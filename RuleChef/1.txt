class RuleSimplifySignBitExtract : public Rule {
public:
  RuleSimplifySignBitExtract(const string &g) : Rule( g, 0, "simplifysignbitextract") {}	///< Constructor
  virtual Rule *clone(const ActionGroupList &grouplist) const {
    if (!grouplist.contains(getGroup())) return (Rule *)0;
    return new RuleSimplifySignBitExtract(getGroup());
  }
  virtual void getOpList(vector<uint4> &oplist) const;
  virtual int4 applyOp(PcodeOp *op,Funcdata &data);
};


/// \class RuleSimplifySignBitExtract
///
/// \brief This rule was automatically generated by RuleChef from the expression:
///
/// INT_RIGHT(x, ((|x| * 8) - 1)) :- {
///     x = INT_OR(y, INT_MULT(y, -1:|y|))
/// } => INT_ZEXT(INT_NOTEQUAL(y, 0:|y|))
///
void RuleSimplifySignBitExtract::getOpList(vector<uint4> &oplist) const
{
  oplist.push_back(CPUI_INT_RIGHT);
}


int4 RuleSimplifySignBitExtract::applyOp(PcodeOp *op, Funcdata &data)

{

  // Remaining checks on the match expression
  Varnode* autovar_y;

  // Checks INT_RIGHT(x, ((|x| * 8) - 1))
  Varnode* autovar_x = op->getIn(0);

  if (! op->getIn(1)->constantMatch(((autovar_x->getSize() * 8) - 1))) return 0;


  // Some more checks for the extra constraints
  if (! autovar_x->isWritten()) return 0;
  PcodeOp* temp_pcode_0 = autovar_x->getDef();
  if (temp_pcode_0->code() != CPUI_INT_OR) return 0;

  // Checks INT_OR(y, INT_MULT(y, -1:|y|))
  auto check_or_0 = [&](Varnode* autovar_left_0, Varnode* autovar_right_0) -> int4 {
    autovar_y = autovar_left_0;

    if (! autovar_right_0->isWritten()) return 0;
    PcodeOp* temp_pcode_1 = autovar_right_0->getDef();
    if (temp_pcode_1->code() != CPUI_INT_MULT) return 0;

    // Checks INT_MULT(y, -1:|y|)
    auto check_mult_0 = [&](Varnode* autovar_left_1, Varnode* autovar_right_1) -> int4 {
      if (autovar_left_1 != autovar_y) return 0;

      uintb masked_const = -1 & ((((uintb) 1) << (8 * autovar_y->getSize())) - 1);
      if (! autovar_right_1->constantMatch(masked_const)) return 0;

      return 1;
    };

    Varnode* autovar_0 = temp_pcode_1->getIn(0);
    Varnode* autovar_1 = temp_pcode_1->getIn(1);
    if ((! check_mult_0(autovar_0, autovar_1)) && (! check_mult_0(autovar_1, autovar_0)))
      return 0;

    return 1;
  };

  Varnode* autovar_2 = temp_pcode_0->getIn(0);
  Varnode* autovar_3 = temp_pcode_0->getIn(1);
  if ((! check_or_0(autovar_2, autovar_3)) && (! check_or_0(autovar_3, autovar_2)))
    return 0;

  // matched this PcodeOp - replace this with the simplified structure
  data.opSetOpcode(op, CPUI_INT_ZEXT);
  data.opRemoveInput(op, 1);
  PcodeOp* out_op_0 = data.newOp(2, op->getAddr());
  data.opSetOpcode(out_op_0, CPUI_INT_NOTEQUAL);
  Varnode* out_varnode_0 = data.newUniqueOut(1, out_op_0);
  data.opInsertBefore(out_op_0, op);
  data.opSetInput(op, out_varnode_0, 0);

  data.opSetInput(out_op_0, autovar_y, 0);
  Varnode* out_const_0 = data.newConstant(autovar_y->getSize(), 0);
  data.opSetInput(out_op_0, out_const_0, 1);

  return 1;
}

