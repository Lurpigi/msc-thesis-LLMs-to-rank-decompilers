class RuleSimplifySimplifyLessAndNotEqual : public Rule {
public:
  RuleSimplifySimplifyLessAndNotEqual(const string &g) : Rule( g, 0, "simplifysimplifylessandnotequal") {}	///< Constructor
  virtual Rule *clone(const ActionGroupList &grouplist) const {
    if (!grouplist.contains(getGroup())) return (Rule *)0;
    return new RuleSimplifySimplifyLessAndNotEqual(getGroup());
  }
  virtual void getOpList(vector<uint4> &oplist) const;
  virtual int4 applyOp(PcodeOp *op,Funcdata &data);
};


/// \class RuleSimplifySimplifyLessAndNotEqual
///
/// \brief This rule was automatically generated by RuleChef from the expression:
///
/// BOOL_AND(INT_LESSEQUAL(a, b), INT_NOTEQUAL(a, b)) => INT_LESS(a, b)
///
void RuleSimplifySimplifyLessAndNotEqual::getOpList(vector<uint4> &oplist) const
{
  oplist.push_back(CPUI_BOOL_AND);
}


int4 RuleSimplifySimplifyLessAndNotEqual::applyOp(PcodeOp *op, Funcdata &data)

{

  // Remaining checks on the match expression
  Varnode* autovar_a;
  Varnode* autovar_b;

  // Checks BOOL_AND(INT_LESSEQUAL(a, b), INT_NOTEQUAL(a, b))
  auto check_and_0 = [&](Varnode* autovar_left_0, Varnode* autovar_right_0) -> int4 {
    if (! autovar_left_0->isWritten()) return 0;
    PcodeOp* temp_pcode_0 = autovar_left_0->getDef();
    if (temp_pcode_0->code() != CPUI_INT_LESSEQUAL) return 0;

    // Checks INT_LESSEQUAL(a, b)
    autovar_a = temp_pcode_0->getIn(0);

    autovar_b = temp_pcode_0->getIn(1);


    if (! autovar_right_0->isWritten()) return 0;
    PcodeOp* temp_pcode_1 = autovar_right_0->getDef();
    if (temp_pcode_1->code() != CPUI_INT_NOTEQUAL) return 0;

    // Checks INT_NOTEQUAL(a, b)
    auto check_notequal_0 = [&](Varnode* autovar_left_1, Varnode* autovar_right_1) -> int4 {
      if (autovar_left_1 != autovar_a) return 0;

      if (autovar_right_1 != autovar_b) return 0;

      return 1;
    };

    Varnode* autovar_0 = temp_pcode_1->getIn(0);
    Varnode* autovar_1 = temp_pcode_1->getIn(1);
    if ((! check_notequal_0(autovar_0, autovar_1)) && (! check_notequal_0(autovar_1, autovar_0)))
      return 0;

    return 1;
  };

  Varnode* autovar_2 = op->getIn(0);
  Varnode* autovar_3 = op->getIn(1);
  if ((! check_and_0(autovar_2, autovar_3)) && (! check_and_0(autovar_3, autovar_2)))
    return 0;

  // matched this PcodeOp - replace this with the simplified structure
  data.opSetOpcode(op, CPUI_INT_LESS);
  data.opSetInput(op, autovar_a, 0);
  data.opSetInput(op, autovar_b, 1);

  return 1;
}

