class RuleSimplifySimplifyConditionalCopy : public Rule {
public:
  RuleSimplifySimplifyConditionalCopy(const string &g) : Rule( g, 0, "simplifysimplifyconditionalcopy") {}	///< Constructor
  virtual Rule *clone(const ActionGroupList &grouplist) const {
    if (!grouplist.contains(getGroup())) return (Rule *)0;
    return new RuleSimplifySimplifyConditionalCopy(getGroup());
  }
  virtual void getOpList(vector<uint4> &oplist) const;
  virtual int4 applyOp(PcodeOp *op,Funcdata &data);
};


/// \class RuleSimplifySimplifyConditionalCopy
///
/// \brief This rule was automatically generated by RuleChef from the expression:
///
/// BOOL_NEGATE(INT_EQUAL(a, b)) => INT_NOTEQUAL(a, b)
///
void RuleSimplifySimplifyConditionalCopy::getOpList(vector<uint4> &oplist) const
{
  oplist.push_back(CPUI_BOOL_NEGATE);
}


int4 RuleSimplifySimplifyConditionalCopy::applyOp(PcodeOp *op, Funcdata &data)

{

  // Remaining checks on the match expression
  Varnode* autovar_a;
  Varnode* autovar_b;

  // Checks BOOL_NEGATE(INT_EQUAL(a, b))
  Varnode* autovar_0 = op->getIn(0);
  if (! autovar_0->isWritten()) return 0;
  PcodeOp* temp_pcode_0 = autovar_0->getDef();
  if (temp_pcode_0->code() != CPUI_INT_EQUAL) return 0;

  // Checks INT_EQUAL(a, b)
  auto check_equal_0 = [&](Varnode* autovar_left_0, Varnode* autovar_right_0) -> int4 {
    autovar_a = autovar_left_0;

    autovar_b = autovar_right_0;

    return 1;
  };

  Varnode* autovar_1 = temp_pcode_0->getIn(0);
  Varnode* autovar_2 = temp_pcode_0->getIn(1);
  if ((! check_equal_0(autovar_1, autovar_2)) && (! check_equal_0(autovar_2, autovar_1)))
    return 0;


  // matched this PcodeOp - replace this with the simplified structure
  data.opSetOpcode(op, CPUI_INT_NOTEQUAL);
  op->insertInput(1);
  data.opSetInput(op, autovar_a, 0);
  data.opSetInput(op, autovar_b, 1);

  return 1;
}

