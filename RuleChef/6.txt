class RuleSimplifyNestedConditionals : public Rule {
public:
  RuleSimplifyNestedConditionals(const string &g) : Rule( g, 0, "simplifynestedconditionals") {}	///< Constructor
  virtual Rule *clone(const ActionGroupList &grouplist) const {
    if (!grouplist.contains(getGroup())) return (Rule *)0;
    return new RuleSimplifyNestedConditionals(getGroup());
  }
  virtual void getOpList(vector<uint4> &oplist) const;
  virtual int4 applyOp(PcodeOp *op,Funcdata &data);
};


/// \class RuleSimplifyNestedConditionals
///
/// \brief This rule was automatically generated by RuleChef from the expression:
///
/// CBRANCH(cond, op_true, op_false) :- {
///     cond = INT_OR(a, b)
///     a = INT_AND(x, y)
///     b = INT_AND(x, z)
/// } => CBRANCH(INT_AND(x, INT_OR(y, z)), op_true, op_false)
///
void RuleSimplifyNestedConditionals::getOpList(vector<uint4> &oplist) const
{
  oplist.push_back(CPUI_CBRANCH);
}


int4 RuleSimplifyNestedConditionals::applyOp(PcodeOp *op, Funcdata &data)

{

  // Remaining checks on the match expression
  Varnode* autovar_x;
  Varnode* autovar_y;
  Varnode* autovar_z;
  Varnode* autovar_op_true;
  Varnode* autovar_op_false;

  // Checks CBRANCH(cond, op_true, op_false)
  Varnode* autovar_cond = op->getIn(0);

  autovar_op_true = op->getIn(1);

  autovar_op_false = op->getIn(2);


  // Some more checks for the extra constraints
  if (! autovar_cond->isWritten()) return 0;
  PcodeOp* temp_pcode_0 = autovar_cond->getDef();
  if (temp_pcode_0->code() != CPUI_INT_OR) return 0;

  // Checks INT_OR(a, b)
  auto check_or_0 = [&](Varnode* autovar_left_0, Varnode* autovar_right_0) -> int4 {
    Varnode* autovar_a = autovar_left_0;

    Varnode* autovar_b = autovar_right_0;

    return 1;
  };

  Varnode* autovar_0 = temp_pcode_0->getIn(0);
  Varnode* autovar_1 = temp_pcode_0->getIn(1);
  if ((! check_or_0(autovar_0, autovar_1)) && (! check_or_0(autovar_1, autovar_0)))
    return 0;
  if (! autovar_a->isWritten()) return 0;
  PcodeOp* temp_pcode_1 = autovar_a->getDef();
  if (temp_pcode_1->code() != CPUI_INT_AND) return 0;

  // Checks INT_AND(x, y)
  auto check_and_0 = [&](Varnode* autovar_left_1, Varnode* autovar_right_1) -> int4 {
    autovar_x = autovar_left_1;

    autovar_y = autovar_right_1;

    return 1;
  };

  Varnode* autovar_2 = temp_pcode_1->getIn(0);
  Varnode* autovar_3 = temp_pcode_1->getIn(1);
  if ((! check_and_0(autovar_2, autovar_3)) && (! check_and_0(autovar_3, autovar_2)))
    return 0;
  if (! autovar_b->isWritten()) return 0;
  PcodeOp* temp_pcode_2 = autovar_b->getDef();
  if (temp_pcode_2->code() != CPUI_INT_AND) return 0;

  // Checks INT_AND(x, z)
  auto check_and_1 = [&](Varnode* autovar_left_2, Varnode* autovar_right_2) -> int4 {
    if (autovar_left_2 != autovar_x) return 0;

    autovar_z = autovar_right_2;

    return 1;
  };

  Varnode* autovar_4 = temp_pcode_2->getIn(0);
  Varnode* autovar_5 = temp_pcode_2->getIn(1);
  if ((! check_and_1(autovar_4, autovar_5)) && (! check_and_1(autovar_5, autovar_4)))
    return 0;

  // matched this PcodeOp - replace this with the simplified structure
  PcodeOp* out_op_0 = data.newOp(2, op->getAddr());
  data.opSetOpcode(out_op_0, CPUI_INT_AND);
  Varnode* out_varnode_0 = data.newUniqueOut(None, out_op_0);
  data.opInsertBefore(out_op_0, op);
  data.opSetInput(op, out_varnode_0, 0);

  data.opSetInput(out_op_0, autovar_x, 0);
  PcodeOp* out_op_1 = data.newOp(2, out_op_0->getAddr());
  data.opSetOpcode(out_op_1, CPUI_INT_OR);
  Varnode* out_varnode_1 = data.newUniqueOut(None, out_op_1);
  data.opInsertBefore(out_op_1, out_op_0);
  data.opSetInput(out_op_0, out_varnode_1, 1);

  data.opSetInput(out_op_1, autovar_y, 0);
  data.opSetInput(out_op_1, autovar_z, 1);
  data.opSetInput(op, autovar_op_true, 1);
  data.opSetInput(op, autovar_op_false, 2);

  return 1;
}

