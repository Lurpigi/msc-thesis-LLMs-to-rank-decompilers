/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_2020();
void sub_2030();
void sub_2040();
void sub_2050();
void sub_2060();
void sub_2070();
void sub_2080();
void sub_2090();
void sub_20A0();
void sub_20B0();
void sub_20C0();
void sub_20D0();
void sub_20E0();
void sub_20F0();
void sub_2100();
void sub_2110();
void sub_2120();
void sub_2130();
void sub_2140();
void sub_2150();
void sub_2160();
void sub_2170();
void sub_2180();
void sub_2190();
void sub_21A0();
void sub_21B0();
void sub_21C0();
void sub_21D0();
void sub_21E0();
void sub_21F0();
void sub_2200();
void sub_2210();
void sub_2220();
void sub_2230();
void sub_2240();
void sub_2250();
void sub_2260();
void sub_2270();
void sub_2280();
void sub_2290();
void sub_22A0();
void sub_22B0();
void sub_22C0();
void sub_22D0();
// int _cxa_finalize(void *);
// void free(void *ptr);
// void __noreturn abort(void);
// int *__errno_location(void);
// int strncmp(const char *s1, const char *s2, size_t n);
// size_t __fpending(FILE *fp);
// int puts(const char *s);
// char *textdomain(const char *domainname);
// int fclose(FILE *stream);
// struct passwd *getpwuid(__uid_t uid);
// char *bindtextdomain(const char *domainname, const char *dirname);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// size_t __ctype_get_mb_cur_max(void);
// size_t strlen(const char *s);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// char *strrchr(const char *s, int c);
// __off_t lseek(int fd, __off_t offset, int whence);
// void *memset(void *s, int c, size_t n);
// __uid_t geteuid(void);
// int memcmp(const void *s1, const void *s2, size_t n);
// int fputs_unlocked(const char *s, FILE *stream);
// int strcmp(const char *s1, const char *s2);
// int fputc_unlocked(int c, FILE *stream);
// __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int fileno(FILE *stream);
// void *malloc(size_t size);
// int fflush(FILE *stream);
// char *nl_langinfo(nl_item item);
// int __freading(FILE *fp);
// void *realloc(void *ptr, size_t size);
// char *setlocale(int category, const char *locale);
// __int64 __fastcall __printf_chk(_QWORD, _QWORD, _QWORD); weak
// void error(int status, int errnum, const char *format, ...);
// int fseeko(FILE *stream, __off_t off, int whence);
// void __noreturn exit(int status);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int mbsinit(const mbstate_t *ps);
// int iswprint(wint_t wc);
// const unsigned __int16 **__ctype_b_loc(void);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)());
void *sub_27E0();
__int64 sub_2810();
void *sub_2850();
__int64 sub_2890();
__int64 __fastcall sub_28A0(__int64 a1, __int64 a2, char a3, char a4);
void __fastcall __noreturn sub_2990(int status); // idb
void __noreturn sub_2CD0();
const char *__fastcall sub_2D10(_BYTE *a1, int a2);
int __fastcall sub_2E00(FILE *stream);
unsigned __int64 __fastcall sub_2F60(int a1, char *const *a2, __m128 a3, __m128 a4, __m128 a5, __m128 a6, __m128 a7, __m128 a8, __m128 a9, __m128 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, int a15, char a16);
__int64 sub_3570();
unsigned __int64 __fastcall sub_3640(_BYTE *a1, unsigned __int64 a2, __int64 a3, int a4, int a5, __int64 a6, char *a7, const char *a8);
_BYTE *__fastcall sub_4AE0(__int64 a1, __int64 a2);
__int64 __fastcall sub_4C80(); // weak
int __fastcall sub_4D00(void (*a1)(void *));
void term_proc();
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// int _cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
// int __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
_UNKNOWN unk_50D6; // weak
_UNKNOWN unk_50DA; // weak
_UNKNOWN unk_50DD; // weak
_UNKNOWN unk_50E1; // weak
_UNKNOWN unk_50E5; // weak
struct option longopts = { "help", 0, &dword_0, 104 }; // idb
void *lpdso_handle = &lpdso_handle; // idb
int dword_8020 = 1; // weak
int status = 1; // idb
_UNKNOWN unk_8040; // weak
_UNKNOWN unk_8080; // weak
void *ptr = &unk_8080; // idb
_UNKNOWN unk_8098; // weak
char byte_80A0; // weak
_UNKNOWN unk_80C0; // weak
__int64 qword_81C0; // weak
// extern struct _IO_FILE *stdout;
// extern int optind;
// extern char *program_invocation_name;
// extern char *program_invocation_short_name;
// extern int opterr;
// extern struct _IO_FILE *stderr;


//----- (0000000000002000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 8378: using guessed type __int64 _gmon_start__(void);

//----- (0000000000002020) ----------------------------------------------------
void sub_2020()
{
  JUMPOUT(0);
}
// 2026: control flows out of bounds to 0

//----- (0000000000002030) ----------------------------------------------------
void sub_2030()
{
  sub_2020();
}

//----- (0000000000002040) ----------------------------------------------------
void sub_2040()
{
  sub_2020();
}

//----- (0000000000002050) ----------------------------------------------------
void sub_2050()
{
  sub_2020();
}

//----- (0000000000002060) ----------------------------------------------------
void sub_2060()
{
  sub_2020();
}

//----- (0000000000002070) ----------------------------------------------------
void sub_2070()
{
  sub_2020();
}

//----- (0000000000002080) ----------------------------------------------------
void sub_2080()
{
  sub_2020();
}

//----- (0000000000002090) ----------------------------------------------------
void sub_2090()
{
  sub_2020();
}

//----- (00000000000020A0) ----------------------------------------------------
void sub_20A0()
{
  sub_2020();
}

//----- (00000000000020B0) ----------------------------------------------------
void sub_20B0()
{
  sub_2020();
}

//----- (00000000000020C0) ----------------------------------------------------
void sub_20C0()
{
  sub_2020();
}

//----- (00000000000020D0) ----------------------------------------------------
void sub_20D0()
{
  sub_2020();
}

//----- (00000000000020E0) ----------------------------------------------------
void sub_20E0()
{
  sub_2020();
}

//----- (00000000000020F0) ----------------------------------------------------
void sub_20F0()
{
  sub_2020();
}

//----- (0000000000002100) ----------------------------------------------------
void sub_2100()
{
  sub_2020();
}

//----- (0000000000002110) ----------------------------------------------------
void sub_2110()
{
  sub_2020();
}

//----- (0000000000002120) ----------------------------------------------------
void sub_2120()
{
  sub_2020();
}

//----- (0000000000002130) ----------------------------------------------------
void sub_2130()
{
  sub_2020();
}

//----- (0000000000002140) ----------------------------------------------------
void sub_2140()
{
  sub_2020();
}

//----- (0000000000002150) ----------------------------------------------------
void sub_2150()
{
  sub_2020();
}

//----- (0000000000002160) ----------------------------------------------------
void sub_2160()
{
  sub_2020();
}

//----- (0000000000002170) ----------------------------------------------------
void sub_2170()
{
  sub_2020();
}

//----- (0000000000002180) ----------------------------------------------------
void sub_2180()
{
  sub_2020();
}

//----- (0000000000002190) ----------------------------------------------------
void sub_2190()
{
  sub_2020();
}

//----- (00000000000021A0) ----------------------------------------------------
void sub_21A0()
{
  sub_2020();
}

//----- (00000000000021B0) ----------------------------------------------------
void sub_21B0()
{
  sub_2020();
}

//----- (00000000000021C0) ----------------------------------------------------
void sub_21C0()
{
  sub_2020();
}

//----- (00000000000021D0) ----------------------------------------------------
void sub_21D0()
{
  sub_2020();
}

//----- (00000000000021E0) ----------------------------------------------------
void sub_21E0()
{
  sub_2020();
}

//----- (00000000000021F0) ----------------------------------------------------
void sub_21F0()
{
  sub_2020();
}

//----- (0000000000002200) ----------------------------------------------------
void sub_2200()
{
  sub_2020();
}

//----- (0000000000002210) ----------------------------------------------------
void sub_2210()
{
  sub_2020();
}

//----- (0000000000002220) ----------------------------------------------------
void sub_2220()
{
  sub_2020();
}

//----- (0000000000002230) ----------------------------------------------------
void sub_2230()
{
  sub_2020();
}

//----- (0000000000002240) ----------------------------------------------------
void sub_2240()
{
  sub_2020();
}

//----- (0000000000002250) ----------------------------------------------------
void sub_2250()
{
  sub_2020();
}

//----- (0000000000002260) ----------------------------------------------------
void sub_2260()
{
  sub_2020();
}

//----- (0000000000002270) ----------------------------------------------------
void sub_2270()
{
  sub_2020();
}

//----- (0000000000002280) ----------------------------------------------------
void sub_2280()
{
  sub_2020();
}

//----- (0000000000002290) ----------------------------------------------------
void sub_2290()
{
  sub_2020();
}

//----- (00000000000022A0) ----------------------------------------------------
void sub_22A0()
{
  sub_2020();
}

//----- (00000000000022B0) ----------------------------------------------------
void sub_22B0()
{
  sub_2020();
}

//----- (00000000000022C0) ----------------------------------------------------
void sub_22C0()
{
  sub_2020();
}

//----- (00000000000022D0) ----------------------------------------------------
void sub_22D0()
{
  sub_2020();
}

//----- (00000000000025B0) ----------------------------------------------------
__int64 __fastcall main(
        int a1,
        const char **a2,
        char **a3,
        __m128 a4,
        __m128 a5,
        __m128 a6,
        __m128 a7,
        double a8,
        double a9,
        __m128 a10,
        __m128 a11)
{
  char *v11; // rbx
  char *v12; // rax
  char *v13; // rbp
  const char *v14; // r14
  __m128 v15; // xmm4
  __m128 v16; // xmm5
  int *v17; // rax
  int *v18; // rbp
  __uid_t v19; // eax
  __uid_t v20; // ebx
  struct passwd *v21; // rax
  char *v23; // rax
  _BYTE *v24; // r12
  char *v25; // rax

  v11 = (char *)*a2;
  if ( !*a2 )
  {
LABEL_13:
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  v12 = strrchr(*a2, 47);
  v13 = v12;
  if ( v12 )
  {
    v14 = v12 + 1;
    if ( v12 + 1 - v11 > 6 && !strncmp(v12 - 6, "/.libs/", 7u) )
    {
      v11 = (char *)v14;
      if ( !strncmp(v14, "lt-", 3u) )
      {
        v11 = v13 + 4;
        program_invocation_short_name = v13 + 4;
      }
    }
  }
  qword_81C0 = (__int64)v11;
  program_invocation_name = v11;
  setlocale(6, "");
  bindtextdomain("coreutils", "/usr/share/locale");
  textdomain("coreutils");
  sub_4D00((void (*)(void *))sub_4C80);
  sub_2F60(
    a1,
    (char *const *)a2,
    a4,
    a5,
    a6,
    a7,
    v15,
    v16,
    a10,
    a11,
    (__int64)"whoami",
    (__int64)"GNU coreutils",
    (__int64)"8.32",
    1,
    (int)sub_2990,
    (char)"Richard Mlynarik");
  if ( optind != a1 )
  {
    v24 = sub_4AE0((__int64)a2[optind], (__int64)&unk_8040);
    v25 = dcgettext(0, "extra operand %s", 5);
    error(0, 0, v25, v24);
    sub_2990(1);
  }
  v17 = __errno_location();
  *v17 = 0;
  v18 = v17;
  v19 = geteuid();
  v20 = v19;
  if ( v19 == -1 && *v18 || (v21 = getpwuid(v19)) == 0 )
  {
    v23 = dcgettext(0, "cannot find name for user ID %lu", 5);
    error(1, *v18, v23, v20);
    goto LABEL_13;
  }
  puts(v21->pw_name);
  return 0;
}
// 26B5: variable 'v15' is possibly undefined
// 26B5: variable 'v16' is possibly undefined
// 4C80: using guessed type __int64 __fastcall sub_4C80();
// 81C0: using guessed type __int64 qword_81C0;

//----- (00000000000027B0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)())
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (*)(int, char **, char **))main, v4, &retaddr, 0, 0, a3, &v5);
  __halt();
}
// 27BA: positive sp value 8 has been found
// 27C1: variable 'v3' is possibly undefined

//----- (00000000000027E0) ----------------------------------------------------
void *sub_27E0()
{
  return &unk_8098;
}

//----- (0000000000002810) ----------------------------------------------------
__int64 sub_2810()
{
  return 0;
}

//----- (0000000000002850) ----------------------------------------------------
void *sub_2850()
{
  void *result; // rax

  if ( !byte_80A0 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(lpdso_handle);
    result = sub_27E0();
    byte_80A0 = 1;
  }
  return result;
}
// 80A0: using guessed type char byte_80A0;

//----- (0000000000002890) ----------------------------------------------------
// attributes: thunk
__int64 sub_2890()
{
  return sub_2810();
}

//----- (00000000000028A0) ----------------------------------------------------
__int64 __fastcall sub_28A0(__int64 a1, __int64 a2, char a3, char a4)
{
  char v6; // r8
  unsigned int v7; // r8d
  char v9; // si
  __int64 v10; // rcx
  int v11; // r9d
  char v12; // dl
  int v13; // r8d
  char v14; // si

  v6 = *(_BYTE *)(a1 + 7);
  if ( (unsigned int)(a3 - 65) <= 0x19 )
    v6 &= ~0x20u;
  if ( v6 == a3 )
  {
    v7 = 1;
    if ( !a3 )
      return v7;
    v9 = *(_BYTE *)(a1 + 8);
    if ( (unsigned int)(a4 - 65) <= 0x19 )
      v9 &= ~0x20u;
    if ( v9 == a4 )
    {
      v7 = 1;
      if ( a4 && a1 != a2 )
      {
        v10 = 9;
        do
        {
          v11 = *(unsigned __int8 *)(a1 + v10);
          v12 = *(_BYTE *)(a1 + v10);
          if ( (unsigned int)(v11 - 65) <= 0x19 )
          {
            v11 += 32;
            v12 += 32;
          }
          v13 = *(unsigned __int8 *)(a2 + v10);
          v14 = *(_BYTE *)(a2 + v10);
          if ( (unsigned int)(v13 - 65) <= 0x19 )
          {
            v13 += 32;
            v14 += 32;
          }
          if ( !v12 )
            break;
          ++v10;
        }
        while ( v12 == v14 );
        return v11 == v13;
      }
      return v7;
    }
  }
  return 0;
}

//----- (0000000000002990) ----------------------------------------------------
void __fastcall __noreturn sub_2990(int status)
{
  __int64 v2; // r12
  char *v3; // rax
  _QWORD *v4; // rbx
  char *v5; // rax
  FILE *v6; // r12
  char *v7; // rax
  FILE *v8; // r12
  char *v9; // rax
  FILE *v10; // r12
  char *v11; // rax
  const char *v12; // rsi
  const char *v13; // r14
  char *v14; // rax
  char *v15; // rdi
  char *v16; // rax
  char *v17; // rax
  char *v18; // rax
  char *v19; // rdi
  char *v20; // rax
  FILE *v21; // r13
  char *v22; // rax
  _QWORD v23[23]; // [rsp+0h] [rbp-B8h] BYREF

  v2 = qword_81C0;
  v23[15] = __readfsqword(0x28u);
  if ( status )
  {
    v3 = dcgettext(0, "Try '%s --help' for more information.\n", 5);
    __fprintf_chk(stderr, 1, v3, v2);
    goto LABEL_3;
  }
  v4 = v23;
  v5 = dcgettext(0, "Usage: %s [OPTION]...\n", 5);
  __printf_chk(1, v5, v2);
  v6 = stdout;
  v7 = dcgettext(0, "Print the user name associated with the current effective user ID.\nSame as id -un.\n\n", 5);
  fputs_unlocked(v7, v6);
  v8 = stdout;
  v9 = dcgettext(0, "      --help     display this help and exit\n", 5);
  fputs_unlocked(v9, v8);
  v10 = stdout;
  v11 = dcgettext(0, "      --version  output version information and exit\n", 5);
  fputs_unlocked(v11, v10);
  v23[12] = 0;
  v23[0] = "[";
  v23[1] = "test invocation";
  v23[2] = "coreutils";
  v23[3] = "Multi-call invocation";
  v23[6] = "sha256sum";
  v23[4] = "sha224sum";
  v23[8] = "sha384sum";
  v23[5] = "sha2 utilities";
  v23[7] = "sha2 utilities";
  v23[9] = "sha2 utilities";
  v23[10] = "sha512sum";
  v23[11] = "sha2 utilities";
  v23[13] = 0;
  do
  {
    v12 = (const char *)v4[2];
    v4 += 2;
  }
  while ( v12 && strcmp("whoami", v12) );
  v13 = (const char *)v4[1];
  if ( v13 )
  {
    v14 = dcgettext(0, "\n%s online help: <%s>\n", 5);
    __printf_chk(1, v14, "GNU coreutils");
    v15 = setlocale(5, 0);
    if ( !v15 || !strncmp(v15, "en_", 3u) )
      goto LABEL_10;
  }
  else
  {
    v18 = dcgettext(0, "\n%s online help: <%s>\n", 5);
    __printf_chk(1, v18, "GNU coreutils");
    v19 = setlocale(5, 0);
    if ( !v19 || !strncmp(v19, "en_", 3u) )
    {
      v20 = dcgettext(0, "Full documentation <%s%s>\n", 5);
      v13 = "whoami";
      __printf_chk(1, v20, "https://www.gnu.org/software/coreutils/");
      goto LABEL_11;
    }
    v13 = "whoami";
  }
  v21 = stdout;
  v22 = dcgettext(0, "Report any translation bugs to <https://translationproject.org/team/>\n", 5);
  fputs_unlocked(v22, v21);
LABEL_10:
  v16 = dcgettext(0, "Full documentation <%s%s>\n", 5);
  __printf_chk(1, v16, "https://www.gnu.org/software/coreutils/");
LABEL_11:
  v17 = dcgettext(0, "or available locally via: info '(coreutils) %s%s'\n", 5);
  __printf_chk(1, v17, v13);
LABEL_3:
  exit(status);
}
// 2500: using guessed type __int64 __fastcall __printf_chk(_QWORD, _QWORD, _QWORD);
// 2560: using guessed type __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 81C0: using guessed type __int64 qword_81C0;

//----- (0000000000002CD0) ----------------------------------------------------
void __noreturn sub_2CD0()
{
  char *v0; // rax

  v0 = dcgettext(0, "memory exhausted", 5);
  error(status, 0, "%s", v0);
  abort();
}

//----- (0000000000002D10) ----------------------------------------------------
const char *__fastcall sub_2D10(_BYTE *a1, int a2)
{
  char *v3; // rax
  char *v4; // rdi
  char v5; // al
  char v6; // al
  const char *result; // rax

  v3 = nl_langinfo(14);
  if ( !v3 )
    goto LABEL_14;
  v4 = v3;
  v5 = *v3;
  if ( !v5 )
    goto LABEL_14;
  v6 = v5 & 0xDF;
  if ( v6 == 85 )
  {
    if ( (v4[1] & 0xDF) == 0x54 && (v4[2] & 0xDF) == 0x46 && v4[3] == 45 && v4[4] == 56 && !v4[5] )
    {
      result = (const char *)&unk_50E5;
      if ( *a1 != 96 )
        return (const char *)&unk_50D6;
      return result;
    }
    goto LABEL_14;
  }
  if ( v6 != 71
    || (v4[1] & 0xDF) != 0x42
    || v4[2] != 49
    || v4[3] != 56
    || v4[4] != 48
    || v4[5] != 51
    || v4[6] != 48
    || !(unsigned int)sub_28A0((__int64)v4, (__int64)"GB18030", 0, 0) )
  {
LABEL_14:
    result = (const char *)&unk_50DD;
    if ( a2 != 9 )
      return "'";
    return result;
  }
  result = (const char *)&unk_50E1;
  if ( *a1 != 96 )
    return (const char *)&unk_50DA;
  return result;
}

//----- (0000000000002E00) ----------------------------------------------------
int __fastcall sub_2E00(FILE *stream)
{
  size_t v1; // r12
  int v2; // ebx
  int *v3; // rax
  int v4; // r14d
  int *v5; // r13
  int result; // eax
  int v7; // eax
  int v8; // eax
  __off_t v9; // rax

  v1 = __fpending(stream);
  v2 = stream->_flags & 0x20;
  if ( fileno(stream) < 0 )
    goto LABEL_10;
  if ( __freading(stream) )
  {
    v7 = fileno(stream);
    if ( lseek(v7, 0, 1) == -1 )
      goto LABEL_10;
  }
  if ( __freading(stream) && (stream->_flags & 0x100) != 0 )
  {
    if ( stream->_IO_read_end == stream->_IO_read_ptr
      && stream->_IO_write_ptr == stream->_IO_write_base
      && !stream->_IO_save_base )
    {
      v8 = fileno(stream);
      v9 = lseek(v8, 0, 1);
      if ( v9 != -1 )
      {
        stream->_flags &= ~0x10u;
        stream->_offset = v9;
      }
    }
    else
    {
      fseeko(stream, 0, 1);
    }
  }
  if ( !fflush(stream) )
  {
LABEL_10:
    result = fclose(stream);
  }
  else
  {
    v3 = __errno_location();
    v4 = *v3;
    v5 = v3;
    result = fclose(stream);
    if ( v4 )
    {
      *v5 = v4;
      if ( v2 )
        return -1;
      goto LABEL_13;
    }
  }
  if ( v2 )
  {
    if ( !result )
      *__errno_location() = 0;
    return -1;
  }
  if ( result )
  {
LABEL_13:
    if ( !v1 )
      return -(*__errno_location() != 9);
    return -1;
  }
  return result;
}

//----- (0000000000002F60) ----------------------------------------------------
unsigned __int64 __fastcall sub_2F60(
        int a1,
        char *const *a2,
        __m128 a3,
        __m128 a4,
        __m128 a5,
        __m128 a6,
        __m128 a7,
        __m128 a8,
        __m128 a9,
        __m128 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        int a15,
        char a16)
{
  int v16; // r12d
  int v17; // eax
  __int64 v18; // rbx
  char *v19; // rcx
  FILE *v20; // r12
  __int64 v21; // rax
  char *v22; // rax
  char *v24; // rax
  char *v25; // rax
  __int64 v26; // r13
  char *v27; // rdx
  __int64 v28; // r13
  char *v29; // rax
  __int64 v30; // r13
  char *v31; // rax
  __int64 v32; // r13
  char *v33; // rax
  const char *v34; // rsi
  char *v35; // rax
  char *v36; // rax
  __int64 v37; // [rsp+40h] [rbp-148h]
  unsigned __int64 v38; // [rsp+98h] [rbp-F0h]
  __m128 v39; // [rsp+D0h] [rbp-B8h]
  __m128 v40; // [rsp+E0h] [rbp-A8h]
  __m128 v41; // [rsp+F0h] [rbp-98h]
  __m128 v42; // [rsp+100h] [rbp-88h]
  __m128 v43; // [rsp+110h] [rbp-78h]
  __m128 v44; // [rsp+120h] [rbp-68h]
  __m128 v45; // [rsp+130h] [rbp-58h]
  __m128 v46; // [rsp+140h] [rbp-48h]

  v39 = a3;
  v40 = a4;
  v41 = a5;
  v42 = a6;
  v43 = a7;
  v44 = a8;
  v45 = a9;
  v46 = a10;
  v38 = __readfsqword(0x28u);
  v16 = opterr;
  opterr = 1;
  v17 = getopt_long(a1, a2, "", &longopts, 0);
  if ( v17 != -1 )
  {
    if ( v17 != 104 )
    {
      if ( v17 == 118 )
      {
        v18 = 0;
        v19 = &a16;
        v20 = stdout;
        while ( 1 )
        {
          v22 = v19;
          v19 += 8;
          v21 = *(_QWORD *)v22;
          *(&v37 + v18) = v21;
          if ( !v21 )
            break;
          if ( ++v18 == 10 )
          {
            __fprintf_chk(v20, 1, "%s (%s) %s\n", "whoami");
            v35 = dcgettext(0, "(C)", 5);
            __fprintf_chk(v20, 1, "Copyright %s %d Free Software Foundation, Inc.", v35);
            fputc_unlocked(10, v20);
            v36 = dcgettext(
                    0,
                    "License GPLv3+: GNU GPL version 3 or later <%s>.\n"
                    "This is free software: you are free to change and redistribute it.\n"
                    "There is NO WARRANTY, to the extent permitted by law.\n",
                    5);
            __fprintf_chk(v20, 1, v36, "https://gnu.org/licenses/gpl.html");
            fputc_unlocked(10, v20);
            v34 = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n";
            v26 = v37;
LABEL_25:
            v27 = dcgettext(0, v34, 5);
LABEL_13:
            __fprintf_chk(v20, 1, v27, v26);
LABEL_14:
            exit(0);
          }
        }
        __fprintf_chk(v20, 1, "%s (%s) %s\n", "whoami");
        v24 = dcgettext(0, "(C)", 5);
        __fprintf_chk(v20, 1, "Copyright %s %d Free Software Foundation, Inc.", v24);
        fputc_unlocked(10, v20);
        v25 = dcgettext(
                0,
                "License GPLv3+: GNU GPL version 3 or later <%s>.\n"
                "This is free software: you are free to change and redistribute it.\n"
                "There is NO WARRANTY, to the extent permitted by law.\n",
                5);
        __fprintf_chk(v20, 1, v25, "https://gnu.org/licenses/gpl.html");
        fputc_unlocked(10, v20);
        switch ( v18 )
        {
          case 1LL:
            v32 = v37;
            v33 = dcgettext(0, "Written by %s.\n", 5);
            __fprintf_chk(v20, 1, v33, v32);
            goto LABEL_14;
          case 2LL:
            v30 = v37;
            v31 = dcgettext(0, "Written by %s and %s.\n", 5);
            __fprintf_chk(v20, 1, v31, v30);
            goto LABEL_14;
          case 3LL:
            v28 = v37;
            v29 = dcgettext(0, "Written by %s, %s, and %s.\n", 5);
            __fprintf_chk(v20, 1, v29, v28);
            goto LABEL_14;
          case 4LL:
            v26 = v37;
            v27 = dcgettext(0, "Written by %s, %s, %s,\nand %s.\n", 5);
            goto LABEL_13;
          case 5LL:
            v26 = v37;
            v27 = dcgettext(0, "Written by %s, %s, %s,\n%s, and %s.\n", 5);
            goto LABEL_13;
          case 6LL:
            v26 = v37;
            v27 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, and %s.\n", 5);
            goto LABEL_13;
          case 7LL:
            v26 = v37;
            v27 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n", 5);
            goto LABEL_13;
          case 8LL:
            v26 = v37;
            v27 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n", 5);
            goto LABEL_13;
          case 9LL:
            v34 = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n";
            v26 = v37;
            goto LABEL_25;
          default:
            goto LABEL_14;
        }
      }
      sub_2990(status);
    }
    sub_2990(0);
  }
  opterr = v16;
  return v38 - __readfsqword(0x28u);
}
// 308B: conditional instruction was optimized away because edx.4==30
// 30DC: conditional instruction was optimized away because di.1==1
// 30E6: conditional instruction was optimized away because r8.1==0
// 2560: using guessed type __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000003570) ----------------------------------------------------
__int64 sub_3570()
{
  char *v0; // rax
  char *v1; // rbp
  unsigned int v2; // r12d
  size_t v3; // rax
  const char *v5; // rdi
  _BYTE v6[264]; // [rsp+0h] [rbp-128h] BYREF
  unsigned __int64 v7; // [rsp+108h] [rbp-20h]

  v7 = __readfsqword(0x28u);
  v0 = setlocale(0, 0);
  if ( v0 )
  {
    v1 = v0;
    v2 = 0;
    v3 = strlen(v0);
    if ( v3 <= 0x100 )
    {
      v5 = (const char *)__memcpy_chk(v6, v1, v3 + 1, 257);
      if ( v6[0] != 67 || v6[1] )
        LOBYTE(v2) = strcmp(v5, "POSIX") != 0;
    }
  }
  else
  {
    return 0;
  }
  return v2;
}
// 2480: using guessed type __int64 __fastcall __memcpy_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000003640) ----------------------------------------------------
unsigned __int64 __fastcall sub_3640(
        _BYTE *a1,
        unsigned __int64 a2,
        __int64 a3,
        int a4,
        int a5,
        __int64 a6,
        char *a7,
        const char *a8)
{
  __int64 v9; // r14
  _BYTE *v10; // r13
  size_t mb_cur_max; // rax
  int v13; // r11d
  char *v14; // rax
  int v15; // r11d
  char *v16; // rax
  unsigned __int64 v17; // r15
  char v18; // bp
  size_t v19; // rax
  int v20; // esi
  unsigned __int64 v21; // r10
  unsigned __int64 v22; // r12
  _BYTE *v23; // r14
  int v24; // r13d
  int v25; // r11d
  unsigned __int64 v26; // r9
  bool v27; // bp
  _BYTE *v28; // rbx
  bool v29; // r8
  unsigned __int64 v30; // rdx
  size_t v31; // rax
  int v32; // eax
  char v33; // bl
  bool v34; // cl
  int v35; // eax
  unsigned __int8 v36; // cl
  bool v37; // dl
  bool v38; // al
  int v39; // eax
  char v40; // al
  unsigned __int64 v41; // rdx
  bool v42; // al
  const unsigned __int16 **v43; // rax
  unsigned __int64 v44; // rdi
  char v45; // dl
  char v46; // al
  char v47; // al
  bool v48; // al
  bool v49; // al
  bool v50; // dl
  unsigned __int64 v51; // rsi
  bool v52; // al
  __int64 v53; // rax
  size_t v54; // rax
  unsigned __int64 v55; // rbx
  unsigned __int64 v56; // r15
  const char *v57; // r13
  size_t v58; // rax
  unsigned __int64 v59; // r12
  wint_t v60; // edi
  bool v61; // zf
  bool v62; // al
  char v63; // si
  unsigned __int64 v64; // rcx
  bool v65; // si
  int v66; // eax
  __int64 v67; // rax
  __int64 v68; // rax
  bool v69; // dl
  _BYTE *v70; // rdx
  __int64 v71; // rdi
  char i; // al
  unsigned __int64 v73; // rax
  unsigned __int64 v74; // rdx
  char v75; // cl
  unsigned __int64 v76; // rdx
  const char *v78; // rax
  char *v79; // rax
  size_t n; // [rsp+18h] [rbp-E0h]
  int v83; // [rsp+20h] [rbp-D8h]
  int v84; // [rsp+20h] [rbp-D8h]
  int v85; // [rsp+20h] [rbp-D8h]
  char v86; // [rsp+20h] [rbp-D8h]
  char v87; // [rsp+25h] [rbp-D3h]
  bool v88; // [rsp+26h] [rbp-D2h]
  bool v89; // [rsp+27h] [rbp-D1h]
  bool v90; // [rsp+27h] [rbp-D1h]
  bool v91; // [rsp+27h] [rbp-D1h]
  bool v92; // [rsp+27h] [rbp-D1h]
  unsigned __int64 v93; // [rsp+28h] [rbp-D0h]
  unsigned __int64 v94; // [rsp+28h] [rbp-D0h]
  unsigned __int64 v95; // [rsp+28h] [rbp-D0h]
  unsigned __int64 v96; // [rsp+28h] [rbp-D0h]
  unsigned __int64 v97; // [rsp+28h] [rbp-D0h]
  unsigned __int64 v98; // [rsp+30h] [rbp-C8h]
  unsigned __int8 v99; // [rsp+30h] [rbp-C8h]
  unsigned __int8 v100; // [rsp+30h] [rbp-C8h]
  char v101; // [rsp+30h] [rbp-C8h]
  unsigned __int64 v102; // [rsp+30h] [rbp-C8h]
  unsigned __int8 pwc; // [rsp+38h] [rbp-C0h]
  wchar_t *pwca; // [rsp+38h] [rbp-C0h]
  wchar_t *pwcb; // [rsp+38h] [rbp-C0h]
  wchar_t *pwcc; // [rsp+38h] [rbp-C0h]
  unsigned __int64 v107; // [rsp+40h] [rbp-B8h]
  int v108; // [rsp+40h] [rbp-B8h]
  const char *s2; // [rsp+48h] [rbp-B0h]
  unsigned __int64 v110; // [rsp+50h] [rbp-A8h]
  size_t v111; // [rsp+58h] [rbp-A0h]
  _BYTE *v112; // [rsp+68h] [rbp-90h]
  unsigned __int64 v113; // [rsp+70h] [rbp-88h]
  bool v115; // [rsp+7Ch] [rbp-7Ch]
  bool v116; // [rsp+7Dh] [rbp-7Bh]
  char v117; // [rsp+7Eh] [rbp-7Ah]
  unsigned __int8 v118; // [rsp+7Fh] [rbp-79h]
  unsigned __int64 v119; // [rsp+80h] [rbp-78h]
  wint_t wc; // [rsp+ACh] [rbp-4Ch] BYREF
  mbstate_t v124[9]; // [rsp+B0h] [rbp-48h] BYREF

  v9 = -1;
  v10 = a1;
  v124[1] = (mbstate_t)__readfsqword(0x28u);
LABEL_2:
  v83 = a4;
  mb_cur_max = __ctype_get_mb_cur_max();
  v13 = v83;
  v111 = mb_cur_max;
  switch ( v83 )
  {
    case 0:
      v88 = 0;
      v18 = 0;
      v17 = 0;
      n = 0;
      s2 = 0;
      goto LABEL_10;
    case 1:
      goto LABEL_72;
    case 2:
      if ( (a5 & 2) == 0 )
      {
        v18 = 0;
        goto LABEL_91;
      }
      v88 = 1;
      v18 = 0;
      v17 = 0;
      n = 1;
      s2 = "'";
LABEL_10:
      v86 = 1;
      v20 = 0;
      v115 = 0;
      v110 = 0;
      break;
    case 3:
      v88 = 1;
      v18 = 1;
      goto LABEL_69;
    case 4:
      if ( (a5 & 2) == 0 )
        goto LABEL_90;
LABEL_72:
      v88 = 1;
      v18 = 0;
LABEL_69:
      v17 = 0;
      v13 = 2;
      n = 1;
      s2 = "'";
      goto LABEL_10;
    case 5:
      if ( (a5 & 2) == 0 )
        goto LABEL_66;
      v88 = 1;
      v18 = 1;
      v17 = 0;
      n = 1;
      s2 = (const char *)&unk_50DD;
      goto LABEL_10;
    case 6:
      v88 = 1;
      v18 = 1;
      v17 = 0;
      n = 1;
      v13 = 5;
      s2 = (const char *)&unk_50DD;
      goto LABEL_10;
    case 7:
      v88 = 0;
      v18 = 1;
      v17 = 0;
      n = 0;
      s2 = 0;
      goto LABEL_10;
    case 8:
    case 9:
    case 10:
      if ( v83 != 10 )
      {
        v14 = dcgettext(0, "`", 5);
        v15 = v83;
        a7 = v14;
        if ( v14 == "`" )
        {
          v79 = (char *)sub_2D10(v14, v83);
          v15 = v83;
          a7 = v79;
        }
        v84 = v15;
        v16 = dcgettext(0, "'", 5);
        v13 = v84;
        a8 = v16;
        if ( v16 == "'" )
        {
          v78 = sub_2D10(v16, v84);
          v13 = v84;
          a8 = v78;
        }
      }
      v17 = 0;
      if ( (a5 & 2) == 0 )
      {
        for ( i = *a7; i; i = a7[v17] )
        {
          if ( a2 > v17 )
            v10[v17] = i;
          ++v17;
        }
      }
      v85 = v13;
      v18 = 1;
      v88 = (a5 & 2) != 0;
      v19 = strlen(a8);
      s2 = a8;
      v13 = v85;
      n = v19;
      goto LABEL_10;
    default:
      abort();
  }
LABEL_11:
  while ( 1 )
  {
    v87 = v18;
    v21 = a2;
    v22 = v9;
    v23 = v10;
    v24 = v13;
    v25 = v20;
LABEL_12:
    v26 = 0;
    while ( 1 )
    {
      v27 = v26 != v22;
      if ( v22 == -1 )
        v27 = *(_BYTE *)(a3 + v26) != 0;
      if ( !v27 )
        break;
      v28 = (_BYTE *)(a3 + v26);
      v29 = v87 & (v24 != 2);
      if ( v29 )
      {
        if ( n )
        {
          v30 = n + v26;
          if ( v22 == -1 && n > 1 )
          {
            v107 = v21;
            pwc = v25;
            v98 = v26;
            v93 = n + v26;
            v31 = strlen((const char *)a3);
            v21 = v107;
            v25 = pwc;
            v26 = v98;
            v30 = v93;
            v22 = v31;
            v29 = v87 & (v24 != 2);
          }
          if ( v30 <= v22 )
          {
            pwca = (wchar_t *)v21;
            v99 = v25;
            v94 = v26;
            v89 = v29;
            v32 = memcmp(v28, s2, n);
            v29 = v89;
            v26 = v94;
            v25 = v99;
            v21 = (unsigned __int64)pwca;
            if ( !v32 )
            {
              if ( v88 )
                goto LABEL_326;
              v33 = *v28;
              if ( v33 <= 63 )
              {
                if ( v33 >= 0 )
                {
                  switch ( v33 )
                  {
                    case 0:
                      goto LABEL_102;
                    case 7:
                      goto LABEL_99;
                    case 8:
                      goto LABEL_96;
                    case 9:
                      goto LABEL_115;
                    case 10:
                      goto LABEL_98;
                    case 11:
                      goto LABEL_119;
                    case 12:
                      goto LABEL_93;
                    case 13:
                      goto LABEL_85;
                    case 32:
                      v34 = v89;
                      goto LABEL_121;
                    case 33:
                    case 34:
                    case 36:
                    case 38:
                    case 40:
                    case 41:
                    case 42:
                    case 59:
                    case 60:
                    case 61:
                    case 62:
                      goto LABEL_49;
                    case 35:
                      goto LABEL_111;
                    case 37:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 58:
                      v34 = v89;
                      goto LABEL_28;
                    case 39:
                      goto LABEL_83;
                    case 63:
                      goto LABEL_76;
                    default:
                      goto LABEL_56;
                  }
                }
                goto LABEL_56;
              }
              if ( v33 > 122 )
              {
                if ( v33 == 125 )
                {
LABEL_232:
                  v36 = 125;
                  if ( v22 == -1 )
                    goto LABEL_233;
LABEL_201:
                  if ( v22 != 1 )
                    goto LABEL_202;
LABEL_112:
                  v52 = v29;
                  if ( !v26 )
                  {
                    v33 = v36;
                    goto LABEL_50;
                  }
LABEL_229:
                  v29 = v52;
                  LOBYTE(v41) = v24 == 2;
                  v27 = 0;
                  goto LABEL_61;
                }
                if ( v33 <= 125 )
                {
                  v36 = 123;
                  if ( v33 != 123 )
                  {
                    v36 = 124;
                    goto LABEL_202;
                  }
LABEL_200:
                  if ( v22 != -1 )
                    goto LABEL_201;
LABEL_233:
                  if ( *(_BYTE *)(a3 + 1) )
                    goto LABEL_202;
                  goto LABEL_112;
                }
                v52 = v89;
                if ( v33 == 126 )
                {
LABEL_227:
                  if ( !v26 )
                  {
                    v27 = v29;
                    v36 = 126;
                    v29 = v52;
                    LOBYTE(v41) = v24 == 2;
                    goto LABEL_61;
                  }
                  v36 = 126;
                  goto LABEL_229;
                }
LABEL_56:
                if ( v111 == 1 )
                  goto LABEL_57;
                goto LABEL_150;
              }
              if ( v33 == 64 )
                goto LABEL_56;
              v68 = 1LL << (v33 - 65);
              v34 = v89;
              if ( (v68 & 0x3FFFFFF53FFFFFFLL) != 0 )
              {
LABEL_28:
                v27 = v29;
                LOBYTE(v35) = 0;
                v29 = v34;
                v36 = v33;
                goto LABEL_29;
              }
              v36 = v33;
              if ( (v68 & 0xA4000000) != 0 )
                goto LABEL_202;
LABEL_214:
              if ( v33 == 92 )
              {
                if ( (v88 & (unsigned __int8)v87) == 0 || !n )
                {
                  v36 = 92;
                  v27 = 0;
                  goto LABEL_86;
                }
                goto LABEL_217;
              }
              goto LABEL_56;
            }
          }
        }
        v33 = *v28;
        if ( v33 > 63 )
        {
          if ( v33 > 122 )
          {
            if ( v33 == 125 )
            {
              v29 = 0;
              v36 = 125;
              goto LABEL_200;
            }
            if ( v33 <= 125 )
            {
              v29 = 0;
              v36 = 123;
              if ( v33 == 123 )
                goto LABEL_200;
              v36 = 124;
LABEL_202:
              LOBYTE(v41) = v24 == 2;
              v27 = 0;
              goto LABEL_61;
            }
            v52 = 0;
            if ( v33 == 126 )
              goto LABEL_227;
          }
          else if ( v33 != 64 )
          {
            v67 = 1LL << (v33 - 65);
            v34 = 0;
            if ( (v67 & 0x3FFFFFF53FFFFFFLL) != 0 )
              goto LABEL_28;
            v36 = v33;
            v29 = 0;
            if ( (v67 & 0xA4000000) != 0 )
              goto LABEL_202;
            goto LABEL_214;
          }
        }
        else if ( v33 >= 0 )
        {
          switch ( v33 )
          {
            case 0:
              goto LABEL_100;
            case 7:
LABEL_99:
              v36 = 97;
              goto LABEL_94;
            case 8:
LABEL_96:
              v36 = 98;
              v49 = v24 == 2;
              if ( v88 )
                goto LABEL_97;
              goto LABEL_95;
            case 9:
              v29 = 0;
LABEL_115:
              v36 = 9;
              v33 = 116;
              goto LABEL_116;
            case 10:
LABEL_98:
              v36 = 110;
              v27 = 0;
              goto LABEL_86;
            case 11:
LABEL_119:
              v36 = 118;
              v27 = 0;
              goto LABEL_86;
            case 12:
LABEL_93:
              v36 = 102;
LABEL_94:
              v49 = v24 == 2;
              if ( !v88 )
              {
LABEL_95:
                v27 = 0;
LABEL_41:
                if ( v17 < v21 )
                  v23[v17] = 92;
                ++v17;
                ++v26;
                goto LABEL_44;
              }
LABEL_97:
              a4 = v24;
              v10 = v23;
              v9 = v22;
              a2 = v21;
              v47 = v88 && v49;
              break;
            case 13:
LABEL_85:
              v36 = 114;
              v27 = 0;
              goto LABEL_86;
            case 32:
              v34 = 0;
LABEL_121:
              v33 = 32;
              goto LABEL_28;
            case 33:
            case 34:
            case 36:
            case 38:
            case 40:
            case 41:
            case 42:
            case 59:
            case 60:
            case 61:
            case 62:
              v29 = 0;
              v27 = 0;
              goto LABEL_50;
            case 35:
              v29 = 0;
              v36 = 35;
              goto LABEL_112;
            case 37:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
              v34 = 0;
              goto LABEL_28;
            case 39:
              v29 = 0;
              goto LABEL_83;
            case 63:
              v29 = 0;
              goto LABEL_76;
            default:
              goto LABEL_55;
          }
          goto LABEL_88;
        }
LABEL_55:
        v29 = 0;
        goto LABEL_56;
      }
      v33 = *v28;
      if ( v33 > 63 )
      {
        if ( v33 <= 122 )
        {
          if ( v33 != 64 )
          {
            v53 = 1LL << (v33 - 65);
            if ( (v53 & 0x3FFFFFF53FFFFFFLL) != 0 )
              goto LABEL_59;
            if ( (v53 & 0xA4000000) != 0 )
              goto LABEL_49;
            if ( v33 == 92 )
            {
              if ( v24 != 2 )
              {
                v29 = (n != 0) & v88 & v87;
                if ( !v29 )
                {
                  v36 = 92;
LABEL_116:
                  if ( !v87 )
                  {
LABEL_117:
                    v27 = 0;
                    LOBYTE(v35) = 0;
                    if ( !v88 )
                      goto LABEL_63;
LABEL_29:
                    if ( !a6 || ((*(_DWORD *)(a6 + 4LL * (v36 >> 5)) >> v36) & 1) == 0 )
                    {
LABEL_31:
                      if ( !v29 )
                        goto LABEL_64;
                    }
LABEL_32:
                    v37 = v24 == 2;
                    v38 = v24 == 2;
                    if ( !v88 )
                    {
LABEL_33:
                      v39 = v25 ^ 1;
                      if ( (v37 & ((unsigned __int8)v25 ^ 1)) != 0 )
                      {
                        if ( v21 > v17 )
                          v23[v17] = 39;
                        if ( v21 > v17 + 1 )
                          v23[v17 + 1] = 36;
                        if ( v21 > v17 + 2 )
                          v23[v17 + 2] = 39;
                        v17 += 3LL;
                        LOBYTE(v39) = v37 & (v25 ^ 1);
                        v25 = v39;
                      }
                      goto LABEL_41;
                    }
LABEL_87:
                    a4 = v24;
                    v10 = v23;
                    v9 = v22;
                    a2 = v21;
                    v47 = v87 & v38;
LABEL_88:
                    if ( !v47 )
                      goto LABEL_54;
                    goto LABEL_89;
                  }
                  v36 = v33;
                  v27 = 0;
LABEL_86:
                  v37 = v24 == 2;
                  v38 = v24 == 2;
                  if ( !v88 )
                    goto LABEL_33;
                  goto LABEL_87;
                }
LABEL_217:
                ++v26;
                v46 = v25;
                v27 = 0;
                v36 = 92;
                goto LABEL_218;
              }
              if ( !v88 )
                goto LABEL_217;
LABEL_255:
              a4 = 2;
              v10 = v23;
              v9 = v22;
              a2 = v21;
              v42 = v87;
              goto LABEL_53;
            }
          }
          goto LABEL_56;
        }
        if ( v33 == 125 )
          goto LABEL_232;
        if ( v33 <= 125 )
        {
          v36 = 123;
          if ( v33 == 123 )
            goto LABEL_200;
LABEL_49:
          v27 = 0;
LABEL_50:
          LOBYTE(v41) = v24 == 2;
          if ( v88 && v24 == 2 )
          {
LABEL_52:
            v10 = v23;
            a4 = 2;
            v9 = v22;
            a2 = v21;
            v42 = v87;
            goto LABEL_53;
          }
          goto LABEL_60;
        }
        v36 = 126;
        if ( v33 == 126 )
          goto LABEL_112;
        if ( v111 == 1 )
        {
LABEL_57:
          pwcb = (wchar_t *)v21;
          v100 = v25;
          v95 = v26;
          v90 = v29;
          v43 = __ctype_b_loc();
          v29 = v90;
          v26 = v95;
          v44 = 1;
          v25 = v100;
          v21 = (unsigned __int64)pwcb;
          v27 = ((*v43)[(unsigned __int8)v33] & 0x4000) != 0;
          v45 = v87 & (((*v43)[(unsigned __int8)v33] & 0x4000) == 0);
          goto LABEL_58;
        }
LABEL_150:
        v124[0] = 0;
        if ( v22 == -1 )
        {
          pwcc = (wchar_t *)v21;
          v101 = v25;
          v96 = v26;
          v91 = v29;
          v54 = strlen((const char *)a3);
          v21 = (unsigned __int64)pwcc;
          v26 = v96;
          LOBYTE(v25) = v101;
          v29 = v91;
          v22 = v54;
        }
        v116 = v29;
        v102 = v26;
        v97 = v22;
        v118 = v25;
        v92 = v27;
        v119 = v17;
        v113 = v21;
        v108 = v24;
        v112 = v23;
        v117 = v33;
        v55 = 0;
LABEL_153:
        v56 = v102 + v55;
        v57 = (const char *)(a3 + v102 + v55);
        v58 = mbrtowc((wchar_t *)&wc, v57, v97 - (v102 + v55), v124);
        v59 = v58;
        if ( v58 <= 0xFFFFFFFFFFFFFFFDLL || v97 == v102 + v55 )
        {
          if ( !v58 )
            goto LABEL_164;
          if ( v58 == -1 )
          {
LABEL_265:
            v44 = v55;
            v29 = v116;
            v26 = v102;
            v27 = 0;
            v22 = v97;
            v25 = v118;
            v33 = v117;
            v17 = v119;
            v21 = v113;
            v24 = v108;
            v45 = v87;
            goto LABEL_165;
          }
LABEL_157:
          if ( v59 == -2 )
          {
            v22 = v97;
            v44 = v55;
            v73 = v102 + v55;
            v26 = v102;
            v29 = v116;
            v33 = v117;
            v74 = v44;
            v25 = v118;
            v17 = v119;
            v21 = v113;
            v24 = v108;
            if ( v73 < v97 )
            {
              do
              {
                if ( !*(_BYTE *)(a3 + v73) )
                  break;
                ++v74;
                v73 = v102 + v74;
              }
              while ( v97 > v102 + v74 );
              v44 = v74;
            }
            v45 = v87;
            v27 = 0;
LABEL_165:
            if ( v44 > 1 )
            {
LABEL_166:
              v63 = 0;
              v64 = v26 + v44;
              while ( 1 )
              {
                if ( v45 )
                {
                  v65 = v24 == 2;
                  v42 = v24 == 2;
                  if ( v88 )
                  {
                    a4 = v24;
                    v10 = v23;
                    v9 = v22;
                    a2 = v21;
LABEL_53:
                    if ( !v42 )
                    {
LABEL_54:
                      a5 &= ~2u;
                      a6 = 0;
                      goto LABEL_2;
                    }
LABEL_89:
                    a5 &= ~2u;
                    a6 = 0;
                    v111 = __ctype_get_mb_cur_max();
LABEL_90:
                    v18 = 1;
LABEL_91:
                    v88 = 0;
                    v20 = 0;
                    v13 = 2;
                    s2 = "'";
                    v17 = 1;
                    n = 1;
                    v115 = 0;
                    v86 = 1;
                    v110 = 0;
                    if ( !a2 )
                      goto LABEL_11;
                    v48 = 0;
LABEL_253:
                    v115 = v48;
                    v17 = 1;
                    v13 = 2;
                    *v10 = 39;
                    v88 = 0;
                    n = 1;
                    s2 = "'";
                    goto LABEL_11;
                  }
                  v66 = v25 ^ 1;
                  if ( (v65 & ((unsigned __int8)v25 ^ 1)) != 0 )
                  {
                    if ( v21 > v17 )
                      v23[v17] = 39;
                    if ( v21 > v17 + 1 )
                      v23[v17 + 1] = 36;
                    if ( v21 > v17 + 2 )
                      v23[v17 + 2] = 39;
                    v17 += 3LL;
                    LOBYTE(v66) = v65 & (v25 ^ 1);
                    v25 = v66;
                  }
                  if ( v21 > v17 )
                    v23[v17] = 92;
                  if ( v21 > v17 + 1 )
                    v23[v17 + 1] = ((unsigned __int8)v33 >> 6) + 48;
                  if ( v21 > v17 + 2 )
                    v23[v17 + 2] = (((unsigned __int8)v33 >> 3) & 7) + 48;
                  ++v26;
                  v17 += 3LL;
                  v33 = (v33 & 7) + 48;
                  if ( v64 <= v26 )
                  {
                    v36 = v33;
                    goto LABEL_44;
                  }
                  v63 = v45;
                }
                else
                {
                  v46 = v25 & (v63 ^ 1);
                  if ( v29 )
                  {
                    if ( v21 > v17 )
                      v23[v17] = 92;
                    ++v17;
                  }
                  if ( v64 <= ++v26 )
                  {
                    v36 = v33;
                    goto LABEL_218;
                  }
                  if ( v46 )
                  {
                    if ( v21 > v17 )
                      v23[v17] = 39;
                    if ( v21 > v17 + 1 )
                      v23[v17 + 1] = 39;
                    v17 += 2LL;
                    v29 = 0;
                    v25 = 0;
                  }
                  else
                  {
                    v29 = 0;
                  }
                }
                if ( v21 > v17 )
                  v23[v17] = v33;
                v33 = *(_BYTE *)(a3 + v26);
                ++v17;
              }
            }
LABEL_58:
            if ( v45 )
            {
              v45 = v87;
              v27 = 0;
              goto LABEL_166;
            }
LABEL_59:
            LOBYTE(v41) = v24 == 2;
LABEL_60:
            v36 = v33;
LABEL_61:
            LOBYTE(v35) = v41 | v87 ^ 1;
            if ( !(_BYTE)v35 )
              goto LABEL_29;
            LOBYTE(v35) = 0;
            if ( v88 )
              goto LABEL_29;
LABEL_63:
            if ( v29 )
              goto LABEL_32;
LABEL_64:
            ++v26;
            v46 = v25 & (v35 ^ 1);
LABEL_218:
            if ( v46 )
            {
              if ( v21 > v17 )
                v23[v17] = 39;
              if ( v21 > v17 + 1 )
                v23[v17 + 1] = 39;
              v17 += 2LL;
              v25 = 0;
            }
LABEL_44:
            if ( v17 < v21 )
              v23[v17] = v36;
            v40 = v86;
            ++v17;
            if ( !v27 )
              v40 = 0;
            v86 = v40;
            continue;
          }
          if ( v108 == 2 && v88 && v59 > 1 )
          {
            v70 = (_BYTE *)(a3 + v56 + 1);
            while ( 1 )
            {
              if ( (unsigned __int8)(*v70 - 91) <= 0x21u )
              {
                v71 = 0x20000002BLL;
                if ( _bittest64(&v71, (unsigned int)(unsigned __int8)*v70 - 91) )
                  break;
              }
              if ( (_BYTE *)(v56 + a3 + v59) == ++v70 )
                goto LABEL_160;
            }
            v9 = v97;
            v10 = v112;
            a2 = v113;
            if ( v87 )
              goto LABEL_89;
LABEL_272:
            a5 &= ~2u;
            v18 = 0;
            a6 = 0;
            v111 = __ctype_get_mb_cur_max();
            goto LABEL_91;
          }
LABEL_160:
          v60 = wc;
        }
        else
        {
          if ( (unsigned __int8)sub_3570() )
          {
            if ( v59 == -1 )
              goto LABEL_265;
            goto LABEL_157;
          }
          v60 = *(unsigned __int8 *)v57;
          v59 = 1;
          wc = v60;
        }
        v61 = iswprint(v60) == 0;
        v62 = v92;
        if ( v61 )
          v62 = 0;
        v55 += v59;
        v92 = v62;
        if ( mbsinit(v124) )
        {
LABEL_164:
          v27 = v92;
          v44 = v55;
          v29 = v116;
          v26 = v102;
          v22 = v97;
          v25 = v118;
          v33 = v117;
          v17 = v119;
          v21 = v113;
          v24 = v108;
          v45 = v87 & !v92;
          goto LABEL_165;
        }
        goto LABEL_153;
      }
      if ( v33 < 0 )
        goto LABEL_56;
      switch ( v33 )
      {
        case 0:
          if ( v87 )
          {
LABEL_100:
            if ( v88 )
            {
              a4 = v24;
              v10 = v23;
              v9 = v22;
              a2 = v21;
              if ( a4 != 2 )
                goto LABEL_54;
              goto LABEL_89;
            }
            v29 = 0;
LABEL_102:
            v50 = v24 == 2;
            v35 = v25 ^ 1;
            LOBYTE(v35) = (v24 == 2) & (v25 ^ 1);
            if ( (_BYTE)v35 )
            {
              if ( v21 > v17 )
                v23[v17] = 39;
              if ( v21 > v17 + 1 )
                v23[v17 + 1] = 36;
              if ( v21 > v17 + 2 )
                v23[v17 + 2] = 39;
              v51 = v17 + 3;
              if ( v21 <= v17 + 3 )
              {
                v17 += 4LL;
                v25 = v35;
                v27 = 0;
                v36 = 48;
                goto LABEL_31;
              }
LABEL_275:
              v23[v51] = 92;
              v25 = v35;
            }
            else
            {
              v51 = v17;
              if ( v21 > v17 )
              {
                v35 = v25;
                goto LABEL_275;
              }
            }
            v17 = v51 + 1;
            if ( v24 == 2 )
            {
              LOBYTE(v35) = v27;
              v36 = 48;
              v27 = 0;
              goto LABEL_31;
            }
            v36 = 48;
            if ( v26 + 1 < v22 && (unsigned __int8)(*(_BYTE *)(a3 + v26 + 1) - 48) <= 9u )
            {
              if ( v21 > v17 )
                v23[v17] = 48;
              if ( v21 > v51 + 2 )
                v23[v51 + 2] = 48;
              v17 = v51 + 3;
              v36 = 48;
            }
LABEL_279:
            LOBYTE(v35) = v27;
            v27 = 0;
            if ( !(v50 | (unsigned __int8)v87 ^ 1) )
              goto LABEL_29;
            goto LABEL_31;
          }
          v29 = 0;
          v36 = 0;
          if ( (a5 & 1) == 0 )
            goto LABEL_117;
          ++v26;
          break;
        case 7:
          v36 = 7;
          v33 = 97;
          goto LABEL_116;
        case 8:
          v36 = 8;
          v33 = 98;
          goto LABEL_116;
        case 9:
          v36 = 9;
          v33 = 116;
          goto LABEL_127;
        case 10:
          v36 = 10;
          v33 = 110;
          goto LABEL_127;
        case 11:
          v36 = 11;
          v33 = 118;
          goto LABEL_116;
        case 12:
          v36 = 12;
          v33 = 102;
          goto LABEL_116;
        case 13:
          v36 = 13;
          v33 = 114;
LABEL_127:
          v29 = v88 && v24 == 2;
          if ( v29 )
            goto LABEL_52;
          goto LABEL_116;
        case 32:
          v33 = 32;
          goto LABEL_50;
        case 33:
        case 34:
        case 36:
        case 38:
        case 40:
        case 41:
        case 42:
        case 59:
        case 60:
        case 61:
        case 62:
          goto LABEL_49;
        case 35:
LABEL_111:
          v36 = 35;
          goto LABEL_112;
        case 37:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
          goto LABEL_59;
        case 39:
LABEL_83:
          if ( v24 != 2 )
          {
            v115 = v27;
            LOBYTE(v41) = 0;
            v36 = 39;
            goto LABEL_61;
          }
          if ( v88 )
            goto LABEL_255;
          if ( !v21 || v110 )
          {
            if ( v21 > v17 )
              v23[v17] = 39;
            if ( v21 > v17 + 1 )
              v23[v17 + 1] = 92;
            if ( v21 > v17 + 2 )
              v23[v17 + 2] = 39;
          }
          else
          {
            v110 = v21;
            v21 = 0;
          }
          v115 = v27;
          v17 += 3LL;
          LOBYTE(v35) = 0;
          v25 = 0;
          v36 = 39;
          goto LABEL_31;
        case 63:
LABEL_76:
          if ( v24 == 2 )
          {
            if ( !v88 )
            {
              v27 = 0;
              LOBYTE(v35) = 0;
              v36 = 63;
              goto LABEL_31;
            }
            goto LABEL_255;
          }
          if ( v24 != 5
            || (a5 & 4) == 0
            || v26 + 2 >= v22
            || *(_BYTE *)(a3 + v26 + 1) != 63
            || (v36 = *(_BYTE *)(a3 + v26 + 2), v36 > 0x3Eu) )
          {
            LOBYTE(v41) = 0;
            v27 = 0;
            v36 = 63;
            goto LABEL_61;
          }
          v41 = (0x7000A38200000000uLL >> v36) & 1;
          if ( ((0x7000A38200000000uLL >> v36) & 1) == 0 )
          {
            v27 = 0;
            v36 = 63;
            goto LABEL_61;
          }
          if ( v88 )
          {
LABEL_326:
            a4 = v24;
            v10 = v23;
            v9 = v22;
            a2 = v21;
            goto LABEL_54;
          }
          if ( v21 > v17 )
            v23[v17] = 63;
          if ( v21 > v17 + 1 )
            v23[v17 + 1] = 34;
          if ( v21 > v17 + 2 )
            v23[v17 + 2] = 34;
          if ( v21 > v17 + 3 )
            v23[v17 + 3] = 63;
          v17 += 4LL;
          v50 = 0;
          v27 = 0;
          v26 += 2LL;
          goto LABEL_279;
        default:
          goto LABEL_56;
      }
    }
    if ( v24 == 2 && v88 && v17 == 0 )
    {
      v10 = v23;
      v9 = v22;
      a2 = v21;
      if ( v87 )
        goto LABEL_89;
      goto LABEL_272;
    }
    v69 = !v88;
    if ( v88 || v24 != 2 )
      break;
    if ( !v115 )
    {
      v69 = !v88 && v24 == 2;
      break;
    }
    if ( !v86 )
    {
      v10 = v23;
      v18 = v87;
      v20 = v25;
      v9 = v22;
      v48 = v110 != 0 && v21 == 0;
      if ( v48 )
      {
        a2 = v110;
        goto LABEL_253;
      }
      v69 = v115;
      break;
    }
    v24 = 5;
    v17 = 0;
    n = 1;
    v111 = __ctype_get_mb_cur_max();
    s2 = (const char *)&unk_50DD;
    if ( (a5 & 2) != 0 )
    {
      v21 = v110;
      v115 = 0;
      v25 = 0;
      v110 = 0;
      v88 = v86;
      v87 = v86;
      goto LABEL_12;
    }
    v10 = v23;
    v9 = v22;
    a2 = v110;
LABEL_66:
    v88 = 0;
    v18 = 1;
    v20 = 0;
    s2 = (const char *)&unk_50DD;
    v13 = 5;
    v17 = 1;
    n = 1;
    v115 = 0;
    v86 = 1;
    v110 = 0;
    if ( a2 )
      *v10 = 34;
  }
  if ( s2 )
  {
    if ( v69 )
    {
      v75 = *s2;
      if ( *s2 )
      {
        v76 = v17;
        do
        {
          if ( v21 > v76 )
            a1[v76] = v75;
          v75 = s2[++v76 - v17];
        }
        while ( v75 );
        v17 = v76;
      }
    }
  }
  if ( v21 > v17 )
    a1[v17] = 0;
  return v17;
}
// 39B3: conditional instruction was optimized away because bl.1==7C
// 43D2: conditional instruction was optimized away because bl.1==7C
// 4492: conditional instruction was optimized away because bl.1==7C

//----- (0000000000004AE0) ----------------------------------------------------
_BYTE *__fastcall sub_4AE0(__int64 a1, __int64 a2)
{
  int *v3; // rax
  int v4; // r12d
  unsigned __int64 *v5; // rbp
  int *v6; // r13
  unsigned __int64 *v7; // rax
  _BYTE *v8; // r15
  int v9; // r12d
  unsigned __int64 v10; // rax
  size_t v11; // rsi
  __int64 v12; // r9
  _BYTE *v13; // rax
  __m128i *v15; // rax
  int v16; // [rsp+Ch] [rbp-4Ch]
  unsigned __int64 v17; // [rsp+10h] [rbp-48h]
  __int64 v18; // [rsp+18h] [rbp-40h]
  __int64 v19; // [rsp+18h] [rbp-40h]

  v3 = __errno_location();
  v4 = dword_8020;
  v5 = (unsigned __int64 *)ptr;
  v6 = v3;
  v16 = *v3;
  if ( dword_8020 <= 0 )
  {
    if ( ptr == &unk_8080 )
    {
      v15 = (__m128i *)malloc(0x10u);
      v5 = (unsigned __int64 *)v15;
      if ( !v15 )
        goto LABEL_15;
      ptr = v15;
      *v15 = _mm_load_si128((const __m128i *)&unk_8080);
    }
    else
    {
      v7 = (unsigned __int64 *)realloc(ptr, 0x10u);
      v5 = v7;
      if ( !v7 )
        goto LABEL_15;
      ptr = v7;
    }
    memset(&v5[2 * v4], 0, 16LL * (1 - v4));
    dword_8020 = 1;
  }
  v8 = (_BYTE *)v5[1];
  v9 = *(_DWORD *)(a2 + 4) | 1;
  v18 = a2 + 8;
  v17 = *v5;
  v10 = sub_3640(v8, *v5, a1, *(_DWORD *)a2, v9, a2 + 8, *(char **)(a2 + 40), *(const char **)(a2 + 48));
  if ( v17 <= v10 )
  {
    v11 = v10 + 1;
    v12 = v18;
    *v5 = v10 + 1;
    if ( v8 != (_BYTE *)&unk_80C0 )
    {
      free(v8);
      v12 = v18;
    }
    v19 = v12;
    v13 = malloc(v11);
    v8 = v13;
    if ( v13 || !v11 )
    {
      v5[1] = (unsigned __int64)v13;
      sub_3640(v13, v11, a1, *(_DWORD *)a2, v9, v19, *(char **)(a2 + 40), *(const char **)(a2 + 48));
      goto LABEL_12;
    }
LABEL_15:
    sub_2CD0();
  }
LABEL_12:
  *v6 = v16;
  return v8;
}
// 8020: using guessed type int dword_8020;

//----- (0000000000004D00) ----------------------------------------------------
int __fastcall sub_4D00(void (*a1)(void *))
{
  return _cxa_atexit(a1, 0, lpdso_handle);
}

//----- (0000000000004D14) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=152 queued=62 decompiled=62 lumina nreq=0 worse=0 better=0
// ALL OK, 62 function(s) have been successfully decompiled
