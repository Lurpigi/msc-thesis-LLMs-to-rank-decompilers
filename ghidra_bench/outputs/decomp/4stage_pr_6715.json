{
  "exception": "\n/* Library Function - Single Match\n    public: __cdecl std::exception::exception(class std::exception const & __ptr64) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nexception * __thiscall std::exception::exception(exception *this,exception *param_1)\n\n{\n  *(undefined ***)this = vftable;\n  *(undefined (*) [16])(this + 8) = ZEXT816(0);\n  __std_exception_copy((char **)(param_1 + 8),(char **)(this + 8));\n  return this;\n}\n\n",
  "_invalid_parameter": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    _invalid_parameter\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _invalid_parameter(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,\n                       uintptr_t param_5)\n\n{\n  ulonglong uVar1;\n  byte bVar2;\n  \n  uVar1 = __acrt_getptd_noexit();\n  if (((uVar1 == 0) || (*(longlong *)(uVar1 + 0x3b8) == 0)) &&\n     (bVar2 = (byte)DAT_140035020 & 0x3f,\n     ((DAT_140035020 ^ _DAT_140036e90) >> bVar2 | (DAT_140035020 ^ _DAT_140036e90) << 0x40 - bVar2)\n     == 0)) {\n                    /* WARNING: Subroutine does not return */\n    _invoke_watson(param_1,param_2,param_3,param_4,param_5);\n  }\n  (*(code *)PTR__guard_dispatch_icall_140023298)(param_1,param_2,param_3,param_4,param_5);\n  return;\n}\n\n",
  "ungetc": "\n/* Library Function - Single Match\n    ungetc\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl ungetc(int _Ch,FILE *_File)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  \n  if (_File == (FILE *)0x0) {\n    puVar2 = __doserrno();\n    *puVar2 = 0x16;\n    FUN_14000d030();\n    iVar1 = -1;\n  }\n  else {\n    FUN_14000d384((longlong)_File);\n    iVar1 = _ungetc_nolock(_Ch,_File);\n    FUN_14000d390((longlong)_File);\n  }\n  return iVar1;\n}\n\n",
  "FID_conflict:__acrt_lowio_lock_fh": "\n/* Library Function - Multiple Matches With Different Base Names\n    __acrt_lowio_lock_fh\n    __acrt_lowio_unlock_fh\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid FID_conflict___acrt_lowio_lock_fh(uint param_1)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00014001c504. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  EnterCriticalSection\n            ((LPCRITICAL_SECTION)\n             ((&DAT_140037490)[(longlong)(int)param_1 >> 6] + (ulonglong)(param_1 & 0x3f) * 0x48));\n  return;\n}\n\n",
  "wcscmp": "\n/* Library Function - Single Match\n    wcscmp\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl wcscmp(wchar_t *_Str1,wchar_t *_Str2)\n\n{\n  wchar_t wVar1;\n  longlong lVar2;\n  int iVar3;\n  \n  wVar1 = *_Str2;\n  iVar3 = (uint)(ushort)*_Str1 - (uint)(ushort)wVar1;\n  if (iVar3 == 0) {\n    lVar2 = (longlong)_Str1 - (longlong)_Str2;\n    do {\n      if (wVar1 == L'\\0') break;\n      _Str2 = _Str2 + 1;\n      wVar1 = *_Str2;\n      iVar3 = (uint)*(ushort *)(lVar2 + (longlong)_Str2) - (uint)(ushort)wVar1;\n    } while (iVar3 == 0);\n  }\n  return (iVar3 >> 0x1f) - (-iVar3 >> 0x1f);\n}\n\n",
  "__c16rtomb_utf8": "\n/* Library Function - Single Match\n    unsigned __int64 __cdecl __crt_mbstring::__c16rtomb_utf8(char * __ptr64,char16_t,struct\n   _Mbstatet * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\n__uint64 __cdecl __crt_mbstring::__c16rtomb_utf8(char *param_1,wchar16 param_2,_Mbstatet *param_3)\n\n{\n  ulong *puVar1;\n  __uint64 _Var2;\n  _Mbstatet *p_Var3;\n  undefined8 local_res18 [2];\n  \n  p_Var3 = (_Mbstatet *)&DAT_1400379e8;\n  if (param_3 != (_Mbstatet *)0x0) {\n    p_Var3 = param_3;\n  }\n  if (*(int *)p_Var3 == 0) {\n    if (0x3ff < (ushort)(param_2 + L'␀')) {\n      if ((ushort)(param_2 + L'⠀') < 0x400) {\n        *(uint *)p_Var3 = ((ushort)param_2 & 0x3f27ff) * 0x400 + 0x10000;\n        return 0;\n      }\n      _Var2 = __c32rtomb_utf8(param_1,(uint)(ushort)param_2,p_Var3);\n      return _Var2;\n    }\n  }\n  else if ((ushort)(param_2 + L'␀') < 0x400) {\n    local_res18[0] = 0;\n    _Var2 = __c32rtomb_utf8(param_1,((ushort)param_2 & 0xffff23ff) + *(int *)p_Var3,\n                            (_Mbstatet *)local_res18);\n    *(undefined8 *)p_Var3 = 0;\n    return _Var2;\n  }\n  *(undefined8 *)p_Var3 = 0;\n  puVar1 = __doserrno();\n  *puVar1 = 0x2a;\n  return 0xffffffffffffffff;\n}\n\n",
  "__acrt_GetStringTypeA": "\n/* WARNING: Function: __chkstk replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    __acrt_GetStringTypeA\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_GetStringTypeA\n               (__crt_locale_pointers *param_1,DWORD param_2,LPCSTR param_3,int param_4,\n               LPWORD param_5,UINT param_6,int param_7)\n\n{\n  longlong lVar1;\n  int iVar2;\n  ulonglong uVar3;\n  undefined (*lpSrcStr) [16];\n  ulonglong uVar4;\n  ulonglong uVar5;\n  undefined *puVar6;\n  undefined *puVar7;\n  undefined auStackY_88 [32];\n  longlong local_58;\n  longlong local_50;\n  char local_40;\n  ulonglong local_38;\n  \n  puVar6 = auStackY_88;\n  puVar7 = auStackY_88;\n  local_38 = DAT_140035020 ^ (ulonglong)&local_58;\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_58,param_1);\n  if (param_6 == 0) {\n    param_6 = *(UINT *)(local_50 + 0xc);\n  }\n  iVar2 = __acrt_MultiByteToWideChar\n                    (param_6,(-(uint)(param_7 != 0) & 8) + 1,param_3,param_4,(LPWSTR)0x0,0);\n  if (iVar2 == 0) goto LAB_140019414;\n  uVar5 = (longlong)iVar2 * 2;\n  uVar4 = -(ulonglong)(uVar5 < uVar5 + 0x10) & uVar5 + 0x10;\n  if (uVar4 == 0) {\n    lpSrcStr = (undefined (*) [16])0x0;\n    puVar7 = auStackY_88;\nLAB_1400193b0:\n    if (lpSrcStr != (undefined (*) [16])0x0) {\n      *(undefined8 *)(puVar7 + -8) = 0x1400193c2;\n      FUN_140008580(lpSrcStr,0,uVar5);\n      *(int *)(puVar7 + 0x28) = iVar2;\n      *(undefined (**) [16])(puVar7 + 0x20) = lpSrcStr;\n      *(undefined8 *)(puVar7 + -8) = 0x1400193de;\n      iVar2 = __acrt_MultiByteToWideChar\n                        (param_6,1,param_3,param_4,*(LPWSTR *)(puVar7 + 0x20),\n                         *(int *)(puVar7 + 0x28));\n      if (iVar2 != 0) {\n        *(undefined8 *)(puVar7 + -8) = 0x1400193f8;\n        GetStringTypeW(param_2,(LPCWSTR)lpSrcStr,iVar2,param_5);\n      }\n    }\n  }\n  else {\n    if (0x400 < uVar4) {\n      lpSrcStr = (undefined (*) [16])_malloc_base(uVar4);\n      puVar7 = auStackY_88;\n      if (lpSrcStr != (undefined (*) [16])0x0) {\n        *(undefined4 *)*lpSrcStr = 0xdddd;\n        goto LAB_1400193a8;\n      }\n      goto LAB_1400193b0;\n    }\n    uVar3 = uVar4 + 0xf;\n    if (uVar3 <= uVar4) {\n      uVar3 = 0xffffffffffffff0;\n    }\n    lVar1 = -(uVar3 & 0xfffffffffffffff0);\n    puVar7 = auStackY_88 + lVar1;\n    puVar6 = auStackY_88 + lVar1;\n    lpSrcStr = (undefined (*) [16])((longlong)&local_58 + lVar1);\n    if (lpSrcStr != (undefined (*) [16])0x0) {\n      *(undefined4 *)*lpSrcStr = 0xcccc;\nLAB_1400193a8:\n      lpSrcStr = lpSrcStr + 1;\n      puVar7 = puVar6;\n      goto LAB_1400193b0;\n    }\n  }\n  if ((lpSrcStr != (undefined (*) [16])0x0) && (*(int *)lpSrcStr[-1] == 0xdddd)) {\n    *(undefined8 *)(puVar7 + -8) = 0x140019414;\n    _free_base(lpSrcStr + -1);\n  }\nLAB_140019414:\n  if (local_40 != '\\0') {\n    *(uint *)(local_58 + 0x3a8) = *(uint *)(local_58 + 0x3a8) & 0xfffffffd;\n  }\n  uVar5 = local_38 ^ (ulonglong)&local_58;\n  *(undefined8 *)(puVar7 + -8) = 0x140019433;\n  FUN_140006060(uVar5);\n  return;\n}\n\n",
  "_Endwrite": "\n/* Library Function - Single Match\n    protected: bool __cdecl std::basic_filebuf<char,struct std::char_traits<char> >::_Endwrite(void)\n   __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nbool __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::_Endwrite\n          (basic_filebuf<char,struct_std::char_traits<char>_> *this)\n\n{\n  undefined uVar1;\n  int iVar2;\n  undefined auStack_68 [32];\n  longlong *local_48;\n  longlong local_38;\n  undefined local_30 [32];\n  ulonglong local_10;\n  \n  local_10 = DAT_140035020 ^ (ulonglong)auStack_68;\n  if (((*(longlong *)(this + 0x68) != 0) &&\n      (this[0x71] != (basic_filebuf<char,struct_std::char_traits<char>_>)0x0)) &&\n     (iVar2 = (*(code *)PTR__guard_dispatch_icall_140023298)(this,0xffffffff), iVar2 != -1)) {\n    local_48 = &local_38;\n    iVar2 = (*(code *)PTR__guard_dispatch_icall_140023298)\n                      (*(undefined8 *)(this + 0x68),this + 0x74,local_30,&local_10);\n    if (iVar2 == 0) {\n      this[0x71] = (basic_filebuf<char,struct_std::char_traits<char>_>)0x0;\n    }\n    else if (iVar2 != 1) {\n      if (iVar2 == 3) {\n        this[0x71] = (basic_filebuf<char,struct_std::char_traits<char>_>)0x0;\n      }\n      goto LAB_1400041ef;\n    }\n    if (local_38 - (longlong)local_30 != 0) {\n      fwrite(local_30,1,local_38 - (longlong)local_30,*(FILE **)(this + 0x80));\n    }\n  }\nLAB_1400041ef:\n  uVar1 = FUN_140006060(local_10 ^ (ulonglong)auStack_68);\n  return (bool)uVar1;\n}\n\n",
  "Is_bad_exception_allowed": "\n/* Library Function - Single Match\n    unsigned char __cdecl Is_bad_exception_allowed(struct _s_ESTypeList const * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nuchar __cdecl Is_bad_exception_allowed(_s_ESTypeList *param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  longlong lVar3;\n  int iVar4;\n  longlong lVar5;\n  \n  iVar4 = 0;\n  if (0 < *(int *)param_1) {\n    lVar5 = 0;\n    do {\n      lVar3 = _GetImageBase();\n      if (*(int *)((longlong)*(int *)(param_1 + 4) + 4 + lVar3 + lVar5) == 0) {\n        lVar3 = 0;\n      }\n      else {\n        lVar3 = _GetImageBase();\n        iVar1 = *(int *)((longlong)*(int *)(param_1 + 4) + 4 + lVar3 + lVar5);\n        lVar3 = _GetImageBase();\n        lVar3 = lVar3 + iVar1;\n      }\n      uVar2 = __std_type_info_compare(lVar3 + 8,0x140035bd8);\n      if (uVar2 == 0) {\n        return '\\x01';\n      }\n      iVar4 = iVar4 + 1;\n      lVar5 = lVar5 + 0x14;\n    } while (iVar4 < *(int *)param_1);\n  }\n  return '\\0';\n}\n\n",
  "FUN_14001a250": "\nulonglong FUN_14001a250(undefined8 param_1,undefined8 param_2,ulonglong param_3,uint param_4)\n\n{\n  int iVar1;\n  ulonglong uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  if (param_4 == 2) {\n    iVar1 = 2;\n    uVar4 = 0x22;\n    uVar3 = 4;\n  }\n  else {\n    if (param_4 < 3) {\n      return param_3;\n    }\n    if (param_4 < 6) {\n      uVar2 = FUN_14001fb2c(param_3);\n      return uVar2;\n    }\n    if (param_4 == 6) {\n      iVar1 = 1;\n      uVar4 = 0x21;\n      uVar3 = 8;\n    }\n    else {\n      if (param_4 < 7) {\n        return param_3;\n      }\n      if (param_4 < 9) {\n        iVar1 = 4;\n        uVar4 = 0x22;\n        uVar3 = 0x12;\n      }\n      else {\n        if (param_4 != 9) {\n          return param_3;\n        }\n        iVar1 = 3;\n        uVar4 = 0x22;\n        uVar3 = 0x11;\n      }\n    }\n  }\n  FUN_14001f8d0(&DAT_140028f28,0x1d,param_3,iVar1,uVar3,uVar4,param_1,param_2,2);\n  return param_3;\n}\n\n",
  "FUN_140012fec": "\nvoid FUN_140012fec(undefined4 *param_1,undefined4 *param_2)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 *puVar4;\n  longlong lVar5;\n  undefined4 *puVar6;\n  undefined4 *puVar7;\n  \n  if (((param_2 != (undefined4 *)0x0) && (param_1 != (undefined4 *)0x0)) && (param_1 != param_2)) {\n    lVar5 = 2;\n    puVar4 = param_1;\n    do {\n      puVar7 = puVar4;\n      puVar6 = param_2;\n      uVar1 = puVar6[1];\n      uVar2 = puVar6[2];\n      uVar3 = puVar6[3];\n      *puVar7 = *puVar6;\n      puVar7[1] = uVar1;\n      puVar7[2] = uVar2;\n      puVar7[3] = uVar3;\n      uVar1 = puVar6[5];\n      uVar2 = puVar6[6];\n      uVar3 = puVar6[7];\n      puVar7[4] = puVar6[4];\n      puVar7[5] = uVar1;\n      puVar7[6] = uVar2;\n      puVar7[7] = uVar3;\n      uVar1 = puVar6[9];\n      uVar2 = puVar6[10];\n      uVar3 = puVar6[0xb];\n      puVar7[8] = puVar6[8];\n      puVar7[9] = uVar1;\n      puVar7[10] = uVar2;\n      puVar7[0xb] = uVar3;\n      uVar1 = puVar6[0xd];\n      uVar2 = puVar6[0xe];\n      uVar3 = puVar6[0xf];\n      puVar7[0xc] = puVar6[0xc];\n      puVar7[0xd] = uVar1;\n      puVar7[0xe] = uVar2;\n      puVar7[0xf] = uVar3;\n      uVar1 = puVar6[0x11];\n      uVar2 = puVar6[0x12];\n      uVar3 = puVar6[0x13];\n      puVar7[0x10] = puVar6[0x10];\n      puVar7[0x11] = uVar1;\n      puVar7[0x12] = uVar2;\n      puVar7[0x13] = uVar3;\n      uVar1 = puVar6[0x15];\n      uVar2 = puVar6[0x16];\n      uVar3 = puVar6[0x17];\n      puVar7[0x14] = puVar6[0x14];\n      puVar7[0x15] = uVar1;\n      puVar7[0x16] = uVar2;\n      puVar7[0x17] = uVar3;\n      uVar1 = puVar6[0x19];\n      uVar2 = puVar6[0x1a];\n      uVar3 = puVar6[0x1b];\n      puVar7[0x18] = puVar6[0x18];\n      puVar7[0x19] = uVar1;\n      puVar7[0x1a] = uVar2;\n      puVar7[0x1b] = uVar3;\n      uVar1 = puVar6[0x1d];\n      uVar2 = puVar6[0x1e];\n      uVar3 = puVar6[0x1f];\n      puVar7[0x1c] = puVar6[0x1c];\n      puVar7[0x1d] = uVar1;\n      puVar7[0x1e] = uVar2;\n      puVar7[0x1f] = uVar3;\n      lVar5 = lVar5 + -1;\n      param_2 = puVar6 + 0x20;\n      puVar4 = puVar7 + 0x20;\n    } while (lVar5 != 0);\n    uVar1 = puVar6[0x21];\n    uVar2 = puVar6[0x22];\n    uVar3 = puVar6[0x23];\n    puVar7[0x20] = puVar6[0x20];\n    puVar7[0x21] = uVar1;\n    puVar7[0x22] = uVar2;\n    puVar7[0x23] = uVar3;\n    uVar1 = puVar6[0x25];\n    uVar2 = puVar6[0x26];\n    uVar3 = puVar6[0x27];\n    puVar7[0x24] = puVar6[0x24];\n    puVar7[0x25] = uVar1;\n    puVar7[0x26] = uVar2;\n    puVar7[0x27] = uVar3;\n    uVar1 = puVar6[0x29];\n    uVar2 = puVar6[0x2a];\n    uVar3 = puVar6[0x2b];\n    puVar7[0x28] = puVar6[0x28];\n    puVar7[0x29] = uVar1;\n    puVar7[0x2a] = uVar2;\n    puVar7[0x2b] = uVar3;\n    uVar1 = puVar6[0x2d];\n    uVar2 = puVar6[0x2e];\n    uVar3 = puVar6[0x2f];\n    puVar7[0x2c] = puVar6[0x2c];\n    puVar7[0x2d] = uVar1;\n    puVar7[0x2e] = uVar2;\n    puVar7[0x2f] = uVar3;\n    uVar1 = puVar6[0x31];\n    uVar2 = puVar6[0x32];\n    uVar3 = puVar6[0x33];\n    puVar7[0x30] = puVar6[0x30];\n    puVar7[0x31] = uVar1;\n    puVar7[0x32] = uVar2;\n    puVar7[0x33] = uVar3;\n    *(undefined8 *)(puVar7 + 0x34) = *(undefined8 *)(puVar6 + 0x34);\n    param_1[4] = 0;\n    __acrt_add_locale_ref((longlong)param_1);\n  }\n  return;\n}\n\n",
  "__acrt_CompareStringA": "\n/* Library Function - Single Match\n    __acrt_CompareStringA\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_CompareStringA\n               (__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,\n               int param_5,char *param_6,int param_7,int param_8)\n\n{\n  longlong local_28;\n  __crt_locale_pointers local_20 [16];\n  char local_10;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,param_1);\n  InternalCompareStringA(local_20,param_2,param_3,param_4,param_5,param_6,param_7,param_8);\n  if (local_10 != '\\0') {\n    *(uint *)(local_28 + 0x3a8) = *(uint *)(local_28 + 0x3a8) & 0xfffffffd;\n  }\n  return;\n}\n\n",
  "write_text_ansi_nolock": "\n/* WARNING: Function: __chkstk replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    struct `anonymous namespace'::write_result __cdecl write_text_ansi_nolock(int,char const *\n   __ptr64 const,unsigned int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl write_text_ansi_nolock(DWORD *param_1,uint param_2,char *param_3,ulonglong param_4)\n\n{\n  char cVar1;\n  HANDLE hFile;\n  BOOL BVar2;\n  DWORD DVar3;\n  uint nNumberOfBytesToWrite;\n  char *pcVar4;\n  char *pcVar5;\n  undefined auStackY_1468 [32];\n  uint local_1438 [4];\n  char local_1428 [5120];\n  ulonglong local_28;\n  undefined8 uStack_20;\n  \n  uStack_20 = 0x140016940;\n  local_28 = DAT_140035020 ^ (ulonglong)auStackY_1468;\n  pcVar5 = param_3 + (param_4 & 0xffffffff);\n  hFile = *(HANDLE *)\n           ((&DAT_140037490)[(longlong)(int)param_2 >> 6] + 0x28 +\n           (ulonglong)(param_2 & 0x3f) * 0x48);\n  *(undefined8 *)param_1 = 0;\n  param_1[2] = 0;\n  if (pcVar5 <= param_3) {\nLAB_1400169ff:\n    FUN_140006060(local_28 ^ (ulonglong)auStackY_1468);\n    return;\n  }\n  do {\n    pcVar4 = local_1428;\n    do {\n      if (pcVar5 <= param_3) break;\n      cVar1 = *param_3;\n      param_3 = param_3 + 1;\n      if (cVar1 == '\\n') {\n        param_1[2] = param_1[2] + 1;\n        *pcVar4 = '\\r';\n        pcVar4 = pcVar4 + 1;\n      }\n      *pcVar4 = cVar1;\n      pcVar4 = pcVar4 + 1;\n    } while (pcVar4 < local_1428 + 0x13ff);\n    nNumberOfBytesToWrite = (int)pcVar4 - (int)local_1428;\n    BVar2 = WriteFile(hFile,local_1428,nNumberOfBytesToWrite,local_1438,(LPOVERLAPPED)0x0);\n    if (BVar2 == 0) {\n      DVar3 = GetLastError();\n      *param_1 = DVar3;\n      goto LAB_1400169ff;\n    }\n    param_1[1] = param_1[1] + local_1438[0];\n    if ((local_1438[0] < nNumberOfBytesToWrite) || (pcVar5 <= param_3)) goto LAB_1400169ff;\n  } while( true );\n}\n\n",
  "FUN_1400039fc": "\nundefined8 * FUN_1400039fc(undefined8 *param_1,char *param_2)\n\n{\n  char *local_18;\n  undefined local_10;\n  \n  local_10 = 1;\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  local_18 = param_2;\n  __std_exception_copy(&local_18,(char **)(param_1 + 1));\n  *param_1 = std::runtime_error::vftable;\n  return param_1;\n}\n\n",
  "FUN_14001a374": "\nfloat FUN_14001a374(float param_1,float param_2,float param_3,uint param_4)\n\n{\n  int iVar1;\n  float fVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  iVar1 = 2;\n  if (param_4 == 1) {\n    uVar4 = 0;\n    iVar1 = 0;\n  }\n  else {\n    if (param_4 == 2) {\n      uVar4 = 0x22;\n      uVar3 = 4;\n      goto LAB_14001a4da;\n    }\n    if (param_4 < 3) {\n      return param_3;\n    }\n    if (param_4 < 6) {\n      fVar2 = (float)FUN_14001fb48((uint)param_3);\n      return fVar2;\n    }\n    if (param_4 != 6) {\n      if (param_4 == 7) {\n        iVar1 = 4;\n        uVar4 = 0x22;\n        uVar3 = 0x12;\n      }\n      else {\n        if (param_4 != 9) {\n          return param_3;\n        }\n        iVar1 = 3;\n        uVar4 = 0x22;\n        uVar3 = 0x11;\n      }\n      goto LAB_14001a4da;\n    }\n    iVar1 = 1;\n    uVar4 = 0x21;\n  }\n  uVar3 = 8;\nLAB_14001a4da:\n  FUN_14001f9f8(&DAT_14002a360,0x1d,param_3,iVar1,uVar3,uVar4,param_1,param_2,2);\n  return param_3;\n}\n\n",
  "_wcstombs_s_l": "\n/* Library Function - Single Match\n    _wcstombs_s_l\n   \n   Library: Visual Studio 2019 Release */\n\nerrno_t __cdecl\n_wcstombs_s_l(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,wchar_t *_Src,\n             size_t _MaxCountInBytes,_locale_t _Locale)\n\n{\n  __uint64 _Var1;\n  ulong *puVar2;\n  size_t sVar3;\n  ulong uVar4;\n  errno_t eVar5;\n  \n  eVar5 = 0;\n  if (_DstSizeInBytes == 0) {\n    if (_Dst != (char *)0x0) {\n      *_Dst = '\\0';\n    }\n    if (_PtNumOfCharConverted != (size_t *)0x0) {\n      *_PtNumOfCharConverted = 0;\n    }\n    _Var1 = _MaxCountInBytes;\n    if (_MaxCountInBytes != 0) {\n      _Var1 = 0;\n    }\n    if (_Var1 < 0x80000000) {\n      _Var1 = _wcstombs_l_helper(_Dst,_Src,_Var1,(__crt_locale_pointers *)_Locale);\n      if (_Var1 == 0xffffffffffffffff) {\n        if (_Dst != (char *)0x0) {\n          *_Dst = '\\0';\n        }\n        puVar2 = __doserrno();\n        return *puVar2;\n      }\n      sVar3 = _Var1 + 1;\n      if (_Dst != (char *)0x0) {\n        eVar5 = 0;\n        if (sVar3 != 0) {\n          if (_MaxCountInBytes != 0xffffffffffffffff) {\n            *_Dst = '\\0';\n            puVar2 = __doserrno();\n            uVar4 = 0x22;\n            goto LAB_140018f19;\n          }\n          eVar5 = 0x50;\n          sVar3 = 0;\n        }\n        _Dst[sVar3 - 1] = '\\0';\n      }\n      if (_PtNumOfCharConverted == (size_t *)0x0) {\n        return eVar5;\n      }\n      *_PtNumOfCharConverted = sVar3;\n      return eVar5;\n    }\n  }\n  puVar2 = __doserrno();\n  uVar4 = 0x16;\nLAB_140018f19:\n  *puVar2 = uVar4;\n  FUN_14000d030();\n  return uVar4;\n}\n\n",
  "~basic_filebuf<char,struct_std::char_traits<char>_>": "\n/* Library Function - Single Match\n    public: virtual __cdecl std::basic_filebuf<char,struct std::char_traits<char>\n   >::~basic_filebuf<char,struct std::char_traits<char> >(void) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::\n~basic_filebuf<char,struct_std::char_traits<char>_>\n          (basic_filebuf<char,struct_std::char_traits<char>_> *this)\n\n{\n  undefined8 uVar1;\n  basic_filebuf<char,struct_std::char_traits<char>_> *pbVar2;\n  LPVOID pvVar3;\n  longlong lVar4;\n  \n  *(undefined ***)this = vftable;\n  if ((*(longlong *)(this + 0x80) != 0) &&\n     (**(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x18) == this + 0x70)) {\n    uVar1 = *(undefined8 *)(this + 0x90);\n    pbVar2 = *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x88);\n    **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x18) = pbVar2;\n    **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x38) = pbVar2;\n    **(int **)(this + 0x50) = (int)uVar1 - (int)pbVar2;\n  }\n  if (this[0x7c] != (basic_filebuf<char,struct_std::char_traits<char>_>)0x0) {\n    if (*(longlong *)(this + 0x80) != 0) {\n      _Endwrite(this);\n      fclose(*(FILE **)(this + 0x80));\n    }\n    _Init(this,(_iobuf *)0x0,2);\n  }\n  *(undefined ***)this = basic_streambuf<char,struct_std::char_traits<char>_>::vftable;\n  pvVar3 = *(LPVOID *)(this + 0x60);\n  if (pvVar3 != (LPVOID)0x0) {\n    if (*(longlong *)((longlong)pvVar3 + 8) != 0) {\n      lVar4 = (*(code *)PTR__guard_dispatch_icall_140023298)();\n      if (lVar4 != 0) {\n        (*(code *)PTR__guard_dispatch_icall_140023298)(lVar4,1);\n      }\n    }\n    thunk_FUN_14000ce08(pvVar3);\n  }\n  return;\n}\n\n",
  "initialize_environment_by_cloning_nolock<char>": "\n/* Library Function - Single Match\n    int __cdecl initialize_environment_by_cloning_nolock<char>(void)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl initialize_environment_by_cloning_nolock<char>(void)\n\n{\n  int iVar1;\n  char *pcVar2;\n  LPCWSTR *ppWVar3;\n  \n  ppWVar3 = DAT_140037220;\n  if (DAT_140037220 == (LPCWSTR *)0x0) {\nLAB_140012417:\n    iVar1 = -1;\n  }\n  else {\n    for (; *ppWVar3 != (LPCWSTR)0x0; ppWVar3 = ppWVar3 + 1) {\n      iVar1 = __acrt_WideCharToMultiByte(0,0,*ppWVar3,-1,(LPSTR)0x0,0,(LPBOOL)0x0,(LPBOOL)0x0);\n      if (iVar1 == 0) goto LAB_140012417;\n      pcVar2 = (char *)_calloc_base((longlong)iVar1,1);\n      if (pcVar2 == (char *)0x0) {\nLAB_1400124bc:\n        _free_base(pcVar2);\n        goto LAB_140012417;\n      }\n      iVar1 = __acrt_WideCharToMultiByte(0,0,*ppWVar3,-1,pcVar2,iVar1,(LPBOOL)0x0,(LPBOOL)0x0);\n      if (iVar1 == 0) goto LAB_1400124bc;\n      common_set_variable_in_environment_nolock<char>(pcVar2,0);\n      _free_base((LPVOID)0x0);\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
  "FUN_140020504": "\n/* WARNING: Removing unreachable block (ram,0x0001400215e3) */\n\nint FUN_140020504(byte *param_1,byte *param_2,size_t param_3)\n\n{\n  byte bVar1;\n  byte bVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  ulong *puVar6;\n  uint uVar7;\n  longlong local_28;\n  localeinfo_struct local_20;\n  char local_10;\n  \n  if (DAT_140037280 != 0) {\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,(__crt_locale_pointers *)0x0);\n    if (param_3 == 0) {\n      iVar4 = 0;\n    }\n    else if ((param_1 == (byte *)0x0) || (param_2 == (byte *)0x0)) {\n      puVar6 = __doserrno();\n      *puVar6 = 0x16;\n      FUN_14000d030();\n      iVar4 = 0x7fffffff;\n    }\n    else {\n      iVar4 = 0x7fffffff;\n      if (param_3 < 0x80000000) {\n        if ((local_20.locinfo)->locale_name[1] == (wchar_t *)0x0) {\n          iVar4 = _strnicmp_l((char *)param_1,(char *)param_2,param_3,&local_20);\n        }\n        else {\n          iVar5 = __acrt_CompareStringA\n                            ((__crt_locale_pointers *)&local_20,(local_20.locinfo)->locale_name[1],\n                             0x1001,(char *)param_1,(int)param_3,(char *)param_2,(int)param_3,\n                             *(int *)((longlong)&(local_20.locinfo)->lc_category[0].locale + 4));\n          if (iVar5 == 0) {\n            puVar6 = __doserrno();\n            *puVar6 = 0x16;\n          }\n          else {\n            iVar4 = iVar5 + -2;\n          }\n        }\n      }\n      else {\n        puVar6 = __doserrno();\n        *puVar6 = 0x16;\n        FUN_14000d030();\n      }\n    }\n    if (local_10 != '\\0') {\n      *(uint *)(local_28 + 0x3a8) = *(uint *)(local_28 + 0x3a8) & 0xfffffffd;\n    }\n    return iVar4;\n  }\n  if (((param_1 != (byte *)0x0) && (param_2 != (byte *)0x0)) && (param_3 < 0x80000000)) {\n    if (param_3 != 0) {\n      do {\n        bVar1 = *param_1;\n        bVar2 = *param_2;\n        uVar3 = bVar1 + 0x20;\n        if (0x19 < bVar1 - 0x41) {\n          uVar3 = (uint)bVar1;\n        }\n        param_1 = param_1 + 1;\n        param_2 = param_2 + 1;\n        uVar7 = bVar2 + 0x20;\n        if (0x19 < bVar2 - 0x41) {\n          uVar7 = (uint)bVar2;\n        }\n      } while (((uVar3 - uVar7 == 0) && (uVar3 != 0)) && (param_3 = param_3 - 1, param_3 != 0));\n      return uVar3 - uVar7;\n    }\n    return 0;\n  }\n  puVar6 = __doserrno();\n  *puVar6 = 0x16;\n  FUN_14000d030();\n  return 0x7fffffff;\n}\n\n",
  "_IsExceptionObjectToBeDestroyed": "\n/* Library Function - Single Match\n    _IsExceptionObjectToBeDestroyed\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined4 _IsExceptionObjectToBeDestroyed(longlong param_1)\n\n{\n  longlong lVar1;\n  longlong *plVar2;\n  \n  lVar1 = FUN_140008b20();\n  plVar2 = *(longlong **)(lVar1 + 0x58);\n  while( true ) {\n    if (plVar2 == (longlong *)0x0) {\n      return 1;\n    }\n    if (*plVar2 == param_1) break;\n    plVar2 = (longlong *)plVar2[1];\n  }\n  return 0;\n}\n\n",
  "__security_init_cookie": "\n/* Library Function - Single Match\n    __security_init_cookie\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl __security_init_cookie(void)\n\n{\n  DWORD DVar1;\n  _FILETIME local_res8;\n  _FILETIME local_res10;\n  LARGE_INTEGER local_res18;\n  \n  if (DAT_140035020 == 0x2b992ddfa232) {\n    local_res10.dwLowDateTime = 0;\n    local_res10.dwHighDateTime = 0;\n    GetSystemTimeAsFileTime(&local_res10);\n    local_res8 = local_res10;\n    DVar1 = GetCurrentThreadId();\n    local_res8 = (_FILETIME)((ulonglong)local_res8 ^ (ulonglong)DVar1);\n    DVar1 = GetCurrentProcessId();\n    local_res8 = (_FILETIME)((ulonglong)local_res8 ^ (ulonglong)DVar1);\n    QueryPerformanceCounter(&local_res18);\n    DAT_140035020 =\n         ((ulonglong)local_res18.s.LowPart << 0x20 ^\n          CONCAT44(local_res18.s.HighPart,local_res18.s.LowPart) ^ (ulonglong)local_res8 ^\n         (ulonglong)&local_res8) & 0xffffffffffff;\n    if (DAT_140035020 == 0x2b992ddfa232) {\n      DAT_140035020 = 0x2b992ddfa233;\n    }\n  }\n  DAT_140035018 = ~DAT_140035020;\n  return;\n}\n\n",
  "__vcrt_getptd_noexit": "\n/* Library Function - Single Match\n    __vcrt_getptd_noexit\n   \n   Library: Visual Studio 2019 Release */\n\nLPVOID __vcrt_getptd_noexit(void)\n\n{\n  DWORD dwErrCode;\n  int iVar1;\n  LPVOID pvVar2;\n  LPVOID pvVar3;\n  LPVOID pvVar4;\n  \n  if (DAT_140035050 == 0xffffffff) {\n    pvVar3 = (LPVOID)0x0;\n  }\n  else {\n    dwErrCode = GetLastError();\n    pvVar2 = (LPVOID)__vcrt_FlsGetValue(DAT_140035050);\n    pvVar4 = (LPVOID)0x0;\n    pvVar3 = pvVar4;\n    if (((pvVar2 != (LPVOID)0xffffffffffffffff) && (pvVar3 = pvVar2, pvVar2 == (LPVOID)0x0)) &&\n       (iVar1 = __vcrt_FlsSetValue(DAT_140035050,(LPVOID)0xffffffffffffffff), pvVar3 = pvVar4,\n       iVar1 != 0)) {\n      pvVar3 = _calloc_base(1,0x80);\n      if ((pvVar3 == (LPVOID)0x0) || (iVar1 = __vcrt_FlsSetValue(DAT_140035050,pvVar3), iVar1 == 0))\n      {\n        __vcrt_FlsSetValue(DAT_140035050,(LPVOID)0x0);\n        pvVar2 = pvVar3;\n      }\n      else {\n        *(undefined4 *)((longlong)pvVar3 + 0x78) = 0xfffffffe;\n        pvVar2 = pvVar4;\n        pvVar4 = pvVar3;\n      }\n      FUN_14000ce08(pvVar2);\n      pvVar3 = pvVar4;\n    }\n    SetLastError(dwErrCode);\n  }\n  return pvVar3;\n}\n\n",
  "InternalCompareStringA": "\n/* WARNING: Function: __chkstk replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    int __cdecl InternalCompareStringA(struct __crt_locale_pointers * __ptr64,wchar_t const *\n   __ptr64,unsigned long,char const * __ptr64,int,char const * __ptr64,int,int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl\nInternalCompareStringA\n          (__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5,\n          char *param_6,int param_7,int param_8)\n\n{\n  longlong lVar1;\n  ulong uVar2;\n  wchar_t *pwVar3;\n  BOOL BVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  size_t sVar8;\n  BYTE *pBVar9;\n  ulonglong uVar10;\n  PCNZWCH pWVar11;\n  undefined4 *puVar12;\n  ulonglong uVar13;\n  undefined *puVar14;\n  undefined *puVar15;\n  undefined *puVar16;\n  undefined *puVar17;\n  undefined auStackY_c8 [32];\n  ulong local_78 [2];\n  wchar_t *local_70;\n  _cpinfo local_68;\n  ulonglong local_50;\n  \n  puVar14 = auStackY_c8;\n  puVar16 = auStackY_c8;\n  local_50 = DAT_140035020 ^ (ulonglong)local_78;\n  local_78[0] = param_3;\n  local_70 = param_2;\n  if (param_5 < 1) {\n    puVar17 = auStackY_c8;\n    if (param_5 < -1) goto LAB_1400219e0;\n  }\n  else {\n    sVar8 = __strncnt(param_4,(longlong)param_5);\n    param_5 = (int)sVar8;\n  }\n  if (param_7 < 1) {\n    puVar17 = auStackY_c8;\n    if (param_7 < -1) goto LAB_1400219e0;\n  }\n  else {\n    sVar8 = __strncnt(param_6,(longlong)param_7);\n    param_7 = (int)sVar8;\n  }\n  if (param_8 == 0) {\n    param_8 = *(UINT *)(*(longlong *)param_1 + 0xc);\n  }\n  if ((param_5 == 0) || (param_7 == 0)) {\n    puVar17 = auStackY_c8;\n    if ((param_5 == param_7) ||\n       (((puVar17 = auStackY_c8, 1 < param_7 || (puVar17 = auStackY_c8, 1 < param_5)) ||\n        (BVar4 = GetCPInfo(param_8,&local_68), puVar17 = auStackY_c8, BVar4 == 0))))\n    goto LAB_1400219e0;\n    if (0 < param_5) {\n      puVar17 = auStackY_c8;\n      if (1 < local_68.MaxCharSize) {\n        pBVar9 = local_68.LeadByte;\n        while (((puVar17 = auStackY_c8, local_68.LeadByte[0] != 0 &&\n                (puVar17 = auStackY_c8, pBVar9[1] != 0)) &&\n               (((byte)*param_4 < *pBVar9 || (puVar17 = auStackY_c8, pBVar9[1] < (byte)*param_4)))))\n        {\n          pBVar9 = pBVar9 + 2;\n          local_68.LeadByte[0] = *pBVar9;\n        }\n      }\n      goto LAB_1400219e0;\n    }\n    if (0 < param_7) {\n      puVar17 = auStackY_c8;\n      if (1 < local_68.MaxCharSize) {\n        pBVar9 = local_68.LeadByte;\n        while (((puVar17 = auStackY_c8, local_68.LeadByte[0] != 0 &&\n                (puVar17 = auStackY_c8, pBVar9[1] != 0)) &&\n               (((byte)*param_6 < *pBVar9 || (puVar17 = auStackY_c8, pBVar9[1] < (byte)*param_6)))))\n        {\n          pBVar9 = pBVar9 + 2;\n          local_68.LeadByte[0] = *pBVar9;\n        }\n      }\n      goto LAB_1400219e0;\n    }\n  }\n  iVar7 = __acrt_MultiByteToWideChar(param_8,9,param_4,param_5,(LPWSTR)0x0,0);\n  puVar17 = auStackY_c8;\n  if (iVar7 == 0) goto LAB_1400219e0;\n  uVar13 = (longlong)iVar7 * 2 + 0x10;\n  uVar13 = -(ulonglong)((ulonglong)((longlong)iVar7 * 2) < uVar13) & uVar13;\n  if (uVar13 == 0) {\n    pWVar11 = (PCNZWCH)0x0;\nLAB_140021885:\n    if (pWVar11 != (PCNZWCH)0x0) {\n      *(int *)(puVar16 + 0x28) = iVar7;\n      *(PCNZWCH *)(puVar16 + 0x20) = pWVar11;\n      *(undefined8 *)(puVar16 + -8) = 0x1400218ab;\n      iVar5 = __acrt_MultiByteToWideChar\n                        (param_8,1,param_4,param_5,*(LPWSTR *)(puVar16 + 0x20),\n                         *(int *)(puVar16 + 0x28));\n      if (iVar5 != 0) {\n        *(undefined4 *)(puVar16 + 0x28) = 0;\n        *(undefined8 *)(puVar16 + 0x20) = 0;\n        *(undefined8 *)(puVar16 + -8) = 0x1400218d1;\n        iVar5 = __acrt_MultiByteToWideChar\n                          (param_8,9,param_6,param_7,*(LPWSTR *)(puVar16 + 0x20),\n                           *(int *)(puVar16 + 0x28));\n        if (iVar5 != 0) {\n          uVar13 = (longlong)iVar5 * 2 + 0x10;\n          uVar13 = -(ulonglong)((ulonglong)((longlong)iVar5 * 2) < uVar13) & uVar13;\n          if (uVar13 == 0) {\n            puVar12 = (undefined4 *)0x0;\nLAB_140021949:\n            if (puVar12 != (undefined4 *)0x0) {\n              *(int *)(puVar16 + 0x28) = iVar5;\n              *(undefined4 **)(puVar16 + 0x20) = puVar12;\n              *(undefined8 *)(puVar16 + -8) = 0x14002196b;\n              iVar6 = __acrt_MultiByteToWideChar\n                                (param_8,1,param_6,param_7,*(LPWSTR *)(puVar16 + 0x20),\n                                 *(int *)(puVar16 + 0x28));\n              if (iVar6 != 0) {\n                *(undefined8 *)(puVar16 + 0x40) = 0;\n                *(undefined8 *)(puVar16 + 0x38) = 0;\n                *(undefined8 *)(puVar16 + 0x30) = 0;\n                pwVar3 = local_70;\n                uVar2 = local_78[0];\n                *(int *)(puVar16 + 0x28) = iVar5;\n                *(undefined4 **)(puVar16 + 0x20) = puVar12;\n                *(undefined8 *)(puVar16 + -8) = 0x14002199d;\n                __acrt_CompareStringEx\n                          ((ushort *)pwVar3,uVar2,pWVar11,iVar7,*(PCNZWCH *)(puVar16 + 0x20),\n                           *(int *)(puVar16 + 0x28),*(undefined8 *)(puVar16 + 0x30),\n                           *(undefined8 *)(puVar16 + 0x38),*(undefined8 *)(puVar16 + 0x40));\n              }\n            }\n          }\n          else {\n            if (0x400 < uVar13) {\n              *(undefined8 *)(puVar16 + -8) = 0x140021933;\n              puVar12 = (undefined4 *)_malloc_base(uVar13);\n              if (puVar12 != (undefined4 *)0x0) {\n                *puVar12 = 0xdddd;\n                goto LAB_140021941;\n              }\n              goto LAB_140021949;\n            }\n            uVar10 = uVar13 + 0xf;\n            if (uVar10 <= uVar13) {\n              uVar10 = 0xffffffffffffff0;\n            }\n            *(undefined8 *)(puVar16 + -8) = 0x140021916;\n            lVar1 = -(uVar10 & 0xfffffffffffffff0);\n            puVar15 = puVar16 + lVar1;\n            puVar12 = (undefined4 *)(puVar16 + lVar1 + 0x50);\n            puVar16 = puVar16 + lVar1;\n            if (puVar12 != (undefined4 *)0x0) {\n              *puVar12 = 0xcccc;\n              puVar16 = puVar15;\nLAB_140021941:\n              puVar12 = puVar12 + 4;\n              goto LAB_140021949;\n            }\n          }\n          if ((puVar12 != (undefined4 *)0x0) && (puVar12[-4] == 0xdddd)) {\n            *(undefined8 *)(puVar16 + -8) = 0x1400219b9;\n            _free_base(puVar12 + -4);\n          }\n        }\n      }\n    }\n  }\n  else {\n    if (0x400 < uVar13) {\n      pWVar11 = (PCNZWCH)_malloc_base(uVar13);\n      puVar16 = auStackY_c8;\n      if (pWVar11 != (PCNZWCH)0x0) {\n        *(undefined4 *)pWVar11 = 0xdddd;\n        goto LAB_14002187d;\n      }\n      goto LAB_140021885;\n    }\n    uVar10 = uVar13 + 0xf;\n    if (uVar10 <= uVar13) {\n      uVar10 = 0xffffffffffffff0;\n    }\n    lVar1 = -(uVar10 & 0xfffffffffffffff0);\n    puVar16 = auStackY_c8 + lVar1;\n    puVar14 = auStackY_c8 + lVar1;\n    pWVar11 = (PCNZWCH)((longlong)local_78 + lVar1);\n    if (pWVar11 != (PCNZWCH)0x0) {\n      *(undefined4 *)pWVar11 = 0xcccc;\nLAB_14002187d:\n      pWVar11 = pWVar11 + 8;\n      puVar16 = puVar14;\n      goto LAB_140021885;\n    }\n  }\n  puVar17 = puVar16;\n  if ((pWVar11 != (PCNZWCH)0x0) && (*(int *)(pWVar11 + -8) == 0xdddd)) {\n    *(undefined8 *)(puVar16 + -8) = 0x1400219d3;\n    _free_base(pWVar11 + -8);\n  }\nLAB_1400219e0:\n  uVar13 = local_50 ^ (ulonglong)local_78;\n  *(undefined8 *)(puVar17 + -8) = 0x1400219ec;\n  iVar7 = FUN_140006060(uVar13);\n  return iVar7;\n}\n\n",
  "do_toupper": "\n/* Library Function - Single Match\n    protected: virtual char __cdecl std::ctype<char>::do_toupper(char)const __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nchar __thiscall std::ctype<char>::do_toupper(ctype<char> *this,char param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = _Toupper((uint)(byte)param_1,(_Ctypevec *)(this + 0x10));\n  return (char)iVar1;\n}\n\n",
  "__scrt_is_managed_app": "\n/* Library Function - Single Match\n    __scrt_is_managed_app\n   \n   Library: Visual Studio 2019 Release */\n\nulonglong __scrt_is_managed_app(void)\n\n{\n  HMODULE pHVar1;\n  ulonglong uVar2;\n  int *piVar3;\n  \n  pHVar1 = GetModuleHandleW((LPCWSTR)0x0);\n  if ((((pHVar1 == (HMODULE)0x0) || (*(short *)&pHVar1->unused != 0x5a4d)) ||\n      (piVar3 = (int *)((longlong)&pHVar1->unused + (longlong)pHVar1[0xf].unused), *piVar3 != 0x4550\n      )) || (((pHVar1 = (HMODULE)0x20b, *(short *)(piVar3 + 6) != 0x20b ||\n              ((uint)piVar3[0x21] < 0xf)) || (piVar3[0x3e] == 0)))) {\n    uVar2 = (ulonglong)pHVar1 & 0xffffffffffffff00;\n  }\n  else {\n    uVar2 = 0x201;\n  }\n  return uVar2;\n}\n\n",
  "DecompFuncInfo": "\n/* Library Function - Single Match\n    __int64 __cdecl FH4::DecompFuncInfo(unsigned char * __ptr64,struct FH4::FuncInfo4 &\n   __ptr64,unsigned __int64,int,bool)\n   \n   Library: Visual Studio 2019 Release */\n\n__int64 __cdecl\nFH4::DecompFuncInfo(uchar *param_1,FuncInfo4 *param_2,__uint64 param_3,int param_4,bool param_5)\n\n{\n  byte *pbVar1;\n  FuncInfo4 FVar2;\n  byte bVar3;\n  undefined4 uVar4;\n  int iVar5;\n  uint uVar6;\n  byte *pbVar7;\n  uint uVar8;\n  byte *pbVar9;\n  \n  FVar2 = (FuncInfo4)*param_1;\n  pbVar9 = param_1 + 1;\n  *param_2 = FVar2;\n  if (((byte)FVar2 & 4) != 0) {\n    bVar3 = *pbVar9;\n    pbVar9 = pbVar9 + -(longlong)(char)(&DAT_140024780)[bVar3 & 0xf];\n    *(uint *)(param_2 + 4) = *(uint *)(pbVar9 + -4) >> ((&DAT_140024790)[bVar3 & 0xf] & 0x1f);\n  }\n  if (((byte)FVar2 & 8) != 0) {\n    uVar4 = *(undefined4 *)pbVar9;\n    pbVar9 = pbVar9 + 4;\n    *(undefined4 *)(param_2 + 8) = uVar4;\n  }\n  if (((byte)FVar2 & 0x10) != 0) {\n    uVar4 = *(undefined4 *)pbVar9;\n    pbVar9 = pbVar9 + 4;\n    *(undefined4 *)(param_2 + 0xc) = uVar4;\n  }\n  pbVar7 = pbVar9 + 4;\n  uVar8 = 0;\n  if ((param_5) || (((byte)FVar2 & 2) == 0)) {\n    *(int *)(param_2 + 0x10) = *(int *)pbVar9;\n  }\n  else {\n    pbVar9 = (byte *)((longlong)*(int *)pbVar9 + param_3);\n    uVar6 = *pbVar9 & 0xf;\n    bVar3 = (&DAT_140024790)[uVar6];\n    pbVar9 = pbVar9 + -(longlong)(char)(&DAT_140024780)[uVar6];\n    uVar6 = *(uint *)(pbVar9 + -4);\n    *(undefined4 *)(param_2 + 0x10) = 0;\n    if (uVar6 >> (bVar3 & 0x1f) != 0) {\n      do {\n        iVar5 = *(int *)pbVar9;\n        pbVar1 = pbVar9 + 4;\n        pbVar9 = pbVar9 + 8;\n        if (iVar5 == param_4) {\n          *(undefined4 *)(param_2 + 0x10) = *(undefined4 *)pbVar1;\n          break;\n        }\n        uVar8 = uVar8 + 1;\n      } while (uVar8 < uVar6 >> (bVar3 & 0x1f));\n    }\n  }\n  if (((byte)FVar2 & 1) != 0) {\n    bVar3 = *pbVar7;\n    pbVar7 = pbVar7 + -(longlong)(char)(&DAT_140024780)[bVar3 & 0xf];\n    *(uint *)(param_2 + 0x14) = *(uint *)(pbVar7 + -4) >> ((&DAT_140024790)[bVar3 & 0xf] & 0x1f);\n  }\n  return (longlong)pbVar7 - (longlong)param_1;\n}\n\n",
  "capture_current_context": "\n/* Library Function - Single Match\n    capture_current_context\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid capture_current_context(PCONTEXT param_1)\n\n{\n  DWORD64 ControlPc;\n  PRUNTIME_FUNCTION FunctionEntry;\n  DWORD64 local_res8;\n  ulonglong local_res10;\n  PVOID local_res18;\n  \n  RtlCaptureContext();\n  ControlPc = param_1->Rip;\n  FunctionEntry = RtlLookupFunctionEntry(ControlPc,&local_res8,(PUNWIND_HISTORY_TABLE)0x0);\n  if (FunctionEntry != (PRUNTIME_FUNCTION)0x0) {\n    RtlVirtualUnwind(0,local_res8,ControlPc,FunctionEntry,param_1,&local_res18,&local_res10,\n                     (PKNONVOLATILE_CONTEXT_POINTERS)0x0);\n  }\n  return;\n}\n\n",
  "_fileno": "\n/* Library Function - Single Match\n    _fileno\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _fileno(FILE *_File)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  \n  if (_File == (FILE *)0x0) {\n    puVar2 = __doserrno();\n    *puVar2 = 0x16;\n    FUN_14000d030();\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = _File->_flag;\n  }\n  return iVar1;\n}\n\n",
  "wcsncat_s": "\n/* Library Function - Single Match\n    wcsncat_s\n   \n   Library: Visual Studio 2019 Release */\n\nerrno_t __cdecl wcsncat_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src,rsize_t _MaxCount)\n\n{\n  wchar_t wVar1;\n  ulong *puVar2;\n  wchar_t *pwVar3;\n  rsize_t rVar4;\n  ulong uVar5;\n  rsize_t rVar6;\n  longlong lVar7;\n  \n  if (_MaxCount == 0) {\n    if (_Dst == (wchar_t *)0x0) {\n      if (_SizeInWords == 0) {\n        return 0;\n      }\n    }\n    else {\nLAB_14001d581:\n      if (_SizeInWords != 0) {\n        pwVar3 = _Dst;\n        rVar4 = _SizeInWords;\n        if ((_MaxCount == 0) || (_Src != (wchar_t *)0x0)) {\n          do {\n            if (*pwVar3 == L'\\0') break;\n            pwVar3 = pwVar3 + 1;\n            rVar4 = rVar4 - 1;\n          } while (rVar4 != 0);\n          if (rVar4 != 0) {\n            if (_MaxCount == 0xffffffffffffffff) {\n              lVar7 = (longlong)_Src - (longlong)pwVar3;\n              do {\n                wVar1 = *(wchar_t *)(lVar7 + (longlong)pwVar3);\n                *pwVar3 = wVar1;\n                pwVar3 = pwVar3 + 1;\n                if (wVar1 == L'\\0') break;\n                rVar4 = rVar4 - 1;\n              } while (rVar4 != 0);\n            }\n            else {\n              rVar6 = _MaxCount;\n              if (_MaxCount != 0) {\n                do {\n                  wVar1 = *_Src;\n                  _Src = _Src + 1;\n                  *pwVar3 = wVar1;\n                  pwVar3 = pwVar3 + 1;\n                  if ((wVar1 == L'\\0') || (rVar4 = rVar4 - 1, rVar4 == 0)) break;\n                  rVar6 = rVar6 - 1;\n                } while (rVar6 != 0);\n              }\n              if (rVar6 == 0) {\n                *pwVar3 = L'\\0';\n              }\n            }\n            if (rVar4 != 0) {\n              return 0;\n            }\n            if (_MaxCount == 0xffffffffffffffff) {\n              _Dst[_SizeInWords - 1] = L'\\0';\n              return 0x50;\n            }\n            *_Dst = L'\\0';\n            puVar2 = __doserrno();\n            uVar5 = 0x22;\n            goto LAB_14001d564;\n          }\n          *_Dst = L'\\0';\n        }\n        else {\n          *_Dst = L'\\0';\n        }\n      }\n    }\n  }\n  else if (_Dst != (wchar_t *)0x0) goto LAB_14001d581;\n  puVar2 = __doserrno();\n  uVar5 = 0x16;\nLAB_14001d564:\n  *puVar2 = uVar5;\n  FUN_14000d030();\n  return uVar5;\n}\n\n",
  "FUN_1400147bc": "\nundefined8 FUN_1400147bc(void)\n\n{\n  uint uVar1;\n  ulonglong uVar2;\n  \n  LOCK();\n  uVar1 = *DAT_1400379c0;\n  uVar2 = (ulonglong)uVar1;\n  *DAT_1400379c0 = *DAT_1400379c0 - 1;\n  UNLOCK();\n  if ((uVar1 == 1) && (DAT_1400379c0 != (uint *)&DAT_1400355c0)) {\n    uVar2 = _free_base(DAT_1400379c0);\n    DAT_1400379c0 = (uint *)&DAT_1400355c0;\n  }\n  return CONCAT71((int7)(uVar2 >> 8),1);\n}\n\n",
  "_mbstowcs_s_l": "\n/* Library Function - Single Match\n    _mbstowcs_s_l\n   \n   Library: Visual Studio 2019 Release */\n\nerrno_t __cdecl\n_mbstowcs_s_l(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,char *_SrcBuf,\n             size_t _MaxCount,_locale_t _Locale)\n\n{\n  ulong *puVar1;\n  __uint64 _Var2;\n  ulonglong uVar3;\n  ulong uVar4;\n  size_t sVar5;\n  longlong local_38;\n  __crt_locale_pointers local_30 [16];\n  char local_20;\n  \n  uVar4 = 0;\n  if (_DstBuf == (wchar_t *)0x0) {\n    if (_SizeInWords != 0) {\nLAB_140018a55:\n      puVar1 = __doserrno();\n      *puVar1 = 0x16;\n      FUN_14000d030();\n      return 0x16;\n    }\n  }\n  else if (_SizeInWords == 0) goto LAB_140018a55;\n  if (_DstBuf != (wchar_t *)0x0) {\n    *_DstBuf = L'\\0';\n  }\n  if (_PtNumOfCharConverted != (size_t *)0x0) {\n    *_PtNumOfCharConverted = 0;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_38,(__crt_locale_pointers *)_Locale);\n  sVar5 = _MaxCount;\n  if (_SizeInWords < _MaxCount) {\n    sVar5 = _SizeInWords;\n  }\n  if (sVar5 < 0x80000000) {\n    _Var2 = _mbstowcs_l_helper(_DstBuf,_SrcBuf,sVar5,local_30);\n    if (_Var2 == 0xffffffffffffffff) {\n      if (_DstBuf != (wchar_t *)0x0) {\n        *_DstBuf = L'\\0';\n      }\n      puVar1 = __doserrno();\n      uVar4 = *puVar1;\n      goto LAB_140018ad8;\n    }\n    uVar3 = _Var2 + 1;\n    if (_DstBuf != (wchar_t *)0x0) {\n      if (_SizeInWords < uVar3) {\n        if (_MaxCount != 0xffffffffffffffff) {\n          *_DstBuf = L'\\0';\n          puVar1 = __doserrno();\n          uVar4 = 0x22;\n          goto LAB_140018ab9;\n        }\n        uVar4 = 0x50;\n        uVar3 = _SizeInWords;\n      }\n      _DstBuf[uVar3 - 1] = L'\\0';\n    }\n    if (_PtNumOfCharConverted != (size_t *)0x0) {\n      *_PtNumOfCharConverted = uVar3;\n    }\n  }\n  else {\n    puVar1 = __doserrno();\n    uVar4 = 0x16;\nLAB_140018ab9:\n    *puVar1 = uVar4;\n    FUN_14000d030();\n  }\nLAB_140018ad8:\n  if (local_20 != '\\0') {\n    *(uint *)(local_38 + 0x3a8) = *(uint *)(local_38 + 0x3a8) & 0xfffffffd;\n  }\n  return uVar4;\n}\n\n",
  "_guard_dispatch_icall": "\n/* WARNING: This is an inlined function */\n\nvoid _guard_dispatch_icall(void)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  \n                    /* WARNING: Could not recover jumptable at 0x000140021e60. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
  "setSBCS": "\n/* Library Function - Single Match\n    void __cdecl setSBCS(struct __crt_multibyte_data * __ptr64)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl setSBCS(__crt_multibyte_data *param_1)\n\n{\n  longlong lVar1;\n  __crt_multibyte_data *p_Var2;\n  longlong lVar3;\n  __crt_multibyte_data *p_Var4;\n  \n  p_Var2 = param_1 + 0x18;\n  lVar3 = 0x101;\n  FUN_140008580((undefined (*) [16])p_Var2,0,0x101);\n  *(undefined8 *)(param_1 + 4) = 0;\n  *(undefined8 *)(param_1 + 0x220) = 0;\n  p_Var4 = param_1 + 0xc;\n  for (lVar1 = 6; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *(undefined2 *)p_Var4 = 0;\n    p_Var4 = p_Var4 + 2;\n  }\n  do {\n    *p_Var2 = p_Var2[(longlong)&DAT_1400355c0 - (longlong)param_1];\n    p_Var2 = p_Var2 + 1;\n    lVar3 = lVar3 + -1;\n  } while (lVar3 != 0);\n  p_Var2 = param_1 + 0x119;\n  lVar1 = 0x100;\n  do {\n    *p_Var2 = p_Var2[(longlong)&DAT_1400355c0 - (longlong)param_1];\n    p_Var2 = p_Var2 + 1;\n    lVar1 = lVar1 + -1;\n  } while (lVar1 != 0);\n  return;\n}\n\n",
  "__acrt_errno_map_os_error": "\n/* Library Function - Single Match\n    __acrt_errno_map_os_error\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_errno_map_os_error(int param_1)\n\n{\n  undefined4 uVar1;\n  ulonglong uVar2;\n  int *piVar3;\n  undefined4 *puVar4;\n  \n  uVar2 = __acrt_getptd_noexit();\n  if (uVar2 == 0) {\n    piVar3 = &DAT_140035064;\n  }\n  else {\n    piVar3 = (int *)(uVar2 + 0x24);\n  }\n  *piVar3 = param_1;\n  uVar2 = __acrt_getptd_noexit();\n  puVar4 = (undefined4 *)&DAT_140035060;\n  if (uVar2 != 0) {\n    puVar4 = (undefined4 *)(uVar2 + 0x20);\n  }\n  uVar1 = __acrt_errno_from_os_error(param_1);\n  *puVar4 = uVar1;\n  return;\n}\n\n",
  "construct_ptd_array": "\n/* Library Function - Single Match\n    void __cdecl construct_ptd_array(struct __acrt_ptd * __ptr64 const)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl construct_ptd_array(__acrt_ptd *param_1)\n\n{\n  undefined local_res10 [8];\n  int local_res18 [2];\n  int local_res20 [2];\n  int local_38 [2];\n  __acrt_ptd *local_30;\n  undefined8 *local_28;\n  __acrt_ptd **local_20;\n  __acrt_ptd **local_18;\n  undefined8 **local_10;\n  \n  local_20 = &local_30;\n  local_res18[0] = 5;\n  local_res20[0] = 5;\n  local_18 = &local_30;\n  local_10 = &local_28;\n  local_38[0] = 4;\n  local_38[1] = 4;\n  local_28 = &DAT_1400372c0;\n  *(undefined4 *)(param_1 + 0x28) = 1;\n  *(undefined **)param_1 = &DAT_140027e30;\n  *(undefined4 *)(param_1 + 0x3a8) = 1;\n  *(undefined **)(param_1 + 0x88) = &DAT_1400355c0;\n  *(undefined2 *)(param_1 + 0xbc) = 0x43;\n  *(undefined2 *)(param_1 + 0x1c2) = 0x43;\n  *(undefined8 *)(param_1 + 0x3a0) = 0;\n  local_30 = param_1;\n  operator()<>(local_res10,local_res20,(longlong **)&local_20,local_res18);\n  operator()<>(local_res10,local_38 + 1,&local_18,local_38);\n  return;\n}\n\n",
  "common_ftell_read_mode_nolock": "\n/* Library Function - Single Match\n    __int64 __cdecl common_ftell_read_mode_nolock(class __crt_stdio_stream,__int64,__int64)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nlonglong __cdecl common_ftell_read_mode_nolock(FILE *param_1,longlong param_2,longlong param_3)\n\n{\n  char cVar1;\n  uint uVar2;\n  __int64 _Var3;\n  ulonglong uVar4;\n  char *pcVar5;\n  char *pcVar6;\n  undefined8 uVar7;\n  longlong lVar8;\n  bool bVar9;\n  \n  uVar2 = _fileno(param_1);\n  uVar4 = (ulonglong)(uVar2 & 0x3f);\n  cVar1 = *(char *)((&DAT_140037490)[(longlong)(int)uVar2 >> 6] + 0x39 + uVar4 * 0x48);\n  lVar8 = (ulonglong)(cVar1 == '\\x01') + 1;\n  if (*(int *)&param_1->_base != 0) {\n    pcVar6 = param_1->_ptr + ((longlong)*(int *)&param_1->_base - *(longlong *)&param_1->_cnt);\n    if (*(char *)((&DAT_140037490)[(longlong)(int)uVar2 >> 6] + 0x38 + uVar4 * 0x48) < '\\0') {\n      uVar7 = 0;\n      _Var3 = common_lseek<__int64>(uVar2,0,2);\n      if (_Var3 == param_2) {\n        _Var3 = count_newline_bytes(*(char **)&param_1->_cnt,\n                                    *(char **)&param_1->_cnt + (longlong)pcVar6,\n                                    (__crt_lowio_text_mode)\n                                    CONCAT71((int7)((ulonglong)uVar7 >> 8),cVar1));\n        bVar9 = (*(uint *)((longlong)&param_1->_base + 4) >> 5 & 1) == 0;\n        pcVar6 = pcVar6 + _Var3;\n      }\n      else {\n        _Var3 = common_lseek<__int64>(uVar2,param_2,0);\n        if (_Var3 == -1) {\n          return -1;\n        }\n        pcVar5 = (char *)0x200;\n        if (((0x200 < (longlong)pcVar6) ||\n            ((*(uint *)((longlong)&param_1->_base + 4) >> 6 & 1) == 0)) ||\n           ((*(uint *)((longlong)&param_1->_base + 4) >> 8 & 1) != 0)) {\n          pcVar5 = (char *)(longlong)param_1->_charbuf;\n        }\n        bVar9 = (*(byte *)((&DAT_140037490)[(longlong)(int)uVar2 >> 6] + 0x38 + uVar4 * 0x48) & 4)\n                == 0;\n        pcVar6 = pcVar5;\n      }\n      if (!bVar9) {\n        pcVar6 = pcVar6 + (ulonglong)((byte)(cVar1 - 1U) < 2) + 1;\n      }\n    }\n    param_2 = (param_3 / lVar8 - (longlong)pcVar6 / lVar8) + param_2;\n  }\n  return param_2;\n}\n\n",
  "_ismbblead": "\n/* Library Function - Single Match\n    _ismbblead\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _ismbblead(uint _C)\n\n{\n  int iVar1;\n  \n  iVar1 = x_ismbbtype_l((__crt_locale_pointers *)0x0,_C,0,4);\n  return iVar1;\n}\n\n",
  "FUN_1400013a0": "\nundefined8 * FUN_1400013a0(undefined8 *param_1,longlong param_2)\n\n{\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  __std_exception_copy((char **)(param_2 + 8),(char **)(param_1 + 1));\n  *param_1 = std::runtime_error::vftable;\n  return param_1;\n}\n\n",
  "FUN_140005d44": "\nundefined8 * FUN_140005d44(void)\n\n{\n  return &DAT_140036630;\n}\n\n",
  "_wsetlocale": "\n/* Library Function - Single Match\n    _wsetlocale\n   \n   Library: Visual Studio 2019 Release */\n\nwchar_t * __cdecl _wsetlocale(int _Category,wchar_t *_Locale)\n\n{\n  ulong *puVar1;\n  int local_res8 [2];\n  wchar_t *local_res10;\n  <lambda_7f2adfce497ff2baa965cd4f576ecfd1> local_res18 [8];\n  longlong local_res20;\n  wchar_t *local_48;\n  undefined8 local_40;\n  longlong *local_38;\n  undefined8 *local_30;\n  longlong *local_28;\n  wchar_t **local_20;\n  int *local_18;\n  wchar_t **local_10;\n  \n  local_48 = (wchar_t *)0x0;\n  local_40 = 0;\n  local_res8[0] = _Category;\n  local_res10 = _Locale;\n  if ((uint)_Category < 6) {\n    local_res20 = FUN_140014d84();\n    __acrt_eagerly_load_locale_apis();\n    __acrt_update_thread_locale_data();\n    *(uint *)(local_res20 + 0x3a8) = *(uint *)(local_res20 + 0x3a8) | 0x10;\n    local_38 = &local_res20;\n    local_30 = &local_40;\n    local_28 = &local_res20;\n    local_20 = &local_48;\n    local_18 = local_res8;\n    local_10 = &local_res10;\n    __crt_seh_guarded_call<void>::\n    operator()<class_<lambda_7f2adfce497ff2baa965cd4f576ecfd1>,class_<lambda_2a444430fde8c29194d880d93eed5e8f>&___ptr64,class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&___ptr64>\n              ((__crt_seh_guarded_call<void> *)local_res18,local_res18,\n               (<lambda_2a444430fde8c29194d880d93eed5e8f> *)&local_30,\n               (<lambda_8dff2cf36a5417162780cd64fa2883ef> *)&local_38);\n  }\n  else {\n    puVar1 = __doserrno();\n    *puVar1 = 0x16;\n    FUN_14000d030();\n    local_48 = (wchar_t *)0x0;\n  }\n  return local_48;\n}\n\n",
  "FUN_1400220c0": "\nundefined8 FUN_1400220c0(void)\n\n{\n  return 0;\n}\n\n",
  "FUN_140003a44": "\nvoid FUN_140003a44(char *param_1)\n\n{\n  undefined8 local_28 [5];\n  \n  FUN_140003870(local_28,param_1);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_28,(ThrowInfo *)&DAT_1400339c8);\n}\n\n",
  "FUN_140022818": "\nundefined8 FUN_140022818(int **param_1)\n\n{\n  undefined8 uVar1;\n  \n  if ((**param_1 == -0x3ffffffb) || (**param_1 == -0x3fffffe3)) {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = 0;\n  }\n  return uVar1;\n}\n\n",
  "FUN_14000459c": "\nulonglong FUN_14000459c(undefined8 param_1,undefined8 param_2,longlong param_3,longlong param_4,\n                       ulonglong param_5)\n\n{\n  ulonglong uVar1;\n  \n  uVar1 = param_4 - param_3;\n  if (0x7fffffff < (longlong)uVar1) {\n    uVar1 = 0x7fffffff;\n  }\n  if (uVar1 < param_5) {\n    param_5 = uVar1;\n  }\n  return param_5 & 0xffffffff;\n}\n\n",
  "__scrt_release_startup_lock": "\n/* Library Function - Single Match\n    __scrt_release_startup_lock\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __scrt_release_startup_lock(char param_1)\n\n{\n  bool bVar1;\n  undefined3 extraout_var;\n  \n  bVar1 = __scrt_is_ucrt_dll_in_use();\n  if ((CONCAT31(extraout_var,bVar1) != 0) && (param_1 == '\\0')) {\n    LOCK();\n    DAT_140036748 = 0;\n    UNLOCK();\n  }\n  return;\n}\n\n",
  "setlocale": "\n/* Library Function - Single Match\n    setlocale\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nchar * __cdecl setlocale(int _Category,char *_Locale)\n\n{\n  wchar_t *pwVar1;\n  int local_res8 [2];\n  char *local_res10;\n  undefined local_res18 [8];\n  int local_res20 [2];\n  int local_28 [2];\n  int *local_20;\n  char **local_18;\n  \n  local_res8[0] = _Category;\n  local_res10 = _Locale;\n  __acrt_eagerly_load_locale_apis();\n  local_20 = local_res8;\n  local_18 = &local_res10;\n  local_res20[0] = 4;\n  local_28[0] = 4;\n  pwVar1 = operator()<>(local_res18,local_28,&local_20,local_res20);\n  return (char *)pwVar1;\n}\n\n",
  "FUN_1400037a4": "\nvoid FUN_1400037a4(void)\n\n{\n  int iVar1;\n  int iVar2;\n  LPCRITICAL_SECTION lpCriticalSection;\n  \n  LOCK();\n  iVar2 = DAT_140035000 + -1;\n  UNLOCK();\n  iVar1 = DAT_140035000 + -1;\n  DAT_140035000 = iVar2;\n  if (iVar1 < 0) {\n    lpCriticalSection = (LPCRITICAL_SECTION)&DAT_140036110;\n    do {\n      DeleteCriticalSection(lpCriticalSection);\n      lpCriticalSection = lpCriticalSection + 1;\n    } while (lpCriticalSection != (LPCRITICAL_SECTION)&DAT_140036250);\n  }\n  return;\n}\n\n",
  "FUN_140020f20": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\ndouble FUN_140020f20(void)\n\n{\n  undefined auVar1 [16];\n  undefined auVar2 [16];\n  undefined auVar3 [16];\n  undefined auVar4 [16];\n  undefined auVar5 [16];\n  undefined auVar6 [16];\n  undefined auVar7 [16];\n  undefined auVar8 [16];\n  undefined auVar9 [16];\n  undefined auVar10 [16];\n  undefined auVar11 [16];\n  undefined auVar12 [16];\n  ulonglong uVar13;\n  ulonglong uVar14;\n  double dVar15;\n  undefined auVar16 [16];\n  undefined auVar17 [16];\n  undefined auVar18 [16];\n  undefined auVar19 [16];\n  undefined in_ZMM0 [64];\n  double dVar20;\n  undefined auVar21 [16];\n  undefined auVar22 [16];\n  double dVar23;\n  double dVar24;\n  undefined auVar25 [16];\n  undefined auVar26 [16];\n  double dVar27;\n  undefined auVar28 [16];\n  undefined auVar29 [16];\n  undefined auVar30 [16];\n  undefined auVar31 [16];\n  undefined auVar32 [16];\n  undefined auVar33 [16];\n  undefined auVar34 [16];\n  undefined auVar35 [16];\n  undefined auVar36 [16];\n  undefined auVar37 [16];\n  double dVar38;\n  \n  dVar15 = in_ZMM0._0_8_;\n  auVar16 = in_ZMM0._0_16_;\n  if (DAT_1400378d4 == 0) {\n    if ((double)((ulonglong)dVar15 & (ulonglong)DAT_14002f0f0) == DAT_14002f0f0) {\n      if (dVar15 == DAT_14002f0f0) {\n        return dVar15;\n      }\n      if (dVar15 != DAT_14002f0e0) {\n        return (double)((ulonglong)dVar15 | _DAT_14002f110);\n      }\n    }\n    else {\n      dVar38 = (double)(int)(((ulonglong)dVar15 >> 0x34) - _DAT_14002f120);\n      if (0.0 < dVar15) {\n        dVar23 = (double)((ulonglong)dVar15 & SUB168(_DAT_14002f140,0));\n        dVar20 = dVar15;\n        if (dVar38 == DAT_14002f260) {\n          dVar38 = (double)((ulonglong)dVar23 | (ulonglong)DAT_14002f1d0) - DAT_14002f1d0;\n          dVar20 = (double)((ulonglong)dVar38 & SUB168(_DAT_14002f140,0));\n          dVar38 = (double)((uint)((ulonglong)dVar38 >> 0x34) - _DAT_14002f270);\n          dVar23 = dVar20;\n        }\n        uVar13 = ((ulonglong)dVar20 & _DAT_14002f150) + ((ulonglong)dVar20 & _DAT_14002f160) * 2;\n        if ((double)((ulonglong)(dVar15 - DAT_14002f1d0) & _DAT_14002f2c0) < DAT_14002f280) {\n          dVar15 = dVar15 - DAT_14002f1d0;\n          dVar38 = dVar15 / (DAT_14002f1c0 + dVar15);\n          dVar20 = dVar38 + dVar38;\n          dVar23 = dVar20 * dVar20;\n          dVar24 = dVar23 * dVar20;\n          dVar27 = (double)((ulonglong)dVar15 & SUB168(_DAT_14002f310,0));\n          dVar15 = (((DAT_14002f2e0 * dVar23 + DAT_14002f2d0) * dVar24 +\n                    (DAT_14002f300 * dVar23 + DAT_14002f2f0) * dVar24 * dVar24 * dVar20) -\n                   dVar15 * dVar38) + (dVar15 - dVar27);\n          return dVar27 * DAT_14002f190 + dVar15 * DAT_14002f190 + dVar15 * DAT_14002f180 +\n                 dVar27 * DAT_14002f180;\n        }\n        uVar14 = uVar13 >> 0x2c;\n        dVar20 = ((double)(uVar13 | DAT_14002f1e0) - (double)((ulonglong)dVar23 | DAT_14002f1e0)) *\n                 *(double *)(&DAT_14002a570 + uVar14 * 8);\n        dVar15 = dVar20 * dVar20;\n        return *(double *)(&DAT_14002f330 + uVar14 * 8) + DAT_14002f1a0 * dVar38 +\n               *(double *)(&DAT_14002fb40 + uVar14 * 8) +\n               (DAT_14002f1b0 * dVar38 -\n               ((DAT_14002f220 * dVar20 + _DAT_14002f210) * dVar15 + dVar20 +\n               ((DAT_14002f250 * dVar20 + DAT_14002f240) * dVar20 + DAT_14002f230) * dVar15 * dVar15\n               ) * DAT_14002f170);\n      }\n      if (dVar15 == 0.0) {\n        dVar15 = (double)FUN_140021a90(dVar15,DAT_14002f0e0,DAT_14002f320);\n        return dVar15;\n      }\n    }\n    dVar15 = (double)FUN_140021a90(dVar15,DAT_14002f100,DAT_14002f324);\n    return dVar15;\n  }\n  auVar28 = vpsrlq_avx(auVar16,0x34);\n  auVar37._8_8_ = _UNK_14002f128;\n  auVar37._0_8_ = _DAT_14002f120;\n  auVar37 = vpsubq_avx(auVar28,auVar37);\n  auVar37 = vcvtdq2pd_avx(auVar37);\n  auVar28._8_8_ = _UNK_14002f0f8;\n  auVar28._0_8_ = DAT_14002f0f0;\n  auVar28 = vpand_avx(auVar16,auVar28);\n  if (auVar28._0_8_ == DAT_14002f0f0) {\n    if (dVar15 != DAT_14002f0f0) {\n      if (dVar15 == DAT_14002f0e0) goto LAB_140021470;\n      dVar15 = (double)FUN_140021a90(dVar15,(ulonglong)dVar15 | _DAT_14002f110,DAT_14002f328);\n    }\n    return dVar15;\n  }\n  if (0.0 < dVar15) {\n    auVar28 = vpand_avx(auVar16,_DAT_14002f140);\n    if (auVar37._0_8_ == DAT_14002f260) {\n      auVar16._8_8_ = _UNK_14002f1d8;\n      auVar16._0_8_ = DAT_14002f1d0;\n      auVar16 = vpor_avx(auVar28,auVar16);\n      auVar29._8_8_ = 0;\n      auVar29._0_8_ = auVar16._0_8_ - DAT_14002f1d0;\n      auVar37 = vpsrlq_avx(auVar29,0x34);\n      auVar16 = vpand_avx(auVar29,_DAT_14002f140);\n      auVar7._4_12_ = _UNK_14002f274;\n      auVar7._0_4_ = _DAT_14002f270;\n      auVar37 = vpsubd_avx(auVar37,auVar7);\n      auVar37 = vcvtdq2pd_avx(auVar37);\n      auVar28 = auVar16;\n    }\n    auVar8._8_8_ = _UNK_14002f158;\n    auVar8._0_8_ = _DAT_14002f150;\n    auVar7 = vpand_avx(auVar16,auVar8);\n    auVar9._8_8_ = _UNK_14002f168;\n    auVar9._0_8_ = _DAT_14002f160;\n    auVar29 = vpand_avx(auVar16,auVar9);\n    auVar29 = vpsllq_avx(auVar29,1);\n    auVar7 = vpaddq_avx(auVar29,auVar7);\n    auVar31._8_8_ = 0;\n    auVar31._0_8_ = dVar15 - DAT_14002f1d0;\n    auVar12._8_8_ = _UNK_14002f2c8;\n    auVar12._0_8_ = _DAT_14002f2c0;\n    auVar29 = vpand_avx(auVar31,auVar12);\n    if (auVar29._0_8_ < DAT_14002f280) {\n      dVar20 = auVar16._0_8_ - DAT_14002f1d0;\n      auVar19._8_8_ = 0;\n      auVar19._0_8_ = dVar20;\n      auVar25._8_8_ = 0;\n      auVar25._0_8_ = DAT_14002f1c0 + dVar20;\n      auVar16 = vdivsd_avx(auVar19,auVar25);\n      auVar33._8_8_ = 0;\n      auVar33._0_8_ = DAT_14002f2e0;\n      auVar36._8_8_ = 0;\n      auVar36._0_8_ = DAT_14002f300;\n      dVar23 = auVar16._0_8_;\n      dVar15 = dVar23 + dVar23;\n      auVar5._8_8_ = 0;\n      auVar5._0_8_ = DAT_14002f2d0;\n      auVar26._8_8_ = 0;\n      auVar26._0_8_ = dVar15 * dVar15;\n      auVar37 = vfmadd213sd_fma(auVar33,auVar26,auVar5);\n      auVar6._8_8_ = 0;\n      auVar6._0_8_ = DAT_14002f2f0;\n      auVar28 = vfmadd213sd_fma(auVar36,auVar26,auVar6);\n      dVar38 = dVar15 * dVar15 * dVar15;\n      auVar16 = vpand_avx(auVar19,_DAT_14002f310);\n      dVar24 = auVar16._0_8_;\n      dVar15 = ((auVar37._0_8_ * dVar38 + auVar28._0_8_ * dVar38 * dVar38 * dVar15) -\n               dVar20 * dVar23) + (dVar20 - dVar24);\n      return dVar24 * DAT_14002f190 + dVar15 * DAT_14002f190 + dVar15 * DAT_14002f180 +\n             dVar24 * DAT_14002f180;\n    }\n    uVar13 = auVar7._0_8_ >> 0x2c;\n    auVar10._8_8_ = _UNK_14002f1e8;\n    auVar10._0_8_ = DAT_14002f1e0;\n    auVar16 = vpor_avx(auVar28,auVar10);\n    auVar11._8_8_ = _UNK_14002f1e8;\n    auVar11._0_8_ = DAT_14002f1e0;\n    auVar28 = vpor_avx(auVar7,auVar11);\n    dVar15 = (auVar28._0_8_ - auVar16._0_8_) * *(double *)(&DAT_14002a570 + uVar13 * 8);\n    dVar38 = dVar15 * dVar15;\n    auVar30._8_8_ = 0;\n    auVar30._0_8_ = DAT_14002f250;\n    auVar34._8_8_ = 0;\n    auVar34._0_8_ = DAT_14002f220;\n    auVar1._8_8_ = 0;\n    auVar1._0_8_ = DAT_14002f240;\n    auVar21._8_8_ = 0;\n    auVar21._0_8_ = dVar15;\n    auVar16 = vfmadd213sd_fma(auVar30,auVar21,auVar1);\n    auVar2._8_8_ = 0;\n    auVar2._0_8_ = DAT_14002f1e0;\n    auVar28 = vfmadd213sd_fma(auVar34,auVar21,auVar2);\n    auVar3._8_8_ = 0;\n    auVar3._0_8_ = DAT_14002f230;\n    auVar16 = vfmadd213sd_fma(auVar16,auVar21,auVar3);\n    auVar17._8_8_ = 0;\n    auVar17._0_8_ = dVar38;\n    auVar28 = vfmadd231sd_fma(auVar21,auVar28,auVar17);\n    auVar32._8_8_ = 0;\n    auVar32._0_8_ = dVar38 * dVar38;\n    auVar16 = vfmadd231sd_fma(auVar28,auVar16,auVar32);\n    auVar35._8_8_ = 0;\n    auVar35._0_8_ = DAT_14002f1b0;\n    auVar22._8_8_ = 0;\n    auVar22._0_8_ = auVar16._0_8_ * DAT_14002f170;\n    auVar28 = vfmsub213sd_fma(auVar35,auVar37,auVar22);\n    auVar4._8_8_ = 0;\n    auVar4._0_8_ = DAT_14002f1a0;\n    auVar18._8_8_ = 0;\n    auVar18._0_8_ = *(ulonglong *)(&DAT_14002f330 + uVar13 * 8);\n    auVar16 = vfmadd231sd_fma(auVar18,auVar37,auVar4);\n    return auVar16._0_8_ + *(double *)(&DAT_14002fb40 + uVar13 * 8) + auVar28._0_8_;\n  }\n  if (dVar15 == 0.0) {\n    dVar15 = (double)FUN_140021a90(dVar15,DAT_14002f0e0,DAT_14002f320);\n    return dVar15;\n  }\nLAB_140021470:\n  dVar15 = (double)FUN_140021a90(dVar15,DAT_14002f100,DAT_14002f324);\n  return dVar15;\n}\n\n",
  "FUN_140002050": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_140002050(undefined8 *param_1)\n\n{\n  byte bVar1;\n  code *pcVar2;\n  short sVar3;\n  byte bVar4;\n  int iVar5;\n  byte ****ppppbVar6;\n  longlong *plVar7;\n  char cVar8;\n  int iVar9;\n  undefined8 *puVar10;\n  char *pcVar11;\n  ushort uVar12;\n  longlong *plVar13;\n  byte ****ppppbVar14;\n  undefined auStack_68 [32];\n  byte ***local_48 [2];\n  undefined8 local_38;\n  ulonglong local_30;\n  ulonglong local_28;\n  \n  local_28 = DAT_140035020 ^ (ulonglong)auStack_68;\n  iVar5 = FUN_140001ef0(param_1);\n  iVar9 = 0;\n  local_48[0] = (byte ***)0x0;\n  local_38 = 0;\n  local_30 = 0xf;\n  if ((ulonglong)param_1[2] < 2) {\nLAB_140002340:\n    local_30 = 0xf;\n    local_38 = 0;\n    local_48[0] = (byte ***)0x0;\n    FUN_140002700();\n    pcVar2 = (code *)swi(3);\n    (*pcVar2)();\n    return;\n  }\n  plVar7 = (longlong *)(param_1[2] - 2);\n  plVar13 = (longlong *)0x2;\n  if (plVar7 < (longlong *)0x2) {\n    plVar13 = plVar7;\n  }\n  puVar10 = param_1;\n  if (0xf < (ulonglong)param_1[3]) {\n    puVar10 = (undefined8 *)*param_1;\n  }\n  FUN_140002520((longlong **)local_48,(undefined8 *)((longlong)puVar10 + 2),plVar13);\n  ppppbVar6 = local_48;\n  ppppbVar14 = local_48;\n  if (0xf < local_30) {\n    ppppbVar6 = (byte ****)local_48[0];\n    ppppbVar14 = (byte ****)local_48[0];\n  }\n  do {\n    cVar8 = (char)iVar9;\n    iVar9 = iVar9 + 1;\n    *(byte *)ppppbVar6 = (cVar8 * '\\a' ^ *(byte *)ppppbVar6) + cVar8;\n    ppppbVar6 = (byte ****)((longlong)ppppbVar6 + 1);\n  } while (iVar9 < 2);\n  sVar3 = *(short *)ppppbVar14;\n  if (0xf < local_30) {\n    ppppbVar6 = (byte ****)local_48[0];\n    if ((0xfff < local_30 + 1) &&\n       (ppppbVar6 = (byte ****)local_48[0][-1],\n       (byte *)0x1f < (byte *)((longlong)local_48[0] + (-8 - (longlong)ppppbVar6))))\n    goto LAB_14000233a;\n    thunk_FUN_14000ce08(ppppbVar6);\n  }\n  local_48[0] = (byte ***)0x0;\n  local_38 = 0;\n  local_30 = 0xf;\n  if ((ulonglong)param_1[2] < 4) goto LAB_140002340;\n  plVar7 = (longlong *)(param_1[2] - 4);\n  plVar13 = (longlong *)0x2;\n  if (plVar7 < (longlong *)0x2) {\n    plVar13 = plVar7;\n  }\n  puVar10 = param_1;\n  if (0xf < (ulonglong)param_1[3]) {\n    puVar10 = (undefined8 *)*param_1;\n  }\n  FUN_140002520((longlong **)local_48,(undefined8 *)((longlong)puVar10 + 4),plVar13);\n  ppppbVar6 = local_48;\n  if (0xf < local_30) {\n    ppppbVar6 = (byte ****)local_48[0];\n  }\n  uVar12 = ((ushort)*(byte *)((longlong)ppppbVar6 + 1) << 7 | (ushort)(*(byte *)ppppbVar6 >> 1)) &\n           _DAT_140035b20;\n  if (0xf < local_30) {\n    ppppbVar6 = (byte ****)local_48[0];\n    if ((0xfff < local_30 + 1) &&\n       (ppppbVar6 = (byte ****)local_48[0][-1],\n       (byte *)0x1f < (byte *)((longlong)local_48[0] + (-8 - (longlong)ppppbVar6))))\n    goto LAB_14000233a;\n    thunk_FUN_14000ce08(ppppbVar6);\n  }\n  local_48[0] = (byte ***)0x0;\n  local_38 = 0;\n  local_30 = 0xf;\n  if ((ulonglong)param_1[2] < 6) goto LAB_140002340;\n  plVar7 = (longlong *)(param_1[2] - 6);\n  plVar13 = (longlong *)0x2;\n  if (plVar7 < (longlong *)0x2) {\n    plVar13 = plVar7;\n  }\n  if (0xf < (ulonglong)param_1[3]) {\n    param_1 = (undefined8 *)*param_1;\n  }\n  FUN_140002520((longlong **)local_48,(undefined8 *)((longlong)param_1 + 6),plVar13);\n  ppppbVar6 = local_48;\n  if (0xf < local_30) {\n    ppppbVar6 = (byte ****)local_48[0];\n  }\n  bVar4 = *(byte *)((longlong)ppppbVar6 + 1) ^ 0x5a;\n  bVar1 = *(byte *)ppppbVar6;\n  ppppbVar6 = (byte ****)local_48[0];\n  if (0xf < local_30) {\n    if ((0xfff < local_30 + 1) &&\n       (ppppbVar6 = (byte ****)local_48[0][-1],\n       (byte *)0x1f < (byte *)((longlong)local_48[0] + (-8 - (longlong)ppppbVar6)))) {\nLAB_14000233a:\n      FUN_14000d050();\n      pcVar2 = (code *)swi(3);\n      (*pcVar2)();\n      return;\n    }\n    thunk_FUN_14000ce08(ppppbVar6);\n  }\n  if (iVar5 == 0x1e) {\n    if (sVar3 == 0x646f) {\n      if (uVar12 == DAT_140035b24) {\n        if (CONCAT11(bVar4 << 2 | bVar4 >> 6,(bVar1 + 3) * '\\x02' | (char)(bVar1 + 3) < '\\0') ==\n            -0x1236) goto LAB_1400022d4;\n        pcVar11 = \"Stage 4 failed\\n\";\n      }\n      else {\n        pcVar11 = \"Stage 3 failed\\n\";\n      }\n    }\n    else {\n      pcVar11 = \"Stage 2 failed\\n\";\n    }\n  }\n  else {\n    pcVar11 = \"Stage 1 failed\\n\";\n  }\n  FUN_140002860(&DAT_140036260,(longlong)pcVar11,ppppbVar6,ppppbVar14);\nLAB_1400022d4:\n  FUN_140006060(local_28 ^ (ulonglong)auStack_68);\n  return;\n}\n\n",
  "Unwind@1400227eb": "\nvoid Unwind_1400227eb(undefined8 param_1,longlong param_2)\n\n{\n  FUN_14000cd50((longlong *)(param_2 + 0x58));\n  return;\n}\n\n",
  "FUN_140015008": "\nundefined FUN_140015008(void)\n\n{\n  if (DAT_140035250 != -1) {\n    __acrt_FlsFree(DAT_140035250);\n    DAT_140035250 = -1;\n  }\n  return 1;\n}\n\n",
  "FUN_140004b0c": "\nundefined8 FUN_140004b0c(void)\n\n{\n  return 0;\n}\n\n",
  "x_ismbbtype_l": "\n/* Library Function - Single Match\n    int __cdecl x_ismbbtype_l(struct __crt_locale_pointers * __ptr64,unsigned int,int,int)\n   \n   Libraries: Visual Studio 2015, Visual Studio 2017, Visual Studio 2019 */\n\nint __cdecl x_ismbbtype_l(__crt_locale_pointers *param_1,uint param_2,int param_3,int param_4)\n\n{\n  uint uVar1;\n  longlong local_28;\n  longlong *local_20;\n  longlong local_18;\n  char local_10;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,param_1);\n  if ((*(byte *)((ulonglong)(param_2 & 0xff) + 0x19 + local_18) & (byte)param_4) == 0) {\n    if (param_3 == 0) {\n      uVar1 = 0;\n    }\n    else {\n      uVar1 = (uint)*(ushort *)(*local_20 + (ulonglong)(param_2 & 0xff) * 2) & param_3;\n    }\n    if (uVar1 == 0) goto LAB_14001bdba;\n  }\n  uVar1 = 1;\nLAB_14001bdba:\n  if (local_10 != '\\0') {\n    *(uint *)(local_28 + 0x3a8) = *(uint *)(local_28 + 0x3a8) & 0xfffffffd;\n  }\n  return uVar1;\n}\n\n",
  "operator()<class_<lambda_84ec643ea9557e2f7dc01bb0e9624395>,class_<lambda_ca71763b3c0644891230e4f79ea54fa6>&___ptr64,class_<lambda_439a761618c59b0600e24586724d733b>_>": "\n/* Library Function - Single Match\n    public: int __cdecl __crt_seh_guarded_call<int>::operator()<class\n   <lambda_84ec643ea9557e2f7dc01bb0e9624395>,class <lambda_ca71763b3c0644891230e4f79ea54fa6> &\n   __ptr64,class <lambda_439a761618c59b0600e24586724d733b> >(class\n   <lambda_84ec643ea9557e2f7dc01bb0e9624395> && __ptr64,class\n   <lambda_ca71763b3c0644891230e4f79ea54fa6> & __ptr64,class\n   <lambda_439a761618c59b0600e24586724d733b> && __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_84ec643ea9557e2f7dc01bb0e9624395>,class_<lambda_ca71763b3c0644891230e4f79ea54fa6>&___ptr64,class_<lambda_439a761618c59b0600e24586724d733b>_>\n          (__crt_seh_guarded_call<int> *this,<lambda_84ec643ea9557e2f7dc01bb0e9624395> *param_1,\n          <lambda_ca71763b3c0644891230e4f79ea54fa6> *param_2,\n          <lambda_439a761618c59b0600e24586724d733b> *param_3)\n\n{\n  int iVar1;\n  \n  FUN_14000d384(*(longlong *)param_1);\n  iVar1 = <lambda_ca71763b3c0644891230e4f79ea54fa6>::operator()(param_2);\n  FUN_14000d390(*(longlong *)param_3);\n  return iVar1;\n}\n\n",
  "__vcrt_uninitialize_locks": "\n/* Library Function - Single Match\n    __vcrt_uninitialize_locks\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __vcrt_uninitialize_locks(void)\n\n{\n  undefined8 in_RAX;\n  undefined8 extraout_RAX;\n  ulonglong uVar1;\n  \n  uVar1 = (ulonglong)DAT_140036de0;\n  while ((int)uVar1 != 0) {\n    uVar1 = (ulonglong)((int)uVar1 - 1);\n    DeleteCriticalSection((LPCRITICAL_SECTION)(&DAT_140036db8 + uVar1 * 0x28));\n    DAT_140036de0 = DAT_140036de0 - 1;\n    in_RAX = extraout_RAX;\n  }\n  return CONCAT71((int7)((ulonglong)in_RAX >> 8),1);\n}\n\n",
  "parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<wchar_t>_>": "\n/* Library Function - Single Match\n    unsigned long __cdecl __crt_strtox::parse_integer<unsigned long,class\n   __crt_strtox::c_string_character_source<wchar_t> >(struct __crt_locale_pointers * __ptr64\n   const,class __crt_strtox::c_string_character_source<wchar_t>,int,bool)\n   \n   Library: Visual Studio 2019 Release */\n\nuint __cdecl\n__crt_strtox::parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<wchar_t>_>\n          (__crt_locale_pointers *param_1,wint_t **param_2,uint param_3,byte param_4)\n\n{\n  wint_t wVar1;\n  wint_t *pwVar2;\n  wint_t *pwVar3;\n  int iVar4;\n  uint uVar5;\n  ulong *puVar6;\n  byte bVar7;\n  uint uVar8;\n  wint_t _C;\n  uint uVar9;\n  byte bVar10;\n  uint uVar11;\n  longlong local_48 [3];\n  char local_30;\n  \n  uVar9 = 0;\n  if ((*param_2 == (wint_t *)0x0) || ((param_3 != 0 && (0x22 < param_3 - 2)))) {\n    puVar6 = __doserrno();\n    *puVar6 = 0x16;\n    FUN_14000d030();\n    goto LAB_14000cbc5;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_48,param_1);\n  pwVar2 = *param_2;\n  _C = *pwVar2;\n  pwVar3 = pwVar2;\n  while( true ) {\n    *param_2 = pwVar3 + 1;\n    iVar4 = iswctype(_C,8);\n    if (iVar4 == 0) break;\n    pwVar3 = *param_2;\n    _C = *pwVar3;\n  }\n  bVar10 = param_4 | 2;\n  if (_C != 0x2d) {\n    bVar10 = param_4;\n  }\n  if ((_C - 0x2b & 0xfffd) == 0) {\n    _C = **param_2;\n    *param_2 = *param_2 + 1;\n  }\n  iVar4 = 0xff10;\n  uVar5 = param_3;\n  if ((param_3 & 0xffffffef) != 0) goto LAB_14000c951;\n  if (_C < 0x30) goto LAB_14000c8b1;\n  if (_C < 0x3a) {\n    iVar4 = _C - 0x30;\nLAB_14000c8ac:\n    if (iVar4 == -1) goto LAB_14000c8b1;\n  }\n  else {\n    if (0xff0f < _C) {\n      if (_C < 0xff1a) {\nLAB_14000c7a5:\n        iVar4 = (uint)_C - iVar4;\n      }\n      else {\n        iVar4 = -1;\n      }\n      goto LAB_14000c8ac;\n    }\n    if (0x65f < _C) {\n      if (_C < 0x66a) {\n        iVar4 = _C - 0x660;\n        goto LAB_14000c8ac;\n      }\n      if (0x6ef < _C) {\n        if (_C < 0x6fa) {\n          iVar4 = _C - 0x6f0;\n          goto LAB_14000c8ac;\n        }\n        if (0x965 < _C) {\n          if (_C < 0x970) {\n            iVar4 = _C - 0x966;\n            goto LAB_14000c8ac;\n          }\n          if (0x9e5 < _C) {\n            if (_C < 0x9f0) {\n              iVar4 = _C - 0x9e6;\n              goto LAB_14000c8ac;\n            }\n            iVar4 = 0xa66;\n            if ((0xa65 < _C) &&\n               ((_C < 0xa70 ||\n                ((iVar4 = 0xae6, 0xae5 < _C &&\n                 ((_C < 0xaf0 ||\n                  ((iVar4 = 0xb66, 0xb65 < _C &&\n                   ((_C < 0xb70 ||\n                    ((iVar4 = 0xc66, 0xc65 < _C &&\n                     ((_C < 0xc70 ||\n                      ((iVar4 = 0xce6, 0xce5 < _C &&\n                       ((_C < 0xcf0 ||\n                        ((iVar4 = 0xd66, 0xd65 < _C &&\n                         ((_C < 0xd70 ||\n                          ((iVar4 = 0xe50, 0xe4f < _C &&\n                           ((_C < 0xe5a ||\n                            ((iVar4 = 0xed0, 0xecf < _C &&\n                             ((_C < 0xeda ||\n                              ((iVar4 = 0xf20, 0xf1f < _C &&\n                               ((_C < 0xf2a ||\n                                ((iVar4 = 0x1040, 0x103f < _C &&\n                                 ((_C < 0x104a ||\n                                  ((iVar4 = 0x17e0, 0x17df < _C &&\n                                   ((_C < 0x17ea || (iVar4 = 0x1810, (ushort)(_C + 0xe7f0) < 10)))))\n                                  ))))))))))))))))))))))))))))))))))))))) goto LAB_14000c7a5;\n          }\n        }\n      }\n    }\nLAB_14000c8b1:\n    if ((_C - 0x41 < 0x1a) || (_C - 0x61 < 0x1a)) {\n      uVar5 = _C - 0x20;\n      if (0x19 < _C - 0x61) {\n        uVar5 = (uint)_C;\n      }\n      iVar4 = uVar5 - 0x37;\n    }\n    else {\n      iVar4 = -1;\n    }\n  }\n  if (iVar4 == 0) {\n    pwVar3 = *param_2;\n    wVar1 = *pwVar3;\n    *param_2 = pwVar3 + 1;\n    if ((wVar1 - 0x58 & 0xffdf) != 0) {\n      uVar5 = 8;\n      if (param_3 != 0) {\n        uVar5 = param_3;\n      }\n      *param_2 = pwVar3;\n      if ((wVar1 != 0) && (*pwVar3 != wVar1)) {\n        puVar6 = __doserrno();\n        *puVar6 = 0x16;\n        FUN_14000d030();\n      }\n      goto LAB_14000c951;\n    }\n    _C = pwVar3[1];\n    *param_2 = pwVar3 + 2;\n    uVar5 = 0x10;\n  }\n  else {\n    uVar5 = 10;\n  }\n  if (param_3 != 0) {\n    uVar5 = param_3;\n  }\nLAB_14000c951:\n  do {\n    if (_C < 0x30) goto LAB_14000cb1d;\n    if (_C < 0x3a) {\n      uVar8 = _C - 0x30;\nLAB_14000cb18:\n      if (uVar8 == 0xffffffff) goto LAB_14000cb1d;\n    }\n    else {\n      if (0xff0f < _C) {\n        if (_C < 0xff1a) {\n          uVar8 = _C - 0xff10;\n        }\n        else {\n          uVar8 = 0xffffffff;\n        }\n        goto LAB_14000cb18;\n      }\n      if (0x65f < _C) {\n        if (_C < 0x66a) {\n          uVar8 = _C - 0x660;\n          goto LAB_14000cb18;\n        }\n        iVar4 = 0x6f0;\n        if (0x6ef < _C) {\n          if (_C < 0x6fa) {\nLAB_14000c9c5:\n            uVar8 = (uint)_C - iVar4;\n            goto LAB_14000cb18;\n          }\n          iVar4 = 0x966;\n          if (0x965 < _C) {\n            if (_C < 0x970) goto LAB_14000c9c5;\n            iVar4 = 0x9e6;\n            if (0x9e5 < _C) {\n              if (_C < 0x9f0) goto LAB_14000c9c5;\n              iVar4 = 0xa66;\n              if (0xa65 < _C) {\n                if (_C < 0xa70) goto LAB_14000c9c5;\n                iVar4 = 0xae6;\n                if (0xae5 < _C) {\n                  if (_C < 0xaf0) goto LAB_14000c9c5;\n                  iVar4 = 0xb66;\n                  if (0xb65 < _C) {\n                    if (_C < 0xb70) goto LAB_14000c9c5;\n                    iVar4 = 0xc66;\n                    if (0xc65 < _C) {\n                      if (_C < 0xc70) goto LAB_14000c9c5;\n                      iVar4 = 0xce6;\n                      if (0xce5 < _C) {\n                        if (_C < 0xcf0) goto LAB_14000c9c5;\n                        iVar4 = 0xd66;\n                        if (0xd65 < _C) {\n                          if (_C < 0xd70) goto LAB_14000c9c5;\n                          iVar4 = 0xe50;\n                          if (0xe4f < _C) {\n                            if (_C < 0xe5a) goto LAB_14000c9c5;\n                            iVar4 = 0xed0;\n                            if (0xecf < _C) {\n                              if (_C < 0xeda) goto LAB_14000c9c5;\n                              iVar4 = 0xf20;\n                              if (0xf1f < _C) {\n                                if (_C < 0xf2a) goto LAB_14000c9c5;\n                                iVar4 = 0x1040;\n                                if (0x103f < _C) {\n                                  if (_C < 0x104a) goto LAB_14000c9c5;\n                                  iVar4 = 0x17e0;\n                                  if (0x17df < _C) {\n                                    if (_C < 0x17ea) goto LAB_14000c9c5;\n                                    if ((ushort)(_C + 0xe7f0) < 10) {\n                                      uVar8 = _C - 0x1810;\n                                      goto LAB_14000cb18;\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\nLAB_14000cb1d:\n      if ((_C - 0x41 < 0x1a) || (uVar8 = 0xffffffff, _C - 0x61 < 0x1a)) {\n        uVar8 = _C - 0x20;\n        if (0x19 < _C - 0x61) {\n          uVar8 = (uint)_C;\n        }\n        uVar8 = uVar8 - 0x37;\n      }\n    }\n    if ((uVar8 == 0xffffffff) || (uVar5 <= uVar8)) break;\n    uVar11 = (uint)(0xffffffff / (ulonglong)uVar5);\n    if ((uVar9 < uVar11) || ((uVar9 == uVar11 && (uVar8 <= (uint)(0xffffffff % (ulonglong)uVar5)))))\n    {\n      uVar9 = uVar9 * uVar5 + uVar8;\n      bVar7 = 8;\n    }\n    else {\n      bVar7 = 0xc;\n    }\n    _C = **param_2;\n    *param_2 = *param_2 + 1;\n    bVar10 = bVar10 | bVar7;\n  } while( true );\n  pwVar3 = *param_2;\n  *param_2 = pwVar3 + -1;\n  if ((_C != 0) && (pwVar3[-1] != _C)) {\n    puVar6 = __doserrno();\n    *puVar6 = 0x16;\n    FUN_14000d030();\n  }\n  if ((bVar10 & 8) == 0) {\n    *param_2 = pwVar2;\n    if (local_30 != '\\0') {\n      *(uint *)(local_48[0] + 0x3a8) = *(uint *)(local_48[0] + 0x3a8) & 0xfffffffd;\n    }\nLAB_14000cbc5:\n    if ((wint_t **)param_2[1] != (wint_t **)0x0) {\n      *(wint_t **)param_2[1] = *param_2;\n    }\n    return 0;\n  }\n  if ((bVar10 & 4) != 0) goto LAB_14000cc01;\n  if ((bVar10 & 1) == 0) {\nLAB_14000cc41:\n    if ((bVar10 & 2) != 0) {\n      uVar9 = -uVar9;\n    }\n  }\n  else {\n    if ((bVar10 & 2) == 0) {\n      if (uVar9 < 0x80000000) goto LAB_14000cc41;\n    }\n    else if (uVar9 < 0x80000001) goto LAB_14000cc41;\nLAB_14000cc01:\n    puVar6 = __doserrno();\n    *puVar6 = 0x22;\n    if ((bVar10 & 1) != 0) {\n      if ((bVar10 & 2) != 0) {\n        if (local_30 != '\\0') {\n          *(uint *)(local_48[0] + 0x3a8) = *(uint *)(local_48[0] + 0x3a8) & 0xfffffffd;\n        }\n        if ((wint_t **)param_2[1] != (wint_t **)0x0) {\n          *(wint_t **)param_2[1] = *param_2;\n        }\n        return 0x80000000;\n      }\n      if (local_30 != '\\0') {\n        *(uint *)(local_48[0] + 0x3a8) = *(uint *)(local_48[0] + 0x3a8) & 0xfffffffd;\n      }\n      if ((wint_t **)param_2[1] != (wint_t **)0x0) {\n        *(wint_t **)param_2[1] = *param_2;\n      }\n      return 0x7fffffff;\n    }\n    uVar9 = 0xffffffff;\n  }\n  if (local_30 != '\\0') {\n    *(uint *)(local_48[0] + 0x3a8) = *(uint *)(local_48[0] + 0x3a8) & 0xfffffffd;\n  }\n  if ((wint_t **)param_2[1] == (wint_t **)0x0) {\n    return uVar9;\n  }\n  *(wint_t **)param_2[1] = *param_2;\n  return uVar9;\n}\n\n",
  "__acrt_LocaleNameToLCID": "\n/* Library Function - Single Match\n    __acrt_LocaleNameToLCID\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_LocaleNameToLCID(ushort *param_1,undefined4 param_2)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = try_get_function(0x16,\"LocaleNameToLCID\",(module_id *)&DAT_140028eb8,\n                            (module_id *)\"LocaleNameToLCID\");\n  if (pvVar1 == (void *)0x0) {\n    __acrt_DownlevelLocaleNameToLCID(param_1);\n  }\n  else {\n    (*(code *)PTR__guard_dispatch_icall_140023298)(param_1,param_2);\n  }\n  return;\n}\n\n",
  "_isleadbyte_l": "\n/* Library Function - Single Match\n    _isleadbyte_l\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _isleadbyte_l(int _C,_locale_t _Locale)\n\n{\n  uint uVar1;\n  longlong local_28;\n  longlong *local_20;\n  char local_10;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,(__crt_locale_pointers *)_Locale);\n  if (_C + 1U < 0x101) {\n    uVar1 = *(ushort *)(*local_20 + (longlong)_C * 2) & 0x8000;\n  }\n  else {\n    uVar1 = 0;\n  }\n  if (local_10 != '\\0') {\n    *(uint *)(local_28 + 0x3a8) = *(uint *)(local_28 + 0x3a8) & 0xfffffffd;\n  }\n  return uVar1;\n}\n\n",
  "operator()<class_<lambda_7f2adfce497ff2baa965cd4f576ecfd1>,class_<lambda_2a444430fde8c29194d880d93eed5e8f>&___ptr64,class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&___ptr64>": "\n/* Library Function - Single Match\n    public: void __cdecl __crt_seh_guarded_call<void>::operator()<class\n   <lambda_7f2adfce497ff2baa965cd4f576ecfd1>,class <lambda_2a444430fde8c29194d880d93eed5e8f> &\n   __ptr64,class <lambda_8dff2cf36a5417162780cd64fa2883ef> & __ptr64>(class\n   <lambda_7f2adfce497ff2baa965cd4f576ecfd1> && __ptr64,class\n   <lambda_2a444430fde8c29194d880d93eed5e8f> & __ptr64,class\n   <lambda_8dff2cf36a5417162780cd64fa2883ef> & __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_7f2adfce497ff2baa965cd4f576ecfd1>,class_<lambda_2a444430fde8c29194d880d93eed5e8f>&___ptr64,class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&___ptr64>\n          (__crt_seh_guarded_call<void> *this,<lambda_7f2adfce497ff2baa965cd4f576ecfd1> *param_1,\n          <lambda_2a444430fde8c29194d880d93eed5e8f> *param_2,\n          <lambda_8dff2cf36a5417162780cd64fa2883ef> *param_3)\n\n{\n  <lambda_2a444430fde8c29194d880d93eed5e8f>::operator()(param_2);\n  *(uint *)(**(longlong **)param_3 + 0x3a8) = *(uint *)(**(longlong **)param_3 + 0x3a8) & 0xffffffef\n  ;\n  return;\n}\n\n",
  "__acrt_get_process_end_policy": "\n/* Library Function - Single Match\n    __acrt_get_process_end_policy\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined4 __acrt_get_process_end_policy(void)\n\n{\n  int local_res8 [8];\n  \n  local_res8[0] = 0;\n  if ((-1 < *(int *)(*(longlong *)((longlong)ProcessEnvironmentBlock + 0x20) + 8)) &&\n     (__acrt_AppPolicyGetProcessTerminationMethodInternal(local_res8), local_res8[0] == 1)) {\n    return 0;\n  }\n  return 1;\n}\n\n",
  "__vcrt_getptd_noinit": "\n/* Library Function - Single Match\n    __vcrt_getptd_noinit\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nlonglong __vcrt_getptd_noinit(void)\n\n{\n  DWORD dwErrCode;\n  longlong lVar1;\n  \n  if (DAT_140035050 == -1) {\n    lVar1 = 0;\n  }\n  else {\n    dwErrCode = GetLastError();\n    lVar1 = __vcrt_FlsGetValue(DAT_140035050);\n    SetLastError(dwErrCode);\n    if (lVar1 == -1) {\n      lVar1 = 0;\n    }\n  }\n  return lVar1;\n}\n\n",
  "FUN_140022705": "\nvoid FUN_140022705(void)\n\n{\n  __acrt_unlock(0);\n  return;\n}\n\n",
  "FUN_14000543c": "\nundefined8 FUN_14000543c(void)\n\n{\n  return DAT_1400363d8;\n}\n\n",
  "__ascii_wcsnicmp": "\n/* Library Function - Single Match\n    __ascii_wcsnicmp\n   \n   Library: Visual Studio 2019 Release */\n\nint __ascii_wcsnicmp(ushort *param_1,ushort *param_2,longlong param_3)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  if (param_3 == 0) {\n    return 0;\n  }\n  do {\n    uVar1 = *param_1;\n    param_1 = param_1 + 1;\n    uVar2 = *param_2;\n    param_2 = param_2 + 1;\n    uVar3 = uVar1 + 0x20;\n    if (0x19 < uVar1 - 0x41) {\n      uVar3 = (uint)uVar1;\n    }\n    uVar4 = uVar2 + 0x20;\n    if (0x19 < uVar2 - 0x41) {\n      uVar4 = (uint)uVar2;\n    }\n  } while (((uVar3 - uVar4 == 0) && (uVar3 != 0)) && (param_3 = param_3 + -1, param_3 != 0));\n  return uVar3 - uVar4;\n}\n\n",
  "FUN_140009aac": "\nvoid FUN_140009aac(EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n                  _xDISPATCHER_CONTEXT *param_4,FuncInfo4 *param_5,uchar param_6,int param_7,\n                  __uint64 *param_8)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  _s_ESTypeList *p_Var3;\n  code *pcVar4;\n  int iVar5;\n  char cVar6;\n  uchar uVar7;\n  byte bVar8;\n  int iVar9;\n  int iVar10;\n  longlong lVar11;\n  longlong lVar12;\n  int *piVar13;\n  uint uVar14;\n  byte *pbVar15;\n  byte *pbVar16;\n  int iVar17;\n  undefined auStackY_1c8 [32];\n  uchar local_168;\n  int local_164;\n  uint local_160;\n  int local_140;\n  int iStack_13c;\n  uint uStack_138;\n  undefined4 uStack_134;\n  __uint64 *local_128;\n  int local_120;\n  int iStack_11c;\n  uint uStack_118;\n  undefined4 uStack_114;\n  uint local_108;\n  undefined4 local_100;\n  undefined4 uStack_fc;\n  undefined4 uStack_f8;\n  undefined4 uStack_f4;\n  undefined4 local_f0;\n  undefined4 uStack_ec;\n  undefined4 uStack_e8;\n  undefined4 uStack_e4;\n  undefined8 local_e0;\n  int local_d8 [12];\n  int local_a8 [6];\n  undefined4 local_90;\n  undefined4 uStack_8c;\n  undefined4 uStack_88;\n  undefined4 uStack_84;\n  undefined4 local_80;\n  undefined4 uStack_7c;\n  undefined4 uStack_78;\n  undefined4 uStack_74;\n  undefined8 local_70;\n  ulonglong local_58;\n  \n  local_58 = DAT_140035020 ^ (ulonglong)auStackY_1c8;\n  local_128 = param_8;\n  local_168 = '\\0';\n  iVar9 = FUN_140008d5c(param_5,param_4);\n  if (*(int *)(param_4 + 0x48) == 0) {\n    lVar11 = FUN_140008b20();\n    if (*(int *)(lVar11 + 0x78) != -2) {\n      lVar11 = FUN_140008b20();\n      iVar9 = *(int *)(lVar11 + 0x78);\n      lVar11 = FUN_140008b20();\n      *(undefined4 *)(lVar11 + 0x78) = 0xfffffffe;\n    }\n  }\n  else {\n    lVar11 = FUN_140008b20();\n    if (*(int *)(lVar11 + 0x78) != -2) goto LAB_140009fa1;\n    iVar9 = *(int *)(param_4 + 0x48) + -2;\n  }\n  if (-2 < iVar9) {\n    if (*(int *)(param_5 + 8) == 0) {\n      uVar14 = 0;\n    }\n    else {\n      uVar14 = *(byte *)((longlong)*(int *)(param_5 + 8) + *(longlong *)(param_4 + 8)) & 0xf;\n      uVar14 = *(uint *)((byte *)((longlong)*(int *)(param_5 + 8) + *(longlong *)(param_4 + 8)) +\n                        (-4 - (longlong)(char)(&DAT_140024780)[uVar14])) >>\n               ((&DAT_140024790)[uVar14] & 0x1f);\n    }\n    if ((int)uVar14 <= iVar9) goto LAB_140009fa1;\n    if ((((*(int *)param_1 == -0x1f928c9d) && (*(int *)(param_1 + 0x18) == 4)) &&\n        (*(int *)(param_1 + 0x20) + 0xe66cfae0U < 3)) && (*(longlong *)(param_1 + 0x30) == 0)) {\n      lVar11 = FUN_140008b20();\n      if (*(longlong *)(lVar11 + 0x20) == 0) goto LAB_140009f3f;\n      lVar11 = FUN_140008b20();\n      param_1 = *(EHExceptionRecord **)(lVar11 + 0x20);\n      lVar11 = FUN_140008b20();\n      local_168 = '\\x01';\n      param_3 = *(_CONTEXT **)(lVar11 + 0x28);\n      FUN_140007a58(*(undefined8 *)(param_1 + 0x38));\n      if (((*(int *)param_1 == -0x1f928c9d) && (*(int *)(param_1 + 0x18) == 4)) &&\n         ((*(int *)(param_1 + 0x20) + 0xe66cfae0U < 3 && (*(longlong *)(param_1 + 0x30) == 0))))\n      goto LAB_140009fa1;\n      lVar11 = FUN_140008b20();\n      if (*(longlong *)(lVar11 + 0x38) != 0) {\n        lVar11 = FUN_140008b20();\n        p_Var3 = *(_s_ESTypeList **)(lVar11 + 0x38);\n        lVar11 = FUN_140008b20();\n        *(undefined8 *)(lVar11 + 0x38) = 0;\n        cVar6 = FUN_14000b938((longlong)param_1,(int *)p_Var3);\n        if (cVar6 == '\\0') {\n          uVar7 = Is_bad_exception_allowed(p_Var3);\n          if (uVar7 != '\\0') {\n            __DestructExceptionObject((int *)param_1);\n            FUN_14000ad90((undefined8 *)&local_140);\n                    /* WARNING: Subroutine does not return */\n            _CxxThrowException(&local_140,(ThrowInfo *)&DAT_140033b60);\n          }\n          terminate();\n          pcVar4 = (code *)swi(3);\n          (*pcVar4)();\n          return;\n        }\n      }\n    }\n    FH4::TryBlockMap4::TryBlockMap4((TryBlockMap4 *)local_d8,param_5,*(__uint64 *)(param_4 + 8));\n    if (((*(int *)param_1 == -0x1f928c9d) && (*(int *)(param_1 + 0x18) == 4)) &&\n       (*(int *)(param_1 + 0x20) + 0xe66cfae0U < 3)) {\n      if (local_d8[0] != 0) {\n        FUN_14000743c((undefined (*) [16])&local_120,local_d8,iVar9);\n        local_140 = local_120;\n        iStack_13c = iStack_11c;\n        uStack_138 = uStack_118;\n        uStack_134 = uStack_114;\n        if (uStack_118 < local_108) {\n          lVar11 = CONCAT44(iStack_11c,local_120);\n          local_160 = uStack_118;\n          do {\n            local_140 = *(int *)(lVar11 + 0x18);\n            iStack_13c = *(int *)(lVar11 + 0x1c);\n            uStack_138 = *(uint *)(lVar11 + 0x20);\n            uStack_134 = *(undefined4 *)(lVar11 + 0x24);\n            if ((local_140 <= iVar9) && (iVar9 <= iStack_13c)) {\n              FH4::HandlerMap4::HandlerMap4\n                        ((HandlerMap4 *)local_a8,(TryBlockMapEntry4 *)&local_140,\n                         *(__uint64 *)(param_4 + 8),**(int **)(param_4 + 0x10));\n              iVar5 = local_a8[0];\n              local_164 = 0;\n              if (local_a8[0] != 0) {\n                do {\n                  local_100 = local_90;\n                  uStack_fc = uStack_8c;\n                  uStack_f8 = uStack_88;\n                  uStack_f4 = uStack_84;\n                  local_e0 = local_70;\n                  local_f0 = local_80;\n                  uStack_ec = uStack_7c;\n                  uStack_e8 = uStack_78;\n                  uStack_e4 = uStack_74;\n                  lVar12 = _GetThrowImageBase();\n                  piVar13 = (int *)(lVar12 + 4 +\n                                   (longlong)*(int *)(*(longlong *)(param_1 + 0x30) + 0xc));\n                  lVar12 = _GetThrowImageBase();\n                  for (iVar17 = *(int *)(lVar12 + *(int *)(*(longlong *)(param_1 + 0x30) + 0xc));\n                      0 < iVar17; iVar17 = iVar17 + -1) {\n                    lVar12 = _GetThrowImageBase();\n                    iVar1 = *piVar13;\n                    iVar10 = TypeMatchHelper<class___FrameHandler4>\n                                       ((HandlerType4 *)&local_100,\n                                        (_s_CatchableType *)(lVar12 + iVar1),\n                                        *(_s_ThrowInfo **)(param_1 + 0x30));\n                    if (iVar10 != 0) {\n                      CatchIt<class___FrameHandler4>\n                                (param_1,param_2,param_3,param_4,param_5,(HandlerType4 *)&local_100,\n                                 (_s_CatchableType *)(lVar12 + iVar1),\n                                 (TryBlockMapEntry4 *)&local_140,param_7,local_128,local_168,param_6\n                                );\n                      goto LAB_140009e37;\n                    }\n                    piVar13 = piVar13 + 1;\n                  }\n                  FH4::HandlerMap4::DecompHandler((HandlerMap4 *)local_a8);\n                  local_164 = local_164 + 1;\n                } while (local_164 != iVar5);\n              }\n            }\nLAB_140009e37:\n            uVar14 = **(byte **)(lVar11 + 8) & 0xf;\n            bVar8 = (&DAT_140024790)[uVar14];\n            pbVar15 = *(byte **)(lVar11 + 8) + -(longlong)(char)(&DAT_140024780)[uVar14];\n            uVar14 = *(uint *)(pbVar15 + -4);\n            *(byte **)(lVar11 + 8) = pbVar15;\n            *(uint *)(lVar11 + 0x18) = uVar14 >> (bVar8 & 0x1f);\n            bVar8 = (&DAT_140024790)[*pbVar15 & 0xf];\n            pbVar15 = pbVar15 + -(longlong)(char)(&DAT_140024780)[*pbVar15 & 0xf];\n            uVar14 = *(uint *)(pbVar15 + -4);\n            *(byte **)(lVar11 + 8) = pbVar15;\n            *(uint *)(lVar11 + 0x1c) = uVar14 >> (bVar8 & 0x1f);\n            pbVar16 = pbVar15 + -(longlong)(char)(&DAT_140024780)[*pbVar15 & 0xf];\n            *(uint *)(lVar11 + 0x20) =\n                 *(uint *)(pbVar16 + -4) >> ((&DAT_140024790)[*pbVar15 & 0xf] & 0x1f);\n            local_160 = local_160 + 1;\n            *(byte **)(lVar11 + 8) = pbVar16;\n            uVar2 = *(undefined4 *)pbVar16;\n            *(byte **)(lVar11 + 8) = pbVar16 + 4;\n            *(undefined4 *)(lVar11 + 0x24) = uVar2;\n          } while (local_160 < local_108);\n        }\n      }\n      if ((((byte)*param_5 & 0x40) != 0) &&\n         (bVar8 = FUN_14000716c(param_4,(byte *)param_5), bVar8 == 0)) {\n        lVar11 = FUN_140008b20();\n        *(EHExceptionRecord **)(lVar11 + 0x20) = param_1;\n        lVar11 = FUN_140008b20();\n        *(_CONTEXT **)(lVar11 + 0x28) = param_3;\n        terminate();\n        pcVar4 = (code *)swi(3);\n        (*pcVar4)();\n        return;\n      }\n    }\n    else if (local_d8[0] != 0) {\n      if (param_6 != '\\0') goto LAB_140009fa1;\n      FindHandlerForForeignException<class___FrameHandler4>\n                (param_1,param_2,param_3,param_4,param_5,iVar9,param_7,param_8);\n    }\n    lVar11 = FUN_140008b20();\n    if (*(longlong *)(lVar11 + 0x38) == 0) {\nLAB_140009f3f:\n      FUN_140006060(local_58 ^ (ulonglong)auStackY_1c8);\n      return;\n    }\n  }\nLAB_140009fa1:\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "_isatty": "\n/* Library Function - Single Match\n    _isatty\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _isatty(int _FileHandle)\n\n{\n  ulong *puVar1;\n  \n  if (_FileHandle == -2) {\n    puVar1 = __doserrno();\n    *puVar1 = 9;\n  }\n  else {\n    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_140037890)) {\n      return *(byte *)((&DAT_140037490)[(longlong)_FileHandle >> 6] + 0x38 +\n                      (ulonglong)(_FileHandle & 0x3f) * 0x48) & 0x40;\n    }\n    puVar1 = __doserrno();\n    *puVar1 = 9;\n    FUN_14000d030();\n  }\n  return 0;\n}\n\n",
  "FUN_140004580": "\nundefined8\nFUN_140004580(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n             undefined8 *param_5,undefined8 param_6,undefined8 param_7,undefined8 *param_8)\n\n{\n  *param_5 = param_3;\n  *param_8 = param_6;\n  return 3;\n}\n\n",
  "GetLocaleNameFromLanguage": "\n/* Library Function - Single Match\n    GetLocaleNameFromLanguage\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid GetLocaleNameFromLanguage(short **param_1)\n\n{\n  short sVar1;\n  int iVar2;\n  short *psVar3;\n  int iVar4;\n  longlong lVar5;\n  \n  psVar3 = *param_1;\n  lVar5 = -1;\n  do {\n    lVar5 = lVar5 + 1;\n  } while (psVar3[lVar5] != 0);\n  iVar4 = 0;\n  *(uint *)(param_1 + 3) = (uint)(lVar5 == 3);\n  if (lVar5 == 3) {\n    iVar4 = 2;\n  }\n  else {\n    iVar2 = 0;\n    if (psVar3 != (short *)0x0) {\n      while( true ) {\n        iVar4 = iVar2;\n        sVar1 = *psVar3;\n        psVar3 = psVar3 + 1;\n        if ((0x19 < (ushort)(sVar1 - 0x41U)) && (0x19 < (ushort)(sVar1 - 0x61U))) break;\n        iVar2 = iVar4 + 1;\n      }\n    }\n  }\n  *(int *)((longlong)param_1 + 0x14) = iVar4;\n  __acrt_EnumSystemLocalesEx(0x14001dfb0,3,0,0);\n  if ((*(byte *)(param_1 + 2) & 4) == 0) {\n    *(undefined4 *)(param_1 + 2) = 0;\n  }\n  return;\n}\n\n",
  "_read_nolock": "\n/* Library Function - Single Match\n    _read_nolock\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _read_nolock(int _FileHandle,void *_DstBuf,uint _MaxCharCount)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  BOOL BVar6;\n  DWORD DVar7;\n  ulong *puVar8;\n  ulonglong uVar9;\n  wchar_t *pwVar10;\n  __int64 _Var11;\n  wchar_t wVar12;\n  uint uVar13;\n  uint nNumberOfBytesToRead;\n  int iVar14;\n  ulonglong uVar15;\n  longlong lVar16;\n  wchar_t *pwVar17;\n  wchar_t *pwVar18;\n  uint local_res20 [2];\n  DWORD local_68 [2];\n  HANDLE local_60;\n  longlong local_58;\n  ulonglong local_50;\n  wchar_t *local_48;\n  \n  if (_FileHandle == -2) {\n    puVar8 = __doserrno();\n    *puVar8 = 0;\n    puVar8 = __doserrno();\n    *puVar8 = 9;\n    return -1;\n  }\n  pwVar10 = (wchar_t *)0x0;\n  iVar14 = 0;\n  if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_140037890)) {\n    uVar9 = (ulonglong)(_FileHandle & 0x3f);\n    local_50 = 1;\n    local_58 = (longlong)_FileHandle >> 6;\n    lVar16 = (&DAT_140037490)[local_58];\n    bVar2 = *(byte *)(lVar16 + 0x38 + uVar9 * 0x48);\n    if ((bVar2 & 1) != 0) {\n      if (_MaxCharCount < 0x80000000) {\n        if ((_MaxCharCount == 0) || ((bVar2 & 2) != 0)) {\n          return 0;\n        }\n        if (_DstBuf != (void *)0x0) {\n          cVar4 = *(char *)(lVar16 + 0x39 + uVar9 * 0x48);\n          local_60 = *(HANDLE *)(lVar16 + 0x28 + uVar9 * 0x48);\n          if (cVar4 == '\\x01') {\n            if ((~(byte)_MaxCharCount & 1) == 0) goto LAB_140018109;\n            uVar13 = _MaxCharCount >> 1;\n            if (uVar13 < 4) {\n              uVar13 = 4;\n            }\n            pwVar10 = (wchar_t *)_malloc_base((ulonglong)uVar13);\n            _free_base((LPVOID)0x0);\n            _free_base((LPVOID)0x0);\n            if (pwVar10 != (wchar_t *)0x0) {\n              _Var11 = common_lseek_nolock<__int64>(_FileHandle,0,1);\n              *(__int64 *)((&DAT_140037490)[local_58] + 0x30 + uVar9 * 0x48) = _Var11;\n              lVar16 = (&DAT_140037490)[local_58];\n              pwVar17 = pwVar10;\n              goto LAB_1400181bb;\n            }\n            puVar8 = __doserrno();\n            *puVar8 = 0xc;\n            puVar8 = __doserrno();\n            *puVar8 = 8;\n          }\n          else {\n            pwVar17 = (wchar_t *)_DstBuf;\n            uVar13 = _MaxCharCount;\n            if ((cVar4 == '\\x02') && ((~(byte)_MaxCharCount & 1) == 0)) {\nLAB_140018109:\n              puVar8 = __doserrno();\n              *puVar8 = 0;\n              puVar8 = __doserrno();\n              *puVar8 = 0x16;\n              FUN_14000d030();\n            }\n            else {\nLAB_1400181bb:\n              pwVar18 = pwVar17;\n              nNumberOfBytesToRead = uVar13;\n              if (((*(byte *)(lVar16 + 0x38 + uVar9 * 0x48) & 0x48) != 0) &&\n                 ((cVar3 = *(char *)(lVar16 + 0x3a + uVar9 * 0x48), cVar3 != '\\n' && (uVar13 != 0)))\n                 ) {\n                *(char *)pwVar17 = cVar3;\n                nNumberOfBytesToRead = uVar13 - 1;\n                pwVar18 = (wchar_t *)((longlong)pwVar17 + 1);\n                iVar14 = 1;\n                *(undefined *)((&DAT_140037490)[local_58] + 0x3a + uVar9 * 0x48) = 10;\n                if ((cVar4 != '\\0') &&\n                   ((cVar3 = *(char *)((&DAT_140037490)[local_58] + 0x3b + uVar9 * 0x48),\n                    cVar3 != '\\n' && (nNumberOfBytesToRead != 0)))) {\n                  *(char *)pwVar18 = cVar3;\n                  pwVar18 = pwVar17 + 1;\n                  nNumberOfBytesToRead = uVar13 - 2;\n                  *(undefined *)((&DAT_140037490)[local_58] + 0x3b + uVar9 * 0x48) = 10;\n                  iVar14 = 2;\n                  if ((cVar4 == '\\x01') &&\n                     ((cVar3 = *(char *)((&DAT_140037490)[local_58] + 0x3c + uVar9 * 0x48),\n                      cVar3 != '\\n' && (iVar14 = 2, nNumberOfBytesToRead != 0)))) {\n                    *(char *)pwVar18 = cVar3;\n                    iVar14 = 3;\n                    pwVar18 = (wchar_t *)((longlong)pwVar17 + 3);\n                    nNumberOfBytesToRead = uVar13 - 3;\n                    *(undefined *)((&DAT_140037490)[local_58] + 0x3c + uVar9 * 0x48) = 10;\n                  }\n                }\n              }\n              local_48 = pwVar17;\n              iVar5 = _isatty(_FileHandle);\n              if (((iVar5 == 0) ||\n                  (-1 < *(char *)((&DAT_140037490)[local_58] + 0x38 + uVar9 * 0x48))) ||\n                 (BVar6 = GetConsoleMode(local_60,local_68), BVar6 == 0)) {\n                local_50 = local_50 & 0xffffffffffffff00;\nLAB_1400182e3:\n                BVar6 = ReadFile(local_60,pwVar18,nNumberOfBytesToRead,local_res20,(LPOVERLAPPED)0x0\n                                );\n                if ((BVar6 != 0) && (local_res20[0] <= _MaxCharCount)) {\nLAB_14001831e:\n                  iVar14 = iVar14 + local_res20[0];\n                  if (*(char *)((&DAT_140037490)[local_58] + 0x38 + uVar9 * 0x48) < '\\0') {\n                    if (cVar4 == '\\x02') {\n                      uVar15 = (ulonglong)(longlong)iVar14 >> 1;\n                      if ((char)local_50 == '\\0') {\n                        iVar14 = translate_text_mode_nolock<wchar_t>(_FileHandle,local_48,uVar15);\n                      }\n                      else {\n                        pwVar17 = local_48;\n                        for (pwVar18 = local_48; pwVar18 < local_48 + uVar15;\n                            pwVar18 = (wchar_t *)((longlong)pwVar18 + lVar16)) {\n                          wVar12 = *pwVar18;\n                          if (wVar12 == L'\\x1a') {\n                            pbVar1 = (byte *)((&DAT_140037490)[local_58] + 0x38 + uVar9 * 0x48);\n                            *pbVar1 = *pbVar1 | 2;\n                            break;\n                          }\n                          if (((wVar12 == L'\\r') && (pwVar18 + 1 < local_48 + uVar15)) &&\n                             (pwVar18[1] == L'\\n')) {\n                            wVar12 = L'\\n';\n                            lVar16 = 4;\n                          }\n                          else {\n                            lVar16 = 2;\n                          }\n                          *pwVar17 = wVar12;\n                          pwVar17 = pwVar17 + 1;\n                        }\n                        iVar14 = (int)((longlong)pwVar17 - (longlong)local_48 >> 1) * 2;\n                      }\n                    }\n                    else {\n                      iVar14 = translate_ansi_or_utf8_nolock\n                                         (_FileHandle,(char *)pwVar18,(longlong)iVar14,\n                                          (wchar_t *)_DstBuf,(ulonglong)(_MaxCharCount >> 1));\n                    }\n                  }\n                  goto LAB_1400182c3;\n                }\n                DVar7 = GetLastError();\n                if (DVar7 != 5) {\n                  if (DVar7 == 0x6d) {\n                    iVar14 = 0;\n                    goto LAB_1400182c3;\n                  }\n                  goto LAB_1400182b9;\n                }\n                puVar8 = __doserrno();\n                *puVar8 = 9;\n                puVar8 = __doserrno();\n                *puVar8 = 5;\n              }\n              else {\n                if (cVar4 != '\\x02') goto LAB_1400182e3;\n                BVar6 = ReadConsoleW(local_60,pwVar18,nNumberOfBytesToRead >> 1,local_res20,\n                                     (PCONSOLE_READCONSOLE_CONTROL)0x0);\n                if (BVar6 != 0) {\n                  local_res20[0] = local_res20[0] * 2;\n                  goto LAB_14001831e;\n                }\n                DVar7 = GetLastError();\nLAB_1400182b9:\n                __acrt_errno_map_os_error(DVar7);\n              }\n            }\n          }\n          iVar14 = -1;\nLAB_1400182c3:\n          _free_base(pwVar10);\n          return iVar14;\n        }\n      }\n      puVar8 = __doserrno();\n      *puVar8 = 0;\n      puVar8 = __doserrno();\n      *puVar8 = 0x16;\n      goto LAB_140018442;\n    }\n  }\n  puVar8 = __doserrno();\n  *puVar8 = 0;\n  puVar8 = __doserrno();\n  *puVar8 = 9;\nLAB_140018442:\n  FUN_14000d030();\n  return -1;\n}\n\n",
  "__vcrt_initialize_locks": "\n/* Library Function - Single Match\n    __vcrt_initialize_locks\n   \n   Library: Visual Studio 2019 Release */\n\nbool __vcrt_initialize_locks(void)\n\n{\n  int iVar1;\n  \n  iVar1 = __vcrt_InitializeCriticalSectionEx((LPCRITICAL_SECTION)&DAT_140036db8,4000,0);\n  if (iVar1 == 0) {\n    __vcrt_uninitialize_locks();\n  }\n  else {\n    DAT_140036de0 = DAT_140036de0 + 1;\n  }\n  return iVar1 != 0;\n}\n\n",
  "FUN_140004b08": "\nundefined8 FUN_140004b08(undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
  "FUN_140004104": "\nundefined8 * FUN_140004104(undefined8 *param_1,ulonglong param_2)\n\n{\n  *param_1 = std::_Facet_base::vftable;\n  if ((param_2 & 1) != 0) {\n    thunk_FUN_14000ce08(param_1);\n  }\n  return param_1;\n}\n\n",
  "Initcvt": "\n/* Library Function - Multiple Matches With Same Base Name\n    protected: void __cdecl std::basic_filebuf<char,struct std::char_traits<char> >::_Initcvt(class\n   std::codecvt<char,char,struct _Mbstatet> const & __ptr64) __ptr64\n    protected: void __cdecl std::basic_filebuf<unsigned short,struct std::char_traits<unsigned\n   short> >::_Initcvt(class std::codecvt<unsigned short,char,struct _Mbstatet> const & __ptr64)\n   __ptr64\n    protected: void __cdecl std::basic_filebuf<wchar_t,struct std::char_traits<wchar_t>\n   >::_Initcvt(class std::codecvt<wchar_t,char,struct _Mbstatet> const & __ptr64) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nvoid Initcvt(longlong param_1,longlong *param_2)\n\n{\n  char cVar1;\n  \n  cVar1 = (*(code *)PTR__guard_dispatch_icall_140023298)(param_2);\n  if (cVar1 == '\\0') {\n    *(longlong **)(param_1 + 0x68) = param_2;\n    *(undefined8 **)(param_1 + 0x18) = (undefined8 *)(param_1 + 8);\n    *(undefined8 **)(param_1 + 0x20) = (undefined8 *)(param_1 + 0x10);\n    *(undefined8 **)(param_1 + 0x38) = (undefined8 *)(param_1 + 0x28);\n    *(undefined8 **)(param_1 + 0x40) = (undefined8 *)(param_1 + 0x30);\n    *(undefined4 **)(param_1 + 0x50) = (undefined4 *)(param_1 + 0x48);\n    *(undefined4 **)(param_1 + 0x58) = (undefined4 *)(param_1 + 0x4c);\n    *(undefined8 *)(param_1 + 0x10) = 0;\n    *(undefined8 *)(param_1 + 0x30) = 0;\n    *(undefined4 *)(param_1 + 0x4c) = 0;\n    *(undefined8 *)(param_1 + 8) = 0;\n    *(undefined8 *)(param_1 + 0x28) = 0;\n    *(undefined4 *)(param_1 + 0x48) = 0;\n  }\n  else {\n    *(undefined8 *)(param_1 + 0x68) = 0;\n  }\n  return;\n}\n\n",
  "ExFilterRethrowFH4": "\n/* Library Function - Single Match\n    int __cdecl ExFilterRethrowFH4(struct _EXCEPTION_POINTERS * __ptr64,struct EHExceptionRecord *\n   __ptr64,int,int * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\nExFilterRethrowFH4(_EXCEPTION_POINTERS *param_1,EHExceptionRecord *param_2,int param_3,int *param_4)\n\n{\n  int iVar1;\n  longlong lVar2;\n  \n  iVar1 = ExFilterRethrow(param_1,param_2,param_4);\n  if (iVar1 == 0) {\n    lVar2 = FUN_140008b20();\n    *(int *)(lVar2 + 0x78) = param_3;\n  }\n  return iVar1;\n}\n\n",
  "FUN_1400038b8": "\nundefined8 * FUN_1400038b8(undefined8 *param_1,longlong param_2)\n\n{\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  __std_exception_copy((char **)(param_2 + 8),(char **)(param_1 + 1));\n  *param_1 = std::length_error::vftable;\n  return param_1;\n}\n\n",
  "FUN_14001c218": "\nLPVOID FUN_14001c218(char **param_1)\n\n{\n  char **ppcVar1;\n  longlong lVar2;\n  errno_t eVar3;\n  LPVOID pvVar4;\n  char *pcVar5;\n  LPVOID pvVar6;\n  longlong lVar7;\n  longlong lVar8;\n  \n  if (param_1 == (char **)0x0) {\n    pvVar4 = (LPVOID)0x0;\n  }\n  else {\n    lVar7 = 0;\n    pcVar5 = *param_1;\n    ppcVar1 = param_1;\n    while (pcVar5 != (char *)0x0) {\n      lVar7 = lVar7 + 1;\n      ppcVar1 = ppcVar1 + 1;\n      pcVar5 = *ppcVar1;\n    }\n    pvVar4 = _calloc_base(lVar7 + 1,8);\n    if (pvVar4 == (LPVOID)0x0) {\nLAB_14001c2f7:\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    pcVar5 = *param_1;\n    if (pcVar5 != (char *)0x0) {\n      lVar7 = (longlong)pvVar4 - (longlong)param_1;\n      do {\n        lVar2 = -1;\n        do {\n          lVar8 = lVar2;\n          lVar2 = lVar8 + 1;\n        } while (pcVar5[lVar8 + 1] != '\\0');\n        pvVar6 = _calloc_base(lVar8 + 2,1);\n        *(LPVOID *)(lVar7 + (longlong)param_1) = pvVar6;\n        _free_base((LPVOID)0x0);\n        pcVar5 = *(char **)(lVar7 + (longlong)param_1);\n        if (pcVar5 == (char *)0x0) goto LAB_14001c2f7;\n        eVar3 = strcpy_s(pcVar5,lVar8 + 2,*param_1);\n        if (eVar3 != 0) {\n                    /* WARNING: Subroutine does not return */\n          _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n        }\n        param_1 = param_1 + 1;\n        pcVar5 = *param_1;\n      } while (pcVar5 != (char *)0x0);\n    }\n    _free_base((LPVOID)0x0);\n  }\n  return pvVar4;\n}\n\n",
  "wcscspn": "\n/* Library Function - Single Match\n    wcscspn\n   \n   Library: Visual Studio 2019 Release */\n\nsize_t __cdecl wcscspn(wchar_t *_Str,wchar_t *_Control)\n\n{\n  wchar_t *pwVar1;\n  wchar_t wVar2;\n  wchar_t *pwVar3;\n  \n  wVar2 = *_Str;\n  pwVar1 = _Str;\n  while (wVar2 != L'\\0') {\n    if (*_Control != L'\\0') {\n      wVar2 = *_Control;\n      pwVar3 = _Control;\n      do {\n        if (*pwVar1 == wVar2) goto LAB_14001d670;\n        pwVar3 = pwVar3 + 1;\n        wVar2 = *pwVar3;\n      } while (wVar2 != L'\\0');\n    }\n    pwVar1 = pwVar1 + 1;\n    wVar2 = *pwVar1;\n  }\nLAB_14001d670:\n  return (longlong)pwVar1 - (longlong)_Str >> 1;\n}\n\n",
  "FUN_140001a80": "\nlonglong FUN_140001a80(longlong param_1)\n\n{\n  int *piVar1;\n  longlong lVar2;\n  \n  LOCK();\n  piVar1 = (int *)(param_1 + 8);\n  *piVar1 = *piVar1 + -1;\n  UNLOCK();\n  lVar2 = 0;\n  if (*piVar1 == 0) {\n    lVar2 = param_1;\n  }\n  return lVar2;\n}\n\n",
  "common_fseek_nolock": "\n/* Library Function - Single Match\n    int __cdecl common_fseek_nolock(class __crt_stdio_stream,__int64,int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 __cdecl common_fseek_nolock(FILE *param_1,longlong param_2,int param_3)\n\n{\n  uint *puVar1;\n  ulong *puVar2;\n  undefined8 uVar3;\n  ulonglong uVar4;\n  __int64 _Var5;\n  \n  if ((*(uint *)((longlong)&param_1->_base + 4) >> 0xd & 1) == 0) {\n    puVar2 = __doserrno();\n    *puVar2 = 0x16;\nLAB_14000dfa1:\n    uVar3 = 0xffffffff;\n  }\n  else {\n    LOCK();\n    puVar1 = (uint *)((longlong)&param_1->_base + 4);\n    *puVar1 = *puVar1 & 0xfffffff7;\n    UNLOCK();\n    uVar4 = common_fseek_binary_mode_read_only_fast_track_nolock\n                      ((longlong *)param_1,param_2,param_3);\n    if ((char)uVar4 == '\\0') {\n      if (param_3 == 1) {\n        uVar4 = common_ftell_nolock<__int64>(param_1);\n        param_2 = param_2 + uVar4;\n        param_3 = 0;\n      }\n      __acrt_stdio_flush_nolock(param_1);\n      *(undefined4 *)&param_1->_base = 0;\n      param_1->_ptr = *(char **)&param_1->_cnt;\n      if ((*(uint *)((longlong)&param_1->_base + 4) >> 2 & 1) == 0) {\n        if ((((byte)*(undefined4 *)((longlong)&param_1->_base + 4) & 0x41) == 0x41) &&\n           ((*(uint *)((longlong)&param_1->_base + 4) >> 8 & 1) == 0)) {\n          param_1->_charbuf = 0x200;\n        }\n      }\n      else {\n        LOCK();\n        puVar1 = (uint *)((longlong)&param_1->_base + 4);\n        *puVar1 = *puVar1 & 0xfffffffc;\n        UNLOCK();\n      }\n      _Var5 = common_lseek_nolock<__int64>(param_1->_flag,param_2,param_3);\n      if (_Var5 == -1) goto LAB_14000dfa1;\n    }\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
  "__acrt_FlsFree": "\n/* WARNING: Switch with 1 destination removed at 0x000140015743 */\n/* Library Function - Single Match\n    __acrt_FlsFree\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_FlsFree(undefined4 param_1)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  \n  UNRECOVERED_JUMPTABLE =\n       (code *)try_get_function(4,\"FlsFree\",(module_id *)&DAT_140028dd0,(module_id *)&DAT_140028dd8)\n  ;\n  if (UNRECOVERED_JUMPTABLE == (code *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00014001574f. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    TlsFree(param_1);\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x000140021e60. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
  "wcsncpy_s": "\n/* Library Function - Single Match\n    wcsncpy_s\n   \n   Library: Visual Studio 2019 Release */\n\nerrno_t __cdecl wcsncpy_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src,rsize_t _MaxCount)\n\n{\n  wchar_t wVar1;\n  ulong *puVar2;\n  wchar_t *pwVar3;\n  ulong uVar4;\n  rsize_t rVar5;\n  rsize_t rVar6;\n  \n  if (_MaxCount == 0) {\n    if (_Dst == (wchar_t *)0x0) {\n      if (_SizeInWords == 0) {\n        return 0;\n      }\n    }\n    else {\nLAB_14001a8fd:\n      if (_SizeInWords != 0) {\n        if (_MaxCount == 0) {\n          *_Dst = L'\\0';\n          return 0;\n        }\n        if (_Src != (wchar_t *)0x0) {\n          pwVar3 = _Dst;\n          rVar5 = _MaxCount;\n          rVar6 = _SizeInWords;\n          if (_MaxCount == 0xffffffffffffffff) {\n            do {\n              wVar1 = *(wchar_t *)(((longlong)_Src - (longlong)_Dst) + (longlong)pwVar3);\n              *pwVar3 = wVar1;\n              pwVar3 = pwVar3 + 1;\n              if (wVar1 == L'\\0') break;\n              rVar6 = rVar6 - 1;\n            } while (rVar6 != 0);\n          }\n          else {\n            do {\n              wVar1 = *(wchar_t *)(((longlong)_Src - (longlong)_Dst) + (longlong)pwVar3);\n              *pwVar3 = wVar1;\n              pwVar3 = pwVar3 + 1;\n              if ((wVar1 == L'\\0') || (rVar6 = rVar6 - 1, rVar6 == 0)) break;\n              rVar5 = rVar5 - 1;\n            } while (rVar5 != 0);\n            if (rVar5 == 0) {\n              *pwVar3 = L'\\0';\n            }\n          }\n          if (rVar6 != 0) {\n            return 0;\n          }\n          if (_MaxCount == 0xffffffffffffffff) {\n            _Dst[_SizeInWords - 1] = L'\\0';\n            return 0x50;\n          }\n          *_Dst = L'\\0';\n          puVar2 = __doserrno();\n          uVar4 = 0x22;\n          goto LAB_14001a8e0;\n        }\n        *_Dst = L'\\0';\n      }\n    }\n  }\n  else if (_Dst != (wchar_t *)0x0) goto LAB_14001a8fd;\n  puVar2 = __doserrno();\n  uVar4 = 0x16;\nLAB_14001a8e0:\n  *puVar2 = uVar4;\n  FUN_14000d030();\n  return uVar4;\n}\n\n",
  "FUN_1400057a8": "\nios_base * FUN_1400057a8(longlong param_1,uint param_2)\n\n{\n  ios_base *piVar1;\n  ios_base *piVar2;\n  \n  piVar2 = (ios_base *)(param_1 - *(int *)(param_1 + -4));\n  piVar1 = piVar2 + -0x18;\n  *(undefined ***)(piVar2 + (longlong)*(int *)(*(longlong *)piVar1 + 4) + -0x18) =\n       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;\n  *(int *)(piVar2 + (longlong)*(int *)(*(longlong *)piVar1 + 4) + -0x1c) =\n       *(int *)(*(longlong *)piVar1 + 4) + -0x18;\n  *(undefined ***)piVar2 = std::ios_base::vftable;\n  std::ios_base::_Ios_base_dtor(piVar2);\n  if ((param_2 & 1) != 0) {\n    thunk_FUN_14000ce08(piVar1);\n  }\n  return piVar1;\n}\n\n",
  "FUN_1400069b4": "\nvoid FUN_1400069b4(void)\n\n{\n  undefined8 local_28 [5];\n  \n  FUN_140003814(local_28);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_28,(ThrowInfo *)&DAT_140033990);\n}\n\n",
  "replace_current_thread_locale_nolock": "\n/* Library Function - Single Match\n    void __cdecl replace_current_thread_locale_nolock(struct __acrt_ptd * __ptr64 const,struct\n   __crt_locale_data * __ptr64 const)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl replace_current_thread_locale_nolock(__acrt_ptd *param_1,__crt_locale_data *param_2)\n\n{\n  undefined **ppuVar1;\n  \n  if (*(longlong *)(param_1 + 0x90) != 0) {\n    __acrt_release_locale_ref(*(longlong *)(param_1 + 0x90));\n    ppuVar1 = *(undefined ***)(param_1 + 0x90);\n    if (((ppuVar1 != DAT_1400372c0) && (ppuVar1 != &PTR_DAT_140035260)) &&\n       (*(int *)(ppuVar1 + 2) == 0)) {\n      __acrt_free_locale(ppuVar1);\n    }\n  }\n  *(__crt_locale_data **)(param_1 + 0x90) = param_2;\n  if (param_2 != (__crt_locale_data *)0x0) {\n    __acrt_add_locale_ref((longlong)param_2);\n  }\n  return;\n}\n\n",
  "GetCurrentState": "\n/* Library Function - Single Match\n    public: static int __cdecl __FrameHandler3::GetCurrentState(unsigned __int64 * __ptr64,struct\n   _xDISPATCHER_CONTEXT * __ptr64,struct _s_FuncInfo const * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\n__FrameHandler3::GetCurrentState\n          (__uint64 *param_1,_xDISPATCHER_CONTEXT *param_2,_s_FuncInfo *param_3)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)((longlong)param_3->dispUnwindHelp + *param_1);\n  if (iVar1 == -2) {\n    iVar1 = FUN_140008d64((longlong)param_3,(longlong)param_2,*(ulonglong *)param_2);\n  }\n  return iVar1;\n}\n\n",
  "__acrt_locale_free_lc_time_if_unreferenced": "\n/* Library Function - Single Match\n    __acrt_locale_free_lc_time_if_unreferenced\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_locale_free_lc_time_if_unreferenced(undefined **param_1)\n\n{\n  if (((param_1 != (undefined **)0x0) && (param_1 != &PTR_DAT_1400281f0)) &&\n     (*(int *)((longlong)param_1 + 0x15c) == 0)) {\n    __acrt_locale_free_time(param_1);\n    _free_base(param_1);\n  }\n  return;\n}\n\n",
  "operator()<class_<lambda_751a882b2c74d4b022dec766aa51a29a>,class_<lambda_628dfdc04ba53c8bfc02c9951375f3f5>&___ptr64,class_<lambda_f6c7be5f7998530c34de24c7437d6b54>_>": "\n/* Library Function - Single Match\n    public: int __cdecl __crt_seh_guarded_call<int>::operator()<class\n   <lambda_751a882b2c74d4b022dec766aa51a29a>,class <lambda_628dfdc04ba53c8bfc02c9951375f3f5> &\n   __ptr64,class <lambda_f6c7be5f7998530c34de24c7437d6b54> >(class\n   <lambda_751a882b2c74d4b022dec766aa51a29a> && __ptr64,class\n   <lambda_628dfdc04ba53c8bfc02c9951375f3f5> & __ptr64,class\n   <lambda_f6c7be5f7998530c34de24c7437d6b54> && __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_751a882b2c74d4b022dec766aa51a29a>,class_<lambda_628dfdc04ba53c8bfc02c9951375f3f5>&___ptr64,class_<lambda_f6c7be5f7998530c34de24c7437d6b54>_>\n          (__crt_seh_guarded_call<int> *this,<lambda_751a882b2c74d4b022dec766aa51a29a> *param_1,\n          <lambda_628dfdc04ba53c8bfc02c9951375f3f5> *param_2,\n          <lambda_f6c7be5f7998530c34de24c7437d6b54> *param_3)\n\n{\n  uint _FileHandle;\n  int iVar1;\n  ulong *puVar2;\n  \n  FID_conflict___acrt_lowio_lock_fh(*(uint *)param_1);\n  _FileHandle = **(uint **)param_2;\n  if ((*(byte *)((&DAT_140037490)[(longlong)(int)_FileHandle >> 6] + 0x38 +\n                (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) == 0) {\n    puVar2 = __doserrno();\n    *puVar2 = 9;\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = _close_nolock(_FileHandle);\n  }\n  FID_conflict___acrt_lowio_lock_fh(*(uint *)param_3);\n  return iVar1;\n}\n\n",
  "FUN_140002ee0": "\nvoid FUN_140002ee0(longlong *param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 *puVar3;\n  longlong lVar4;\n  char *pcVar5;\n  undefined4 local_48 [4];\n  char ****local_38 [6];\n  \n  lVar4 = (longlong)*(int *)(*param_1 + 4);\n  if ((*(int *)(lVar4 + 0x10 + (longlong)param_1) == 0) &&\n     ((*(byte *)(lVar4 + 0x18 + (longlong)param_1) & 2) != 0)) {\n    iVar1 = (**(code **)(**(longlong **)(lVar4 + 0x48 + (longlong)param_1) + 0x68))();\n    if (iVar1 == -1) {\n      lVar4 = (longlong)*(int *)(*param_1 + 4);\n      uVar2 = *(uint *)(lVar4 + 0x10 + (longlong)param_1) & 0x13 | 4;\n      *(uint *)(lVar4 + 0x10 + (longlong)param_1) = uVar2;\n      uVar2 = uVar2 & *(uint *)(lVar4 + 0x14 + (longlong)param_1);\n      if (uVar2 != 0) {\n        if ((uVar2 & 4) == 0) {\n          pcVar5 = \"ios_base::failbit set\";\n          if ((uVar2 & 2) == 0) {\n            pcVar5 = \"ios_base::eofbit set\";\n          }\n        }\n        else {\n          pcVar5 = \"ios_base::badbit set\";\n        }\n        puVar3 = (undefined8 *)FUN_140001450(local_48,1);\n        FUN_140001dd0(local_38,(undefined8 *)pcVar5,puVar3);\n                    /* WARNING: Subroutine does not return */\n        _CxxThrowException(local_38,(ThrowInfo *)&DAT_140033c40);\n      }\n    }\n  }\n  return;\n}\n\n",
  "FUN_1400225fe": "\nvoid FUN_1400225fe(int **param_1)\n\n{\n  __FrameUnwindFilter(param_1);\n  return;\n}\n\n",
  "memcmp": "\n/* Library Function - Single Match\n    memcmp\n   \n   Library: Visual Studio */\n\nint __cdecl memcmp(void *_Buf1,void *_Buf2,size_t _Size)\n\n{\n  uint uVar1;\n  ulonglong uVar2;\n  longlong lVar3;\n  ulonglong uVar4;\n  bool bVar5;\n  \n  lVar3 = (longlong)_Buf2 - (longlong)_Buf1;\n  if (7 < _Size) {\n    uVar4 = (ulonglong)_Buf1 & 7;\n    while (uVar4 != 0) {\n                    /* WARNING: Load size is inaccurate */\n      bVar5 = *_Buf1 < *(byte *)((longlong)_Buf1 + lVar3);\n      if (*_Buf1 != *(byte *)((longlong)_Buf1 + lVar3)) goto LAB_140008803;\n      _Buf1 = (void *)((longlong)_Buf1 + 1);\n      _Size = _Size - 1;\n      uVar4 = (ulonglong)_Buf1 & 7;\n    }\n    if (_Size >> 3 != 0) {\n      uVar4 = _Size >> 5;\n      if (uVar4 != 0) {\n        do {\n                    /* WARNING: Load size is inaccurate */\n          uVar2 = *_Buf1;\n          if (uVar2 != *(ulonglong *)((longlong)_Buf1 + lVar3)) goto LAB_140008874;\n          uVar2 = *(ulonglong *)((longlong)_Buf1 + 8);\n          if (uVar2 != *(ulonglong *)((longlong)_Buf1 + lVar3 + 8)) {\nLAB_140008870:\n            _Buf1 = (void *)((longlong)_Buf1 + 8);\n            goto LAB_140008874;\n          }\n          uVar2 = *(ulonglong *)((longlong)_Buf1 + 0x10);\n          if (uVar2 != *(ulonglong *)((longlong)_Buf1 + lVar3 + 0x10)) {\nLAB_14000886c:\n            _Buf1 = (void *)((longlong)_Buf1 + 8);\n            goto LAB_140008870;\n          }\n          uVar2 = *(ulonglong *)((longlong)_Buf1 + 0x18);\n          if (uVar2 != *(ulonglong *)((longlong)_Buf1 + lVar3 + 0x18)) {\n            _Buf1 = (void *)((longlong)_Buf1 + 8);\n            goto LAB_14000886c;\n          }\n          _Buf1 = (void *)((longlong)_Buf1 + 0x20);\n          uVar4 = uVar4 - 1;\n        } while (uVar4 != 0);\n        _Size = _Size & 0x1f;\n      }\n      uVar4 = _Size >> 3;\n      if (uVar4 != 0) {\n        do {\n                    /* WARNING: Load size is inaccurate */\n          uVar2 = *_Buf1;\n          if (uVar2 != *(ulonglong *)((longlong)_Buf1 + lVar3)) {\nLAB_140008874:\n            uVar4 = *(ulonglong *)(lVar3 + (longlong)_Buf1);\n            uVar1 = (uint)((uVar2 >> 0x38 | (uVar2 & 0xff000000000000) >> 0x28 |\n                            (uVar2 & 0xff0000000000) >> 0x18 | (uVar2 & 0xff00000000) >> 8 |\n                            (uVar2 & 0xff000000) << 8 | (uVar2 & 0xff0000) << 0x18 |\n                            (uVar2 & 0xff00) << 0x28 | uVar2 << 0x38) <\n                          (uVar4 >> 0x38 | (uVar4 & 0xff000000000000) >> 0x28 |\n                           (uVar4 & 0xff0000000000) >> 0x18 | (uVar4 & 0xff00000000) >> 8 |\n                           (uVar4 & 0xff000000) << 8 | (uVar4 & 0xff0000) << 0x18 |\n                           (uVar4 & 0xff00) << 0x28 | uVar4 << 0x38));\n            return (1 - uVar1) - (uint)(uVar1 != 0);\n          }\n          _Buf1 = (void *)((longlong)_Buf1 + 8);\n          uVar4 = uVar4 - 1;\n        } while (uVar4 != 0);\n        _Size = _Size & 7;\n      }\n    }\n  }\n  while( true ) {\n    if (_Size == 0) {\n      return 0;\n    }\n                    /* WARNING: Load size is inaccurate */\n    bVar5 = *_Buf1 < *(byte *)((longlong)_Buf1 + lVar3);\n    if (*_Buf1 != *(byte *)((longlong)_Buf1 + lVar3)) break;\n    _Buf1 = (void *)((longlong)_Buf1 + 1);\n    _Size = _Size - 1;\n  }\nLAB_140008803:\n  return (1 - (uint)bVar5) - (uint)(bVar5 != 0);\n}\n\n",
  "_CallSettingFrame": "\n/* Library Function - Single Match\n    _CallSettingFrame\n   \n   Library: Visual Studio 2019 Release */\n\nvoid _CallSettingFrame(void)\n\n{\n  code *pcVar1;\n  \n  pcVar1 = (code *)FUN_14000bd20();\n  (*pcVar1)();\n  FUN_14000bd50();\n  FUN_14000bd20();\n  return;\n}\n\n",
  "_wsetlocale_set_cat": "\n/* Library Function - Single Match\n    _wsetlocale_set_cat\n   \n   Library: Visual Studio 2019 Release */\n\nvoid _wsetlocale_set_cat(longlong param_1,int param_2,wchar_t *param_3)\n\n{\n  wchar_t wVar1;\n  wchar_t wVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  errno_t eVar5;\n  int iVar6;\n  longlong lVar7;\n  longlong lVar8;\n  undefined4 *puVar9;\n  ushort *puVar10;\n  undefined8 uVar11;\n  wchar_t *pwVar12;\n  wchar_t *pwVar13;\n  longlong lVar14;\n  uint uVar15;\n  longlong lVar17;\n  longlong lVar18;\n  undefined auStackY_368 [32];\n  UINT local_328;\n  undefined4 local_324;\n  undefined *local_320;\n  undefined8 local_318;\n  wchar_t local_308;\n  short local_306;\n  wchar_t local_1f8 [88];\n  WORD local_148 [128];\n  ulonglong local_48;\n  wchar_t *pwVar16;\n  \n  local_48 = DAT_140035020 ^ (ulonglong)auStackY_368;\n  lVar18 = (longlong)param_2;\n  lVar7 = FUN_140014d84();\n  lVar8 = _expandlocale(param_3,&local_308,0x83,local_1f8,0x55,&local_328);\n  if (lVar8 != 0) {\n    pwVar12 = &local_308;\n    lVar8 = lVar18 * 0x20;\n    lVar17 = *(longlong *)(lVar8 + 0x28 + param_1) - (longlong)pwVar12;\n    do {\n      wVar1 = *pwVar12;\n      wVar2 = *(wchar_t *)((longlong)pwVar12 + lVar17);\n      if (wVar1 != wVar2) break;\n      pwVar12 = pwVar12 + 1;\n    } while (wVar2 != L'\\0');\n    if (wVar1 != wVar2) {\n      lVar17 = -1;\n      do {\n        lVar14 = lVar17;\n        lVar17 = lVar14 + 1;\n      } while ((&local_308)[lVar17] != L'\\0');\n      puVar9 = (undefined4 *)_malloc_base(lVar17 * 2 + 6);\n      if (puVar9 != (undefined4 *)0x0) {\n        local_320 = *(undefined **)(lVar8 + 0x28 + param_1);\n        local_318 = *(undefined8 *)(param_1 + 0x128 + lVar18 * 8);\n        local_324 = *(undefined4 *)(param_1 + 0xc);\n        eVar5 = wcscpy_s((wchar_t *)(puVar9 + 1),lVar14 + 2,&local_308);\n        pwVar12 = (wchar_t *)0x0;\n        if (eVar5 != 0) {\n                    /* WARNING: Subroutine does not return */\n          _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n        }\n        *(undefined4 **)(lVar8 + 0x28 + param_1) = puVar9 + 1;\n        if ((local_308 != L'C') || (pwVar13 = pwVar12, local_306 != 0)) {\n          pwVar13 = __acrt_copy_locale_name((undefined (*) [32])local_1f8);\n        }\n        *(wchar_t **)(param_1 + 0x128 + lVar18 * 8) = pwVar13;\n        if (param_2 == 2) {\n          *(UINT *)(param_1 + 0xc) = local_328;\n          uVar11 = *(undefined8 *)(lVar7 + 0x2e8);\n          pwVar13 = pwVar12;\n          pwVar16 = pwVar12;\n          do {\n            uVar15 = (uint)pwVar16;\n            if (*(int *)(param_1 + 0xc) == *(int *)(lVar7 + 0x2c8 + (longlong)pwVar13 * 8)) {\n              if (uVar15 != 0) {\n                *(undefined8 *)(lVar7 + 0x2c8) =\n                     *(undefined8 *)(lVar7 + 0x2c8 + (longlong)(int)uVar15 * 8);\n                *(undefined8 *)(lVar7 + 0x2c8 + (longlong)(int)uVar15 * 8) = uVar11;\n              }\n              break;\n            }\n            uVar3 = *(undefined8 *)(lVar7 + 0x2c8 + (longlong)pwVar13 * 8);\n            uVar15 = uVar15 + 1;\n            pwVar16 = (wchar_t *)(ulonglong)uVar15;\n            *(undefined8 *)(lVar7 + 0x2c8 + (longlong)pwVar13 * 8) = uVar11;\n            pwVar13 = (wchar_t *)((longlong)pwVar13 + 1);\n            uVar11 = uVar3;\n          } while ((longlong)pwVar13 < 5);\n          if (uVar15 == 5) {\n            iVar6 = __acrt_GetStringTypeA\n                              ((__crt_locale_pointers *)0x0,1,\n                               \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\t\\n\\v\\f\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\"\n                               ,0x7f,local_148,*(UINT *)(param_1 + 0xc),1);\n            uVar15 = 0;\n            if (iVar6 != 0) {\n              puVar10 = local_148;\n              do {\n                uVar15 = (int)pwVar12 + 1;\n                pwVar12 = (wchar_t *)(ulonglong)uVar15;\n                *puVar10 = *puVar10 & 0x1ff;\n                puVar10 = puVar10 + 1;\n              } while (uVar15 < 0x7f);\n              iVar6 = memcmp(local_148,PTR_DAT_140035240,0xfe);\n              uVar15 = (uint)(iVar6 == 0);\n            }\n            *(uint *)(lVar7 + 0x2cc) = uVar15;\n            *(undefined4 *)(lVar7 + 0x2c8) = *(undefined4 *)(param_1 + 0xc);\n          }\n          *(undefined4 *)(param_1 + 0x1c) = *(undefined4 *)(lVar7 + 0x2cc);\n        }\n        else if (param_2 == 1) {\n          *(UINT *)(param_1 + 0x14) = local_328;\n        }\n        else if (param_2 == 5) {\n          *(UINT *)(param_1 + 0x18) = local_328;\n        }\n        iVar6 = (*(code *)PTR__guard_dispatch_icall_140023298)(param_1);\n        if (iVar6 == 0) {\n          if (local_320 != &DAT_1400353c8) {\n            piVar4 = *(int **)(lVar8 + 0x38 + param_1);\n            LOCK();\n            iVar6 = *piVar4;\n            *piVar4 = *piVar4 + -1;\n            UNLOCK();\n            if (iVar6 == 1) {\n              _free_base(*(LPVOID *)(lVar8 + 0x38 + param_1));\n              _free_base(*(LPVOID *)(lVar8 + 0x30 + param_1));\n              _free_base(*(LPVOID *)(param_1 + 0x128 + lVar18 * 8));\n              *(undefined8 *)(lVar8 + 0x28 + param_1) = 0;\n              *(undefined8 *)(param_1 + 0x128 + lVar18 * 8) = 0;\n            }\n          }\n          *puVar9 = 1;\n          *(undefined4 **)(lVar8 + 0x38 + param_1) = puVar9;\n        }\n        else {\n          *(undefined **)(lVar8 + 0x28 + param_1) = local_320;\n          _free_base(*(LPVOID *)(param_1 + 0x128 + lVar18 * 8));\n          *(undefined8 *)(param_1 + 0x128 + lVar18 * 8) = local_318;\n          _free_base(puVar9);\n          *(undefined4 *)(param_1 + 0xc) = local_324;\n        }\n      }\n    }\n  }\n  FUN_140006060(local_48 ^ (ulonglong)auStackY_368);\n  return;\n}\n\n",
  "mbstowcs_s": "\n/* Library Function - Single Match\n    mbstowcs_s\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nerrno_t __cdecl\nmbstowcs_s(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,char *_SrcBuf,\n          size_t _MaxCount)\n\n{\n  errno_t eVar1;\n  \n  eVar1 = _mbstowcs_s_l(_PtNumOfCharConverted,_DstBuf,_SizeInWords,_SrcBuf,_MaxCount,(_locale_t)0x0)\n  ;\n  return eVar1;\n}\n\n",
  "FUN_140003fd4": "\nios_base * FUN_140003fd4(ios_base *param_1,uint param_2)\n\n{\n  *(undefined ***)param_1 = std::ios_base::vftable;\n  std::ios_base::_Ios_base_dtor(param_1);\n  if ((param_2 & 1) != 0) {\n    thunk_FUN_14000ce08(param_1);\n  }\n  return param_1;\n}\n\n",
  "pbackfail": "\n/* Library Function - Single Match\n    protected: virtual int __cdecl std::basic_filebuf<char,struct std::char_traits<char>\n   >::pbackfail(int) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::pbackfail\n          (basic_filebuf<char,struct_std::char_traits<char>_> *this,int param_1)\n\n{\n  basic_filebuf<char,struct_std::char_traits<char>_> *pbVar1;\n  ulonglong uVar2;\n  basic_filebuf<char,struct_std::char_traits<char>_> *pbVar3;\n  int iVar4;\n  \n  uVar2 = **(ulonglong **)(this + 0x38);\n  if (((uVar2 != 0) && (**(ulonglong **)(this + 0x18) < uVar2)) &&\n     ((param_1 == -1 || ((uint)*(byte *)(uVar2 - 1) == param_1)))) {\n    **(int **)(this + 0x50) = **(int **)(this + 0x50) + 1;\n    **(longlong **)(this + 0x38) = **(longlong **)(this + 0x38) + -1;\n    if (param_1 != -1) {\n      return param_1;\n    }\n    return 0;\n  }\n  if ((*(FILE **)(this + 0x80) != (FILE *)0x0) && (param_1 != -1)) {\n    if ((*(longlong *)(this + 0x68) == 0) &&\n       (iVar4 = ungetc(param_1 & 0xff,*(FILE **)(this + 0x80)), iVar4 != -1)) {\n      return param_1;\n    }\n    pbVar1 = this + 0x70;\n    if (**(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x38) != pbVar1) {\n      *pbVar1 = SUB41(param_1,0);\n      pbVar3 = **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x18);\n      if (pbVar3 != pbVar1) {\n        *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x88) = pbVar3;\n        *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x90) =\n             **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x38) +\n             **(int **)(this + 0x50);\n      }\n      **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x18) = pbVar1;\n      **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x38) = pbVar1;\n      **(int **)(this + 0x50) = ((int)this - (int)pbVar1) + 0x71;\n      return param_1;\n    }\n  }\n  return -1;\n}\n\n",
  "`scalar_deleting_destructor'": "\n/* Library Function - Single Match\n    protected: virtual void * __ptr64 __cdecl std::ctype<char>::`scalar deleting\n   destructor'(unsigned int) __ptr64\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid * __thiscall std::ctype<char>::_scalar_deleting_destructor_(ctype<char> *this,uint param_1)\n\n{\n  *(undefined ***)this = vftable;\n  if (*(int *)(this + 0x20) < 1) {\n    if (*(int *)(this + 0x20) < 0) {\n      thunk_FUN_14000ce08(*(LPVOID *)(this + 0x18));\n    }\n  }\n  else {\n    FUN_14000ce08(*(LPVOID *)(this + 0x18));\n  }\n  FUN_14000ce08(*(LPVOID *)(this + 0x28));\n  *(undefined ***)this = _Facet_base::vftable;\n  if ((param_1 & 1) != 0) {\n    thunk_FUN_14000ce08(this);\n  }\n  return this;\n}\n\n",
  "ExFilterRethrow": "\n/* Library Function - Single Match\n    int __cdecl ExFilterRethrow(struct _EXCEPTION_POINTERS * __ptr64,struct EHExceptionRecord *\n   __ptr64,int * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl ExFilterRethrow(_EXCEPTION_POINTERS *param_1,EHExceptionRecord *param_2,int *param_3)\n\n{\n  PEXCEPTION_RECORD pEVar1;\n  int iVar2;\n  longlong lVar3;\n  \n  pEVar1 = param_1->ExceptionRecord;\n  *param_3 = 0;\n  if (((((pEVar1->ExceptionCode == 0xe06d7363) && (pEVar1->NumberParameters == 4)) &&\n       ((2 < *(int *)pEVar1->ExceptionInformation + 0xe66cfae0U ||\n        ((pEVar1->ExceptionInformation[1] != *(ULONG_PTR *)(param_2 + 0x28) ||\n         (*param_3 = 1, pEVar1->ExceptionCode == 0xe06d7363)))))) && (pEVar1->NumberParameters == 4)\n      ) && ((*(int *)pEVar1->ExceptionInformation + 0xe66cfae0U < 3 &&\n            (pEVar1->ExceptionInformation[2] == 0)))) {\n    lVar3 = FUN_140008b20();\n    *(undefined4 *)(lVar3 + 0x40) = 1;\n    iVar2 = 1;\n    *param_3 = 1;\n  }\n  else {\n    iVar2 = 0;\n  }\n  return iVar2;\n}\n\n",
  "__FrameUnwindFilter": "\n/* Library Function - Single Match\n    __FrameUnwindFilter\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __FrameUnwindFilter(int **param_1)\n\n{\n  int *piVar1;\n  code *pcVar2;\n  longlong lVar3;\n  undefined8 uVar4;\n  \n  piVar1 = *param_1;\n  if ((*piVar1 == -0x1fbcbcae) || (*piVar1 == -0x1fbcb0b3)) {\n    lVar3 = FUN_140008b20();\n    if (0 < *(int *)(lVar3 + 0x30)) {\n      lVar3 = FUN_140008b20();\n      *(int *)(lVar3 + 0x30) = *(int *)(lVar3 + 0x30) + -1;\n    }\n  }\n  else if (*piVar1 == -0x1f928c9d) {\n    lVar3 = FUN_140008b20();\n    *(int **)(lVar3 + 0x20) = piVar1;\n    piVar1 = param_1[1];\n    lVar3 = FUN_140008b20();\n    *(int **)(lVar3 + 0x28) = piVar1;\n    terminate();\n    pcVar2 = (code *)swi(3);\n    uVar4 = (*pcVar2)();\n    return uVar4;\n  }\n  return 0;\n}\n\n",
  "common_xtox_s<unsigned_long,wchar_t>": "\n/* Library Function - Single Match\n    int __cdecl common_xtox_s<unsigned long,wchar_t>(unsigned long,wchar_t * __ptr64 const,unsigned\n   __int64,unsigned int,bool)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl\ncommon_xtox_s<unsigned_long,wchar_t>\n          (ulong param_1,wchar_t *param_2,__uint64 param_3,uint param_4,bool param_5)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  ulong uVar3;\n  \n  if ((param_2 != (wchar_t *)0x0) && (param_3 != 0)) {\n    *param_2 = L'\\0';\n    if (param_3 <= (ulonglong)param_5 + 1) {\n      puVar2 = __doserrno();\n      uVar3 = 0x22;\n      goto LAB_1400208a2;\n    }\n    if (param_4 - 2 < 0x23) {\n      iVar1 = common_xtox<unsigned_long,wchar_t>(param_1,param_2,param_3,param_4,param_5);\n      return iVar1;\n    }\n  }\n  puVar2 = __doserrno();\n  uVar3 = 0x16;\nLAB_1400208a2:\n  *puVar2 = uVar3;\n  FUN_14000d030();\n  return uVar3;\n}\n\n",
  "thunk_FUN_140004b0c": "\nundefined8 thunk_FUN_140004b0c(void)\n\n{\n  return 0;\n}\n\n",
  "FUN_1400013f0": "\nundefined8 FUN_1400013f0(longlong *param_1,undefined4 param_2,int *param_3)\n\n{\n  int *piVar1;\n  uint7 uVar2;\n  undefined local_18 [16];\n  \n  piVar1 = (int *)(**(code **)(*param_1 + 0x18))(param_1,local_18,param_2);\n  uVar2 = (uint7)((ulonglong)piVar1 >> 8);\n  if ((*(longlong *)(*(longlong *)(piVar1 + 2) + 8) == *(longlong *)(*(longlong *)(param_3 + 2) + 8)\n      ) && (*piVar1 == *param_3)) {\n    return CONCAT71(uVar2,1);\n  }\n  return (ulonglong)uVar2 << 8;\n}\n\n",
  "FUN_14000743c": "\nundefined (*) [16] FUN_14000743c(undefined (*param_1) [16],int *param_2,int param_3)\n\n{\n  byte bVar1;\n  undefined auVar2 [16];\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  int iVar11;\n  undefined4 uStack_3c;\n  undefined4 uStack_2c;\n  undefined local_28 [2] [16];\n  \n  iVar9 = 0;\n  iVar11 = 0;\n  local_28[0]._8_4_ = 0;\n  local_28[0]._0_8_ = param_2;\n  local_28[0]._12_4_ = uStack_3c;\n  iVar8 = 0;\n  iVar7 = 0;\n  FUN_1400077c8((longlong)param_2,(longlong)local_28);\n  iVar10 = 0;\n  if (*param_2 != 0) {\n    do {\n      iVar3 = iVar9;\n      iVar7 = iVar8;\n      if ((((int)*(undefined8 *)(param_2 + 6) <= param_3) &&\n          (param_3 <= (int)((ulonglong)*(undefined8 *)(param_2 + 6) >> 0x20))) &&\n         (iVar11 = iVar10, iVar3 = iVar10, iVar7 = iVar10, iVar9 == 0)) {\n        iVar11 = 0;\n        iVar3 = iVar9;\n      }\n      iVar9 = iVar3;\n      iVar10 = iVar10 + 1;\n      uVar4 = **(byte **)(param_2 + 2) & 0xf;\n      bVar1 = (&DAT_140024790)[uVar4];\n      pbVar5 = *(byte **)(param_2 + 2) + -(longlong)(char)(&DAT_140024780)[uVar4];\n      uVar4 = *(uint *)(pbVar5 + -4);\n      *(byte **)(param_2 + 2) = pbVar5;\n      param_2[6] = uVar4 >> (bVar1 & 0x1f);\n      bVar1 = (&DAT_140024790)[*pbVar5 & 0xf];\n      pbVar5 = pbVar5 + -(longlong)(char)(&DAT_140024780)[*pbVar5 & 0xf];\n      uVar4 = *(uint *)(pbVar5 + -4);\n      *(byte **)(param_2 + 2) = pbVar5;\n      param_2[7] = uVar4 >> (bVar1 & 0x1f);\n      pbVar6 = pbVar5 + -(longlong)(char)(&DAT_140024780)[*pbVar5 & 0xf];\n      param_2[8] = *(uint *)(pbVar6 + -4) >> ((&DAT_140024790)[*pbVar5 & 0xf] & 0x1f);\n      *(byte **)(param_2 + 2) = pbVar6;\n      iVar8 = *(int *)pbVar6;\n      *(byte **)(param_2 + 2) = pbVar6 + 4;\n      param_2[9] = iVar8;\n      iVar8 = iVar7;\n    } while (iVar10 != *param_2);\n  }\n  local_28[0]._8_4_ = iVar11;\n  FUN_1400077c8((longlong)param_2,(longlong)local_28);\n  auVar2._8_4_ = iVar11;\n  auVar2._0_8_ = param_2;\n  auVar2._12_4_ = uStack_3c;\n  *param_1 = auVar2;\n  *(int **)param_1[1] = param_2;\n  *(int *)(param_1[1] + 8) = iVar7 + 1;\n  *(undefined4 *)(param_1[1] + 0xc) = uStack_2c;\n  return param_1;\n}\n\n",
  "GetLocaleNameFromLangCountry": "\n/* Library Function - Single Match\n    GetLocaleNameFromLangCountry\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid GetLocaleNameFromLangCountry(short **param_1)\n\n{\n  short sVar1;\n  uint uVar2;\n  int iVar3;\n  longlong lVar4;\n  short *psVar5;\n  int iVar6;\n  longlong lVar7;\n  \n  psVar5 = *param_1;\n  lVar7 = -1;\n  lVar4 = -1;\n  do {\n    lVar4 = lVar4 + 1;\n  } while (psVar5[lVar4] != 0);\n  iVar6 = 0;\n  *(uint *)(param_1 + 3) = (uint)(lVar4 == 3);\n  do {\n    lVar7 = lVar7 + 1;\n  } while (param_1[1][lVar7] != 0);\n  *(uint *)((longlong)param_1 + 0x1c) = (uint)(lVar7 == 3);\n  if (lVar4 == 3) {\n    iVar6 = 2;\n  }\n  else {\n    iVar3 = 0;\n    if (psVar5 != (short *)0x0) {\n      while( true ) {\n        iVar6 = iVar3;\n        sVar1 = *psVar5;\n        psVar5 = psVar5 + 1;\n        if ((0x19 < (ushort)(sVar1 - 0x41U)) && (0x19 < (ushort)(sVar1 - 0x61U))) break;\n        iVar3 = iVar6 + 1;\n      }\n    }\n  }\n  *(int *)((longlong)param_1 + 0x14) = iVar6;\n  __acrt_EnumSystemLocalesEx(0x14001dcc4,3,0,0);\n  uVar2 = *(uint *)(param_1 + 2);\n  if ((uVar2 >> 8 & 1) == 0 || ((uVar2 & 7) == 0 || (uVar2 >> 9 & 1) == 0)) {\n    *(undefined4 *)(param_1 + 2) = 0;\n  }\n  return;\n}\n\n",
  "FUN_1400046a8": "\nvoid FUN_1400046a8(longlong param_1,int param_2)\n\n{\n  ulonglong *puVar1;\n  char *pcVar2;\n  longlong lVar3;\n  undefined8 uVar4;\n  int iVar5;\n  size_t sVar6;\n  char cVar7;\n  size_t _Count;\n  undefined auStack_a8 [32];\n  undefined8 *local_88;\n  undefined *local_80;\n  ulonglong *local_78;\n  longlong *local_70;\n  char local_58;\n  undefined local_57 [7];\n  longlong local_50;\n  undefined8 local_48;\n  undefined local_40 [32];\n  ulonglong local_20;\n  \n  local_20 = DAT_140035020 ^ (ulonglong)auStack_a8;\n  if (param_2 != -1) {\n    puVar1 = *(ulonglong **)(param_1 + 0x40);\n    cVar7 = (char)param_2;\n    if (*puVar1 != 0) {\n      iVar5 = **(int **)(param_1 + 0x58);\n      if (*puVar1 < (longlong)iVar5 + *puVar1) {\n        **(int **)(param_1 + 0x58) = iVar5 + -1;\n        pcVar2 = **(char ***)(param_1 + 0x40);\n        **(char ***)(param_1 + 0x40) = pcVar2 + 1;\n        *pcVar2 = cVar7;\n        goto LAB_14000480c;\n      }\n    }\n    if (*(longlong *)(param_1 + 0x80) != 0) {\n      if (**(longlong **)(param_1 + 0x18) == param_1 + 0x70) {\n        lVar3 = *(longlong *)(param_1 + 0x88);\n        uVar4 = *(undefined8 *)(param_1 + 0x90);\n        **(longlong **)(param_1 + 0x18) = lVar3;\n        **(longlong **)(param_1 + 0x38) = lVar3;\n        **(int **)(param_1 + 0x50) = (int)uVar4 - (int)lVar3;\n      }\n      if (*(longlong *)(param_1 + 0x68) != 0) {\n        local_70 = &local_50;\n        local_78 = &local_20;\n        local_80 = local_40;\n        local_88 = &local_48;\n        local_58 = cVar7;\n        iVar5 = (*(code *)PTR__guard_dispatch_icall_140023298)\n                          (*(longlong *)(param_1 + 0x68),param_1 + 0x74,&local_58,local_57);\n        if ((iVar5 == 0) || (iVar5 == 1)) {\n          _Count = local_50 - (longlong)local_40;\n          if ((_Count == 0) ||\n             (sVar6 = fwrite(local_40,1,_Count,*(FILE **)(param_1 + 0x80)), _Count == sVar6)) {\n            *(undefined *)(param_1 + 0x71) = 1;\n          }\n          goto LAB_14000480c;\n        }\n        cVar7 = local_58;\n        if (iVar5 != 3) goto LAB_14000480c;\n      }\n      fputc((int)cVar7,*(FILE **)(param_1 + 0x80));\n    }\n  }\nLAB_14000480c:\n  FUN_140006060(local_20 ^ (ulonglong)auStack_a8);\n  return;\n}\n\n",
  "_Locimp": "\n/* Library Function - Single Match\n    private: __cdecl std::locale::_Locimp::_Locimp(bool) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\n_Locimp * __thiscall std::locale::_Locimp::_Locimp(_Locimp *this,bool param_1)\n\n{\n  char *pcVar1;\n  undefined8 *puVar2;\n  char *pcVar3;\n  \n  *(undefined8 *)(this + 0x10) = 0;\n  *(undefined8 *)(this + 0x18) = 0;\n  *(undefined4 *)(this + 0x20) = 0;\n  *(undefined ***)this = vftable;\n  *(undefined4 *)(this + 8) = 1;\n  this[0x24] = (_Locimp)param_1;\n  *(undefined8 *)(this + 0x28) = 0;\n  this[0x30] = (_Locimp)0x0;\n  pcVar1 = \"*\";\n  do {\n    pcVar3 = pcVar1;\n    pcVar1 = pcVar3 + 1;\n  } while (pcVar3[1] != '\\0');\n  puVar2 = (undefined8 *)_malloc_base((ulonglong)(pcVar3 + -0x140023746));\n  *(undefined8 **)(this + 0x28) = puVar2;\n  if (puVar2 != (undefined8 *)0x0) {\n    FUN_140007ed0(puVar2,(undefined8 *)&DAT_140023748,(ulonglong)(pcVar3 + -0x140023746));\n  }\n  return this;\n}\n\n",
  "free_crt_array_internal": "\n/* Library Function - Single Match\n    void __cdecl free_crt_array_internal(void const * __ptr64 * __ptr64 const,unsigned __int64)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl free_crt_array_internal(void **param_1,__uint64 param_2)\n\n{\n  ulonglong uVar1;\n  ulonglong uVar2;\n  \n  uVar2 = 0;\n  uVar1 = param_2 & 0x1fffffffffffffff;\n  if (param_1 + param_2 < param_1) {\n    uVar1 = uVar2;\n  }\n  if (uVar1 != 0) {\n    do {\n      _free_base(*param_1);\n      uVar2 = uVar2 + 1;\n      param_1 = param_1 + 1;\n    } while (uVar2 != uVar1);\n  }\n  return;\n}\n\n",
  "LcidFromHexString": "\n/* Library Function - Single Match\n    LcidFromHexString\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint LcidFromHexString(ushort *param_1)\n\n{\n  short sVar1;\n  ushort uVar2;\n  ushort uVar3;\n  int iVar4;\n  \n  uVar3 = *param_1;\n  iVar4 = 0;\n  do {\n    if (uVar3 == 0) {\n      return iVar4;\n    }\n    param_1 = param_1 + 1;\n    if ((ushort)(uVar3 - 0x61) < 6) {\n      sVar1 = -0x27;\nLAB_14001eaa0:\n      uVar2 = uVar3 + sVar1;\n    }\n    else {\n      uVar2 = uVar3;\n      if ((ushort)(uVar3 - 0x41) < 6) {\n        sVar1 = -7;\n        goto LAB_14001eaa0;\n      }\n    }\n    uVar3 = *param_1;\n    iVar4 = iVar4 * 0x10 + -0x30 + (uint)uVar2;\n  } while( true );\n}\n\n",
  "_callnewh": "\n/* Library Function - Single Match\n    _callnewh\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _callnewh(size_t _Size)\n\n{\n  int iVar1;\n  ulonglong uVar2;\n  \n  uVar2 = _query_new_handler();\n  if ((uVar2 != 0) && (iVar1 = (*(code *)PTR__guard_dispatch_icall_140023298)(_Size), iVar1 != 0)) {\n    return 1;\n  }\n  return 0;\n}\n\n",
  "FUN_14000eae4": "\nvoid FUN_14000eae4(LPWORD *param_1)\n\n{\n  LPWSTR *ppWVar1;\n  byte bVar2;\n  LPWORD pWVar3;\n  int iVar4;\n  uint uVar5;\n  BOOL BVar6;\n  LPCSTR pCVar7;\n  LPCSTR pCVar8;\n  LPCSTR pCVar9;\n  LPCSTR pCVar10;\n  longlong lVar12;\n  undefined2 uVar13;\n  BYTE *pBVar14;\n  LPCSTR pCVar15;\n  undefined auStackY_c8 [32];\n  LPWORD local_70;\n  LPWORD *local_58;\n  undefined8 local_50;\n  _cpinfo local_48;\n  ulonglong local_30;\n  LPCSTR pCVar11;\n  \n  local_30 = DAT_140035020 ^ (ulonglong)auStackY_c8;\n  pCVar11 = (LPCSTR)0x0;\n  local_50 = 0;\n  local_58 = param_1;\n  if ((wchar_t *)param_1[0x27] == (wchar_t *)0x0) {\n    pWVar3 = param_1[0x20];\n    if (pWVar3 != (LPWORD)0x0) {\n      LOCK();\n      *(int *)pWVar3 = *(int *)pWVar3 + -1;\n      UNLOCK();\n    }\n    param_1[0x20] = (LPWORD)0x0;\n    *param_1 = (LPWORD)&DAT_140025a70;\n    param_1[0x21] = (LPWORD)0x0;\n    param_1[0x22] = (LPWORD)&DAT_140025cf0;\n    param_1[0x23] = (LPWORD)&DAT_140025e70;\n    *(undefined4 *)(param_1 + 1) = 1;\n    goto LAB_14000f114;\n  }\n  ppWVar1 = (LPWSTR *)((longlong)param_1 + 0xc);\n  local_70 = (LPWORD)0x0;\n  if ((*(int *)ppWVar1 == 0) &&\n     (iVar4 = __acrt_GetLocaleInfoA\n                        ((__crt_locale_pointers *)&local_58,0,(wchar_t *)param_1[0x27],0x1004,\n                         ppWVar1), pCVar9 = pCVar11, pCVar10 = pCVar11, pCVar7 = pCVar11,\n     pCVar8 = pCVar11, iVar4 != 0)) {\nLAB_14000f097:\n    _free_base(local_70);\n    _free_base(pCVar7);\n    _free_base(pCVar8);\n    _free_base(pCVar9);\n  }\n  else {\n    local_70 = (LPWORD)_calloc_base(1,4);\n    _free_base((LPVOID)0x0);\n    pCVar7 = (LPCSTR)_calloc_base(0x180,2);\n    _free_base((LPVOID)0x0);\n    pCVar8 = (LPCSTR)_calloc_base(0x180,1);\n    _free_base((LPVOID)0x0);\n    pCVar9 = (LPCSTR)_calloc_base(0x180,1);\n    _free_base((LPVOID)0x0);\n    pCVar10 = (LPCSTR)_calloc_base(0x101,1);\n    _free_base((LPVOID)0x0);\n    if ((local_70 == (LPWORD)0x0) ||\n       ((((pCVar7 == (LPCSTR)0x0 || (pCVar10 == (LPCSTR)0x0)) || (pCVar8 == (LPCSTR)0x0)) ||\n        (pCVar15 = pCVar10, pCVar9 == (LPCSTR)0x0)))) goto LAB_14000f097;\n    do {\n      *pCVar15 = (CHAR)pCVar11;\n      uVar5 = (int)pCVar11 + 1;\n      pCVar11 = (LPCSTR)(ulonglong)uVar5;\n      pCVar15 = pCVar15 + 1;\n    } while ((int)uVar5 < 0x100);\n    BVar6 = GetCPInfo(*(UINT *)ppWVar1,&local_48);\n    if ((BVar6 == 0) || (5 < local_48.MaxCharSize)) goto LAB_14000f097;\n    if (1 < (ushort)local_48.MaxCharSize) {\n      if (*(int *)ppWVar1 == 0xfde9) {\n        FUN_140008580((undefined (*) [16])(pCVar10 + 0x80),0x20,0x80);\n      }\n      else {\n        pBVar14 = local_48.LeadByte;\n        bVar2 = local_48.LeadByte[0];\n        while ((bVar2 != 0 && (pBVar14[1] != 0))) {\n          uVar5 = (uint)*pBVar14;\n          if (*pBVar14 <= pBVar14[1]) {\n            do {\n              lVar12 = (longlong)(int)uVar5;\n              uVar5 = uVar5 + 1;\n              pCVar10[lVar12] = ' ';\n            } while ((int)uVar5 <= (int)(uint)pBVar14[1]);\n          }\n          pBVar14 = pBVar14 + 2;\n          bVar2 = *pBVar14;\n        }\n      }\n    }\n    iVar4 = __acrt_LCMapStringA((__crt_locale_pointers *)0x0,(wchar_t *)param_1[0x27],0x100,\n                                pCVar10 + 1,0xff,pCVar8 + 0x81,0xff,*(int *)ppWVar1,0);\n    if ((iVar4 == 0) ||\n       (iVar4 = __acrt_LCMapStringA((__crt_locale_pointers *)0x0,(wchar_t *)param_1[0x27],0x200,\n                                    pCVar10 + 1,0xff,pCVar9 + 0x81,0xff,*(int *)ppWVar1,0),\n       iVar4 == 0)) goto LAB_14000f097;\n    iVar4 = __acrt_GetStringTypeA\n                      ((__crt_locale_pointers *)0x0,1,pCVar10,0x100,(LPWORD)(pCVar7 + 0x100),\n                       *(UINT *)ppWVar1,0);\n    if (iVar4 == 0) goto LAB_14000f097;\n    *(WORD *)(pCVar7 + 0xfe) = 0;\n    pCVar8[0x7f] = '\\0';\n    pCVar9[0x7f] = '\\0';\n    pCVar8[0x80] = '\\0';\n    pCVar9[0x80] = '\\0';\n    if (1 < (local_48.MaxCharSize & 0xffff)) {\n      if (*(int *)ppWVar1 == 0xfde9) {\n        pCVar15 = pCVar9 + 0x100;\n        pCVar11 = pCVar7 + 0x200;\n        iVar4 = 0x80;\n        do {\n          uVar13 = 0x8000;\n          if (0x32 < iVar4 - 0xc2U) {\n            uVar13 = 0;\n          }\n          *(undefined2 *)pCVar11 = uVar13;\n          pCVar11 = pCVar11 + 2;\n          pCVar15[(longlong)pCVar8 - (longlong)pCVar9] = (CHAR)iVar4;\n          *pCVar15 = (CHAR)iVar4;\n          iVar4 = iVar4 + 1;\n          pCVar15 = pCVar15 + 1;\n        } while (iVar4 < 0x100);\n      }\n      else {\n        pBVar14 = local_48.LeadByte;\n        while ((local_48.LeadByte[0] != 0 && (pBVar14[1] != 0))) {\n          uVar5 = (uint)*pBVar14;\n          if (*pBVar14 <= pBVar14[1]) {\n            do {\n              lVar12 = (longlong)(int)uVar5;\n              *(undefined2 *)(pCVar7 + lVar12 * 2 + 0x100) = 0x8000;\n              pCVar8[lVar12 + 0x80] = (CHAR)uVar5;\n              pCVar9[lVar12 + 0x80] = (CHAR)uVar5;\n              uVar5 = uVar5 + 1;\n            } while ((int)uVar5 <= (int)(uint)pBVar14[1]);\n          }\n          pBVar14 = pBVar14 + 2;\n          local_48.LeadByte[0] = *pBVar14;\n        }\n      }\n    }\n    *(undefined4 *)pCVar7 = *(undefined4 *)(pCVar7 + 0x200);\n    *(undefined4 *)(pCVar7 + 4) = *(undefined4 *)(pCVar7 + 0x204);\n    *(undefined4 *)(pCVar7 + 8) = *(undefined4 *)(pCVar7 + 0x208);\n    *(undefined4 *)(pCVar7 + 0xc) = *(undefined4 *)(pCVar7 + 0x20c);\n    *(undefined4 *)(pCVar7 + 0x10) = *(undefined4 *)(pCVar7 + 0x210);\n    *(undefined4 *)(pCVar7 + 0x14) = *(undefined4 *)(pCVar7 + 0x214);\n    *(undefined4 *)(pCVar7 + 0x18) = *(undefined4 *)(pCVar7 + 0x218);\n    *(undefined4 *)(pCVar7 + 0x1c) = *(undefined4 *)(pCVar7 + 0x21c);\n    *(undefined4 *)(pCVar7 + 0x20) = *(undefined4 *)(pCVar7 + 0x220);\n    *(undefined4 *)(pCVar7 + 0x24) = *(undefined4 *)(pCVar7 + 0x224);\n    *(undefined4 *)(pCVar7 + 0x28) = *(undefined4 *)(pCVar7 + 0x228);\n    *(undefined4 *)(pCVar7 + 0x2c) = *(undefined4 *)(pCVar7 + 0x22c);\n    *(undefined4 *)(pCVar7 + 0x30) = *(undefined4 *)(pCVar7 + 0x230);\n    *(undefined4 *)(pCVar7 + 0x34) = *(undefined4 *)(pCVar7 + 0x234);\n    *(undefined4 *)(pCVar7 + 0x38) = *(undefined4 *)(pCVar7 + 0x238);\n    *(undefined4 *)(pCVar7 + 0x3c) = *(undefined4 *)(pCVar7 + 0x23c);\n    *(undefined4 *)(pCVar7 + 0x40) = *(undefined4 *)(pCVar7 + 0x240);\n    *(undefined4 *)(pCVar7 + 0x44) = *(undefined4 *)(pCVar7 + 0x244);\n    *(undefined4 *)(pCVar7 + 0x48) = *(undefined4 *)(pCVar7 + 0x248);\n    *(undefined4 *)(pCVar7 + 0x4c) = *(undefined4 *)(pCVar7 + 0x24c);\n    *(undefined4 *)(pCVar7 + 0x50) = *(undefined4 *)(pCVar7 + 0x250);\n    *(undefined4 *)(pCVar7 + 0x54) = *(undefined4 *)(pCVar7 + 0x254);\n    *(undefined4 *)(pCVar7 + 0x58) = *(undefined4 *)(pCVar7 + 600);\n    *(undefined4 *)(pCVar7 + 0x5c) = *(undefined4 *)(pCVar7 + 0x25c);\n    *(undefined4 *)(pCVar7 + 0x60) = *(undefined4 *)(pCVar7 + 0x260);\n    *(undefined4 *)(pCVar7 + 100) = *(undefined4 *)(pCVar7 + 0x264);\n    *(undefined4 *)(pCVar7 + 0x68) = *(undefined4 *)(pCVar7 + 0x268);\n    *(undefined4 *)(pCVar7 + 0x6c) = *(undefined4 *)(pCVar7 + 0x26c);\n    *(undefined4 *)(pCVar7 + 0x70) = *(undefined4 *)(pCVar7 + 0x270);\n    *(undefined4 *)(pCVar7 + 0x74) = *(undefined4 *)(pCVar7 + 0x274);\n    *(undefined4 *)(pCVar7 + 0x78) = *(undefined4 *)(pCVar7 + 0x278);\n    *(undefined4 *)(pCVar7 + 0x7c) = *(undefined4 *)(pCVar7 + 0x27c);\n    *(undefined4 *)(pCVar7 + 0x80) = *(undefined4 *)(pCVar7 + 0x280);\n    *(undefined4 *)(pCVar7 + 0x84) = *(undefined4 *)(pCVar7 + 0x284);\n    *(undefined4 *)(pCVar7 + 0x88) = *(undefined4 *)(pCVar7 + 0x288);\n    *(undefined4 *)(pCVar7 + 0x8c) = *(undefined4 *)(pCVar7 + 0x28c);\n    *(undefined4 *)(pCVar7 + 0x90) = *(undefined4 *)(pCVar7 + 0x290);\n    *(undefined4 *)(pCVar7 + 0x94) = *(undefined4 *)(pCVar7 + 0x294);\n    *(undefined4 *)(pCVar7 + 0x98) = *(undefined4 *)(pCVar7 + 0x298);\n    *(undefined4 *)(pCVar7 + 0x9c) = *(undefined4 *)(pCVar7 + 0x29c);\n    *(undefined4 *)(pCVar7 + 0xa0) = *(undefined4 *)(pCVar7 + 0x2a0);\n    *(undefined4 *)(pCVar7 + 0xa4) = *(undefined4 *)(pCVar7 + 0x2a4);\n    *(undefined4 *)(pCVar7 + 0xa8) = *(undefined4 *)(pCVar7 + 0x2a8);\n    *(undefined4 *)(pCVar7 + 0xac) = *(undefined4 *)(pCVar7 + 0x2ac);\n    *(undefined4 *)(pCVar7 + 0xb0) = *(undefined4 *)(pCVar7 + 0x2b0);\n    *(undefined4 *)(pCVar7 + 0xb4) = *(undefined4 *)(pCVar7 + 0x2b4);\n    *(undefined4 *)(pCVar7 + 0xb8) = *(undefined4 *)(pCVar7 + 0x2b8);\n    *(undefined4 *)(pCVar7 + 0xbc) = *(undefined4 *)(pCVar7 + 700);\n    *(undefined4 *)(pCVar7 + 0xc0) = *(undefined4 *)(pCVar7 + 0x2c0);\n    *(undefined4 *)(pCVar7 + 0xc4) = *(undefined4 *)(pCVar7 + 0x2c4);\n    *(undefined4 *)(pCVar7 + 200) = *(undefined4 *)(pCVar7 + 0x2c8);\n    *(undefined4 *)(pCVar7 + 0xcc) = *(undefined4 *)(pCVar7 + 0x2cc);\n    *(undefined4 *)(pCVar7 + 0xd0) = *(undefined4 *)(pCVar7 + 0x2d0);\n    *(undefined4 *)(pCVar7 + 0xd4) = *(undefined4 *)(pCVar7 + 0x2d4);\n    *(undefined4 *)(pCVar7 + 0xd8) = *(undefined4 *)(pCVar7 + 0x2d8);\n    *(undefined4 *)(pCVar7 + 0xdc) = *(undefined4 *)(pCVar7 + 0x2dc);\n    *(undefined4 *)(pCVar7 + 0xe0) = *(undefined4 *)(pCVar7 + 0x2e0);\n    *(undefined4 *)(pCVar7 + 0xe4) = *(undefined4 *)(pCVar7 + 0x2e4);\n    *(undefined4 *)(pCVar7 + 0xe8) = *(undefined4 *)(pCVar7 + 0x2e8);\n    *(undefined4 *)(pCVar7 + 0xec) = *(undefined4 *)(pCVar7 + 0x2ec);\n    *(undefined8 *)(pCVar7 + 0xf0) = *(undefined8 *)(pCVar7 + 0x2f0);\n    *(undefined4 *)(pCVar7 + 0xf8) = *(undefined4 *)(pCVar7 + 0x2f8);\n    *(undefined2 *)(pCVar7 + 0xfc) = *(undefined2 *)(pCVar7 + 0x2fc);\n    *(undefined4 *)pCVar8 = *(undefined4 *)(pCVar8 + 0x100);\n    *(undefined4 *)(pCVar8 + 4) = *(undefined4 *)(pCVar8 + 0x104);\n    *(undefined4 *)(pCVar8 + 8) = *(undefined4 *)(pCVar8 + 0x108);\n    *(undefined4 *)(pCVar8 + 0xc) = *(undefined4 *)(pCVar8 + 0x10c);\n    *(undefined4 *)(pCVar8 + 0x10) = *(undefined4 *)(pCVar8 + 0x110);\n    *(undefined4 *)(pCVar8 + 0x14) = *(undefined4 *)(pCVar8 + 0x114);\n    *(undefined4 *)(pCVar8 + 0x18) = *(undefined4 *)(pCVar8 + 0x118);\n    *(undefined4 *)(pCVar8 + 0x1c) = *(undefined4 *)(pCVar8 + 0x11c);\n    *(undefined4 *)(pCVar8 + 0x20) = *(undefined4 *)(pCVar8 + 0x120);\n    *(undefined4 *)(pCVar8 + 0x24) = *(undefined4 *)(pCVar8 + 0x124);\n    *(undefined4 *)(pCVar8 + 0x28) = *(undefined4 *)(pCVar8 + 0x128);\n    *(undefined4 *)(pCVar8 + 0x2c) = *(undefined4 *)(pCVar8 + 300);\n    *(undefined4 *)(pCVar8 + 0x30) = *(undefined4 *)(pCVar8 + 0x130);\n    *(undefined4 *)(pCVar8 + 0x34) = *(undefined4 *)(pCVar8 + 0x134);\n    *(undefined4 *)(pCVar8 + 0x38) = *(undefined4 *)(pCVar8 + 0x138);\n    *(undefined4 *)(pCVar8 + 0x3c) = *(undefined4 *)(pCVar8 + 0x13c);\n    *(undefined4 *)(pCVar8 + 0x40) = *(undefined4 *)(pCVar8 + 0x140);\n    *(undefined4 *)(pCVar8 + 0x44) = *(undefined4 *)(pCVar8 + 0x144);\n    *(undefined4 *)(pCVar8 + 0x48) = *(undefined4 *)(pCVar8 + 0x148);\n    *(undefined4 *)(pCVar8 + 0x4c) = *(undefined4 *)(pCVar8 + 0x14c);\n    *(undefined4 *)(pCVar8 + 0x50) = *(undefined4 *)(pCVar8 + 0x150);\n    *(undefined4 *)(pCVar8 + 0x54) = *(undefined4 *)(pCVar8 + 0x154);\n    *(undefined4 *)(pCVar8 + 0x58) = *(undefined4 *)(pCVar8 + 0x158);\n    *(undefined4 *)(pCVar8 + 0x5c) = *(undefined4 *)(pCVar8 + 0x15c);\n    *(undefined4 *)(pCVar8 + 0x60) = *(undefined4 *)(pCVar8 + 0x160);\n    *(undefined4 *)(pCVar8 + 100) = *(undefined4 *)(pCVar8 + 0x164);\n    *(undefined4 *)(pCVar8 + 0x68) = *(undefined4 *)(pCVar8 + 0x168);\n    *(undefined4 *)(pCVar8 + 0x6c) = *(undefined4 *)(pCVar8 + 0x16c);\n    *(undefined8 *)(pCVar8 + 0x70) = *(undefined8 *)(pCVar8 + 0x170);\n    *(undefined4 *)(pCVar8 + 0x78) = *(undefined4 *)(pCVar8 + 0x178);\n    *(undefined2 *)(pCVar8 + 0x7c) = *(undefined2 *)(pCVar8 + 0x17c);\n    pCVar8[0x7e] = pCVar8[0x17e];\n    *(undefined4 *)pCVar9 = *(undefined4 *)(pCVar9 + 0x100);\n    *(undefined4 *)(pCVar9 + 4) = *(undefined4 *)(pCVar9 + 0x104);\n    *(undefined4 *)(pCVar9 + 8) = *(undefined4 *)(pCVar9 + 0x108);\n    *(undefined4 *)(pCVar9 + 0xc) = *(undefined4 *)(pCVar9 + 0x10c);\n    *(undefined4 *)(pCVar9 + 0x10) = *(undefined4 *)(pCVar9 + 0x110);\n    *(undefined4 *)(pCVar9 + 0x14) = *(undefined4 *)(pCVar9 + 0x114);\n    *(undefined4 *)(pCVar9 + 0x18) = *(undefined4 *)(pCVar9 + 0x118);\n    *(undefined4 *)(pCVar9 + 0x1c) = *(undefined4 *)(pCVar9 + 0x11c);\n    *(undefined4 *)(pCVar9 + 0x20) = *(undefined4 *)(pCVar9 + 0x120);\n    *(undefined4 *)(pCVar9 + 0x24) = *(undefined4 *)(pCVar9 + 0x124);\n    *(undefined4 *)(pCVar9 + 0x28) = *(undefined4 *)(pCVar9 + 0x128);\n    *(undefined4 *)(pCVar9 + 0x2c) = *(undefined4 *)(pCVar9 + 300);\n    *(undefined4 *)(pCVar9 + 0x30) = *(undefined4 *)(pCVar9 + 0x130);\n    *(undefined4 *)(pCVar9 + 0x34) = *(undefined4 *)(pCVar9 + 0x134);\n    *(undefined4 *)(pCVar9 + 0x38) = *(undefined4 *)(pCVar9 + 0x138);\n    *(undefined4 *)(pCVar9 + 0x3c) = *(undefined4 *)(pCVar9 + 0x13c);\n    *(undefined4 *)(pCVar9 + 0x40) = *(undefined4 *)(pCVar9 + 0x140);\n    *(undefined4 *)(pCVar9 + 0x44) = *(undefined4 *)(pCVar9 + 0x144);\n    *(undefined4 *)(pCVar9 + 0x48) = *(undefined4 *)(pCVar9 + 0x148);\n    *(undefined4 *)(pCVar9 + 0x4c) = *(undefined4 *)(pCVar9 + 0x14c);\n    *(undefined4 *)(pCVar9 + 0x50) = *(undefined4 *)(pCVar9 + 0x150);\n    *(undefined4 *)(pCVar9 + 0x54) = *(undefined4 *)(pCVar9 + 0x154);\n    *(undefined4 *)(pCVar9 + 0x58) = *(undefined4 *)(pCVar9 + 0x158);\n    *(undefined4 *)(pCVar9 + 0x5c) = *(undefined4 *)(pCVar9 + 0x15c);\n    *(undefined4 *)(pCVar9 + 0x60) = *(undefined4 *)(pCVar9 + 0x160);\n    *(undefined4 *)(pCVar9 + 100) = *(undefined4 *)(pCVar9 + 0x164);\n    *(undefined4 *)(pCVar9 + 0x68) = *(undefined4 *)(pCVar9 + 0x168);\n    *(undefined4 *)(pCVar9 + 0x6c) = *(undefined4 *)(pCVar9 + 0x16c);\n    *(undefined8 *)(pCVar9 + 0x70) = *(undefined8 *)(pCVar9 + 0x170);\n    *(undefined4 *)(pCVar9 + 0x78) = *(undefined4 *)(pCVar9 + 0x178);\n    *(undefined2 *)(pCVar9 + 0x7c) = *(undefined2 *)(pCVar9 + 0x17c);\n    pCVar9[0x7e] = pCVar9[0x17e];\n    pWVar3 = param_1[0x20];\n    if (pWVar3 != (LPWORD)0x0) {\n      LOCK();\n      iVar4 = *(int *)pWVar3;\n      *(int *)pWVar3 = *(int *)pWVar3 + -1;\n      UNLOCK();\n      if (iVar4 == 1) {\n        _free_base(param_1[0x21] + -0x7f);\n        _free_base(param_1[0x22] + -0x40);\n        _free_base(param_1[0x23] + -0x40);\n        _free_base(param_1[0x20]);\n      }\n    }\n    *(undefined4 *)local_70 = 1;\n    param_1[0x20] = local_70;\n    *param_1 = (LPWORD)(pCVar7 + 0x100);\n    param_1[0x21] = (LPWORD)(pCVar7 + 0xfe);\n    param_1[0x22] = (LPWORD)(pCVar8 + 0x80);\n    param_1[0x23] = (LPWORD)(pCVar9 + 0x80);\n    *(UINT *)(param_1 + 1) = local_48.MaxCharSize & 0xffff;\n  }\n  _free_base(pCVar10);\nLAB_14000f114:\n  FUN_140006060(local_30 ^ (ulonglong)auStackY_c8);\n  return;\n}\n\n",
  "~_Lockit": "\n/* Library Function - Single Match\n    public: __cdecl std::_Lockit::~_Lockit(void) __ptr64\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __thiscall std::_Lockit::~_Lockit(_Lockit *this)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)this;\n  if (iVar1 == 0) {\n    FUN_14000d19c();\n    return;\n  }\n  if (iVar1 < 8) {\n    LeaveCriticalSection((LPCRITICAL_SECTION)(&DAT_140036110 + (longlong)iVar1 * 0x28));\n  }\n  return;\n}\n\n",
  "FUN_140001cc0": "\nbyte * FUN_140001cc0(longlong param_1,byte *param_2,byte *param_3)\n\n{\n  int iVar1;\n  \n  if (param_2 != param_3) {\n    do {\n      iVar1 = _Toupper((uint)*param_2,(_Ctypevec *)(param_1 + 0x10));\n      *param_2 = (byte)iVar1;\n      param_2 = param_2 + 1;\n    } while (param_2 != param_3);\n  }\n  return param_2;\n}\n\n",
  "FUN_14001b304": "\nvoid FUN_14001b304(undefined8 param_1,int *param_2,longlong **param_3,int *param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 *puVar6;\n  ulong *puVar7;\n  undefined (*pauVar8) [16];\n  undefined (*pauVar9) [16];\n  longlong lVar10;\n  \n  __acrt_lock(*param_2);\n  puVar6 = (undefined4 *)(*(longlong *)(**param_3 + 0x88) + 0x18);\n  if (DAT_1400379b0 == (undefined (*) [16])0x0) {\nLAB_14001b3ad:\n    puVar7 = __doserrno();\n    *puVar7 = 0x16;\n    FUN_14000d030();\n  }\n  else {\n    if (puVar6 == (undefined4 *)0x0) {\n      FUN_140008580(DAT_1400379b0,0,0x101);\n      goto LAB_14001b3ad;\n    }\n    lVar10 = 2;\n    pauVar9 = DAT_1400379b0;\n    do {\n      uVar3 = puVar6[1];\n      uVar4 = puVar6[2];\n      uVar5 = puVar6[3];\n      *(undefined4 *)*pauVar9 = *puVar6;\n      *(undefined4 *)(*pauVar9 + 4) = uVar3;\n      *(undefined4 *)(*pauVar9 + 8) = uVar4;\n      *(undefined4 *)(*pauVar9 + 0xc) = uVar5;\n      uVar3 = puVar6[5];\n      uVar4 = puVar6[6];\n      uVar5 = puVar6[7];\n      *(undefined4 *)pauVar9[1] = puVar6[4];\n      *(undefined4 *)(pauVar9[1] + 4) = uVar3;\n      *(undefined4 *)(pauVar9[1] + 8) = uVar4;\n      *(undefined4 *)(pauVar9[1] + 0xc) = uVar5;\n      uVar3 = puVar6[9];\n      uVar4 = puVar6[10];\n      uVar5 = puVar6[0xb];\n      *(undefined4 *)pauVar9[2] = puVar6[8];\n      *(undefined4 *)(pauVar9[2] + 4) = uVar3;\n      *(undefined4 *)(pauVar9[2] + 8) = uVar4;\n      *(undefined4 *)(pauVar9[2] + 0xc) = uVar5;\n      uVar3 = puVar6[0xd];\n      uVar4 = puVar6[0xe];\n      uVar5 = puVar6[0xf];\n      *(undefined4 *)pauVar9[3] = puVar6[0xc];\n      *(undefined4 *)(pauVar9[3] + 4) = uVar3;\n      *(undefined4 *)(pauVar9[3] + 8) = uVar4;\n      *(undefined4 *)(pauVar9[3] + 0xc) = uVar5;\n      uVar3 = puVar6[0x11];\n      uVar4 = puVar6[0x12];\n      uVar5 = puVar6[0x13];\n      *(undefined4 *)pauVar9[4] = puVar6[0x10];\n      *(undefined4 *)(pauVar9[4] + 4) = uVar3;\n      *(undefined4 *)(pauVar9[4] + 8) = uVar4;\n      *(undefined4 *)(pauVar9[4] + 0xc) = uVar5;\n      uVar3 = puVar6[0x15];\n      uVar4 = puVar6[0x16];\n      uVar5 = puVar6[0x17];\n      *(undefined4 *)pauVar9[5] = puVar6[0x14];\n      *(undefined4 *)(pauVar9[5] + 4) = uVar3;\n      *(undefined4 *)(pauVar9[5] + 8) = uVar4;\n      *(undefined4 *)(pauVar9[5] + 0xc) = uVar5;\n      uVar3 = puVar6[0x19];\n      uVar4 = puVar6[0x1a];\n      uVar5 = puVar6[0x1b];\n      *(undefined4 *)pauVar9[6] = puVar6[0x18];\n      *(undefined4 *)(pauVar9[6] + 4) = uVar3;\n      *(undefined4 *)(pauVar9[6] + 8) = uVar4;\n      *(undefined4 *)(pauVar9[6] + 0xc) = uVar5;\n      pauVar8 = pauVar9 + 8;\n      uVar3 = puVar6[0x1d];\n      uVar4 = puVar6[0x1e];\n      uVar5 = puVar6[0x1f];\n      *(undefined4 *)pauVar9[7] = puVar6[0x1c];\n      *(undefined4 *)(pauVar9[7] + 4) = uVar3;\n      *(undefined4 *)(pauVar9[7] + 8) = uVar4;\n      *(undefined4 *)(pauVar9[7] + 0xc) = uVar5;\n      puVar6 = puVar6 + 0x20;\n      lVar10 = lVar10 + -1;\n      pauVar9 = pauVar8;\n    } while (lVar10 != 0);\n    (*pauVar8)[0] = *(undefined *)puVar6;\n  }\n  lVar10 = 2;\n  puVar6 = (undefined4 *)(*(longlong *)(**param_3 + 0x88) + 0x119);\n  if (DAT_1400379b8 != (undefined (*) [16])0x0) {\n    pauVar9 = DAT_1400379b8;\n    if (puVar6 != (undefined4 *)0x0) {\n      do {\n        uVar3 = puVar6[1];\n        uVar4 = puVar6[2];\n        uVar5 = puVar6[3];\n        *(undefined4 *)*pauVar9 = *puVar6;\n        *(undefined4 *)(*pauVar9 + 4) = uVar3;\n        *(undefined4 *)(*pauVar9 + 8) = uVar4;\n        *(undefined4 *)(*pauVar9 + 0xc) = uVar5;\n        uVar3 = puVar6[5];\n        uVar4 = puVar6[6];\n        uVar5 = puVar6[7];\n        *(undefined4 *)pauVar9[1] = puVar6[4];\n        *(undefined4 *)(pauVar9[1] + 4) = uVar3;\n        *(undefined4 *)(pauVar9[1] + 8) = uVar4;\n        *(undefined4 *)(pauVar9[1] + 0xc) = uVar5;\n        uVar3 = puVar6[9];\n        uVar4 = puVar6[10];\n        uVar5 = puVar6[0xb];\n        *(undefined4 *)pauVar9[2] = puVar6[8];\n        *(undefined4 *)(pauVar9[2] + 4) = uVar3;\n        *(undefined4 *)(pauVar9[2] + 8) = uVar4;\n        *(undefined4 *)(pauVar9[2] + 0xc) = uVar5;\n        uVar3 = puVar6[0xd];\n        uVar4 = puVar6[0xe];\n        uVar5 = puVar6[0xf];\n        *(undefined4 *)pauVar9[3] = puVar6[0xc];\n        *(undefined4 *)(pauVar9[3] + 4) = uVar3;\n        *(undefined4 *)(pauVar9[3] + 8) = uVar4;\n        *(undefined4 *)(pauVar9[3] + 0xc) = uVar5;\n        uVar3 = puVar6[0x11];\n        uVar4 = puVar6[0x12];\n        uVar5 = puVar6[0x13];\n        *(undefined4 *)pauVar9[4] = puVar6[0x10];\n        *(undefined4 *)(pauVar9[4] + 4) = uVar3;\n        *(undefined4 *)(pauVar9[4] + 8) = uVar4;\n        *(undefined4 *)(pauVar9[4] + 0xc) = uVar5;\n        uVar3 = puVar6[0x15];\n        uVar4 = puVar6[0x16];\n        uVar5 = puVar6[0x17];\n        *(undefined4 *)pauVar9[5] = puVar6[0x14];\n        *(undefined4 *)(pauVar9[5] + 4) = uVar3;\n        *(undefined4 *)(pauVar9[5] + 8) = uVar4;\n        *(undefined4 *)(pauVar9[5] + 0xc) = uVar5;\n        uVar3 = puVar6[0x19];\n        uVar4 = puVar6[0x1a];\n        uVar5 = puVar6[0x1b];\n        *(undefined4 *)pauVar9[6] = puVar6[0x18];\n        *(undefined4 *)(pauVar9[6] + 4) = uVar3;\n        *(undefined4 *)(pauVar9[6] + 8) = uVar4;\n        *(undefined4 *)(pauVar9[6] + 0xc) = uVar5;\n        uVar3 = puVar6[0x1d];\n        uVar4 = puVar6[0x1e];\n        uVar5 = puVar6[0x1f];\n        *(undefined4 *)pauVar9[7] = puVar6[0x1c];\n        *(undefined4 *)(pauVar9[7] + 4) = uVar3;\n        *(undefined4 *)(pauVar9[7] + 8) = uVar4;\n        *(undefined4 *)(pauVar9[7] + 0xc) = uVar5;\n        puVar6 = puVar6 + 0x20;\n        lVar10 = lVar10 + -1;\n        pauVar9 = pauVar9 + 8;\n      } while (lVar10 != 0);\n      goto LAB_14001b454;\n    }\n    FUN_140008580(DAT_1400379b8,0,0x100);\n  }\n  puVar7 = __doserrno();\n  *puVar7 = 0x16;\n  FUN_14000d030();\nLAB_14001b454:\n  piVar2 = *(int **)*param_3[1];\n  LOCK();\n  iVar1 = *piVar2;\n  *piVar2 = *piVar2 + -1;\n  UNLOCK();\n  if ((iVar1 == 1) && (*(undefined **)*param_3[1] != &DAT_1400355c0)) {\n    _free_base(*(LPVOID *)*param_3[1]);\n  }\n  *(undefined8 *)*param_3[1] = *(undefined8 *)(**param_3 + 0x88);\n  LOCK();\n  **(int **)(**param_3 + 0x88) = **(int **)(**param_3 + 0x88) + 1;\n  UNLOCK();\n  __acrt_unlock(*param_4);\n  return;\n}\n\n",
  "BuildCatchObjectHelperInternal<class___FrameHandler3>": "\n/* Library Function - Single Match\n    int __cdecl BuildCatchObjectHelperInternal<class __FrameHandler3>(struct EHExceptionRecord *\n   __ptr64,void * __ptr64,struct _s_HandlerType const * __ptr64,struct _s_CatchableType const *\n   __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\nBuildCatchObjectHelperInternal<class___FrameHandler3>\n          (EHExceptionRecord *param_1,void *param_2,_s_HandlerType *param_3,\n          _s_CatchableType *param_4)\n\n{\n  longlong lVar1;\n  undefined8 *puVar2;\n  ulonglong uVar3;\n  ulonglong uVar4;\n  int iVar5;\n  ulonglong uVar6;\n  int iVar7;\n  \n  uVar4 = 0;\n  uVar6 = 0;\n  iVar5 = 0;\n  uVar3 = uVar4;\n  iVar7 = iVar5;\n  if (*(int *)(param_3 + 4) != 0) {\n    iVar7 = *(int *)(param_3 + 4);\n    lVar1 = _GetImageBase();\n    uVar3 = iVar7 + lVar1;\n  }\n  if (uVar3 == 0) {\n    return 0;\n  }\n  uVar3 = uVar4;\n  if (iVar7 != 0) {\n    lVar1 = _GetImageBase();\n    uVar3 = lVar1 + *(int *)(param_3 + 4);\n  }\n  if (*(char *)(uVar3 + 0x10) == '\\0') {\n    return 0;\n  }\n  if ((*(int *)(param_3 + 8) == 0) && (-1 < *(int *)param_3)) {\n    return 0;\n  }\n  if (-1 < *(int *)param_3) {\n                    /* WARNING: Load size is inaccurate */\n    param_2 = (void *)((longlong)*(int *)(param_3 + 8) + *param_2);\n  }\n  if (((((byte)*param_3 & 0x80) == 0) || (((byte)*param_4 & 0x10) == 0)) || (DAT_140036d20 == 0)) {\n    if (((byte)*param_3 & 8) == 0) {\n      if (((byte)*param_4 & 1) == 0) {\n        uVar3 = uVar4;\n        if (*(int *)(param_4 + 0x18) != 0) {\n          iVar5 = *(int *)(param_4 + 0x18);\n          lVar1 = _GetThrowImageBase();\n          uVar3 = iVar5 + lVar1;\n        }\n        if (uVar3 != 0) {\n          if ((*(longlong *)(param_1 + 0x28) != 0) && ((longlong *)param_2 != (longlong *)0x0)) {\n            if (iVar5 != 0) {\n              lVar1 = _GetThrowImageBase();\n              uVar4 = lVar1 + *(int *)(param_4 + 0x18);\n            }\n            if (uVar4 != 0) {\n              uVar6 = (ulonglong)((((byte)*param_4 & 4) != 0) + 1);\n              goto LAB_140009072;\n            }\n          }\n                    /* WARNING: Subroutine does not return */\n          abort();\n        }\n        if ((*(longlong *)(param_1 + 0x28) == 0) || ((longlong *)param_2 == (longlong *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n          abort();\n        }\n        iVar7 = *(int *)(param_4 + 0x14);\n        puVar2 = (undefined8 *)__AdjustPointer(*(longlong *)(param_1 + 0x28),(int *)(param_4 + 8));\n        FUN_140007ed0((undefined8 *)param_2,puVar2,(longlong)iVar7);\n        goto LAB_140009072;\n      }\n      if ((*(undefined8 **)(param_1 + 0x28) == (undefined8 *)0x0) ||\n         ((longlong *)param_2 == (longlong *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n      FUN_140007ed0((undefined8 *)param_2,*(undefined8 **)(param_1 + 0x28),\n                    (longlong)*(int *)(param_4 + 0x14));\n      uVar6 = uVar4;\n                    /* WARNING: Load size is inaccurate */\n      if ((*(int *)(param_4 + 0x14) != 8) || (*param_2 == 0)) goto LAB_140009072;\n                    /* WARNING: Load size is inaccurate */\n      lVar1 = *param_2;\n    }\n    else {\n      lVar1 = *(longlong *)(param_1 + 0x28);\n      if ((lVar1 == 0) || ((longlong *)param_2 == (longlong *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n      *(longlong *)param_2 = lVar1;\n    }\n  }\n  else {\n    lVar1 = (*(code *)PTR__guard_dispatch_icall_140023298)();\n    if ((lVar1 == 0) || ((longlong *)param_2 == (longlong *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    *(longlong *)param_2 = lVar1;\n  }\n  lVar1 = __AdjustPointer(lVar1,(int *)(param_4 + 8));\n  *(longlong *)param_2 = lVar1;\n  uVar6 = uVar4;\nLAB_140009072:\n  return (int)uVar6;\n}\n\n",
  "__acrt_copy_locale_name": "\n/* Library Function - Single Match\n    __acrt_copy_locale_name\n   \n   Library: Visual Studio 2019 Release */\n\nwchar_t * __acrt_copy_locale_name(undefined (*param_1) [32])\n\n{\n  errno_t eVar1;\n  ulonglong uVar2;\n  wchar_t *_Dst;\n  \n  if (((param_1 == (undefined (*) [32])0x0) || (uVar2 = FUN_140011a3c(param_1,0x55), 0x54 < uVar2))\n     || (_Dst = (wchar_t *)_malloc_base(uVar2 * 2 + 2), _Dst == (wchar_t *)0x0)) {\n    _Dst = (wchar_t *)0x0;\n  }\n  else {\n    eVar1 = wcsncpy_s(_Dst,uVar2 + 1,(wchar_t *)param_1,uVar2 + 1);\n    if (eVar1 != 0) {\n                    /* WARNING: Subroutine does not return */\n      _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n  }\n  return _Dst;\n}\n\n",
  "FUN_140021ab0": "\nundefined4\nFUN_140021ab0(undefined8 param_1,undefined8 param_2,int param_3,uint param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  if (param_3 == 1) {\n    iVar1 = 2;\n    uVar3 = 0x22;\n    uVar2 = 4;\n  }\n  else {\n    if (param_3 != 2) {\n      return (int)param_2;\n    }\n    uVar3 = 0x21;\n    uVar2 = 8;\n    iVar1 = 1;\n  }\n  FUN_14001f8d0(param_5,param_4,param_2,iVar1,uVar2,uVar3,param_1,0,1);\n  return (int)param_2;\n}\n\n",
  "FUN_140012908": "\nvoid FUN_140012908(int param_1)\n\n{\n  common_exit(param_1,2,0);\n  return;\n}\n\n",
  "_Allocate_manually_vector_aligned<struct_std::_Default_allocate_traits>": "\n/* Library Function - Single Match\n    void * __ptr64 __cdecl std::_Allocate_manually_vector_aligned<struct\n   std::_Default_allocate_traits>(unsigned __int64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid * __cdecl\nstd::_Allocate_manually_vector_aligned<struct_std::_Default_allocate_traits>(__uint64 param_1)\n\n{\n  code *pcVar1;\n  void *pvVar2;\n  void *pvVar3;\n  \n  if (param_1 + 0x27 <= param_1) {\n    FUN_1400012e0();\n    pcVar1 = (code *)swi(3);\n    pvVar2 = (void *)(*pcVar1)();\n    return pvVar2;\n  }\n  pvVar2 = operator_new(param_1 + 0x27);\n  if (pvVar2 != (void *)0x0) {\n    pvVar3 = (void *)((longlong)pvVar2 + 0x27U & 0xffffffffffffffe0);\n    *(void **)((longlong)pvVar3 + -8) = pvVar2;\n    return pvVar3;\n  }\n  FUN_14000d050();\n  pcVar1 = (code *)swi(3);\n  pvVar2 = (void *)(*pcVar1)();\n  return pvVar2;\n}\n\n",
  "FUN_14000ad54": "\nundefined8 * FUN_14000ad54(undefined8 *param_1,longlong param_2)\n\n{\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  __std_exception_copy((char **)(param_2 + 8),(char **)(param_1 + 1));\n  *param_1 = std::bad_exception::vftable;\n  return param_1;\n}\n\n",
  "FindHandlerForForeignException<class___FrameHandler3>": "\n/* Library Function - Single Match\n    void __cdecl FindHandlerForForeignException<class __FrameHandler3>(struct EHExceptionRecord *\n   __ptr64,unsigned __int64 * __ptr64,struct _CONTEXT * __ptr64,struct _xDISPATCHER_CONTEXT *\n   __ptr64,struct _s_FuncInfo const * __ptr64,int,int,unsigned __int64 * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl\nFindHandlerForForeignException<class___FrameHandler3>\n          (EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n          _xDISPATCHER_CONTEXT *param_4,_s_FuncInfo *param_5,int param_6,int param_7,\n          __uint64 *param_8)\n\n{\n  int *piVar1;\n  _s_HandlerType *p_Var2;\n  longlong lVar3;\n  int iVar4;\n  longlong lVar5;\n  PVOID pvVar6;\n  uint uVar7;\n  _s_FuncInfo *local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 uStack_84;\n  uint uStack_80;\n  undefined4 uStack_7c;\n  int local_78;\n  int iStack_74;\n  int iStack_70;\n  int iStack_6c;\n  int local_68;\n  undefined4 local_60;\n  undefined4 uStack_5c;\n  uint uStack_58;\n  undefined4 uStack_54;\n  uint local_48;\n  \n  if (*(int *)param_1 != -0x7ffffffd) {\n    lVar5 = FUN_140008b20();\n    if (*(longlong *)(lVar5 + 0x10) != 0) {\n      pvVar6 = EncodePointer((PVOID)0x0);\n      lVar5 = FUN_140008b20();\n      if ((((*(PVOID *)(lVar5 + 0x10) != pvVar6) && (*(int *)param_1 != -0x1fbcb0b3)) &&\n          (*(int *)param_1 != -0x1fbcbcae)) &&\n         (iVar4 = _CallSETranslator<class___FrameHandler3>\n                            (param_1,param_2,param_3,param_4,param_5,param_7,param_8,param_6),\n         iVar4 != 0)) {\n        return;\n      }\n    }\n    local_90 = *(undefined8 *)(param_4 + 8);\n    local_98 = param_5;\n    if (param_5->nTryBlocks == 0) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    FUN_1400072fc(&local_60,&local_98,param_6,(ulonglong *)param_4,(longlong)param_5);\n    local_88 = local_60;\n    uStack_84 = uStack_5c;\n    uStack_80 = uStack_58;\n    uStack_7c = uStack_54;\n    if (uStack_58 < local_48) {\n      uVar7 = uStack_58;\n      do {\n        lVar3 = *(longlong *)(CONCAT44(uStack_5c,local_60) + 8);\n        lVar5 = (longlong)*(int *)(*(longlong *)CONCAT44(uStack_84,local_88) + 0x10) +\n                (ulonglong)uVar7 * 0x14;\n        piVar1 = (int *)(lVar5 + lVar3);\n        local_78 = *piVar1;\n        iStack_74 = piVar1[1];\n        iStack_70 = piVar1[2];\n        iStack_6c = piVar1[3];\n        local_68 = *(int *)(lVar5 + 0x10 + lVar3);\n        if ((local_78 <= param_6) && (param_6 <= iStack_74)) {\n          p_Var2 = (_s_HandlerType *)\n                   ((longlong)local_68 + *(longlong *)(param_4 + 8) +\n                   ((*(ulonglong *)(piVar1 + 2) >> 0x20) - 1) * 0x14);\n          if (*(int *)(p_Var2 + 4) != 0) {\n            iVar4 = *(int *)(p_Var2 + 4);\n            lVar5 = _GetImageBase();\n            if (lVar5 + iVar4 != 0) {\n              if (iVar4 == 0) {\n                lVar5 = 0;\n              }\n              else {\n                lVar5 = _GetImageBase();\n                lVar5 = lVar5 + *(int *)(p_Var2 + 4);\n              }\n              if (*(char *)(lVar5 + 0x10) != '\\0') goto LAB_14000a19d;\n            }\n          }\n          if (((byte)*p_Var2 & 0x40) == 0) {\n            CatchIt<class___FrameHandler3>\n                      (param_1,param_2,param_3,param_4,param_5,p_Var2,(_s_CatchableType *)0x0,\n                       (_s_TryBlockMapEntry *)&local_78,param_7,param_8,'\\x01','\\0');\n          }\n        }\nLAB_14000a19d:\n        uVar7 = uVar7 + 1;\n      } while (uVar7 < local_48);\n    }\n  }\n  return;\n}\n\n",
  "__acrt_stdio_free_stream": "\n/* Library Function - Single Match\n    void __cdecl __acrt_stdio_free_stream(class __crt_stdio_stream)\n   \n   Library: Visual Studio 2019 Release */\n\nundefined4 __cdecl __acrt_stdio_free_stream(undefined8 *param_1)\n\n{\n  undefined4 uVar1;\n  \n  *(undefined4 *)(param_1 + 3) = 0xffffffff;\n  *param_1 = 0;\n  param_1[1] = 0;\n  *(undefined4 *)(param_1 + 2) = 0;\n  *(undefined8 *)((longlong)param_1 + 0x1c) = 0;\n  param_1[5] = 0;\n  LOCK();\n  uVar1 = *(undefined4 *)((longlong)param_1 + 0x14);\n  *(undefined4 *)((longlong)param_1 + 0x14) = 0;\n  UNLOCK();\n  return uVar1;\n}\n\n",
  "FUN_14000bd20": "\nvoid FUN_14000bd20(void)\n\n{\n  return;\n}\n\n",
  "__acrt_InitializeCriticalSectionEx": "\n/* Library Function - Single Match\n    __acrt_InitializeCriticalSectionEx\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_InitializeCriticalSectionEx(LPCRITICAL_SECTION param_1,DWORD param_2,undefined4 param_3)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = try_get_function(0x12,\"InitializeCriticalSectionEx\",(module_id *)&DAT_140028e58,\n                            (module_id *)&DAT_140028e60);\n  if (pvVar1 == (void *)0x0) {\n    InitializeCriticalSectionAndSpinCount(param_1,param_2);\n  }\n  else {\n    (*(code *)PTR__guard_dispatch_icall_140023298)(param_1,param_2,param_3);\n  }\n  return;\n}\n\n",
  "_register_thread_local_exe_atexit_callback": "\n/* Library Function - Single Match\n    _register_thread_local_exe_atexit_callback\n   \n   Library: Visual Studio 2019 Release */\n\nvoid _register_thread_local_exe_atexit_callback(ulonglong param_1)\n\n{\n  code *pcVar1;\n  byte bVar2;\n  \n  if (DAT_140037240 == DAT_140035020) {\n    bVar2 = 0x40 - ((byte)DAT_140035020 & 0x3f) & 0x3f;\n    DAT_140037240 = (param_1 >> bVar2 | param_1 << 0x40 - bVar2) ^ DAT_140035020;\n    return;\n  }\n  terminate();\n  pcVar1 = (code *)swi(3);\n  (*pcVar1)();\n  return;\n}\n\n",
  "FUN_1400035c0": "\nundefined8 *\nFUN_1400035c0(undefined8 *param_1,undefined8 param_2,undefined8 param_3,undefined param_4)\n\n{\n  ulonglong uVar1;\n  ulonglong uVar2;\n  ulonglong uVar3;\n  undefined8 *puVar4;\n  code *pcVar5;\n  void *pvVar6;\n  ulonglong uVar7;\n  __uint64 _Var8;\n  ulonglong uVar9;\n  undefined8 *puVar10;\n  undefined8 *puVar11;\n  \n  uVar2 = param_1[2];\n  if (uVar2 == 0x7fffffffffffffff) {\n    FUN_140001380();\n    pcVar5 = (code *)swi(3);\n    puVar11 = (undefined8 *)(*pcVar5)();\n    return puVar11;\n  }\n  uVar3 = param_1[3];\n  uVar7 = uVar2 + 1 | 0xf;\n  uVar9 = 0x7fffffffffffffff;\n  if (((uVar7 < 0x8000000000000000) && (uVar3 <= 0x7fffffffffffffff - (uVar3 >> 1))) &&\n     (uVar1 = (uVar3 >> 1) + uVar3, uVar9 = uVar7, uVar7 < uVar1)) {\n    uVar9 = uVar1;\n  }\n  _Var8 = uVar9 + 1;\n  if (uVar9 == 0xffffffffffffffff) {\n    _Var8 = 0xffffffffffffffff;\n  }\n  if (_Var8 < 0x1000) {\n    if (_Var8 == 0) {\n      puVar11 = (undefined8 *)0x0;\n    }\n    else {\n      puVar11 = (undefined8 *)operator_new(_Var8);\n    }\n  }\n  else {\n    if (_Var8 + 0x27 <= _Var8) {\n      FUN_1400012e0();\n      pcVar5 = (code *)swi(3);\n      puVar11 = (undefined8 *)(*pcVar5)();\n      return puVar11;\n    }\n    pvVar6 = operator_new(_Var8 + 0x27);\n    if (pvVar6 == (void *)0x0) goto LAB_140003710;\n    puVar11 = (undefined8 *)((longlong)pvVar6 + 0x27U & 0xffffffffffffffe0);\n    puVar11[-1] = pvVar6;\n  }\n  param_1[2] = uVar2 + 1;\n  param_1[3] = uVar9;\n  if (uVar3 < 0x10) {\n    FUN_140007ed0(puVar11,param_1,uVar2);\n    *(undefined *)((longlong)puVar11 + uVar2) = param_4;\n    *(undefined *)((longlong)puVar11 + uVar2 + 1) = 0;\n  }\n  else {\n    puVar4 = (undefined8 *)*param_1;\n    FUN_140007ed0(puVar11,puVar4,uVar2);\n    *(undefined *)((longlong)puVar11 + uVar2) = param_4;\n    *(undefined *)((longlong)puVar11 + uVar2 + 1) = 0;\n    puVar10 = puVar4;\n    if ((0xfff < uVar3 + 1) &&\n       (puVar10 = (undefined8 *)puVar4[-1],\n       0x1f < (ulonglong)((longlong)puVar4 + (-8 - (longlong)puVar10)))) {\nLAB_140003710:\n      FUN_14000d050();\n      pcVar5 = (code *)swi(3);\n      puVar11 = (undefined8 *)(*pcVar5)();\n      return puVar11;\n    }\n    thunk_FUN_14000ce08(puVar10);\n  }\n  *param_1 = puVar11;\n  return param_1;\n}\n\n",
  "basic_streambuf<>": "\n/* Library Function - Multiple Matches With Same Base Name\n    protected: __cdecl std::basic_streambuf<char,struct std::char_traits<char>\n   >::basic_streambuf<char,struct std::char_traits<char> >(void) __ptr64\n    protected: __cdecl std::basic_streambuf<unsigned short,struct std::char_traits<unsigned short>\n   >::basic_streambuf<unsigned short,struct std::char_traits<unsigned short> >(void) __ptr64\n    protected: __cdecl std::basic_streambuf<wchar_t,struct std::char_traits<wchar_t>\n   >::basic_streambuf<wchar_t,struct std::char_traits<wchar_t> >(void) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 * basic_streambuf<>(undefined8 *param_1)\n\n{\n  void *pvVar1;\n  _Locimp *p_Var2;\n  \n  *param_1 = std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable;\n  pvVar1 = operator_new(0x10);\n  if (pvVar1 == (void *)0x0) {\n    pvVar1 = (void *)0x0;\n  }\n  else {\n    p_Var2 = std::locale::_Init(true);\n    *(_Locimp **)((longlong)pvVar1 + 8) = p_Var2;\n  }\n  param_1[0xc] = pvVar1;\n  param_1[3] = param_1 + 1;\n  param_1[4] = param_1 + 2;\n  param_1[7] = param_1 + 5;\n  param_1[8] = param_1 + 6;\n  param_1[10] = param_1 + 9;\n  param_1[0xb] = (undefined4 *)((longlong)param_1 + 0x4c);\n  param_1[2] = 0;\n  param_1[6] = 0;\n  *(undefined4 *)((longlong)param_1 + 0x4c) = 0;\n  param_1[1] = 0;\n  param_1[5] = 0;\n  *(undefined4 *)(param_1 + 9) = 0;\n  return param_1;\n}\n\n",
  "_cexit": "\n/* Library Function - Single Match\n    _cexit\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl _cexit(void)\n\n{\n  common_exit(0,0,1);\n  return;\n}\n\n",
  "FUN_1400013e0": "\nundefined4 * FUN_1400013e0(undefined8 param_1,undefined4 *param_2,undefined4 param_3)\n\n{\n  *param_2 = param_3;\n  *(undefined8 *)(param_2 + 2) = param_1;\n  return param_2;\n}\n\n",
  "parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<char>_>": "\n/* Library Function - Single Match\n    unsigned long __cdecl __crt_strtox::parse_integer<unsigned long,class\n   __crt_strtox::c_string_character_source<char> >(struct __crt_locale_pointers * __ptr64\n   const,class __crt_strtox::c_string_character_source<char>,int,bool)\n   \n   Library: Visual Studio 2019 Release */\n\nuint __cdecl\n__crt_strtox::parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<char>_>\n          (__crt_locale_pointers *param_1,byte **param_2,uint param_3,byte param_4)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  char cVar3;\n  uint uVar4;\n  int iVar5;\n  ulong *puVar6;\n  byte bVar7;\n  uint uVar8;\n  byte bVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  longlong local_38;\n  localeinfo_struct local_30;\n  char local_20;\n  \n  if ((*param_2 == (byte *)0x0) || ((param_3 != 0 && (0x22 < param_3 - 2)))) {\n    puVar6 = __doserrno();\n    *puVar6 = 0x16;\n    FUN_14000d030();\n    goto LAB_14000c514;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_38,param_1);\n  pbVar1 = *param_2;\n  uVar10 = 0;\n  bVar7 = *pbVar1;\n  pbVar2 = pbVar1;\n  while( true ) {\n    uVar8 = (uint)bVar7;\n    *param_2 = pbVar2 + 1;\n    uVar4 = _ischartype_l(uVar8,8,&local_30);\n    if (uVar4 == 0) break;\n    pbVar2 = *param_2;\n    bVar7 = *pbVar2;\n  }\n  bVar9 = param_4 | 2;\n  if (bVar7 != 0x2d) {\n    bVar9 = param_4;\n  }\n  if ((uVar8 - 0x2b & 0xfd) == 0) {\n    uVar8 = (uint)**param_2;\n    *param_2 = *param_2 + 1;\n  }\n  uVar11 = 0xffffffff;\n  uVar4 = param_3;\n  if ((param_3 & 0xffffffef) == 0) {\n    cVar3 = (char)uVar8;\n    if ((byte)(cVar3 - 0x30U) < 10) {\n      iVar5 = cVar3 + -0x30;\n    }\n    else if ((byte)(cVar3 + 0x9fU) < 0x1a) {\n      iVar5 = cVar3 + -0x57;\n    }\n    else if ((byte)(cVar3 + 0xbfU) < 0x1a) {\n      iVar5 = cVar3 + -0x37;\n    }\n    else {\n      iVar5 = -1;\n    }\n    if (iVar5 == 0) {\n      pbVar2 = *param_2;\n      bVar7 = *pbVar2;\n      *param_2 = pbVar2 + 1;\n      if ((bVar7 + 0xa8 & 0xdf) != 0) {\n        uVar4 = 8;\n        if (param_3 != 0) {\n          uVar4 = param_3;\n        }\n        *param_2 = pbVar2;\n        if ((bVar7 != 0) && (*pbVar2 != bVar7)) {\n          puVar6 = __doserrno();\n          *puVar6 = 0x16;\n          FUN_14000d030();\n        }\n        goto LAB_14000c45f;\n      }\n      uVar8 = (uint)pbVar2[1];\n      *param_2 = pbVar2 + 2;\n      uVar4 = 0x10;\n    }\n    else {\n      uVar4 = 10;\n    }\n    if (param_3 != 0) {\n      uVar4 = param_3;\n    }\n  }\nLAB_14000c45f:\n  while( true ) {\n    bVar7 = (byte)uVar8;\n    if ((byte)(bVar7 - 0x30) < 10) {\n      uVar8 = (int)(char)bVar7 - 0x30;\n    }\n    else if ((byte)(bVar7 + 0x9f) < 0x1a) {\n      uVar8 = (int)(char)bVar7 - 0x57;\n    }\n    else if ((byte)(bVar7 + 0xbf) < 0x1a) {\n      uVar8 = (int)(char)bVar7 - 0x37;\n    }\n    else {\n      uVar8 = 0xffffffff;\n    }\n    if ((uVar8 == 0xffffffff) || (uVar4 <= uVar8)) break;\n    uVar12 = (uint)(0xffffffff / (ulonglong)uVar4);\n    if ((uVar10 < uVar12) ||\n       ((uVar10 == uVar12 && (uVar8 <= (uint)(0xffffffff % (ulonglong)uVar4))))) {\n      uVar10 = uVar10 * uVar4 + uVar8;\n      bVar7 = 8;\n    }\n    else {\n      bVar7 = 0xc;\n    }\n    uVar8 = (uint)**param_2;\n    *param_2 = *param_2 + 1;\n    bVar9 = bVar9 | bVar7;\n  }\n  pbVar2 = *param_2;\n  *param_2 = pbVar2 + -1;\n  if ((bVar7 != 0) && (pbVar2[-1] != bVar7)) {\n    puVar6 = __doserrno();\n    *puVar6 = 0x16;\n    FUN_14000d030();\n  }\n  if ((bVar9 & 8) == 0) {\n    *param_2 = pbVar1;\n    if (local_20 != '\\0') {\n      *(uint *)(local_38 + 0x3a8) = *(uint *)(local_38 + 0x3a8) & 0xfffffffd;\n    }\nLAB_14000c514:\n    if ((byte **)param_2[1] != (byte **)0x0) {\n      *(byte **)param_2[1] = *param_2;\n    }\n    return 0;\n  }\n  if ((bVar9 & 4) != 0) goto LAB_14000c550;\n  if ((bVar9 & 1) == 0) {\nLAB_14000c590:\n    uVar11 = uVar10;\n    if ((bVar9 & 2) != 0) {\n      uVar11 = -uVar10;\n    }\n  }\n  else {\n    if ((bVar9 & 2) == 0) {\n      if (uVar10 < 0x80000000) goto LAB_14000c590;\n    }\n    else if (uVar10 < 0x80000001) goto LAB_14000c590;\nLAB_14000c550:\n    puVar6 = __doserrno();\n    *puVar6 = 0x22;\n    if ((bVar9 & 1) != 0) {\n      if ((bVar9 & 2) != 0) {\n        if (local_20 != '\\0') {\n          *(uint *)(local_38 + 0x3a8) = *(uint *)(local_38 + 0x3a8) & 0xfffffffd;\n        }\n        if ((byte **)param_2[1] != (byte **)0x0) {\n          *(byte **)param_2[1] = *param_2;\n        }\n        return 0x80000000;\n      }\n      if (local_20 != '\\0') {\n        *(uint *)(local_38 + 0x3a8) = *(uint *)(local_38 + 0x3a8) & 0xfffffffd;\n      }\n      if ((byte **)param_2[1] != (byte **)0x0) {\n        *(byte **)param_2[1] = *param_2;\n      }\n      return 0x7fffffff;\n    }\n  }\n  if (local_20 != '\\0') {\n    *(uint *)(local_38 + 0x3a8) = *(uint *)(local_38 + 0x3a8) & 0xfffffffd;\n  }\n  if ((byte **)param_2[1] == (byte **)0x0) {\n    return uVar11;\n  }\n  *(byte **)param_2[1] = *param_2;\n  return uVar11;\n}\n\n",
  "_wcsdup": "\n/* Library Function - Single Match\n    _wcsdup\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nwchar_t * __cdecl _wcsdup(wchar_t *_Str)\n\n{\n  errno_t eVar1;\n  wchar_t *_Dst;\n  longlong lVar2;\n  rsize_t _SizeInWords;\n  longlong lVar3;\n  \n  if (_Str != (wchar_t *)0x0) {\n    lVar2 = -1;\n    do {\n      lVar3 = lVar2;\n      lVar2 = lVar3 + 1;\n    } while (_Str[lVar2] != L'\\0');\n    _SizeInWords = lVar3 + 2;\n    _Dst = (wchar_t *)_malloc_base(_SizeInWords * 2);\n    if (_Dst != (wchar_t *)0x0) {\n      eVar1 = wcscpy_s(_Dst,_SizeInWords,_Str);\n      if (eVar1 == 0) {\n        return _Dst;\n      }\n                    /* WARNING: Subroutine does not return */\n      _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n  }\n  return (wchar_t *)0x0;\n}\n\n",
  "_New_Locimp": "\n/* Library Function - Single Match\n    private: static class std::locale::_Locimp * __ptr64 __cdecl\n   std::locale::_Locimp::_New_Locimp(bool)\n   \n   Library: Visual Studio 2019 Release */\n\n_Locimp * __cdecl std::locale::_Locimp::_New_Locimp(bool param_1)\n\n{\n  _Locimp *this;\n  _Locimp *p_Var1;\n  \n  this = (_Locimp *)operator_new(0x38);\n  p_Var1 = (_Locimp *)0x0;\n  if (this != (_Locimp *)0x0) {\n    p_Var1 = (_Locimp *)_Locimp(this,param_1);\n  }\n  return p_Var1;\n}\n\n",
  "_configthreadlocale": "\n/* Library Function - Single Match\n    _configthreadlocale\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _configthreadlocale(int _Flag)\n\n{\n  uint uVar1;\n  longlong lVar2;\n  ulong *puVar3;\n  uint uVar4;\n  \n  lVar2 = FUN_140014d84();\n  uVar1 = *(uint *)(lVar2 + 0x3a8);\n  if (_Flag == -1) {\n    DAT_140035520 = 0xffffffff;\n  }\n  else if (_Flag != 0) {\n    if (_Flag == 1) {\n      uVar4 = uVar1 | 2;\n    }\n    else {\n      if (_Flag != 2) {\n        puVar3 = __doserrno();\n        *puVar3 = 0x16;\n        FUN_14000d030();\n        return -1;\n      }\n      uVar4 = uVar1 & 0xfffffffd;\n    }\n    *(uint *)(lVar2 + 0x3a8) = uVar4;\n  }\n  return 2 - (uint)((uVar1 & 2) != 0);\n}\n\n",
  "__isa_available_init": "\n/* WARNING: Removing unreachable block (ram,0x000140006e2b) */\n/* WARNING: Removing unreachable block (ram,0x000140006da6) */\n/* WARNING: Removing unreachable block (ram,0x000140006d7f) */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    __isa_available_init\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __isa_available_init(void)\n\n{\n  int *piVar1;\n  uint *puVar2;\n  longlong lVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  byte in_XCR0;\n  \n  piVar1 = (int *)cpuid_basic_info(0);\n  uVar6 = 0;\n  puVar2 = (uint *)cpuid_Version_info(1);\n  uVar4 = puVar2[3];\n  if ((piVar1[1] ^ 0x756e6547U | piVar1[3] ^ 0x6c65746eU | piVar1[2] ^ 0x49656e69U) == 0) {\n    _DAT_140035040 = 0xffffffffffffffff;\n    uVar5 = *puVar2 & 0xfff3ff0;\n    if ((((uVar5 == 0x106c0) || (uVar5 == 0x20660)) || (uVar5 == 0x20670)) ||\n       ((uVar5 - 0x30650 < 0x21 &&\n        ((0x100010001U >> ((ulonglong)(uVar5 - 0x30650) & 0x3f) & 1) != 0)))) {\n      DAT_140036d1c = DAT_140036d1c | 1;\n    }\n  }\n  if (6 < *piVar1) {\n    lVar3 = cpuid_Extended_Feature_Enumeration_info(7);\n    uVar6 = *(uint *)(lVar3 + 4);\n    if ((uVar6 >> 9 & 1) != 0) {\n      DAT_140036d1c = DAT_140036d1c | 2;\n    }\n  }\n  DAT_140035038 = 1;\n  DAT_14003503c = 2;\n  if ((uVar4 >> 0x14 & 1) != 0) {\n    DAT_140035038 = 2;\n    DAT_14003503c = 6;\n    if ((((uVar4 >> 0x1b & 1) != 0) && ((uVar4 >> 0x1c & 1) != 0)) && ((in_XCR0 & 6) == 6)) {\n      DAT_14003503c = 0xe;\n      DAT_140035038 = 3;\n      if ((uVar6 & 0x20) != 0) {\n        DAT_140035038 = 5;\n        DAT_14003503c = 0x2e;\n        if (((uVar6 & 0xd0030000) == 0xd0030000) && ((in_XCR0 & 0xe0) == 0xe0)) {\n          DAT_14003503c = 0x6e;\n          DAT_140035038 = 6;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
  "islower": "\n/* Library Function - Single Match\n    islower\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl islower(int _C)\n\n{\n  uint uVar1;\n  longlong local_28;\n  localeinfo_struct local_20;\n  char local_10;\n  \n  uVar1 = 0;\n  if (DAT_140037280 == 0) {\n    if (_C + 1U < 0x101) {\n      uVar1 = *(ushort *)(PTR_DAT_140035260 + (longlong)_C * 2) & 2;\n    }\n  }\n  else {\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,(__crt_locale_pointers *)0x0);\n    uVar1 = _ischartype_l(_C,2,&local_20);\n    if (local_10 != '\\0') {\n      *(uint *)(local_28 + 0x3a8) = *(uint *)(local_28 + 0x3a8) & 0xfffffffd;\n    }\n  }\n  return uVar1;\n}\n\n",
  "__acrt_wcs_to_mbs_cp<struct___crt_win32_buffer_internal_dynamic_resizing>": "\n/* Library Function - Single Match\n    int __cdecl __acrt_wcs_to_mbs_cp<struct __crt_win32_buffer_internal_dynamic_resizing>(wchar_t\n   const * __ptr64 const,class __crt_win32_buffer<char,struct\n   __crt_win32_buffer_internal_dynamic_resizing> & __ptr64,unsigned int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl\n__acrt_wcs_to_mbs_cp<struct___crt_win32_buffer_internal_dynamic_resizing>\n          (wchar_t *param_1,\n          __crt_win32_buffer<char,struct___crt_win32_buffer_internal_dynamic_resizing> *param_2,\n          uint param_3)\n\n{\n  int iVar1;\n  DWORD DVar2;\n  LPVOID pvVar3;\n  ulong *puVar4;\n  ulonglong uVar5;\n  uint uVar6;\n  ulonglong uVar7;\n  ulonglong uVar8;\n  \n  uVar7 = 0;\n  if (param_1 == (wchar_t *)0x0) {\n    if (param_2[0x28] !=\n        (__crt_win32_buffer<char,struct___crt_win32_buffer_internal_dynamic_resizing>)0x0) {\n      _free_base(*(LPVOID *)(param_2 + 0x10));\n      param_2[0x28] =\n           (__crt_win32_buffer<char,struct___crt_win32_buffer_internal_dynamic_resizing>)0x0;\n    }\n    *(undefined8 *)(param_2 + 0x10) = 0;\n    *(undefined8 *)(param_2 + 0x18) = 0;\n  }\n  else {\n    if (*param_1 != L'\\0') {\n      iVar1 = __acrt_WideCharToMultiByte(param_3,0,param_1,-1,(LPSTR)0x0,0,(LPBOOL)0x0,(LPBOOL)0x0);\n      uVar8 = (ulonglong)iVar1;\n      if (iVar1 != 0) {\n        uVar5 = *(ulonglong *)(param_2 + 0x18);\n        if (uVar5 < uVar8) {\n          if (param_2[0x28] !=\n              (__crt_win32_buffer<char,struct___crt_win32_buffer_internal_dynamic_resizing>)0x0) {\n            _free_base(*(LPVOID *)(param_2 + 0x10));\n            param_2[0x28] =\n                 (__crt_win32_buffer<char,struct___crt_win32_buffer_internal_dynamic_resizing>)0x0;\n          }\n          pvVar3 = _malloc_base(uVar8);\n          *(LPVOID *)(param_2 + 0x10) = pvVar3;\n          uVar6 = ~-(uint)(pvVar3 != (LPVOID)0x0) & 0xc;\n          uVar5 = 0;\n          if (uVar6 == 0) {\n            uVar5 = uVar8;\n          }\n          param_2[0x28] =\n               (__crt_win32_buffer<char,struct___crt_win32_buffer_internal_dynamic_resizing>)\n               (uVar6 == 0);\n          *(ulonglong *)(param_2 + 0x18) = uVar5;\n          if (uVar6 != 0) goto LAB_14001aa41;\n        }\n        iVar1 = __acrt_WideCharToMultiByte\n                          (param_3,0,param_1,-1,*(LPSTR *)(param_2 + 0x10),(int)uVar5,(LPBOOL)0x0,\n                           (LPBOOL)0x0);\n        if (iVar1 != 0) {\n          *(longlong *)(param_2 + 0x20) = (longlong)iVar1 + -1;\n          goto LAB_14001ab19;\n        }\n      }\n      DVar2 = GetLastError();\n      __acrt_errno_map_os_error(DVar2);\n      puVar4 = __doserrno();\n      uVar7 = (ulonglong)*puVar4;\n      goto LAB_14001ab19;\n    }\n    if (*(longlong *)(param_2 + 0x18) == 0) {\n      if (param_2[0x28] !=\n          (__crt_win32_buffer<char,struct___crt_win32_buffer_internal_dynamic_resizing>)0x0) {\n        _free_base(*(LPVOID *)(param_2 + 0x10));\n        param_2[0x28] =\n             (__crt_win32_buffer<char,struct___crt_win32_buffer_internal_dynamic_resizing>)0x0;\n      }\n      pvVar3 = _malloc_base(1);\n      *(LPVOID *)(param_2 + 0x10) = pvVar3;\n      uVar6 = ~-(uint)(pvVar3 != (LPVOID)0x0) & 0xc;\n      param_2[0x28] =\n           (__crt_win32_buffer<char,struct___crt_win32_buffer_internal_dynamic_resizing>)\n           (uVar6 == 0);\n      *(ulonglong *)(param_2 + 0x18) = (ulonglong)(uVar6 == 0);\n      if (uVar6 != 0) {\nLAB_14001aa41:\n        uVar7 = (ulonglong)uVar6;\n        goto LAB_14001ab19;\n      }\n    }\n    **(undefined **)(param_2 + 0x10) = 0;\n  }\n  *(undefined8 *)(param_2 + 0x20) = 0;\n  uVar7 = 0;\nLAB_14001ab19:\n  return (int)uVar7;\n}\n\n",
  "free_environment<char>": "\n/* Library Function - Single Match\n    void __cdecl free_environment<char>(char * __ptr64 * __ptr64 const)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl free_environment<char>(char **param_1)\n\n{\n  char *pcVar1;\n  char **ppcVar2;\n  \n  if (param_1 != (char **)0x0) {\n    pcVar1 = *param_1;\n    ppcVar2 = param_1;\n    while (pcVar1 != (char *)0x0) {\n      _free_base(pcVar1);\n      ppcVar2 = ppcVar2 + 1;\n      pcVar1 = *ppcVar2;\n    }\n    _free_base(param_1);\n  }\n  return;\n}\n\n",
  "FUN_140001dd0": "\nchar ***** FUN_140001dd0(char *****param_1,undefined8 *param_2,undefined8 *param_3)\n\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  char *****pppppcVar4;\n  longlong *plVar5;\n  longlong *local_48 [2];\n  undefined8 local_38;\n  ulonglong local_30;\n  char *****local_28;\n  undefined4 uStack_20;\n  undefined4 uStack_1c;\n  \n  pppppcVar4 = (char *****)*param_3;\n  uVar2 = *(undefined4 *)(param_3 + 1);\n  uVar3 = *(undefined4 *)((longlong)param_3 + 0xc);\n  local_38 = 0;\n  local_30 = 0xf;\n  local_48[0] = (longlong *)0x0;\n  plVar5 = (longlong *)0xffffffffffffffff;\n  do {\n    plVar5 = (longlong *)((longlong)plVar5 + 1);\n  } while (*(char *)((longlong)param_2 + (longlong)plVar5) != '\\0');\n  local_28 = param_1;\n  FUN_140002520(local_48,param_2,plVar5);\n  local_28 = pppppcVar4;\n  uStack_20 = uVar2;\n  uStack_1c = uVar3;\n  FUN_140001470(param_1,&local_28,local_48);\n  if (0xf < local_30) {\n    plVar5 = local_48[0];\n    if ((0xfff < local_30 + 1) &&\n       (plVar5 = (longlong *)local_48[0][-1],\n       0x1f < (ulonglong)((longlong)local_48[0] + (-8 - (longlong)plVar5)))) {\n      FUN_14000d050();\n      pcVar1 = (code *)swi(3);\n      pppppcVar4 = (char *****)(*pcVar1)();\n      return pppppcVar4;\n    }\n    thunk_FUN_14000ce08(plVar5);\n  }\n  *param_1 = (char ****)std::ios_base::failure::vftable;\n  return param_1;\n}\n\n",
  "FUN_140007d08": "\nvoid FUN_140007d08(undefined8 param_1,undefined *UNRECOVERED_JUMPTABLE)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x000140007d08. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
  "strncpy_s": "\n/* Library Function - Single Match\n    strncpy_s\n   \n   Library: Visual Studio 2019 Release */\n\nerrno_t __cdecl strncpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src,rsize_t _MaxCount)\n\n{\n  char cVar1;\n  ulong *puVar2;\n  char *pcVar3;\n  ulong uVar4;\n  rsize_t rVar5;\n  rsize_t rVar6;\n  \n  if (_MaxCount == 0) {\n    if (_Dst == (char *)0x0) {\n      if (_SizeInBytes == 0) {\n        return 0;\n      }\n    }\n    else {\nLAB_14001f5f9:\n      if (_SizeInBytes != 0) {\n        if (_MaxCount == 0) {\n          *_Dst = '\\0';\n          return 0;\n        }\n        if (_Src != (char *)0x0) {\n          pcVar3 = _Dst;\n          rVar5 = _MaxCount;\n          rVar6 = _SizeInBytes;\n          if (_MaxCount == 0xffffffffffffffff) {\n            do {\n              cVar1 = pcVar3[(longlong)_Src - (longlong)_Dst];\n              *pcVar3 = cVar1;\n              pcVar3 = pcVar3 + 1;\n              if (cVar1 == '\\0') break;\n              rVar6 = rVar6 - 1;\n            } while (rVar6 != 0);\n          }\n          else {\n            do {\n              cVar1 = pcVar3[(longlong)_Src - (longlong)_Dst];\n              *pcVar3 = cVar1;\n              pcVar3 = pcVar3 + 1;\n              if ((cVar1 == '\\0') || (rVar6 = rVar6 - 1, rVar6 == 0)) break;\n              rVar5 = rVar5 - 1;\n            } while (rVar5 != 0);\n            if (rVar5 == 0) {\n              *pcVar3 = '\\0';\n            }\n          }\n          if (rVar6 != 0) {\n            return 0;\n          }\n          if (_MaxCount == 0xffffffffffffffff) {\n            _Dst[_SizeInBytes - 1] = '\\0';\n            return 0x50;\n          }\n          *_Dst = '\\0';\n          puVar2 = __doserrno();\n          uVar4 = 0x22;\n          goto LAB_14001f5dc;\n        }\n        *_Dst = '\\0';\n      }\n    }\n  }\n  else if (_Dst != (char *)0x0) goto LAB_14001f5f9;\n  puVar2 = __doserrno();\n  uVar4 = 0x16;\nLAB_14001f5dc:\n  *puVar2 = uVar4;\n  FUN_14000d030();\n  return uVar4;\n}\n\n",
  "FUN_140002da0": "\nvoid FUN_140002da0(longlong **param_1)\n\n{\n  longlong *plVar1;\n  \n  plVar1 = *(longlong **)((longlong)*(int *)(**param_1 + 4) + 0x48 + (longlong)*param_1);\n  if (plVar1 != (longlong *)0x0) {\n    (**(code **)(*plVar1 + 0x10))();\n  }\n  return;\n}\n\n",
  "FUN_14000ce08": "\nvoid FUN_14000ce08(LPVOID param_1)\n\n{\n  _free_base(param_1);\n  return;\n}\n\n",
  "BuildCatchObjectHelperInternal<class___FrameHandler4>": "\n/* Library Function - Single Match\n    int __cdecl BuildCatchObjectHelperInternal<class __FrameHandler4>(struct EHExceptionRecord *\n   __ptr64,void * __ptr64,struct FH4::HandlerType4 * __ptr64,struct _s_CatchableType const *\n   __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\nBuildCatchObjectHelperInternal<class___FrameHandler4>\n          (EHExceptionRecord *param_1,void *param_2,HandlerType4 *param_3,_s_CatchableType *param_4)\n\n{\n  longlong lVar1;\n  undefined8 *puVar2;\n  ulonglong uVar3;\n  ulonglong uVar4;\n  int iVar5;\n  ulonglong uVar6;\n  int iVar7;\n  \n  uVar4 = 0;\n  uVar6 = 0;\n  iVar5 = 0;\n  uVar3 = uVar4;\n  iVar7 = iVar5;\n  if (*(int *)(param_3 + 8) != 0) {\n    iVar7 = *(int *)(param_3 + 8);\n    lVar1 = _GetImageBase();\n    uVar3 = iVar7 + lVar1;\n  }\n  if (uVar3 == 0) {\n    return 0;\n  }\n  uVar3 = uVar4;\n  if (iVar7 != 0) {\n    lVar1 = _GetImageBase();\n    uVar3 = lVar1 + *(int *)(param_3 + 8);\n  }\n  if (*(char *)(uVar3 + 0x10) == '\\0') {\n    return 0;\n  }\n  if ((*(int *)(param_3 + 0xc) == 0) && (-1 < *(int *)(param_3 + 4))) {\n    return 0;\n  }\n  if (-1 < *(int *)(param_3 + 4)) {\n                    /* WARNING: Load size is inaccurate */\n    param_2 = (void *)((ulonglong)*(uint *)(param_3 + 0xc) + *param_2);\n  }\n  if (((((byte)param_3[4] & 0x80) == 0) || (((byte)*param_4 & 0x10) == 0)) || (DAT_140036d20 == 0))\n  {\n    if (((byte)param_3[4] & 8) == 0) {\n      if (((byte)*param_4 & 1) == 0) {\n        uVar3 = uVar4;\n        if (*(int *)(param_4 + 0x18) != 0) {\n          iVar5 = *(int *)(param_4 + 0x18);\n          lVar1 = _GetThrowImageBase();\n          uVar3 = iVar5 + lVar1;\n        }\n        if (uVar3 != 0) {\n          if ((*(longlong *)(param_1 + 0x28) != 0) && ((longlong *)param_2 != (longlong *)0x0)) {\n            if (iVar5 != 0) {\n              lVar1 = _GetThrowImageBase();\n              uVar4 = lVar1 + *(int *)(param_4 + 0x18);\n            }\n            if (uVar4 != 0) {\n              uVar6 = (ulonglong)((((byte)*param_4 & 4) != 0) + 1);\n              goto LAB_140009275;\n            }\n          }\n                    /* WARNING: Subroutine does not return */\n          abort();\n        }\n        if ((*(longlong *)(param_1 + 0x28) == 0) || ((longlong *)param_2 == (longlong *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n          abort();\n        }\n        iVar7 = *(int *)(param_4 + 0x14);\n        puVar2 = (undefined8 *)__AdjustPointer(*(longlong *)(param_1 + 0x28),(int *)(param_4 + 8));\n        FUN_140007ed0((undefined8 *)param_2,puVar2,(longlong)iVar7);\n        goto LAB_140009275;\n      }\n      if ((*(undefined8 **)(param_1 + 0x28) == (undefined8 *)0x0) ||\n         ((longlong *)param_2 == (longlong *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n      FUN_140007ed0((undefined8 *)param_2,*(undefined8 **)(param_1 + 0x28),\n                    (longlong)*(int *)(param_4 + 0x14));\n      uVar6 = uVar4;\n                    /* WARNING: Load size is inaccurate */\n      if ((*(int *)(param_4 + 0x14) != 8) || (*param_2 == 0)) goto LAB_140009275;\n                    /* WARNING: Load size is inaccurate */\n      lVar1 = *param_2;\n    }\n    else {\n      lVar1 = *(longlong *)(param_1 + 0x28);\n      if ((lVar1 == 0) || ((longlong *)param_2 == (longlong *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n      *(longlong *)param_2 = lVar1;\n    }\n  }\n  else {\n    lVar1 = (*(code *)PTR__guard_dispatch_icall_140023298)();\n    if ((lVar1 == 0) || ((longlong *)param_2 == (longlong *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    *(longlong *)param_2 = lVar1;\n  }\n  lVar1 = __AdjustPointer(lVar1,(int *)(param_4 + 8));\n  *(longlong *)param_2 = lVar1;\n  uVar6 = uVar4;\nLAB_140009275:\n  return (int)uVar6;\n}\n\n",
  "FUN_140001ef0": "\nvoid FUN_140001ef0(undefined8 *param_1)\n\n{\n  code *pcVar1;\n  ulong *puVar2;\n  longlong ****pppplVar3;\n  longlong *plVar4;\n  undefined auStack_58 [32];\n  longlong ***local_38;\n  longlong ***local_30 [2];\n  undefined8 local_20;\n  ulonglong local_18;\n  ulonglong local_10;\n  \n  local_10 = DAT_140035020 ^ (ulonglong)auStack_58;\n  local_20 = 0;\n  local_18 = 0xf;\n  local_30[0] = (longlong ***)0x0;\n  plVar4 = (longlong *)0x2;\n  if ((ulonglong)param_1[2] < 2) {\n    plVar4 = (longlong *)param_1[2];\n  }\n  if (0xf < (ulonglong)param_1[3]) {\n    param_1 = (undefined8 *)*param_1;\n  }\n  FUN_140002520((longlong **)local_30,param_1,plVar4);\n  puVar2 = __doserrno();\n  pppplVar3 = local_30;\n  if (0xf < local_18) {\n    pppplVar3 = (longlong ****)local_30[0];\n  }\n  *puVar2 = 0;\n  strtol((char *)pppplVar3,(char **)&local_38,10);\n  if (pppplVar3 == (longlong ****)local_38) {\n    FUN_140003a44(\"invalid stoi argument\");\n  }\n  else if (*puVar2 != 0x22) {\n    if (local_18 < 0x10) {\nLAB_140001fd5:\n      FUN_140006060(local_10 ^ (ulonglong)auStack_58);\n      return;\n    }\n    pppplVar3 = (longlong ****)local_30[0];\n    if ((local_18 + 1 < 0x1000) ||\n       (pppplVar3 = (longlong ****)local_30[0][-1],\n       (char *)((longlong)local_30[0] + (-8 - (longlong)pppplVar3)) < (char *)0x20)) {\n      thunk_FUN_14000ce08(pppplVar3);\n      goto LAB_140001fd5;\n    }\n    goto LAB_140002045;\n  }\n  FUN_140003a8c(\"stoi argument out of range\");\nLAB_140002045:\n  FUN_14000d050();\n  pcVar1 = (code *)swi(3);\n  (*pcVar1)();\n  return;\n}\n\n",
  "__GSHandlerCheck_SEH": "\n/* Library Function - Single Match\n    __GSHandlerCheck_SEH\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __GSHandlerCheck_SEH\n               (_EXCEPTION_RECORD *param_1,void *param_2,_CONTEXT *param_3,\n               _DISPATCHER_CONTEXT *param_4)\n\n{\n  uint uVar1;\n  uint *puVar2;\n  \n  puVar2 = *(uint **)(param_4 + 0x38);\n  uVar1 = *puVar2;\n  __GSHandlerCheckCommon((ulonglong)param_2,(longlong)param_4,puVar2 + (ulonglong)uVar1 * 4 + 1);\n  if ((puVar2[(ulonglong)uVar1 * 4 + 1] & ((param_1->ExceptionFlags & 0x66) != 0) + 1) != 0) {\n    __C_specific_handler(param_1,param_2,param_3,param_4);\n  }\n  return;\n}\n\n",
  "TestDefaultCountry": "\n/* Library Function - Single Match\n    TestDefaultCountry\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid TestDefaultCountry(wchar_t *param_1)\n\n{\n  int iVar1;\n  undefined auStack_48 [32];\n  WCHAR local_28 [12];\n  ulonglong local_10;\n  \n  local_10 = DAT_140035020 ^ (ulonglong)auStack_48;\n  iVar1 = __acrt_GetLocaleInfoEx((ushort *)param_1,0x59,local_28,9);\n  if (iVar1 != 0) {\n    wcsncmp(local_28,param_1,9);\n  }\n  FUN_140006060(local_10 ^ (ulonglong)auStack_48);\n  return;\n}\n\n",
  "__acrt_getptd_noexit": "\n/* Library Function - Single Match\n    __acrt_getptd_noexit\n   \n   Library: Visual Studio 2019 Release */\n\nulonglong __acrt_getptd_noexit(void)\n\n{\n  DWORD dwErrCode;\n  int iVar1;\n  __acrt_ptd *p_Var2;\n  \n  dwErrCode = GetLastError();\n  if ((DAT_140035250 == 0xffffffff) ||\n     (p_Var2 = (__acrt_ptd *)__acrt_FlsGetValue(DAT_140035250), p_Var2 == (__acrt_ptd *)0x0)) {\n    iVar1 = __acrt_FlsSetValue(DAT_140035250,(LPVOID)0xffffffffffffffff);\n    if (iVar1 != 0) {\n      p_Var2 = (__acrt_ptd *)_calloc_base(1,0x3c8);\n      if (p_Var2 == (__acrt_ptd *)0x0) {\n        __acrt_FlsSetValue(DAT_140035250,(LPVOID)0x0);\n        p_Var2 = (__acrt_ptd *)0x0;\n      }\n      else {\n        iVar1 = __acrt_FlsSetValue(DAT_140035250,p_Var2);\n        if (iVar1 != 0) {\n          construct_ptd_array(p_Var2);\n          _free_base((LPVOID)0x0);\n          goto LAB_140014fab;\n        }\n        __acrt_FlsSetValue(DAT_140035250,(LPVOID)0x0);\n      }\n      _free_base(p_Var2);\n    }\n  }\n  else if (p_Var2 != (__acrt_ptd *)0xffffffffffffffff) goto LAB_140014fab;\n  p_Var2 = (__acrt_ptd *)0x0;\nLAB_140014fab:\n  SetLastError(dwErrCode);\n  return -(ulonglong)(p_Var2 != (__acrt_ptd *)0x0) & (ulonglong)p_Var2;\n}\n\n",
  "FUN_140020960": "\nint FUN_140020960(ushort *param_1,ushort *param_2,longlong param_3)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  int iVar3;\n  ulong *puVar4;\n  ulonglong uVar5;\n  pthreadlocinfo ptVar6;\n  longlong local_38;\n  localeinfo_struct local_30;\n  char local_20;\n  \n  if (DAT_140037280 != 0) {\n    if ((param_1 == (ushort *)0x0) || (param_2 == (ushort *)0x0)) {\n      puVar4 = __doserrno();\n      *puVar4 = 0x16;\n      FUN_14000d030();\n      iVar3 = 0x7fffffff;\n    }\n    else if (param_3 == 0) {\n      iVar3 = 0;\n    }\n    else {\n      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_38,(__crt_locale_pointers *)0x0);\n      ptVar6 = local_30.locinfo;\n      if ((local_30.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n        iVar3 = __ascii_wcsnicmp(param_1,param_2,param_3);\n      }\n      else {\n        do {\n          if (*param_1 < 0x100) {\n            uVar5 = (ulonglong)*(byte *)param_1;\n            if (((&DAT_140025f72)[uVar5 * 2] & 1) != 0) {\n              uVar5 = (ulonglong)ptVar6->pclmap[uVar5];\n            }\n            uVar1 = (ushort)uVar5;\n          }\n          else {\n            uVar1 = _towlower_l(*param_1,&local_30);\n            ptVar6 = local_30.locinfo;\n          }\n          param_1 = param_1 + 1;\n          if (*param_2 < 0x100) {\n            uVar5 = (ulonglong)*(byte *)param_2;\n            if (((&DAT_140025f72)[uVar5 * 2] & 1) != 0) {\n              uVar5 = (ulonglong)ptVar6->pclmap[uVar5];\n            }\n            uVar2 = (ushort)uVar5;\n          }\n          else {\n            uVar2 = _towlower_l(*param_2,&local_30);\n            ptVar6 = local_30.locinfo;\n          }\n          param_2 = param_2 + 1;\n          iVar3 = (uint)uVar1 - (uint)uVar2;\n        } while (((iVar3 == 0) && (uVar1 != 0)) && (param_3 = param_3 + -1, param_3 != 0));\n      }\n      if (local_20 != '\\0') {\n        *(uint *)(local_38 + 0x3a8) = *(uint *)(local_38 + 0x3a8) & 0xfffffffd;\n      }\n    }\n    return iVar3;\n  }\n  if ((param_1 != (ushort *)0x0) && (param_2 != (ushort *)0x0)) {\n    iVar3 = __ascii_wcsnicmp(param_1,param_2,param_3);\n    return iVar3;\n  }\n  local_30.locinfo = (pthreadlocinfo)0x140020977;\n  puVar4 = __doserrno();\n  *puVar4 = 0x16;\n  local_30.locinfo = (pthreadlocinfo)0x140020982;\n  FUN_14000d030();\n  return 0x7fffffff;\n}\n\n",
  "setbuf": "\n/* Library Function - Single Match\n    protected: virtual class std::basic_streambuf<char,struct std::char_traits<char> > * __ptr64\n   __cdecl std::basic_filebuf<char,struct std::char_traits<char> >::setbuf(char * __ptr64,__int64)\n   __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nbasic_streambuf<char,struct_std::char_traits<char>_> * __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::setbuf\n          (basic_filebuf<char,struct_std::char_traits<char>_> *this,char *param_1,__int64 param_2)\n\n{\n  int iVar1;\n  \n  if ((param_1 == (char *)0x0) && (param_2 == 0)) {\n    iVar1 = 4;\n  }\n  else {\n    iVar1 = 0;\n  }\n  if ((*(FILE **)(this + 0x80) != (FILE *)0x0) &&\n     (iVar1 = setvbuf(*(FILE **)(this + 0x80),param_1,iVar1,param_2), iVar1 == 0)) {\n    _Init(this,*(_iobuf **)(this + 0x80),1);\n    return (basic_streambuf<char,struct_std::char_traits<char>_> *)this;\n  }\n  return (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0;\n}\n\n",
  "_query_new_handler": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    _query_new_handler\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nulonglong _query_new_handler(void)\n\n{\n  byte bVar1;\n  ulonglong uVar2;\n  \n  __acrt_lock(0);\n  bVar1 = (byte)DAT_140035020 & 0x3f;\n  uVar2 = DAT_140035020 ^ _DAT_1400370f8;\n  __acrt_unlock(0);\n  return uVar2 >> bVar1 | uVar2 << 0x40 - bVar1;\n}\n\n",
  "FUN_1400012b0": "\nundefined8 * FUN_1400012b0(undefined8 *param_1)\n\n{\n  param_1[2] = 0;\n  param_1[1] = \"bad array new length\";\n  *param_1 = std::bad_array_new_length::vftable;\n  return param_1;\n}\n\n",
  "FUN_1400024c0": "\nvoid FUN_1400024c0(LPVOID *param_1)\n\n{\n  LPVOID pvVar1;\n  code *pcVar2;\n  LPVOID pvVar3;\n  \n  if ((LPVOID)0xf < param_1[3]) {\n    pvVar1 = *param_1;\n    pvVar3 = pvVar1;\n    if ((0xfff < (longlong)param_1[3] + 1U) &&\n       (pvVar3 = *(LPVOID *)((longlong)pvVar1 + -8),\n       0x1f < (ulonglong)((longlong)pvVar1 + (-8 - (longlong)pvVar3)))) {\n      FUN_14000d050();\n      pcVar2 = (code *)swi(3);\n      (*pcVar2)();\n      return;\n    }\n    thunk_FUN_14000ce08(pvVar3);\n  }\n  param_1[2] = (LPVOID)0x0;\n  param_1[3] = (LPVOID)0xf;\n  *(undefined *)param_1 = 0;\n  return;\n}\n\n",
  "__pctype_func": "\n/* Library Function - Single Match\n    __pctype_func\n   \n   Library: Visual Studio 2019 Release */\n\nushort * __cdecl __pctype_func(void)\n\n{\n  longlong lVar1;\n  ushort **local_res8 [4];\n  \n  lVar1 = FUN_140014d84();\n  local_res8[0] = *(ushort ***)(lVar1 + 0x90);\n  __acrt_update_locale_info(lVar1,(longlong *)local_res8);\n  return *local_res8[0];\n}\n\n",
  "FindHandlerForForeignException<class___FrameHandler4>": "\n/* Library Function - Single Match\n    void __cdecl FindHandlerForForeignException<class __FrameHandler4>(struct EHExceptionRecord *\n   __ptr64,unsigned __int64 * __ptr64,struct _CONTEXT * __ptr64,struct _xDISPATCHER_CONTEXT *\n   __ptr64,struct FH4::FuncInfo4 * __ptr64,int,int,unsigned __int64 * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl\nFindHandlerForForeignException<class___FrameHandler4>\n          (EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n          _xDISPATCHER_CONTEXT *param_4,FuncInfo4 *param_5,int param_6,int param_7,__uint64 *param_8\n          )\n\n{\n  byte bVar1;\n  int iVar2;\n  longlong lVar3;\n  PVOID pvVar4;\n  longlong lVar5;\n  uint uVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  ulonglong uVar9;\n  undefined auStackY_178 [32];\n  uint local_118;\n  int local_f8;\n  int iStack_f4;\n  uint uStack_f0;\n  undefined4 uStack_ec;\n  int local_e8;\n  int iStack_e4;\n  uint uStack_e0;\n  undefined4 uStack_dc;\n  uint local_d0;\n  int local_c8 [2];\n  undefined8 local_c0;\n  undefined8 local_b8;\n  HandlerType4 local_b0 [4];\n  byte local_ac;\n  int local_a8;\n  int local_78 [10];\n  ulonglong local_50;\n  \n  local_50 = DAT_140035020 ^ (ulonglong)auStackY_178;\n  if (*(int *)param_1 != -0x7ffffffd) {\n    lVar3 = FUN_140008b20();\n    if (*(longlong *)(lVar3 + 0x10) != 0) {\n      pvVar4 = EncodePointer((PVOID)0x0);\n      lVar3 = FUN_140008b20();\n      if ((((*(PVOID *)(lVar3 + 0x10) != pvVar4) && (*(int *)param_1 != -0x1fbcb0b3)) &&\n          (*(int *)param_1 != -0x1fbcbcae)) &&\n         (iVar2 = _CallSETranslator<class___FrameHandler4>\n                            (param_1,param_2,param_3,param_4,param_5,param_7,param_8,param_6),\n         iVar2 != 0)) goto LAB_14000a489;\n    }\n    FH4::TryBlockMap4::TryBlockMap4((TryBlockMap4 *)local_78,param_5,*(__uint64 *)(param_4 + 8));\n    if (local_78[0] == 0) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    FUN_14000743c((undefined (*) [16])&local_e8,local_78,param_6);\n    local_f8 = local_e8;\n    iStack_f4 = iStack_e4;\n    uStack_f0 = uStack_e0;\n    uStack_ec = uStack_dc;\n    if (uStack_e0 < local_d0) {\n      lVar3 = CONCAT44(iStack_e4,local_e8);\n      local_118 = uStack_e0;\n      do {\n        local_f8 = *(int *)(lVar3 + 0x18);\n        iStack_f4 = *(int *)(lVar3 + 0x1c);\n        uStack_f0 = *(uint *)(lVar3 + 0x20);\n        uStack_ec = *(undefined4 *)(lVar3 + 0x24);\n        if ((local_f8 <= param_6) && (param_6 <= iStack_f4)) {\n          FH4::HandlerMap4::HandlerMap4\n                    ((HandlerMap4 *)local_c8,(TryBlockMapEntry4 *)&local_f8,\n                     *(__uint64 *)(param_4 + 8),**(int **)(param_4 + 0x10));\n          local_c0 = local_b8;\n          FH4::HandlerMap4::DecompHandler((HandlerMap4 *)local_c8);\n          iVar2 = local_c8[0];\n          local_c0 = local_b8;\n          FH4::HandlerMap4::DecompHandler((HandlerMap4 *)local_c8);\n          uVar9 = (ulonglong)(iVar2 - 1U);\n          if (iVar2 - 1U != 0) {\n            do {\n              FH4::HandlerMap4::DecompHandler((HandlerMap4 *)local_c8);\n              uVar9 = uVar9 - 1;\n            } while (uVar9 != 0);\n          }\n          if ((local_a8 != 0) && (lVar5 = _GetImageBase(), lVar5 + local_a8 != 0)) {\n            if (local_a8 == 0) {\n              lVar5 = 0;\n            }\n            else {\n              lVar5 = _GetImageBase();\n              lVar5 = lVar5 + local_a8;\n            }\n            if (*(char *)(lVar5 + 0x10) != '\\0') goto LAB_14000a3ef;\n          }\n          if ((local_ac & 0x40) == 0) {\n            CatchIt<class___FrameHandler4>\n                      (param_1,param_2,param_3,param_4,param_5,local_b0,(_s_CatchableType *)0x0,\n                       (TryBlockMapEntry4 *)&local_f8,param_7,param_8,'\\x01','\\0');\n          }\n        }\nLAB_14000a3ef:\n        uVar6 = **(byte **)(lVar3 + 8) & 0xf;\n        bVar1 = (&DAT_140024790)[uVar6];\n        pbVar7 = *(byte **)(lVar3 + 8) + -(longlong)(char)(&DAT_140024780)[uVar6];\n        uVar6 = *(uint *)(pbVar7 + -4);\n        *(byte **)(lVar3 + 8) = pbVar7;\n        *(uint *)(lVar3 + 0x18) = uVar6 >> (bVar1 & 0x1f);\n        bVar1 = (&DAT_140024790)[*pbVar7 & 0xf];\n        pbVar7 = pbVar7 + -(longlong)(char)(&DAT_140024780)[*pbVar7 & 0xf];\n        uVar6 = *(uint *)(pbVar7 + -4);\n        *(byte **)(lVar3 + 8) = pbVar7;\n        *(uint *)(lVar3 + 0x1c) = uVar6 >> (bVar1 & 0x1f);\n        pbVar8 = pbVar7 + -(longlong)(char)(&DAT_140024780)[*pbVar7 & 0xf];\n        *(uint *)(lVar3 + 0x20) = *(uint *)(pbVar8 + -4) >> ((&DAT_140024790)[*pbVar7 & 0xf] & 0x1f)\n        ;\n        *(byte **)(lVar3 + 8) = pbVar8;\n        *(undefined4 *)(lVar3 + 0x24) = *(undefined4 *)pbVar8;\n        local_118 = local_118 + 1;\n        *(byte **)(lVar3 + 8) = pbVar8 + 4;\n      } while (local_118 < local_d0);\n    }\n  }\nLAB_14000a489:\n  FUN_140006060(local_50 ^ (ulonglong)auStackY_178);\n  return;\n}\n\n",
  "translate_text_mode_nolock<wchar_t>": "\n/* Library Function - Single Match\n    int __cdecl translate_text_mode_nolock<wchar_t>(int,wchar_t * __ptr64 const,unsigned __int64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl translate_text_mode_nolock<wchar_t>(int param_1,wchar_t *param_2,__uint64 param_3)\n\n{\n  wchar_t *pwVar1;\n  byte *pbVar2;\n  byte bVar3;\n  wchar_t wVar4;\n  BOOL BVar5;\n  ulonglong uVar6;\n  ulonglong uVar7;\n  wchar_t wVar8;\n  longlong lVar9;\n  wchar_t *pwVar10;\n  wchar_t *pwVar11;\n  HANDLE pvVar12;\n  wchar_t *pwVar13;\n  wchar_t *pwVar14;\n  longlong lVar15;\n  short local_res8 [4];\n  short local_res10 [4];\n  DWORD local_res18 [2];\n  HANDLE local_res20;\n  \n  uVar6 = (ulonglong)(param_1 & 0x3f);\n  lVar15 = (longlong)param_1 >> 6;\n  lVar9 = (&DAT_140037490)[lVar15];\n  pvVar12 = *(HANDLE *)(lVar9 + 0x28 + uVar6 * 0x48);\n  if ((param_3 == 0) || (*param_2 != L'\\n')) {\n    pbVar2 = (byte *)(lVar9 + 0x38 + uVar6 * 0x48);\n    *pbVar2 = *pbVar2 & 0xfb;\n  }\n  else {\n    pbVar2 = (byte *)(lVar9 + 0x38 + uVar6 * 0x48);\n    *pbVar2 = *pbVar2 | 4;\n  }\n  pwVar1 = param_2 + param_3;\n  pwVar10 = param_2;\n  pwVar11 = param_2;\n  pwVar13 = param_2;\n  local_res20 = pvVar12;\n  if (param_2 < pwVar1) {\n    do {\n      wVar4 = *pwVar13;\n      pwVar11 = pwVar10;\n      if (wVar4 == L'\\x1a') {\n        bVar3 = *(byte *)((&DAT_140037490)[lVar15] + 0x38 + uVar6 * 0x48);\n        if ((bVar3 & 0x40) == 0) {\n          *(byte *)((&DAT_140037490)[lVar15] + 0x38 + uVar6 * 0x48) = bVar3 | 2;\n        }\n        else {\n          *pwVar10 = L'\\x1a';\n          pwVar11 = pwVar10 + 1;\n        }\n        break;\n      }\n      pwVar14 = pwVar13 + 1;\n      if (wVar4 == L'\\r') {\n        if (pwVar14 < pwVar1) {\n          wVar4 = *pwVar14;\n          wVar8 = L'\\r';\n          if (wVar4 == L'\\n') {\n            wVar8 = L'\\n';\n          }\n          *pwVar10 = wVar8;\n          lVar9 = 4;\n          if (wVar4 != L'\\n') {\n            lVar9 = 2;\n          }\n          pwVar14 = (wchar_t *)((longlong)pwVar13 + lVar9);\n          pwVar11 = pwVar10 + 1;\n        }\n        else {\n          BVar5 = ReadFile(pvVar12,local_res8,2,local_res18,(LPOVERLAPPED)0x0);\n          pvVar12 = local_res20;\n          if ((BVar5 == 0) || (local_res18[0] == 0)) {\n            *pwVar10 = L'\\r';\n            pwVar11 = pwVar10 + 1;\n          }\n          else {\n            uVar7 = (ulonglong)(param_1 & 0x3f);\n            if ((*(byte *)((&DAT_140037490)[lVar15] + 0x38 + uVar7 * 0x48) & 0x48) == 0) {\n              if ((local_res8[0] == 10) && (pwVar10 == param_2)) {\n                *pwVar10 = L'\\n';\n                pwVar11 = pwVar10 + 1;\n              }\n              else {\n                common_lseek_nolock<__int64>(param_1,-2,1);\n                pvVar12 = local_res20;\n                if (local_res8[0] != 10) {\n                  *pwVar10 = L'\\r';\n                  pwVar11 = pwVar10 + 1;\n                }\n              }\n            }\n            else {\n              pwVar11 = pwVar10 + 1;\n              if (local_res8[0] == 10) {\n                *pwVar10 = L'\\n';\n              }\n              else {\n                local_res10[0] = local_res8[0];\n                *pwVar10 = L'\\r';\n                lVar9 = 0;\n                do {\n                  *(undefined *)((&DAT_140037490)[lVar15] + uVar7 * 0x48 + 0x3a + lVar9) =\n                       *(undefined *)((longlong)local_res10 + lVar9);\n                  lVar9 = lVar9 + 1;\n                } while (lVar9 < 2);\n                *(undefined *)((&DAT_140037490)[lVar15] + 0x3c + uVar7 * 0x48) = 10;\n              }\n            }\n          }\n        }\n      }\n      else {\n        *pwVar10 = wVar4;\n        pwVar11 = pwVar10 + 1;\n      }\n      pwVar10 = pwVar11;\n      pwVar13 = pwVar14;\n    } while (pwVar14 < pwVar1);\n  }\n  return (int)((longlong)pwVar11 - (longlong)param_2 >> 1) * 2;\n}\n\n",
  "__acrt_uninitialize": "\n/* Library Function - Single Match\n    __acrt_uninitialize\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __acrt_uninitialize(bool param_1)\n\n{\n  int iVar1;\n  undefined8 in_RAX;\n  undefined4 extraout_var;\n  undefined8 uVar2;\n  \n  if (param_1) {\n    if (DAT_1400370e0 != 0) {\n      iVar1 = common_flush_all(param_1);\n      in_RAX = CONCAT44(extraout_var,iVar1);\n    }\n    return CONCAT71((int7)((ulonglong)in_RAX >> 8),1);\n  }\n  uVar2 = __acrt_execute_uninitializers(0x1400280f0,0x1400281f0);\n  return uVar2;\n}\n\n",
  "_write_nolock": "\n/* Library Function - Single Match\n    _write_nolock\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _write_nolock(int _FileHandle,void *_Buf,uint _MaxCharCount)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  wchar_t wVar4;\n  wint_t wVar5;\n  int iVar6;\n  BOOL BVar7;\n  DWORD DVar8;\n  ulong *puVar9;\n  ulonglong uVar10;\n  longlong lVar11;\n  undefined8 *puVar12;\n  int iVar13;\n  longlong lVar14;\n  ulonglong uVar15;\n  wchar_t *pwVar16;\n  undefined8 local_68;\n  int local_60;\n  undefined8 local_58;\n  wchar_t local_48 [8];\n  \n  uVar15 = (ulonglong)_MaxCharCount;\n  if (_MaxCharCount == 0) {\n    return 0;\n  }\n  if (_Buf == (void *)0x0) {\nLAB_140016dd2:\n    puVar9 = __doserrno();\n    *puVar9 = 0;\n    puVar9 = __doserrno();\n    *puVar9 = 0x16;\n    FUN_14000d030();\n    return -1;\n  }\n  uVar10 = (ulonglong)(_FileHandle & 0x3f);\n  lVar14 = (longlong)_FileHandle >> 6;\n  cVar1 = *(char *)((&DAT_140037490)[lVar14] + 0x39 + uVar10 * 0x48);\n  if (((byte)(cVar1 - 1U) < 2) && ((~_MaxCharCount & 1) == 0)) goto LAB_140016dd2;\n  if ((*(byte *)((&DAT_140037490)[lVar14] + 0x38 + uVar10 * 0x48) & 0x20) != 0) {\n    common_lseek_nolock<__int64>(_FileHandle,0,2);\n  }\n  local_58 = 0;\n  iVar6 = _isatty(_FileHandle);\n  iVar13 = 0;\n  if ((((iVar6 == 0) || (-1 < *(char *)((&DAT_140037490)[lVar14] + 0x38 + uVar10 * 0x48))) ||\n      ((lVar11 = FUN_140014d84(), *(longlong *)(*(longlong *)(lVar11 + 0x90) + 0x138) == 0 &&\n       (*(char *)((&DAT_140037490)[lVar14] + 0x39 + uVar10 * 0x48) == '\\0')))) ||\n     (BVar7 = GetConsoleMode(*(HANDLE *)((&DAT_140037490)[lVar14] + 0x28 + uVar10 * 0x48),\n                             (LPDWORD)local_48), BVar7 == 0)) {\n    if (-1 < *(char *)((&DAT_140037490)[lVar14] + 0x38 + uVar10 * 0x48)) {\n      local_68 = 0;\n      local_60 = 0;\n      BVar7 = WriteFile(*(HANDLE *)((&DAT_140037490)[lVar14] + 0x28 + uVar10 * 0x48),_Buf,\n                        _MaxCharCount,(LPDWORD)((longlong)&local_68 + 4),(LPOVERLAPPED)0x0);\n      iVar13 = local_60;\n      uVar3 = local_68;\n      if (BVar7 == 0) {\n        DVar8 = GetLastError();\n        local_68 = CONCAT44(local_68._4_4_,DVar8);\n        iVar13 = local_60;\n        uVar3 = local_68;\n      }\n      goto LAB_140016ff0;\n    }\n    if (cVar1 == '\\0') {\n      puVar12 = (undefined8 *)write_text_ansi_nolock(&local_68,_FileHandle,_Buf,uVar15);\n    }\n    else if (cVar1 == '\\x01') {\n      puVar12 = (undefined8 *)write_text_utf8_nolock(&local_68,_FileHandle,_Buf,uVar15);\n    }\n    else {\n      uVar3 = local_58;\n      if (cVar1 != '\\x02') goto LAB_140016ff0;\n      puVar12 = (undefined8 *)write_text_utf16le_nolock(&local_68,_FileHandle,_Buf,uVar15);\n    }\n  }\n  else {\n    if (cVar1 != '\\0') {\n      uVar3 = local_58;\n      if ((byte)(cVar1 - 1U) < 2) {\n        iVar13 = 0;\n        local_68 = 0;\n        uVar3 = local_68;\n        if (_Buf < (wchar_t *)((longlong)_Buf + uVar15)) {\n          local_68._4_4_ = 0;\n          pwVar16 = (wchar_t *)_Buf;\n          iVar6 = local_68._4_4_;\n          do {\n            local_48[0] = *pwVar16;\n            wVar4 = _putwch_nolock(local_48[0]);\n            if (wVar4 != local_48[0]) {\nLAB_140016f24:\n              DVar8 = GetLastError();\n              local_68 = CONCAT44(local_68._4_4_,DVar8);\n              uVar3 = local_68;\n              break;\n            }\n            local_68 = CONCAT44(iVar6 + 2,(undefined4)local_68);\n            iVar2 = iVar6 + 2;\n            if (local_48[0] == L'\\n') {\n              wVar5 = _putwch_nolock(L'\\r');\n              if (wVar5 != 0xd) goto LAB_140016f24;\n              local_68 = CONCAT44(iVar6 + 3,(undefined4)local_68);\n              iVar13 = iVar13 + 1;\n              iVar2 = iVar6 + 3;\n            }\n            iVar6 = iVar2;\n            pwVar16 = pwVar16 + 1;\n            uVar3 = local_68;\n          } while (pwVar16 < (wchar_t *)((longlong)_Buf + uVar15));\n        }\n      }\n      goto LAB_140016ff0;\n    }\n    puVar12 = (undefined8 *)write_double_translated_ansi_nolock(&local_68,_FileHandle,_Buf,uVar15);\n  }\n  iVar13 = *(int *)(puVar12 + 1);\n  uVar3 = *puVar12;\nLAB_140016ff0:\n  local_58 = uVar3;\n  iVar6 = (int)((ulonglong)local_58 >> 0x20);\n  if (iVar6 != 0) {\n    return iVar6 - iVar13;\n  }\n  if ((int)local_58 != 0) {\n    if ((int)local_58 == 5) {\n      puVar9 = __doserrno();\n      *puVar9 = 9;\n      puVar9 = __doserrno();\n      *puVar9 = 5;\n      return -1;\n    }\n    __acrt_errno_map_os_error((int)local_58);\n    return -1;\n  }\n                    /* WARNING: Load size is inaccurate */\n  if (((*(byte *)((&DAT_140037490)[lVar14] + 0x38 + uVar10 * 0x48) & 0x40) != 0) &&\n     (*_Buf == '\\x1a')) {\n    return 0;\n  }\n  puVar9 = __doserrno();\n  *puVar9 = 0x1c;\n  puVar9 = __doserrno();\n  *puVar9 = 0;\n  return -1;\n}\n\n",
  "__vcrt_uninitialize": "\n/* Library Function - Single Match\n    __vcrt_uninitialize\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __vcrt_uninitialize(char param_1)\n\n{\n  undefined8 in_RAX;\n  \n  if (param_1 == '\\0') {\n    __vcrt_uninitialize_ptd();\n    in_RAX = __vcrt_uninitialize_locks();\n  }\n  return CONCAT71((int7)((ulonglong)in_RAX >> 8),1);\n}\n\n",
  "FUN_1400038f4": "\nundefined8 * FUN_1400038f4(undefined8 *param_1,char *param_2)\n\n{\n  char *local_18;\n  undefined local_10;\n  \n  local_10 = 1;\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  local_18 = param_2;\n  __std_exception_copy(&local_18,(char **)(param_1 + 1));\n  *param_1 = std::length_error::vftable;\n  return param_1;\n}\n\n",
  "initialize_inherited_file_handles_nolock": "\n/* Library Function - Single Match\n    void __cdecl initialize_inherited_file_handles_nolock(void)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl initialize_inherited_file_handles_nolock(void)\n\n{\n  longlong lVar1;\n  DWORD DVar2;\n  ulonglong uVar3;\n  HANDLE *ppvVar4;\n  longlong lVar5;\n  uint *puVar6;\n  uint uVar7;\n  ulonglong uVar8;\n  _STARTUPINFOW local_78;\n  \n  GetStartupInfoW(&local_78);\n  lVar5 = 0;\n  if ((local_78.cbReserved2 != 0) && ((uint *)local_78.lpReserved2 != (uint *)0x0)) {\n    puVar6 = (uint *)((longlong)local_78.lpReserved2 + 4);\n    ppvVar4 = (HANDLE *)((longlong)(int)*(uint *)local_78.lpReserved2 + (longlong)puVar6);\n    uVar7 = 0x2000;\n    if ((int)*(uint *)local_78.lpReserved2 < 0x2000) {\n      uVar7 = *(uint *)local_78.lpReserved2;\n    }\n    __acrt_lowio_ensure_fh_exists(uVar7);\n    if ((int)DAT_140037890 < (int)uVar7) {\n      uVar7 = DAT_140037890;\n    }\n    uVar8 = (ulonglong)uVar7;\n    if (uVar7 != 0) {\n      do {\n        if ((((*ppvVar4 != (HANDLE)0xffffffffffffffff) && (*ppvVar4 != (HANDLE)0xfffffffffffffffe))\n            && ((*(byte *)puVar6 & 1) != 0)) &&\n           (((*(byte *)puVar6 & 8) != 0 || (DVar2 = GetFileType(*ppvVar4), DVar2 != 0)))) {\n          uVar3 = (ulonglong)((uint)lVar5 & 0x3f);\n          lVar1 = (&DAT_140037490)[lVar5 >> 6];\n          *(HANDLE *)(lVar1 + 0x28 + uVar3 * 0x48) = *ppvVar4;\n          *(byte *)(lVar1 + 0x38 + uVar3 * 0x48) = *(byte *)puVar6;\n        }\n        lVar5 = lVar5 + 1;\n        puVar6 = (uint *)((longlong)puVar6 + 1);\n        ppvVar4 = ppvVar4 + 1;\n        uVar8 = uVar8 - 1;\n      } while (uVar8 != 0);\n    }\n  }\n  return;\n}\n\n",
  "use_facet<class_std::codecvt<char,char,struct__Mbstatet>_>": "\n/* Library Function - Single Match\n    class std::codecvt<char,char,struct _Mbstatet> const & __ptr64 __cdecl std::use_facet<class\n   std::codecvt<char,char,struct _Mbstatet> >(class std::locale const & __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\ncodecvt<char,char,struct__Mbstatet> * __cdecl\nstd::use_facet<class_std::codecvt<char,char,struct__Mbstatet>_>(locale *param_1)\n\n{\n  ulonglong uVar1;\n  longlong lVar2;\n  __uint64 _Var3;\n  codecvt<char,char,struct__Mbstatet> *pcVar4;\n  codecvt<char,char,struct__Mbstatet> *pcVar5;\n  char in_R8B;\n  int in_R9D;\n  _Facet_base *local_res8;\n  _Lockit local_res10 [8];\n  codecvt<char,char,struct__Mbstatet> *local_res18;\n  \n  _Lockit::_Lockit(local_res10,0);\n  pcVar4 = DAT_140036378;\n  local_res18 = DAT_140036378;\n  if (DAT_140036368 == 0) {\n    _Lockit::_Lockit((_Lockit *)&local_res8,0);\n    if (DAT_140036368 == 0) {\n      DAT_140036380 = DAT_140036380 + 1;\n      DAT_140036368 = (ulonglong)DAT_140036380;\n    }\n    _Lockit::~_Lockit((_Lockit *)&local_res8);\n  }\n  uVar1 = DAT_140036368;\n  lVar2 = *(longlong *)(param_1 + 8);\n  if (DAT_140036368 < *(ulonglong *)(lVar2 + 0x18)) {\n    pcVar5 = *(codecvt<char,char,struct__Mbstatet> **)\n              (*(longlong *)(lVar2 + 0x10) + DAT_140036368 * 8);\n    if (pcVar5 != (codecvt<char,char,struct__Mbstatet> *)0x0) goto LAB_140003d04;\n  }\n  else {\n    pcVar5 = (codecvt<char,char,struct__Mbstatet> *)0x0;\n  }\n  if (*(char *)(lVar2 + 0x24) == '\\0') {\nLAB_140003cb9:\n    if (pcVar5 != (codecvt<char,char,struct__Mbstatet> *)0x0) goto LAB_140003d04;\n  }\n  else {\n    lVar2 = FUN_14000543c();\n    if (uVar1 < *(ulonglong *)(lVar2 + 0x18)) {\n      pcVar5 = *(codecvt<char,char,struct__Mbstatet> **)(*(longlong *)(lVar2 + 0x10) + uVar1 * 8);\n      goto LAB_140003cb9;\n    }\n  }\n  pcVar5 = pcVar4;\n  if (pcVar4 == (codecvt<char,char,struct__Mbstatet> *)0x0) {\n    pcVar4 = (codecvt<char,char,struct__Mbstatet> *)&local_res18;\n    _Var3 = codecvt<char,char,struct__Mbstatet>::_Getcat((facet **)pcVar4,param_1);\n    pcVar5 = local_res18;\n    if (_Var3 == 0xffffffffffffffff) {\n      FUN_1400018c0();\n      if (in_R9D != 0) {\n        *(facet **)pcVar4 = (facet *)&DAT_1400236c8;\n        *(facet **)(pcVar4 + 0x18) = (facet *)0x0;\n        *(facet **)(pcVar4 + 0x40) = (facet *)0x0;\n        *(facet **)(pcVar4 + 0x48) = (facet *)0x0;\n        *(facet **)(pcVar4 + 0x50) = (facet *)0x0;\n        *(undefined ***)(pcVar4 + 0x10) = basic_ios<char,struct_std::char_traits<char>_>::vftable;\n      }\n      *(undefined ***)(pcVar4 + *(int *)(*(facet **)pcVar4 + 4)) =\n           basic_ostream<char,struct_std::char_traits<char>_>::vftable;\n      *(int *)(pcVar4 + (longlong)*(int *)(*(facet **)pcVar4 + 4) + -4) =\n           *(int *)(*(facet **)pcVar4 + 4) + -0x10;\n      FUN_1400045ec((ios_base *)(pcVar4 + *(int *)(*(facet **)pcVar4 + 4)),param_1,in_R8B);\n      return pcVar4;\n    }\n    local_res8 = (_Facet_base *)local_res18;\n    _Facet_Register((_Facet_base *)local_res18);\n    (*(code *)PTR__guard_dispatch_icall_140023298)(pcVar5);\n    DAT_140036378 = pcVar5;\n  }\nLAB_140003d04:\n  _Lockit::~_Lockit(local_res10);\n  return pcVar5;\n}\n\n",
  "FUN_1400049e4": "\nundefined8 * FUN_1400049e4(undefined8 param_1,undefined8 *param_2)\n\n{\n  *param_2 = 0xffffffffffffffff;\n  param_2[1] = 0;\n  param_2[2] = 0;\n  return param_2;\n}\n\n",
  "operator()": "\n/* Library Function - Single Match\n    public: unsigned __int64 __cdecl\n   <lambda_5856287d7ecd2be6c9197bb4007c3f6e>::operator()(void)const __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\n__uint64 __thiscall\n<lambda_5856287d7ecd2be6c9197bb4007c3f6e>::operator()\n          (<lambda_5856287d7ecd2be6c9197bb4007c3f6e> *this)\n\n{\n  FILE *pFVar1;\n  ulonglong uVar2;\n  size_t sVar3;\n  \n  pFVar1 = **(FILE ***)this;\n  uVar2 = __acrt_stdio_begin_temporary_buffering_nolock(pFVar1);\n  sVar3 = _fwrite_nolock(**(void ***)(this + 8),**(size_t **)(this + 0x10),\n                         **(size_t **)(this + 0x18),**(FILE ***)this);\n  __acrt_stdio_end_temporary_buffering_nolock((char)uVar2,pFVar1);\n  return sVar3;\n}\n\n",
  "isupper": "\n/* Library Function - Single Match\n    isupper\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl isupper(int _C)\n\n{\n  uint uVar1;\n  longlong local_28;\n  localeinfo_struct local_20;\n  char local_10;\n  \n  uVar1 = 0;\n  if (DAT_140037280 == 0) {\n    if (_C + 1U < 0x101) {\n      uVar1 = *(ushort *)(PTR_DAT_140035260 + (longlong)_C * 2) & 1;\n    }\n  }\n  else {\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,(__crt_locale_pointers *)0x0);\n    uVar1 = _ischartype_l(_C,1,&local_20);\n    if (local_10 != '\\0') {\n      *(uint *)(local_28 + 0x3a8) = *(uint *)(local_28 + 0x3a8) & 0xfffffffd;\n    }\n  }\n  return uVar1;\n}\n\n",
  "__acrt_uninitialize_locks": "\n/* Library Function - Single Match\n    __acrt_uninitialize_locks\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 __acrt_uninitialize_locks(void)\n\n{\n  undefined8 in_RAX;\n  undefined8 extraout_RAX;\n  ulonglong uVar1;\n  \n  uVar1 = (ulonglong)DAT_1400370d0;\n  while ((int)uVar1 != 0) {\n    uVar1 = (ulonglong)((int)uVar1 - 1);\n    DeleteCriticalSection((LPCRITICAL_SECTION)(&DAT_140036ea0 + uVar1 * 0x28));\n    DAT_1400370d0 = DAT_1400370d0 - 1;\n    in_RAX = extraout_RAX;\n  }\n  return CONCAT71((int7)((ulonglong)in_RAX >> 8),1);\n}\n\n",
  "write_double_translated_ansi_nolock": "\n/* Library Function - Single Match\n    struct `anonymous namespace'::write_result __cdecl write_double_translated_ansi_nolock(int,char\n   const * __ptr64 const,unsigned int)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl\nwrite_double_translated_ansi_nolock\n          (undefined8 *param_1,uint param_2,byte *param_3,ulonglong param_4)\n\n{\n  byte bVar1;\n  char cVar2;\n  BOOL BVar3;\n  DWORD DVar4;\n  ulonglong uVar5;\n  __uint64 _Var6;\n  ushort *puVar7;\n  longlong lVar8;\n  uint uVar9;\n  ulonglong uVar10;\n  longlong lVar11;\n  byte *pbVar12;\n  int iVar13;\n  ulonglong uVar14;\n  longlong lVar15;\n  size_t sVar16;\n  ulonglong uVar17;\n  longlong lVar18;\n  int iVar19;\n  byte *pbVar20;\n  bool bVar21;\n  undefined auStackY_138 [32];\n  undefined2 local_f8 [2];\n  wchar_t local_f4 [2];\n  uint local_f0 [2];\n  longlong local_e8;\n  longlong local_e0;\n  char local_d0;\n  undefined8 local_c8;\n  UINT local_b8;\n  int local_b4;\n  ulonglong local_b0;\n  byte *local_a8;\n  HANDLE local_a0;\n  undefined8 local_98;\n  char *local_90;\n  undefined8 local_88;\n  byte *local_80;\n  byte *local_78;\n  longlong local_70;\n  longlong local_68;\n  undefined8 *local_60;\n  char local_58 [8];\n  byte local_50;\n  byte local_4f;\n  CHAR local_48 [8];\n  ulonglong local_40;\n  \n  local_40 = DAT_140035020 ^ (ulonglong)auStackY_138;\n  local_68 = (longlong)(int)param_2;\n  uVar5 = (ulonglong)(param_2 & 0x3f);\n  pbVar20 = param_3 + (param_4 & 0xffffffff);\n  lVar18 = local_68 >> 6;\n  local_a0 = *(HANDLE *)((&DAT_140037490)[lVar18] + 0x28 + uVar5 * 0x48);\n  local_a8 = pbVar20;\n  local_78 = param_3;\n  local_60 = param_1;\n  local_b8 = GetConsoleCP();\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_e8,(__crt_locale_pointers *)0x0);\n  local_b0 = 0;\n  local_c8 = 0;\n  local_b4 = *(int *)(local_e0 + 0xc);\n  if (param_3 < pbVar20) {\n    local_c8._4_4_ = 0;\n    iVar13 = local_c8._4_4_;\n    local_70 = lVar18;\n    do {\n      uVar17 = 0;\n      uVar9 = 1;\n      local_f8[0] = CONCAT11(local_f8[0]._1_1_,*param_3);\n      local_f4[0] = L'\\0';\n      local_f4[1] = L'\\0';\n      if (local_b4 == 0xfde9) {\n        lVar11 = (&DAT_140037490)[local_70];\n        uVar10 = uVar17;\n        uVar14 = uVar17;\n        do {\n          uVar9 = (uint)uVar10;\n          if (*(char *)(lVar11 + uVar5 * 0x48 + 0x3e + uVar14) == '\\0') break;\n          uVar9 = uVar9 + 1;\n          uVar10 = (ulonglong)uVar9;\n          uVar14 = uVar14 + 1;\n        } while ((longlong)uVar14 < 5);\n        if ((longlong)uVar14 < 1) {\n          lVar11 = (longlong)pbVar20 - (longlong)param_3;\n          cVar2 = (&DAT_140035420)[*param_3];\n          iVar19 = cVar2 + 1;\n          if (iVar19 <= lVar11) {\n            local_88 = 0;\n            uVar9 = (iVar19 == 4) + 1;\n            local_80 = param_3;\n            _Var6 = __crt_mbstring::__mbsrtowcs_utf8\n                              (local_f4,(char **)&local_80,(ulonglong)uVar9,(_Mbstatet *)&local_88);\n            if (_Var6 != 0xffffffffffffffff) {\n              param_3 = param_3 + cVar2;\n              goto LAB_14001671f;\n            }\n            goto LAB_14001690e;\n          }\n          if (0 < lVar11) {\n            uVar5 = uVar17;\n            do {\n              pbVar20 = param_3 + uVar17;\n              uVar9 = (int)uVar5 + 1;\n              uVar5 = (ulonglong)uVar9;\n              lVar18 = (&DAT_140037490)[local_68 >> 6] + uVar17;\n              uVar17 = uVar17 + 1;\n              *(byte *)(lVar18 + 0x3e + (ulonglong)((uint)local_68 & 0x3f) * 0x48) = *pbVar20;\n            } while ((int)uVar9 < lVar11);\n          }\n          iVar13 = iVar13 + (int)lVar11;\nLAB_140016833:\n          local_c8 = CONCAT44(iVar13,(undefined4)local_c8);\n          break;\n        }\n        lVar15 = (longlong)local_a8 - (longlong)param_3;\n        cVar2 = (&DAT_140035420)[*(byte *)((&DAT_140037490)[lVar18] + 0x3e + uVar5 * 0x48)];\n        iVar19 = (cVar2 + 1) - uVar9;\n        if (lVar15 < iVar19) {\n          if (0 < lVar15) {\n            uVar10 = uVar14;\n            do {\n              lVar11 = uVar10 - uVar14;\n              uVar9 = (int)uVar17 + 1;\n              uVar17 = (ulonglong)uVar9;\n              lVar8 = (&DAT_140037490)[lVar18] + uVar10;\n              uVar10 = uVar10 + 1;\n              *(byte *)(lVar8 + 0x3e + uVar5 * 0x48) = param_3[lVar11];\n            } while ((int)uVar9 < lVar15);\n            iVar13 = local_c8._4_4_;\n          }\n          iVar13 = iVar13 + (int)lVar15;\n          goto LAB_140016833;\n        }\n        if (0 < (longlong)uVar14) {\n          do {\n            uVar10 = uVar17 + 1;\n            local_58[uVar17] = *(char *)(uVar17 + lVar11 + 0x3e + uVar5 * 0x48);\n            uVar17 = uVar10;\n          } while ((longlong)uVar10 < (longlong)uVar14);\n        }\n        if (0 < iVar19) {\n          FUN_140007ed0((undefined8 *)(local_58 + uVar14),(undefined8 *)param_3,(longlong)iVar19);\n        }\n        lVar11 = 0;\n        if (0 < (longlong)uVar14) {\n          do {\n            lVar15 = (&DAT_140037490)[lVar18] + lVar11;\n            lVar11 = lVar11 + 1;\n            *(undefined *)(lVar15 + 0x3e + uVar5 * 0x48) = 0;\n          } while (lVar11 < (longlong)uVar14);\n        }\n        local_90 = local_58;\n        local_98 = 0;\n        uVar9 = (cVar2 + 1 == 4) + 1;\n        _Var6 = __crt_mbstring::__mbsrtowcs_utf8\n                          (local_f4,&local_90,(ulonglong)uVar9,(_Mbstatet *)&local_98);\n        if (_Var6 != 0xffffffffffffffff) {\n          param_3 = param_3 + (iVar19 + -1);\n          pbVar20 = local_a8;\n          goto LAB_14001671f;\n        }\nLAB_14001690e:\n        bVar21 = local_d0 == '\\0';\n        goto LAB_14001683a;\n      }\n      lVar11 = (&DAT_140037490)[lVar18];\n      bVar1 = *(byte *)(lVar11 + 0x3d + uVar5 * 0x48);\n      if ((bVar1 & 4) == 0) {\n        puVar7 = __pctype_func();\n        pbVar12 = param_3;\n        if ((short)puVar7[*param_3] < 0) {\n          if (pbVar20 <= param_3 + 1) {\n            local_c8 = CONCAT44(iVar13 + 1,(undefined4)local_c8);\n            *(byte *)((&DAT_140037490)[lVar18] + 0x3e + uVar5 * 0x48) = *param_3;\n            pbVar20 = (byte *)((&DAT_140037490)[lVar18] + 0x3d + uVar5 * 0x48);\n            *pbVar20 = *pbVar20 | 4;\n            bVar21 = local_d0 == '\\0';\n            goto LAB_14001683a;\n          }\n          sVar16 = 2;\n          param_3 = param_3 + 1;\n        }\n        else {\n          sVar16 = 1;\n        }\n      }\n      else {\n        local_50 = *(byte *)(lVar11 + 0x3e + uVar5 * 0x48);\n        sVar16 = 2;\n        local_4f = *param_3;\n        *(byte *)(lVar11 + 0x3d + uVar5 * 0x48) = bVar1 & 0xfb;\n        pbVar12 = &local_50;\n      }\n      iVar13 = FUN_14001a1cc(local_f4,(char *)pbVar12,sVar16);\n      if (iVar13 == -1) goto LAB_14001690e;\nLAB_14001671f:\n      param_3 = param_3 + 1;\n      uVar9 = __acrt_WideCharToMultiByte\n                        (local_b8,0,local_f4,uVar9,local_48,5,(LPBOOL)0x0,(LPBOOL)0x0);\n      if (uVar9 == 0) {\nLAB_140016920:\n        bVar21 = local_d0 == '\\0';\n        goto LAB_14001683a;\n      }\n      BVar3 = WriteFile(local_a0,local_48,uVar9,local_f0,(LPOVERLAPPED)0x0);\n      if (BVar3 == 0) {\n        DVar4 = GetLastError();\n        local_c8 = CONCAT44(local_c8._4_4_,DVar4);\n        goto LAB_140016920;\n      }\n      iVar19 = (int)local_b0;\n      iVar13 = ((int)param_3 - (int)local_78) + iVar19;\n      local_c8 = CONCAT44(iVar13,(undefined4)local_c8);\n      if (local_f0[0] < uVar9) break;\n      if ((char)local_f8[0] != '\\n') goto LAB_1400167e7;\n      local_f8[0] = 0xd;\n      BVar3 = WriteFile(local_a0,local_f8,1,local_f0,(LPOVERLAPPED)0x0);\n      if (BVar3 == 0) {\n        DVar4 = GetLastError();\n        local_c8 = CONCAT44(local_c8._4_4_,DVar4);\n        goto LAB_14001690e;\n      }\n      if (local_f0[0] == 0) break;\n      local_b0 = (ulonglong)(iVar19 + 1);\n      iVar13 = iVar13 + 1;\n      local_c8 = CONCAT44(iVar13,(undefined4)local_c8);\nLAB_1400167e7:\n    } while (param_3 < pbVar20);\n  }\n  bVar21 = local_d0 == '\\0';\nLAB_14001683a:\n  if (!bVar21) {\n    *(uint *)(local_e8 + 0x3a8) = *(uint *)(local_e8 + 0x3a8) & 0xfffffffd;\n  }\n  *local_60 = local_c8;\n  *(int *)(local_60 + 1) = (int)local_b0;\n  FUN_140006060(local_40 ^ (ulonglong)auStackY_138);\n  return;\n}\n\n",
  "_Setgloballocale": "\n/* Library Function - Single Match\n    private: static void __cdecl std::locale::_Setgloballocale(void * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl std::locale::_Setgloballocale(void *param_1)\n\n{\n  if (DAT_1400363e0 == '\\0') {\n    DAT_1400363e0 = '\\x01';\n    FUN_140005d08(&LAB_1400056e0);\n  }\n  DAT_1400363d8 = param_1;\n  return;\n}\n\n",
  "__acrt_FlsGetValue": "\n/* WARNING: Switch with 1 destination removed at 0x00014001578b */\n/* Library Function - Single Match\n    __acrt_FlsGetValue\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_FlsGetValue(undefined4 param_1)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  \n  UNRECOVERED_JUMPTABLE =\n       (code *)try_get_function(5,\"FlsGetValue\",(module_id *)&DAT_140028dd8,\n                                (module_id *)&DAT_140028de0);\n  if (UNRECOVERED_JUMPTABLE == (code *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x000140015797. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    TlsGetValue(param_1);\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x000140021e60. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
  "__mbrtowc_utf8": "\n/* Library Function - Single Match\n    unsigned __int64 __cdecl __crt_mbstring::__mbrtowc_utf8(wchar_t * __ptr64,char const *\n   __ptr64,unsigned __int64,struct _Mbstatet * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\n__uint64 __cdecl\n__crt_mbstring::__mbrtowc_utf8(wchar_t *param_1,char *param_2,__uint64 param_3,_Mbstatet *param_4)\n\n{\n  __uint64 _Var1;\n  wchar32 local_18 [4];\n  \n  _Var1 = __mbrtoc32_utf8(local_18,param_2,param_3,param_4);\n  if (_Var1 < 5) {\n    if (0xffff < (uint)local_18[0]) {\n      local_18[0] = L'�';\n    }\n    if (param_1 != (wchar_t *)0x0) {\n      *param_1 = (wchar_t)local_18[0];\n    }\n  }\n  return _Var1;\n}\n\n",
  "__c32rtomb_utf8": "\n/* Library Function - Single Match\n    unsigned __int64 __cdecl __crt_mbstring::__c32rtomb_utf8(char * __ptr64,char32_t,struct\n   _Mbstatet * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\n__uint64 __cdecl __crt_mbstring::__c32rtomb_utf8(char *param_1,wchar32 param_2,_Mbstatet *param_3)\n\n{\n  byte bVar1;\n  ulong *puVar2;\n  longlong lVar3;\n  longlong lVar4;\n  byte bVar5;\n  \n  if (param_1 != (char *)0x0) {\n    if (param_2 != L'\\0') {\n      if ((param_2 & 0xffffff80U) == 0) {\n        *param_1 = (char)param_2;\n        return 1;\n      }\n      if ((param_2 & 0xfffff800U) == 0) {\n        lVar3 = 1;\n        bVar5 = 0xc0;\n        lVar4 = lVar3;\n      }\n      else if ((param_2 & 0xffff0000U) == 0) {\n        if ((uint)(param_2 + L'\\xffff2800') < 0x800) {\nLAB_14001f78b:\n          *(undefined8 *)param_3 = 0;\n          puVar2 = __doserrno();\n          *puVar2 = 0x2a;\n          return 0xffffffffffffffff;\n        }\n        lVar3 = 2;\n        bVar5 = 0xe0;\n        lVar4 = lVar3;\n      }\n      else {\n        if (((param_2 & 0xffe00000U) != 0) || (0x10ffff < (uint)param_2)) goto LAB_14001f78b;\n        lVar3 = 3;\n        bVar5 = 0xf0;\n        lVar4 = lVar3;\n      }\n      do {\n        bVar1 = (byte)param_2;\n        param_2 = (uint)param_2 >> 6;\n        param_1[lVar3] = bVar1 & 0x3f | 0x80;\n        lVar3 = lVar3 + -1;\n      } while (lVar3 != 0);\n      *param_1 = (byte)param_2 | bVar5;\n      *(undefined8 *)param_3 = 0;\n      return lVar4 + 1;\n    }\n    *param_1 = (char)param_2;\n  }\n  *(undefined8 *)param_3 = 0;\n  return 1;\n}\n\n",
  "FUN_140004b58": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid FUN_140004b58(longlong param_1)\n\n{\n  undefined *puVar1;\n  undefined8 uVar2;\n  code *pcVar3;\n  int iVar4;\n  undefined8 *******pppppppuVar5;\n  FILE *_File;\n  longlong *plVar6;\n  longlong lVar7;\n  ulonglong uVar8;\n  undefined auStack_98 [32];\n  longlong *local_78;\n  undefined *local_70;\n  undefined *local_68;\n  undefined **local_60;\n  undefined local_48;\n  undefined local_47 [7];\n  longlong local_40;\n  undefined *local_38;\n  undefined8 *******local_30 [2];\n  ulonglong local_20;\n  ulonglong local_18;\n  ulonglong local_10;\n  \n  local_10 = DAT_140035020 ^ (ulonglong)auStack_98;\n  uVar8 = **(ulonglong **)(param_1 + 0x38);\n  if (uVar8 != 0) {\n    iVar4 = **(int **)(param_1 + 0x50);\n    if (uVar8 < uVar8 + (longlong)iVar4) {\n      **(int **)(param_1 + 0x50) = iVar4 + -1;\n      **(longlong **)(param_1 + 0x38) = **(longlong **)(param_1 + 0x38) + 1;\n      goto LAB_140004de4;\n    }\n  }\n  _File = *(FILE **)(param_1 + 0x80);\n  if (_File != (FILE *)0x0) {\n    plVar6 = *(longlong **)(param_1 + 0x18);\n    if (*plVar6 == param_1 + 0x70) {\n      uVar2 = *(undefined8 *)(param_1 + 0x90);\n      lVar7 = *(longlong *)(param_1 + 0x88);\n      *plVar6 = lVar7;\n      **(longlong **)(param_1 + 0x38) = lVar7;\n      **(int **)(param_1 + 0x50) = (int)uVar2 - (int)lVar7;\n      _File = *(FILE **)(param_1 + 0x80);\n    }\n    if (*(longlong *)(param_1 + 0x68) != 0) {\n      local_20 = 0;\n      local_18 = 0xf;\n      local_30[0] = (undefined8 *******)0x0;\n      iVar4 = fgetc(_File);\n      do {\n        uVar8 = local_20;\n        if (iVar4 == -1) goto LAB_140004dab;\n        if (local_20 < local_18) {\n          pppppppuVar5 = local_30;\n          if (0xf < local_18) {\n            pppppppuVar5 = local_30[0];\n          }\n          puVar1 = (undefined *)((longlong)pppppppuVar5 + local_20);\n          local_20 = local_20 + 1;\n          *puVar1 = (char)iVar4;\n          *(undefined *)((longlong)pppppppuVar5 + uVar8 + 1) = 0;\n        }\n        else {\n          FUN_140003ad4(local_30,1,CONCAT71((int7)((ulonglong)plVar6 >> 8),local_47[0]),(char)iVar4)\n          ;\n        }\n        if (local_18 < 0x10) {\n          lVar7 = (longlong)local_30 + local_20;\n          pppppppuVar5 = local_30;\n          if (local_18 >= 0x10) goto LAB_140004cb4;\n        }\n        else {\n          lVar7 = local_20 + (longlong)local_30[0];\nLAB_140004cb4:\n          pppppppuVar5 = local_30[0];\n        }\n        local_60 = &local_38;\n        local_68 = local_47;\n        local_70 = &local_48;\n        local_78 = &local_40;\n        iVar4 = (*(code *)PTR__guard_dispatch_icall_140023298)\n                          (*(undefined8 *)(param_1 + 0x68),param_1 + 0x74,pppppppuVar5,lVar7);\n        if ((iVar4 != 0) && (iVar4 != 1)) goto LAB_140004dab;\n        if (local_38 != &local_48) {\n          pppppppuVar5 = local_30;\n          if (0xf < local_18) {\n            pppppppuVar5 = local_30[0];\n          }\n          lVar7 = (local_20 - local_40) + (longlong)pppppppuVar5;\n          while (0 < lVar7) {\n            lVar7 = lVar7 + -1;\n            ungetc((int)*(char *)(lVar7 + local_40),*(FILE **)(param_1 + 0x80));\n          }\nLAB_140004dab:\n          if (0xf < local_18) {\n            pppppppuVar5 = local_30[0];\n            if ((0xfff < local_18 + 1) &&\n               (pppppppuVar5 = (undefined8 *******)local_30[0][-1],\n               0x1f < (ulonglong)((longlong)local_30[0] + (-8 - (longlong)pppppppuVar5)))) {\n              FUN_14000d050();\n              pcVar3 = (code *)swi(3);\n              (*pcVar3)();\n              return;\n            }\n            thunk_FUN_14000ce08(pppppppuVar5);\n          }\n          goto LAB_140004de4;\n        }\n        pppppppuVar5 = local_30;\n        if (0xf < local_18) {\n          pppppppuVar5 = local_30[0];\n        }\n        uVar8 = local_40 - (longlong)pppppppuVar5;\n        if (local_20 < (ulonglong)(local_40 - (longlong)pppppppuVar5)) {\n          uVar8 = local_20;\n        }\n        pppppppuVar5 = local_30;\n        if (0xf < local_18) {\n          pppppppuVar5 = local_30[0];\n        }\n        local_20 = local_20 - uVar8;\n        plVar6 = (longlong *)(local_20 + 1);\n        FUN_140007ed0(pppppppuVar5,(undefined8 *)((longlong)pppppppuVar5 + uVar8),(ulonglong)plVar6)\n        ;\n        iVar4 = fgetc(*(FILE **)(param_1 + 0x80));\n      } while( true );\n    }\n    fgetc(_File);\n  }\nLAB_140004de4:\n  FUN_140006060(local_10 ^ (ulonglong)auStack_98);\n  return;\n}\n\n",
  "__acrt_CompareStringEx": "\n/* Library Function - Single Match\n    __acrt_CompareStringEx\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_CompareStringEx\n               (ushort *param_1,DWORD param_2,PCNZWCH param_3,int param_4,PCNZWCH param_5,\n               int param_6,undefined8 param_7,undefined8 param_8,undefined8 param_9)\n\n{\n  LCID Locale;\n  void *pvVar1;\n  \n  pvVar1 = try_get_function(1,\"CompareStringEx\",(module_id *)&DAT_140028d90,\n                            (module_id *)\"CompareStringEx\");\n  if (pvVar1 == (void *)0x0) {\n    Locale = __acrt_LocaleNameToLCID(param_1,0);\n    CompareStringW(Locale,param_2,param_3,param_4,param_5,param_6);\n  }\n  else {\n    (*(code *)PTR__guard_dispatch_icall_140023298)\n              (param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);\n  }\n  return;\n}\n\n",
  "FUN_140003a68": "\nvoid FUN_140003a68(char *param_1)\n\n{\n  undefined8 local_28 [5];\n  \n  FUN_1400038f4(local_28,param_1);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_28,(ThrowInfo *)&DAT_140033a58);\n}\n\n",
  "FUN_140022918": "\nvoid FUN_140022918(void)\n\n{\n  undefined8 *puVar1;\n  longlong lVar2;\n  \n  while (puVar1 = DAT_1400363c8, DAT_1400363c8 != (undefined8 *)0x0) {\n    DAT_1400363c8 = (undefined8 *)*DAT_1400363c8;\n    lVar2 = (*(code *)PTR__guard_dispatch_icall_140023298)();\n    if (lVar2 != 0) {\n      (*(code *)PTR__guard_dispatch_icall_140023298)(lVar2,1);\n    }\n    thunk_FUN_14000ce08(puVar1);\n  }\n  return;\n}\n\n",
  "fgetc": "\n/* Library Function - Single Match\n    fgetc\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl fgetc(FILE *_File)\n\n{\n  uint uVar1;\n  ulong *puVar2;\n  ulonglong uVar3;\n  undefined *puVar4;\n  int iVar5;\n  undefined *puVar6;\n  undefined auStack_38 [32];\n  undefined *local_18;\n  \n  local_18 = auStack_38;\n  if (_File == (FILE *)0x0) {\n    local_18 = auStack_38;\n    puVar2 = __doserrno();\n    *puVar2 = 0x16;\n    FUN_14000d030();\n    return -1;\n  }\n  FUN_14000d384((longlong)_File);\n  if ((*(uint *)((longlong)&_File->_base + 4) >> 0xc & 1) == 0) {\n    uVar1 = _fileno(_File);\n    if (uVar1 + 2 < 2) {\n      puVar6 = &DAT_1400353d0;\n    }\n    else {\n      puVar6 = (undefined *)\n               ((&DAT_140037490)[(longlong)(int)uVar1 >> 6] + (ulonglong)(uVar1 & 0x3f) * 0x48);\n    }\n    puVar4 = &DAT_1400353d0;\n    if (puVar6[0x39] == '\\0') {\n      if (1 < uVar1 + 2) {\n        puVar4 = (undefined *)\n                 ((&DAT_140037490)[(longlong)(int)uVar1 >> 6] + (ulonglong)(uVar1 & 0x3f) * 0x48);\n      }\n      if ((puVar4[0x3d] & 1) == 0) goto LAB_14000d90b;\n    }\n    puVar2 = __doserrno();\n    *puVar2 = 0x16;\n    FUN_14000d030();\n    _local_unwind(local_18,(PVOID)0x14000d903);\n    iVar5 = -1;\n  }\n  else {\nLAB_14000d90b:\n    uVar3 = _fgetc_nolock(_File);\n    FUN_14000d390((longlong)_File);\n    iVar5 = (int)uVar3;\n  }\n  return iVar5;\n}\n\n",
  "FUN_140001380": "\nvoid FUN_140001380(void)\n\n{\n  code *pcVar1;\n  \n  FUN_140003a68(\"string too long\");\n  pcVar1 = (code *)swi(3);\n  (*pcVar1)();\n  return;\n}\n\n",
  "__InternalCxxFrameHandler<class___FrameHandler4>": "\n/* Library Function - Single Match\n    enum _EXCEPTION_DISPOSITION __cdecl __InternalCxxFrameHandler<class __FrameHandler4>(struct\n   EHExceptionRecord * __ptr64,unsigned __int64 * __ptr64,struct _CONTEXT * __ptr64,struct\n   _xDISPATCHER_CONTEXT * __ptr64,struct FH4::FuncInfo4 * __ptr64,int,unsigned __int64 *\n   __ptr64,unsigned char)\n   \n   Library: Visual Studio 2019 Release */\n\n_EXCEPTION_DISPOSITION __cdecl\n__InternalCxxFrameHandler<class___FrameHandler4>\n          (EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n          _xDISPATCHER_CONTEXT *param_4,FuncInfo4 *param_5,int param_6,__uint64 *param_7,\n          uchar param_8)\n\n{\n  int iVar1;\n  _EXCEPTION_DISPOSITION _Var2;\n  longlong lVar3;\n  uint uVar4;\n  uint uVar5;\n  undefined8 in_stack_ffffffffffffffa0;\n  undefined4 uVar6;\n  int local_48 [12];\n  \n  uVar6 = (undefined4)((ulonglong)in_stack_ffffffffffffffa0 >> 0x20);\n  __except_validate_context_record((longlong)param_3);\n  lVar3 = FUN_140008b20();\n  uVar5 = 0;\n  if ((*(int *)(lVar3 + 0x40) == 0) && (*(int *)param_1 != -0x1f928c9d)) {\n    if (*(int *)param_1 == -0x7fffffd7) {\n      if (*(int *)(param_1 + 0x18) == 0xf) {\n        if (*(longlong *)(param_1 + 0x60) == 0x19930520) goto LAB_14000a9e6;\n        goto LAB_14000a9d8;\n      }\n    }\n    else {\nLAB_14000a9d8:\n      if (*(int *)param_1 == -0x7fffffda) goto LAB_14000a9e6;\n    }\n    if (((byte)*param_5 & 0x20) != 0) {\n      return ExceptionContinueSearch;\n    }\n  }\nLAB_14000a9e6:\n  if (((byte)param_1[4] & 0x66) == 0) {\n    FH4::TryBlockMap4::TryBlockMap4((TryBlockMap4 *)local_48,param_5,*(__uint64 *)(param_4 + 8));\n    if ((local_48[0] == 0) && (((byte)*param_5 & 0x40) == 0)) {\n      return ExceptionContinueSearch;\n    }\n    if (((*(int *)param_1 == -0x1f928c9d) &&\n        (((2 < *(uint *)(param_1 + 0x18) && (0x19930522 < *(uint *)(param_1 + 0x20))) &&\n         (*(int *)(*(longlong *)(param_1 + 0x30) + 8) != 0)))) &&\n       (lVar3 = _GetThrowImageBase(), lVar3 + *(int *)(*(longlong *)(param_1 + 0x30) + 8) != 0)) {\n      _Var2 = (*(code *)PTR__guard_dispatch_icall_140023298)\n                        (param_1,param_2,param_3,param_4,param_5,param_6,param_7,\n                         CONCAT44(uVar6,(uint)param_8));\n      return _Var2;\n    }\n    FUN_140009aac(param_1,param_2,param_3,param_4,param_5,param_8,param_6,param_7);\n    return ExceptionContinueSearch;\n  }\n  if (*(int *)(param_5 + 8) == 0) {\n    return ExceptionContinueSearch;\n  }\n  uVar4 = *(byte *)((longlong)*(int *)(param_5 + 8) + *(longlong *)(param_4 + 8)) & 0xf;\n  if (*(uint *)((byte *)((longlong)*(int *)(param_5 + 8) + *(longlong *)(param_4 + 8)) +\n               (-4 - (longlong)(char)(&DAT_140024780)[uVar4])) >> ((&DAT_140024790)[uVar4] & 0x1f)\n      == 0) {\n    return ExceptionContinueSearch;\n  }\n  if (param_6 != 0) {\n    return ExceptionContinueSearch;\n  }\n  if (((byte)param_1[4] & 0x20) == 0) {\nLAB_14000aaf7:\n    __FrameHandler4::FrameUnwindToEmptyState(param_2,param_4,param_5);\n  }\n  else {\n    if (*(int *)param_1 == -0x7fffffda) {\n      iVar1 = __FrameHandler4::StateFromIp(param_5,param_4,*(__uint64 *)(param_4 + 0x20));\n      if (iVar1 < -1) {\nLAB_14000abfa:\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n      if (*(int *)(param_5 + 8) != 0) {\n        uVar5 = *(byte *)((longlong)*(int *)(param_5 + 8) + *(longlong *)(param_4 + 8)) & 0xf;\n        uVar5 = *(uint *)((byte *)((longlong)*(int *)(param_5 + 8) + *(longlong *)(param_4 + 8)) +\n                         (-4 - (longlong)(char)(&DAT_140024780)[uVar5])) >>\n                ((&DAT_140024790)[uVar5] & 0x1f);\n      }\n      if ((int)uVar5 <= iVar1) goto LAB_14000abfa;\n    }\n    else {\n      if (*(int *)param_1 != -0x7fffffd7) goto LAB_14000aaf7;\n      iVar1 = *(int *)(param_1 + 0x38);\n      if ((iVar1 < -1) ||\n         (uVar5 = *(byte *)((longlong)*(int *)(param_5 + 8) + *(longlong *)(param_4 + 8)) & 0xf,\n         (int)(*(uint *)((byte *)((longlong)*(int *)(param_5 + 8) + *(longlong *)(param_4 + 8)) +\n                        (-4 - (longlong)(char)(&DAT_140024780)[uVar5])) >>\n              ((&DAT_140024790)[uVar5] & 0x1f)) <= iVar1)) goto LAB_14000abfa;\n      param_2 = *(__uint64 **)(param_1 + 0x28);\n    }\n    FUN_14000b5b8((longlong *)param_2,param_4,param_5,iVar1);\n  }\n  return ExceptionContinueSearch;\n}\n\n",
  "FUN_140006ae0": "\nvoid FUN_140006ae0(undefined4 param_1)\n\n{\n  code *pcVar1;\n  BOOL BVar2;\n  LONG LVar3;\n  PRUNTIME_FUNCTION FunctionEntry;\n  undefined *puVar4;\n  undefined8 unaff_retaddr;\n  DWORD64 local_res10;\n  undefined local_res18 [8];\n  undefined local_res20 [8];\n  undefined auStack_5c8 [8];\n  undefined auStack_5c0 [232];\n  undefined local_4d8 [152];\n  undefined *local_440;\n  DWORD64 local_3e0;\n  \n  puVar4 = auStack_5c8;\n  BVar2 = IsProcessorFeaturePresent(0x17);\n  if (BVar2 != 0) {\n    pcVar1 = (code *)swi(0x29);\n    (*pcVar1)(param_1);\n    puVar4 = auStack_5c0;\n  }\n  *(undefined8 *)(puVar4 + -8) = 0x140006b14;\n  FUN_140006ad8();\n  *(undefined8 *)(puVar4 + -8) = 0x140006b25;\n  FUN_140008580((undefined (*) [16])local_4d8,0,0x4d0);\n  *(undefined8 *)(puVar4 + -8) = 0x140006b2f;\n  RtlCaptureContext(local_4d8);\n  *(undefined8 *)(puVar4 + -8) = 0x140006b49;\n  FunctionEntry = RtlLookupFunctionEntry(local_3e0,&local_res10,(PUNWIND_HISTORY_TABLE)0x0);\n  if (FunctionEntry != (PRUNTIME_FUNCTION)0x0) {\n    *(undefined8 *)(puVar4 + 0x38) = 0;\n    *(undefined **)(puVar4 + 0x30) = local_res18;\n    *(undefined **)(puVar4 + 0x28) = local_res20;\n    *(undefined **)(puVar4 + 0x20) = local_4d8;\n    *(undefined8 *)(puVar4 + -8) = 0x140006b8a;\n    RtlVirtualUnwind(0,local_res10,local_3e0,FunctionEntry,*(PCONTEXT *)(puVar4 + 0x20),\n                     *(PVOID **)(puVar4 + 0x28),*(PDWORD64 *)(puVar4 + 0x30),\n                     *(PKNONVOLATILE_CONTEXT_POINTERS *)(puVar4 + 0x38));\n  }\n  local_440 = &stack0x00000008;\n  *(undefined8 *)(puVar4 + -8) = 0x140006bbc;\n  FUN_140008580((undefined (*) [16])(puVar4 + 0x50),0,0x98);\n  *(undefined8 *)(puVar4 + 0x60) = unaff_retaddr;\n  *(undefined4 *)(puVar4 + 0x50) = 0x40000015;\n  *(undefined4 *)(puVar4 + 0x54) = 1;\n  *(undefined8 *)(puVar4 + -8) = 0x140006bde;\n  BVar2 = IsDebuggerPresent();\n  *(undefined **)(puVar4 + 0x40) = puVar4 + 0x50;\n  *(undefined **)(puVar4 + 0x48) = local_4d8;\n  *(undefined8 *)(puVar4 + -8) = 0x140006bff;\n  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);\n  *(undefined8 *)(puVar4 + -8) = 0x140006c0a;\n  LVar3 = UnhandledExceptionFilter((_EXCEPTION_POINTERS *)(puVar4 + 0x40));\n  if ((LVar3 == 0) && (BVar2 != 1)) {\n    *(undefined8 *)(puVar4 + -8) = 0x140006c1a;\n    FUN_140006ad8();\n  }\n  return;\n}\n\n",
  "FUN_1400018c0": "\nvoid FUN_1400018c0(void)\n\n{\n  undefined8 local_28 [5];\n  \n  FUN_140001890(local_28);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_28,(ThrowInfo *)&DAT_140033c20);\n}\n\n",
  "FUN_1400225c5": "\nvoid FUN_1400225c5(int **param_1)\n\n{\n  __FrameUnwindFilter(param_1);\n  return;\n}\n\n",
  "FUN_140003d24": "\nlonglong * FUN_140003d24(longlong *param_1,undefined8 param_2,char param_3,int param_4)\n\n{\n  if (param_4 != 0) {\n    *param_1 = (longlong)&DAT_1400236c8;\n    param_1[3] = 0;\n    param_1[8] = 0;\n    param_1[9] = 0;\n    param_1[10] = 0;\n    param_1[2] = (longlong)std::basic_ios<char,struct_std::char_traits<char>_>::vftable;\n  }\n  *(undefined ***)((longlong)*(int *)(*param_1 + 4) + (longlong)param_1) =\n       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;\n  *(int *)((longlong)*(int *)(*param_1 + 4) + -4 + (longlong)param_1) =\n       *(int *)(*param_1 + 4) + -0x10;\n  FUN_1400045ec((ios_base *)((longlong)*(int *)(*param_1 + 4) + (longlong)param_1),param_2,param_3);\n  return param_1;\n}\n\n",
  "__vcrt_uninitialize_ptd": "\n/* Library Function - Single Match\n    __vcrt_uninitialize_ptd\n   \n   Library: Visual Studio 2019 Release */\n\nundefined __vcrt_uninitialize_ptd(void)\n\n{\n  if (DAT_140035050 != -1) {\n    __vcrt_FlsFree(DAT_140035050);\n    DAT_140035050 = -1;\n  }\n  return 1;\n}\n\n",
  "FUN_140002350": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_140002350(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  code *pcVar1;\n  int iVar2;\n  longlong *plVar3;\n  char *pcVar4;\n  undefined auStack_58 [32];\n  longlong *local_38 [2];\n  longlong local_28;\n  ulonglong local_20;\n  ulonglong local_18;\n  \n  local_18 = DAT_140035020 ^ (ulonglong)auStack_58;\n  FUN_14000c214(0x40035b24);\n  _DAT_140035b20 = FUN_14000c1e8();\n  DAT_140035b24 = (ushort)_DAT_140035b20 & 0x1835;\n  while( true ) {\n    do {\n      FUN_140002860(&DAT_140036260,0x1400304b8,param_3,param_4);\n      local_28 = 0;\n      local_20 = 0xf;\n      local_38[0] = (longlong *)0x0;\n      param_3 = 0;\n      FUN_140002520(local_38,(undefined8 *)&DAT_14003038b,(longlong *)0x0);\n      FUN_140002860(&DAT_140036260,0x1400304c0,param_3,param_4);\n      FUN_140002f90(&DAT_1400364a0,local_38);\n      if (local_28 == 8) {\n        iVar2 = FUN_140002050(local_38);\n        pcVar4 = \"Password IS Correct!\";\n        if (iVar2 == 0) {\n          pcVar4 = \"Password Is NOT Correct!\";\n        }\n        plVar3 = FUN_140002860(&DAT_140036260,(longlong)pcVar4,param_3,param_4);\n        pcVar4 = \"\\n\";\n      }\n      else {\n        pcVar4 = \"Password must be 8 characters long!\\n\";\n        plVar3 = &DAT_140036260;\n      }\n      FUN_140002860(plVar3,(longlong)pcVar4,param_3,param_4);\n    } while (local_20 < 0x10);\n    plVar3 = local_38[0];\n    if ((0xfff < local_20 + 1) &&\n       (plVar3 = (longlong *)local_38[0][-1],\n       0x1f < (ulonglong)((longlong)local_38[0] + (-8 - (longlong)plVar3)))) break;\n    thunk_FUN_14000ce08(plVar3);\n  }\n  FUN_14000d050();\n  pcVar1 = (code *)swi(3);\n  (*pcVar1)();\n  return;\n}\n\n",
  "FUN_1400128e0": "\nvoid FUN_1400128e0(undefined8 param_1)\n\n{\n  DAT_140037240 = param_1;\n  return;\n}\n\n",
  "FUN_140014e58": "\n__acrt_ptd * FUN_140014e58(void)\n\n{\n  int iVar1;\n  __acrt_ptd *p_Var2;\n  \n  if ((DAT_140035250 == 0xffffffff) ||\n     (p_Var2 = (__acrt_ptd *)__acrt_FlsGetValue(DAT_140035250), p_Var2 == (__acrt_ptd *)0x0)) {\n    iVar1 = __acrt_FlsSetValue(DAT_140035250,(LPVOID)0xffffffffffffffff);\n    if (iVar1 == 0) goto LAB_140014ef9;\n    p_Var2 = (__acrt_ptd *)_calloc_base(1,0x3c8);\n    if (p_Var2 == (__acrt_ptd *)0x0) {\n      __acrt_FlsSetValue(DAT_140035250,(LPVOID)0x0);\n      p_Var2 = (__acrt_ptd *)0x0;\n    }\n    else {\n      iVar1 = __acrt_FlsSetValue(DAT_140035250,p_Var2);\n      if (iVar1 != 0) {\n        construct_ptd_array(p_Var2);\n        _free_base((LPVOID)0x0);\n        goto LAB_140014eeb;\n      }\n      __acrt_FlsSetValue(DAT_140035250,(LPVOID)0x0);\n    }\n    _free_base(p_Var2);\n  }\n  else {\n    if (p_Var2 == (__acrt_ptd *)0xffffffffffffffff) goto LAB_140014ef9;\nLAB_140014eeb:\n    if (p_Var2 != (__acrt_ptd *)0x0) {\n      return p_Var2;\n    }\n  }\nLAB_140014ef9:\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "__acrt_add_locale_ref": "\n/* Library Function - Single Match\n    __acrt_add_locale_ref\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_add_locale_ref(longlong param_1)\n\n{\n  int *piVar1;\n  int **ppiVar2;\n  longlong lVar3;\n  \n  LOCK();\n  *(int *)(param_1 + 0x10) = *(int *)(param_1 + 0x10) + 1;\n  UNLOCK();\n  piVar1 = *(int **)(param_1 + 0xe0);\n  if (piVar1 != (int *)0x0) {\n    LOCK();\n    *piVar1 = *piVar1 + 1;\n    UNLOCK();\n  }\n  piVar1 = *(int **)(param_1 + 0xf0);\n  if (piVar1 != (int *)0x0) {\n    LOCK();\n    *piVar1 = *piVar1 + 1;\n    UNLOCK();\n  }\n  piVar1 = *(int **)(param_1 + 0xe8);\n  if (piVar1 != (int *)0x0) {\n    LOCK();\n    *piVar1 = *piVar1 + 1;\n    UNLOCK();\n  }\n  piVar1 = *(int **)(param_1 + 0x100);\n  if (piVar1 != (int *)0x0) {\n    LOCK();\n    *piVar1 = *piVar1 + 1;\n    UNLOCK();\n  }\n  ppiVar2 = (int **)(param_1 + 0x38);\n  lVar3 = 6;\n  do {\n    if ((ppiVar2[-2] != (int *)&DAT_1400353c8) && (piVar1 = *ppiVar2, piVar1 != (int *)0x0)) {\n      LOCK();\n      *piVar1 = *piVar1 + 1;\n      UNLOCK();\n    }\n    if ((ppiVar2[-3] != (int *)0x0) && (piVar1 = ppiVar2[-1], piVar1 != (int *)0x0)) {\n      LOCK();\n      *piVar1 = *piVar1 + 1;\n      UNLOCK();\n    }\n    ppiVar2 = ppiVar2 + 4;\n    lVar3 = lVar3 + -1;\n  } while (lVar3 != 0);\n  __acrt_locale_add_lc_time_reference(*(undefined ***)(param_1 + 0x120));\n  return;\n}\n\n",
  "_CreateFrameInfo": "\n/* Library Function - Single Match\n    _CreateFrameInfo\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 * _CreateFrameInfo(undefined8 *param_1,undefined8 param_2)\n\n{\n  longlong lVar1;\n  undefined8 uVar2;\n  \n  *param_1 = param_2;\n  lVar1 = FUN_140008b20();\n  if (param_1 < *(undefined8 **)(lVar1 + 0x58)) {\n    lVar1 = FUN_140008b20();\n    uVar2 = *(undefined8 *)(lVar1 + 0x58);\n  }\n  else {\n    uVar2 = 0;\n  }\n  param_1[1] = uVar2;\n  lVar1 = FUN_140008b20();\n  *(undefined8 **)(lVar1 + 0x58) = param_1;\n  return param_1;\n}\n\n",
  "_set_statfp": "\n/* Library Function - Single Match\n    _set_statfp\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _set_statfp(uint param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = _get_fpsr();\n  FUN_14001f6b0(uVar1 | param_1 & 0x3f);\n  return;\n}\n\n",
  "__dcrt_write_console": "\n/* Library Function - Single Match\n    __dcrt_write_console\n   \n   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual\n   Studio 2019 Release */\n\nBOOL __dcrt_write_console(void *param_1,DWORD param_2,LPDWORD param_3)\n\n{\n  BOOL BVar1;\n  DWORD DVar2;\n  \n  BVar1 = WriteConsoleW(DAT_140035b00,param_1,param_2,param_3,(LPVOID)0x0);\n  if (BVar1 == 0) {\n    DVar2 = GetLastError();\n    if (DVar2 == 6) {\n      if (DAT_140035b00 < (HANDLE)0xfffffffffffffffe) {\n        CloseHandle(DAT_140035b00);\n      }\n      DAT_140035b00 =\n           CreateFileW(L\"CONOUT$\",0x40000000,3,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);\n      BVar1 = WriteConsoleW(DAT_140035b00,param_1,param_2,param_3,(LPVOID)0x0);\n    }\n  }\n  return BVar1;\n}\n\n",
  "common_initialize_environment_nolock<char>": "\n/* Library Function - Single Match\n    int __cdecl common_initialize_environment_nolock<char>(void)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl common_initialize_environment_nolock<char>(void)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  LPSTR pCVar3;\n  char **ppcVar4;\n  \n  iVar2 = 0;\n  if (DAT_140037218 == (char **)0x0) {\n    __acrt_initialize_multibyte();\n    pCVar3 = __dcrt_get_narrow_environment_from_os();\n    if (pCVar3 == (LPSTR)0x0) {\n      iVar2 = -1;\n    }\n    else {\n      ppcVar4 = create_environment<char>(pCVar3);\n      ppcVar1 = ppcVar4;\n      if (ppcVar4 == (char **)0x0) {\n        iVar2 = -1;\n        ppcVar4 = DAT_140037218;\n        ppcVar1 = DAT_140037230;\n      }\n      DAT_140037230 = ppcVar1;\n      DAT_140037218 = ppcVar4;\n      _free_base((LPVOID)0x0);\n    }\n    _free_base(pCVar3);\n  }\n  else {\n    iVar2 = 0;\n  }\n  return iVar2;\n}\n\n",
  "FUN_140006ad0": "\nundefined * FUN_140006ad0(void)\n\n{\n  return &DAT_140037a00;\n}\n\n",
  "setSBUpLow": "\n/* Library Function - Single Match\n    void __cdecl setSBUpLow(struct __crt_multibyte_data * __ptr64)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl setSBUpLow(__crt_multibyte_data *param_1)\n\n{\n  byte bVar1;\n  __crt_multibyte_data _Var2;\n  BOOL BVar3;\n  uint uVar4;\n  longlong lVar5;\n  CHAR *pCVar6;\n  ulonglong uVar7;\n  BYTE *pBVar8;\n  WORD *pWVar9;\n  longlong lVar10;\n  undefined auStackY_788 [32];\n  _cpinfo local_738;\n  CHAR local_718 [255];\n  __crt_multibyte_data a_Stack_619 [256];\n  __crt_multibyte_data a_Stack_519 [257];\n  WORD local_418 [512];\n  ulonglong local_18;\n  \n  local_18 = DAT_140035020 ^ (ulonglong)auStackY_788;\n  if ((*(UINT *)(param_1 + 4) == 0xfde9) ||\n     (BVar3 = GetCPInfo(*(UINT *)(param_1 + 4),&local_738), BVar3 == 0)) {\n    uVar4 = 0;\n    lVar10 = 1;\n    do {\n      if (uVar4 - 0x41 < 0x1a) {\n        param_1[lVar10 + 0x18] = (__crt_multibyte_data)((byte)param_1[lVar10 + 0x18] | 0x10);\n        _Var2 = (__crt_multibyte_data)((char)uVar4 + ' ');\n      }\n      else if (uVar4 - 0x61 < 0x1a) {\n        param_1[lVar10 + 0x18] = (__crt_multibyte_data)((byte)param_1[lVar10 + 0x18] | 0x20);\n        _Var2 = (__crt_multibyte_data)((char)uVar4 + -0x20);\n      }\n      else {\n        _Var2 = (__crt_multibyte_data)0x0;\n      }\n      param_1[lVar10 + 0x118] = _Var2;\n      uVar4 = uVar4 + 1;\n      lVar10 = lVar10 + 1;\n    } while (uVar4 < 0x100);\n  }\n  else {\n    uVar4 = 0;\n    pCVar6 = local_718;\n    lVar10 = 0x100;\n    do {\n      *pCVar6 = (CHAR)uVar4;\n      uVar4 = uVar4 + 1;\n      pCVar6 = pCVar6 + 1;\n    } while (uVar4 < 0x100);\n    pBVar8 = local_738.LeadByte;\n    local_718[0] = ' ';\n    while (local_738.LeadByte[0] != 0) {\n      bVar1 = pBVar8[1];\n      uVar7 = (ulonglong)local_738.LeadByte[0];\n      while ((uVar4 = (uint)uVar7, uVar4 <= bVar1 && (uVar4 < 0x100))) {\n        local_718[uVar7] = ' ';\n        uVar7 = (ulonglong)(uVar4 + 1);\n      }\n      pBVar8 = pBVar8 + 2;\n      local_738.LeadByte[0] = *pBVar8;\n    }\n    __acrt_GetStringTypeA\n              ((__crt_locale_pointers *)0x0,1,local_718,0x100,local_418,*(UINT *)(param_1 + 4),0);\n    __acrt_LCMapStringA((__crt_locale_pointers *)0x0,*(wchar_t **)(param_1 + 0x220),0x100,local_718,\n                        0x100,(char *)(a_Stack_619 + 1),0x100,*(int *)(param_1 + 4),0);\n    __acrt_LCMapStringA((__crt_locale_pointers *)0x0,*(wchar_t **)(param_1 + 0x220),0x200,local_718,\n                        0x100,(char *)(a_Stack_519 + 1),0x100,*(int *)(param_1 + 4),0);\n    lVar5 = 1;\n    pWVar9 = local_418;\n    do {\n      if ((*(byte *)pWVar9 & 1) == 0) {\n        if ((*(byte *)pWVar9 & 2) == 0) {\n          _Var2 = (__crt_multibyte_data)0x0;\n        }\n        else {\n          param_1[lVar5 + 0x18] = (__crt_multibyte_data)((byte)param_1[lVar5 + 0x18] | 0x20);\n          _Var2 = a_Stack_519[lVar5];\n        }\n      }\n      else {\n        param_1[lVar5 + 0x18] = (__crt_multibyte_data)((byte)param_1[lVar5 + 0x18] | 0x10);\n        _Var2 = a_Stack_619[lVar5];\n      }\n      param_1[lVar5 + 0x118] = _Var2;\n      pWVar9 = pWVar9 + 1;\n      lVar5 = lVar5 + 1;\n      lVar10 = lVar10 + -1;\n    } while (lVar10 != 0);\n  }\n  FUN_140006060(local_18 ^ (ulonglong)auStackY_788);\n  return;\n}\n\n",
  "FUN_1400019d0": "\nvoid FUN_1400019d0(_Locinfo *param_1)\n\n{\n  std::_Locinfo::_Locinfo_dtor(param_1);\n  if (*(LPVOID *)(param_1 + 0x58) != (LPVOID)0x0) {\n    FUN_14000ce08(*(LPVOID *)(param_1 + 0x58));\n  }\n  *(undefined8 *)(param_1 + 0x58) = 0;\n  if (*(LPVOID *)(param_1 + 0x48) != (LPVOID)0x0) {\n    FUN_14000ce08(*(LPVOID *)(param_1 + 0x48));\n  }\n  *(undefined8 *)(param_1 + 0x48) = 0;\n  if (*(LPVOID *)(param_1 + 0x38) != (LPVOID)0x0) {\n    FUN_14000ce08(*(LPVOID *)(param_1 + 0x38));\n  }\n  *(undefined8 *)(param_1 + 0x38) = 0;\n  if (*(LPVOID *)(param_1 + 0x28) != (LPVOID)0x0) {\n    FUN_14000ce08(*(LPVOID *)(param_1 + 0x28));\n  }\n  *(undefined8 *)(param_1 + 0x28) = 0;\n  if (*(LPVOID *)(param_1 + 0x18) != (LPVOID)0x0) {\n    FUN_14000ce08(*(LPVOID *)(param_1 + 0x18));\n  }\n  *(undefined8 *)(param_1 + 0x18) = 0;\n  if (*(LPVOID *)(param_1 + 8) != (LPVOID)0x0) {\n    FUN_14000ce08(*(LPVOID *)(param_1 + 8));\n  }\n  *(undefined8 *)(param_1 + 8) = 0;\n  std::_Lockit::~_Lockit((_Lockit *)param_1);\n  return;\n}\n\n",
  "FUN_14000571c": "\nlonglong * FUN_14000571c(longlong *param_1,undefined8 param_2,char param_3,int param_4)\n\n{\n  if (param_4 != 0) {\n    *param_1 = (longlong)&DAT_140023760;\n    param_1[4] = 0;\n    param_1[9] = 0;\n    param_1[10] = 0;\n    param_1[0xb] = 0;\n    param_1[3] = (longlong)std::basic_ios<char,struct_std::char_traits<char>_>::vftable;\n  }\n  *(undefined ***)((longlong)*(int *)(*param_1 + 4) + (longlong)param_1) =\n       std::basic_istream<char,struct_std::char_traits<char>_>::vftable;\n  *(int *)((longlong)*(int *)(*param_1 + 4) + -4 + (longlong)param_1) =\n       *(int *)(*param_1 + 4) + -0x18;\n  param_1[1] = 0;\n  FUN_1400045ec((ios_base *)((longlong)*(int *)(*param_1 + 4) + (longlong)param_1),param_2,param_3);\n  return param_1;\n}\n\n",
  "FUN_140014328": "\nundefined * FUN_140014328(void)\n\n{\n  return &DAT_140037288;\n}\n\n",
  "FUN_140003310": "\nundefined8 FUN_140003310(longlong *param_1)\n\n{\n  int iVar1;\n  longlong *plVar2;\n  int *piVar3;\n  bool bVar4;\n  uint uVar5;\n  uint uVar6;\n  undefined8 uVar7;\n  longlong lVar8;\n  ulonglong uVar9;\n  undefined8 *puVar10;\n  byte *pbVar11;\n  char *pcVar12;\n  undefined4 local_78 [2];\n  longlong *local_70;\n  char ****local_68 [5];\n  char ****local_40 [5];\n  \n  lVar8 = *param_1;\n  iVar1 = *(int *)(lVar8 + 4);\n  uVar6 = *(uint *)((longlong)param_1 + (longlong)iVar1 + 0x10);\n  if (uVar6 == 0) {\n    plVar2 = *(longlong **)((longlong)param_1 + (longlong)iVar1 + 0x50);\n    if (plVar2 != (longlong *)0x0) {\n      FUN_140002dd0(plVar2);\n      lVar8 = *param_1;\n    }\n    bVar4 = false;\n    if ((*(byte *)((longlong)*(int *)(lVar8 + 4) + 0x18 + (longlong)param_1) & 1) != 0) {\n      local_70 = *(longlong **)\n                  (*(longlong *)((longlong)*(int *)(lVar8 + 4) + 0x40 + (longlong)param_1) + 8);\n      (**(code **)(*local_70 + 8))();\n      lVar8 = FUN_140002720((longlong)local_78);\n      if (local_70 != (longlong *)0x0) {\n        puVar10 = (undefined8 *)(**(code **)(*local_70 + 0x10))();\n        if (puVar10 != (undefined8 *)0x0) {\n          (**(code **)*puVar10)(puVar10,1);\n        }\n      }\n      plVar2 = *(longlong **)((longlong)*(int *)(*param_1 + 4) + 0x48 + (longlong)param_1);\n      if ((*(byte **)plVar2[7] == (byte *)0x0) || (*(int *)plVar2[10] < 1)) {\n        uVar9 = (**(code **)(*plVar2 + 0x30))();\n      }\n      else {\n        uVar9 = (ulonglong)**(byte **)plVar2[7];\n      }\nLAB_140003406:\n      if ((int)uVar9 != -1) {\n        if ((*(byte *)(*(longlong *)(lVar8 + 0x18) + (uVar9 & 0xff) * 2) & 0x48) == 0)\n        goto LAB_140003425;\n        plVar2 = *(longlong **)((longlong)*(int *)(*param_1 + 4) + 0x48 + (longlong)param_1);\n        if (*(longlong *)plVar2[7] == 0) {\nLAB_14000347d:\n          uVar9 = (**(code **)(*plVar2 + 0x38))(plVar2);\n        }\n        else {\n          piVar3 = (int *)plVar2[10];\n          if (1 < *piVar3) {\n            *piVar3 = *piVar3 + -1;\n            pbVar11 = *(byte **)plVar2[7] + 1;\n            *(byte **)plVar2[7] = pbVar11;\n            uVar9 = (ulonglong)*pbVar11;\n            goto LAB_140003406;\n          }\n          if (*piVar3 < 1) goto LAB_14000347d;\n          *piVar3 = *piVar3 + -1;\n          pbVar11 = *(byte **)plVar2[7];\n          *(byte **)plVar2[7] = pbVar11 + 1;\n          uVar9 = (ulonglong)*pbVar11;\n        }\n        if ((int)uVar9 != -1) {\n          if ((*(byte **)plVar2[7] == (byte *)0x0) || (*(int *)plVar2[10] < 1)) {\n            uVar9 = (**(code **)(*plVar2 + 0x30))(plVar2);\n          }\n          else {\n            uVar9 = (ulonglong)**(byte **)plVar2[7];\n          }\n        }\n        goto LAB_140003406;\n      }\n      bVar4 = true;\nLAB_140003425:\n      if (bVar4) {\n        iVar1 = *(int *)(*param_1 + 4);\n        uVar6 = 4;\n        if (*(longlong *)((longlong)param_1 + (longlong)iVar1 + 0x48) != 0) {\n          uVar6 = 0;\n        }\n        uVar6 = uVar6 | *(uint *)((longlong)param_1 + (longlong)iVar1 + 0x10) & 0x14 | 3;\n        *(uint *)((longlong)param_1 + (longlong)iVar1 + 0x10) = uVar6;\n        uVar6 = uVar6 & *(uint *)((longlong)param_1 + (longlong)iVar1 + 0x14);\n        if (uVar6 != 0) {\n          if ((uVar6 & 4) == 0) {\n            pcVar12 = \"ios_base::failbit set\";\n            if ((uVar6 & 2) == 0) {\n              pcVar12 = \"ios_base::eofbit set\";\n            }\n          }\n          else {\n            pcVar12 = \"ios_base::badbit set\";\n          }\n          puVar10 = (undefined8 *)FUN_140001450(local_78,1);\n          FUN_140001dd0(local_40,(undefined8 *)pcVar12,puVar10);\n                    /* WARNING: Subroutine does not return */\n          _CxxThrowException(local_40,(ThrowInfo *)&DAT_140033c40);\n        }\n      }\n    }\n    uVar7 = CONCAT71((int7)((ulonglong)*param_1 >> 8),\n                     *(int *)((longlong)*(int *)(*param_1 + 4) + 0x10 + (longlong)param_1) == 0);\n  }\n  else {\n    uVar5 = 4;\n    if (*(longlong *)((longlong)param_1 + (longlong)iVar1 + 0x48) != 0) {\n      uVar5 = 0;\n    }\n    uVar6 = uVar5 | uVar6 & 0x15 | 2;\n    *(uint *)((longlong)param_1 + (longlong)iVar1 + 0x10) = uVar6;\n    uVar6 = uVar6 & *(uint *)((longlong)param_1 + (longlong)iVar1 + 0x14);\n    if (uVar6 != 0) {\n      if ((uVar6 & 4) == 0) {\n        pcVar12 = \"ios_base::failbit set\";\n        if ((uVar6 & 2) == 0) {\n          pcVar12 = \"ios_base::eofbit set\";\n        }\n      }\n      else {\n        pcVar12 = \"ios_base::badbit set\";\n      }\n      puVar10 = (undefined8 *)FUN_140001450(local_78,1);\n      FUN_140001dd0(local_68,(undefined8 *)pcVar12,puVar10);\n                    /* WARNING: Subroutine does not return */\n      _CxxThrowException(local_68,(ThrowInfo *)&DAT_140033c40);\n    }\n    uVar7 = 0;\n  }\n  return uVar7;\n}\n\n",
  "FUN_140006ad8": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_140006ad8(void)\n\n{\n  _DAT_140036d18 = 0;\n  return;\n}\n\n",
  "__acrt_stdio_flush_nolock": "\n/* Library Function - Single Match\n    __acrt_stdio_flush_nolock\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __acrt_stdio_flush_nolock(FILE *param_1)\n\n{\n  uint *puVar1;\n  char *_Buf;\n  int _FileHandle;\n  uint uVar2;\n  uint uVar3;\n  \n  uVar3 = *(uint *)((longlong)&param_1->_base + 4);\n  if ((((byte)uVar3 & 3) == 2) && ((uVar3 & 0xc0) != 0)) {\n    uVar3 = *(int *)&param_1->_ptr - param_1->_cnt;\n    *(undefined4 *)&param_1->_base = 0;\n    _Buf = *(char **)&param_1->_cnt;\n    param_1->_ptr = _Buf;\n    if (0 < (int)uVar3) {\n      _FileHandle = _fileno(param_1);\n      uVar2 = _write(_FileHandle,_Buf,uVar3);\n      if (uVar3 != uVar2) {\n        LOCK();\n        puVar1 = (uint *)((longlong)&param_1->_base + 4);\n        *puVar1 = *puVar1 | 0x10;\n        UNLOCK();\n        return 0xffffffff;\n      }\n      if ((*(uint *)((longlong)&param_1->_base + 4) >> 2 & 1) != 0) {\n        LOCK();\n        puVar1 = (uint *)((longlong)&param_1->_base + 4);\n        *puVar1 = *puVar1 & 0xfffffffd;\n        UNLOCK();\n      }\n    }\n  }\n  return 0;\n}\n\n",
  "wcspbrk": "\n/* Library Function - Single Match\n    wcspbrk\n   \n   Library: Visual Studio 2019 Release */\n\nwchar_t * __cdecl wcspbrk(wchar_t *_Str,wchar_t *_Control)\n\n{\n  wchar_t wVar1;\n  wchar_t *pwVar2;\n  \n  do {\n    if (*_Str == L'\\0') {\n      return (wchar_t *)0x0;\n    }\n    if (*_Control != L'\\0') {\n      wVar1 = *_Control;\n      pwVar2 = _Control;\n      do {\n        if (wVar1 == *_Str) {\n          return _Str;\n        }\n        pwVar2 = pwVar2 + 1;\n        wVar1 = *pwVar2;\n      } while (wVar1 != L'\\0');\n    }\n    _Str = _Str + 1;\n  } while( true );\n}\n\n",
  "__acrt_allocate_buffer_for_argv": "\n/* Library Function - Single Match\n    __acrt_allocate_buffer_for_argv\n   \n   Library: Visual Studio 2019 Release */\n\nLPVOID __acrt_allocate_buffer_for_argv(ulonglong param_1,ulonglong param_2,ulonglong param_3)\n\n{\n  undefined auVar1 [16];\n  LPVOID pvVar2;\n  \n  if ((param_1 < 0x1fffffffffffffff) &&\n     (auVar1._8_8_ = 0, auVar1._0_8_ = param_3,\n     param_2 < SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / auVar1,0))) {\n    if (param_2 * param_3 < ~(param_1 * 8)) {\n      pvVar2 = _calloc_base(param_1 * 8 + param_2 * param_3,1);\n      _free_base((LPVOID)0x0);\n      return pvVar2;\n    }\n  }\n  return (LPVOID)0x0;\n}\n\n",
  "FUN_1400095e4": "\nvoid FUN_1400095e4(EHExceptionRecord *param_1,PVOID *param_2,_CONTEXT *param_3,\n                  _xDISPATCHER_CONTEXT *param_4,_s_FuncInfo *param_5,byte param_6,int param_7,\n                  __uint64 *param_8)\n\n{\n  undefined4 *puVar1;\n  _s_ESTypeList *p_Var2;\n  longlong lVar3;\n  code *pcVar4;\n  uint uVar5;\n  char cVar6;\n  uchar uVar7;\n  bool bVar8;\n  int iVar9;\n  int iVar10;\n  int iVar11;\n  longlong lVar12;\n  int *piVar13;\n  __uint64 *p_Var14;\n  uint uVar15;\n  uint uVar16;\n  undefined auStackY_168 [32];\n  _s_TryBlockMapEntry *in_stack_fffffffffffffed0;\n  undefined4 uVar18;\n  uchar local_108;\n  _CONTEXT *local_100;\n  _s_CatchableType *local_e0;\n  longlong local_d8;\n  __uint64 *local_d0;\n  int local_c8;\n  int iStack_c4;\n  int iStack_c0;\n  uint uStack_bc;\n  int local_b8;\n  _s_FuncInfo *local_b0;\n  undefined8 local_a8;\n  undefined4 local_a0;\n  undefined4 uStack_9c;\n  uint uStack_98;\n  undefined4 uStack_94;\n  undefined4 local_90;\n  undefined4 uStack_8c;\n  uint uStack_88;\n  undefined4 uStack_84;\n  uint local_78;\n  undefined8 local_70;\n  undefined4 uStack_68;\n  undefined4 uStack_64;\n  undefined4 local_60;\n  ulonglong local_58;\n  ulonglong uVar17;\n  \n  local_58 = DAT_140035020 ^ (ulonglong)auStackY_168;\n  local_d0 = param_8;\n  local_108 = '\\0';\n  iVar9 = __FrameHandler3::GetHandlerSearchState((__uint64 *)param_2,param_4,param_5);\n  if ((-2 < iVar9) && (iVar9 < param_5->maxState)) {\n    local_100 = param_3;\n    if ((*(int *)param_1 == -0x1f928c9d) &&\n       (((*(int *)(param_1 + 0x18) == 4 && (*(int *)(param_1 + 0x20) + 0xe66cfae0U < 3)) &&\n        (*(longlong *)(param_1 + 0x30) == 0)))) {\n      lVar12 = FUN_140008b20();\n      if (*(longlong *)(lVar12 + 0x20) == 0) goto LAB_140009a3c;\n      lVar12 = FUN_140008b20();\n      param_1 = *(EHExceptionRecord **)(lVar12 + 0x20);\n      lVar12 = FUN_140008b20();\n      local_108 = '\\x01';\n      local_100 = *(_CONTEXT **)(lVar12 + 0x28);\n      FUN_140007a58(*(undefined8 *)(param_1 + 0x38));\n      if (((*(int *)param_1 == -0x1f928c9d) && (*(int *)(param_1 + 0x18) == 4)) &&\n         ((*(int *)(param_1 + 0x20) + 0xe66cfae0U < 3 && (*(longlong *)(param_1 + 0x30) == 0))))\n      goto LAB_140009aa3;\n      lVar12 = FUN_140008b20();\n      if (*(longlong *)(lVar12 + 0x38) != 0) {\n        lVar12 = FUN_140008b20();\n        p_Var2 = *(_s_ESTypeList **)(lVar12 + 0x38);\n        lVar12 = FUN_140008b20();\n        *(undefined8 *)(lVar12 + 0x38) = 0;\n        cVar6 = FUN_14000b938((longlong)param_1,(int *)p_Var2);\n        if (cVar6 == '\\0') {\n          uVar7 = Is_bad_exception_allowed(p_Var2);\n          if (uVar7 != '\\0') {\n            __DestructExceptionObject((int *)param_1);\n            FUN_14000ad90(&local_70);\n                    /* WARNING: Subroutine does not return */\n            _CxxThrowException(&local_70,(ThrowInfo *)&DAT_140033b60);\n          }\n          terminate();\n          pcVar4 = (code *)swi(3);\n          (*pcVar4)();\n          return;\n        }\n      }\n    }\n    uVar18 = (undefined4)((ulonglong)in_stack_fffffffffffffed0 >> 0x20);\n    local_a8 = *(undefined8 *)(param_4 + 8);\n    local_b0 = param_5;\n    if (((*(int *)param_1 == -0x1f928c9d) && (*(int *)(param_1 + 0x18) == 4)) &&\n       (*(int *)(param_1 + 0x20) + 0xe66cfae0U < 3)) {\n      if (param_5->nTryBlocks != 0) {\n        FUN_1400072fc(&local_90,&local_b0,iVar9,(ulonglong *)param_4,(longlong)param_5);\n        uVar18 = (undefined4)((ulonglong)in_stack_fffffffffffffed0 >> 0x20);\n        local_a0 = local_90;\n        uStack_9c = uStack_8c;\n        uStack_98 = uStack_88;\n        uStack_94 = uStack_84;\n        if (uStack_88 < local_78) {\n          uVar15 = uStack_88;\n          do {\n            uVar17 = 0;\n            lVar3 = *(longlong *)(CONCAT44(uStack_8c,local_90) + 8);\n            lVar12 = (longlong)*(int *)(*(longlong *)CONCAT44(uStack_9c,local_a0) + 0x10) +\n                     (ulonglong)uVar15 * 0x14;\n            piVar13 = (int *)(lVar12 + lVar3);\n            local_c8 = *piVar13;\n            iStack_c4 = piVar13[1];\n            iStack_c0 = piVar13[2];\n            uVar5 = piVar13[3];\n            local_b8 = *(int *)(lVar12 + 0x10 + lVar3);\n            uStack_bc = uVar5;\n            if (((local_c8 <= iVar9) && (iVar9 <= iStack_c4)) &&\n               (local_d8 = (longlong)local_b8 + *(longlong *)(param_4 + 8), uVar5 != 0)) {\n              do {\n                puVar1 = (undefined4 *)(local_d8 + uVar17 * 0x14);\n                local_70._0_4_ = *puVar1;\n                local_70._4_4_ = puVar1[1];\n                uStack_68 = puVar1[2];\n                uStack_64 = puVar1[3];\n                local_60 = *(undefined4 *)(local_d8 + 0x10 + uVar17 * 0x14);\n                lVar12 = _GetThrowImageBase();\n                piVar13 = (int *)(lVar12 + 4 +\n                                 (longlong)*(int *)(*(longlong *)(param_1 + 0x30) + 0xc));\n                lVar12 = _GetThrowImageBase();\n                for (iVar11 = *(int *)(lVar12 + *(int *)(*(longlong *)(param_1 + 0x30) + 0xc));\n                    0 < iVar11; iVar11 = iVar11 + -1) {\n                  lVar12 = _GetThrowImageBase();\n                  local_e0 = (_s_CatchableType *)(lVar12 + *piVar13);\n                  iVar10 = TypeMatchHelper<class___FrameHandler3>\n                                     ((_s_HandlerType *)&local_70,local_e0,\n                                      *(_s_ThrowInfo **)(param_1 + 0x30));\n                  if (iVar10 != 0) {\n                    in_stack_fffffffffffffed0 = (_s_TryBlockMapEntry *)&local_c8;\n                    CatchIt<class___FrameHandler3>\n                              (param_1,(__uint64 *)param_2,local_100,param_4,param_5,\n                               (_s_HandlerType *)&local_70,local_e0,in_stack_fffffffffffffed0,\n                               param_7,local_d0,local_108,param_6);\n                    goto LAB_140009913;\n                  }\n                  piVar13 = piVar13 + 1;\n                }\n                uVar16 = (int)uVar17 + 1;\n                uVar17 = (ulonglong)uVar16;\n              } while (uVar16 != uVar5);\n            }\nLAB_140009913:\n            uVar18 = (undefined4)((ulonglong)in_stack_fffffffffffffed0 >> 0x20);\n            uVar15 = uVar15 + 1;\n          } while (uVar15 < local_78);\n        }\n      }\n      piVar13 = (int *)0x0;\n      if ((0x19930520 < (param_5->magicNumber_and_bbtFlags & 0x1fffffff)) &&\n         (((param_5->dispESTypeList != 0 &&\n           (lVar12 = _GetImageBase(), lVar12 + (int)param_5->dispESTypeList != 0)) ||\n          ((((uint)param_5->EHFlags >> 2 & 1) != 0 &&\n           (bVar8 = __FrameHandler3::ExecutionInCatch(param_4,param_5), !bVar8)))))) {\n        if (((uint)param_5->EHFlags >> 2 & 1) != 0) {\n          lVar12 = FUN_140008b20();\n          *(EHExceptionRecord **)(lVar12 + 0x20) = param_1;\n          lVar12 = FUN_140008b20();\n          *(_CONTEXT **)(lVar12 + 0x28) = local_100;\n          terminate();\n          pcVar4 = (code *)swi(3);\n          (*pcVar4)();\n          return;\n        }\n        if (param_5->dispESTypeList != 0) {\n          lVar12 = _GetImageBase();\n          piVar13 = (int *)(lVar12 + (int)param_5->dispESTypeList);\n        }\n        cVar6 = FUN_14000b938((longlong)param_1,piVar13);\n        if (cVar6 == '\\0') {\n          p_Var14 = __FrameHandler3::GetEstablisherFrame\n                              ((__uint64 *)param_2,param_4,param_5,(__uint64 *)&local_e0);\n          FUN_1400075a4(param_2,(ULONG_PTR)param_1,(ULONG_PTR)local_100,(ULONG_PTR)p_Var14,0,\n                        (ULONG_PTR)param_5,-1,CONCAT44(uVar18,0xffffffff),0,(PVOID *)param_4,param_6\n                       );\n        }\n      }\n    }\n    else if (param_5->nTryBlocks != 0) {\n      if (param_6 != 0) goto LAB_140009aa3;\n      FindHandlerForForeignException<class___FrameHandler3>\n                (param_1,(__uint64 *)param_2,local_100,param_4,param_5,iVar9,param_7,param_8);\n    }\n    lVar12 = FUN_140008b20();\n    if (*(longlong *)(lVar12 + 0x38) == 0) {\nLAB_140009a3c:\n      FUN_140006060(local_58 ^ (ulonglong)auStackY_168);\n      return;\n    }\n  }\nLAB_140009aa3:\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "__acrt_locale_add_lc_time_reference": "\n/* Library Function - Single Match\n    __acrt_locale_add_lc_time_reference\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __acrt_locale_add_lc_time_reference(undefined **param_1)\n\n{\n  int *piVar1;\n  int iVar2;\n  \n  if ((param_1 != (undefined **)0x0) && (param_1 != &PTR_DAT_1400281f0)) {\n    LOCK();\n    piVar1 = (int *)((longlong)param_1 + 0x15c);\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + 1;\n    UNLOCK();\n    return iVar2 + 1;\n  }\n  return 0x7fffffff;\n}\n\n",
  "FUN_1400226eb": "\nvoid FUN_1400226eb(undefined8 param_1,longlong param_2)\n\n{\n  __acrt_unlock(**(int **)(param_2 + 0x48));\n  return;\n}\n\n",
  "_invoke_watson": "\n/* Library Function - Single Match\n    _invoke_watson\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl\n_invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)\n\n{\n  code *pcVar1;\n  BOOL BVar2;\n  HANDLE hProcess;\n  undefined *puVar3;\n  undefined auStack_28 [8];\n  undefined auStack_20 [32];\n  \n  puVar3 = auStack_28;\n  BVar2 = IsProcessorFeaturePresent(0x17);\n  if (BVar2 != 0) {\n    pcVar1 = (code *)swi(0x29);\n    (*pcVar1)(5);\n    puVar3 = auStack_20;\n  }\n  *(undefined8 *)(puVar3 + -8) = 0x14000d0ae;\n  __acrt_call_reportfault(2,0xc0000417,1);\n  *(undefined8 *)(puVar3 + -8) = 0x14000d0b4;\n  hProcess = GetCurrentProcess();\n                    /* WARNING: Could not recover jumptable at 0x00014000d0c0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  TerminateProcess(hProcess,0xc0000417);\n  return;\n}\n\n",
  "FUN_140021dd4": "\nushort * FUN_140021dd4(ushort *param_1,ushort param_2)\n\n{\n  uint uVar1;\n  longlong lVar2;\n  ushort *puVar3;\n  undefined auVar4 [16];\n  undefined in_XMM1 [16];\n  undefined auVar5 [16];\n  undefined auVar6 [16];\n  ushort uVar7;\n  ushort uVar8;\n  \n  auVar5 = pshuflw(in_XMM1,ZEXT216(param_2),0);\n  do {\n    if (((uint)param_1 & 0xfff) < 0xff1) {\n      auVar6._0_2_ = -(ushort)(*param_1 == 0);\n      auVar6._2_2_ = -(ushort)(param_1[1] == 0);\n      auVar6._4_2_ = -(ushort)(param_1[2] == 0);\n      auVar6._6_2_ = -(ushort)(param_1[3] == 0);\n      auVar6._8_2_ = -(ushort)(param_1[4] == 0);\n      auVar6._10_2_ = -(ushort)(param_1[5] == 0);\n      auVar6._12_2_ = -(ushort)(param_1[6] == 0);\n      auVar6._14_2_ = -(ushort)(param_1[7] == 0);\n      uVar7 = auVar5._0_2_;\n      auVar4._0_2_ = -(ushort)(*param_1 == uVar7);\n      uVar8 = auVar5._2_2_;\n      auVar4._2_2_ = -(ushort)(param_1[1] == uVar8);\n      auVar4._4_2_ = -(ushort)(param_1[2] == uVar7);\n      auVar4._6_2_ = -(ushort)(param_1[3] == uVar8);\n      auVar4._8_2_ = -(ushort)(param_1[4] == uVar7);\n      auVar4._10_2_ = -(ushort)(param_1[5] == uVar8);\n      auVar4._12_2_ = -(ushort)(param_1[6] == uVar7);\n      auVar4._14_2_ = -(ushort)(param_1[7] == uVar8);\n      auVar6 = auVar6 | auVar4;\n      uVar7 = (ushort)(SUB161(auVar6 >> 7,0) & 1) | (ushort)(SUB161(auVar6 >> 0xf,0) & 1) << 1 |\n              (ushort)(SUB161(auVar6 >> 0x17,0) & 1) << 2 |\n              (ushort)(SUB161(auVar6 >> 0x1f,0) & 1) << 3 |\n              (ushort)(SUB161(auVar6 >> 0x27,0) & 1) << 4 |\n              (ushort)(SUB161(auVar6 >> 0x2f,0) & 1) << 5 |\n              (ushort)(SUB161(auVar6 >> 0x37,0) & 1) << 6 |\n              (ushort)(SUB161(auVar6 >> 0x3f,0) & 1) << 7 |\n              (ushort)(SUB161(auVar6 >> 0x47,0) & 1) << 8 |\n              (ushort)(SUB161(auVar6 >> 0x4f,0) & 1) << 9 |\n              (ushort)(SUB161(auVar6 >> 0x57,0) & 1) << 10 |\n              (ushort)(SUB161(auVar6 >> 0x5f,0) & 1) << 0xb |\n              (ushort)(SUB161(auVar6 >> 0x67,0) & 1) << 0xc |\n              (ushort)(SUB161(auVar6 >> 0x6f,0) & 1) << 0xd |\n              (ushort)(SUB161(auVar6 >> 0x77,0) & 1) << 0xe |\n              (ushort)(byte)(auVar6[0xf] >> 7) << 0xf;\n      if (uVar7 != 0) {\n        uVar1 = 0;\n        if (uVar7 != 0) {\n          for (; (uVar7 >> uVar1 & 1) == 0; uVar1 = uVar1 + 1) {\n          }\n        }\n        puVar3 = (ushort *)0x0;\n        if (*(ushort *)((longlong)param_1 + (ulonglong)uVar1) == param_2) {\n          puVar3 = (ushort *)((longlong)param_1 + (ulonglong)uVar1);\n        }\n        return puVar3;\n      }\n      lVar2 = 0x10;\n    }\n    else {\n      if (*param_1 == param_2) {\n        return param_1;\n      }\n      if (*param_1 == 0) {\n        return (ushort *)0x0;\n      }\n      lVar2 = 2;\n    }\n    param_1 = (ushort *)((longlong)param_1 + lVar2);\n  } while( true );\n}\n\n",
  "write_buffer_nolock<char>": "\n/* Library Function - Single Match\n    bool __cdecl write_buffer_nolock<char>(char,class __crt_stdio_stream)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nbool __cdecl write_buffer_nolock<char>(undefined param_1,FILE *param_2)\n\n{\n  uint *puVar1;\n  uint _FileHandle;\n  uint uVar2;\n  int iVar3;\n  __int64 _Var4;\n  undefined *puVar5;\n  uint _MaxCharCount;\n  bool bVar6;\n  undefined local_res8 [8];\n  \n  local_res8[0] = param_1;\n  _FileHandle = _fileno(param_2);\n  if ((*(uint *)((longlong)&param_2->_base + 4) & 0xc0) == 0) {\n    iVar3 = _write(_FileHandle,local_res8,1);\n    bVar6 = iVar3 == 1;\n  }\n  else {\n    uVar2 = 0;\n    _MaxCharCount = *(int *)&param_2->_ptr - param_2->_cnt;\n    param_2->_ptr = (char *)((longlong)*(void **)&param_2->_cnt + 1);\n    *(int *)&param_2->_base = param_2->_charbuf + -1;\n    if ((int)_MaxCharCount < 1) {\n      if (_FileHandle + 2 < 2) {\n        puVar5 = &DAT_1400353d0;\n      }\n      else {\n        puVar5 = (undefined *)\n                 ((&DAT_140037490)[(longlong)(int)_FileHandle >> 6] +\n                 (ulonglong)(_FileHandle & 0x3f) * 0x48);\n      }\n      if (((puVar5[0x38] & 0x20) != 0) &&\n         (_Var4 = common_lseek<__int64>(_FileHandle,0,2), _Var4 == -1)) {\n        LOCK();\n        puVar1 = (uint *)((longlong)&param_2->_base + 4);\n        *puVar1 = *puVar1 | 0x10;\n        UNLOCK();\n        return true;\n      }\n    }\n    else {\n      uVar2 = _write(_FileHandle,*(void **)&param_2->_cnt,_MaxCharCount);\n    }\n    bVar6 = uVar2 == _MaxCharCount;\n    **(undefined **)&param_2->_cnt = local_res8[0];\n  }\n  return bVar6;\n}\n\n",
  "GetLocaleNameFromDefault": "\n/* Library Function - Single Match\n    GetLocaleNameFromDefault\n   \n   Library: Visual Studio 2019 Release */\n\nvoid GetLocaleNameFromDefault(longlong param_1)\n\n{\n  int iVar1;\n  errno_t eVar2;\n  longlong lVar3;\n  undefined auStackY_f8 [32];\n  wchar_t local_c8 [88];\n  ulonglong local_18;\n  longlong lVar4;\n  \n  local_18 = DAT_140035020 ^ (ulonglong)auStackY_f8;\n  *(uint *)(param_1 + 0x10) = *(uint *)(param_1 + 0x10) | 0x104;\n  iVar1 = __acrt_GetUserDefaultLocaleName(local_c8,0x55);\n  if (1 < iVar1) {\n    lVar3 = -1;\n    do {\n      lVar4 = lVar3;\n      lVar3 = lVar4 + 1;\n    } while (local_c8[lVar3] != L'\\0');\n    eVar2 = wcsncpy_s((wchar_t *)(param_1 + 600),0x55,local_c8,lVar4 + 2);\n    if (eVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n      _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n  }\n  FUN_140006060(local_18 ^ (ulonglong)auStackY_f8);\n  return;\n}\n\n",
  "FUN_140001c60": "\nbyte * FUN_140001c60(longlong param_1,byte *param_2,byte *param_3)\n\n{\n  int iVar1;\n  \n  if (param_2 != param_3) {\n    do {\n      iVar1 = _Tolower((uint)*param_2,(_Ctypevec *)(param_1 + 0x10));\n      *param_2 = (byte)iVar1;\n      param_2 = param_2 + 1;\n    } while (param_2 != param_3);\n  }\n  return param_2;\n}\n\n",
  "FUN_140002f90": "\nlonglong * FUN_140002f90(longlong *param_1,longlong **param_2)\n\n{\n  int iVar1;\n  longlong *plVar2;\n  longlong *plVar3;\n  int *piVar4;\n  bool bVar5;\n  uint uVar6;\n  undefined8 uVar7;\n  longlong lVar8;\n  undefined8 *puVar9;\n  longlong **pplVar10;\n  ulonglong uVar11;\n  byte *pbVar12;\n  char *pcVar13;\n  uint uVar14;\n  ulonglong uVar15;\n  undefined4 local_60 [2];\n  longlong *local_58;\n  char ****local_50 [5];\n  \n  bVar5 = false;\n  plVar2 = *(longlong **)((longlong)*(int *)(*param_1 + 4) + 0x48 + (longlong)param_1);\n  if (plVar2 != (longlong *)0x0) {\n    (**(code **)(*plVar2 + 8))();\n  }\n  uVar7 = FUN_140003310(param_1);\n  uVar14 = 0;\n  if ((char)uVar7 != '\\0') {\n    local_58 = *(longlong **)\n                (*(longlong *)((longlong)*(int *)(*param_1 + 4) + 0x40 + (longlong)param_1) + 8);\n    (**(code **)(*local_58 + 8))();\n    lVar8 = FUN_140002720((longlong)local_60);\n    if ((local_58 != (longlong *)0x0) &&\n       (puVar9 = (undefined8 *)(**(code **)(*local_58 + 0x10))(), puVar9 != (undefined8 *)0x0)) {\n      (**(code **)*puVar9)(puVar9,1);\n    }\n    param_2[2] = (longlong *)0x0;\n    pplVar10 = param_2;\n    if ((longlong *)0xf < param_2[3]) {\n      pplVar10 = (longlong **)*param_2;\n    }\n    *(undefined *)pplVar10 = 0;\n    uVar15 = *(ulonglong *)((longlong)*(int *)(*param_1 + 4) + 0x28 + (longlong)param_1);\n    if (((longlong)uVar15 < 1) || (0x7ffffffffffffffe < uVar15)) {\n      uVar15 = 0x7fffffffffffffff;\n    }\n    plVar2 = *(longlong **)((longlong)*(int *)(*param_1 + 4) + 0x48 + (longlong)param_1);\n    if ((*(byte **)plVar2[7] == (byte *)0x0) || (*(int *)plVar2[10] < 1)) {\n      uVar11 = (**(code **)(*plVar2 + 0x30))();\n    }\n    else {\n      uVar11 = (ulonglong)**(byte **)plVar2[7];\n    }\n    while (uVar14 = 0, uVar15 != 0) {\n      if ((int)uVar11 == -1) {\n        uVar14 = 1;\n        break;\n      }\n      uVar14 = 0;\n      if ((*(byte *)(*(longlong *)(lVar8 + 0x18) + (uVar11 & 0xff) * 2) & 0x48) != 0) break;\n      plVar2 = param_2[2];\n      plVar3 = param_2[3];\n      if (plVar2 < plVar3) {\n        param_2[2] = (longlong *)((longlong)plVar2 + 1);\n        pplVar10 = param_2;\n        if ((longlong *)0xf < plVar3) {\n          pplVar10 = (longlong **)*param_2;\n        }\n        *(char *)((longlong)pplVar10 + (longlong)plVar2) = (char)uVar11;\n        *(undefined *)((longlong)pplVar10 + 1 + (longlong)plVar2) = 0;\n      }\n      else {\n        FUN_1400035c0(param_2,uVar11 & 0xff,plVar3,(char)uVar11);\n      }\n      bVar5 = true;\n      uVar15 = uVar15 - 1;\n      plVar2 = *(longlong **)((longlong)*(int *)(*param_1 + 4) + 0x48 + (longlong)param_1);\n      if (*(longlong *)plVar2[7] == 0) {\nLAB_14000316c:\n        uVar11 = (**(code **)(*plVar2 + 0x38))(plVar2);\nLAB_140003175:\n        if ((int)uVar11 != -1) {\n          if ((*(byte **)plVar2[7] == (byte *)0x0) || (*(int *)plVar2[10] < 1)) {\n            uVar11 = (**(code **)(*plVar2 + 0x30))(plVar2);\n          }\n          else {\n            uVar11 = (ulonglong)**(byte **)plVar2[7];\n          }\n        }\n      }\n      else {\n        piVar4 = (int *)plVar2[10];\n        if (*piVar4 < 2) {\n          if (*piVar4 < 1) goto LAB_14000316c;\n          *piVar4 = *piVar4 + -1;\n          pbVar12 = *(byte **)plVar2[7];\n          *(byte **)plVar2[7] = pbVar12 + 1;\n          uVar11 = (ulonglong)*pbVar12;\n          goto LAB_140003175;\n        }\n        *piVar4 = *piVar4 + -1;\n        pbVar12 = *(byte **)plVar2[7] + 1;\n        *(byte **)plVar2[7] = pbVar12;\n        uVar11 = (ulonglong)*pbVar12;\n        bVar5 = true;\n      }\n    }\n  }\n  *(undefined8 *)((longlong)*(int *)(*param_1 + 4) + 0x28 + (longlong)param_1) = 0;\n  if (!bVar5) {\n    uVar14 = uVar14 | 2;\n  }\n  iVar1 = *(int *)(*param_1 + 4);\n  uVar6 = 4;\n  if (*(longlong *)((longlong)param_1 + (longlong)iVar1 + 0x48) != 0) {\n    uVar6 = 0;\n  }\n  uVar6 = uVar6 | uVar14 | *(uint *)((longlong)param_1 + (longlong)iVar1 + 0x10) & 0x17;\n  *(uint *)((longlong)param_1 + (longlong)iVar1 + 0x10) = uVar6;\n  uVar6 = uVar6 & *(uint *)((longlong)param_1 + (longlong)iVar1 + 0x14);\n  if (uVar6 != 0) {\n    if ((uVar6 & 4) == 0) {\n      pcVar13 = \"ios_base::failbit set\";\n      if ((uVar6 & 2) == 0) {\n        pcVar13 = \"ios_base::eofbit set\";\n      }\n    }\n    else {\n      pcVar13 = \"ios_base::badbit set\";\n    }\n    puVar9 = (undefined8 *)FUN_140001450(local_60,1);\n    FUN_140001dd0(local_50,(undefined8 *)pcVar13,puVar9);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_50,(ThrowInfo *)&DAT_140033c40);\n  }\n  plVar2 = *(longlong **)((longlong)*(int *)(*param_1 + 4) + 0x48 + (longlong)param_1);\n  if (plVar2 != (longlong *)0x0) {\n    (**(code **)(*plVar2 + 0x10))();\n  }\n  return param_1;\n}\n\n",
  "_CallSettingFrameEncoded": "\n/* Library Function - Single Match\n    _CallSettingFrameEncoded\n   \n   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual\n   Studio 2019 Release */\n\nvoid _CallSettingFrameEncoded(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  code *pcVar1;\n  \n  pcVar1 = (code *)FUN_14000bd20();\n  (*pcVar1)(param_3);\n  FUN_14000bd50();\n  FUN_14000bd20();\n  return;\n}\n\n",
  "__acrt_GetLocaleInfoA": "\n/* Library Function - Single Match\n    __acrt_GetLocaleInfoA\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_GetLocaleInfoA\n               (__crt_locale_pointers *param_1,int param_2,wchar_t *param_3,ulong param_4,\n               LPWSTR *param_5)\n\n{\n  int iVar1;\n  errno_t eVar2;\n  DWORD DVar3;\n  LPWSTR pWVar4;\n  undefined auStackY_108 [32];\n  undefined4 local_d8 [4];\n  char local_c8 [128];\n  ulonglong local_48;\n  \n  local_48 = DAT_140035020 ^ (ulonglong)auStackY_108;\n  *param_5 = (LPWSTR)0x0;\n  if (param_2 == 1) {\n    iVar1 = InternalGetLocaleInfoA(param_1,param_3,param_4,local_c8,0x80);\n    if (iVar1 != 0) {\n      pWVar4 = (LPWSTR)_calloc_base((longlong)iVar1,1);\n      *param_5 = pWVar4;\n      _free_base((LPVOID)0x0);\n      if ((*param_5 != (LPWSTR)0x0) &&\n         (eVar2 = strncpy_s((char *)*param_5,(longlong)iVar1,local_c8,(longlong)(iVar1 + -1)),\n         eVar2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n        _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n      }\n      goto LAB_140019289;\n    }\n    DVar3 = GetLastError();\n    if (DVar3 != 0x7a) goto LAB_140019289;\n    iVar1 = InternalGetLocaleInfoA(param_1,param_3,param_4,(char *)0x0,0);\n    if (iVar1 == 0) goto LAB_140019289;\n    pWVar4 = (LPWSTR)_calloc_base((longlong)iVar1,1);\n    if (pWVar4 != (LPWSTR)0x0) {\n      iVar1 = InternalGetLocaleInfoA(param_1,param_3,param_4,(char *)pWVar4,iVar1);\n      goto LAB_1400191f7;\n    }\n  }\n  else {\n    if (param_2 != 2) {\n      if (param_2 == 0) {\n        local_d8[0] = 0;\n        iVar1 = __acrt_GetLocaleInfoEx((ushort *)param_3,param_4 | 0x20000000,(LPWSTR)local_d8,2);\n        if (iVar1 != 0) {\n          *(undefined *)param_5 = (undefined)local_d8[0];\n        }\n      }\n      goto LAB_140019289;\n    }\n    iVar1 = __acrt_GetLocaleInfoEx((ushort *)param_3,param_4,(LPWSTR)0x0,0);\n    if (iVar1 == 0) goto LAB_140019289;\n    pWVar4 = (LPWSTR)_calloc_base((longlong)iVar1,2);\n    if (pWVar4 != (LPWSTR)0x0) {\n      iVar1 = __acrt_GetLocaleInfoEx((ushort *)param_3,param_4,pWVar4,iVar1);\nLAB_1400191f7:\n      if (iVar1 != 0) {\n        *param_5 = pWVar4;\n        pWVar4 = (LPWSTR)0x0;\n      }\n    }\n  }\n  _free_base(pWVar4);\nLAB_140019289:\n  FUN_140006060(local_48 ^ (ulonglong)auStackY_108);\n  return;\n}\n\n",
  "__acrt_update_thread_locale_data": "\n/* Library Function - Single Match\n    __acrt_update_thread_locale_data\n   \n   Library: Visual Studio 2019 Release */\n\nundefined ** __acrt_update_thread_locale_data(void)\n\n{\n  longlong lVar1;\n  undefined **ppuVar2;\n  \n  lVar1 = FUN_140014d84();\n  if (((DAT_140035520 & *(uint *)(lVar1 + 0x3a8)) == 0) ||\n     (ppuVar2 = *(undefined ***)(lVar1 + 0x90), ppuVar2 == (undefined **)0x0)) {\n    __acrt_lock(4);\n    ppuVar2 = _updatetlocinfoEx_nolock((LPVOID *)(lVar1 + 0x90),DAT_1400372c0);\n    __acrt_unlock(4);\n    if (ppuVar2 == (undefined **)0x0) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n  }\n  return ppuVar2;\n}\n\n",
  "common_ftell_nolock<__int64>": "\n/* Library Function - Single Match\n    __int64 __cdecl common_ftell_nolock<__int64>(class __crt_stdio_stream)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nulonglong __cdecl common_ftell_nolock<__int64>(FILE *param_1)\n\n{\n  char cVar1;\n  uint uVar2;\n  ulong *puVar3;\n  __int64 _Var4;\n  ulonglong uVar5;\n  __int64 _Var6;\n  longlong lVar7;\n  ulonglong uVar8;\n  \n  if (param_1 == (FILE *)0x0) {\n    puVar3 = __doserrno();\n    *puVar3 = 0x16;\n    FUN_14000d030();\n  }\n  else {\n    uVar2 = _fileno(param_1);\n    if (*(int *)&param_1->_base < 0) {\n      *(undefined4 *)&param_1->_base = 0;\n    }\n    _Var4 = common_lseek<__int64>(uVar2,0,1);\n    if (-1 < _Var4) {\n      if ((*(uint *)((longlong)&param_1->_base + 4) & 0xc0) == 0) {\n        return _Var4 - *(int *)&param_1->_base;\n      }\n      uVar5 = (ulonglong)(uVar2 & 0x3f);\n      lVar7 = (longlong)(int)uVar2 >> 6;\n      uVar8 = (longlong)param_1->_ptr - *(longlong *)&param_1->_cnt;\n      cVar1 = *(char *)((&DAT_140037490)[lVar7] + 0x39 + uVar5 * 0x48);\n      if ((*(uint *)((longlong)&param_1->_base + 4) & 3) == 0) {\n        if ((*(uint *)((longlong)&param_1->_base + 4) >> 2 & 1) == 0) {\n          puVar3 = __doserrno();\n          *puVar3 = 0x16;\n          return 0xffffffffffffffff;\n        }\n      }\n      else {\n        if ((cVar1 == '\\x01') &&\n           ((*(byte *)((&DAT_140037490)[lVar7] + 0x3d + uVar5 * 0x48) & 2) != 0)) {\n          uVar5 = common_ftell_translated_utf8_nolock(param_1,_Var4);\n          return uVar5;\n        }\n        if (*(char *)((&DAT_140037490)[lVar7] + 0x38 + uVar5 * 0x48) < '\\0') {\n          _Var6 = count_newline_bytes(*(char **)&param_1->_cnt,param_1->_ptr,\n                                      (__crt_lowio_text_mode)CONCAT71(0x1400374,cVar1));\n          uVar8 = uVar8 + _Var6;\n        }\n      }\n      if (_Var4 == 0) {\n        return uVar8;\n      }\n      if ((*(uint *)((longlong)&param_1->_base + 4) & 1) == 0) {\n        if (cVar1 == '\\x01') {\n          uVar8 = uVar8 >> 1;\n        }\n        return uVar8 + _Var4;\n      }\n      uVar5 = common_ftell_read_mode_nolock(param_1,_Var4,uVar8);\n      return uVar5;\n    }\n  }\n  return 0xffffffffffffffff;\n}\n\n",
  "__scrt_is_nonwritable_in_current_image": "\n/* Library Function - Single Match\n    __scrt_is_nonwritable_in_current_image\n   \n   Library: Visual Studio 2019 Release */\n\nulonglong __scrt_is_nonwritable_in_current_image(longlong param_1)\n\n{\n  ulonglong uVar1;\n  uint7 uVar2;\n  longlong lVar3;\n  longlong lVar4;\n  \n  uVar1 = 0x5a4d;\n  if (((IMAGE_DOS_HEADER_140000000.e_magic == (char  [2])0x5a4d) &&\n      (lVar3 = (longlong)(int)IMAGE_DOS_HEADER_140000000.e_lfanew,\n      *(int *)(IMAGE_DOS_HEADER_140000000.e_magic + lVar3) == 0x4550)) &&\n     (uVar1 = 0x20b, *(short *)((longlong)IMAGE_DOS_HEADER_140000000.e_res_4_ + lVar3 + -4) == 0x20b\n     )) {\n    lVar4 = lVar3 + 0x140000018 +\n            (ulonglong)*(ushort *)((longlong)IMAGE_DOS_HEADER_140000000.e_res_4_ + lVar3 + -8);\n    uVar1 = (ulonglong)*(ushort *)(IMAGE_DOS_HEADER_140000000.e_magic + lVar3 + 6);\n    lVar3 = lVar4 + uVar1 * 0x28;\n    for (; lVar4 != lVar3; lVar4 = lVar4 + 0x28) {\n      if (((ulonglong)*(uint *)(lVar4 + 0xc) <= param_1 - 0x140000000U) &&\n         (uVar1 = (ulonglong)(*(int *)(lVar4 + 8) + *(uint *)(lVar4 + 0xc)),\n         param_1 - 0x140000000U < uVar1)) goto LAB_1400064ee;\n    }\n    lVar4 = 0;\nLAB_1400064ee:\n    if (lVar4 == 0) {\n      uVar1 = uVar1 & 0xffffffffffffff00;\n    }\n    else {\n      uVar2 = (uint7)(uVar1 >> 8);\n      if (*(int *)(lVar4 + 0x24) < 0) {\n        uVar1 = (ulonglong)uVar2 << 8;\n      }\n      else {\n        uVar1 = CONCAT71(uVar2,1);\n      }\n    }\n  }\n  else {\n    uVar1 = uVar1 & 0xffffffffffffff00;\n  }\n  return uVar1;\n}\n\n",
  "_SetImageBase": "\n/* Library Function - Single Match\n    _SetImageBase\n   \n   Library: Visual Studio 2019 Release */\n\nvoid _SetImageBase(undefined8 param_1)\n\n{\n  longlong lVar1;\n  \n  lVar1 = FUN_140008b20();\n  *(undefined8 *)(lVar1 + 0x60) = param_1;\n  return;\n}\n\n",
  "_calloc_base": "\nLPVOID _calloc_base(ulonglong param_1,ulonglong param_2)\n\n{\n  int iVar1;\n  LPVOID pvVar2;\n  ulong *puVar3;\n  size_t dwBytes;\n  \n  if ((param_1 == 0) || (param_2 <= 0xffffffffffffffe0 / param_1)) {\n    dwBytes = param_1 * param_2;\n    if (dwBytes == 0) {\n      dwBytes = 1;\n    }\n    do {\n      pvVar2 = HeapAlloc(DAT_1400379d8,8,dwBytes);\n      if (pvVar2 != (LPVOID)0x0) {\n        return pvVar2;\n      }\n      iVar1 = FUN_1400142f4();\n    } while ((iVar1 != 0) && (iVar1 = _callnewh(dwBytes), iVar1 != 0));\n  }\n  puVar3 = __doserrno();\n  *puVar3 = 0xc;\n  return (LPVOID)0x0;\n}\n\n",
  "widen": "\n/* Library Function - Single Match\n    public: char __cdecl std::basic_ios<char,struct std::char_traits<char> >::widen(char)const\n   __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nchar __thiscall\nstd::basic_ios<char,struct_std::char_traits<char>_>::widen\n          (basic_ios<char,struct_std::char_traits<char>_> *this,char param_1)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  longlong lVar3;\n  undefined7 in_register_00000011;\n  undefined local_18 [8];\n  longlong local_10;\n  \n  lVar3 = *(longlong *)(*(longlong *)(this + 0x40) + 8);\n  local_10 = lVar3;\n  (*(code *)PTR__guard_dispatch_icall_140023298)(lVar3);\n  uVar2 = FUN_140002720((longlong)local_18);\n  cVar1 = (*(code *)PTR__guard_dispatch_icall_140023298)\n                    (uVar2,CONCAT71(in_register_00000011,param_1));\n  if (lVar3 != 0) {\n    lVar3 = (*(code *)PTR__guard_dispatch_icall_140023298)(lVar3);\n    if (lVar3 != 0) {\n      (*(code *)PTR__guard_dispatch_icall_140023298)(lVar3,1);\n    }\n  }\n  return cVar1;\n}\n\n",
  "FUN_1400129cc": "\nundefined8 * FUN_1400129cc(void)\n\n{\n  return &DAT_140037260;\n}\n\n",
  "fputc": "\n/* Library Function - Single Match\n    fputc\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl fputc(int _Ch,FILE *_File)\n\n{\n  char **ppcVar1;\n  uint uVar2;\n  ulong *puVar3;\n  ulonglong uVar4;\n  undefined *puVar5;\n  undefined *puVar6;\n  undefined auStack_38 [32];\n  undefined *local_18;\n  \n  local_18 = auStack_38;\n  if (_File == (FILE *)0x0) {\n    local_18 = auStack_38;\n    puVar3 = __doserrno();\n    *puVar3 = 0x16;\n    FUN_14000d030();\n    return -1;\n  }\n  FUN_14000d384((longlong)_File);\n  if ((*(uint *)((longlong)&_File->_base + 4) >> 0xc & 1) == 0) {\n    uVar2 = _fileno(_File);\n    if (uVar2 + 2 < 2) {\n      puVar6 = &DAT_1400353d0;\n    }\n    else {\n      puVar6 = (undefined *)\n               ((&DAT_140037490)[(longlong)(int)uVar2 >> 6] + (ulonglong)(uVar2 & 0x3f) * 0x48);\n    }\n    puVar5 = &DAT_1400353d0;\n    if (puVar6[0x39] == '\\0') {\n      if (1 < uVar2 + 2) {\n        puVar5 = (undefined *)\n                 ((&DAT_140037490)[(longlong)(int)uVar2 >> 6] + (ulonglong)(uVar2 & 0x3f) * 0x48);\n      }\n      if ((puVar5[0x3d] & 1) == 0) goto LAB_14000da64;\n    }\n    puVar3 = __doserrno();\n    *puVar3 = 0x16;\n    FUN_14000d030();\n    _local_unwind(local_18,(PVOID)0x14000da5c);\n    uVar2 = 0xffffffff;\n  }\n  else {\nLAB_14000da64:\n    ppcVar1 = &_File->_base;\n    *(int *)ppcVar1 = *(int *)ppcVar1 + -1;\n    if (*(int *)ppcVar1 < 0) {\n      uVar4 = __acrt_stdio_flush_and_write_narrow_nolock((byte)_Ch,_File);\n      uVar2 = (uint)uVar4;\n    }\n    else {\n      *_File->_ptr = (byte)_Ch;\n      _File->_ptr = _File->_ptr + 1;\n      uVar2 = _Ch & 0xff;\n    }\n    FUN_14000d390((longlong)_File);\n  }\n  return uVar2;\n}\n\n",
  "FUN_140005840": "\nUINT * FUN_140005840(UINT *param_1)\n\n{\n  ushort *puVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  UINT UVar5;\n  LPVOID pvVar6;\n  ushort *puVar7;\n  wchar_t **ppwVar8;\n  wchar_t *pwVar9;\n  undefined4 *puVar10;\n  longlong lVar11;\n  \n  UVar5 = ___lc_codepage_func();\n  *param_1 = UVar5;\n  pvVar6 = _calloc_base(0x100,2);\n  *(LPVOID *)(param_1 + 2) = pvVar6;\n  if (pvVar6 == (LPVOID)0x0) {\n    puVar7 = __pctype_func();\n    param_1[4] = 0;\n    *(ushort **)(param_1 + 2) = puVar7;\n  }\n  else {\n    puVar7 = __pctype_func();\n    lVar11 = 4;\n    puVar10 = *(undefined4 **)(param_1 + 2);\n    do {\n      uVar2 = *(undefined4 *)(puVar7 + 2);\n      uVar3 = *(undefined4 *)(puVar7 + 4);\n      uVar4 = *(undefined4 *)(puVar7 + 6);\n      *puVar10 = *(undefined4 *)puVar7;\n      puVar10[1] = uVar2;\n      puVar10[2] = uVar3;\n      puVar10[3] = uVar4;\n      uVar2 = *(undefined4 *)(puVar7 + 10);\n      uVar3 = *(undefined4 *)(puVar7 + 0xc);\n      uVar4 = *(undefined4 *)(puVar7 + 0xe);\n      puVar10[4] = *(undefined4 *)(puVar7 + 8);\n      puVar10[5] = uVar2;\n      puVar10[6] = uVar3;\n      puVar10[7] = uVar4;\n      uVar2 = *(undefined4 *)(puVar7 + 0x12);\n      uVar3 = *(undefined4 *)(puVar7 + 0x14);\n      uVar4 = *(undefined4 *)(puVar7 + 0x16);\n      puVar10[8] = *(undefined4 *)(puVar7 + 0x10);\n      puVar10[9] = uVar2;\n      puVar10[10] = uVar3;\n      puVar10[0xb] = uVar4;\n      uVar2 = *(undefined4 *)(puVar7 + 0x1a);\n      uVar3 = *(undefined4 *)(puVar7 + 0x1c);\n      uVar4 = *(undefined4 *)(puVar7 + 0x1e);\n      puVar10[0xc] = *(undefined4 *)(puVar7 + 0x18);\n      puVar10[0xd] = uVar2;\n      puVar10[0xe] = uVar3;\n      puVar10[0xf] = uVar4;\n      uVar2 = *(undefined4 *)(puVar7 + 0x22);\n      uVar3 = *(undefined4 *)(puVar7 + 0x24);\n      uVar4 = *(undefined4 *)(puVar7 + 0x26);\n      puVar10[0x10] = *(undefined4 *)(puVar7 + 0x20);\n      puVar10[0x11] = uVar2;\n      puVar10[0x12] = uVar3;\n      puVar10[0x13] = uVar4;\n      uVar2 = *(undefined4 *)(puVar7 + 0x2a);\n      uVar3 = *(undefined4 *)(puVar7 + 0x2c);\n      uVar4 = *(undefined4 *)(puVar7 + 0x2e);\n      puVar10[0x14] = *(undefined4 *)(puVar7 + 0x28);\n      puVar10[0x15] = uVar2;\n      puVar10[0x16] = uVar3;\n      puVar10[0x17] = uVar4;\n      uVar2 = *(undefined4 *)(puVar7 + 0x32);\n      uVar3 = *(undefined4 *)(puVar7 + 0x34);\n      uVar4 = *(undefined4 *)(puVar7 + 0x36);\n      puVar10[0x18] = *(undefined4 *)(puVar7 + 0x30);\n      puVar10[0x19] = uVar2;\n      puVar10[0x1a] = uVar3;\n      puVar10[0x1b] = uVar4;\n      puVar1 = puVar7 + 0x38;\n      uVar2 = *(undefined4 *)(puVar7 + 0x3a);\n      uVar3 = *(undefined4 *)(puVar7 + 0x3c);\n      uVar4 = *(undefined4 *)(puVar7 + 0x3e);\n      puVar7 = puVar7 + 0x40;\n      puVar10[0x1c] = *(undefined4 *)puVar1;\n      puVar10[0x1d] = uVar2;\n      puVar10[0x1e] = uVar3;\n      puVar10[0x1f] = uVar4;\n      lVar11 = lVar11 + -1;\n      puVar10 = puVar10 + 0x20;\n    } while (lVar11 != 0);\n    param_1[4] = 1;\n  }\n  ppwVar8 = ___lc_locale_name_func();\n  pwVar9 = ppwVar8[1];\n  *(wchar_t **)(param_1 + 6) = pwVar9;\n  if (pwVar9 != (wchar_t *)0x0) {\n    pwVar9 = _wcsdup(pwVar9);\n    *(wchar_t **)(param_1 + 6) = pwVar9;\n  }\n  return param_1;\n}\n\n",
  "FUN_140006ac8": "\nundefined * FUN_140006ac8(void)\n\n{\n  return &DAT_140037a08;\n}\n\n",
  "FUN_140001240": "\nundefined8 * FUN_140001240(undefined8 *param_1,uint param_2)\n\n{\n  *param_1 = std::exception::vftable;\n  __std_exception_destroy((LPVOID *)(param_1 + 1));\n  if ((param_2 & 1) != 0) {\n    thunk_FUN_14000ce08(param_1);\n  }\n  return param_1;\n}\n\n",
  "_execute_onexit_table": "\n/* Library Function - Single Match\n    _execute_onexit_table\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _execute_onexit_table(undefined8 param_1)\n\n{\n  undefined8 local_res8;\n  __crt_seh_guarded_call<int> local_res10 [8];\n  undefined4 local_res18 [2];\n  undefined4 local_res20 [2];\n  undefined8 *local_18 [3];\n  \n  local_18[0] = &local_res8;\n  local_res18[0] = 2;\n  local_res20[0] = 2;\n  local_res8 = param_1;\n  __crt_seh_guarded_call<int>::\n  operator()<class_<lambda_7777bce6b2f8c936911f934f8298dc43>,class_<lambda_f03950bc5685219e0bcd2087efbe011e>&___ptr64,class_<lambda_3883c3dff614d5e0c5f61bb1ac94921c>_>\n            (local_res10,(<lambda_7777bce6b2f8c936911f934f8298dc43> *)local_res20,\n             (<lambda_f03950bc5685219e0bcd2087efbe011e> *)local_18,\n             (<lambda_3883c3dff614d5e0c5f61bb1ac94921c> *)local_res18);\n  return;\n}\n\n",
  "FUN_1400225db": "\nvoid FUN_1400225db(void)\n\n{\n  longlong lVar1;\n  \n  lVar1 = FUN_140008b20();\n  if (0 < *(int *)(lVar1 + 0x30)) {\n    lVar1 = FUN_140008b20();\n    *(int *)(lVar1 + 0x30) = *(int *)(lVar1 + 0x30) + -1;\n  }\n  return;\n}\n\n",
  "_get_stream_buffer_pointers": "\n/* Library Function - Single Match\n    _get_stream_buffer_pointers\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8\n_get_stream_buffer_pointers(longlong param_1,longlong *param_2,longlong *param_3,longlong *param_4)\n\n{\n  ulong *puVar1;\n  undefined8 uVar2;\n  \n  if (param_1 == 0) {\n    puVar1 = __doserrno();\n    *puVar1 = 0x16;\n    FUN_14000d030();\n    uVar2 = 0x16;\n  }\n  else {\n    if (param_2 != (longlong *)0x0) {\n      *param_2 = param_1 + 8;\n    }\n    if (param_3 != (longlong *)0x0) {\n      *param_3 = param_1;\n    }\n    if (param_4 != (longlong *)0x0) {\n      *param_4 = param_1 + 0x10;\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
  "common_set_variable_in_environment_nolock<char>": "\n/* Library Function - Single Match\n    int __cdecl common_set_variable_in_environment_nolock<char>(char * __ptr64 const,int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl common_set_variable_in_environment_nolock<char>(char *param_1,int param_2)\n\n{\n  ulonglong uVar1;\n  char cVar2;\n  int iVar3;\n  errno_t eVar4;\n  ulong *puVar5;\n  char *pcVar6;\n  longlong lVar7;\n  byte *pbVar8;\n  byte **ppbVar9;\n  char *pcVar10;\n  LPCWSTR pWVar11;\n  byte **ppbVar12;\n  ulonglong uVar13;\n  int iVar14;\n  char *pcVar15;\n  size_t sVar16;\n  longlong lVar17;\n  \n  pcVar10 = (char *)0x0;\n  iVar14 = 0;\n  if (param_1 == (char *)0x0) {\n    puVar5 = __doserrno();\n    *puVar5 = 0x16;\n    return -1;\n  }\n  pcVar6 = FUN_140021d54((ulonglong)param_1,'=');\n  pcVar15 = param_1;\n  if ((pcVar6 != (char *)0x0) && (pcVar6 != param_1)) {\n    cVar2 = pcVar6[1];\n    if (DAT_140037218 == DAT_140037230) {\n      DAT_140037218 = (byte **)FUN_14001c218((char **)DAT_140037218);\n    }\n    if (DAT_140037218 != (byte **)0x0) {\nLAB_14001c041:\n      ppbVar9 = DAT_140037218;\n      sVar16 = (longlong)pcVar6 - (longlong)param_1;\n      pbVar8 = *DAT_140037218;\n      ppbVar12 = DAT_140037218;\n      while (pbVar8 != (byte *)0x0) {\n        iVar3 = FUN_140020504((byte *)param_1,pbVar8,sVar16);\n        if ((iVar3 == 0) && (((*ppbVar12)[sVar16] == 0x3d || ((*ppbVar12)[sVar16] == 0)))) {\n          uVar13 = (longlong)ppbVar12 - (longlong)ppbVar9 >> 3;\n          goto LAB_14001c090;\n        }\n        ppbVar12 = ppbVar12 + 1;\n        pbVar8 = *ppbVar12;\n      }\n      uVar13 = -((longlong)ppbVar12 - (longlong)ppbVar9 >> 3);\nLAB_14001c090:\n      if (((longlong)uVar13 < 0) || (*ppbVar9 == (byte *)0x0)) {\n        if (cVar2 == '\\0') goto LAB_14001c1e1;\n        uVar1 = -uVar13 + 2;\n        if ((-uVar13 <= uVar1) && (uVar1 < 0x1fffffffffffffff)) {\n          ppbVar9 = (byte **)_recalloc_base(ppbVar9,uVar1,8);\n          _free_base((LPVOID)0x0);\n          if (ppbVar9 != (byte **)0x0) {\n            ppbVar9[-uVar13] = (byte *)param_1;\n            ppbVar9[1 - uVar13] = (byte *)0x0;\n            DAT_140037218 = ppbVar9;\n            goto LAB_14001c149;\n          }\n        }\n        iVar14 = -1;\n      }\n      else {\n        _free_base(ppbVar9[uVar13]);\n        if (cVar2 == '\\0') {\n          for (; ppbVar9[uVar13] != (byte *)0x0; uVar13 = uVar13 + 1) {\n            ppbVar9[uVar13] = ppbVar9[uVar13 + 1];\n          }\n          ppbVar9 = (byte **)_recalloc_base(ppbVar9,uVar13,8);\n          _free_base((LPVOID)0x0);\n          pcVar10 = param_1;\n          if (ppbVar9 != (byte **)0x0) {\n            DAT_140037218 = ppbVar9;\n          }\n        }\n        else {\n          ppbVar9[uVar13] = (byte *)param_1;\n        }\nLAB_14001c149:\n        pcVar15 = pcVar10;\n        if (param_2 != 0) {\n          lVar7 = -1;\n          do {\n            lVar17 = lVar7;\n            lVar7 = lVar17 + 1;\n          } while (param_1[lVar17 + 1] != '\\0');\n          pcVar10 = (char *)_calloc_base(lVar17 + 3,1);\n          iVar14 = 0;\n          if (pcVar10 != (char *)0x0) {\n            eVar4 = strcpy_s(pcVar10,lVar17 + 3,param_1);\n            if (eVar4 != 0) {\n                    /* WARNING: Subroutine does not return */\n              _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n            }\n            (pcVar6 + (longlong)(pcVar10 + (1 - (longlong)param_1)))[-1] = '\\0';\n            pWVar11 = __acrt_SetEnvironmentVariableA\n                                (pcVar10,(char *)(-(ulonglong)(cVar2 != '\\0') &\n                                                 (ulonglong)\n                                                 (pcVar6 + (longlong)\n                                                           (pcVar10 + (1 - (longlong)param_1)))));\n            if ((int)pWVar11 == 0) {\n              puVar5 = __doserrno();\n              iVar14 = -1;\n              *puVar5 = 0x2a;\n            }\n          }\n          _free_base(pcVar10);\n        }\n      }\n      goto LAB_14001c1e1;\n    }\n    if ((param_2 == 0) || (DAT_140037220 == (LPVOID)0x0)) {\n      if (cVar2 == '\\0') goto LAB_14001c1e1;\n      DAT_140037218 = (byte **)_calloc_base(1,8);\n      _free_base((LPVOID)0x0);\n      if (DAT_140037218 != (byte **)0x0) {\n        if (DAT_140037220 == (LPVOID)0x0) {\n          DAT_140037220 = _calloc_base(1,8);\n          _free_base((LPVOID)0x0);\n          if (DAT_140037220 == (LPVOID)0x0) goto LAB_14001bfff;\n        }\nLAB_14001c03c:\n        if (DAT_140037218 != (byte **)0x0) goto LAB_14001c041;\n      }\nLAB_14001bfff:\n      iVar14 = -1;\n      goto LAB_14001c1e1;\n    }\n    lVar7 = __dcrt_get_or_create_narrow_environment_nolock();\n    if (lVar7 != 0) {\n      if (DAT_140037218 == DAT_140037230) {\n        DAT_140037218 = (byte **)FUN_14001c218((char **)DAT_140037218);\n      }\n      goto LAB_14001c03c;\n    }\n  }\n  puVar5 = __doserrno();\n  iVar14 = -1;\n  *puVar5 = 0x16;\nLAB_14001c1e1:\n  _free_base(pcVar15);\n  return iVar14;\n}\n\n",
  "__acrt_lowio_create_handle_array": "\n/* Library Function - Single Match\n    __acrt_lowio_create_handle_array\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 * __acrt_lowio_create_handle_array(void)\n\n{\n  uint uVar1;\n  undefined8 *puVar2;\n  undefined *puVar4;\n  undefined8 *puVar5;\n  undefined8 *puVar3;\n  \n  puVar2 = (undefined8 *)_calloc_base(0x40,0x48);\n  puVar5 = (undefined8 *)0x0;\n  if ((puVar2 != (undefined8 *)0x0) && (puVar5 = puVar2, puVar2 != puVar2 + 0x240)) {\n    puVar2 = puVar2 + 6;\n    do {\n      __acrt_InitializeCriticalSectionEx((LPCRITICAL_SECTION)(puVar2 + -6),4000,0);\n      puVar2[-1] = 0xffffffffffffffff;\n      puVar4 = (undefined *)((longlong)puVar2 + 0xe);\n      *puVar2 = 0;\n      *(undefined4 *)(puVar2 + 1) = 0xa0a0000;\n      *(undefined *)((longlong)puVar2 + 0xc) = 10;\n      *(byte *)((longlong)puVar2 + 0xd) = *(byte *)((longlong)puVar2 + 0xd) & 0xf8;\n      puVar3 = (undefined8 *)0x0;\n      do {\n        *puVar4 = 0;\n        uVar1 = (int)puVar3 + 1;\n        puVar3 = (undefined8 *)(ulonglong)uVar1;\n        puVar4 = puVar4 + 1;\n      } while (uVar1 < 5);\n      puVar3 = puVar2 + 3;\n      puVar2 = puVar2 + 9;\n    } while (puVar3 != puVar2 + 0x240);\n  }\n  _free_base((LPVOID)0x0);\n  return puVar5;\n}\n\n",
  "translate_text_mode_nolock<char>": "\n/* Library Function - Single Match\n    int __cdecl translate_text_mode_nolock<char>(int,char * __ptr64 const,unsigned __int64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl translate_text_mode_nolock<char>(int param_1,char *param_2,__uint64 param_3)\n\n{\n  char *pcVar1;\n  byte *pbVar2;\n  char cVar3;\n  byte bVar4;\n  longlong lVar5;\n  BOOL BVar6;\n  ulonglong uVar7;\n  char *pcVar8;\n  char cVar9;\n  HANDLE hFile;\n  char *pcVar10;\n  char *pcVar11;\n  longlong lVar12;\n  char local_res8 [8];\n  DWORD local_res10 [2];\n  HANDLE local_res18;\n  \n  uVar7 = (ulonglong)(param_1 & 0x3f);\n  lVar12 = (longlong)param_1 >> 6;\n  lVar5 = (&DAT_140037490)[lVar12];\n  hFile = *(HANDLE *)(lVar5 + 0x28 + uVar7 * 0x48);\n  if ((param_3 == 0) || (*param_2 != '\\n')) {\n    pbVar2 = (byte *)(lVar5 + 0x38 + uVar7 * 0x48);\n    *pbVar2 = *pbVar2 & 0xfb;\n  }\n  else {\n    pbVar2 = (byte *)(lVar5 + 0x38 + uVar7 * 0x48);\n    *pbVar2 = *pbVar2 | 4;\n  }\n  pcVar1 = param_2 + param_3;\n  pcVar10 = param_2;\n  pcVar11 = param_2;\n  local_res18 = hFile;\n  if (param_2 < pcVar1) {\n    do {\n      cVar9 = *pcVar11;\n      if (cVar9 == '\\x1a') {\n        bVar4 = *(byte *)((&DAT_140037490)[lVar12] + 0x38 + uVar7 * 0x48);\n        if ((bVar4 & 0x40) == 0) {\n          *(byte *)((&DAT_140037490)[lVar12] + 0x38 + uVar7 * 0x48) = bVar4 | 2;\n        }\n        else {\n          *pcVar10 = '\\x1a';\n          pcVar10 = pcVar10 + 1;\n        }\n        break;\n      }\n      pcVar8 = pcVar11 + 1;\n      if (cVar9 == '\\r') {\n        if (pcVar8 < pcVar1) {\n          cVar9 = '\\r';\n          if (*pcVar8 == '\\n') {\n            cVar9 = '\\n';\n          }\n          cVar3 = *pcVar8;\n          *pcVar10 = cVar9;\n          pcVar8 = pcVar11 + (ulonglong)(cVar3 == '\\n') + 1;\n        }\n        else {\n          BVar6 = ReadFile(hFile,local_res8,1,local_res10,(LPOVERLAPPED)0x0);\n          if ((BVar6 == 0) || (local_res10[0] == 0)) {\nLAB_140017a86:\n            *pcVar10 = '\\r';\n          }\n          else {\n            if ((*(byte *)((&DAT_140037490)[lVar12] + 0x38 + (ulonglong)(param_1 & 0x3f) * 0x48) &\n                0x48) == 0) {\n              if ((local_res8[0] != '\\n') || (pcVar10 != param_2)) {\n                common_lseek_nolock<__int64>(param_1,-1,1);\n                hFile = local_res18;\n                if (local_res8[0] == '\\n') goto LAB_140017a94;\n                goto LAB_140017a86;\n              }\n            }\n            else if (local_res8[0] != '\\n') {\n              *pcVar10 = '\\r';\n              *(char *)((&DAT_140037490)[lVar12] + 0x3a + (ulonglong)(param_1 & 0x3f) * 0x48) =\n                   local_res8[0];\n              goto LAB_140017a89;\n            }\n            *pcVar10 = '\\n';\n          }\n        }\nLAB_140017a89:\n        pcVar10 = pcVar10 + 1;\n        hFile = local_res18;\n      }\n      else {\n        *pcVar10 = cVar9;\n        pcVar10 = pcVar10 + 1;\n      }\nLAB_140017a94:\n      pcVar11 = pcVar8;\n    } while (pcVar8 < pcVar1);\n  }\n  return (int)pcVar10 - (int)param_2;\n}\n\n",
  "FUN_14000bdf8": "\nFARPROC FUN_14000bdf8(uint param_1,LPCSTR param_2,uint *param_3,uint *param_4)\n\n{\n  HMODULE pHVar1;\n  wchar_t *lpLibFileName;\n  DWORD DVar2;\n  int iVar3;\n  HMODULE hLibModule;\n  FARPROC pFVar4;\n  ulonglong uVar5;\n  ulonglong uVar6;\n  bool bVar7;\n  \n  uVar6 = (ulonglong)param_1;\n  pFVar4 = *(FARPROC *)(&DAT_140036e68 + uVar6 * 8);\n  if (pFVar4 != (FARPROC)0xffffffffffffffff) {\n    if (pFVar4 != (FARPROC)0x0) {\n      return pFVar4;\n    }\n    bVar7 = param_3 == param_4;\n    while (!bVar7) {\n      uVar5 = (ulonglong)*param_3;\n      hLibModule = *(HMODULE *)(&DAT_140036e50 + uVar5 * 8);\n      if (hLibModule == (HMODULE)0x0) {\n        lpLibFileName = (wchar_t *)(&PTR_u_api_ms_win_core_fibers_l1_1_1_1400256c0)[uVar5];\n        hLibModule = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0x800);\n        if ((hLibModule != (HMODULE)0x0) ||\n           (((DVar2 = GetLastError(), DVar2 == 0x57 &&\n             (iVar3 = wcsncmp(lpLibFileName,L\"api-ms-\",7), iVar3 != 0)) &&\n            (hLibModule = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0), hLibModule != (HMODULE)0x0)))\n           ) {\n          LOCK();\n          pHVar1 = *(HMODULE *)(&DAT_140036e50 + uVar5 * 8);\n          *(HMODULE *)(&DAT_140036e50 + uVar5 * 8) = hLibModule;\n          UNLOCK();\n          if (pHVar1 != (HMODULE)0x0) {\n            FreeLibrary(hLibModule);\n          }\n          goto LAB_14000bf01;\n        }\n        LOCK();\n        *(undefined8 *)(&DAT_140036e50 + uVar5 * 8) = 0xffffffffffffffff;\n        UNLOCK();\n      }\n      else if (hLibModule != (HMODULE)0xffffffffffffffff) {\nLAB_14000bf01:\n        pFVar4 = GetProcAddress(hLibModule,param_2);\n        if (pFVar4 != (FARPROC)0x0) {\n          LOCK();\n          *(FARPROC *)(&DAT_140036e68 + uVar6 * 8) = pFVar4;\n          UNLOCK();\n          return pFVar4;\n        }\n        break;\n      }\n      param_3 = param_3 + 1;\n      bVar7 = param_3 == param_4;\n    }\n    LOCK();\n    *(undefined8 *)(&DAT_140036e68 + uVar6 * 8) = 0xffffffffffffffff;\n    UNLOCK();\n  }\n  return (FARPROC)0x0;\n}\n\n",
  "seekpos": "\n/* Library Function - Single Match\n    protected: virtual class std::fpos<struct _Mbstatet> __cdecl std::basic_filebuf<char,struct\n   std::char_traits<char> >::seekpos(class std::fpos<struct _Mbstatet>,int) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nlonglong * __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::seekpos\n          (basic_filebuf<char,struct_std::char_traits<char>_> *this,longlong *param_1,\n          longlong *param_2)\n\n{\n  basic_filebuf<char,struct_std::char_traits<char>_> *pbVar1;\n  undefined8 uVar2;\n  bool bVar3;\n  int iVar4;\n  longlong lVar5;\n  longlong local_res8;\n  \n  local_res8 = param_2[1] + *param_2;\n  if (((*(longlong *)(this + 0x80) != 0) && (bVar3 = _Endwrite(this), bVar3)) &&\n     (iVar4 = fsetpos(*(FILE **)(this + 0x80),&local_res8), iVar4 == 0)) {\n    lVar5 = param_2[2];\n    *(longlong *)(this + 0x74) = lVar5;\n    if (**(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x18) == this + 0x70) {\n      pbVar1 = *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x88);\n      uVar2 = *(undefined8 *)(this + 0x90);\n      **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x18) = pbVar1;\n      **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x38) = pbVar1;\n      **(int **)(this + 0x50) = (int)uVar2 - (int)pbVar1;\n      lVar5 = *(longlong *)(this + 0x74);\n    }\n    param_1[1] = 0;\n    *param_1 = local_res8;\n    param_1[2] = lVar5;\n    return param_1;\n  }\n  *param_1 = -1;\n  param_1[1] = 0;\n  param_1[2] = 0;\n  return param_1;\n}\n\n",
  "FUN_140001e90": "\nundefined8 * FUN_140001e90(undefined8 *param_1,longlong param_2)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  \n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  __std_exception_copy((char **)(param_2 + 8),(char **)(param_1 + 1));\n  *param_1 = std::_System_error::vftable;\n  uVar1 = *(undefined4 *)(param_2 + 0x18);\n  uVar2 = *(undefined4 *)(param_2 + 0x1c);\n  uVar3 = *(undefined4 *)(param_2 + 0x20);\n  uVar4 = *(undefined4 *)(param_2 + 0x24);\n  *param_1 = std::ios_base::failure::vftable;\n  *(undefined4 *)(param_1 + 3) = uVar1;\n  *(undefined4 *)((longlong)param_1 + 0x1c) = uVar2;\n  *(undefined4 *)(param_1 + 4) = uVar3;\n  *(undefined4 *)((longlong)param_1 + 0x24) = uVar4;\n  return param_1;\n}\n\n",
  "FUN_140011a3c": "\nulonglong FUN_140011a3c(undefined (*param_1) [32],ulonglong param_2)\n\n{\n  undefined auVar1 [32];\n  ulonglong uVar2;\n  undefined (*pauVar3) [32];\n  ulonglong uVar4;\n  undefined auVar5 [16];\n  \n  pauVar3 = param_1;\n  if (DAT_140035038 < 5) {\n    if (DAT_140035038 < 1) {\n      if (param_1 != (undefined (*) [32])(*param_1 + param_2 * 2)) {\n        do {\n          if (*(short *)*pauVar3 == 0) break;\n          pauVar3 = (undefined (*) [32])(*pauVar3 + 2);\n        } while (pauVar3 != (undefined (*) [32])(*param_1 + param_2 * 2));\n      }\n    }\n    else if (((ulonglong)param_1 & 1) == 0) {\n      uVar4 = (ulonglong)((uint)param_1 & 0xf);\n      uVar4 = (-(ulonglong)(uVar4 != 0) & 0x10 - uVar4) >> 1;\n      if (param_2 < uVar4) {\n        uVar4 = param_2;\n      }\n      if (param_1 != (undefined (*) [32])(*param_1 + uVar4 * 2)) {\n        do {\n          if (*(short *)*pauVar3 == 0) break;\n          pauVar3 = (undefined (*) [32])(*pauVar3 + 2);\n        } while (pauVar3 != (undefined (*) [32])(*param_1 + uVar4 * 2));\n      }\n      uVar2 = (longlong)pauVar3 - (longlong)param_1 >> 1;\n      if (uVar2 != uVar4) {\n        return uVar2;\n      }\n      for (pauVar3 = (undefined (*) [32])(*param_1 + uVar2 * 2);\n          pauVar3 !=\n          (undefined (*) [32])(*param_1 + ((param_2 - uVar4 & 0xfffffffffffffff0) + uVar2) * 2);\n          pauVar3 = (undefined (*) [32])(*pauVar3 + 0x10)) {\n        auVar5._0_2_ = -(ushort)(*(short *)*pauVar3 == 0);\n        auVar5._2_2_ = -(ushort)(*(short *)(*pauVar3 + 2) == 0);\n        auVar5._4_2_ = -(ushort)(*(short *)(*pauVar3 + 4) == 0);\n        auVar5._6_2_ = -(ushort)(*(short *)(*pauVar3 + 6) == 0);\n        auVar5._8_2_ = -(ushort)(*(short *)(*pauVar3 + 8) == 0);\n        auVar5._10_2_ = -(ushort)(*(short *)(*pauVar3 + 10) == 0);\n        auVar5._12_2_ = -(ushort)(*(short *)(*pauVar3 + 0xc) == 0);\n        auVar5._14_2_ = -(ushort)(*(short *)(*pauVar3 + 0xe) == 0);\n        if ((ushort)((ushort)(SUB161(auVar5 >> 7,0) & 1) |\n                     (ushort)(SUB161(auVar5 >> 0xf,0) & 1) << 1 |\n                     (ushort)(SUB161(auVar5 >> 0x17,0) & 1) << 2 |\n                     (ushort)(SUB161(auVar5 >> 0x1f,0) & 1) << 3 |\n                     (ushort)(SUB161(auVar5 >> 0x27,0) & 1) << 4 |\n                     (ushort)(SUB161(auVar5 >> 0x2f,0) & 1) << 5 |\n                     (ushort)(SUB161(auVar5 >> 0x37,0) & 1) << 6 |\n                     (ushort)(SUB161(auVar5 >> 0x3f,0) & 1) << 7 |\n                     (ushort)(SUB161(auVar5 >> 0x47,0) & 1) << 8 |\n                     (ushort)(SUB161(auVar5 >> 0x4f,0) & 1) << 9 |\n                     (ushort)(SUB161(auVar5 >> 0x57,0) & 1) << 10 |\n                     (ushort)(SUB161(auVar5 >> 0x5f,0) & 1) << 0xb |\n                     (ushort)(SUB161(auVar5 >> 0x67,0) & 1) << 0xc |\n                     (ushort)(SUB161(auVar5 >> 0x6f,0) & 1) << 0xd |\n                     (ushort)((byte)(auVar5._14_2_ >> 7) & 1) << 0xe | auVar5._14_2_ & 0x8000) != 0)\n        break;\n      }\n      for (; (pauVar3 != (undefined (*) [32])(*param_1 + param_2 * 2) && (*(short *)*pauVar3 != 0));\n          pauVar3 = (undefined (*) [32])(*pauVar3 + 2)) {\n      }\n    }\n    else if (param_1 != (undefined (*) [32])(*param_1 + param_2 * 2)) {\n      do {\n        if (*(short *)*pauVar3 == 0) break;\n        pauVar3 = (undefined (*) [32])(*pauVar3 + 2);\n      } while (pauVar3 != (undefined (*) [32])(*param_1 + param_2 * 2));\n    }\n  }\n  else if (((ulonglong)param_1 & 1) == 0) {\n    uVar4 = (ulonglong)((uint)param_1 & 0x1f);\n    uVar4 = (-(ulonglong)(uVar4 != 0) & 0x20 - uVar4) >> 1;\n    if (param_2 < uVar4) {\n      uVar4 = param_2;\n    }\n    if (param_1 != (undefined (*) [32])(*param_1 + uVar4 * 2)) {\n      do {\n        if (*(short *)*pauVar3 == 0) break;\n        pauVar3 = (undefined (*) [32])(*pauVar3 + 2);\n      } while (pauVar3 != (undefined (*) [32])(*param_1 + uVar4 * 2));\n    }\n    uVar2 = (longlong)pauVar3 - (longlong)param_1 >> 1;\n    if (uVar2 != uVar4) {\n      return uVar2;\n    }\n    pauVar3 = (undefined (*) [32])(*param_1 + uVar2 * 2);\n    while ((pauVar3 !=\n            (undefined (*) [32])(*param_1 + ((param_2 - uVar4 & 0xffffffffffffffe0) + uVar2) * 2) &&\n           (auVar1 = vpcmpeqw_avx2(SUB6432(ZEXT1664((undefined  [16])0x0),0),*pauVar3),\n           ((uint)(SUB321(auVar1 >> 7,0) & 1) | (uint)(SUB321(auVar1 >> 0xf,0) & 1) << 1 |\n            (uint)(SUB321(auVar1 >> 0x17,0) & 1) << 2 | (uint)(SUB321(auVar1 >> 0x1f,0) & 1) << 3 |\n            (uint)(SUB321(auVar1 >> 0x27,0) & 1) << 4 | (uint)(SUB321(auVar1 >> 0x2f,0) & 1) << 5 |\n            (uint)(SUB321(auVar1 >> 0x37,0) & 1) << 6 | (uint)(SUB321(auVar1 >> 0x3f,0) & 1) << 7 |\n            (uint)(SUB321(auVar1 >> 0x47,0) & 1) << 8 | (uint)(SUB321(auVar1 >> 0x4f,0) & 1) << 9 |\n            (uint)(SUB321(auVar1 >> 0x57,0) & 1) << 10 | (uint)(SUB321(auVar1 >> 0x5f,0) & 1) << 0xb\n            | (uint)(SUB321(auVar1 >> 0x67,0) & 1) << 0xc |\n            (uint)(SUB321(auVar1 >> 0x6f,0) & 1) << 0xd |\n            (uint)(SUB321(auVar1 >> 0x77,0) & 1) << 0xe | (uint)SUB321(auVar1 >> 0x7f,0) << 0xf |\n            (uint)(SUB321(auVar1 >> 0x87,0) & 1) << 0x10 |\n            (uint)(SUB321(auVar1 >> 0x8f,0) & 1) << 0x11 |\n            (uint)(SUB321(auVar1 >> 0x97,0) & 1) << 0x12 |\n            (uint)(SUB321(auVar1 >> 0x9f,0) & 1) << 0x13 |\n            (uint)(SUB321(auVar1 >> 0xa7,0) & 1) << 0x14 |\n            (uint)(SUB321(auVar1 >> 0xaf,0) & 1) << 0x15 |\n            (uint)(SUB321(auVar1 >> 0xb7,0) & 1) << 0x16 | (uint)SUB321(auVar1 >> 0xbf,0) << 0x17 |\n            (uint)(SUB321(auVar1 >> 199,0) & 1) << 0x18 |\n            (uint)(SUB321(auVar1 >> 0xcf,0) & 1) << 0x19 |\n            (uint)(SUB321(auVar1 >> 0xd7,0) & 1) << 0x1a |\n            (uint)(SUB321(auVar1 >> 0xdf,0) & 1) << 0x1b |\n            (uint)(SUB321(auVar1 >> 0xe7,0) & 1) << 0x1c |\n            (uint)(SUB321(auVar1 >> 0xef,0) & 1) << 0x1d |\n            (uint)(SUB321(auVar1 >> 0xf7,0) & 1) << 0x1e | (uint)(byte)(auVar1[0x1f] >> 7) << 0x1f)\n           == 0))) {\n      pauVar3 = pauVar3 + 1;\n    }\n    for (; (pauVar3 != (undefined (*) [32])(*param_1 + param_2 * 2) && (*(short *)*pauVar3 != 0));\n        pauVar3 = (undefined (*) [32])(*pauVar3 + 2)) {\n    }\n  }\n  else if (param_1 != (undefined (*) [32])(*param_1 + param_2 * 2)) {\n    do {\n      if (*(short *)*pauVar3 == 0) break;\n      pauVar3 = (undefined (*) [32])(*pauVar3 + 2);\n    } while (pauVar3 != (undefined (*) [32])(*param_1 + param_2 * 2));\n  }\n  return (longlong)pauVar3 - (longlong)param_1 >> 1;\n}\n\n",
  "FUN_140014670": "\nvoid FUN_140014670(undefined8 param_1)\n\n{\n  _register_onexit_function(&DAT_140037290,param_1);\n  return;\n}\n\n",
  "DeleteCriticalSection": "\nvoid __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x000140005b70. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  DeleteCriticalSection(lpCriticalSection);\n  return;\n}\n\n",
  "FUN_1400060c4": "\nundefined8 * FUN_1400060c4(undefined8 *param_1,ulonglong param_2)\n\n{\n  *param_1 = type_info::vftable;\n  if ((param_2 & 1) != 0) {\n    thunk_FUN_14000ce08(param_1);\n  }\n  return param_1;\n}\n\n",
  "FUN_140006abc": "\nbool FUN_140006abc(void)\n\n{\n  return DAT_140035030 == 0;\n}\n\n",
  "__acrt_release_locale_ref": "\n/* Library Function - Single Match\n    __acrt_release_locale_ref\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_release_locale_ref(longlong param_1)\n\n{\n  int *piVar1;\n  int **ppiVar2;\n  longlong lVar3;\n  \n  if (param_1 != 0) {\n    LOCK();\n    *(int *)(param_1 + 0x10) = *(int *)(param_1 + 0x10) + -1;\n    UNLOCK();\n    piVar1 = *(int **)(param_1 + 0xe0);\n    if (piVar1 != (int *)0x0) {\n      LOCK();\n      *piVar1 = *piVar1 + -1;\n      UNLOCK();\n    }\n    piVar1 = *(int **)(param_1 + 0xf0);\n    if (piVar1 != (int *)0x0) {\n      LOCK();\n      *piVar1 = *piVar1 + -1;\n      UNLOCK();\n    }\n    piVar1 = *(int **)(param_1 + 0xe8);\n    if (piVar1 != (int *)0x0) {\n      LOCK();\n      *piVar1 = *piVar1 + -1;\n      UNLOCK();\n    }\n    piVar1 = *(int **)(param_1 + 0x100);\n    if (piVar1 != (int *)0x0) {\n      LOCK();\n      *piVar1 = *piVar1 + -1;\n      UNLOCK();\n    }\n    ppiVar2 = (int **)(param_1 + 0x38);\n    lVar3 = 6;\n    do {\n      if ((ppiVar2[-2] != (int *)&DAT_1400353c8) && (piVar1 = *ppiVar2, piVar1 != (int *)0x0)) {\n        LOCK();\n        *piVar1 = *piVar1 + -1;\n        UNLOCK();\n      }\n      if ((ppiVar2[-3] != (int *)0x0) && (piVar1 = ppiVar2[-1], piVar1 != (int *)0x0)) {\n        LOCK();\n        *piVar1 = *piVar1 + -1;\n        UNLOCK();\n      }\n      ppiVar2 = ppiVar2 + 4;\n      lVar3 = lVar3 + -1;\n    } while (lVar3 != 0);\n    __acrt_locale_release_lc_time_reference(*(undefined ***)(param_1 + 0x120));\n  }\n  return;\n}\n\n",
  "__acrt_get_qualified_locale": "\n/* Library Function - Single Match\n    __acrt_get_qualified_locale\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __acrt_get_qualified_locale(ushort *param_1,uint *param_2,LPWSTR param_3)\n\n{\n  ushort **ppuVar1;\n  ushort **ppuVar2;\n  wchar_t *_Src;\n  wchar_t *_Dst;\n  LPWSTR pWVar3;\n  bool bVar4;\n  uint _Val;\n  BOOL BVar5;\n  errno_t eVar6;\n  int iVar7;\n  longlong lVar8;\n  undefined7 extraout_var;\n  ushort *puVar9;\n  longlong lVar10;\n  \n  lVar8 = FUN_140014d84();\n  ppuVar2 = (ushort **)(lVar8 + 0x98);\n  *(undefined4 *)(lVar8 + 0xa8) = 0;\n  _Src = (wchar_t *)(lVar8 + 0x2f0);\n  *ppuVar2 = param_1;\n  ppuVar1 = (ushort **)(lVar8 + 0xa0);\n  *_Src = L'\\0';\n  *ppuVar1 = param_1 + 0x40;\n  puVar9 = param_1;\n  if (param_1[0x40] != 0) {\n    TranslateName(0x14002b200,0x16,ppuVar1);\n    puVar9 = *ppuVar2;\n  }\n  if (*puVar9 == 0) {\n    GetLocaleNameFromDefault((longlong)ppuVar2);\nLAB_14001e338:\n    if (*(int *)(lVar8 + 0xa8) == 0) {\n      return 0;\n    }\n  }\n  else {\n    if (**ppuVar1 == 0) {\n      GetLocaleNameFromLanguage((short **)ppuVar2);\n    }\n    else {\n      GetLocaleNameFromLangCountry((short **)ppuVar2);\n    }\n    if (*(int *)(lVar8 + 0xa8) == 0) {\n      bVar4 = TranslateName(0x14002ade0,0x40,ppuVar2);\n      if ((int)CONCAT71(extraout_var,bVar4) != 0) {\n        if (**ppuVar1 == 0) {\n          GetLocaleNameFromLanguage((short **)ppuVar2);\n        }\n        else {\n          GetLocaleNameFromLangCountry((short **)ppuVar2);\n        }\n      }\n      goto LAB_14001e338;\n    }\n  }\n  if ((*param_1 == 0) && (param_1[0x80] == L'\\0')) {\n    _Val = GetACP();\n  }\n  else {\n    _Val = ProcessCodePage((wchar_t *)(param_1 + 0x80),(longlong)ppuVar2);\n  }\n  if (((_Val != 0) && (_Val != 65000)) && (BVar5 = IsValidCodePage(_Val & 0xffff), BVar5 != 0)) {\n    if (param_2 != (uint *)0x0) {\n      *param_2 = _Val;\n    }\n    if (param_3 == (LPWSTR)0x0) {\n      return 1;\n    }\n    _Dst = param_3 + 0x90;\n    *_Dst = L'\\0';\n    lVar8 = -1;\n    do {\n      lVar10 = lVar8;\n      lVar8 = lVar10 + 1;\n    } while (_Src[lVar8] != L'\\0');\n    eVar6 = wcsncpy_s(_Dst,0x55,_Src,lVar10 + 2);\n    if (eVar6 != 0) {\nLAB_14001e4b6:\n                    /* WARNING: Subroutine does not return */\n      _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    iVar7 = __acrt_GetLocaleInfoEx((ushort *)_Dst,0x1001,param_3,0x40);\n    if (iVar7 != 0) {\n      pWVar3 = param_3 + 0x40;\n      iVar7 = __acrt_GetLocaleInfoEx((ushort *)_Dst,0x1002,pWVar3,0x40);\n      if ((iVar7 != 0) &&\n         (((puVar9 = FUN_140021dd4((ushort *)pWVar3,0x5f), puVar9 == (ushort *)0x0 &&\n           (puVar9 = FUN_140021dd4((ushort *)pWVar3,0x2e), puVar9 == (ushort *)0x0)) ||\n          (iVar7 = __acrt_GetLocaleInfoEx((ushort *)_Dst,7,pWVar3,0x40), iVar7 != 0)))) {\n        if (_Val != 0xfde9) {\n          _itow_s(_Val,param_3 + 0x80,0x10,10);\n          return 1;\n        }\n        eVar6 = wcsncpy_s(param_3 + 0x80,0x10,L\"utf8\",5);\n        if (eVar6 == 0) {\n          return 1;\n        }\n        goto LAB_14001e4b6;\n      }\n    }\n  }\n  return 0;\n}\n\n",
  "_Init_locks": "\n/* Library Function - Single Match\n    public: __cdecl std::_Init_locks::_Init_locks(void) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\n_Init_locks * __thiscall std::_Init_locks::_Init_locks(_Init_locks *this)\n\n{\n  undefined *puVar1;\n  \n  LOCK();\n  DAT_140035000 = DAT_140035000 + 1;\n  UNLOCK();\n  if (DAT_140035000 == 0) {\n    puVar1 = &DAT_140036110;\n    do {\n      FUN_140005b78(puVar1);\n      puVar1 = puVar1 + 0x28;\n    } while (puVar1 != &DAT_140036250);\n  }\n  return this;\n}\n\n",
  "FUN_14000d19c": "\nvoid FUN_14000d19c(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00014000d1a3. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_140036f40);\n  return;\n}\n\n",
  "_ctrlfp": "\n/* Library Function - Single Match\n    _ctrlfp\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nuint _ctrlfp(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar1 = _get_fpsr();\n  uVar2 = (~param_2 | 0xffff807f) & uVar1 | param_1 & param_2;\n  if ((DAT_140035524 == '\\0') || ((uVar2 & 0x40) == 0)) {\n    FUN_14001f6b0(uVar2 & 0xffffffbf);\n  }\n  else {\n    FUN_14001f6b0(uVar2);\n  }\n  return uVar1;\n}\n\n",
  "__acrt_AreFileApisANSI": "\n/* WARNING: Switch with 1 destination removed at 0x000140015541 */\n/* Library Function - Single Match\n    __acrt_AreFileApisANSI\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 __acrt_AreFileApisANSI(void)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  undefined8 uVar1;\n  \n  UNRECOVERED_JUMPTABLE =\n       (code *)try_get_function(0,\"AreFileApisANSI\",(module_id *)&DAT_140028d78,\n                                (module_id *)&DAT_140028d7c);\n  if (UNRECOVERED_JUMPTABLE == (code *)0x0) {\n    return 1;\n  }\n                    /* WARNING: Could not recover jumptable at 0x000140021e60. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  uVar1 = (*UNRECOVERED_JUMPTABLE)();\n  return uVar1;\n}\n\n",
  "initialize_lc_time": "\n/* Library Function - Single Match\n    bool __cdecl initialize_lc_time(struct __crt_lc_time_data * __ptr64 const,struct\n   __crt_locale_data * __ptr64 const)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nbool __cdecl initialize_lc_time(__crt_lc_time_data *param_1,__crt_locale_data *param_2)\n\n{\n  undefined (*pauVar1) [32];\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  wchar_t *pwVar13;\n  uint uVar14;\n  __crt_lc_time_data *p_Var15;\n  longlong lVar16;\n  ulong uVar17;\n  __crt_locale_data *local_38;\n  undefined8 local_30;\n  \n  pauVar1 = *(undefined (**) [32])(param_2 + 0x150);\n  uVar14 = 0;\n  local_30 = 0;\n  local_38 = param_2;\n  pwVar13 = __acrt_copy_locale_name(pauVar1);\n  *(wchar_t **)(param_1 + 0x2b8) = pwVar13;\n  uVar17 = 0x31;\n  lVar16 = 7;\n  do {\n    p_Var15 = param_1 + (ulonglong)((uVar17 - 0x30) % 7) * 8;\n    uVar2 = __acrt_GetLocaleInfoA\n                      ((__crt_locale_pointers *)&local_38,1,(wchar_t *)pauVar1,uVar17,\n                       (LPWSTR *)p_Var15);\n    uVar3 = __acrt_GetLocaleInfoA\n                      ((__crt_locale_pointers *)&local_38,1,(wchar_t *)pauVar1,uVar17 - 7,\n                       (LPWSTR *)(p_Var15 + 0x38));\n    uVar4 = __acrt_GetLocaleInfoA\n                      ((__crt_locale_pointers *)&local_38,2,(wchar_t *)pauVar1,uVar17,\n                       (LPWSTR *)(p_Var15 + 0x160));\n    uVar5 = __acrt_GetLocaleInfoA\n                      ((__crt_locale_pointers *)&local_38,2,(wchar_t *)pauVar1,uVar17 - 7,\n                       (LPWSTR *)(p_Var15 + 0x198));\n    uVar14 = uVar14 | uVar2 | uVar3 | uVar4 | uVar5;\n    uVar17 = uVar17 + 1;\n    lVar16 = lVar16 + -1;\n  } while (lVar16 != 0);\n  uVar17 = 0x38;\n  lVar16 = 0xc;\n  p_Var15 = param_1 + 0xd0;\n  do {\n    uVar2 = __acrt_GetLocaleInfoA\n                      ((__crt_locale_pointers *)&local_38,1,(wchar_t *)pauVar1,uVar17 + 0xc,\n                       (LPWSTR *)(p_Var15 + -0x60));\n    uVar3 = __acrt_GetLocaleInfoA\n                      ((__crt_locale_pointers *)&local_38,1,(wchar_t *)pauVar1,uVar17,\n                       (LPWSTR *)p_Var15);\n    uVar4 = __acrt_GetLocaleInfoA\n                      ((__crt_locale_pointers *)&local_38,2,(wchar_t *)pauVar1,uVar17 + 0xc,\n                       (LPWSTR *)(p_Var15 + 0x100));\n    uVar5 = __acrt_GetLocaleInfoA\n                      ((__crt_locale_pointers *)&local_38,2,(wchar_t *)pauVar1,uVar17,\n                       (LPWSTR *)(p_Var15 + 0x160));\n    uVar14 = uVar14 | uVar2 | uVar3 | uVar4 | uVar5;\n    p_Var15 = p_Var15 + 8;\n    uVar17 = uVar17 + 1;\n    lVar16 = lVar16 + -1;\n  } while (lVar16 != 0);\n  uVar2 = __acrt_GetLocaleInfoA\n                    ((__crt_locale_pointers *)&local_38,1,(wchar_t *)pauVar1,0x28,\n                     (LPWSTR *)(param_1 + 0x130));\n  uVar3 = __acrt_GetLocaleInfoA\n                    ((__crt_locale_pointers *)&local_38,1,(wchar_t *)pauVar1,0x29,\n                     (LPWSTR *)(param_1 + 0x138));\n  uVar4 = __acrt_GetLocaleInfoA\n                    ((__crt_locale_pointers *)&local_38,2,(wchar_t *)pauVar1,0x28,\n                     (LPWSTR *)(param_1 + 0x290));\n  uVar5 = __acrt_GetLocaleInfoA\n                    ((__crt_locale_pointers *)&local_38,2,(wchar_t *)pauVar1,0x29,\n                     (LPWSTR *)(param_1 + 0x298));\n  uVar6 = __acrt_GetLocaleInfoA\n                    ((__crt_locale_pointers *)&local_38,1,(wchar_t *)pauVar1,0x1f,\n                     (LPWSTR *)(param_1 + 0x140));\n  uVar7 = __acrt_GetLocaleInfoA\n                    ((__crt_locale_pointers *)&local_38,1,(wchar_t *)pauVar1,0x20,\n                     (LPWSTR *)(param_1 + 0x148));\n  uVar8 = __acrt_GetLocaleInfoA\n                    ((__crt_locale_pointers *)&local_38,1,(wchar_t *)pauVar1,0x1003,\n                     (LPWSTR *)(param_1 + 0x150));\n  uVar9 = __acrt_GetLocaleInfoA\n                    ((__crt_locale_pointers *)&local_38,0,(wchar_t *)pauVar1,0x1009,\n                     (LPWSTR *)(param_1 + 0x158));\n  uVar10 = __acrt_GetLocaleInfoA\n                     ((__crt_locale_pointers *)&local_38,2,(wchar_t *)pauVar1,0x1f,\n                      (LPWSTR *)(param_1 + 0x2a0));\n  uVar11 = __acrt_GetLocaleInfoA\n                     ((__crt_locale_pointers *)&local_38,2,(wchar_t *)pauVar1,0x20,\n                      (LPWSTR *)(param_1 + 0x2a8));\n  uVar12 = __acrt_GetLocaleInfoA\n                     ((__crt_locale_pointers *)&local_38,2,(wchar_t *)pauVar1,0x1003,\n                      (LPWSTR *)(param_1 + 0x2b0));\n  return (uVar12 | uVar14 | uVar2 | uVar3 | uVar4 | uVar5 | uVar6 | uVar7 | uVar8 | uVar9 | uVar10 |\n                   uVar11) == 0;\n}\n\n",
  "__AdjustPointer": "\n/* Library Function - Single Match\n    __AdjustPointer\n   \n   Library: Visual Studio 2019 Release */\n\nlonglong __AdjustPointer(longlong param_1,int *param_2)\n\n{\n  longlong lVar1;\n  \n  lVar1 = *param_2 + param_1;\n  if (-1 < param_2[1]) {\n    lVar1 = lVar1 + (longlong)*(int *)((longlong)param_2[2] + *(longlong *)(param_2[1] + param_1)) +\n                    (longlong)param_2[1];\n  }\n  return lVar1;\n}\n\n",
  "__InternalCxxFrameHandler<class___FrameHandler3>": "\n/* Library Function - Single Match\n    enum _EXCEPTION_DISPOSITION __cdecl __InternalCxxFrameHandler<class __FrameHandler3>(struct\n   EHExceptionRecord * __ptr64,unsigned __int64 * __ptr64,struct _CONTEXT * __ptr64,struct\n   _xDISPATCHER_CONTEXT * __ptr64,struct _s_FuncInfo const * __ptr64,int,unsigned __int64 *\n   __ptr64,unsigned char)\n   \n   Library: Visual Studio 2019 Release */\n\n_EXCEPTION_DISPOSITION __cdecl\n__InternalCxxFrameHandler<class___FrameHandler3>\n          (EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n          _xDISPATCHER_CONTEXT *param_4,_s_FuncInfo *param_5,int param_6,__uint64 *param_7,\n          uchar param_8)\n\n{\n  int iVar1;\n  _EXCEPTION_DISPOSITION _Var2;\n  longlong lVar3;\n  bool bVar4;\n  undefined8 in_stack_ffffffffffffffe0;\n  undefined4 uVar5;\n  \n  uVar5 = (undefined4)((ulonglong)in_stack_ffffffffffffffe0 >> 0x20);\n  __except_validate_context_record((longlong)param_3);\n  lVar3 = FUN_140008b20();\n  if ((*(int *)(lVar3 + 0x40) == 0) && (*(int *)param_1 != -0x1f928c9d)) {\n    if (*(int *)param_1 == -0x7fffffd7) {\n      if (*(int *)(param_1 + 0x18) == 0xf) {\n        bVar4 = *(longlong *)(param_1 + 0x60) == 0x19930520;\n        goto LAB_14000a79c;\n      }\n    }\n    else {\n      bVar4 = *(int *)param_1 == -0x7fffffda;\nLAB_14000a79c:\n      if (bVar4) goto LAB_14000a7b6;\n    }\n    if ((0x19930521 < (param_5->magicNumber_and_bbtFlags & 0x1fffffff)) &&\n       ((*(byte *)&param_5->EHFlags & 1) != 0)) {\n      return ExceptionContinueSearch;\n    }\n  }\nLAB_14000a7b6:\n  if (((byte)param_1[4] & 0x66) == 0) {\n    if ((param_5->nTryBlocks == 0) &&\n       ((((param_5->magicNumber_and_bbtFlags & 0x1fffffff) < 0x19930521 ||\n         (param_5->dispESTypeList == 0)) ||\n        (lVar3 = _GetImageBase(), lVar3 + (int)param_5->dispESTypeList == 0)))) {\n      if ((param_5->magicNumber_and_bbtFlags & 0x1fffffff) < 0x19930522) {\n        return ExceptionContinueSearch;\n      }\n      if (((uint)param_5->EHFlags >> 2 & 1) == 0) {\n        return ExceptionContinueSearch;\n      }\n    }\n    if (((*(int *)param_1 == -0x1f928c9d) && (2 < *(uint *)(param_1 + 0x18))) &&\n       ((0x19930522 < *(uint *)(param_1 + 0x20) &&\n        ((*(int *)(*(longlong *)(param_1 + 0x30) + 8) != 0 &&\n         (lVar3 = _GetThrowImageBase(), lVar3 + *(int *)(*(longlong *)(param_1 + 0x30) + 8) != 0))))\n       )) {\n      _Var2 = (*(code *)PTR__guard_dispatch_icall_140023298)\n                        (param_1,param_2,param_3,param_4,param_5,param_6,param_7,\n                         CONCAT44(uVar5,(uint)param_8));\n      return _Var2;\n    }\n    FUN_1400095e4(param_1,(PVOID *)param_2,param_3,param_4,param_5,param_8,param_6,param_7);\n    return ExceptionContinueSearch;\n  }\n  if (param_5->maxState == 0) {\n    return ExceptionContinueSearch;\n  }\n  if (param_6 != 0) {\n    return ExceptionContinueSearch;\n  }\n  if (((byte)param_1[4] & 0x20) == 0) {\nLAB_14000a83b:\n    __FrameHandler3::FrameUnwindToEmptyState(param_2,param_4,param_5);\n  }\n  else {\n    if (*(int *)param_1 == -0x7fffffda) {\n      iVar1 = FUN_140008d64((longlong)param_5,(longlong)param_4,*(ulonglong *)(param_4 + 0x20));\n      if ((iVar1 < -1) || (param_5->maxState <= iVar1)) {\nLAB_14000a965:\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n    }\n    else {\n      if (*(int *)param_1 != -0x7fffffd7) goto LAB_14000a83b;\n      iVar1 = *(int *)(param_1 + 0x38);\n      if ((iVar1 < -1) || (param_5->maxState <= iVar1)) goto LAB_14000a965;\n      param_2 = *(__uint64 **)(param_1 + 0x28);\n    }\n    __FrameHandler3::FrameUnwindToState(param_2,param_4,param_5,iVar1);\n  }\n  return ExceptionContinueSearch;\n}\n\n",
  "FUN_140002680": "\nlonglong * FUN_140002680(longlong *param_1,undefined8 *param_2,ulonglong param_3)\n\n{\n  longlong lVar1;\n  ulonglong uVar2;\n  longlong *plVar3;\n  \n  lVar1 = param_1[2];\n  uVar2 = param_1[3];\n  if (param_3 <= uVar2 - lVar1) {\n    param_1[2] = lVar1 + param_3;\n    plVar3 = param_1;\n    if (0xf < uVar2) {\n      plVar3 = (longlong *)*param_1;\n    }\n    FUN_140007ed0((undefined8 *)((longlong)plVar3 + lVar1),param_2,param_3);\n    *(undefined *)((longlong)plVar3 + lVar1 + param_3) = 0;\n    return param_1;\n  }\n  plVar3 = FUN_140002b30(param_1,param_3,uVar2,param_2,param_3);\n  return plVar3;\n}\n\n",
  "_GetImageBase": "\n/* Library Function - Single Match\n    _GetImageBase\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 _GetImageBase(void)\n\n{\n  longlong lVar1;\n  \n  lVar1 = FUN_140008b20();\n  return *(undefined8 *)(lVar1 + 0x60);\n}\n\n",
  "FUN_140001470": "\nvoid FUN_140001470(char *****param_1,undefined8 *param_2,undefined8 *param_3)\n\n{\n  ulonglong uVar1;\n  ulonglong uVar2;\n  code *pcVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  char ******ppppppcVar7;\n  char *******pppppppcVar8;\n  ulonglong uVar9;\n  undefined auStack_d8 [32];\n  char ******local_b8;\n  undefined4 uStack_b0;\n  undefined4 uStack_ac;\n  ulonglong local_a8;\n  ulonglong uStack_a0;\n  char ******local_98;\n  char ******local_90;\n  undefined8 uStack_88;\n  ulonglong local_80;\n  ulonglong uStack_78;\n  char ******local_68;\n  undefined4 uStack_60;\n  undefined4 uStack_5c;\n  ulonglong local_58;\n  ulonglong local_50;\n  ulonglong local_48;\n  \n  local_48 = DAT_140035020 ^ (ulonglong)auStack_d8;\n  pppppppcVar8 = (char *******)0x0;\n  local_b8 = (char ******)0x0;\n  local_a8 = 0;\n  uStack_a0 = 0;\n  uVar2 = param_3[2];\n  if (0xf < (ulonglong)param_3[3]) {\n    param_3 = (undefined8 *)*param_3;\n  }\n  if (uVar2 < 0x10) {\n    local_b8 = (char ******)*param_3;\n    uStack_b0 = *(undefined4 *)(param_3 + 1);\n    uStack_ac = *(undefined4 *)((longlong)param_3 + 0xc);\n    uVar9 = 0xf;\n  }\n  else {\n    uVar9 = uVar2 | 0xf;\n    if (0x7fffffffffffffff < uVar9) {\n      uVar9 = 0x7fffffffffffffff;\n    }\n    uVar1 = uVar9 + 1;\n    local_98 = (char ******)param_1;\n    if (uVar1 < 0x1000) {\n      if (uVar1 != 0) {\n        pppppppcVar8 = (char *******)operator_new(uVar1);\n      }\n    }\n    else {\n      if (uVar9 + 0x28 <= uVar1) {\n        FUN_1400012e0();\n        goto LAB_1400016c6;\n      }\n      ppppppcVar7 = (char ******)operator_new(uVar9 + 0x28);\n      if (ppppppcVar7 == (char ******)0x0) goto LAB_1400016ba;\n      pppppppcVar8 = (char *******)((longlong)ppppppcVar7 + 0x27U & 0xffffffffffffffe0);\n      pppppppcVar8[-1] = ppppppcVar7;\n    }\n    local_b8 = (char ******)pppppppcVar8;\n    FUN_140007ed0(pppppppcVar8,param_3,uVar2 + 1);\n  }\n  local_98 = (char ******)&local_b8;\n  local_68 = (char ******)*param_2;\n  uStack_60 = *(undefined4 *)(param_2 + 1);\n  uStack_5c = *(undefined4 *)((longlong)param_2 + 0xc);\n  local_a8 = uVar2;\n  uStack_a0 = uVar9;\n  if (uVar2 != 0) {\n    FUN_140002680((longlong *)&local_b8,(undefined8 *)&DAT_140030388,2);\n  }\n  (**(code **)(*(longlong *)CONCAT44(uStack_5c,uStack_60) + 0x10))\n            ((longlong *)CONCAT44(uStack_5c,uStack_60),&local_68,(ulonglong)local_68 & 0xffffffff);\n  pppppppcVar8 = &local_68;\n  if (0xf < local_50) {\n    pppppppcVar8 = (char *******)local_68;\n  }\n  FUN_140002680((longlong *)&local_b8,pppppppcVar8,local_58);\n  if (0xf < local_50) {\n    pppppppcVar8 = (char *******)local_68;\n    if ((0xfff < local_50 + 1) &&\n       (pppppppcVar8 = (char *******)local_68[-1],\n       0x1f < (ulonglong)((longlong)local_68 + (-8 - (longlong)pppppppcVar8)))) {\nLAB_1400016c6:\n      FUN_14000d050();\n      pcVar3 = (code *)swi(3);\n      (*pcVar3)();\n      return;\n    }\n    thunk_FUN_14000ce08(pppppppcVar8);\n  }\n  uVar2 = uStack_a0;\n  ppppppcVar7 = local_b8;\n  uStack_88 = CONCAT44(uStack_ac,uStack_b0);\n  local_90 = local_b8;\n  local_80 = local_a8;\n  uStack_78 = uStack_a0;\n  local_a8 = 0;\n  uStack_a0 = 0xf;\n  local_b8 = (char ******)((ulonglong)local_b8 & 0xffffffffffffff00);\n  local_68 = (char ******)&local_90;\n  if (0xf < uVar2) {\n    local_68 = ppppppcVar7;\n  }\n  *param_1 = (char ****)std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  uStack_60 = CONCAT31(uStack_60._1_3_,1);\n  __std_exception_copy((char **)&local_68,(char **)(param_1 + 1));\n  *param_1 = (char ****)std::runtime_error::vftable;\n  if (0xf < uStack_78) {\n    pppppppcVar8 = (char *******)local_90;\n    if ((0xfff < uStack_78 + 1) &&\n       (pppppppcVar8 = (char *******)local_90[-1],\n       0x1f < (ulonglong)((longlong)local_90 + (-8 - (longlong)pppppppcVar8)))) {\nLAB_1400016ba:\n      FUN_14000d050();\n      pcVar3 = (code *)swi(3);\n      (*pcVar3)();\n      return;\n    }\n    thunk_FUN_14000ce08(pppppppcVar8);\n  }\n  *param_1 = (char ****)std::_System_error::vftable;\n  uVar4 = *(undefined4 *)((longlong)param_2 + 4);\n  uVar5 = *(undefined4 *)(param_2 + 1);\n  uVar6 = *(undefined4 *)((longlong)param_2 + 0xc);\n  *(undefined4 *)(param_1 + 3) = *(undefined4 *)param_2;\n  *(undefined4 *)((longlong)param_1 + 0x1c) = uVar4;\n  *(undefined4 *)(param_1 + 4) = uVar5;\n  *(undefined4 *)((longlong)param_1 + 0x24) = uVar6;\n  FUN_140006060(local_48 ^ (ulonglong)auStack_d8);\n  return;\n}\n\n",
  "FUN_140006cf4": "\nvoid FUN_140006cf4(void)\n\n{\n  longlong *plVar1;\n  \n  for (plVar1 = &DAT_140031a88; plVar1 < &DAT_140031a88; plVar1 = plVar1 + 1) {\n    if (*plVar1 != 0) {\n      (*(code *)PTR__guard_dispatch_icall_140023298)();\n    }\n  }\n  return;\n}\n\n",
  "FUN_140004508": "\nvoid FUN_140004508(longlong param_1,uint param_2)\n\n{\n  undefined8 *puVar1;\n  uint uVar2;\n  char *pcVar3;\n  undefined4 local_48 [4];\n  char ****local_38 [6];\n  \n  *(uint *)(param_1 + 0x10) = param_2 & 0x17;\n  uVar2 = param_2 & 0x17 & *(uint *)(param_1 + 0x14);\n  if (uVar2 == 0) {\n    return;\n  }\n  if ((uVar2 & 4) == 0) {\n    pcVar3 = \"ios_base::failbit set\";\n    if ((uVar2 & 2) == 0) {\n      pcVar3 = \"ios_base::eofbit set\";\n    }\n  }\n  else {\n    pcVar3 = \"ios_base::badbit set\";\n  }\n  puVar1 = (undefined8 *)FUN_140001450(local_48,1);\n  FUN_140001dd0(local_38,(undefined8 *)pcVar3,puVar1);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_38,(ThrowInfo *)&DAT_140033c40);\n}\n\n",
  "thunk_FUN_14000ce08": "\nvoid thunk_FUN_14000ce08(LPVOID param_1)\n\n{\n  _free_base(param_1);\n  return;\n}\n\n",
  "FUN_140007ddc": "\nlonglong FUN_140007ddc(void)\n\n{\n  longlong lVar1;\n  \n  lVar1 = FUN_140008b20();\n  return lVar1 + 0x28;\n}\n\n",
  "__acrt_locale_free_time": "\n/* Library Function - Single Match\n    __acrt_locale_free_time\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_locale_free_time(void **param_1)\n\n{\n  if (param_1 != (void **)0x0) {\n    free_crt_array_internal(param_1,7);\n    free_crt_array_internal(param_1 + 7,7);\n    free_crt_array_internal(param_1 + 0xe,0xc);\n    free_crt_array_internal(param_1 + 0x1a,0xc);\n    free_crt_array_internal(param_1 + 0x26,2);\n    _free_base(param_1[0x28]);\n    _free_base(param_1[0x29]);\n    _free_base(param_1[0x2a]);\n    free_crt_array_internal(param_1 + 0x2c,7);\n    free_crt_array_internal(param_1 + 0x33,7);\n    free_crt_array_internal(param_1 + 0x3a,0xc);\n    free_crt_array_internal(param_1 + 0x46,0xc);\n    free_crt_array_internal(param_1 + 0x52,2);\n    _free_base(param_1[0x54]);\n    _free_base(param_1[0x55]);\n    _free_base(param_1[0x56]);\n    _free_base(param_1[0x57]);\n  }\n  return;\n}\n\n",
  "FUN_1400129c4": "\nundefined * FUN_1400129c4(void)\n\n{\n  return &DAT_140037258;\n}\n\n",
  "FID_conflict:`scalar_deleting_destructor'": "\n/* Library Function - Multiple Matches With Different Base Names\n    public: virtual void * __ptr64 __cdecl std::basic_ostream<char,struct std::char_traits<char>\n   >::`scalar deleting destructor'(unsigned int) __ptr64\n    public: virtual void * __ptr64 __cdecl std::basic_ostream<unsigned short,struct\n   std::char_traits<unsigned short> >::`scalar deleting destructor'(unsigned int) __ptr64\n    public: virtual void * __ptr64 __cdecl std::basic_ostream<wchar_t,struct\n   std::char_traits<wchar_t> >::`scalar deleting destructor'(unsigned int) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nios_base * FID_conflict__scalar_deleting_destructor_(ios_base *param_1,uint param_2)\n\n{\n  ios_base *piVar1;\n  \n  piVar1 = param_1 + -0x10;\n  *(undefined ***)(param_1 + (longlong)*(int *)(*(longlong *)piVar1 + 4) + -0x10) =\n       std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;\n  *(int *)(param_1 + (longlong)*(int *)(*(longlong *)piVar1 + 4) + -0x14) =\n       *(int *)(*(longlong *)piVar1 + 4) + -0x10;\n  *(undefined ***)param_1 = std::ios_base::vftable;\n  std::ios_base::_Ios_base_dtor(param_1);\n  if ((param_2 & 1) != 0) {\n    thunk_FUN_14000ce08(piVar1);\n  }\n  return piVar1;\n}\n\n",
  "_clrfp": "\n/* Library Function - Single Match\n    _clrfp\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nuint _clrfp(void)\n\n{\n  uint uVar1;\n  \n  uVar1 = _get_fpsr();\n  _fclrf();\n  return uVar1 & 0x3f;\n}\n\n",
  "_Locinfo": "\n/* Library Function - Single Match\n    public: __cdecl std::_Locinfo::_Locinfo(char const * __ptr64) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\n_Locinfo * __thiscall std::_Locinfo::_Locinfo(_Locinfo *this,char *param_1)\n\n{\n  code *pcVar1;\n  _Locinfo *p_Var2;\n  \n  _Lockit::_Lockit((_Lockit *)this,0);\n  *(undefined8 *)(this + 8) = 0;\n  this[0x10] = (_Locinfo)0x0;\n  *(undefined8 *)(this + 0x18) = 0;\n  this[0x20] = (_Locinfo)0x0;\n  *(undefined8 *)(this + 0x28) = 0;\n  *(undefined2 *)(this + 0x30) = 0;\n  *(undefined8 *)(this + 0x38) = 0;\n  *(undefined2 *)(this + 0x40) = 0;\n  *(undefined8 *)(this + 0x48) = 0;\n  this[0x50] = (_Locinfo)0x0;\n  *(undefined8 *)(this + 0x58) = 0;\n  this[0x60] = (_Locinfo)0x0;\n  if (param_1 != (char *)0x0) {\n    _Locinfo_ctor(this,param_1);\n    return this;\n  }\n  _Xruntime_error(\"bad locale name\");\n  pcVar1 = (code *)swi(3);\n  p_Var2 = (_Locinfo *)(*pcVar1)();\n  return p_Var2;\n}\n\n",
  "_set_fmode": "\n/* Library Function - Single Match\n    _set_fmode\n   \n   Library: Visual Studio 2012 Release */\n\nerrno_t __cdecl _set_fmode(int _Mode)\n\n{\n  errno_t eVar1;\n  ulong *puVar2;\n  \n  if (((_Mode - 0x4000U & 0xffff3fff) == 0) && (_Mode != 0xc000)) {\n    LOCK();\n    UNLOCK();\n    eVar1 = 0;\n    DAT_1400379d0 = _Mode;\n  }\n  else {\n    puVar2 = __doserrno();\n    *puVar2 = 0x16;\n    FUN_14000d030();\n    eVar1 = 0x16;\n  }\n  return eVar1;\n}\n\n",
  "_raise_exc_ex": "\n/* Library Function - Single Match\n    _raise_exc_ex\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _raise_exc_ex(uint *param_1,ulonglong *param_2,ulonglong param_3,uint param_4,uint *param_5,\n                  uint *param_6,int param_7)\n\n{\n  uint uVar1;\n  DWORD dwExceptionCode;\n  uint *local_res8;\n  \n  dwExceptionCode = 0xc000000d;\n  param_1[1] = 0;\n  param_1[2] = 0;\n  param_1[3] = 0;\n  if ((param_3 & 0x10) != 0) {\n    dwExceptionCode = 0xc000008f;\n    param_1[1] = param_1[1] | 1;\n  }\n  if ((param_3 & 2) != 0) {\n    dwExceptionCode = 0xc0000093;\n    param_1[1] = param_1[1] | 2;\n  }\n  if ((param_3 & 1) != 0) {\n    dwExceptionCode = 0xc0000091;\n    param_1[1] = param_1[1] | 4;\n  }\n  if ((param_3 & 4) != 0) {\n    dwExceptionCode = 0xc000008e;\n    param_1[1] = param_1[1] | 8;\n  }\n  if ((param_3 & 8) != 0) {\n    dwExceptionCode = 0xc0000090;\n    param_1[1] = param_1[1] | 0x10;\n  }\n  param_1[2] = param_1[2] ^ (~((int)(*param_2 >> 7) << 4) ^ param_1[2]) & 0x10;\n  param_1[2] = param_1[2] ^ (~((int)(*param_2 >> 9) << 3) ^ param_1[2]) & 8;\n  param_1[2] = param_1[2] ^ (~((int)(*param_2 >> 10) << 2) ^ param_1[2]) & 4;\n  param_1[2] = param_1[2] ^ (~((int)(*param_2 >> 0xb) * 2) ^ param_1[2]) & 2;\n  param_1[2] = param_1[2] ^ (~(*(uint *)param_2 >> 0xc) ^ param_1[2]) & 1;\n  local_res8 = param_1;\n  uVar1 = _statfp();\n  if ((uVar1 & 1) != 0) {\n    local_res8[3] = local_res8[3] | 0x10;\n  }\n  if ((uVar1 & 4) != 0) {\n    local_res8[3] = local_res8[3] | 8;\n  }\n  if ((uVar1 & 8) != 0) {\n    local_res8[3] = local_res8[3] | 4;\n  }\n  if ((uVar1 & 0x10) != 0) {\n    local_res8[3] = local_res8[3] | 2;\n  }\n  if ((uVar1 & 0x20) != 0) {\n    local_res8[3] = local_res8[3] | 1;\n  }\n  uVar1 = *(uint *)param_2 & 0x6000;\n  if ((*(uint *)param_2 & 0x6000) == 0) {\n    *local_res8 = *local_res8 & 0xfffffffc;\n  }\n  else if (uVar1 == 0x2000) {\n    *local_res8 = *local_res8 & 0xfffffffd;\n    *local_res8 = *local_res8 | 1;\n  }\n  else if (uVar1 == 0x4000) {\n    *local_res8 = *local_res8 & 0xfffffffe;\n    *local_res8 = *local_res8 | 2;\n  }\n  else if (uVar1 == 0x6000) {\n    *local_res8 = *local_res8 | 3;\n  }\n  *local_res8 = *local_res8 & 0xfffe001f;\n  *local_res8 = *local_res8 | (param_4 & 0xfff) << 5;\n  local_res8[8] = local_res8[8] | 1;\n  if (param_7 == 0) {\n    local_res8[8] = local_res8[8] & 0xffffffe3 | 2;\n    *(undefined8 *)(local_res8 + 4) = *(undefined8 *)param_5;\n    local_res8[0x18] = local_res8[0x18] | 1;\n    local_res8[0x18] = local_res8[0x18] & 0xffffffe3 | 2;\n    *(undefined8 *)(local_res8 + 0x14) = *(undefined8 *)param_6;\n  }\n  else {\n    local_res8[8] = local_res8[8] & 0xffffffe1;\n    local_res8[4] = *param_5;\n    local_res8[0x18] = local_res8[0x18] | 1;\n    local_res8[0x18] = local_res8[0x18] & 0xffffffe1;\n    local_res8[0x14] = *param_6;\n  }\n  _clrfp();\n  RaiseException(dwExceptionCode,0,1,(ULONG_PTR *)&local_res8);\n  uVar1 = local_res8[2];\n  if ((uVar1 & 0x10) != 0) {\n    *param_2 = *param_2 & 0xffffffffffffff7f;\n    uVar1 = local_res8[2];\n  }\n  if ((uVar1 & 8) != 0) {\n    *param_2 = *param_2 & 0xfffffffffffffdff;\n    uVar1 = local_res8[2];\n  }\n  if ((uVar1 & 4) != 0) {\n    *param_2 = *param_2 & 0xfffffffffffffbff;\n    uVar1 = local_res8[2];\n  }\n  if ((uVar1 & 2) != 0) {\n    *param_2 = *param_2 & 0xfffffffffffff7ff;\n    uVar1 = local_res8[2];\n  }\n  if ((uVar1 & 1) != 0) {\n    *param_2 = *param_2 & 0xffffffffffffefff;\n  }\n  uVar1 = *local_res8 & 3;\n  if (uVar1 == 0) {\n    *param_2 = *param_2 & 0xffffffffffff9fff;\n  }\n  else if (uVar1 == 1) {\n    *param_2 = *param_2 & 0xffffffffffffbfff;\n    *param_2 = *param_2 | 0x2000;\n  }\n  else if (uVar1 == 2) {\n    *param_2 = *param_2 & 0xffffffffffffdfff;\n    *param_2 = *param_2 | 0x4000;\n  }\n  else if (uVar1 == 3) {\n    *param_2 = *param_2 | 0x6000;\n  }\n  if (param_7 == 0) {\n    *(undefined8 *)param_6 = *(undefined8 *)(local_res8 + 0x14);\n  }\n  else {\n    *param_6 = local_res8[0x14];\n  }\n  return;\n}\n\n",
  "fflush": "\n/* Library Function - Single Match\n    fflush\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl fflush(FILE *_File)\n\n{\n  uint uVar1;\n  int iVar2;\n  __crt_seh_guarded_call<int> local_res8 [8];\n  FILE *local_res10;\n  FILE *local_res18;\n  FILE **local_res20;\n  FILE *local_18 [3];\n  \n  local_res10 = _File;\n  if (_File == (FILE *)0x0) {\n    iVar2 = common_flush_all(false);\n  }\n  else {\n    uVar1 = *(uint *)((longlong)&_File->_base + 4);\n    if (((((byte)uVar1 & 3) == 2) && ((uVar1 & 0xc0) != 0)) || ((uVar1 >> 0xb & 1) != 0)) {\n      local_res20 = &local_res10;\n      local_res18 = _File;\n      local_18[0] = _File;\n      iVar2 = __crt_seh_guarded_call<int>::\n              operator()<class_<lambda_c376a267cfb53b6959b3b692ec76b120>,class_<lambda_9a32fed5bf61b6b509b2d3f6003082a1>&___ptr64,class_<lambda_572fbb9fa0ab338edf41edfd4b5fcc8d>_>\n                        (local_res8,(<lambda_c376a267cfb53b6959b3b692ec76b120> *)local_18,\n                         (<lambda_9a32fed5bf61b6b509b2d3f6003082a1> *)&local_res20,\n                         (<lambda_572fbb9fa0ab338edf41edfd4b5fcc8d> *)&local_res18);\n    }\n    else {\n      iVar2 = 0;\n    }\n  }\n  return iVar2;\n}\n\n",
  "_Toupper": "\n/* Library Function - Single Match\n    _Toupper\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _Toupper(int param_1,_Ctypevec *param_2)\n\n{\n  UINT _CchDest;\n  int iVar1;\n  wchar_t **ppwVar2;\n  ushort *puVar3;\n  uint uVar4;\n  uint uVar5;\n  _locale_t _Plocinfo;\n  BOOL unaff_R14D;\n  undefined local_res10;\n  undefined local_res11;\n  undefined local_res12;\n  byte local_res18;\n  undefined local_res19;\n  undefined4 in_stack_ffffffffffffffd4;\n  \n  if (param_2 == (_Ctypevec *)0x0) {\n    ppwVar2 = ___lc_locale_name_func();\n    _Plocinfo = (_locale_t)ppwVar2[2];\n    _CchDest = ___lc_codepage_func();\n  }\n  else {\n    _Plocinfo = (_locale_t)param_2->_LocaleName;\n    _CchDest = param_2->_Page;\n  }\n  if (_Plocinfo == (_locale_t)0x0) {\n    if (0x19 < param_1 - 0x61U) {\n      return param_1;\n    }\n    return param_1 + -0x20;\n  }\n  uVar5 = 2;\n  if ((uint)param_1 < 0x100) {\n    if (param_2 != (_Ctypevec *)0x0) {\n      if ((*(byte *)(param_2->_Table + param_1) & 2) == 0) {\n        return param_1;\n      }\n      goto LAB_140005aaf;\n    }\n    iVar1 = islower(param_1);\n    if (iVar1 == 0) {\n      return param_1;\n    }\n  }\n  else {\nLAB_140005aaf:\n    if (param_2 != (_Ctypevec *)0x0) {\n      uVar4 = (uint)(int)param_2->_Table[(longlong)param_1 >> 8 & 0xff] >> 0xf & 1;\n      goto LAB_140005ae8;\n    }\n  }\n  puVar3 = __pctype_func();\n  uVar4 = puVar3[param_1 >> 8 & 0xff] & 0x8000;\nLAB_140005ae8:\n  if (uVar4 == 0) {\n    uVar5 = 1;\n    local_res11 = 0;\n    local_res10 = (char)param_1;\n  }\n  else {\n    local_res12 = 0;\n    local_res10 = (char)((uint)param_1 >> 8);\n    local_res11 = (char)param_1;\n  }\n  iVar1 = __crtLCMapStringA(_Plocinfo,(LPCWSTR)0x200,(DWORD)&local_res10,(LPCSTR)(ulonglong)uVar5,\n                            (int)&local_res18,(LPSTR)CONCAT44(in_stack_ffffffffffffffd4,3),_CchDest,\n                            1,unaff_R14D);\n  if ((iVar1 != 0) && (param_1 = (int)local_res18, iVar1 != 1)) {\n    param_1 = (int)CONCAT11(local_res18,local_res19);\n  }\n  return param_1;\n}\n\n",
  "FUN_1400226a1": "\nvoid FUN_1400226a1(undefined8 param_1,longlong param_2)\n\n{\n  FUN_14000d390(*(longlong *)(param_2 + 0x48));\n  return;\n}\n\n",
  "uflow": "\n/* Library Function - Single Match\n    protected: virtual int __cdecl std::basic_streambuf<char,struct std::char_traits<char>\n   >::uflow(void) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __thiscall\nstd::basic_streambuf<char,struct_std::char_traits<char>_>::uflow\n          (basic_streambuf<char,struct_std::char_traits<char>_> *this)\n\n{\n  byte *pbVar1;\n  int iVar2;\n  uint uVar3;\n  \n  iVar2 = (*(code *)PTR__guard_dispatch_icall_140023298)();\n  uVar3 = 0xffffffff;\n  if (iVar2 != -1) {\n    **(int **)(this + 0x50) = **(int **)(this + 0x50) + -1;\n    pbVar1 = **(byte ***)(this + 0x38);\n    **(byte ***)(this + 0x38) = pbVar1 + 1;\n    uVar3 = (uint)*pbVar1;\n  }\n  return uVar3;\n}\n\n",
  "FUN_140005d08": "\nvoid FUN_140005d08(PVOID param_1)\n\n{\n  PVOID pvVar1;\n  \n  if (DAT_140035008 != 0) {\n    pvVar1 = EncodePointer(param_1);\n    DAT_140035008 = DAT_140035008 + -1;\n    *(PVOID *)(&DAT_1400365e0 + DAT_140035008 * 8) = pvVar1;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "operator()<class_<lambda_c376a267cfb53b6959b3b692ec76b120>,class_<lambda_9a32fed5bf61b6b509b2d3f6003082a1>&___ptr64,class_<lambda_572fbb9fa0ab338edf41edfd4b5fcc8d>_>": "\n/* Library Function - Single Match\n    public: int __cdecl __crt_seh_guarded_call<int>::operator()<class\n   <lambda_c376a267cfb53b6959b3b692ec76b120>,class <lambda_9a32fed5bf61b6b509b2d3f6003082a1> &\n   __ptr64,class <lambda_572fbb9fa0ab338edf41edfd4b5fcc8d> >(class\n   <lambda_c376a267cfb53b6959b3b692ec76b120> && __ptr64,class\n   <lambda_9a32fed5bf61b6b509b2d3f6003082a1> & __ptr64,class\n   <lambda_572fbb9fa0ab338edf41edfd4b5fcc8d> && __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_c376a267cfb53b6959b3b692ec76b120>,class_<lambda_9a32fed5bf61b6b509b2d3f6003082a1>&___ptr64,class_<lambda_572fbb9fa0ab338edf41edfd4b5fcc8d>_>\n          (__crt_seh_guarded_call<int> *this,<lambda_c376a267cfb53b6959b3b692ec76b120> *param_1,\n          <lambda_9a32fed5bf61b6b509b2d3f6003082a1> *param_2,\n          <lambda_572fbb9fa0ab338edf41edfd4b5fcc8d> *param_3)\n\n{\n  int iVar1;\n  \n  FUN_14000d384(*(longlong *)param_1);\n  iVar1 = _fflush_nolock(**(FILE ***)param_2);\n  FUN_14000d390(*(longlong *)param_3);\n  return iVar1;\n}\n\n",
  "FID_conflict:operator()": "\n/* Library Function - Multiple Matches With Different Base Names\n    public: char * __ptr64 __cdecl <lambda_082c17da81b0962e08c0587ee0fac50c>::operator()(void)const\n   __ptr64\n    public: char * __ptr64 __cdecl <lambda_b37934c380d97b75fd242ea49540127a>::operator()(void)const\n   __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nwchar_t * FID_conflict_operator__(int **param_1)\n\n{\n  int iVar1;\n  char *_SrcBuf;\n  int *piVar2;\n  pthreadlocinfo ptVar3;\n  errno_t eVar4;\n  wchar_t *_Src;\n  wchar_t *pwVar5;\n  longlong lVar6;\n  wchar_t *pwVar7;\n  size_t local_res8;\n  ulonglong local_res10;\n  localeinfo_struct local_38;\n  \n  _SrcBuf = *(char **)param_1[1];\n  iVar1 = **param_1;\n  if (_SrcBuf == (char *)0x0) {\n    _Src = _wsetlocale(iVar1,(wchar_t *)0x0);\n  }\n  else {\n    eVar4 = mbstowcs_s(&local_res10,(wchar_t *)0x0,0,_SrcBuf,0x7fffffff);\n    if ((eVar4 == 0x16) || (eVar4 == 0x22)) {\nLAB_14000e8fe:\n                    /* WARNING: Subroutine does not return */\n      _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    pwVar5 = (wchar_t *)_calloc_base(local_res10,2);\n    pwVar7 = (wchar_t *)0x0;\n    if (pwVar5 == (wchar_t *)0x0) goto LAB_14000e70e;\n    eVar4 = mbstowcs_s((size_t *)0x0,pwVar5,local_res10,_SrcBuf,0xffffffffffffffff);\n    if (eVar4 != 0) {\n      if ((eVar4 == 0x16) || (pwVar7 = pwVar5, eVar4 == 0x22)) goto LAB_14000e8fe;\n      goto LAB_14000e70e;\n    }\n    _Src = _wsetlocale(iVar1,pwVar5);\n    _free_base(pwVar5);\n  }\n  if (_Src == (wchar_t *)0x0) {\n    return (wchar_t *)0x0;\n  }\n  lVar6 = FUN_140014d84();\n  local_38.locinfo = *(pthreadlocinfo *)(lVar6 + 0x90);\n  local_38.mbcinfo = *(pthreadmbcinfo *)(lVar6 + 0x88);\n  local_res8 = 0;\n  eVar4 = _wcstombs_s_l(&local_res8,(char *)0x0,0,_Src,0,&local_38);\n  if (eVar4 == 0) {\n    pwVar7 = (wchar_t *)_malloc_base(local_res8 + 4);\n    if (pwVar7 == (wchar_t *)0x0) {\n      return (wchar_t *)0x0;\n    }\n    pwVar5 = pwVar7 + 2;\n    eVar4 = _wcstombs_s_l((size_t *)0x0,(char *)pwVar5,local_res8,_Src,0xffffffffffffffff,&local_38)\n    ;\n    ptVar3 = local_38.locinfo;\n    if (eVar4 == 0) {\n      piVar2 = (int *)(local_38.locinfo)->lc_category[(longlong)**param_1 + 1].locale;\n      if (piVar2 != (int *)0x0) {\n        LOCK();\n        iVar1 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        UNLOCK();\n        if (iVar1 == 1) {\n          _free_base((local_38.locinfo)->lc_category[(longlong)**param_1 + 1].locale);\n          ptVar3->lc_category[(longlong)**param_1 + 1].locale = (char *)0x0;\n        }\n      }\n      if ((((*(byte *)(lVar6 + 0x3a8) & 2) == 0) && (((byte)DAT_140035520 & 1) == 0)) &&\n         (piVar2 = (int *)ptVar3->lc_category[(longlong)**param_1 + 1].locale, piVar2 != (int *)0x0)\n         ) {\n        LOCK();\n        iVar1 = *piVar2;\n        *piVar2 = *piVar2 + -1;\n        UNLOCK();\n        if (iVar1 == 1) {\n          _free_base(ptVar3->lc_category[(longlong)**param_1 + 1].locale);\n          ptVar3->lc_category[(longlong)**param_1 + 1].locale = (char *)0x0;\n        }\n      }\n      *(undefined4 *)pwVar7 = *(undefined4 *)&ptVar3->lc_category[0].locale;\n      ptVar3->lc_category[(longlong)**param_1 + 1].locale = (char *)pwVar7;\n      ptVar3->lc_category[**param_1].refcount = (int *)pwVar5;\n      return pwVar5;\n    }\n    if ((eVar4 != 0x16) && (eVar4 != 0x22)) {\nLAB_14000e70e:\n      _free_base(pwVar7);\n      return (wchar_t *)0x0;\n    }\n  }\n  else if ((eVar4 != 0x16) && (eVar4 != 0x22)) {\n    return (wchar_t *)0x0;\n  }\n                    /* WARNING: Subroutine does not return */\n  _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n\n",
  "FUN_140004578": "\nundefined8 FUN_140004578(void)\n\n{\n  return 1;\n}\n\n",
  "_Locinfo_ctor": "\n/* Library Function - Single Match\n    public: static void __cdecl std::_Locinfo::_Locinfo_ctor(class std::_Locinfo * __ptr64,char\n   const * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl std::_Locinfo::_Locinfo_ctor(_Locinfo *param_1,char *param_2)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(0,(char *)0x0);\n  if (pcVar1 == (char *)0x0) {\n    pcVar1 = \"\";\n  }\n  _Yarn<char>::operator=((_Yarn<char> *)(param_1 + 0x48),pcVar1);\n  if (param_2 != (char *)0x0) {\n    param_2 = setlocale(0,param_2);\n  }\n  if (param_2 == (char *)0x0) {\n    param_2 = \"*\";\n  }\n  _Yarn<char>::operator=((_Yarn<char> *)(param_1 + 0x58),param_2);\n  return;\n}\n\n",
  "_onexit": "\n/* Library Function - Single Match\n    _onexit\n   \n   Library: Visual Studio 2019 Release */\n\n_onexit_t __cdecl _onexit(_onexit_t _Func)\n\n{\n  int iVar1;\n  _onexit_t p_Var2;\n  \n  if (DAT_140036758 == -1) {\n    iVar1 = FUN_140014670(_Func);\n  }\n  else {\n    iVar1 = _register_onexit_function(&DAT_140036758,_Func);\n  }\n  p_Var2 = (_onexit_t)0x0;\n  if (iVar1 == 0) {\n    p_Var2 = _Func;\n  }\n  return p_Var2;\n}\n\n",
  "__acrt_IsValidLocaleName": "\n/* WARNING: Switch with 1 destination removed at 0x000140015975 */\n/* Library Function - Single Match\n    __acrt_IsValidLocaleName\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_IsValidLocaleName(ushort *param_1)\n\n{\n  LCID Locale;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  UNRECOVERED_JUMPTABLE =\n       (code *)try_get_function(0x13,\"IsValidLocaleName\",(module_id *)&DAT_140028e60,\n                                (module_id *)\"IsValidLocaleName\");\n  if (UNRECOVERED_JUMPTABLE == (code *)0x0) {\n    Locale = __acrt_LocaleNameToLCID(param_1,0);\n                    /* WARNING: Could not recover jumptable at 0x00014001598f. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    IsValidLocale(Locale,1);\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x000140021e60. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
  "FUN_140004574": "\nundefined FUN_140004574(void)\n\n{\n  return 1;\n}\n\n",
  "parse_bcp47": "\n/* Library Function - Single Match\n    parse_bcp47\n   \n   Library: Visual Studio 2019 Release */\n\nvoid parse_bcp47(undefined (*param_1) [16],wchar_t *param_2)\n\n{\n  wchar_t wVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  ulonglong uVar4;\n  wchar_t **ppwVar5;\n  ulonglong uVar6;\n  size_t *psVar7;\n  ulonglong uVar8;\n  ulonglong uVar9;\n  undefined auStack_c8 [32];\n  wchar_t *local_a8;\n  size_t local_a0 [2];\n  wchar_t *local_90 [3];\n  wchar_t *local_78 [3];\n  wchar_t *local_60 [3];\n  ulonglong local_48;\n  \n  local_48 = DAT_140035020 ^ (ulonglong)auStack_c8;\n  FUN_140008580(param_1,0,0x1ca);\n  uVar8 = 0;\n  psVar7 = local_a0;\n  uVar4 = uVar8;\n  uVar9 = uVar8;\n  do {\n    uVar6 = uVar4;\n    if (3 < uVar6) goto LAB_140013fe8;\n    if ((int)uVar9 == 2) {\n      sVar3 = 0xffffffffffffffff;\n      do {\n        sVar3 = sVar3 + 1;\n      } while (param_2[sVar3] != L'\\0');\n    }\n    else {\n      sVar3 = wcscspn(param_2,L\"-_.\");\n    }\n    psVar7[-1] = (size_t)param_2;\n    *psVar7 = sVar3;\n    wVar1 = param_2[sVar3];\n    *(int *)(psVar7 + 1) = (int)uVar9;\n    psVar7 = psVar7 + 3;\n    uVar9 = uVar8;\n    if (wVar1 != L'-') {\n      if (wVar1 == L'.') {\n        uVar9 = 2;\n      }\n      else if (wVar1 != L'_') {\n        uVar9 = 1;\n      }\n    }\n    param_2 = param_2 + sVar3 + 1;\n    uVar4 = uVar6 + 1;\n  } while ((int)uVar9 != 1);\n  if (uVar6 == 0) {\n    parse_bcp47_language((wchar_t *)param_1,&local_a8);\n  }\n  else {\n    if (uVar6 == 1) {\n      uVar4 = parse_bcp47_language((wchar_t *)param_1,&local_a8);\n      if ((((char)uVar4 == '\\0') ||\n          (uVar4 = parse_bcp47_script((longlong)param_1,local_90), (char)uVar4 != '\\0')) ||\n         (uVar4 = parse_bcp47_region((longlong)param_1,local_90), (char)uVar4 != '\\0'))\n      goto LAB_140013fe8;\n      ppwVar5 = local_90;\n    }\n    else if (uVar6 == 2) {\n      uVar4 = parse_bcp47_language((wchar_t *)param_1,&local_a8);\n      if (((char)uVar4 == '\\0') ||\n         (((uVar4 = parse_bcp47_script((longlong)param_1,local_90), (char)uVar4 != '\\0' &&\n           ((uVar4 = parse_bcp47_region((longlong)param_1,local_78), (char)uVar4 != '\\0' ||\n            (uVar2 = parse_bcp47_code_page((longlong)param_1,local_78), (char)uVar2 != '\\0')))) ||\n          (uVar4 = parse_bcp47_region((longlong)param_1,local_90), (char)uVar4 == '\\0'))))\n      goto LAB_140013fe8;\n      ppwVar5 = local_78;\n    }\n    else {\n      if (((uVar6 != 3) ||\n          (uVar4 = parse_bcp47_language((wchar_t *)param_1,&local_a8), (char)uVar4 == '\\0')) ||\n         ((uVar4 = parse_bcp47_script((longlong)param_1,local_90), (char)uVar4 == '\\0' ||\n          (uVar4 = parse_bcp47_region((longlong)param_1,local_78), (char)uVar4 == '\\0'))))\n      goto LAB_140013fe8;\n      ppwVar5 = local_60;\n    }\n    parse_bcp47_code_page((longlong)param_1,ppwVar5);\n  }\nLAB_140013fe8:\n  FUN_140006060(local_48 ^ (ulonglong)auStack_c8);\n  return;\n}\n\n",
  "FUN_140014d84": "\nvoid FUN_140014d84(void)\n\n{\n  DWORD dwErrCode;\n  int iVar1;\n  __acrt_ptd *p_Var2;\n  \n  dwErrCode = GetLastError();\n  if ((DAT_140035250 == 0xffffffff) ||\n     (p_Var2 = (__acrt_ptd *)__acrt_FlsGetValue(DAT_140035250), p_Var2 == (__acrt_ptd *)0x0)) {\n    iVar1 = __acrt_FlsSetValue(DAT_140035250,(LPVOID)0xffffffffffffffff);\n    if (iVar1 != 0) {\n      p_Var2 = (__acrt_ptd *)_calloc_base(1,0x3c8);\n      if (p_Var2 == (__acrt_ptd *)0x0) {\n        __acrt_FlsSetValue(DAT_140035250,(LPVOID)0x0);\n        p_Var2 = (__acrt_ptd *)0x0;\n      }\n      else {\n        iVar1 = __acrt_FlsSetValue(DAT_140035250,p_Var2);\n        if (iVar1 != 0) {\n          construct_ptd_array(p_Var2);\n          _free_base((LPVOID)0x0);\n          goto LAB_140014e2f;\n        }\n        __acrt_FlsSetValue(DAT_140035250,(LPVOID)0x0);\n      }\n      _free_base(p_Var2);\n    }\n  }\n  else if (p_Var2 != (__acrt_ptd *)0xffffffffffffffff) goto LAB_140014e2f;\n  p_Var2 = (__acrt_ptd *)0x0;\nLAB_140014e2f:\n  SetLastError(dwErrCode);\n  if ((-(ulonglong)(p_Var2 != (__acrt_ptd *)0x0) & (ulonglong)p_Var2) == 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  return;\n}\n\n",
  "operator_new": "\n/* Library Function - Single Match\n    void * __ptr64 __cdecl operator new(unsigned __int64)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid * __cdecl operator_new(__uint64 param_1)\n\n{\n  code *pcVar1;\n  int iVar2;\n  LPVOID pvVar3;\n  void *pvVar4;\n  \n  do {\n    pvVar3 = _malloc_base(param_1);\n    if (pvVar3 != (LPVOID)0x0) {\n      return pvVar3;\n    }\n    iVar2 = _callnewh(param_1);\n  } while (iVar2 != 0);\n  if (param_1 == 0xffffffffffffffff) {\n    FUN_1400012e0();\n    pcVar1 = (code *)swi(3);\n    pvVar4 = (void *)(*pcVar1)();\n    return pvVar4;\n  }\n  FUN_1400069b4();\n  pcVar1 = (code *)swi(3);\n  pvVar4 = (void *)(*pcVar1)();\n  return pvVar4;\n}\n\n",
  "ExecutionInCatch": "\n/* Library Function - Single Match\n    public: static bool __cdecl __FrameHandler3::ExecutionInCatch(struct _xDISPATCHER_CONTEXT *\n   __ptr64,struct _s_FuncInfo const * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nbool __cdecl __FrameHandler3::ExecutionInCatch(_xDISPATCHER_CONTEXT *param_1,_s_FuncInfo *param_2)\n\n{\n  int iVar1;\n  _s_TryBlockMapEntry *p_Var2;\n  \n  iVar1 = FUN_140008d54((longlong)param_2,(ulonglong *)param_1);\n  p_Var2 = CatchTryBlock(param_2,iVar1);\n  return p_Var2 != (_s_TryBlockMapEntry *)0x0;\n}\n\n",
  "__dcrt_uninitialize_environments_nolock": "\n/* Library Function - Single Match\n    __dcrt_uninitialize_environments_nolock\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __dcrt_uninitialize_environments_nolock(void)\n\n{\n  uninitialize_environment_internal<>(&DAT_140037218);\n  uninitialize_environment_internal<>(&DAT_140037220);\n  free_environment<char>(DAT_140037230);\n  free_environment<char>(DAT_140037228);\n  return;\n}\n\n",
  "FUN_140001a70": "\nvoid FUN_140001a70(longlong param_1)\n\n{\n  LOCK();\n  *(int *)(param_1 + 8) = *(int *)(param_1 + 8) + 1;\n  UNLOCK();\n  return;\n}\n\n",
  "__acrt_initialize_multibyte": "\n/* Library Function - Single Match\n    __acrt_initialize_multibyte\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __acrt_initialize_multibyte(void)\n\n{\n  int iVar1;\n  undefined8 in_RAX;\n  __acrt_ptd *p_Var2;\n  undefined4 extraout_var;\n  \n  if (DAT_1400379cc == '\\0') {\n    DAT_1400379b8 = &DAT_140035900;\n    DAT_1400379c0 = &DAT_1400355c0;\n    DAT_1400379b0 = &DAT_1400357f0;\n    p_Var2 = FUN_140014e58();\n    iVar1 = FUN_14001b7b4(-3,'\\x01',p_Var2,(__crt_multibyte_data **)&DAT_1400379c0);\n    in_RAX = CONCAT44(extraout_var,iVar1);\n    DAT_1400379cc = '\\x01';\n  }\n  return CONCAT71((int7)((ulonglong)in_RAX >> 8),1);\n}\n\n",
  "FUN_14000c1e8": "\nuint FUN_14000c1e8(void)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  \n  lVar1 = FUN_140014d84();\n  uVar2 = *(int *)(lVar1 + 0x28) * 0x343fd + 0x269ec3;\n  *(uint *)(lVar1 + 0x28) = uVar2;\n  return uVar2 >> 0x10 & 0x7fff;\n}\n\n",
  "__acrt_GetLocaleInfoEx": "\n/* Library Function - Single Match\n    __acrt_GetLocaleInfoEx\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_GetLocaleInfoEx(ushort *param_1,LCTYPE param_2,LPWSTR param_3,int param_4)\n\n{\n  LCID Locale;\n  void *pvVar1;\n  \n  pvVar1 = try_get_function(0xb,\"GetLocaleInfoEx\",(module_id *)&DAT_140028e00,\n                            (module_id *)\"GetLocaleInfoEx\");\n  if (pvVar1 == (void *)0x0) {\n    Locale = __acrt_LocaleNameToLCID(param_1,0);\n    GetLocaleInfoW(Locale,param_2,param_3,param_4);\n  }\n  else {\n    (*(code *)PTR__guard_dispatch_icall_140023298)(param_1,param_2,param_3,param_4);\n  }\n  return;\n}\n\n",
  "__acrt_GetUserDefaultLocaleName": "\n/* Library Function - Single Match\n    __acrt_GetUserDefaultLocaleName\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_GetUserDefaultLocaleName(wchar_t *param_1,int param_2)\n\n{\n  LCID LVar1;\n  void *pvVar2;\n  \n  pvVar2 = try_get_function(0xf,\"GetUserDefaultLocaleName\",(module_id *)&DAT_140028e30,\n                            (module_id *)\"GetUserDefaultLocaleName\");\n  if (pvVar2 == (void *)0x0) {\n    LVar1 = GetUserDefaultLCID();\n    __acrt_LCIDToLocaleName(LVar1,param_1,param_2);\n  }\n  else {\n    (*(code *)PTR__guard_dispatch_icall_140023298)(param_1,param_2);\n  }\n  return;\n}\n\n",
  "_msize_base": "\n/* Library Function - Single Match\n    _msize_base\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 _msize_base(longlong param_1)\n\n{\n  ulong *puVar1;\n  undefined8 uVar2;\n  \n  if (param_1 == 0) {\n    puVar1 = __doserrno();\n    *puVar1 = 0x16;\n    FUN_14000d030();\n    return 0xffffffffffffffff;\n  }\n                    /* WARNING: Could not recover jumptable at 0x000140020b62. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  uVar2 = HeapSize(DAT_1400379d8,0,param_1);\n  return uVar2;\n}\n\n",
  "FUN_1400227bd": "\nvoid FUN_1400227bd(undefined8 param_1,longlong param_2)\n\n{\n  FID_conflict___acrt_lowio_lock_fh(*(uint *)(param_2 + 0x50));\n  return;\n}\n\n",
  "raise": "\n/* Library Function - Single Match\n    raise\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl raise(int _SigNum)\n\n{\n  code *pcVar1;\n  bool bVar2;\n  int iVar3;\n  ulong *puVar4;\n  longlong lVar5;\n  byte bVar6;\n  longlong lVar7;\n  ulonglong uVar8;\n  ulonglong *puVar9;\n  longlong *plVar10;\n  undefined4 local_res10;\n  longlong local_res18;\n  longlong *plVar11;\n  \n  plVar11 = (longlong *)0x0;\n  plVar10 = (longlong *)0x0;\n  local_res10 = 0;\n  bVar2 = true;\n  if (_SigNum == 2) {\nLAB_140019949:\n    if (_SigNum == 2) {\n      puVar9 = (ulonglong *)&DAT_1400378a8;\n    }\n    else if (_SigNum == 6) {\nLAB_1400199e6:\n      puVar9 = (ulonglong *)&DAT_1400378b8;\n      plVar10 = plVar11;\n    }\n    else if (_SigNum == 0xf) {\n      puVar9 = (ulonglong *)&DAT_1400378c0;\n    }\n    else if (_SigNum == 0x15) {\n      puVar9 = (ulonglong *)&DAT_1400378b0;\n      plVar10 = plVar11;\n    }\n    else {\n      if (_SigNum == 0x16) goto LAB_1400199e6;\n      puVar9 = (ulonglong *)0x0;\n      plVar10 = plVar11;\n    }\n  }\n  else {\n    if (_SigNum != 4) {\n      if (_SigNum != 6) {\n        if ((_SigNum == 8) || (_SigNum == 0xb)) goto LAB_140019979;\n        if ((_SigNum != 0xf) && (1 < _SigNum - 0x15U)) goto LAB_1400199c6;\n      }\n      goto LAB_140019949;\n    }\nLAB_140019979:\n    plVar10 = (longlong *)__acrt_getptd_noexit();\n    if (plVar10 == (longlong *)0x0) {\n      return -1;\n    }\n    lVar5 = *plVar10;\n    lVar7 = DAT_140027ef0 * 0x10 + lVar5;\n    for (; lVar5 != lVar7; lVar5 = lVar5 + 0x10) {\n      if (*(int *)(lVar5 + 4) == _SigNum) goto LAB_1400199c1;\n    }\n    lVar5 = 0;\nLAB_1400199c1:\n    if (lVar5 == 0) {\nLAB_1400199c6:\n      puVar4 = __doserrno();\n      *puVar4 = 0x16;\n      FUN_14000d030();\n      return -1;\n    }\n    puVar9 = (ulonglong *)(lVar5 + 8);\n    bVar2 = false;\n  }\n  local_res18 = 0;\n  if (bVar2) {\n    __acrt_lock(3);\n    bVar6 = (byte)DAT_140035020 & 0x3f;\n    uVar8 = (DAT_140035020 ^ *puVar9) >> bVar6 | (DAT_140035020 ^ *puVar9) << 0x40 - bVar6;\n  }\n  else {\n    uVar8 = *puVar9;\n  }\n  if (uVar8 == 1) goto LAB_140019ae1;\n  if (uVar8 == 0) {\n    if (bVar2) {\n      __acrt_unlock(3);\n    }\n    FUN_140012908(3);\n    pcVar1 = (code *)swi(3);\n    iVar3 = (*pcVar1)();\n    return iVar3;\n  }\n  if (((uint)_SigNum < 0xc) && ((0x910U >> (_SigNum & 0x1fU) & 1) != 0)) {\n    local_res18 = plVar10[1];\n    plVar10[1] = 0;\n    if (_SigNum == 8) {\n      lVar5 = FUN_140014d84();\n      local_res10 = *(undefined4 *)(lVar5 + 0x10);\n      lVar5 = FUN_140014d84();\n      *(undefined4 *)(lVar5 + 0x10) = 0x8c;\n      goto LAB_140019a98;\n    }\n  }\n  else {\nLAB_140019a98:\n    if (_SigNum == 8) {\n      lVar5 = DAT_140027ef8 * 0x10 + *plVar10;\n      lVar7 = DAT_140027f00 * 0x10 + lVar5;\n      for (; lVar5 != lVar7; lVar5 = lVar5 + 0x10) {\n        *(undefined8 *)(lVar5 + 8) = 0;\n      }\n      goto LAB_140019ae1;\n    }\n  }\n  *puVar9 = DAT_140035020;\nLAB_140019ae1:\n  if (bVar2) {\n    __acrt_unlock(3);\n  }\n  if (uVar8 != 1) {\n    if (_SigNum == 8) {\n      lVar5 = FUN_140014d84();\n      (*(code *)PTR__guard_dispatch_icall_140023298)(8,*(undefined4 *)(lVar5 + 0x10));\n    }\n    else {\n      (*(code *)PTR__guard_dispatch_icall_140023298)(_SigNum);\n    }\n    if ((((uint)_SigNum < 0xc) && ((0x910U >> (_SigNum & 0x1fU) & 1) != 0)) &&\n       (plVar10[1] = local_res18, _SigNum == 8)) {\n      lVar5 = FUN_140014d84();\n      *(undefined4 *)(lVar5 + 0x10) = local_res10;\n    }\n  }\n  return 0;\n}\n\n",
  "FUN_1400016d0": "\nundefined8 * FUN_1400016d0(undefined8 *param_1,uint param_2)\n\n{\n  *param_1 = std::exception::vftable;\n  __std_exception_destroy((LPVOID *)(param_1 + 1));\n  if ((param_2 & 1) != 0) {\n    thunk_FUN_14000ce08(param_1);\n  }\n  return param_1;\n}\n\n",
  "operator()<class_<lambda_410d79af7f07d98d83a3f525b3859a53>,class_<lambda_3e16ef9562a7dcce91392c22ab16ea36>&___ptr64,class_<lambda_38119f0e861e05405d8a144b9b982f0a>_>": "\n/* Library Function - Single Match\n    public: void __cdecl __crt_seh_guarded_call<void>::operator()<class\n   <lambda_410d79af7f07d98d83a3f525b3859a53>,class <lambda_3e16ef9562a7dcce91392c22ab16ea36> &\n   __ptr64,class <lambda_38119f0e861e05405d8a144b9b982f0a> >(class\n   <lambda_410d79af7f07d98d83a3f525b3859a53> && __ptr64,class\n   <lambda_3e16ef9562a7dcce91392c22ab16ea36> & __ptr64,class\n   <lambda_38119f0e861e05405d8a144b9b982f0a> && __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_410d79af7f07d98d83a3f525b3859a53>,class_<lambda_3e16ef9562a7dcce91392c22ab16ea36>&___ptr64,class_<lambda_38119f0e861e05405d8a144b9b982f0a>_>\n          (__crt_seh_guarded_call<void> *this,<lambda_410d79af7f07d98d83a3f525b3859a53> *param_1,\n          <lambda_3e16ef9562a7dcce91392c22ab16ea36> *param_2,\n          <lambda_38119f0e861e05405d8a144b9b982f0a> *param_3)\n\n{\n  undefined **ppuVar1;\n  LPVOID *ppvVar2;\n  \n  __acrt_lock(*(int *)param_1);\n  for (ppvVar2 = (LPVOID *)&DAT_1400372c0; ppvVar2 != (LPVOID *)&DAT_1400372c8;\n      ppvVar2 = ppvVar2 + 1) {\n    if ((undefined **)*ppvVar2 != &PTR_DAT_140035260) {\n      ppuVar1 = _updatetlocinfoEx_nolock(ppvVar2,&PTR_DAT_140035260);\n      *ppvVar2 = ppuVar1;\n    }\n  }\n  __acrt_unlock(*(int *)param_3);\n  return;\n}\n\n",
  "__acrt_SetEnvironmentVariableA": "\n/* Library Function - Single Match\n    __acrt_SetEnvironmentVariableA\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nLPCWSTR __acrt_SetEnvironmentVariableA(char *param_1,char *param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  LPCWSTR pWVar4;\n  LPCWSTR pWVar5;\n  uint uVar6;\n  longlong local_98;\n  longlong local_90;\n  char local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  LPCWSTR local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  char local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  LPCWSTR local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  char local_20;\n  \n  pWVar4 = (LPCWSTR)0x0;\n  local_48 = 0;\n  local_40 = 0;\n  local_38 = (LPCWSTR)0x0;\n  local_30 = 0;\n  uVar6 = 0;\n  local_28 = 0;\n  local_20 = '\\0';\n  local_78 = 0;\n  local_70 = 0;\n  local_68 = (LPCWSTR)0x0;\n  local_60 = 0;\n  local_58 = 0;\n  local_50 = '\\0';\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_98,(__crt_locale_pointers *)0x0);\n  uVar2 = 0xfde9;\n  if (*(int *)(local_90 + 0xc) == 0xfde9) {\n    if (local_80 != '\\0') {\n      *(uint *)(local_98 + 0x3a8) = *(uint *)(local_98 + 0x3a8) & 0xfffffffd;\n    }\n  }\n  else {\n    uVar3 = __acrt_AreFileApisANSI();\n    if ((int)uVar3 == 0) {\n      if (local_80 != '\\0') {\n        *(uint *)(local_98 + 0x3a8) = *(uint *)(local_98 + 0x3a8) & 0xfffffffd;\n      }\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = uVar6;\n      if (local_80 != '\\0') {\n        *(uint *)(local_98 + 0x3a8) = *(uint *)(local_98 + 0x3a8) & 0xfffffffd;\n      }\n    }\n  }\n  iVar1 = __acrt_mbs_to_wcs_cp<struct___crt_win32_buffer_internal_dynamic_resizing>\n                    (param_1,(__crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing>\n                              *)&local_48,uVar2);\n  pWVar5 = pWVar4;\n  if (iVar1 == 0) {\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_98,(__crt_locale_pointers *)0x0);\n    if (*(int *)(local_90 + 0xc) == 0xfde9) {\n      uVar6 = 0xfde9;\n      if (local_80 != '\\0') {\n        *(uint *)(local_98 + 0x3a8) = *(uint *)(local_98 + 0x3a8) & 0xfffffffd;\n      }\n    }\n    else {\n      uVar3 = __acrt_AreFileApisANSI();\n      if ((int)uVar3 == 0) {\n        if (local_80 != '\\0') {\n          *(uint *)(local_98 + 0x3a8) = *(uint *)(local_98 + 0x3a8) & 0xfffffffd;\n        }\n        uVar6 = 1;\n      }\n      else if (local_80 != '\\0') {\n        *(uint *)(local_98 + 0x3a8) = *(uint *)(local_98 + 0x3a8) & 0xfffffffd;\n      }\n    }\n    iVar1 = __acrt_mbs_to_wcs_cp<struct___crt_win32_buffer_internal_dynamic_resizing>\n                      (param_2,(__crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing>\n                                *)&local_78,uVar6);\n    pWVar5 = local_68;\n    if (iVar1 == 0) {\n      uVar2 = SetEnvironmentVariableW(local_38,local_68);\n      pWVar4 = (LPCWSTR)(ulonglong)uVar2;\n    }\n  }\n  if (local_50 != '\\0') {\n    _free_base(pWVar5);\n  }\n  if (local_20 != '\\0') {\n    _free_base(local_38);\n  }\n  return pWVar4;\n}\n\n",
  "string_is_alpha": "\n/* Library Function - Single Match\n    string_is_alpha\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 string_is_alpha(longlong param_1,ulonglong param_2)\n\n{\n  ulonglong in_RAX;\n  ushort *puVar1;\n  ushort uVar2;\n  ulonglong uVar3;\n  \n  uVar3 = 0;\n  if (param_2 != 0) {\n    do {\n      uVar2 = *(ushort *)(param_1 + uVar3 * 2);\n      puVar1 = __pctype_func();\n      in_RAX = 0;\n      if (uVar2 < 0x100) {\n        in_RAX = (ulonglong)uVar2;\n        uVar2 = puVar1[in_RAX] & 0x103;\n      }\n      else {\n        uVar2 = 0;\n      }\n      if (uVar2 == 0) {\n        return in_RAX & 0xffffffffffffff00;\n      }\n      uVar3 = uVar3 + 1;\n    } while (uVar3 < param_2);\n  }\n  return CONCAT71((int7)(in_RAX >> 8),1);\n}\n\n",
  "operator()<class_<lambda_842d9ff0dc9ef11c61343bbaebe7f885>,class_<lambda_c5860995281e5c4ce005b3de8f5874ee>&___ptr64,class_<lambda_d90129c13df834fdcbf8d2b88dafcf2d>_>": "\n/* Library Function - Single Match\n    public: void __cdecl __crt_seh_guarded_call<void>::operator()<class\n   <lambda_842d9ff0dc9ef11c61343bbaebe7f885>,class <lambda_c5860995281e5c4ce005b3de8f5874ee> &\n   __ptr64,class <lambda_d90129c13df834fdcbf8d2b88dafcf2d> >(class\n   <lambda_842d9ff0dc9ef11c61343bbaebe7f885> && __ptr64,class\n   <lambda_c5860995281e5c4ce005b3de8f5874ee> & __ptr64,class\n   <lambda_d90129c13df834fdcbf8d2b88dafcf2d> && __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_842d9ff0dc9ef11c61343bbaebe7f885>,class_<lambda_c5860995281e5c4ce005b3de8f5874ee>&___ptr64,class_<lambda_d90129c13df834fdcbf8d2b88dafcf2d>_>\n          (__crt_seh_guarded_call<void> *this,<lambda_842d9ff0dc9ef11c61343bbaebe7f885> *param_1,\n          <lambda_c5860995281e5c4ce005b3de8f5874ee> *param_2,\n          <lambda_d90129c13df834fdcbf8d2b88dafcf2d> *param_3)\n\n{\n  uint uVar1;\n  int iVar2;\n  \n  FUN_14000d384(*(longlong *)param_1);\n  if ((**(longlong **)param_2 != 0) &&\n     (uVar1 = *(uint *)(**(longlong **)param_2 + 0x14), (uVar1 >> 0xd & 1) != 0)) {\n    if (((((byte)uVar1 & 3) == 2) && ((uVar1 & 0xc0) != 0)) || ((uVar1 >> 0xb & 1) != 0)) {\n      if ((**(char **)(param_2 + 0x10) != '\\0') ||\n         ((*(uint *)(**(longlong **)param_2 + 0x14) >> 1 & 1) != 0)) {\n        iVar2 = _fflush_nolock(**(FILE ***)param_2);\n        if (iVar2 == -1) {\n          **(undefined4 **)(param_2 + 0x18) = 0xffffffff;\n        }\n        else {\n          **(int **)(param_2 + 8) = **(int **)(param_2 + 8) + 1;\n        }\n      }\n    }\n    else {\n      **(int **)(param_2 + 8) = **(int **)(param_2 + 8) + 1;\n    }\n  }\n  FUN_14000d390(*(longlong *)param_3);\n  return;\n}\n\n",
  "stream_is_at_end_of_file_nolock": "\n/* Library Function - Single Match\n    bool __cdecl stream_is_at_end_of_file_nolock(class __crt_stdio_stream)\n   \n   Library: Visual Studio 2019 Release */\n\nbool __cdecl stream_is_at_end_of_file_nolock(longlong *param_1)\n\n{\n  bool bVar1;\n  BOOL BVar2;\n  HANDLE hFile;\n  LARGE_INTEGER local_res8;\n  LARGE_INTEGER local_res10 [3];\n  \n  if ((*(uint *)((longlong)param_1 + 0x14) >> 3 & 1) == 0) {\n    if (((((*(uint *)((longlong)param_1 + 0x14) & 0xc0) == 0) || (*param_1 != param_1[1])) &&\n        (hFile = (HANDLE)_get_osfhandle(*(int *)(param_1 + 3)), hFile != (HANDLE)0xffffffffffffffff)\n        ) && ((BVar2 = SetFilePointerEx(hFile,(LARGE_INTEGER)0x0,local_res10,1), BVar2 != 0 &&\n              (BVar2 = GetFileSizeEx(hFile,&local_res8), BVar2 != 0)))) {\n      return local_res10[0].QuadPart == local_res8.QuadPart;\n    }\n    bVar1 = false;\n  }\n  else {\n    bVar1 = true;\n  }\n  return bVar1;\n}\n\n",
  "FUN_1400039b4": "\nundefined8 * FUN_1400039b4(undefined8 *param_1,char *param_2)\n\n{\n  char *local_18;\n  undefined local_10;\n  \n  local_10 = 1;\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  local_18 = param_2;\n  __std_exception_copy(&local_18,(char **)(param_1 + 1));\n  *param_1 = std::out_of_range::vftable;\n  return param_1;\n}\n\n",
  "_Getcat": "\n/* Library Function - Single Match\n    public: static unsigned __int64 __cdecl std::codecvt<char,char,struct _Mbstatet>::_Getcat(class\n   std::locale::facet const * __ptr64 * __ptr64,class std::locale const * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\n__uint64 __cdecl std::codecvt<char,char,struct__Mbstatet>::_Getcat(facet **param_1,locale *param_2)\n\n{\n  longlong lVar1;\n  facet *pfVar2;\n  char *pcVar3;\n  bool bVar4;\n  _Locinfo local_78 [112];\n  \n  bVar4 = false;\n  if ((param_1 != (facet **)0x0) && (*param_1 == (facet *)0x0)) {\n    pfVar2 = (facet *)operator_new(0x10);\n    if (pfVar2 == (facet *)0x0) {\n      pfVar2 = (facet *)0x0;\n    }\n    else {\n      lVar1 = *(longlong *)(param_2 + 8);\n      if (lVar1 == 0) {\n        pcVar3 = \"\";\n      }\n      else {\n        pcVar3 = *(char **)(lVar1 + 0x28);\n        if (pcVar3 == (char *)0x0) {\n          pcVar3 = (char *)(lVar1 + 0x30);\n        }\n      }\n      _Locinfo::_Locinfo(local_78,pcVar3);\n      bVar4 = true;\n      *(undefined4 *)(pfVar2 + 8) = 0;\n      *(undefined ***)pfVar2 = vftable;\n    }\n    *param_1 = pfVar2;\n    if (bVar4) {\n      FUN_1400019d0(local_78);\n    }\n  }\n  return 2;\n}\n\n",
  "parse_bcp47_script": "\n/* Library Function - Single Match\n    parse_bcp47_script\n   \n   Library: Visual Studio 2019 Release */\n\nulonglong parse_bcp47_script(longlong param_1,wchar_t **param_2)\n\n{\n  errno_t eVar1;\n  ulonglong in_RAX;\n  undefined4 extraout_var;\n  \n  if (((*(int *)(param_2 + 2) == 0) && (param_2[1] == (wchar_t *)0x4)) &&\n     (in_RAX = string_is_alpha((longlong)*param_2,4), (char)in_RAX != '\\0')) {\n    eVar1 = wcsncat_s((wchar_t *)(param_1 + 0x120),0x55,L\"-\",1);\n    if (eVar1 == 0) {\n      eVar1 = wcsncat_s((wchar_t *)(param_1 + 0x120),0x55,*param_2,(rsize_t)param_2[1]);\n      if (eVar1 == 0) {\n        return CONCAT71((int7)(CONCAT44(extraout_var,eVar1) >> 8),1);\n      }\n    }\n                    /* WARNING: Subroutine does not return */\n    _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n  }\n  return in_RAX & 0xffffffffffffff00;\n}\n\n",
  "parse_bcp47_region": "\n/* Library Function - Single Match\n    parse_bcp47_region\n   \n   Library: Visual Studio 2019 Release */\n\nulonglong parse_bcp47_region(longlong param_1,wchar_t **param_2)\n\n{\n  wchar_t wVar1;\n  wchar_t *pwVar2;\n  errno_t eVar3;\n  ushort *puVar4;\n  undefined4 extraout_var;\n  ulonglong uVar5;\n  \n  if (*(int *)(param_2 + 2) == 0) {\n    if ((param_2[1] != (wchar_t *)0x2) ||\n       (register0x00000020 = (BADSPACEBASE *)string_is_alpha((longlong)*param_2,2),\n       (char)register0x00000020 == '\\0')) {\n      if (param_2[1] != (wchar_t *)0x3) goto LAB_1400141bb;\n      pwVar2 = *param_2;\n      uVar5 = 0;\n      do {\n        wVar1 = pwVar2[uVar5];\n        puVar4 = __pctype_func();\n        if ((ushort)wVar1 < 0x100) {\n          register0x00000020 = (BADSPACEBASE *)(ulonglong)(puVar4[(ushort)wVar1] & 4);\n        }\n        else {\n          register0x00000020 = (BADSPACEBASE *)0x0;\n        }\n        if ((int)register0x00000020 == 0) goto LAB_1400141bb;\n        uVar5 = uVar5 + 1;\n      } while (uVar5 < 3);\n    }\n    eVar3 = wcsncpy_s((wchar_t *)(param_1 + 0x80),0x40,*param_2,(rsize_t)param_2[1]);\n    if (eVar3 == 0) {\n      eVar3 = wcsncat_s((wchar_t *)(param_1 + 0x120),0x55,L\"-\",1);\n      if (eVar3 == 0) {\n        eVar3 = wcsncat_s((wchar_t *)(param_1 + 0x120),0x55,*param_2,(rsize_t)param_2[1]);\n        if (eVar3 == 0) {\n          return CONCAT71((int7)(CONCAT44(extraout_var,eVar3) >> 8),1);\n        }\n      }\n    }\n                    /* WARNING: Subroutine does not return */\n    _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n  }\nLAB_1400141bb:\n  return (ulonglong)register0x00000020 & 0xffffffffffffff00;\n}\n\n",
  "strcpy_s": "\n/* Library Function - Single Match\n    strcpy_s\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nerrno_t __cdecl strcpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)\n\n{\n  char cVar1;\n  ulong *puVar2;\n  ulong uVar3;\n  char *pcVar4;\n  \n  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {\n    if (_Src != (char *)0x0) {\n      pcVar4 = _Dst;\n      do {\n        cVar1 = pcVar4[(longlong)_Src - (longlong)_Dst];\n        *pcVar4 = cVar1;\n        pcVar4 = pcVar4 + 1;\n        if (cVar1 == '\\0') break;\n        _SizeInBytes = _SizeInBytes - 1;\n      } while (_SizeInBytes != 0);\n      if (_SizeInBytes != 0) {\n        return 0;\n      }\n      *_Dst = '\\0';\n      puVar2 = __doserrno();\n      uVar3 = 0x22;\n      goto LAB_1400148e7;\n    }\n    *_Dst = '\\0';\n  }\n  puVar2 = __doserrno();\n  uVar3 = 0x16;\nLAB_1400148e7:\n  *puVar2 = uVar3;\n  FUN_14000d030();\n  return uVar3;\n}\n\n",
  "FUN_1400227d4": "\nvoid FUN_1400227d4(undefined8 param_1,longlong param_2)\n\n{\n  FID_conflict___acrt_lowio_lock_fh(*(uint *)(param_2 + 0x40));\n  return;\n}\n\n",
  "parse_bcp47_language": "\n/* Library Function - Single Match\n    parse_bcp47_language\n   \n   Library: Visual Studio 2019 Release */\n\nulonglong parse_bcp47_language(wchar_t *param_1,wchar_t **param_2)\n\n{\n  errno_t eVar1;\n  wchar_t *in_RAX;\n  undefined4 extraout_var;\n  \n  if (*(int *)(param_2 + 2) == 0) {\n    in_RAX = param_2[1] + -1;\n    if ((in_RAX < (wchar_t *)0x2) &&\n       (in_RAX = (wchar_t *)string_is_alpha((longlong)*param_2,(ulonglong)param_2[1]),\n       (char)in_RAX != '\\0')) {\n      eVar1 = wcsncpy_s(param_1,0x40,*param_2,(rsize_t)param_2[1]);\n      if (eVar1 == 0) {\n        eVar1 = wcsncpy_s(param_1 + 0x90,0x55,*param_2,(rsize_t)param_2[1]);\n        if (eVar1 == 0) {\n          return CONCAT71((int7)(CONCAT44(extraout_var,eVar1) >> 8),1);\n        }\n      }\n                    /* WARNING: Subroutine does not return */\n      _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n  }\n  return (ulonglong)in_RAX & 0xffffffffffffff00;\n}\n\n",
  "FUN_140006744": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_140006744(void)\n\n{\n  code *pcVar1;\n  BOOL BVar2;\n  undefined *puVar3;\n  undefined auStack_38 [8];\n  undefined auStack_30 [48];\n  \n  puVar3 = auStack_38;\n  BVar2 = IsProcessorFeaturePresent(0x17);\n  if (BVar2 != 0) {\n    pcVar1 = (code *)swi(0x29);\n    (*pcVar1)(2);\n    puVar3 = auStack_30;\n  }\n  *(undefined8 *)(puVar3 + -8) = 0x14000676f;\n  capture_previous_context((PCONTEXT)&DAT_140036830);\n  _DAT_1400367a0 = *(undefined8 *)(puVar3 + 0x38);\n  _DAT_1400368c8 = puVar3 + 0x40;\n  _DAT_1400368b0 = *(undefined8 *)(puVar3 + 0x40);\n  _DAT_140036790 = 0xc0000409;\n  _DAT_140036794 = 1;\n  _DAT_1400367a8 = 1;\n  DAT_1400367b0 = 2;\n  *(undefined8 *)(puVar3 + 0x20) = DAT_140035020;\n  *(undefined8 *)(puVar3 + 0x28) = DAT_140035018;\n  *(undefined8 *)(puVar3 + -8) = 0x140006811;\n  DAT_140036928 = _DAT_1400367a0;\n  __raise_securityfailure((_EXCEPTION_POINTERS *)&PTR_DAT_140024770);\n  return;\n}\n\n",
  "commit_locale_name": "\n/* Library Function - Single Match\n    public: void __cdecl _expandlocale_locale_name_cache::commit_locale_name(wchar_t const * __ptr64\n   const,unsigned __int64) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __thiscall\n_expandlocale_locale_name_cache::commit_locale_name\n          (_expandlocale_locale_name_cache *this,wchar_t *param_1,__uint64 param_2)\n\n{\n  errno_t eVar1;\n  \n  eVar1 = wcsncpy_s((wchar_t *)(*(longlong *)(this + 0x10) + 600),0x55,param_1,param_2);\n  if (eVar1 == 0) {\n    eVar1 = wcsncpy_s(*(wchar_t **)this,*(rsize_t *)(this + 8),param_1,param_2);\n    if (eVar1 == 0) {\n      this[0x18] = (_expandlocale_locale_name_cache)0x1;\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n\n",
  "_wsetlocale_nolock": "\n/* Library Function - Single Match\n    _wsetlocale_nolock\n   \n   Library: Visual Studio 2019 Release */\n\nvoid _wsetlocale_nolock(longlong param_1,int param_2,wchar_t *param_3)\n\n{\n  wchar_t wVar1;\n  code *pcVar2;\n  int iVar3;\n  errno_t eVar4;\n  wchar_t *pwVar5;\n  size_t sVar6;\n  longlong lVar7;\n  wchar_t wVar8;\n  int iVar9;\n  int iVar10;\n  size_t sVar11;\n  int iVar12;\n  int iVar13;\n  longlong *plVar14;\n  undefined **ppuVar15;\n  bool bVar16;\n  undefined auStackY_248 [32];\n  UINT local_218 [4];\n  wchar_t local_208 [136];\n  wchar_t local_f8 [88];\n  ulonglong local_48;\n  \n  local_48 = DAT_140035020 ^ (ulonglong)auStackY_248;\n  iVar13 = 0;\n  if (param_2 != 0) {\n    if (param_3 != (wchar_t *)0x0) {\n      _wsetlocale_set_cat(param_1,param_2,param_3);\n    }\n    goto LAB_1400139d2;\n  }\n  if (param_3 != (wchar_t *)0x0) {\n    iVar12 = iVar13;\n    if (((*param_3 == L'L') && (param_3[1] == L'C')) && (param_3[2] == L'_')) {\n      do {\n        pwVar5 = wcspbrk(param_3,L\"=;\");\n        if (((pwVar5 == (wchar_t *)0x0) ||\n            (sVar11 = (longlong)pwVar5 - (longlong)param_3 >> 1, sVar11 == 0)) || (*pwVar5 == L';'))\n        goto LAB_1400139d2;\n        iVar13 = 1;\n        ppuVar15 = &PTR_u_LC_COLLATE_140027fc8;\n        do {\n          iVar3 = wcsncmp((wchar_t *)*ppuVar15,param_3,sVar11);\n          if (iVar3 == 0) {\n            sVar6 = 0xffffffffffffffff;\n            do {\n              sVar6 = sVar6 + 1;\n            } while (*(wchar_t *)((longlong)*ppuVar15 + sVar6 * 2) != L'\\0');\n            if (sVar11 == sVar6) break;\n          }\n          iVar13 = iVar13 + 1;\n          ppuVar15 = (undefined **)((wchar_t **)ppuVar15 + 3);\n        } while ((longlong)ppuVar15 < 0x140028029);\n        pwVar5 = pwVar5 + 1;\n        sVar11 = wcscspn(pwVar5,L\";\");\n        if ((sVar11 == 0) && (*pwVar5 != L';')) goto LAB_1400139d2;\n        if (iVar13 < 6) {\n          eVar4 = wcsncpy_s(local_208,0x83,pwVar5,sVar11);\n          if (eVar4 != 0) {\n                    /* WARNING: Subroutine does not return */\n            _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n          }\n          if (0x105 < sVar11 * 2) {\n            __report_rangecheckfailure();\n            pcVar2 = (code *)swi(3);\n            (*pcVar2)();\n            return;\n          }\n          local_208[sVar11] = L'\\0';\n          lVar7 = _wsetlocale_set_cat(param_1,iVar13,local_208);\n          if (lVar7 != 0) {\n            iVar12 = iVar12 + 1;\n          }\n        }\n        pwVar5 = pwVar5 + sVar11;\n        wVar8 = *pwVar5;\n        bVar16 = wVar8 != L'\\0';\n        if (bVar16) {\n          wVar8 = pwVar5[1];\n        }\n        param_3 = pwVar5 + 1;\n        if (!bVar16) {\n          param_3 = pwVar5;\n        }\n      } while (wVar8 != L'\\0');\n    }\n    else {\n      lVar7 = _expandlocale(param_3,local_208,0x83,local_f8,0x55,local_218);\n      if (lVar7 == 0) goto LAB_1400139d2;\n      plVar14 = (longlong *)(param_1 + 0x28);\n      iVar3 = iVar13;\n      iVar9 = 1;\n      do {\n        iVar10 = iVar9;\n        if (iVar3 != 0) {\n          pwVar5 = local_208;\n          lVar7 = *plVar14 - (longlong)pwVar5;\n          do {\n            wVar8 = *pwVar5;\n            wVar1 = *(wchar_t *)((longlong)pwVar5 + lVar7);\n            if (wVar8 != wVar1) break;\n            pwVar5 = pwVar5 + 1;\n          } while (wVar1 != L'\\0');\n          if ((wVar8 == wVar1) ||\n             (lVar7 = _wsetlocale_set_cat(param_1,iVar3,local_208), iVar10 = iVar13, lVar7 != 0)) {\n            iVar12 = iVar12 + 1;\n            iVar10 = iVar9;\n          }\n        }\n        iVar3 = iVar3 + 1;\n        plVar14 = plVar14 + 4;\n        iVar9 = iVar10;\n      } while (iVar3 < 6);\n      if (iVar10 != 0) goto LAB_1400139cd;\n    }\n    if (iVar12 == 0) goto LAB_1400139d2;\n  }\nLAB_1400139cd:\n  _wsetlocale_get_all(param_1);\nLAB_1400139d2:\n  FUN_140006060(local_48 ^ (ulonglong)auStackY_248);\n  return;\n}\n\n",
  "DecompHandler": "\n/* Library Function - Single Match\n    private: void __cdecl FH4::HandlerMap4::DecompHandler(void) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __thiscall FH4::HandlerMap4::DecompHandler(HandlerMap4 *this)\n\n{\n  HandlerMap4 HVar1;\n  HandlerMap4 HVar2;\n  undefined4 uVar3;\n  int iVar4;\n  uint uVar5;\n  byte bVar6;\n  ulonglong uVar7;\n  HandlerMap4 *pHVar8;\n  HandlerMap4 *pHVar9;\n  \n  this[0x18] = (HandlerMap4)0x0;\n  *(undefined8 *)(this + 0x1c) = 0;\n  *(undefined8 *)(this + 0x24) = 0;\n  *(undefined (*) [16])(this + 0x30) = ZEXT816(0);\n  HVar1 = **(HandlerMap4 **)(this + 8);\n  pHVar8 = *(HandlerMap4 **)(this + 8) + 1;\n  this[0x18] = HVar1;\n  *(HandlerMap4 **)(this + 8) = pHVar8;\n  if (((byte)HVar1 & 1) != 0) {\n    HVar2 = *pHVar8;\n    pHVar8 = pHVar8 + -(longlong)(char)(&DAT_140024780)[(byte)HVar2 & 0xf];\n    *(uint *)(this + 0x1c) = *(uint *)(pHVar8 + -4) >> ((&DAT_140024790)[(byte)HVar2 & 0xf] & 0x1f);\n    *(HandlerMap4 **)(this + 8) = pHVar8;\n  }\n  if (((byte)HVar1 & 2) != 0) {\n    uVar3 = *(undefined4 *)pHVar8;\n    pHVar8 = pHVar8 + 4;\n    *(HandlerMap4 **)(this + 8) = pHVar8;\n    *(undefined4 *)(this + 0x20) = uVar3;\n  }\n  if (((byte)HVar1 & 4) != 0) {\n    HVar2 = *pHVar8;\n    pHVar8 = pHVar8 + -(longlong)(char)(&DAT_140024780)[(byte)HVar2 & 0xf];\n    *(uint *)(this + 0x24) = *(uint *)(pHVar8 + -4) >> ((&DAT_140024790)[(byte)HVar2 & 0xf] & 0x1f);\n    *(HandlerMap4 **)(this + 8) = pHVar8;\n  }\n  pHVar9 = pHVar8 + 4;\n  *(undefined4 *)(this + 0x28) = *(undefined4 *)pHVar8;\n  bVar6 = (byte)HVar1 & 0x30;\n  *(HandlerMap4 **)(this + 8) = pHVar9;\n  if (((byte)HVar1 & 8) == 0) {\n    if (bVar6 == 0x10) {\n      bVar6 = (&DAT_140024790)[(byte)*pHVar9 & 0xf];\n      uVar5 = *(uint *)(((longlong)pHVar9 - (longlong)(char)(&DAT_140024780)[(byte)*pHVar9 & 0xf]) +\n                       -4);\n      *(longlong *)(this + 8) =\n           (longlong)pHVar9 - (longlong)(char)(&DAT_140024780)[(byte)*pHVar9 & 0xf];\n      *(ulonglong *)(this + 0x30) = (ulonglong)(*(int *)(this + 0x48) + (uVar5 >> (bVar6 & 0x1f)));\n      return;\n    }\n    if (bVar6 != 0x20) {\n      return;\n    }\n    bVar6 = (&DAT_140024790)[(byte)*pHVar9 & 0xf];\n    pHVar9 = pHVar9 + -(longlong)(char)(&DAT_140024780)[(byte)*pHVar9 & 0xf];\n    uVar5 = *(uint *)(pHVar9 + -4);\n    *(HandlerMap4 **)(this + 8) = pHVar9;\n    *(ulonglong *)(this + 0x30) = (ulonglong)(*(int *)(this + 0x48) + (uVar5 >> (bVar6 & 0x1f)));\n    bVar6 = (&DAT_140024790)[(byte)*pHVar9 & 0xf];\n    uVar5 = *(uint *)(((longlong)pHVar9 - (longlong)(char)(&DAT_140024780)[(byte)*pHVar9 & 0xf]) +\n                     -4);\n    *(longlong *)(this + 8) =\n         (longlong)pHVar9 - (longlong)(char)(&DAT_140024780)[(byte)*pHVar9 & 0xf];\n    uVar7 = (ulonglong)(*(int *)(this + 0x48) + (uVar5 >> (bVar6 & 0x1f)));\n  }\n  else {\n    if (bVar6 == 0x10) {\n      iVar4 = *(int *)pHVar9;\n      *(HandlerMap4 **)(this + 8) = pHVar8 + 8;\n      *(longlong *)(this + 0x30) = (longlong)iVar4;\n      return;\n    }\n    if (bVar6 != 0x20) {\n      return;\n    }\n    iVar4 = *(int *)pHVar9;\n    *(HandlerMap4 **)(this + 8) = pHVar8 + 8;\n    *(longlong *)(this + 0x30) = (longlong)iVar4;\n    uVar7 = (ulonglong)*(int *)(pHVar8 + 8);\n    *(HandlerMap4 **)(this + 8) = pHVar8 + 0xc;\n  }\n  *(ulonglong *)(this + 0x38) = uVar7;\n  return;\n}\n\n",
  "operator()<class_<lambda_7777bce6b2f8c936911f934f8298dc43>,class_<lambda_f03950bc5685219e0bcd2087efbe011e>&___ptr64,class_<lambda_3883c3dff614d5e0c5f61bb1ac94921c>_>": "\n/* Library Function - Single Match\n    public: int __cdecl __crt_seh_guarded_call<int>::operator()<class\n   <lambda_7777bce6b2f8c936911f934f8298dc43>,class <lambda_f03950bc5685219e0bcd2087efbe011e> &\n   __ptr64,class <lambda_3883c3dff614d5e0c5f61bb1ac94921c> >(class\n   <lambda_7777bce6b2f8c936911f934f8298dc43> && __ptr64,class\n   <lambda_f03950bc5685219e0bcd2087efbe011e> & __ptr64,class\n   <lambda_3883c3dff614d5e0c5f61bb1ac94921c> && __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_7777bce6b2f8c936911f934f8298dc43>,class_<lambda_f03950bc5685219e0bcd2087efbe011e>&___ptr64,class_<lambda_3883c3dff614d5e0c5f61bb1ac94921c>_>\n          (__crt_seh_guarded_call<int> *this,<lambda_7777bce6b2f8c936911f934f8298dc43> *param_1,\n          <lambda_f03950bc5685219e0bcd2087efbe011e> *param_2,\n          <lambda_3883c3dff614d5e0c5f61bb1ac94921c> *param_3)\n\n{\n  int iVar1;\n  \n  __acrt_lock(*(int *)param_1);\n  iVar1 = <lambda_f03950bc5685219e0bcd2087efbe011e>::operator()(param_2);\n  __acrt_unlock(*(int *)param_3);\n  return iVar1;\n}\n\n",
  "__dcrt_lowio_ensure_console_output_initialized": "\n/* Library Function - Single Match\n    __dcrt_lowio_ensure_console_output_initialized\n   \n   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual\n   Studio 2019 Release */\n\nbool __dcrt_lowio_ensure_console_output_initialized(void)\n\n{\n  if (DAT_140035b00 == (HANDLE)0xfffffffffffffffe) {\n    DAT_140035b00 = CreateFileW(L\"CONOUT$\",0x40000000,3,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);\n  }\n  return DAT_140035b00 != (HANDLE)0xffffffffffffffff;\n}\n\n",
  "entry": "\nvoid entry(void)\n\n{\n  __security_init_cookie();\n  __scrt_common_main_seh();\n  return;\n}\n\n",
  "_towlower_l": "\n/* Library Function - Single Match\n    _towlower_l\n   \n   Library: Visual Studio 2019 Release */\n\nwint_t __cdecl _towlower_l(wint_t _C,_locale_t _Locale)\n\n{\n  int iVar1;\n  WCHAR local_res8 [8];\n  WCHAR local_res18 [8];\n  longlong local_28;\n  longlong local_20;\n  char local_10;\n  \n  local_res8[0] = L'\\xffff';\n  if (_C != 0xffff) {\n    local_res8[0] = _C;\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,(__crt_locale_pointers *)_Locale);\n    if ((ushort)local_res8[0] < 0x100) {\n      if (((&DAT_140025f72)[(ulonglong)(byte)local_res8[0] * 2] & 1) == 0) {\n        local_res8[0] = local_res8[0] & 0xff;\n      }\n      else {\n        local_res8[0] =\n             (WCHAR)*(byte *)(*(longlong *)(local_20 + 0x110) + (ulonglong)(byte)local_res8[0]);\n      }\n    }\n    else if ((*(ushort **)(local_20 + 0x138) != (ushort *)0x0) &&\n            (iVar1 = __acrt_LCMapStringW(*(ushort **)(local_20 + 0x138),0x100,\n                                         (undefined (*) [32])local_res8,1,local_res18,1), iVar1 != 0\n            )) {\n      local_res8[0] = local_res18[0];\n    }\n    if (local_10 != '\\0') {\n      *(uint *)(local_28 + 0x3a8) = *(uint *)(local_28 + 0x3a8) & 0xfffffffd;\n    }\n  }\n  return local_res8[0];\n}\n\n",
  "FUN_140021a90": "\nvoid FUN_140021a90(undefined8 param_1,undefined8 param_2,int param_3)\n\n{\n  FUN_140021ab0(param_1,param_2,param_3,0x1b,\"log10\");\n  return;\n}\n\n",
  "FUN_1400017e0": "\nlonglong ** FUN_1400017e0(undefined8 param_1,longlong **param_2,int param_3)\n\n{\n  char *pcVar1;\n  longlong *plVar2;\n  \n  if (param_3 == 1) {\n    param_2[3] = (longlong *)0xf;\n    *param_2 = (longlong *)0x0;\n    param_2[2] = (longlong *)0x0;\n    *(undefined *)param_2 = 0;\n    FUN_140002520(param_2,(undefined8 *)\"iostream stream error\",(longlong *)0x15);\n    return param_2;\n  }\n  pcVar1 = FUN_140005818(param_3);\n  param_2[3] = (longlong *)0xf;\n  *param_2 = (longlong *)0x0;\n  plVar2 = (longlong *)0xffffffffffffffff;\n  param_2[2] = (longlong *)0x0;\n  *(undefined *)param_2 = 0;\n  do {\n    plVar2 = (longlong *)((longlong)plVar2 + 1);\n  } while (pcVar1[(longlong)plVar2] != '\\0');\n  FUN_140002520(param_2,(undefined8 *)pcVar1,plVar2);\n  return param_2;\n}\n\n",
  "__acrt_eagerly_load_locale_apis": "\n/* Library Function - Single Match\n    __acrt_eagerly_load_locale_apis\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_eagerly_load_locale_apis(void)\n\n{\n  try_get_function(0,\"AreFileApisANSI\",(module_id *)&DAT_140028d78,(module_id *)&DAT_140028d7c);\n  try_get_function(1,\"CompareStringEx\",(module_id *)&DAT_140028d90,(module_id *)\"CompareStringEx\");\n  try_get_function(2,\"EnumSystemLocalesEx\",(module_id *)&DAT_140028da8,\n                   (module_id *)\"EnumSystemLocalesEx\");\n  try_get_function(8,\"GetDateFormatEx\",(module_id *)&DAT_140028de8,(module_id *)\"GetDateFormatEx\");\n  try_get_function(0xb,\"GetLocaleInfoEx\",(module_id *)&DAT_140028e00,(module_id *)\"GetLocaleInfoEx\")\n  ;\n  try_get_function(0xe,\"GetTimeFormatEx\",(module_id *)&DAT_140028e18,(module_id *)\"GetTimeFormatEx\")\n  ;\n  try_get_function(0xf,\"GetUserDefaultLocaleName\",(module_id *)&DAT_140028e30,\n                   (module_id *)\"GetUserDefaultLocaleName\");\n  try_get_function(0x13,\"IsValidLocaleName\",(module_id *)&DAT_140028e60,\n                   (module_id *)\"IsValidLocaleName\");\n  try_get_function(0x14,\"LCMapStringEx\",(module_id *)&DAT_140028e80,(module_id *)\"LCMapStringEx\");\n  try_get_function(0x15,\"LCIDToLocaleName\",(module_id *)&DAT_140028e98,\n                   (module_id *)\"LCIDToLocaleName\");\n  try_get_function(0x16,\"LocaleNameToLCID\",(module_id *)&DAT_140028eb8,\n                   (module_id *)\"LocaleNameToLCID\");\n  return;\n}\n\n",
  "__lc_wcstolc": "\n/* Library Function - Single Match\n    __lc_wcstolc\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __lc_wcstolc(undefined (*param_1) [16],wchar_t *param_2)\n\n{\n  wchar_t wVar1;\n  errno_t eVar2;\n  size_t _MaxCount;\n  undefined (*_Dst) [16];\n  rsize_t _SizeInWords;\n  uint uVar3;\n  \n  FUN_140008580(param_1,0,0x1ca);\n  uVar3 = 0;\n  if (*param_2 != L'\\0') {\n    if ((*param_2 != L'.') || (param_2[1] == L'\\0')) {\n      do {\n        _MaxCount = wcscspn(param_2,L\"_.,\");\n        if (_MaxCount == 0) {\n          return 0xffffffff;\n        }\n        wVar1 = param_2[_MaxCount];\n        if (uVar3 == 0) {\n          if (0x3f < _MaxCount) {\n            return 0xffffffff;\n          }\n          eVar2 = wcsncpy_s((wchar_t *)param_1,0x40,param_2,_MaxCount);\n          if (eVar2 != 0) goto LAB_140012f69;\n          uVar3 = (uint)(wVar1 == L'.');\n        }\n        else {\n          if (uVar3 == 1) {\n            if (0x3f < _MaxCount) {\n              return 0xffffffff;\n            }\n            if (wVar1 == L'_') {\n              return 0xffffffff;\n            }\n            _Dst = param_1 + 8;\n            _SizeInWords = 0x40;\n          }\n          else {\n            if (uVar3 != 2) {\n              return 0xffffffff;\n            }\n            if (0xf < _MaxCount) {\n              return 0xffffffff;\n            }\n            if ((wVar1 != L'\\0') && (wVar1 != L',')) {\n              return 0xffffffff;\n            }\n            _Dst = param_1 + 0x10;\n            _SizeInWords = 0x10;\n          }\n          eVar2 = wcsncpy_s((wchar_t *)_Dst,_SizeInWords,param_2,_MaxCount);\n          if (eVar2 != 0) goto LAB_140012f69;\n        }\n        if (wVar1 == L',') {\n          return 0;\n        }\n        if (wVar1 == L'\\0') {\n          return 0;\n        }\n        param_2 = param_2 + _MaxCount + 1;\n        uVar3 = uVar3 + 1;\n      } while( true );\n    }\n    eVar2 = wcsncpy_s((wchar_t *)(param_1 + 0x10),0x10,param_2 + 1,0xf);\n    if (eVar2 != 0) {\nLAB_140012f69:\n                    /* WARNING: Subroutine does not return */\n      _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    *(undefined2 *)(param_1[0x11] + 0xe) = 0;\n  }\n  return 0;\n}\n\n",
  "__acrt_wcs_to_mbs_cp<struct___crt_win32_buffer_no_resizing>": "\n/* Library Function - Single Match\n    int __cdecl __acrt_wcs_to_mbs_cp<struct __crt_win32_buffer_no_resizing>(wchar_t const * __ptr64\n   const,class __crt_win32_buffer<char,struct __crt_win32_buffer_no_resizing> & __ptr64,unsigned\n   int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl\n__acrt_wcs_to_mbs_cp<struct___crt_win32_buffer_no_resizing>\n          (wchar_t *param_1,__crt_win32_buffer<char,struct___crt_win32_buffer_no_resizing> *param_2,\n          uint param_3)\n\n{\n  int iVar1;\n  DWORD DVar2;\n  ulong *puVar3;\n  \n  if (param_1 == (wchar_t *)0x0) {\n    if (param_2[0x28] != (__crt_win32_buffer<char,struct___crt_win32_buffer_no_resizing>)0x0) {\n      param_2[0x28] = (__crt_win32_buffer<char,struct___crt_win32_buffer_no_resizing>)0x0;\n    }\n    *(undefined8 *)(param_2 + 0x10) = 0;\n    *(undefined8 *)(param_2 + 0x18) = 0;\n  }\n  else {\n    if (*param_1 != L'\\0') {\n      iVar1 = __acrt_WideCharToMultiByte(param_3,0,param_1,-1,(LPSTR)0x0,0,(LPBOOL)0x0,(LPBOOL)0x0);\n      if (iVar1 != 0) {\n        if (*(ulonglong *)(param_2 + 0x18) < (ulonglong)(longlong)iVar1) {\n          if (param_2[0x28] != (__crt_win32_buffer<char,struct___crt_win32_buffer_no_resizing>)0x0)\n          {\n            param_2[0x28] = (__crt_win32_buffer<char,struct___crt_win32_buffer_no_resizing>)0x0;\n          }\n          goto LAB_140011978;\n        }\n        iVar1 = __acrt_WideCharToMultiByte\n                          (param_3,0,param_1,-1,*(LPSTR *)(param_2 + 0x10),\n                           (int)*(ulonglong *)(param_2 + 0x18),(LPBOOL)0x0,(LPBOOL)0x0);\n        if (iVar1 != 0) {\n          *(longlong *)(param_2 + 0x20) = (longlong)iVar1 + -1;\n          return 0;\n        }\n      }\n      DVar2 = GetLastError();\n      __acrt_errno_map_os_error(DVar2);\n      puVar3 = __doserrno();\n      return *puVar3;\n    }\n    if (*(longlong *)(param_2 + 0x18) == 0) {\n      if (param_2[0x28] != (__crt_win32_buffer<char,struct___crt_win32_buffer_no_resizing>)0x0) {\n        param_2[0x28] = (__crt_win32_buffer<char,struct___crt_win32_buffer_no_resizing>)0x0;\n      }\nLAB_140011978:\n      puVar3 = __doserrno();\n      *puVar3 = 0x22;\n      param_2[0x28] = (__crt_win32_buffer<char,struct___crt_win32_buffer_no_resizing>)0x0;\n      *(undefined8 *)(param_2 + 0x18) = 0;\n      return 0x22;\n    }\n    **(undefined **)(param_2 + 0x10) = 0;\n  }\n  *(undefined8 *)(param_2 + 0x20) = 0;\n  return 0;\n}\n\n",
  "_Lockit": "\n/* Library Function - Single Match\n    public: __cdecl std::_Lockit::_Lockit(int) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\n_Lockit * __thiscall std::_Lockit::_Lockit(_Lockit *this,int param_1)\n\n{\n  *(int *)this = param_1;\n  if (param_1 == 0) {\n    _lock_locales();\n  }\n  else if (param_1 < 8) {\n    EnterCriticalSection((LPCRITICAL_SECTION)(&DAT_140036110 + (longlong)param_1 * 0x28));\n  }\n  return this;\n}\n\n",
  "__strncnt": "\n/* Library Function - Single Match\n    __strncnt\n   \n   Library: Visual Studio 2019 Release */\n\nsize_t __cdecl __strncnt(char *_String,size_t _Cnt)\n\n{\n  char cVar1;\n  size_t sVar2;\n  \n  sVar2 = 0;\n  cVar1 = *_String;\n  while ((cVar1 != '\\0' && (sVar2 != _Cnt))) {\n    sVar2 = sVar2 + 1;\n    cVar1 = _String[sVar2];\n  }\n  return sVar2;\n}\n\n",
  "uninitialize_environment_internal<>": "\n/* Library Function - Multiple Matches With Same Base Name\n    void __cdecl uninitialize_environment_internal<char>(char * __ptr64 * __ptr64 & __ptr64)\n    void __cdecl uninitialize_environment_internal<wchar_t>(wchar_t * __ptr64 * __ptr64 & __ptr64)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid uninitialize_environment_internal<>(undefined8 *param_1)\n\n{\n  if ((char **)*param_1 != DAT_140037230) {\n    free_environment<char>((char **)*param_1);\n  }\n  return;\n}\n\n",
  "FUN_1400072fc": "\nundefined4 *\nFUN_1400072fc(undefined4 *param_1,undefined8 param_2,int param_3,ulonglong *param_4,longlong param_5\n             )\n\n{\n  uint uVar1;\n  longlong lVar2;\n  uint uVar3;\n  ulonglong uVar4;\n  int iVar5;\n  int *piVar6;\n  ulonglong uVar7;\n  uint uVar8;\n  int iVar10;\n  int iVar11;\n  longlong lVar12;\n  ulonglong uVar13;\n  undefined4 uStack_3c;\n  undefined4 uStack_2c;\n  ulonglong uVar9;\n  \n  uVar3 = *(uint *)(param_5 + 0xc);\n  iVar5 = FUN_140008d54(param_5,param_4);\n  uVar9 = 0;\n  if (uVar3 == 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  uVar4 = param_4[1];\n  lVar12 = (longlong)*(int *)(param_5 + 0x10);\n  iVar10 = -1;\n  uVar13 = 0xffffffff;\n  uVar8 = uVar3;\n  while( true ) {\n    uVar1 = uVar8 - 1;\n    lVar2 = uVar4 + (ulonglong)uVar1 * 0x14;\n    if ((*(int *)(lVar2 + 4 + lVar12) < iVar5) && (iVar5 <= *(int *)(lVar2 + 8 + lVar12))) break;\n    uVar7 = uVar9;\n    uVar8 = uVar1;\n    if (uVar1 == 0) {\nLAB_140007395:\n      piVar6 = (int *)(uVar4 + lVar12);\n      do {\n        iVar5 = iVar10;\n        if ((((uVar7 == 0) ||\n             ((*(int *)(uVar7 + 4) < *piVar6 && (piVar6[1] <= *(int *)(uVar7 + 8))))) &&\n            (*piVar6 <= param_3)) &&\n           ((param_3 <= piVar6[1] && (uVar13 = uVar9, iVar5 = (int)uVar9, iVar10 != -1)))) {\n          iVar5 = iVar10;\n        }\n        iVar10 = iVar5;\n        uVar8 = (int)uVar9 + 1;\n        uVar9 = (ulonglong)uVar8;\n        piVar6 = piVar6 + 5;\n      } while (uVar8 < uVar3);\n      iVar5 = 0;\n      if (iVar10 != -1) {\n        iVar5 = iVar10;\n      }\n      iVar11 = 0;\n      if (iVar10 != -1) {\n        iVar11 = (int)uVar13 + 1;\n      }\n      *(undefined8 *)param_1 = param_2;\n      param_1[2] = iVar5;\n      param_1[3] = uStack_3c;\n      *(undefined8 *)(param_1 + 4) = param_2;\n      param_1[6] = iVar11;\n      param_1[7] = uStack_2c;\n      return param_1;\n    }\n  }\n  uVar7 = lVar12 + (ulonglong)(uVar8 - 1) * 0x14 + uVar4;\n  goto LAB_140007395;\n}\n\n",
  "FUN_140002490": "\nvoid FUN_140002490(LPVOID *param_1)\n\n{\n  if (*param_1 != (LPVOID)0x0) {\n    FUN_14000ce08(*param_1);\n  }\n  *param_1 = (LPVOID)0x0;\n  return;\n}\n\n",
  "HandlerMap4": "\n/* Library Function - Single Match\n    public: __cdecl FH4::HandlerMap4::HandlerMap4(struct FH4::TryBlockMapEntry4 const *\n   __ptr64,unsigned __int64,int) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nHandlerMap4 * __thiscall\nFH4::HandlerMap4::HandlerMap4\n          (HandlerMap4 *this,TryBlockMapEntry4 *param_1,__uint64 param_2,int param_3)\n\n{\n  byte bVar1;\n  uint uVar2;\n  byte *pbVar3;\n  longlong lVar4;\n  \n  this[0x18] = (HandlerMap4)0x0;\n  *(undefined8 *)(this + 0x1c) = 0;\n  *(undefined8 *)(this + 0x24) = 0;\n  *(undefined (*) [16])(this + 0x30) = ZEXT816(0);\n  *(__uint64 *)(this + 0x40) = param_2;\n  *(int *)(this + 0x48) = param_3;\n  if (*(int *)(param_1 + 0xc) == 0) {\n    *(undefined4 *)this = 0;\n  }\n  else {\n    pbVar3 = (byte *)((longlong)*(int *)(param_1 + 0xc) + param_2);\n    *(byte **)(this + 8) = pbVar3;\n    bVar1 = (&DAT_140024790)[*pbVar3 & 0xf];\n    lVar4 = (longlong)pbVar3 - (longlong)(char)(&DAT_140024780)[*pbVar3 & 0xf];\n    uVar2 = *(uint *)(lVar4 + -4);\n    *(longlong *)(this + 8) = lVar4;\n    *(uint *)this = uVar2 >> (bVar1 & 0x1f);\n    *(longlong *)(this + 0x10) = lVar4;\n    DecompHandler(this);\n  }\n  return this;\n}\n\n",
  "__std_exception_destroy": "\n/* Library Function - Single Match\n    __std_exception_destroy\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __std_exception_destroy(LPVOID *param_1)\n\n{\n  if (*(char *)(param_1 + 1) != '\\0') {\n    FUN_14000ce08(*param_1);\n  }\n  *param_1 = (LPVOID)0x0;\n  *(undefined *)(param_1 + 1) = 0;\n  return;\n}\n\n",
  "__scrt_uninitialize_crt": "\n/* Library Function - Single Match\n    __scrt_uninitialize_crt\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __scrt_uninitialize_crt(bool param_1,char param_2)\n\n{\n  undefined8 in_RAX;\n  \n  if ((DAT_140036750 == '\\0') || (param_2 == '\\0')) {\n    __acrt_uninitialize(param_1);\n    in_RAX = __vcrt_uninitialize(param_1);\n  }\n  return CONCAT71((int7)((ulonglong)in_RAX >> 8),1);\n}\n\n",
  "BuildCatchObjectInternal<class___FrameHandler3>": "\n/* Library Function - Single Match\n    void __cdecl BuildCatchObjectInternal<class __FrameHandler3>(struct EHExceptionRecord *\n   __ptr64,void * __ptr64,struct _s_HandlerType const * __ptr64,struct _s_CatchableType const *\n   __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl\nBuildCatchObjectInternal<class___FrameHandler3>\n          (EHExceptionRecord *param_1,void *param_2,_s_HandlerType *param_3,\n          _s_CatchableType *param_4)\n\n{\n  int iVar1;\n  void *pvVar2;\n  longlong lVar3;\n  longlong lVar4;\n  undefined *UNRECOVERED_JUMPTABLE;\n  void *pvVar5;\n  \n  UNRECOVERED_JUMPTABLE = (undefined *)0x0;\n  pvVar5 = param_2;\n  if (-1 < *(int *)param_3) {\n                    /* WARNING: Load size is inaccurate */\n    pvVar5 = (void *)((longlong)*(int *)(param_3 + 8) + *param_2);\n  }\n  iVar1 = BuildCatchObjectHelperInternal<class___FrameHandler3>(param_1,param_2,param_3,param_4);\n  if (iVar1 == 1) {\n    lVar3 = __AdjustPointer(*(longlong *)(param_1 + 0x28),(int *)(param_4 + 8));\n    if (*(int *)(param_4 + 0x18) != 0) {\n      lVar4 = _GetThrowImageBase();\n      UNRECOVERED_JUMPTABLE = (undefined *)(*(int *)(param_4 + 0x18) + lVar4);\n    }\n    FUN_14000bb50(pvVar5,UNRECOVERED_JUMPTABLE,lVar3);\n  }\n  else if (iVar1 == 2) {\n    pvVar2 = (void *)__AdjustPointer(*(longlong *)(param_1 + 0x28),(int *)(param_4 + 8));\n    if (*(int *)(param_4 + 0x18) != 0) {\n      lVar3 = _GetThrowImageBase();\n      UNRECOVERED_JUMPTABLE = (undefined *)(*(int *)(param_4 + 0x18) + lVar3);\n    }\n    _CallMemberFunction2(pvVar5,UNRECOVERED_JUMPTABLE,pvVar2,1);\n  }\n  return;\n}\n\n",
  "FUN_1400226bb": "\nvoid FUN_1400226bb(undefined8 param_1,longlong param_2)\n\n{\n  FUN_14000d390(*(longlong *)(param_2 + 0x60));\n  return;\n}\n\n",
  "__dcrt_get_or_create_narrow_environment_nolock": "\n/* Library Function - Single Match\n    __dcrt_get_or_create_narrow_environment_nolock\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nlonglong __dcrt_get_or_create_narrow_environment_nolock(void)\n\n{\n  int iVar1;\n  longlong lVar2;\n  \n  lVar2 = DAT_140037218;\n  if ((DAT_140037218 == 0) &&\n     ((DAT_140037220 == 0 ||\n      ((iVar1 = common_initialize_environment_nolock<char>(), lVar2 = DAT_140037218, iVar1 != 0 &&\n       (iVar1 = initialize_environment_by_cloning_nolock<char>(), lVar2 = DAT_140037218, iVar1 != 0)\n       ))))) {\n    lVar2 = 0;\n  }\n  return lVar2;\n}\n\n",
  "create_environment<char>": "\n/* Library Function - Single Match\n    char * __ptr64 * __ptr64 __cdecl create_environment<char>(char * __ptr64 const)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nchar ** __cdecl create_environment<char>(char *param_1)\n\n{\n  errno_t eVar1;\n  char **ppcVar2;\n  longlong lVar3;\n  char **ppcVar4;\n  char *pcVar5;\n  char **ppcVar6;\n  char cVar7;\n  longlong lVar8;\n  ulonglong _SizeInBytes;\n  char **ppcVar9;\n  \n  ppcVar9 = (char **)0x0;\n  cVar7 = *param_1;\n  ppcVar6 = ppcVar9;\n  pcVar5 = param_1;\n  while (cVar7 != '\\0') {\n    ppcVar2 = (char **)((longlong)ppcVar6 + 1);\n    if (cVar7 == '=') {\n      ppcVar2 = ppcVar6;\n    }\n    lVar8 = -1;\n    do {\n      lVar3 = lVar8;\n      lVar8 = lVar3 + 1;\n    } while (pcVar5[lVar8] != '\\0');\n    pcVar5 = pcVar5 + lVar3 + 2;\n    ppcVar6 = ppcVar2;\n    cVar7 = *pcVar5;\n  }\n  ppcVar4 = (char **)_calloc_base((longlong)ppcVar6 + 1,8);\n  ppcVar6 = ppcVar9;\n  ppcVar2 = ppcVar4;\n  if (ppcVar4 != (char **)0x0) {\n    for (; ppcVar6 = ppcVar4, *param_1 != '\\0'; param_1 = param_1 + _SizeInBytes) {\n      lVar8 = -1;\n      do {\n        lVar3 = lVar8;\n        lVar8 = lVar3 + 1;\n      } while (param_1[lVar8] != '\\0');\n      _SizeInBytes = lVar3 + 2;\n      if (*param_1 != '=') {\n        pcVar5 = (char *)_calloc_base(_SizeInBytes,1);\n        if (pcVar5 == (char *)0x0) {\n          free_environment<char>(ppcVar4);\n          _free_base((LPVOID)0x0);\n          ppcVar6 = ppcVar9;\n          break;\n        }\n        eVar1 = strcpy_s(pcVar5,_SizeInBytes,param_1);\n        if (eVar1 != 0) {\n                    /* WARNING: Subroutine does not return */\n          _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n        }\n        *ppcVar2 = pcVar5;\n        ppcVar2 = ppcVar2 + 1;\n        _free_base((LPVOID)0x0);\n      }\n    }\n  }\n  _free_base((LPVOID)0x0);\n  return ppcVar6;\n}\n\n",
  "operator()<class_<lambda_638799b9deba96c50f710eeac98168cd>,class_<lambda_22ebabd17bc4fa466a2aca6d8deb888d>&___ptr64,class_<lambda_a6f7d7db0129f75315ebf26d50c089f1>_>": "\n/* Library Function - Single Match\n    public: int __cdecl __crt_seh_guarded_call<int>::operator()<class\n   <lambda_638799b9deba96c50f710eeac98168cd>,class <lambda_22ebabd17bc4fa466a2aca6d8deb888d> &\n   __ptr64,class <lambda_a6f7d7db0129f75315ebf26d50c089f1> >(class\n   <lambda_638799b9deba96c50f710eeac98168cd> && __ptr64,class\n   <lambda_22ebabd17bc4fa466a2aca6d8deb888d> & __ptr64,class\n   <lambda_a6f7d7db0129f75315ebf26d50c089f1> && __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_638799b9deba96c50f710eeac98168cd>,class_<lambda_22ebabd17bc4fa466a2aca6d8deb888d>&___ptr64,class_<lambda_a6f7d7db0129f75315ebf26d50c089f1>_>\n          (__crt_seh_guarded_call<int> *this,<lambda_638799b9deba96c50f710eeac98168cd> *param_1,\n          <lambda_22ebabd17bc4fa466a2aca6d8deb888d> *param_2,\n          <lambda_a6f7d7db0129f75315ebf26d50c089f1> *param_3)\n\n{\n  int iVar1;\n  \n  __acrt_lock(*(int *)param_1);\n  iVar1 = <lambda_22ebabd17bc4fa466a2aca6d8deb888d>::operator()(param_2);\n  __acrt_unlock(*(int *)param_3);\n  return iVar1;\n}\n\n",
  "FUN_1400017d0": "\nchar * FUN_1400017d0(void)\n\n{\n  return \"iostream\";\n}\n\n",
  "__acrt_uninitialize_winapi_thunks": "\n/* Library Function - Single Match\n    __acrt_uninitialize_winapi_thunks\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 __acrt_uninitialize_winapi_thunks(char param_1)\n\n{\n  HMODULE hLibModule;\n  undefined8 *in_RAX;\n  HMODULE *ppHVar1;\n  \n  if (param_1 == '\\0') {\n    ppHVar1 = (HMODULE *)&DAT_1400372d0;\n    do {\n      hLibModule = *ppHVar1;\n      if (hLibModule != (HMODULE)0x0) {\n        if (hLibModule != (HMODULE)0xffffffffffffffff) {\n          FreeLibrary(hLibModule);\n        }\n        *ppHVar1 = (HMODULE)0x0;\n      }\n      ppHVar1 = ppHVar1 + 1;\n      in_RAX = &DAT_140037370;\n    } while (ppHVar1 != (HMODULE *)&DAT_140037370);\n  }\n  return CONCAT71((int7)((ulonglong)in_RAX >> 8),1);\n}\n\n",
  "FUN_140003f94": "\nvoid FUN_140003f94(longlong param_1,uint param_2)\n\n{\n  FID_conflict__scalar_deleting_destructor_((ios_base *)(param_1 - *(int *)(param_1 + -4)),param_2);\n  return;\n}\n\n",
  "__acrt_LCMapStringA": "\n/* Library Function - Single Match\n    __acrt_LCMapStringA\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_LCMapStringA(__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4\n                        ,int param_5,char *param_6,int param_7,int param_8,int param_9)\n\n{\n  longlong local_28;\n  __crt_locale_pointers local_20 [16];\n  char local_10;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,param_1);\n  __acrt_LCMapStringA_stat(local_20,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9)\n  ;\n  if (local_10 != '\\0') {\n    *(uint *)(local_28 + 0x3a8) = *(uint *)(local_28 + 0x3a8) & 0xfffffffd;\n  }\n  return;\n}\n\n",
  "FUN_1400226d3": "\nvoid FUN_1400226d3(undefined8 param_1,longlong param_2)\n\n{\n  FUN_14000d390(*(longlong *)(param_2 + 0x38));\n  return;\n}\n\n",
  "operator()<class_<lambda_d80eeec6fff315bfe5c115232f3240e3>,class_<lambda_6e4b09c48022b2350581041d5f6b0c4c>&___ptr64,class_<lambda_2358e3775559c9db80273638284d5e45>_>": "\n/* Library Function - Single Match\n    public: void __cdecl __crt_seh_guarded_call<void>::operator()<class\n   <lambda_d80eeec6fff315bfe5c115232f3240e3>,class <lambda_6e4b09c48022b2350581041d5f6b0c4c> &\n   __ptr64,class <lambda_2358e3775559c9db80273638284d5e45> >(class\n   <lambda_d80eeec6fff315bfe5c115232f3240e3> && __ptr64,class\n   <lambda_6e4b09c48022b2350581041d5f6b0c4c> & __ptr64,class\n   <lambda_2358e3775559c9db80273638284d5e45> && __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_d80eeec6fff315bfe5c115232f3240e3>,class_<lambda_6e4b09c48022b2350581041d5f6b0c4c>&___ptr64,class_<lambda_2358e3775559c9db80273638284d5e45>_>\n          (__crt_seh_guarded_call<void> *this,<lambda_d80eeec6fff315bfe5c115232f3240e3> *param_1,\n          <lambda_6e4b09c48022b2350581041d5f6b0c4c> *param_2,\n          <lambda_2358e3775559c9db80273638284d5e45> *param_3)\n\n{\n  __acrt_lock(*(int *)param_1);\n  <lambda_6e4b09c48022b2350581041d5f6b0c4c>::operator()(param_2);\n  __acrt_unlock(*(int *)param_3);\n  return;\n}\n\n",
  "_guard_check_icall": "\nvoid _guard_check_icall(void)\n\n{\n  return;\n}\n\n",
  "FUN_140003f78": "\nvoid FUN_140003f78(ios_base *param_1)\n\n{\n  *(undefined ***)param_1 = std::ios_base::vftable;\n  std::ios_base::_Ios_base_dtor(param_1);\n  return;\n}\n\n",
  "FUN_14000682c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_14000682c(undefined4 param_1)\n\n{\n  code *pcVar1;\n  BOOL BVar2;\n  undefined *puVar3;\n  undefined auStack_28 [8];\n  undefined auStack_20 [32];\n  \n  puVar3 = auStack_28;\n  BVar2 = IsProcessorFeaturePresent(0x17);\n  if (BVar2 != 0) {\n    pcVar1 = (code *)swi(0x29);\n    (*pcVar1)(param_1);\n    puVar3 = auStack_20;\n  }\n  *(undefined8 *)(puVar3 + -8) = 0x140006857;\n  capture_current_context((PCONTEXT)&DAT_140036830);\n  _DAT_1400367a0 = *(undefined8 *)(puVar3 + 0x28);\n  _DAT_1400368c8 = puVar3 + 0x30;\n  _DAT_140036790 = 0xc0000409;\n  _DAT_140036794 = 1;\n  _DAT_1400367a8 = 1;\n  DAT_1400367b0 = (ulonglong)*(uint *)(puVar3 + 0x30);\n  *(undefined8 *)(puVar3 + -8) = 0x1400068c3;\n  DAT_140036928 = _DAT_1400367a0;\n  __raise_securityfailure((_EXCEPTION_POINTERS *)&PTR_DAT_140024770);\n  return;\n}\n\n",
  "FUN_140004f3c": "\n__int64 FUN_140004f3c(basic_streambuf<char,struct_std::char_traits<char>_> *param_1,char *param_2,\n                     ulonglong param_3)\n\n{\n  basic_streambuf<char,struct_std::char_traits<char>_> *pbVar1;\n  undefined8 uVar2;\n  __int64 _Var3;\n  size_t sVar4;\n  int iVar5;\n  ulonglong uVar6;\n  ulonglong _Count;\n  \n  if ((longlong)param_3 < 1) {\n    _Var3 = 0;\n  }\n  else if (*(longlong *)(param_1 + 0x68) == 0) {\n    if ((undefined8 *)**(undefined8 **)(param_1 + 0x38) == (undefined8 *)0x0) {\n      iVar5 = 0;\n    }\n    else {\n      iVar5 = **(int **)(param_1 + 0x50);\n    }\n    _Count = param_3;\n    if (iVar5 != 0) {\n      uVar6 = param_3;\n      if ((ulonglong)(longlong)iVar5 < param_3) {\n        uVar6 = (longlong)iVar5;\n      }\n      FUN_140007ed0((undefined8 *)param_2,(undefined8 *)**(undefined8 **)(param_1 + 0x38),uVar6);\n      param_2 = param_2 + uVar6;\n      _Count = param_3 - uVar6;\n      **(int **)(param_1 + 0x50) = **(int **)(param_1 + 0x50) - (int)uVar6;\n      **(longlong **)(param_1 + 0x38) = **(longlong **)(param_1 + 0x38) + (longlong)(int)uVar6;\n    }\n    if (*(longlong *)(param_1 + 0x80) != 0) {\n      if (**(basic_streambuf<char,struct_std::char_traits<char>_> ***)(param_1 + 0x18) ==\n          param_1 + 0x70) {\n        pbVar1 = *(basic_streambuf<char,struct_std::char_traits<char>_> **)(param_1 + 0x88);\n        uVar2 = *(undefined8 *)(param_1 + 0x90);\n        **(basic_streambuf<char,struct_std::char_traits<char>_> ***)(param_1 + 0x18) = pbVar1;\n        **(basic_streambuf<char,struct_std::char_traits<char>_> ***)(param_1 + 0x38) = pbVar1;\n        **(int **)(param_1 + 0x50) = (int)uVar2 - (int)pbVar1;\n      }\n      do {\n        if (_Count < 0x1000) {\n          if (_Count != 0) {\n            sVar4 = fread(param_2,1,_Count,*(FILE **)(param_1 + 0x80));\n            _Count = _Count - sVar4;\n          }\n          break;\n        }\n        sVar4 = fread(param_2,1,0xfff,*(FILE **)(param_1 + 0x80));\n        _Count = _Count - sVar4;\n        param_2 = param_2 + sVar4;\n      } while (sVar4 == 0xfff);\n    }\n    _Var3 = param_3 - _Count;\n  }\n  else {\n    _Var3 = std::basic_streambuf<char,struct_std::char_traits<char>_>::xsgetn\n                      (param_1,param_2,param_3);\n  }\n  return _Var3;\n}\n\n",
  "operator()<class_<lambda_a37b2b86f63e897a80ea819b0eb08c01>,class_<lambda_38ce7e780aa69e748d6df282ebc68efe>&___ptr64,class_<lambda_99fb1378e971ab6e7edea83e3a7a83a2>_>": "\n/* Library Function - Single Match\n    public: int __cdecl __crt_seh_guarded_call<int>::operator()<class\n   <lambda_a37b2b86f63e897a80ea819b0eb08c01>,class <lambda_38ce7e780aa69e748d6df282ebc68efe> &\n   __ptr64,class <lambda_99fb1378e971ab6e7edea83e3a7a83a2> >(class\n   <lambda_a37b2b86f63e897a80ea819b0eb08c01> && __ptr64,class\n   <lambda_38ce7e780aa69e748d6df282ebc68efe> & __ptr64,class\n   <lambda_99fb1378e971ab6e7edea83e3a7a83a2> && __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_a37b2b86f63e897a80ea819b0eb08c01>,class_<lambda_38ce7e780aa69e748d6df282ebc68efe>&___ptr64,class_<lambda_99fb1378e971ab6e7edea83e3a7a83a2>_>\n          (__crt_seh_guarded_call<int> *this,<lambda_a37b2b86f63e897a80ea819b0eb08c01> *param_1,\n          <lambda_38ce7e780aa69e748d6df282ebc68efe> *param_2,\n          <lambda_99fb1378e971ab6e7edea83e3a7a83a2> *param_3)\n\n{\n  uint _FileHandle;\n  BOOL BVar1;\n  DWORD DVar2;\n  HANDLE hFile;\n  ulong *puVar3;\n  int iVar4;\n  \n  FID_conflict___acrt_lowio_lock_fh(*(uint *)param_1);\n  _FileHandle = **(uint **)param_2;\n  if ((*(byte *)((&DAT_140037490)[(longlong)(int)_FileHandle >> 6] + 0x38 +\n                (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) != 0) {\n    hFile = (HANDLE)_get_osfhandle(_FileHandle);\n    BVar1 = FlushFileBuffers(hFile);\n    iVar4 = 0;\n    if (BVar1 != 0) goto LAB_1400163b0;\n    puVar3 = __doserrno();\n    DVar2 = GetLastError();\n    *puVar3 = DVar2;\n  }\n  puVar3 = __doserrno();\n  *puVar3 = 9;\n  iVar4 = -1;\nLAB_1400163b0:\n  FID_conflict___acrt_lowio_lock_fh(*(uint *)param_3);\n  return iVar4;\n}\n\n",
  "common_expand_argv_wildcards<char>": "\n/* WARNING: Removing unreachable block (ram,0x00014001ac1e) */\n/* WARNING: Removing unreachable block (ram,0x00014001ac24) */\n/* WARNING: Removing unreachable block (ram,0x00014001ac2d) */\n/* WARNING: Removing unreachable block (ram,0x00014001ac3f) */\n/* WARNING: Removing unreachable block (ram,0x00014001acf6) */\n/* WARNING: Removing unreachable block (ram,0x00014001ac11) */\n/* WARNING: Removing unreachable block (ram,0x00014001ac73) */\n/* WARNING: Removing unreachable block (ram,0x00014001ac7d) */\n/* WARNING: Removing unreachable block (ram,0x00014001ac83) */\n/* WARNING: Removing unreachable block (ram,0x00014001ac8c) */\n/* WARNING: Removing unreachable block (ram,0x00014001ad2c) */\n/* WARNING: Removing unreachable block (ram,0x00014001aca9) */\n/* WARNING: Removing unreachable block (ram,0x00014001aced) */\n/* Library Function - Single Match\n    int __cdecl common_expand_argv_wildcards<char>(char * __ptr64 * __ptr64 const,char * __ptr64 *\n   __ptr64 * __ptr64 const)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl common_expand_argv_wildcards<char>(char **param_1,char ***param_2)\n\n{\n  ulong *puVar1;\n  char *pcVar2;\n  char **ppcVar3;\n  int iVar4;\n  argument_list<char> *in_R8;\n  argument_list<char> *in_R9;\n  undefined8 local_res18;\n  char **local_res20;\n  undefined8 in_stack_ffffffffffffff88;\n  undefined in_stack_ffffffffffffff90;\n  undefined8 in_stack_ffffffffffffff98;\n  undefined8 in_stack_ffffffffffffffa0;\n  \n  if (param_2 == (char ***)0x0) {\n    puVar1 = __doserrno();\n    iVar4 = 0x16;\n    *puVar1 = 0x16;\n    FUN_14000d030();\n  }\n  else {\n    *param_2 = (char **)0x0;\n    pcVar2 = *param_1;\n    while (pcVar2 != (char *)0x0) {\n      local_res18 = CONCAT53(local_res18._3_5_,0x3f2a);\n      pcVar2 = FUN_140020070(pcVar2,(char *)&local_res18,(char)in_R8,(char)in_R9,\n                             (char)in_stack_ffffffffffffff88,in_stack_ffffffffffffff90,\n                             (char)in_stack_ffffffffffffff98,in_stack_ffffffffffffffa0,0);\n      if (pcVar2 == (char *)0x0) {\n        in_R9 = (argument_list<char> *)&stack0xffffffffffffffa8;\n        in_R8 = (argument_list<char> *)0x0;\n        iVar4 = copy_and_add_argument_to_buffer<char>(*param_1,(char *)0x0,0,in_R9);\n      }\n      else {\n        in_R8 = (argument_list<char> *)&stack0xffffffffffffffa8;\n        iVar4 = expand_argument_wildcards<char>(*param_1,pcVar2,in_R8);\n      }\n      if (iVar4 != 0) goto LAB_14001acd9;\n      param_1 = param_1 + 1;\n      pcVar2 = *param_1;\n    }\n    local_res18 = 0;\n    ppcVar3 = (char **)__acrt_allocate_buffer_for_argv(1,0,1);\n    iVar4 = -1;\n    if (ppcVar3 != (char **)0x0) {\n      local_res20 = ppcVar3 + 1;\n      *param_2 = ppcVar3;\n      iVar4 = 0;\n    }\n    _free_base((LPVOID)0x0);\nLAB_14001acd9:\n    _free_base((LPVOID)0x0);\n  }\n  return iVar4;\n}\n\n",
  "__acrt_locale_release_lc_time_reference": "\n/* Library Function - Single Match\n    __acrt_locale_release_lc_time_reference\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __acrt_locale_release_lc_time_reference(undefined **param_1)\n\n{\n  int *piVar1;\n  int iVar2;\n  \n  if ((param_1 != (undefined **)0x0) && (param_1 != &PTR_DAT_1400281f0)) {\n    LOCK();\n    piVar1 = (int *)((longlong)param_1 + 0x15c);\n    iVar2 = *piVar1;\n    *piVar1 = *piVar1 + -1;\n    UNLOCK();\n    return iVar2 + -1;\n  }\n  return 0x7fffffff;\n}\n\n",
  "_ungetc_nolock": "\n/* Library Function - Single Match\n    _ungetc_nolock\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _ungetc_nolock(int _Ch,FILE *_File)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  ulong *puVar3;\n  char *pcVar4;\n  char *pcVar5;\n  undefined *puVar6;\n  undefined *puVar7;\n  \n  if ((*(uint *)((longlong)&_File->_base + 4) >> 0xc & 1) == 0) {\n    uVar2 = _fileno(_File);\n    puVar6 = &DAT_1400353d0;\n    if (uVar2 + 2 < 2) {\n      puVar7 = &DAT_1400353d0;\n    }\n    else {\n      puVar7 = (undefined *)\n               ((&DAT_140037490)[(longlong)(int)uVar2 >> 6] + (ulonglong)(uVar2 & 0x3f) * 0x48);\n    }\n    if (puVar7[0x39] == '\\0') {\n      if (1 < uVar2 + 2) {\n        puVar6 = (undefined *)\n                 ((&DAT_140037490)[(longlong)(int)uVar2 >> 6] + (ulonglong)(uVar2 & 0x3f) * 0x48);\n      }\n      if ((puVar6[0x3d] & 1) == 0) goto LAB_14000e56f;\n    }\n    puVar3 = __doserrno();\n    *puVar3 = 0x16;\n    FUN_14000d030();\n  }\n  else {\nLAB_14000e56f:\n    if ((_Ch != -1) &&\n       (((*(uint *)((longlong)&_File->_base + 4) & 1) != 0 ||\n        (((byte)*(undefined4 *)((longlong)&_File->_base + 4) & 6) == 6)))) {\n      pcVar4 = *(char **)&_File->_cnt;\n      if (pcVar4 == (char *)0x0) {\n        __acrt_stdio_allocate_buffer_nolock(&_File->_ptr);\n        pcVar4 = *(char **)&_File->_cnt;\n      }\n      if (_File->_ptr == pcVar4) {\n        if (*(int *)&_File->_base != 0) {\n          return -1;\n        }\n        _File->_ptr = _File->_ptr + 1;\n      }\n      uVar2 = *(uint *)((longlong)&_File->_base + 4);\n      pcVar4 = _File->_ptr;\n      pcVar5 = pcVar4 + -1;\n      _File->_ptr = pcVar5;\n      if ((uVar2 >> 0xc & 1) == 0) {\n        *pcVar5 = (char)_Ch;\n      }\n      else if (*pcVar5 != (char)_Ch) {\n        _File->_ptr = pcVar4;\n        return -1;\n      }\n      *(int *)&_File->_base = *(int *)&_File->_base + 1;\n      LOCK();\n      puVar1 = (uint *)((longlong)&_File->_base + 4);\n      *puVar1 = *puVar1 & 0xfffffff7;\n      UNLOCK();\n      LOCK();\n      puVar1 = (uint *)((longlong)&_File->_base + 4);\n      *puVar1 = *puVar1 | 1;\n      UNLOCK();\n      return _Ch & 0xff;\n    }\n  }\n  return -1;\n}\n\n",
  "capture_previous_context": "\n/* Library Function - Single Match\n    capture_previous_context\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid capture_previous_context(PCONTEXT param_1)\n\n{\n  DWORD64 ControlPc;\n  PRUNTIME_FUNCTION FunctionEntry;\n  int iVar1;\n  DWORD64 local_res8;\n  ulonglong local_res10;\n  PVOID local_res18 [2];\n  \n  RtlCaptureContext();\n  ControlPc = param_1->Rip;\n  iVar1 = 0;\n  do {\n    FunctionEntry = RtlLookupFunctionEntry(ControlPc,&local_res8,(PUNWIND_HISTORY_TABLE)0x0);\n    if (FunctionEntry == (PRUNTIME_FUNCTION)0x0) {\n      return;\n    }\n    RtlVirtualUnwind(0,local_res8,ControlPc,FunctionEntry,param_1,local_res18,&local_res10,\n                     (PKNONVOLATILE_CONTEXT_POINTERS)0x0);\n    iVar1 = iVar1 + 1;\n  } while (iVar1 < 2);\n  return;\n}\n\n",
  "___lc_locale_name_func": "\n/* Library Function - Single Match\n    ___lc_locale_name_func\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nwchar_t ** __cdecl ___lc_locale_name_func(void)\n\n{\n  longlong lVar1;\n  longlong local_res8 [4];\n  \n  lVar1 = FUN_140014d84();\n  local_res8[0] = *(longlong *)(lVar1 + 0x90);\n  __acrt_update_locale_info(lVar1,local_res8);\n  return (wchar_t **)(local_res8[0] + 0x128);\n}\n\n",
  "FUN_14001a634": "\nulonglong FUN_14001a634(ushort *param_1,ushort *param_2)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  uint uVar3;\n  ulong *puVar4;\n  ulonglong uVar5;\n  pthreadlocinfo ptVar6;\n  longlong local_38;\n  localeinfo_struct local_30;\n  char local_20;\n  \n  if (DAT_140037280 != 0) {\n    if ((param_1 == (ushort *)0x0) || (param_2 == (ushort *)0x0)) {\n      puVar4 = __doserrno();\n      *puVar4 = 0x16;\n      FUN_14000d030();\n      uVar5 = 0x7fffffff;\n    }\n    else {\n      _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_38,(__crt_locale_pointers *)0x0);\n      ptVar6 = local_30.locinfo;\n      if ((local_30.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n        uVar3 = __ascii_wcsicmp(param_1,param_2);\n        uVar5 = (ulonglong)uVar3;\n      }\n      else {\n        do {\n          if (*param_1 < 0x100) {\n            uVar5 = (ulonglong)*(byte *)param_1;\n            if (((&DAT_140025f72)[uVar5 * 2] & 1) != 0) {\n              uVar5 = (ulonglong)ptVar6->pclmap[uVar5];\n            }\n            uVar1 = (ushort)uVar5;\n          }\n          else {\n            uVar1 = _towlower_l(*param_1,&local_30);\n            ptVar6 = local_30.locinfo;\n          }\n          param_1 = param_1 + 1;\n          if (*param_2 < 0x100) {\n            uVar5 = (ulonglong)*(byte *)param_2;\n            if (((&DAT_140025f72)[uVar5 * 2] & 1) != 0) {\n              uVar5 = (ulonglong)ptVar6->pclmap[uVar5];\n            }\n            uVar2 = (ushort)uVar5;\n          }\n          else {\n            uVar2 = _towlower_l(*param_2,&local_30);\n            ptVar6 = local_30.locinfo;\n          }\n          param_2 = param_2 + 1;\n          uVar3 = (uint)uVar1 - (uint)uVar2;\n          uVar5 = (ulonglong)uVar3;\n        } while ((uVar3 == 0) && (uVar1 != 0));\n      }\n      if (local_20 != '\\0') {\n        *(uint *)(local_38 + 0x3a8) = *(uint *)(local_38 + 0x3a8) & 0xfffffffd;\n      }\n    }\n    return uVar5;\n  }\n  if ((param_1 != (ushort *)0x0) && (param_2 != (ushort *)0x0)) {\n    uVar5 = __ascii_wcsicmp(param_1,param_2);\n    return uVar5;\n  }\n  local_30.locinfo = (pthreadlocinfo)0x14001a64b;\n  puVar4 = __doserrno();\n  *puVar4 = 0x16;\n  local_30.locinfo = (pthreadlocinfo)0x14001a656;\n  FUN_14000d030();\n  return 0x7fffffff;\n}\n\n",
  "count_newline_bytes": "\n/* Library Function - Single Match\n    __int64 __cdecl count_newline_bytes(char const * __ptr64 const,char const * __ptr64 const,enum\n   __crt_lowio_text_mode)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\n__int64 __cdecl count_newline_bytes(char *param_1,char *param_2,__crt_lowio_text_mode param_3)\n\n{\n  short sVar1;\n  ulonglong uVar2;\n  longlong lVar3;\n  ulonglong uVar4;\n  longlong lVar5;\n  ulonglong uVar6;\n  longlong lVar7;\n  ulonglong uVar8;\n  char *pcVar9;\n  \n  if ((byte)((char)param_3 - 1U) < 2) {\n    uVar2 = 0;\n    uVar4 = (ulonglong)(param_2 + (1 - (longlong)param_1)) >> 1;\n    if (param_2 < param_1) {\n      uVar4 = uVar2;\n    }\n    uVar6 = uVar2;\n    uVar8 = uVar2;\n    if (uVar4 != 0) {\n      do {\n        sVar1 = *(short *)param_1;\n        param_1 = (char *)((longlong)param_1 + 2);\n        uVar2 = uVar6 + 1;\n        if (sVar1 != 10) {\n          uVar2 = uVar6;\n        }\n        uVar8 = uVar8 + 1;\n        uVar6 = uVar2;\n      } while (uVar8 != uVar4);\n    }\n    return uVar2 * 2;\n  }\n  lVar5 = 0;\n  lVar3 = (longlong)param_2 - (longlong)param_1;\n  if (param_2 < param_1) {\n    lVar3 = lVar5;\n  }\n  lVar7 = lVar5;\n  pcVar9 = param_1;\n  if (lVar3 != 0) {\n    do {\n      lVar5 = lVar7 + 1;\n      if (*pcVar9 != '\\n') {\n        lVar5 = lVar7;\n      }\n      pcVar9 = pcVar9 + 1;\n      lVar7 = lVar5;\n    } while ((longlong)pcVar9 - (longlong)param_1 != lVar3);\n  }\n  return lVar5;\n}\n\n",
  "getSystemCP": "\n/* Library Function - Single Match\n    int __cdecl getSystemCP(int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl getSystemCP(int param_1)\n\n{\n  longlong local_28;\n  longlong local_20;\n  char local_10;\n  \n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,(__crt_locale_pointers *)0x0);\n  DAT_1400379c8 = 0;\n  if (param_1 == -2) {\n    DAT_1400379c8 = 1;\n    param_1 = GetOEMCP();\n  }\n  else if (param_1 == -3) {\n    DAT_1400379c8 = 1;\n    param_1 = GetACP();\n  }\n  else if (param_1 == -4) {\n    DAT_1400379c8 = 1;\n    param_1 = *(UINT *)(local_20 + 0xc);\n  }\n  if (local_10 != '\\0') {\n    *(uint *)(local_28 + 0x3a8) = *(uint *)(local_28 + 0x3a8) & 0xfffffffd;\n  }\n  return param_1;\n}\n\n",
  "BuildCatchObjectInternal<class___FrameHandler4>": "\n/* Library Function - Single Match\n    void __cdecl BuildCatchObjectInternal<class __FrameHandler4>(struct EHExceptionRecord *\n   __ptr64,void * __ptr64,struct FH4::HandlerType4 * __ptr64,struct _s_CatchableType const *\n   __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl\nBuildCatchObjectInternal<class___FrameHandler4>\n          (EHExceptionRecord *param_1,void *param_2,HandlerType4 *param_3,_s_CatchableType *param_4)\n\n{\n  int iVar1;\n  void *pvVar2;\n  longlong lVar3;\n  longlong lVar4;\n  undefined *UNRECOVERED_JUMPTABLE;\n  void *pvVar5;\n  \n  UNRECOVERED_JUMPTABLE = (undefined *)0x0;\n  pvVar5 = param_2;\n  if (-1 < *(int *)(param_3 + 4)) {\n                    /* WARNING: Load size is inaccurate */\n    pvVar5 = (void *)((ulonglong)*(uint *)(param_3 + 0xc) + *param_2);\n  }\n  iVar1 = BuildCatchObjectHelperInternal<class___FrameHandler4>(param_1,param_2,param_3,param_4);\n  if (iVar1 == 1) {\n    lVar3 = __AdjustPointer(*(longlong *)(param_1 + 0x28),(int *)(param_4 + 8));\n    if (*(int *)(param_4 + 0x18) != 0) {\n      lVar4 = _GetThrowImageBase();\n      UNRECOVERED_JUMPTABLE = (undefined *)(*(int *)(param_4 + 0x18) + lVar4);\n    }\n    FUN_14000bb50(pvVar5,UNRECOVERED_JUMPTABLE,lVar3);\n  }\n  else if (iVar1 == 2) {\n    pvVar2 = (void *)__AdjustPointer(*(longlong *)(param_1 + 0x28),(int *)(param_4 + 8));\n    if (*(int *)(param_4 + 0x18) != 0) {\n      lVar3 = _GetThrowImageBase();\n      UNRECOVERED_JUMPTABLE = (undefined *)(*(int *)(param_4 + 0x18) + lVar3);\n    }\n    _CallMemberFunction2(pvVar5,UNRECOVERED_JUMPTABLE,pvVar2,1);\n  }\n  return;\n}\n\n",
  "FUN_14000b938": "\nundefined FUN_14000b938(longlong param_1,int *param_2)\n\n{\n  _s_ThrowInfo *p_Var1;\n  int iVar2;\n  longlong lVar3;\n  longlong lVar4;\n  int iVar5;\n  int *piVar6;\n  int iVar7;\n  undefined uVar8;\n  undefined uVar9;\n  \n  if (param_2 == (int *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  uVar8 = 0;\n  iVar5 = 0;\n  uVar9 = 0;\n  if (0 < *param_2) {\n    do {\n      lVar3 = _GetThrowImageBase();\n      piVar6 = (int *)((longlong)*(int *)(*(longlong *)(param_1 + 0x30) + 0xc) + 4 + lVar3);\n      lVar3 = _GetThrowImageBase();\n      iVar7 = *(int *)(lVar3 + *(int *)(*(longlong *)(param_1 + 0x30) + 0xc));\n      uVar8 = uVar9;\n      if (0 < iVar7) {\n        do {\n          lVar3 = _GetThrowImageBase();\n          p_Var1 = *(_s_ThrowInfo **)(param_1 + 0x30);\n          iVar2 = *piVar6;\n          lVar4 = _GetImageBase();\n          iVar2 = TypeMatchHelper<class___FrameHandler3>\n                            ((_s_HandlerType *)\n                             ((longlong)param_2[1] + lVar4 + (longlong)iVar5 * 0x14),\n                             (_s_CatchableType *)(lVar3 + iVar2),p_Var1);\n          if (iVar2 != 0) {\n            uVar8 = 1;\n            break;\n          }\n          iVar7 = iVar7 + -1;\n          piVar6 = piVar6 + 1;\n        } while (0 < iVar7);\n      }\n      iVar5 = iVar5 + 1;\n      uVar9 = uVar8;\n    } while (iVar5 < *param_2);\n  }\n  return uVar8;\n}\n\n",
  "_Deletegloballocale": "\n/* Library Function - Single Match\n    _Deletegloballocale\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _Deletegloballocale(longlong **param_1)\n\n{\n  longlong lVar1;\n  \n  if (*param_1 != (longlong *)0x0) {\n    lVar1 = (*(code *)PTR__guard_dispatch_icall_140023298)();\n    if (lVar1 != 0) {\n      (*(code *)PTR__guard_dispatch_icall_140023298)(lVar1,1);\n    }\n  }\n  return;\n}\n\n",
  "FUN_1400060f0": "\nvoid FUN_1400060f0(void)\n\n{\n  code *pcVar1;\n  bool bVar2;\n  char cVar3;\n  int iVar4;\n  undefined8 uVar5;\n  undefined4 *puVar6;\n  undefined7 extraout_var;\n  \n  FUN_140011e0c(1);\n  uVar5 = FUN_140006a80();\n  _set_fmode((int)uVar5);\n  uVar5 = FUN_140004b0c();\n  puVar6 = (undefined4 *)FUN_140014328();\n  *puVar6 = (int)uVar5;\n  uVar5 = __scrt_initialize_onexit_tables(1);\n  if ((char)uVar5 != '\\0') {\n    FUN_140006cf4();\n    atexit((_func_5014 *)&LAB_140006d30);\n    uVar5 = FUN_140004578();\n    iVar4 = _configure_narrow_argv((int)uVar5);\n    if (iVar4 == 0) {\n      FUN_140006a88();\n      bVar2 = FUN_140006abc();\n      if ((int)CONCAT71(extraout_var,bVar2) != 0) {\n        FUN_140011e6c(0x140004b0c);\n      }\n      _guard_check_icall();\n      _guard_check_icall();\n      uVar5 = FUN_140004b0c();\n      _configthreadlocale((int)uVar5);\n      cVar3 = FUN_140004574();\n      if (cVar3 != '\\0') {\n        common_initialize_environment_nolock<char>();\n      }\n      FUN_140004b0c();\n      uVar5 = thunk_FUN_140004b0c();\n      if ((int)uVar5 == 0) {\n        return;\n      }\n    }\n  }\n  FUN_140006ae0(7);\n  pcVar1 = (code *)swi(3);\n  (*pcVar1)();\n  return;\n}\n\n",
  "_IsNonwritableInCurrentImage": "\n/* Library Function - Single Match\n    _IsNonwritableInCurrentImage\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nBOOL __cdecl _IsNonwritableInCurrentImage(PBYTE pTarget)\n\n{\n  uint uVar1;\n  PIMAGE_SECTION_HEADER p_Var2;\n  \n  uVar1 = _ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_140000000);\n  p_Var2 = (PIMAGE_SECTION_HEADER)(ulonglong)uVar1;\n  if (uVar1 != 0) {\n    p_Var2 = _FindPESection((PBYTE)&IMAGE_DOS_HEADER_140000000,(DWORD_PTR)(pTarget + -0x140000000));\n    if (p_Var2 != (PIMAGE_SECTION_HEADER)0x0) {\n      p_Var2 = (PIMAGE_SECTION_HEADER)(ulonglong)(~(p_Var2->Characteristics >> 0x1f) & 1);\n    }\n  }\n  return (BOOL)p_Var2;\n}\n\n",
  "FUN_1400018e0": "\nundefined8 * FUN_1400018e0(undefined8 *param_1,longlong param_2)\n\n{\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  __std_exception_copy((char **)(param_2 + 8),(char **)(param_1 + 1));\n  *param_1 = std::bad_cast::vftable;\n  return param_1;\n}\n\n",
  "__acrt_LCMapStringW": "\n/* Library Function - Single Match\n    __acrt_LCMapStringW\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_LCMapStringW(ushort *param_1,DWORD param_2,undefined (*param_3) [32],int param_4,\n                        LPWSTR param_5,int param_6)\n\n{\n  int iVar1;\n  ulonglong uVar2;\n  int iVar3;\n  \n  iVar3 = param_4;\n  if (0 < param_4) {\n    uVar2 = FUN_140011a3c(param_3,(longlong)param_4);\n    iVar1 = (int)uVar2;\n    iVar3 = iVar1 + 1;\n    if (param_4 <= iVar1) {\n      iVar3 = iVar1;\n    }\n  }\n  __acrt_LCMapStringEx(param_1,param_2,(LPCWSTR)param_3,iVar3,param_5,param_6,0,0,0);\n  return;\n}\n\n",
  "FUN_140002b30": "\nundefined8 *\nFUN_140002b30(undefined8 *param_1,ulonglong param_2,undefined8 param_3,undefined8 *param_4,\n             ulonglong param_5)\n\n{\n  ulonglong uVar1;\n  ulonglong uVar2;\n  ulonglong uVar3;\n  undefined8 *puVar4;\n  code *pcVar5;\n  void *pvVar6;\n  ulonglong uVar7;\n  __uint64 _Var8;\n  ulonglong uVar9;\n  undefined8 *puVar10;\n  undefined8 *puVar11;\n  \n  uVar2 = param_1[2];\n  if (0x7fffffffffffffff - uVar2 < param_2) {\n    FUN_140001380();\n    pcVar5 = (code *)swi(3);\n    puVar11 = (undefined8 *)(*pcVar5)();\n    return puVar11;\n  }\n  uVar3 = param_1[3];\n  uVar7 = param_2 + uVar2 | 0xf;\n  uVar9 = 0x7fffffffffffffff;\n  if (((uVar7 < 0x8000000000000000) && (uVar3 <= 0x7fffffffffffffff - (uVar3 >> 1))) &&\n     (uVar1 = (uVar3 >> 1) + uVar3, uVar9 = uVar7, uVar7 < uVar1)) {\n    uVar9 = uVar1;\n  }\n  _Var8 = uVar9 + 1;\n  if (uVar9 == 0xffffffffffffffff) {\n    _Var8 = 0xffffffffffffffff;\n  }\n  if (_Var8 < 0x1000) {\n    if (_Var8 == 0) {\n      puVar11 = (undefined8 *)0x0;\n    }\n    else {\n      puVar11 = (undefined8 *)operator_new(_Var8);\n    }\n  }\n  else {\n    if (_Var8 + 0x27 <= _Var8) {\n      FUN_1400012e0();\n      pcVar5 = (code *)swi(3);\n      puVar11 = (undefined8 *)(*pcVar5)();\n      return puVar11;\n    }\n    pvVar6 = operator_new(_Var8 + 0x27);\n    if (pvVar6 == (void *)0x0) goto LAB_140002caa;\n    puVar11 = (undefined8 *)((longlong)pvVar6 + 0x27U & 0xffffffffffffffe0);\n    puVar11[-1] = pvVar6;\n  }\n  param_1[2] = param_2 + uVar2;\n  puVar10 = (undefined8 *)((longlong)puVar11 + uVar2);\n  param_1[3] = uVar9;\n  if (uVar3 < 0x10) {\n    FUN_140007ed0(puVar11,param_1,uVar2);\n    FUN_140007ed0(puVar10,param_4,param_5);\n    *(undefined *)((longlong)puVar10 + param_5) = 0;\n  }\n  else {\n    puVar4 = (undefined8 *)*param_1;\n    FUN_140007ed0(puVar11,puVar4,uVar2);\n    FUN_140007ed0(puVar10,param_4,param_5);\n    *(undefined *)((longlong)puVar10 + param_5) = 0;\n    puVar10 = puVar4;\n    if ((0xfff < uVar3 + 1) &&\n       (puVar10 = (undefined8 *)puVar4[-1],\n       0x1f < (ulonglong)((longlong)puVar4 + (-8 - (longlong)puVar10)))) {\nLAB_140002caa:\n      FUN_14000d050();\n      pcVar5 = (code *)swi(3);\n      puVar11 = (undefined8 *)(*pcVar5)();\n      return puVar11;\n    }\n    thunk_FUN_14000ce08(puVar10);\n  }\n  *param_1 = puVar11;\n  return param_1;\n}\n\n",
  "FUN_140014858": "\nvoid FUN_140014858(void)\n\n{\n  __acrt_execute_initializers(&PTR_LAB_1400280f0,&PTR_DAT_1400281f0);\n  return;\n}\n\n",
  "__acrt_stdio_begin_temporary_buffering_nolock": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    __acrt_stdio_begin_temporary_buffering_nolock\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nulonglong __acrt_stdio_begin_temporary_buffering_nolock(FILE *param_1)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  int iVar3;\n  undefined4 extraout_var;\n  FILE *pFVar4;\n  char *pcVar5;\n  char **ppcVar6;\n  \n  iVar3 = _fileno(param_1);\n  iVar3 = _isatty(iVar3);\n  pFVar4 = (FILE *)CONCAT44(extraout_var,iVar3);\n  if (iVar3 == 0) {\nLAB_1400186c2:\n    return (ulonglong)pFVar4 & 0xffffffffffffff00;\n  }\n  pFVar4 = (FILE *)__acrt_iob_func(1);\n  if (param_1 == pFVar4) {\n    ppcVar6 = (char **)&DAT_140037898;\n  }\n  else {\n    pFVar4 = (FILE *)__acrt_iob_func(2);\n    if (param_1 != pFVar4) goto LAB_1400186c2;\n    ppcVar6 = (char **)&DAT_1400378a0;\n  }\n  _DAT_1400370e8 = _DAT_1400370e8 + 1;\n  uVar2 = *(uint *)((longlong)&param_1->_base + 4);\n  pFVar4 = (FILE *)(ulonglong)uVar2;\n  if ((uVar2 & 0x4c0) != 0) goto LAB_1400186c2;\n  LOCK();\n  puVar1 = (uint *)((longlong)&param_1->_base + 4);\n  *puVar1 = *puVar1 | 0x282;\n  UNLOCK();\n  pcVar5 = *ppcVar6;\n  if (pcVar5 == (char *)0x0) {\n    pcVar5 = (char *)_malloc_base(0x1000);\n    *ppcVar6 = pcVar5;\n    _free_base((LPVOID)0x0);\n    pcVar5 = *ppcVar6;\n    if (pcVar5 == (char *)0x0) {\n      *(undefined4 *)&param_1->_base = 2;\n      *(int **)&param_1->_cnt = &param_1->_file;\n      param_1->_ptr = (char *)&param_1->_file;\n      param_1->_charbuf = 2;\n      pcVar5 = (char *)0x0;\n      goto LAB_1400186a4;\n    }\n  }\n  *(char **)&param_1->_cnt = pcVar5;\n  pcVar5 = *ppcVar6;\n  param_1->_ptr = pcVar5;\n  *(undefined4 *)&param_1->_base = 0x1000;\n  param_1->_charbuf = 0x1000;\nLAB_1400186a4:\n  return CONCAT71((int7)((ulonglong)pcVar5 >> 8),1);\n}\n\n",
  "FUN_14001fb48": "\nuint FUN_14001fb48(uint param_1)\n\n{\n  return param_1 | 0x400000;\n}\n\n",
  "__scrt_initialize_onexit_tables": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    __scrt_initialize_onexit_tables\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __scrt_initialize_onexit_tables(uint param_1)\n\n{\n  code *pcVar1;\n  bool bVar2;\n  ulonglong in_RAX;\n  undefined7 extraout_var;\n  undefined8 uVar3;\n  \n  if (DAT_140036751 == '\\0') {\n    if (1 < param_1) {\n      FUN_140006ae0(5);\n      pcVar1 = (code *)swi(3);\n      uVar3 = (*pcVar1)();\n      return uVar3;\n    }\n    bVar2 = __scrt_is_ucrt_dll_in_use();\n    if (((int)CONCAT71(extraout_var,bVar2) == 0) || (param_1 != 0)) {\n      in_RAX = 0xffffffffffffffff;\n      DAT_140036758._0_4_ = _DAT_140024760;\n      DAT_140036758._4_4_ = _UNK_140024764;\n      uRam0000000140036760 = _UNK_140024768;\n      uRam0000000140036764 = _UNK_14002476c;\n      _DAT_140036768 = 0xffffffffffffffff;\n      _DAT_140036770 = _DAT_140024760;\n      uRam0000000140036774 = _UNK_140024764;\n      uRam0000000140036778 = _UNK_140024768;\n      uRam000000014003677c = _UNK_14002476c;\n      _DAT_140036780 = 0xffffffffffffffff;\n    }\n    else {\n      in_RAX = _initialize_onexit_table(&DAT_140036758);\n      if (((int)in_RAX != 0) ||\n         (in_RAX = _initialize_onexit_table((longlong *)&DAT_140036770), (int)in_RAX != 0)) {\n        return in_RAX & 0xffffffffffffff00;\n      }\n    }\n    DAT_140036751 = '\\x01';\n  }\n  return CONCAT71((int7)(in_RAX >> 8),1);\n}\n\n",
  "__C_specific_handler": "\n/* Library Function - Single Match\n    __C_specific_handler\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nEXCEPTION_DISPOSITION\n__C_specific_handler\n          (_EXCEPTION_RECORD *ExceptionRecord,void *EstablisherFrame,_CONTEXT *ContextRecord,\n          _DISPATCHER_CONTEXT *DispatcherContext)\n\n{\n  longlong lVar1;\n  uint *puVar2;\n  int iVar3;\n  BOOL BVar4;\n  ulonglong uVar5;\n  ulonglong uVar6;\n  uint uVar7;\n  ulonglong uVar8;\n  uint uVar9;\n  ulonglong uVar10;\n  uint uVar11;\n  ulonglong uVar12;\n  uint uVar13;\n  ulonglong uVar14;\n  _EXCEPTION_RECORD *local_38;\n  _CONTEXT *local_30;\n  \n  __except_validate_context_record((longlong)ContextRecord);\n  lVar1 = *(longlong *)(DispatcherContext + 8);\n  puVar2 = *(uint **)(DispatcherContext + 0x38);\n  uVar14 = *(longlong *)DispatcherContext - lVar1;\n  uVar7 = *(uint *)(DispatcherContext + 0x48);\n  local_38 = ExceptionRecord;\n  local_30 = ContextRecord;\n  if ((*(byte *)&ExceptionRecord->ExceptionFlags & 0x66) == 0) {\n    for (; uVar7 < *puVar2; uVar7 = uVar7 + 1) {\n      uVar8 = (ulonglong)uVar7;\n      if (((puVar2[uVar8 * 4 + 1] <= uVar14) && (uVar14 < puVar2[uVar8 * 4 + 2])) &&\n         (puVar2[uVar8 * 4 + 4] != 0)) {\n        if (puVar2[uVar8 * 4 + 3] != 1) {\n          iVar3 = (*(code *)((ulonglong)puVar2[uVar8 * 4 + 3] + lVar1))(&local_38,EstablisherFrame);\n          if (iVar3 < 0) {\n            return ExceptionContinueExecution;\n          }\n          if (iVar3 < 1) goto LAB_1400089a2;\n        }\n        if (((ExceptionRecord->ExceptionCode == 0xe06d7363) &&\n            (PTR___DestructExceptionObject_1400248d8 != (undefined *)0x0)) &&\n           (BVar4 = _IsNonwritableInCurrentImage((PBYTE)&PTR___DestructExceptionObject_1400248d8),\n           BVar4 != 0)) {\n          (*(code *)PTR___DestructExceptionObject_1400248d8)(ExceptionRecord,1);\n        }\n        FUN_14000bd20();\n        RtlUnwindEx(EstablisherFrame,(PVOID)((ulonglong)puVar2[uVar8 * 4 + 4] + lVar1),\n                    ExceptionRecord,(PVOID)(ulonglong)ExceptionRecord->ExceptionCode,\n                    *(PCONTEXT *)(DispatcherContext + 0x28),\n                    *(PUNWIND_HISTORY_TABLE *)(DispatcherContext + 0x40));\n        FUN_14000bd50();\n      }\nLAB_1400089a2:\n    }\n  }\n  else {\n    uVar9 = *puVar2;\n    uVar10 = (ulonglong)uVar9;\n    uVar8 = *(longlong *)(DispatcherContext + 0x20) - lVar1;\n    if (uVar7 < uVar9) {\n      do {\n        uVar6 = (ulonglong)uVar7;\n        if ((puVar2[uVar6 * 4 + 1] <= uVar14) && (uVar14 < puVar2[uVar6 * 4 + 2])) {\n          uVar13 = ExceptionRecord->ExceptionFlags & 0x20;\n          uVar5 = (ulonglong)uVar9;\n          if (uVar13 != 0) {\n            uVar12 = 0;\n            if (uVar9 != 0) {\n              do {\n                if ((((puVar2[uVar12 * 4 + 1] <= uVar8) && (uVar8 < puVar2[uVar12 * 4 + 2])) &&\n                    (puVar2[uVar12 * 4 + 4] == puVar2[uVar6 * 4 + 4])) &&\n                   (puVar2[uVar12 * 4 + 3] == puVar2[uVar6 * 4 + 3])) break;\n                uVar11 = (int)uVar12 + 1;\n                uVar12 = (ulonglong)uVar11;\n              } while (uVar11 < uVar9);\n            }\n            uVar5 = uVar10;\n            if ((int)uVar12 != (int)uVar10) {\n              return ExceptionContinueSearch;\n            }\n          }\n          uVar9 = (uint)uVar5;\n          if (puVar2[uVar6 * 4 + 4] == 0) {\n            *(uint *)(DispatcherContext + 0x48) = uVar7 + 1;\n            (*(code *)((ulonglong)puVar2[uVar6 * 4 + 3] + lVar1))\n                      (CONCAT71((int7)(uVar5 >> 8),1),EstablisherFrame);\n            uVar9 = *puVar2;\n            uVar10 = (ulonglong)uVar9;\n          }\n          else if ((uVar8 == puVar2[uVar6 * 4 + 4]) && (uVar13 != 0)) {\n            return ExceptionContinueSearch;\n          }\n        }\n        uVar7 = uVar7 + 1;\n      } while (uVar7 < uVar9);\n    }\n  }\n  return ExceptionContinueSearch;\n}\n\n",
  "__acrt_errno_from_os_error": "\n/* Library Function - Single Match\n    __acrt_errno_from_os_error\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined4 __acrt_errno_from_os_error(int param_1)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  ulonglong uVar3;\n  int *piVar4;\n  \n  uVar3 = 0;\n  piVar4 = &DAT_140025800;\n  do {\n    if (param_1 == *piVar4) {\n      return (&DAT_140025804)[uVar3 * 2];\n    }\n    uVar1 = (int)uVar3 + 1;\n    uVar3 = (ulonglong)uVar1;\n    piVar4 = piVar4 + 2;\n  } while (uVar1 < 0x2d);\n  if (param_1 - 0x13U < 0x12) {\n    return 0xd;\n  }\n  uVar2 = 0x16;\n  if (param_1 - 0xbcU < 0xf) {\n    uVar2 = 8;\n  }\n  return uVar2;\n}\n\n",
  "FUN_14000d390": "\nvoid FUN_14000d390(longlong param_1)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00014000d394. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  LeaveCriticalSection((LPCRITICAL_SECTION)(param_1 + 0x30));\n  return;\n}\n\n",
  "__acrt_can_use_vista_locale_apis": "\n/* Library Function - Single Match\n    __acrt_can_use_vista_locale_apis\n   \n   Library: Visual Studio 2019 Release */\n\nbool __acrt_can_use_vista_locale_apis(void)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = try_get_function(1,\"CompareStringEx\",(module_id *)&DAT_140028d90,\n                            (module_id *)\"CompareStringEx\");\n  return pvVar1 != (void *)0x0;\n}\n\n",
  "FUN_140001300": "\nundefined8 * FUN_140001300(undefined8 *param_1,longlong param_2)\n\n{\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  __std_exception_copy((char **)(param_2 + 8),(char **)(param_1 + 1));\n  *param_1 = std::bad_array_new_length::vftable;\n  return param_1;\n}\n\n",
  "FUN_14000d030": "\nvoid FUN_14000d030(void)\n\n{\n  _invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n  return;\n}\n\n",
  "write_text_utf16le_nolock": "\n/* WARNING: Function: __chkstk replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    struct `anonymous namespace'::write_result __cdecl write_text_utf16le_nolock(int,char const *\n   __ptr64 const,unsigned int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl write_text_utf16le_nolock(DWORD *param_1,uint param_2,short *param_3,ulonglong param_4)\n\n{\n  short sVar1;\n  HANDLE hFile;\n  uint nNumberOfBytesToWrite;\n  BOOL BVar2;\n  DWORD DVar3;\n  short *psVar4;\n  short *psVar5;\n  undefined auStackY_1468 [32];\n  uint local_1438 [4];\n  short local_1428 [2560];\n  ulonglong local_28;\n  undefined8 uStack_20;\n  \n  uStack_20 = 0x140016a44;\n  local_28 = DAT_140035020 ^ (ulonglong)auStackY_1468;\n  psVar5 = (short *)((param_4 & 0xffffffff) + (longlong)param_3);\n  hFile = *(HANDLE *)\n           ((&DAT_140037490)[(longlong)(int)param_2 >> 6] + 0x28 +\n           (ulonglong)(param_2 & 0x3f) * 0x48);\n  *(undefined8 *)param_1 = 0;\n  param_1[2] = 0;\n  if (psVar5 <= param_3) {\nLAB_140016b1a:\n    FUN_140006060(local_28 ^ (ulonglong)auStackY_1468);\n    return;\n  }\n  do {\n    psVar4 = local_1428;\n    do {\n      if (psVar5 <= param_3) break;\n      sVar1 = *param_3;\n      param_3 = param_3 + 1;\n      if (sVar1 == 10) {\n        param_1[2] = param_1[2] + 2;\n        *psVar4 = 0xd;\n        psVar4 = psVar4 + 1;\n      }\n      *psVar4 = sVar1;\n      psVar4 = psVar4 + 1;\n    } while (psVar4 < local_1428 + 0x9ff);\n    nNumberOfBytesToWrite = (int)((longlong)psVar4 - (longlong)local_1428 >> 1) * 2;\n    BVar2 = WriteFile(hFile,local_1428,nNumberOfBytesToWrite,local_1438,(LPOVERLAPPED)0x0);\n    if (BVar2 == 0) {\n      DVar3 = GetLastError();\n      *param_1 = DVar3;\n      goto LAB_140016b1a;\n    }\n    param_1[1] = param_1[1] + local_1438[0];\n    if ((local_1438[0] < nNumberOfBytesToWrite) || (psVar5 <= param_3)) goto LAB_140016b1a;\n  } while( true );\n}\n\n",
  "FUN_140001780": "\nundefined8 * FUN_140001780(undefined8 *param_1,longlong param_2)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  \n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  __std_exception_copy((char **)(param_2 + 8),(char **)(param_1 + 1));\n  *param_1 = std::_System_error::vftable;\n  uVar1 = *(undefined4 *)(param_2 + 0x1c);\n  uVar2 = *(undefined4 *)(param_2 + 0x20);\n  uVar3 = *(undefined4 *)(param_2 + 0x24);\n  *(undefined4 *)(param_1 + 3) = *(undefined4 *)(param_2 + 0x18);\n  *(undefined4 *)((longlong)param_1 + 0x1c) = uVar1;\n  *(undefined4 *)(param_1 + 4) = uVar2;\n  *(undefined4 *)((longlong)param_1 + 0x24) = uVar3;\n  return param_1;\n}\n\n",
  "FUN_14001a1cc": "\nvoid FUN_14001a1cc(wchar_t *param_1,char *param_2,size_t param_3)\n\n{\n  _mbtowc_l(param_1,param_2,param_3,(_locale_t)0x0);\n  return;\n}\n\n",
  "xsgetn": "\n/* Library Function - Single Match\n    protected: virtual __int64 __cdecl std::basic_streambuf<char,struct std::char_traits<char>\n   >::xsgetn(char * __ptr64,__int64) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\n__int64 __thiscall\nstd::basic_streambuf<char,struct_std::char_traits<char>_>::xsgetn\n          (basic_streambuf<char,struct_std::char_traits<char>_> *this,char *param_1,__int64 param_2)\n\n{\n  longlong lVar1;\n  int iVar2;\n  ulonglong uVar3;\n  ulonglong uVar4;\n  ulonglong uVar5;\n  \n  uVar4 = param_2;\n  if (0 < param_2) {\n    do {\n      if (((undefined8 *)**(undefined8 **)(this + 0x38) == (undefined8 *)0x0) ||\n         (uVar3 = (ulonglong)**(int **)(this + 0x50), **(int **)(this + 0x50) < 1)) {\n        iVar2 = (*(code *)PTR__guard_dispatch_icall_140023298)(this);\n        if (iVar2 == -1) break;\n        *param_1 = (char)iVar2;\n        lVar1 = -1;\n        uVar5 = 1;\n      }\n      else {\n        uVar5 = uVar4;\n        if ((longlong)uVar3 <= (longlong)uVar4) {\n          uVar5 = uVar3;\n        }\n        FUN_140007ed0((undefined8 *)param_1,(undefined8 *)**(undefined8 **)(this + 0x38),uVar5);\n        lVar1 = -uVar5;\n        **(int **)(this + 0x50) = **(int **)(this + 0x50) - (int)uVar5;\n        **(longlong **)(this + 0x38) = **(longlong **)(this + 0x38) + (longlong)(int)uVar5;\n      }\n      uVar4 = uVar4 + lVar1;\n      param_1 = param_1 + uVar5;\n    } while (0 < (longlong)uVar4);\n  }\n  return param_2 - uVar4;\n}\n\n",
  "FUN_140001d10": "\nundefined FUN_140001d10(undefined8 param_1,undefined param_2)\n\n{\n  return param_2;\n}\n\n",
  "FUN_14000d384": "\nvoid FUN_14000d384(longlong param_1)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00014000d388. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  EnterCriticalSection((LPCRITICAL_SECTION)(param_1 + 0x30));\n  return;\n}\n\n",
  "_malloc_base": "\nLPVOID _malloc_base(ulonglong param_1)\n\n{\n  int iVar1;\n  LPVOID pvVar2;\n  ulong *puVar3;\n  \n  if (param_1 < 0xffffffffffffffe1) {\n    if (param_1 == 0) {\n      param_1 = 1;\n    }\n    do {\n      pvVar2 = HeapAlloc(DAT_1400379d8,0,param_1);\n      if (pvVar2 != (LPVOID)0x0) {\n        return pvVar2;\n      }\n      iVar1 = FUN_1400142f4();\n    } while ((iVar1 != 0) && (iVar1 = _callnewh(param_1), iVar1 != 0));\n  }\n  puVar3 = __doserrno();\n  *puVar3 = 0xc;\n  return (LPVOID)0x0;\n}\n\n",
  "FUN_14000393c": "\nundefined8 * FUN_14000393c(undefined8 *param_1,longlong param_2)\n\n{\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  __std_exception_copy((char **)(param_2 + 8),(char **)(param_1 + 1));\n  *param_1 = std::logic_error::vftable;\n  return param_1;\n}\n\n",
  "FUN_14001f8d0": "\nvoid FUN_14001f8d0(undefined8 param_1,uint param_2,undefined8 param_3,int param_4,uint param_5,\n                  uint param_6,undefined8 param_7,undefined8 param_8,int param_9)\n\n{\n  undefined8 uVar1;\n  bool bVar2;\n  uint uVar3;\n  undefined4 extraout_var_00;\n  undefined7 extraout_var;\n  undefined auStackY_118 [32];\n  ulonglong local_d8;\n  undefined8 local_d0;\n  undefined8 local_c8;\n  uint local_b8 [12];\n  undefined8 local_88;\n  uint local_78;\n  ulonglong local_48;\n  \n  local_48 = DAT_140035020 ^ (ulonglong)auStackY_118;\n  uVar3 = _ctrlfp(0x1f80,0xffc0);\n  local_d8 = CONCAT44(extraout_var_00,uVar3);\n  local_d0 = param_3;\n  local_c8 = param_3;\n  bVar2 = _exception_enabled(param_5,local_d8);\n  uVar1 = param_8;\n  if ((int)CONCAT71(extraout_var,bVar2) == 0) {\n    if (param_9 == 2) {\n      local_88 = param_8;\n      local_78 = local_78 & 0xffffffe3 | 3;\n    }\n    _raise_exc(local_b8,&local_d8,(ulonglong)param_5,param_2,(uint *)&param_7,(uint *)&local_d0);\n  }\n  bVar2 = FUN_140011e14();\n  if ((bVar2) && (param_4 != 0)) {\n    FUN_14001f7ac(param_4,(ulonglong)param_6,param_1,param_7,uVar1,local_d0,(uint)local_d8);\n  }\n  else {\n    _set_errno_from_matherr(param_4);\n    _ctrlfp((uint)local_d8,0xffc0);\n  }\n  FUN_140006060(local_48 ^ (ulonglong)auStackY_118);\n  return;\n}\n\n",
  "_free_base": "\n/* Library Function - Single Match\n    _free_base\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _free_base(LPVOID param_1)\n\n{\n  BOOL BVar1;\n  DWORD DVar2;\n  ulong uVar3;\n  ulong *puVar4;\n  \n  if ((param_1 != (LPVOID)0x0) && (BVar1 = HeapFree(DAT_1400379d8,0,param_1), BVar1 == 0)) {\n    puVar4 = __doserrno();\n    DVar2 = GetLastError();\n    uVar3 = __acrt_errno_from_os_error(DVar2);\n    *puVar4 = uVar3;\n  }\n  return;\n}\n\n",
  "FUN_140002860": "\nlonglong * FUN_140002860(longlong *param_1,longlong param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  byte bVar1;\n  int iVar2;\n  longlong *plVar3;\n  byte *pbVar4;\n  bool bVar5;\n  longlong lVar6;\n  undefined8 *puVar7;\n  longlong lVar8;\n  uint uVar9;\n  longlong lVar10;\n  char *pcVar11;\n  uint uVar12;\n  longlong lVar13;\n  longlong *local_68 [2];\n  char ****local_58 [6];\n  \n  lVar10 = 0;\n  uVar12 = 0;\n  lVar13 = -1;\n  do {\n    lVar13 = lVar13 + 1;\n  } while (*(char *)(param_2 + lVar13) != '\\0');\n  lVar8 = *param_1;\n  lVar6 = *(longlong *)((longlong)*(int *)(lVar8 + 4) + 0x28 + (longlong)param_1);\n  if ((0 < lVar6) && (lVar13 < lVar6)) {\n    lVar10 = lVar6 - lVar13;\n  }\n  plVar3 = *(longlong **)((longlong)*(int *)(lVar8 + 4) + 0x48 + (longlong)param_1);\n  local_68[0] = param_1;\n  if (plVar3 != (longlong *)0x0) {\n    (**(code **)(*plVar3 + 8))(plVar3);\n    lVar8 = *param_1;\n  }\n  if (*(int *)((longlong)*(int *)(lVar8 + 4) + 0x10 + (longlong)param_1) == 0) {\n    plVar3 = *(longlong **)((longlong)*(int *)(lVar8 + 4) + 0x50 + (longlong)param_1);\n    if ((plVar3 == (longlong *)0x0) || (plVar3 == param_1)) {\n      bVar5 = true;\n    }\n    else {\n      FUN_140002dd0(plVar3);\n      lVar8 = *param_1;\n      bVar5 = *(int *)((longlong)*(int *)(lVar8 + 4) + 0x10 + (longlong)param_1) == 0;\n    }\n  }\n  else {\n    bVar5 = false;\n  }\n  if (bVar5) {\n    if ((*(uint *)((longlong)*(int *)(lVar8 + 4) + 0x18 + (longlong)param_1) & 0x1c0) != 0x40) {\n      for (; 0 < lVar10; lVar10 = lVar10 + -1) {\n        bVar1 = *(byte *)((longlong)*(int *)(*param_1 + 4) + 0x58 + (longlong)param_1);\n        plVar3 = *(longlong **)((longlong)*(int *)(*param_1 + 4) + 0x48 + (longlong)param_1);\n        if (*(longlong *)plVar3[8] == 0) {\nLAB_140002985:\n          uVar9 = (**(code **)(*plVar3 + 0x18))(plVar3,bVar1);\n        }\n        else {\n          iVar2 = *(int *)plVar3[0xb];\n          if (iVar2 < 1) goto LAB_140002985;\n          *(int *)plVar3[0xb] = iVar2 + -1;\n          pbVar4 = *(byte **)plVar3[8];\n          *(byte **)plVar3[8] = pbVar4 + 1;\n          *pbVar4 = bVar1;\n          uVar9 = (uint)bVar1;\n        }\n        if (uVar9 == 0xffffffff) {\n          uVar12 = 4;\n          goto LAB_140002a3c;\n        }\n      }\n    }\n    plVar3 = *(longlong **)((longlong)*(int *)(*param_1 + 4) + 0x48 + (longlong)param_1);\n    lVar6 = (**(code **)(*plVar3 + 0x48))(plVar3,param_2,lVar13);\n    if (lVar6 == lVar13) {\n      for (; 0 < lVar10; lVar10 = lVar10 + -1) {\n        bVar1 = *(byte *)((longlong)*(int *)(*param_1 + 4) + 0x58 + (longlong)param_1);\n        plVar3 = *(longlong **)((longlong)*(int *)(*param_1 + 4) + 0x48 + (longlong)param_1);\n        if (*(longlong *)plVar3[8] == 0) {\nLAB_140002a17:\n          uVar9 = (**(code **)(*plVar3 + 0x18))(plVar3,bVar1);\n        }\n        else {\n          iVar2 = *(int *)plVar3[0xb];\n          if (iVar2 < 1) goto LAB_140002a17;\n          *(int *)plVar3[0xb] = iVar2 + -1;\n          pbVar4 = *(byte **)plVar3[8];\n          *(byte **)plVar3[8] = pbVar4 + 1;\n          *pbVar4 = bVar1;\n          uVar9 = (uint)bVar1;\n        }\n        if (uVar9 == 0xffffffff) {\n          uVar12 = 4;\n          break;\n        }\n      }\n    }\n    else {\n      uVar12 = 4;\n    }\nLAB_140002a3c:\n    *(undefined8 *)((longlong)*(int *)(*param_1 + 4) + 0x28 + (longlong)param_1) = 0;\n  }\n  else {\n    uVar12 = 4;\n  }\n  iVar2 = *(int *)(*param_1 + 4);\n  uVar9 = 4;\n  if (*(longlong *)((longlong)param_1 + (longlong)iVar2 + 0x48) != 0) {\n    uVar9 = 0;\n  }\n  uVar9 = uVar9 | uVar12 | *(uint *)((longlong)param_1 + (longlong)iVar2 + 0x10) & 0x17;\n  *(uint *)((longlong)param_1 + (longlong)iVar2 + 0x10) = uVar9;\n  uVar9 = uVar9 & *(uint *)((longlong)param_1 + (longlong)iVar2 + 0x14);\n  if (uVar9 != 0) {\n    if ((uVar9 & 4) == 0) {\n      pcVar11 = \"ios_base::failbit set\";\n      if ((uVar9 & 2) == 0) {\n        pcVar11 = \"ios_base::eofbit set\";\n      }\n    }\n    else {\n      pcVar11 = \"ios_base::badbit set\";\n    }\n    puVar7 = (undefined8 *)FUN_140001450((undefined4 *)local_68,1);\n    FUN_140001dd0(local_58,(undefined8 *)pcVar11,puVar7);\n                    /* WARNING: Subroutine does not return */\n    _CxxThrowException(local_58,(ThrowInfo *)&DAT_140033c40);\n  }\n  bVar5 = __uncaught_exception();\n  if (!bVar5) {\n    FUN_140002ee0(param_1);\n  }\n  plVar3 = *(longlong **)((longlong)*(int *)(*param_1 + 4) + 0x48 + (longlong)param_1);\n  if (plVar3 != (longlong *)0x0) {\n    (**(code **)(*plVar3 + 0x10))();\n  }\n  return param_1;\n}\n\n",
  "FUN_140020070": "\n/* WARNING: Removing unreachable block (ram,0x00014002031c) */\n/* WARNING: Removing unreachable block (ram,0x000140020315) */\n/* WARNING: Removing unreachable block (ram,0x00014002030e) */\n/* WARNING: Removing unreachable block (ram,0x000140020307) */\n/* WARNING: Removing unreachable block (ram,0x000140020300) */\n/* WARNING: Removing unreachable block (ram,0x0001400202f9) */\n/* WARNING: Removing unreachable block (ram,0x0001400202f2) */\n/* WARNING: Removing unreachable block (ram,0x0001400202eb) */\n/* WARNING: Removing unreachable block (ram,0x0001400202e4) */\n/* WARNING: Removing unreachable block (ram,0x0001400202dd) */\n/* WARNING: Removing unreachable block (ram,0x0001400202d6) */\n/* WARNING: Removing unreachable block (ram,0x0001400202cf) */\n/* WARNING: Removing unreachable block (ram,0x0001400202c8) */\n/* WARNING: Removing unreachable block (ram,0x0001400202c1) */\n/* WARNING: Removing unreachable block (ram,0x0001400202ba) */\n/* WARNING: Removing unreachable block (ram,0x000140020172) */\n/* WARNING: Removing unreachable block (ram,0x000140020181) */\n/* WARNING: Removing unreachable block (ram,0x000140020190) */\n/* WARNING: Removing unreachable block (ram,0x00014002019f) */\n/* WARNING: Removing unreachable block (ram,0x0001400201ae) */\n/* WARNING: Removing unreachable block (ram,0x0001400201ba) */\n/* WARNING: Removing unreachable block (ram,0x0001400201c6) */\n/* WARNING: Removing unreachable block (ram,0x0001400201d2) */\n/* WARNING: Removing unreachable block (ram,0x0001400201de) */\n/* WARNING: Removing unreachable block (ram,0x0001400201ea) */\n/* WARNING: Removing unreachable block (ram,0x0001400201f6) */\n/* WARNING: Removing unreachable block (ram,0x000140020202) */\n/* WARNING: Removing unreachable block (ram,0x00014002020e) */\n/* WARNING: Removing unreachable block (ram,0x00014002021a) */\n/* WARNING: Removing unreachable block (ram,0x000140020226) */\n\nchar * FUN_140020070(char *param_1,char *param_2,undefined param_3,undefined param_4,\n                    undefined param_5,undefined param_6,undefined param_7,undefined8 param_8,\n                    undefined8 param_9)\n\n{\n  char cVar1;\n  ushort uVar2;\n  undefined auVar3 [16];\n  undefined auVar4 [16];\n  undefined auVar5 [16];\n  undefined auVar6 [16];\n  undefined auVar7 [16];\n  undefined auVar8 [16];\n  undefined auVar9 [16];\n  undefined auVar10 [16];\n  undefined auVar11 [16];\n  undefined auVar12 [16];\n  undefined auVar13 [16];\n  undefined auVar14 [16];\n  undefined auVar15 [16];\n  undefined auVar16 [16];\n  undefined auVar17 [16];\n  char *pcVar18;\n  undefined (*pauVar19) [16];\n  uint uVar20;\n  bool bVar22;\n  undefined auVar23 [16];\n  undefined auVar24 [16];\n  undefined auVar25 [16];\n  undefined auVar27 [16];\n  undefined auVar28 [16];\n  undefined auVar29 [16];\n  undefined auVar30 [16];\n  undefined auVar31 [16];\n  undefined auVar32 [16];\n  undefined auVar33 [16];\n  undefined auVar34 [16];\n  undefined auVar35 [16];\n  ulonglong uVar21;\n  longlong lVar26;\n  \n  uVar20 = (uint)param_2 & 0xf;\n  uVar21 = (ulonglong)uVar20;\n  pauVar19 = (undefined (*) [16])(param_2 + -uVar21);\n  auVar35 = *pauVar19;\n  switch(uVar21) {\n  case 1:\n    auVar35 = auVar35 >> 8;\n    break;\n  case 2:\n    auVar35 = auVar35 >> 0x10;\n    break;\n  case 3:\n    auVar35 = auVar35 >> 0x18;\n    break;\n  case 4:\n    auVar35 = auVar35 >> 0x20;\n    break;\n  case 5:\n    auVar35 = auVar35 >> 0x28;\n    break;\n  case 6:\n    auVar35 = auVar35 >> 0x30;\n    break;\n  case 7:\n    auVar35 = auVar35 >> 0x38;\n    break;\n  case 8:\n    auVar35 = auVar35 >> 0x40;\n    break;\n  case 9:\n    auVar35 = auVar35 >> 0x48;\n    break;\n  case 10:\n    auVar35 = auVar35 >> 0x50;\n    break;\n  case 0xb:\n    auVar35 = auVar35 >> 0x58;\n    break;\n  case 0xc:\n    auVar35 = auVar35 >> 0x60;\n    break;\n  case 0xd:\n    auVar35 = auVar35 >> 0x68;\n    break;\n  case 0xe:\n    auVar35 = auVar35 >> 0x70;\n    break;\n  case 0xf:\n    auVar35 = auVar35 >> 0x78;\n  }\n  auVar23[0] = -(auVar35[0] == '\\0');\n  auVar23[1] = -(auVar35[1] == '\\0');\n  auVar23[2] = -(auVar35[2] == '\\0');\n  auVar23[3] = -(auVar35[3] == '\\0');\n  auVar23[4] = -(auVar35[4] == '\\0');\n  auVar23[5] = -(auVar35[5] == '\\0');\n  auVar23[6] = -(auVar35[6] == '\\0');\n  auVar23[7] = -(auVar35[7] == '\\0');\n  auVar23[8] = -(auVar35[8] == '\\0');\n  auVar23[9] = -(auVar35[9] == '\\0');\n  auVar23[10] = -(auVar35[10] == '\\0');\n  auVar23[0xb] = -(auVar35[0xb] == '\\0');\n  auVar23[0xc] = -(auVar35[0xc] == '\\0');\n  auVar23[0xd] = -(auVar35[0xd] == '\\0');\n  auVar23[0xe] = -(auVar35[0xe] == '\\0');\n  auVar23[0xf] = -(auVar35[0xf] == '\\0');\n  uVar2 = (ushort)(SUB161(auVar23 >> 7,0) & 1) | (ushort)(SUB161(auVar23 >> 0xf,0) & 1) << 1 |\n          (ushort)(SUB161(auVar23 >> 0x17,0) & 1) << 2 |\n          (ushort)(SUB161(auVar23 >> 0x1f,0) & 1) << 3 |\n          (ushort)(SUB161(auVar23 >> 0x27,0) & 1) << 4 |\n          (ushort)(SUB161(auVar23 >> 0x2f,0) & 1) << 5 |\n          (ushort)(SUB161(auVar23 >> 0x37,0) & 1) << 6 |\n          (ushort)(SUB161(auVar23 >> 0x3f,0) & 1) << 7 |\n          (ushort)(SUB161(auVar23 >> 0x47,0) & 1) << 8 |\n          (ushort)(SUB161(auVar23 >> 0x4f,0) & 1) << 9 |\n          (ushort)(SUB161(auVar23 >> 0x57,0) & 1) << 10 |\n          (ushort)(SUB161(auVar23 >> 0x5f,0) & 1) << 0xb |\n          (ushort)(SUB161(auVar23 >> 0x67,0) & 1) << 0xc |\n          (ushort)(SUB161(auVar23 >> 0x6f,0) & 1) << 0xd |\n          (ushort)(SUB161(auVar23 >> 0x77,0) & 1) << 0xe | (ushort)(auVar23[0xf] >> 7) << 0xf;\n  if (uVar2 == 0) {\n    if (uVar21 == 0) {\n      if ((*pauVar19)[1] != (char)uVar20) {\n        pcVar18 = FID_conflict_fallbackMethod(param_1,param_2);\n        return pcVar18;\n      }\n      goto LAB_14002032e;\n    }\n  }\n  else {\n    uVar20 = 0;\n    if (uVar2 != 0) {\n      for (; (uVar2 >> uVar20 & 1) == 0; uVar20 = uVar20 + 1) {\n      }\n    }\n    if (uVar21 == 0) {\n      bVar22 = true;\n    }\n    else {\n      bVar22 = (ulonglong)uVar20 < 0x10 - uVar21;\n    }\n    lVar26 = auVar35._8_8_;\n    switch(-uVar20) {\n    case 0:\n      auVar35 = ZEXT816(0);\n      break;\n    case 0xfffffff1:\n      auVar27._0_8_ = auVar35._0_8_ << 8;\n      auVar27._8_8_ = lVar26 << 8 | auVar35._0_8_ >> 0x38;\n      auVar35 = auVar27 >> 8;\n      break;\n    case 0xfffffff2:\n      auVar28._0_8_ = auVar35._0_8_ << 0x10;\n      auVar28._8_8_ = lVar26 << 0x10 | auVar35._0_8_ >> 0x30;\n      auVar35 = auVar28 >> 0x10;\n      break;\n    case 0xfffffff3:\n      auVar29._0_8_ = auVar35._0_8_ << 0x18;\n      auVar29._8_8_ = lVar26 << 0x18 | auVar35._0_8_ >> 0x28;\n      auVar35 = auVar29 >> 0x18;\n      break;\n    case 0xfffffff4:\n      auVar30._0_8_ = auVar35._0_8_ << 0x20;\n      auVar30._8_8_ = lVar26 << 0x20 | auVar35._0_8_ >> 0x20;\n      auVar35 = auVar30 >> 0x20;\n      break;\n    case 0xfffffff5:\n      auVar31._0_8_ = auVar35._0_8_ << 0x28;\n      auVar31._8_8_ = lVar26 << 0x28 | auVar35._0_8_ >> 0x18;\n      auVar35 = auVar31 >> 0x28;\n      break;\n    case 0xfffffff6:\n      auVar32._0_8_ = auVar35._0_8_ << 0x30;\n      auVar32._8_8_ = lVar26 << 0x30 | auVar35._0_8_ >> 0x10;\n      auVar35 = auVar32 >> 0x30;\n      break;\n    case 0xfffffff7:\n      auVar33._0_8_ = auVar35._0_8_ << 0x38;\n      auVar33._8_8_ = lVar26 << 0x38 | auVar35._0_8_ >> 8;\n      auVar35 = auVar33 >> 0x38;\n      break;\n    case 0xfffffff8:\n      auVar35._8_8_ = 0;\n      break;\n    case 0xfffffff9:\n      auVar3._8_8_ = 0;\n      auVar3._0_8_ = auVar35._0_8_ << 8;\n      auVar35 = (auVar3 << 0x40) >> 0x48;\n      break;\n    case 0xfffffffa:\n      auVar4._8_8_ = 0;\n      auVar4._0_8_ = auVar35._0_8_ << 0x10;\n      auVar35 = (auVar4 << 0x40) >> 0x50;\n      break;\n    case 0xfffffffb:\n      auVar5._8_8_ = 0;\n      auVar5._0_8_ = auVar35._0_8_ << 0x18;\n      auVar35 = (auVar5 << 0x40) >> 0x58;\n      break;\n    case 0xfffffffc:\n      auVar6._8_8_ = 0;\n      auVar6._0_8_ = auVar35._0_8_ << 0x20;\n      auVar35 = (auVar6 << 0x40) >> 0x60;\n      break;\n    case 0xfffffffd:\n      auVar7._8_8_ = 0;\n      auVar7._0_8_ = auVar35._0_8_ << 0x28;\n      auVar35 = (auVar7 << 0x40) >> 0x68;\n      break;\n    case 0xfffffffe:\n      auVar8._8_8_ = 0;\n      auVar8._0_8_ = auVar35._0_8_ << 0x30;\n      auVar35 = (auVar8 << 0x40) >> 0x70;\n      break;\n    case 0xffffffff:\n      auVar9._8_8_ = 0;\n      auVar9._0_8_ = auVar35._0_8_ << 0x38;\n      auVar35 = (auVar9 << 0x40) >> 0x78;\n    }\n    if (bVar22) goto LAB_14002032e;\n  }\n  auVar34 = pauVar19[1];\n  auVar24[0] = -(auVar34[0] == '\\0');\n  auVar24[1] = -(auVar34[1] == '\\0');\n  auVar24[2] = -(auVar34[2] == '\\0');\n  auVar24[3] = -(auVar34[3] == '\\0');\n  auVar24[4] = -(auVar34[4] == '\\0');\n  auVar24[5] = -(auVar34[5] == '\\0');\n  auVar24[6] = -(auVar34[6] == '\\0');\n  lVar26 = auVar34._8_8_;\n  auVar24[7] = -(auVar34[7] == '\\0');\n  auVar24[8] = -(auVar34[8] == '\\0');\n  auVar24[9] = -(auVar34[9] == '\\0');\n  auVar24[10] = -(auVar34[10] == '\\0');\n  auVar24[0xb] = -(auVar34[0xb] == '\\0');\n  auVar24[0xc] = -(auVar34[0xc] == '\\0');\n  auVar24[0xd] = -(auVar34[0xd] == '\\0');\n  auVar24[0xe] = -(auVar34[0xe] == '\\0');\n  auVar24[0xf] = -(auVar34[0xf] == '\\0');\n  uVar2 = (ushort)(SUB161(auVar24 >> 7,0) & 1) | (ushort)(SUB161(auVar24 >> 0xf,0) & 1) << 1 |\n          (ushort)(SUB161(auVar24 >> 0x17,0) & 1) << 2 |\n          (ushort)(SUB161(auVar24 >> 0x1f,0) & 1) << 3 |\n          (ushort)(SUB161(auVar24 >> 0x27,0) & 1) << 4 |\n          (ushort)(SUB161(auVar24 >> 0x2f,0) & 1) << 5 |\n          (ushort)(SUB161(auVar24 >> 0x37,0) & 1) << 6 |\n          (ushort)(SUB161(auVar24 >> 0x3f,0) & 1) << 7 |\n          (ushort)(SUB161(auVar24 >> 0x47,0) & 1) << 8 |\n          (ushort)(SUB161(auVar24 >> 0x4f,0) & 1) << 9 |\n          (ushort)(SUB161(auVar24 >> 0x57,0) & 1) << 10 |\n          (ushort)(SUB161(auVar24 >> 0x5f,0) & 1) << 0xb |\n          (ushort)(SUB161(auVar24 >> 0x67,0) & 1) << 0xc |\n          (ushort)(SUB161(auVar24 >> 0x6f,0) & 1) << 0xd |\n          (ushort)(SUB161(auVar24 >> 0x77,0) & 1) << 0xe | (ushort)(auVar24[0xf] >> 7) << 0xf;\n  if (uVar2 != 0) {\n    uVar20 = 0;\n    if (uVar2 != 0) {\n      for (; (uVar2 >> uVar20 & 1) == 0; uVar20 = uVar20 + 1) {\n      }\n    }\n    if ((uVar20 - uVar21) + 0x10 < 0x11) {\n      uVar21 = auVar34._0_8_;\n      switch(-uVar20) {\n      case 0:\n        auVar34 = ZEXT816(0);\n        break;\n      case 0xfffffff1:\n        auVar34._0_8_ = uVar21 << 8;\n        auVar34._8_8_ = lVar26 << 8 | uVar21 >> 0x38;\n        break;\n      case 0xfffffff2:\n        auVar34._0_8_ = uVar21 << 0x10;\n        auVar34._8_8_ = lVar26 << 0x10 | uVar21 >> 0x30;\n        break;\n      case 0xfffffff3:\n        auVar34._0_8_ = uVar21 << 0x18;\n        auVar34._8_8_ = lVar26 << 0x18 | uVar21 >> 0x28;\n        break;\n      case 0xfffffff4:\n        auVar34._0_8_ = uVar21 << 0x20;\n        auVar34._8_8_ = lVar26 << 0x20 | uVar21 >> 0x20;\n        break;\n      case 0xfffffff5:\n        auVar34._0_8_ = uVar21 << 0x28;\n        auVar34._8_8_ = lVar26 << 0x28 | uVar21 >> 0x18;\n        break;\n      case 0xfffffff6:\n        auVar34._0_8_ = uVar21 << 0x30;\n        auVar34._8_8_ = lVar26 << 0x30 | uVar21 >> 0x10;\n        break;\n      case 0xfffffff7:\n        auVar34._0_8_ = uVar21 << 0x38;\n        auVar34._8_8_ = lVar26 << 0x38 | uVar21 >> 8;\n        break;\n      case 0xfffffff8:\n        auVar17._8_8_ = 0;\n        auVar17._0_8_ = uVar21;\n        auVar34 = auVar17 << 0x40;\n        break;\n      case 0xfffffff9:\n        auVar10._8_8_ = 0;\n        auVar10._0_8_ = uVar21 << 8;\n        auVar34 = auVar10 << 0x40;\n        break;\n      case 0xfffffffa:\n        auVar11._8_8_ = 0;\n        auVar11._0_8_ = uVar21 << 0x10;\n        auVar34 = auVar11 << 0x40;\n        break;\n      case 0xfffffffb:\n        auVar12._8_8_ = 0;\n        auVar12._0_8_ = uVar21 << 0x18;\n        auVar34 = auVar12 << 0x40;\n        break;\n      case 0xfffffffc:\n        auVar13._8_8_ = 0;\n        auVar13._0_8_ = uVar21 << 0x20;\n        auVar34 = auVar13 << 0x40;\n        break;\n      case 0xfffffffd:\n        auVar14._8_8_ = 0;\n        auVar14._0_8_ = uVar21 << 0x28;\n        auVar34 = auVar14 << 0x40;\n        break;\n      case 0xfffffffe:\n        auVar15._8_8_ = 0;\n        auVar15._0_8_ = uVar21 << 0x30;\n        auVar34 = auVar15 << 0x40;\n        break;\n      case 0xffffffff:\n        auVar16._8_8_ = 0;\n        auVar16._0_8_ = uVar21 << 0x38;\n        auVar34 = auVar16 << 0x40;\n      }\n      auVar35 = auVar34 | auVar35;\nLAB_14002032e:\n      cVar1 = *param_1;\n      while( true ) {\n        if (cVar1 == '\\0') {\n          return (char *)0x0;\n        }\n        auVar25[0] = -(cVar1 == auVar35[0]);\n        auVar25[1] = -(cVar1 == auVar35[1]);\n        auVar25[2] = -(cVar1 == auVar35[2]);\n        auVar25[3] = -(cVar1 == auVar35[3]);\n        auVar25[4] = -(cVar1 == auVar35[4]);\n        auVar25[5] = -(cVar1 == auVar35[5]);\n        auVar25[6] = -(cVar1 == auVar35[6]);\n        auVar25[7] = -(cVar1 == auVar35[7]);\n        auVar25[8] = -(cVar1 == auVar35[8]);\n        auVar25[9] = -(cVar1 == auVar35[9]);\n        auVar25[10] = -(cVar1 == auVar35[10]);\n        auVar25[0xb] = -(cVar1 == auVar35[0xb]);\n        auVar25[0xc] = -(cVar1 == auVar35[0xc]);\n        auVar25[0xd] = -(cVar1 == auVar35[0xd]);\n        auVar25[0xe] = -(cVar1 == auVar35[0xe]);\n        auVar25[0xf] = -(cVar1 == auVar35[0xf]);\n        if ((ushort)((ushort)(SUB161(auVar25 >> 7,0) & 1) |\n                     (ushort)(SUB161(auVar25 >> 0xf,0) & 1) << 1 |\n                     (ushort)(SUB161(auVar25 >> 0x17,0) & 1) << 2 |\n                     (ushort)(SUB161(auVar25 >> 0x1f,0) & 1) << 3 |\n                     (ushort)(SUB161(auVar25 >> 0x27,0) & 1) << 4 |\n                     (ushort)(SUB161(auVar25 >> 0x2f,0) & 1) << 5 |\n                     (ushort)(SUB161(auVar25 >> 0x37,0) & 1) << 6 |\n                     (ushort)(SUB161(auVar25 >> 0x3f,0) & 1) << 7 |\n                     (ushort)(SUB161(auVar25 >> 0x47,0) & 1) << 8 |\n                     (ushort)(SUB161(auVar25 >> 0x4f,0) & 1) << 9 |\n                     (ushort)(SUB161(auVar25 >> 0x57,0) & 1) << 10 |\n                     (ushort)(SUB161(auVar25 >> 0x5f,0) & 1) << 0xb |\n                     (ushort)(SUB161(auVar25 >> 0x67,0) & 1) << 0xc |\n                     (ushort)(SUB161(auVar25 >> 0x6f,0) & 1) << 0xd |\n                     (ushort)(SUB161(auVar25 >> 0x77,0) & 1) << 0xe |\n                    (ushort)(auVar25[0xf] >> 7) << 0xf) != 0) break;\n        cVar1 = param_1[1];\n        param_1 = param_1 + 1;\n      }\n      return param_1;\n    }\n  }\n  pcVar18 = FID_conflict_fallbackMethod(param_1,param_2);\n  return pcVar18;\n}\n\n",
  "__acrt_iob_func": "\n/* Library Function - Single Match\n    __acrt_iob_func\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined * __acrt_iob_func(ulonglong param_1)\n\n{\n  return &DAT_140035070 + (param_1 & 0xffffffff) * 0x58;\n}\n\n",
  "__CxxFrameHandler4": "\n/* Library Function - Single Match\n    __CxxFrameHandler4\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __CxxFrameHandler4(EHExceptionRecord *param_1,__uint64 param_2,_CONTEXT *param_3,\n                       _xDISPATCHER_CONTEXT *param_4)\n\n{\n  undefined8 uVar1;\n  longlong lVar2;\n  __uint64 local_res8;\n  FuncInfo4 local_28 [4];\n  undefined4 local_24;\n  undefined4 local_20;\n  undefined4 local_1c;\n  undefined4 local_18;\n  undefined4 local_14;\n  \n  local_24 = 0;\n  local_20 = 0;\n  local_1c = 0;\n  local_18 = 0;\n  local_14 = 0;\n  uVar1 = *(undefined8 *)(param_4 + 8);\n  local_28[0] = (FuncInfo4)0x0;\n  local_res8 = param_2;\n  lVar2 = FUN_140008b20();\n  *(undefined8 *)(lVar2 + 0x60) = uVar1;\n  uVar1 = *(undefined8 *)(param_1 + 0x38);\n  lVar2 = FUN_140008b20();\n  *(undefined8 *)(lVar2 + 0x68) = uVar1;\n  lVar2 = FUN_140008b20();\n  FH4::DecompFuncInfo((uchar *)((ulonglong)**(uint **)(param_4 + 0x38) + *(longlong *)(lVar2 + 0x60)\n                               ),local_28,*(__uint64 *)(param_4 + 8),**(int **)(param_4 + 0x10),\n                      false);\n  __InternalCxxFrameHandler<class___FrameHandler4>\n            (param_1,&local_res8,param_3,param_4,local_28,0,(__uint64 *)0x0,'\\0');\n  return;\n}\n\n",
  "common_ftell<__int64>": "\n/* Library Function - Single Match\n    __int64 __cdecl common_ftell<__int64>(class __crt_stdio_stream)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nulonglong __cdecl common_ftell<__int64>(FILE *param_1)\n\n{\n  ulong *puVar1;\n  ulonglong uVar2;\n  \n  if (param_1 == (FILE *)0x0) {\n    puVar1 = __doserrno();\n    *puVar1 = 0x16;\n    FUN_14000d030();\n    uVar2 = 0xffffffffffffffff;\n  }\n  else {\n    FUN_14000d384((longlong)param_1);\n    uVar2 = common_ftell_nolock<__int64>(param_1);\n    FUN_14000d390((longlong)param_1);\n  }\n  return uVar2;\n}\n\n",
  "__CxxFrameHandler3": "\n/* Library Function - Single Match\n    __CxxFrameHandler3\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __CxxFrameHandler3(EHExceptionRecord *param_1,__uint64 param_2,_CONTEXT *param_3,\n                       _xDISPATCHER_CONTEXT *param_4)\n\n{\n  undefined8 uVar1;\n  longlong lVar2;\n  __uint64 local_res8;\n  \n  uVar1 = *(undefined8 *)(param_4 + 8);\n  local_res8 = param_2;\n  lVar2 = FUN_140008b20();\n  *(undefined8 *)(lVar2 + 0x60) = uVar1;\n  uVar1 = *(undefined8 *)(param_1 + 0x38);\n  lVar2 = FUN_140008b20();\n  *(undefined8 *)(lVar2 + 0x68) = uVar1;\n  lVar2 = FUN_140008b20();\n  __InternalCxxFrameHandler<class___FrameHandler3>\n            (param_1,&local_res8,param_3,param_4,\n             (_s_FuncInfo *)((ulonglong)**(uint **)(param_4 + 0x38) + *(longlong *)(lVar2 + 0x60)),0\n             ,(__uint64 *)0x0,'\\0');\n  return;\n}\n\n",
  "_setmbcp_nolock": "\n/* Library Function - Single Match\n    _setmbcp_nolock\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _setmbcp_nolock(int param_1,__crt_multibyte_data *param_2)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint uVar3;\n  BOOL BVar4;\n  uint *puVar5;\n  __crt_multibyte_data *p_Var6;\n  undefined *puVar7;\n  longlong lVar8;\n  BYTE *pBVar9;\n  ulonglong uVar10;\n  byte *pbVar11;\n  undefined *puVar12;\n  undefined *puVar13;\n  undefined4 uVar14;\n  byte *pbVar15;\n  uint uVar16;\n  uint uVar17;\n  byte *pbVar18;\n  undefined auStack_78 [32];\n  _cpinfo local_58;\n  ulonglong local_40;\n  \n  local_40 = DAT_140035020 ^ (ulonglong)auStack_78;\n  uVar3 = getSystemCP(param_1);\n  puVar12 = (undefined *)0x0;\n  if (uVar3 != 0) {\n    puVar5 = &DAT_140035a10;\n    uVar14 = 1;\n    puVar7 = puVar12;\nLAB_14001baf3:\n    if (*puVar5 != uVar3) goto code_r0x00014001bafb;\n    FUN_140008580((undefined (*) [16])(param_2 + 0x18),0,0x101);\n    pbVar18 = &DAT_140035a00;\n    lVar8 = 4;\n    pbVar15 = &DAT_140035a20 + (longlong)puVar7 * 0x30;\n    do {\n      bVar1 = *pbVar15;\n      pbVar11 = pbVar15;\n      while ((bVar1 != 0 && (pbVar11[1] != 0))) {\n        bVar1 = *pbVar11;\n        uVar17 = (uint)bVar1;\n        if (bVar1 <= pbVar11[1]) {\n          uVar16 = (uint)bVar1;\n          do {\n            uVar16 = uVar16 + 1;\n            if (0x100 < uVar16) break;\n            uVar17 = uVar17 + 1;\n            param_2[(ulonglong)uVar16 + 0x18] =\n                 (__crt_multibyte_data)((byte)param_2[(ulonglong)uVar16 + 0x18] | *pbVar18);\n          } while (uVar17 <= pbVar11[1]);\n        }\n        pbVar11 = pbVar11 + 2;\n        bVar1 = *pbVar11;\n      }\n      pbVar15 = pbVar15 + 8;\n      pbVar18 = pbVar18 + 1;\n      lVar8 = lVar8 + -1;\n    } while (lVar8 != 0);\n    *(uint *)(param_2 + 4) = uVar3;\n    *(undefined4 *)(param_2 + 8) = 1;\n    puVar13 = PTR_u_ja_JP_14002ad80;\n    if (((uVar3 != 0x3a4) && (puVar13 = PTR_u_zh_CN_14002ad88, uVar3 != 0x3a8)) &&\n       ((puVar13 = PTR_u_ko_KR_14002ad90, uVar3 != 0x3b5 && (puVar13 = puVar12, uVar3 == 0x3b6)))) {\n      puVar13 = PTR_u_zh_TW_14002ad98;\n    }\n    *(undefined **)(param_2 + 0x220) = puVar13;\n    p_Var6 = param_2 + 0xc;\n    lVar8 = 6;\n    do {\n      *(undefined2 *)p_Var6 =\n           *(undefined2 *)(p_Var6 + ((longlong)puVar7 * 0x30 - (longlong)param_2) + 0x140035a08);\n      p_Var6 = p_Var6 + 2;\n      lVar8 = lVar8 + -1;\n    } while (lVar8 != 0);\n    goto LAB_14001bb4f;\n  }\nLAB_14001bd36:\n  setSBCS(param_2);\nLAB_14001bd40:\n  FUN_140006060(local_40 ^ (ulonglong)auStack_78);\n  return;\ncode_r0x00014001bafb:\n  uVar17 = (int)puVar7 + 1;\n  puVar7 = (undefined *)(ulonglong)uVar17;\n  puVar5 = puVar5 + 0xc;\n  if (4 < uVar17) goto code_r0x00014001bb08;\n  goto LAB_14001baf3;\ncode_r0x00014001bb08:\n  if ((uVar3 == 65000) || (BVar4 = IsValidCodePage(uVar3 & 0xffff), BVar4 == 0)) goto LAB_14001bd40;\n  if (uVar3 == 0xfde9) {\n    *(undefined8 *)(param_2 + 4) = 0xfde9;\n    *(undefined8 *)(param_2 + 0x220) = 0;\n    *(undefined4 *)(param_2 + 0x18) = 0;\n    *(undefined2 *)(param_2 + 0x1c) = 0;\n  }\n  else {\n    BVar4 = GetCPInfo(uVar3,&local_58);\n    if (BVar4 == 0) {\n      if (DAT_1400379c8 == 0) goto LAB_14001bd40;\n      goto LAB_14001bd36;\n    }\n    FUN_140008580((undefined (*) [16])(param_2 + 0x18),0,0x101);\n    *(uint *)(param_2 + 4) = uVar3;\n    *(undefined8 *)(param_2 + 0x220) = 0;\n    if (local_58.MaxCharSize == 2) {\n      pBVar9 = local_58.LeadByte;\n      while ((local_58.LeadByte[0] != 0 && (pBVar9[1] != 0))) {\n        bVar1 = *pBVar9;\n        if ((uint)bVar1 <= (uint)pBVar9[1]) {\n          uVar3 = (uint)bVar1;\n          uVar10 = (ulonglong)(((uint)pBVar9[1] - (uint)bVar1) + 1);\n          do {\n            uVar3 = uVar3 + 1;\n            param_2[(ulonglong)uVar3 + 0x18] =\n                 (__crt_multibyte_data)((byte)param_2[(ulonglong)uVar3 + 0x18] | 4);\n            uVar10 = uVar10 - 1;\n          } while (uVar10 != 0);\n        }\n        pBVar9 = pBVar9 + 2;\n        local_58.LeadByte[0] = *pBVar9;\n      }\n      p_Var6 = param_2 + 0x1a;\n      lVar8 = 0xfe;\n      do {\n        *p_Var6 = (__crt_multibyte_data)((byte)*p_Var6 | 8);\n        p_Var6 = p_Var6 + 1;\n        lVar8 = lVar8 + -1;\n      } while (lVar8 != 0);\n      iVar2 = *(int *)(param_2 + 4);\n      puVar7 = PTR_u_ja_JP_14002ad80;\n      if ((((iVar2 != 0x3a4) && (puVar7 = PTR_u_zh_CN_14002ad88, iVar2 != 0x3a8)) &&\n          (puVar7 = PTR_u_ko_KR_14002ad90, iVar2 != 0x3b5)) &&\n         (puVar7 = PTR_u_zh_TW_14002ad98, iVar2 != 0x3b6)) {\n        puVar7 = puVar12;\n      }\n      *(undefined **)(param_2 + 0x220) = puVar7;\n    }\n    else {\n      uVar14 = 0;\n    }\n    *(undefined4 *)(param_2 + 8) = uVar14;\n  }\n  p_Var6 = param_2 + 0xc;\n  for (lVar8 = 6; lVar8 != 0; lVar8 = lVar8 + -1) {\n    *(undefined2 *)p_Var6 = 0;\n    p_Var6 = p_Var6 + 2;\n  }\nLAB_14001bb4f:\n  setSBUpLow(param_2);\n  goto LAB_14001bd40;\n}\n\n",
  "__acrt_AppPolicyGetProcessTerminationMethodInternal": "\n/* WARNING: Switch with 1 destination removed at 0x000140015504 */\n/* Library Function - Single Match\n    __acrt_AppPolicyGetProcessTerminationMethodInternal\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 __acrt_AppPolicyGetProcessTerminationMethodInternal(undefined8 param_1)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  undefined8 uVar1;\n  \n  UNRECOVERED_JUMPTABLE =\n       (code *)try_get_function(0x1c,\"AppPolicyGetProcessTerminationMethod\",\n                                (module_id *)&DAT_140028ed4,\n                                (module_id *)\"AppPolicyGetProcessTerminationMethod\");\n  if (UNRECOVERED_JUMPTABLE == (code *)0x0) {\n    return 0xc0000225;\n  }\n                    /* WARNING: Could not recover jumptable at 0x000140021e60. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  uVar1 = (*UNRECOVERED_JUMPTABLE)(0xfffffffffffffffa,param_1);\n  return uVar1;\n}\n\n",
  "FUN_14000c170": "\nvoid FUN_14000c170(void)\n\n{\n  FUN_14000bd20();\n  return;\n}\n\n",
  "FUN_140001890": "\nundefined8 * FUN_140001890(undefined8 *param_1)\n\n{\n  param_1[2] = 0;\n  param_1[1] = \"bad cast\";\n  *param_1 = std::bad_cast::vftable;\n  return param_1;\n}\n\n",
  "_CallSETranslator<class___FrameHandler3>": "\n/* Library Function - Single Match\n    int __cdecl _CallSETranslator<class __FrameHandler3>(struct EHExceptionRecord * __ptr64,unsigned\n   __int64 * __ptr64,struct _CONTEXT * __ptr64,struct _xDISPATCHER_CONTEXT * __ptr64,struct\n   _s_FuncInfo const * __ptr64,unsigned long,unsigned __int64 * __ptr64,int)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\n_CallSETranslator<class___FrameHandler3>\n          (EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n          _xDISPATCHER_CONTEXT *param_4,_s_FuncInfo *param_5,ulong param_6,__uint64 *param_7,\n          int param_8)\n\n{\n  EHExceptionRecord *local_20;\n  _CONTEXT *local_18;\n  \n  local_20 = param_1;\n  local_18 = param_3;\n  FUN_140008b20();\n  (*(code *)PTR__guard_dispatch_icall_140023298)(*(undefined4 *)param_1,&local_20);\n  return 0;\n}\n\n",
  "FUN_140011c14": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_140011c14(undefined8 param_1)\n\n{\n  _DAT_1400370f8 = param_1;\n  return;\n}\n\n",
  "iswctype": "\n/* Library Function - Single Match\n    iswctype\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl iswctype(wint_t _C,wctype_t _Type)\n\n{\n  uint uVar1;\n  BOOL BVar2;\n  WORD local_res8 [4];\n  WCHAR local_res18 [8];\n  \n  if (_C == 0xffff) {\nLAB_14001508e:\n    uVar1 = 0;\n  }\n  else {\n    if (_C < 0x100) {\n      local_res8[0] = *(WORD *)(PTR_DAT_140035180 + (ulonglong)_C * 2);\n    }\n    else {\n      local_res8[0] = 0;\n      local_res18[0] = _C;\n      BVar2 = GetStringTypeW(1,local_res18,1,local_res8);\n      if (BVar2 == 0) goto LAB_14001508e;\n    }\n    uVar1 = (uint)(local_res8[0] & _Type);\n  }\n  return uVar1;\n}\n\n",
  "__acrt_EnumSystemLocalesEx": "\n/* Library Function - Single Match\n    __acrt_EnumSystemLocalesEx\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_EnumSystemLocalesEx\n               (ulonglong param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  void *pvVar1;\n  ulonglong local_res8;\n  undefined local_28 [4];\n  int local_24 [3];\n  ulonglong *local_18 [2];\n  \n  local_res8 = param_1;\n  pvVar1 = try_get_function(2,\"EnumSystemLocalesEx\",(module_id *)&DAT_140028da8,\n                            (module_id *)\"EnumSystemLocalesEx\");\n  if (pvVar1 == (void *)0x0) {\n    local_18[0] = &local_res8;\n    local_24[0] = 4;\n    local_24[1] = 4;\n    operator()<>(local_28,local_24 + 1,local_18,local_24);\n  }\n  else {\n    (*(code *)PTR__guard_dispatch_icall_140023298)(local_res8,param_2,param_3,param_4);\n  }\n  return;\n}\n\n",
  "__uncaught_exception": "\nbool __uncaught_exception(void)\n\n{\n  bool bVar1;\n  longlong lVar2;\n  \n  lVar2 = __vcrt_getptd_noinit();\n  bVar1 = false;\n  if (lVar2 != 0) {\n    bVar1 = 0 < *(int *)(lVar2 + 0x30);\n  }\n  return bVar1;\n}\n\n",
  "FUN_140003834": "\nundefined8 * FUN_140003834(undefined8 *param_1,longlong param_2)\n\n{\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  __std_exception_copy((char **)(param_2 + 8),(char **)(param_1 + 1));\n  *param_1 = std::invalid_argument::vftable;\n  return param_1;\n}\n\n",
  "TranslateName": "\n/* Library Function - Single Match\n    TranslateName\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nbool TranslateName(longlong param_1,int param_2,ushort **param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  ulonglong uVar3;\n  int iVar4;\n  bool bVar5;\n  \n  uVar3 = 1;\n  iVar2 = 1;\n  iVar4 = 0;\n  if (-1 < param_2) {\n    do {\n      bVar5 = (int)uVar3 == 0;\n      if (bVar5) {\n        return bVar5;\n      }\n      iVar1 = (iVar4 + param_2) / 2;\n      uVar3 = FUN_14001a634(*param_3,*(ushort **)((longlong)iVar1 * 0x10 + param_1));\n      iVar2 = (int)uVar3;\n      if (iVar2 == 0) {\n        *param_3 = (ushort *)(param_1 + 8 + (longlong)iVar1 * 0x10);\n      }\n      else if (iVar2 < 0) {\n        param_2 = iVar1 + -1;\n      }\n      else {\n        iVar4 = iVar1 + 1;\n      }\n    } while (iVar4 <= param_2);\n  }\n  return iVar2 == 0;\n}\n\n",
  "_fgetc_nolock": "\n/* Library Function - Single Match\n    _fgetc_nolock\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nulonglong _fgetc_nolock(FILE *param_1)\n\n{\n  char **ppcVar1;\n  ulong *puVar2;\n  ulonglong uVar3;\n  \n  if (param_1 == (FILE *)0x0) {\n    puVar2 = __doserrno();\n    *puVar2 = 0x16;\n    FUN_14000d030();\n    uVar3 = 0xffffffff;\n  }\n  else {\n    ppcVar1 = &param_1->_base;\n    *(int *)ppcVar1 = *(int *)ppcVar1 + -1;\n    if (*(int *)ppcVar1 < 0) {\n      uVar3 = __acrt_stdio_refill_and_read_narrow_nolock(param_1);\n      return uVar3;\n    }\n    uVar3 = (ulonglong)(byte)*param_1->_ptr;\n    param_1->_ptr = param_1->_ptr + 1;\n  }\n  return uVar3;\n}\n\n",
  "_fcloseall": "\n/* Library Function - Single Match\n    _fcloseall\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _fcloseall(void)\n\n{\n  longlong lVar1;\n  int iVar2;\n  int iVar3;\n  longlong lVar4;\n  int local_18;\n  \n  local_18 = 0;\n  __acrt_lock(8);\n  for (iVar3 = 3; iVar3 != DAT_1400370d8; iVar3 = iVar3 + 1) {\n    lVar4 = (longlong)iVar3;\n    lVar1 = *(longlong *)(DAT_1400370e0 + lVar4 * 8);\n    if (lVar1 != 0) {\n      if (((*(uint *)(lVar1 + 0x14) >> 0xd & 1) != 0) &&\n         (iVar2 = fclose(*(FILE **)(DAT_1400370e0 + lVar4 * 8)), iVar2 != -1)) {\n        local_18 = local_18 + 1;\n      }\n      DeleteCriticalSection((LPCRITICAL_SECTION)(*(longlong *)(DAT_1400370e0 + lVar4 * 8) + 0x30));\n      _free_base(*(LPVOID *)(DAT_1400370e0 + lVar4 * 8));\n      *(undefined8 *)(DAT_1400370e0 + lVar4 * 8) = 0;\n    }\n  }\n  __acrt_unlock(8);\n  return local_18;\n}\n\n",
  "FUN_14001f9f8": "\nvoid FUN_14001f9f8(undefined8 param_1,uint param_2,float param_3,int param_4,uint param_5,\n                  uint param_6,float param_7,float param_8,int param_9)\n\n{\n  float fVar1;\n  bool bVar2;\n  uint uVar3;\n  undefined4 extraout_var_00;\n  undefined7 extraout_var;\n  undefined auStackY_118 [32];\n  float local_d8 [2];\n  ulonglong local_d0;\n  float local_c8;\n  uint local_b8 [12];\n  float local_88;\n  uint local_78;\n  ulonglong local_48;\n  \n  local_48 = DAT_140035020 ^ (ulonglong)auStackY_118;\n  uVar3 = _ctrlfp(0x1f80,0xffc0);\n  local_d0 = CONCAT44(extraout_var_00,uVar3);\n  local_d8[0] = param_3;\n  local_c8 = param_3;\n  bVar2 = _exception_enabled(param_5,local_d0);\n  fVar1 = param_8;\n  if ((int)CONCAT71(extraout_var,bVar2) == 0) {\n    if (param_9 == 2) {\n      local_88 = param_8;\n      local_78 = local_78 & 0xffffffe1 | 1;\n    }\n    _raise_excf(local_b8,&local_d0,(ulonglong)param_5,param_2,(uint *)&param_7,(uint *)local_d8);\n  }\n  bVar2 = FUN_140011e14();\n  if ((bVar2) && (param_4 != 0)) {\n    FUN_14001f7ac(param_4,(ulonglong)param_6,param_1,(double)param_7,(double)fVar1,\n                  (double)local_d8[0],(uint)local_d0);\n  }\n  else {\n    _set_errno_from_matherr(param_4);\n    _ctrlfp((uint)local_d0,0xffc0);\n  }\n  FUN_140006060(local_48 ^ (ulonglong)auStackY_118);\n  return;\n}\n\n",
  "_write": "\n/* Library Function - Single Match\n    _write\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _write(int _FileHandle,void *_Buf,uint _MaxCharCount)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  \n  if (_FileHandle == -2) {\n    puVar2 = __doserrno();\n    *puVar2 = 0;\n    puVar2 = __doserrno();\n    *puVar2 = 9;\n  }\n  else {\n    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_140037890)) {\n      if ((*(byte *)((&DAT_140037490)[(longlong)_FileHandle >> 6] + 0x38 +\n                    (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) != 0) {\n        FID_conflict___acrt_lowio_lock_fh(_FileHandle);\n        iVar1 = -1;\n        if ((*(byte *)((&DAT_140037490)[(longlong)_FileHandle >> 6] + 0x38 +\n                      (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) == 0) {\n          puVar2 = __doserrno();\n          *puVar2 = 9;\n          puVar2 = __doserrno();\n          *puVar2 = 0;\n        }\n        else {\n          iVar1 = _write_nolock(_FileHandle,_Buf,_MaxCharCount);\n        }\n        FID_conflict___acrt_lowio_lock_fh(_FileHandle);\n        return iVar1;\n      }\n    }\n    puVar2 = __doserrno();\n    *puVar2 = 0;\n    puVar2 = __doserrno();\n    *puVar2 = 9;\n    FUN_14000d030();\n  }\n  return -1;\n}\n\n",
  "_realloc_base": "\n/* Library Function - Single Match\n    _realloc_base\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nLPVOID _realloc_base(LPVOID param_1,ulonglong param_2)\n\n{\n  int iVar1;\n  LPVOID pvVar2;\n  ulong *puVar3;\n  \n  if (param_1 == (LPVOID)0x0) {\n    pvVar2 = _malloc_base(param_2);\n  }\n  else {\n    if (param_2 == 0) {\n      _free_base(param_1);\n    }\n    else {\n      if (param_2 < 0xffffffffffffffe1) {\n        do {\n          pvVar2 = HeapReAlloc(DAT_1400379d8,0,param_1,param_2);\n          if (pvVar2 != (LPVOID)0x0) {\n            return pvVar2;\n          }\n          iVar1 = FUN_1400142f4();\n        } while ((iVar1 != 0) && (iVar1 = _callnewh(param_2), iVar1 != 0));\n      }\n      puVar3 = __doserrno();\n      *puVar3 = 0xc;\n    }\n    pvVar2 = (LPVOID)0x0;\n  }\n  return pvVar2;\n}\n\n",
  "_local_unwind": "\n/* Library Function - Single Match\n    _local_unwind\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _local_unwind(PVOID param_1,PVOID param_2)\n\n{\n  RtlUnwind(param_1,param_2,(PEXCEPTION_RECORD)0x0,(PVOID)0x0);\n  return;\n}\n\n",
  "FUN_140011e3c": "\n/* WARNING: Switch with 1 destination removed at 0x000140011e63 */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 FUN_140011e3c(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  byte bVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  bVar2 = (byte)DAT_140035020 & 0x3f;\n  UNRECOVERED_JUMPTABLE =\n       (code *)((DAT_140035020 ^ _DAT_140037108) >> bVar2 |\n               (DAT_140035020 ^ _DAT_140037108) << 0x40 - bVar2);\n  if (UNRECOVERED_JUMPTABLE != (code *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x000140021e60. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    uVar1 = (*UNRECOVERED_JUMPTABLE)(param_1);\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "__report_rangecheckfailure": "\n/* Library Function - Single Match\n    __report_rangecheckfailure\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __report_rangecheckfailure(void)\n\n{\n  FUN_14000682c(8);\n  return;\n}\n\n",
  "GetLcidFromLanguage": "\n/* Library Function - Single Match\n    GetLcidFromLanguage\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid GetLcidFromLanguage(byte *param_1)\n\n{\n  short sVar1;\n  longlong lVar2;\n  int iVar3;\n  short *psVar4;\n  longlong lVar5;\n  int iVar6;\n  \n  lVar2 = FUN_140014d84();\n  lVar5 = -1;\n  iVar6 = 0;\n  psVar4 = *(short **)(lVar2 + 0x98);\n  do {\n    lVar5 = lVar5 + 1;\n  } while (psVar4[lVar5] != 0);\n  *(uint *)(lVar2 + 0xb0) = (uint)(lVar5 == 3);\n  iVar3 = 2;\n  if (lVar5 != 3) {\n    while( true ) {\n      sVar1 = *psVar4;\n      psVar4 = psVar4 + 1;\n      if ((0x19 < (ushort)(sVar1 - 0x41U)) && (iVar3 = iVar6, 0x19 < (ushort)(sVar1 - 0x61U)))\n      break;\n      iVar6 = iVar6 + 1;\n    }\n  }\n  *(int *)(lVar2 + 0xac) = iVar3;\n  EnumSystemLocalesW((LOCALE_ENUMPROCW)&LAB_14001e968,1);\n  if ((*param_1 & 4) == 0) {\n    *(undefined4 *)param_1 = 0;\n  }\n  return;\n}\n\n",
  "FUN_1400227a3": "\nvoid FUN_1400227a3(undefined8 param_1,longlong param_2)\n\n{\n  FID_conflict___acrt_lowio_lock_fh(**(uint **)(param_2 + 0x48));\n  return;\n}\n\n",
  "FUN_14001efb4": "\nbool FUN_14001efb4(void)\n\n{\n  DAT_1400379d8 = GetProcessHeap();\n  return DAT_1400379d8 != (HANDLE)0x0;\n}\n\n",
  "FUN_14001f7ac": "\nundefined8\nFUN_14001f7ac(int param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n             undefined8 param_5,undefined8 param_6,uint param_7)\n\n{\n  undefined8 uVar1;\n  int local_38 [2];\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  \n  local_20 = param_5;\n  local_18 = param_6;\n  local_38[0] = param_1;\n  local_30 = param_3;\n  local_28 = param_4;\n  _ctrlfp(param_7,0xffc0);\n  uVar1 = FUN_140011e3c(local_38);\n  if ((int)uVar1 == 0) {\n    _set_errno_from_matherr(param_1);\n  }\n  return local_18;\n}\n\n",
  "FUN_14000b5b8": "\nvoid FUN_14000b5b8(longlong *param_1,_xDISPATCHER_CONTEXT *param_2,FuncInfo4 *param_3,int param_4)\n\n{\n  int iVar1;\n  int iVar2;\n  UWMap4 *pUVar3;\n  byte *pbVar4;\n  int iVar5;\n  undefined8 uVar6;\n  longlong lVar7;\n  uint uVar8;\n  longlong lVar9;\n  undefined auStackY_128 [32];\n  undefined8 local_f8;\n  undefined8 uStack_f0;\n  int local_e8;\n  int local_e4;\n  int local_e0;\n  uint *local_d8;\n  byte *local_d0;\n  longlong *local_c8;\n  undefined8 local_c0;\n  longlong *local_b8;\n  _xDISPATCHER_CONTEXT *local_b0;\n  undefined4 local_a8;\n  int iStack_a4;\n  int iStack_a0;\n  uint uStack_9c;\n  uint *local_98;\n  byte *local_90;\n  undefined4 local_88;\n  undefined4 uStack_84;\n  undefined4 uStack_80;\n  undefined4 uStack_7c;\n  uint local_78 [2];\n  byte *local_70;\n  ulonglong local_58;\n  \n  local_58 = DAT_140035020 ^ (ulonglong)auStackY_128;\n  local_e0 = param_4;\n  local_c8 = param_1;\n  local_b8 = param_1;\n  local_b0 = param_2;\n  uVar6 = _GetImageBase();\n  local_c0 = uVar6;\n  iVar5 = FUN_140008d5c(param_3,param_2);\n  if (*(int *)(param_2 + 0x48) == 0) {\n    lVar7 = FUN_140008b20();\n    if (*(int *)(lVar7 + 0x78) != -2) {\n      lVar7 = FUN_140008b20();\n      iVar5 = *(int *)(lVar7 + 0x78);\n      lVar7 = FUN_140008b20();\n      *(undefined4 *)(lVar7 + 0x78) = 0xfffffffe;\n    }\n  }\n  else {\n    lVar7 = FUN_140008b20();\n    if (*(int *)(lVar7 + 0x78) != -2) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    iVar5 = *(int *)(param_2 + 0x48) + -2;\n  }\n  lVar7 = FUN_140008b20();\n  *(int *)(lVar7 + 0x30) = *(int *)(lVar7 + 0x30) + 1;\n  if (*(int *)(param_3 + 8) == 0) {\n    local_78[0] = 0;\n  }\n  else {\n    uVar8 = *(byte *)((longlong)*(int *)(param_3 + 8) + *(longlong *)(param_2 + 8)) & 0xf;\n    local_70 = (byte *)((longlong)*(int *)(param_3 + 8) + *(longlong *)(param_2 + 8)) +\n               -(longlong)(char)(&DAT_140024780)[uVar8];\n    local_78[0] = *(uint *)(local_70 + -4) >> ((&DAT_140024790)[uVar8] & 0x1f);\n  }\n  local_f8 = (UWMap4 *)local_78;\n  local_d8 = local_78;\n  uStack_f0 = local_70;\n  local_d0 = local_70;\n  FUN_14000bb6c((UWMap4 *)local_78,iVar5,param_4,&local_f8,(longlong *)&local_d8);\n  while( true ) {\n    pbVar4 = uStack_f0;\n    local_98 = local_78;\n    local_90 = local_70;\n    if ((uStack_f0 < local_70) || (uStack_f0 <= local_d0)) break;\n    FH4::UWMap4::ReadEntry(local_f8,(uchar **)&uStack_f0);\n    pUVar3 = local_f8;\n    local_a8 = *(undefined4 *)(local_f8 + 0x10);\n    iVar1 = *(int *)(local_f8 + 0x14);\n    iVar2 = *(int *)(local_f8 + 0x18);\n    uStack_9c = *(uint *)(local_f8 + 0x1c);\n    uStack_f0._0_4_ = SUB84(pbVar4,0);\n    uStack_f0._4_4_ = SUB84(pbVar4,4);\n    local_88 = (undefined4)local_f8;\n    uStack_84 = local_f8._4_4_;\n    uStack_80 = (undefined4)uStack_f0;\n    uStack_7c = uStack_f0._4_4_;\n    uStack_f0 = pbVar4;\n    iStack_a4 = iVar1;\n    iStack_a0 = iVar2;\n    FH4::UWMap4::ReadEntry(local_f8,(uchar **)&uStack_f0);\n    uStack_f0 = pbVar4 + -(ulonglong)*(uint *)(pUVar3 + 0x10);\n    iVar5 = FH4::UWMap4::getStateFromIterators\n                      ((iterator *)&local_d8,param_4,(iterator *)&local_88,iVar5,\n                       (iterator *)&local_f8);\n    local_e8 = 0;\n    if (iVar1 != 0) {\n      local_e8 = iVar2;\n    }\n    local_e4 = iVar5;\n    if (local_e8 != 0) {\n      *(int *)(param_2 + 0x48) = iVar5 + 2;\n      if (iVar1 - 1U < 2) {\n        lVar7 = *local_c8;\n        if (iVar1 == 2) {\n          lVar9 = *(longlong *)((ulonglong)uStack_9c + lVar7);\n        }\n        else {\n          lVar9 = (ulonglong)uStack_9c + lVar7;\n        }\n        _CallSettingFrameEncoded((longlong)local_e8 + *(longlong *)(param_2 + 8),lVar7,lVar9);\n      }\n      else {\n        _CallSettingFrame();\n      }\n      _SetImageBase(uVar6);\n    }\n  }\n  lVar7 = FUN_140008b20();\n  if (0 < *(int *)(lVar7 + 0x30)) {\n    lVar7 = FUN_140008b20();\n    *(int *)(lVar7 + 0x30) = *(int *)(lVar7 + 0x30) + -1;\n  }\n  FUN_140006060(local_58 ^ (ulonglong)auStackY_128);\n  return;\n}\n\n",
  "FUN_140003ad4": "\nundefined8 *\nFUN_140003ad4(undefined8 *param_1,ulonglong param_2,undefined8 param_3,undefined param_4)\n\n{\n  ulonglong uVar1;\n  ulonglong uVar2;\n  ulonglong uVar3;\n  undefined8 *puVar4;\n  code *pcVar5;\n  undefined8 *puVar6;\n  ulonglong uVar7;\n  ulonglong uVar8;\n  undefined8 *puVar9;\n  \n  uVar2 = param_1[2];\n  uVar8 = 0x7fffffffffffffff;\n  if (0x7fffffffffffffff - uVar2 < param_2) {\n    FUN_140001380();\n    pcVar5 = (code *)swi(3);\n    puVar6 = (undefined8 *)(*pcVar5)();\n    return puVar6;\n  }\n  uVar3 = param_1[3];\n  uVar7 = uVar2 + param_2 | 0xf;\n  if ((uVar7 < 0x8000000000000000) && (uVar3 <= 0x7fffffffffffffff - (uVar3 >> 1))) {\n    uVar1 = (uVar3 >> 1) + uVar3;\n    uVar8 = uVar7;\n    if (uVar7 < uVar1) {\n      uVar8 = uVar1;\n    }\n    uVar7 = uVar8 + 1;\n    if (uVar7 < 0x1000) {\n      if (uVar7 == 0) {\n        puVar6 = (undefined8 *)0x0;\n      }\n      else {\n        puVar6 = (undefined8 *)operator_new(uVar7);\n      }\n      goto LAB_140003b78;\n    }\n  }\n  else {\n    uVar7 = 0x8000000000000000;\n  }\n  puVar6 = (undefined8 *)\n           std::_Allocate_manually_vector_aligned<struct_std::_Default_allocate_traits>(uVar7);\nLAB_140003b78:\n  param_1[2] = uVar2 + param_2;\n  param_1[3] = uVar8;\n  if (uVar3 < 0x10) {\n    FUN_140007ed0(puVar6,param_1,uVar2);\n    *(undefined *)(uVar2 + (longlong)puVar6) = param_4;\n    *(undefined *)(uVar2 + 1 + (longlong)puVar6) = 0;\n  }\n  else {\n    puVar4 = (undefined8 *)*param_1;\n    FUN_140007ed0(puVar6,puVar4,uVar2);\n    *(undefined *)(uVar2 + (longlong)puVar6) = param_4;\n    *(undefined *)(uVar2 + 1 + (longlong)puVar6) = 0;\n    puVar9 = puVar4;\n    if ((0xfff < uVar3 + 1) &&\n       (puVar9 = (undefined8 *)puVar4[-1],\n       0x1f < (ulonglong)((longlong)puVar4 + (-8 - (longlong)puVar9)))) {\n      FUN_14000d050();\n      pcVar5 = (code *)swi(3);\n      puVar6 = (undefined8 *)(*pcVar5)();\n      return puVar6;\n    }\n    thunk_FUN_14000ce08(puVar9);\n  }\n  *param_1 = puVar6;\n  return param_1;\n}\n\n",
  "_mbstowcs_l_helper": "\n/* Library Function - Single Match\n    unsigned __int64 __cdecl _mbstowcs_l_helper(wchar_t * __ptr64,char const * __ptr64,unsigned\n   __int64,struct __crt_locale_pointers * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\n__uint64 __cdecl\n_mbstowcs_l_helper(wchar_t *param_1,char *param_2,__uint64 param_3,__crt_locale_pointers *param_4)\n\n{\n  UINT UVar1;\n  int iVar2;\n  DWORD DVar3;\n  ulong *puVar4;\n  __uint64 _Var5;\n  byte *pbVar6;\n  uint uVar7;\n  uint uVar8;\n  ulonglong uVar9;\n  undefined8 local_res8;\n  byte *local_res10;\n  longlong local_48;\n  localeinfo_struct local_40;\n  char local_30;\n  \n  _Var5 = 0;\n  if (param_1 != (wchar_t *)0x0) {\n    if (param_3 == 0) {\n      return 0;\n    }\n    *param_1 = L'\\0';\n  }\n  local_res10 = (byte *)param_2;\n  if (param_2 == (char *)0x0) {\n    puVar4 = __doserrno();\n    *puVar4 = 0x16;\n    FUN_14000d030();\n    return 0xffffffffffffffff;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_48,param_4);\n  UVar1 = (local_40.locinfo)->lc_time_cp;\n  if (UVar1 == 0xfde9) {\n    local_res8 = 0;\n    _Var5 = __crt_mbstring::__mbsrtowcs_utf8\n                      (param_1,(char **)&local_res10,param_3,(_Mbstatet *)&local_res8);\n    goto LAB_1400189a7;\n  }\n  if (param_1 == (wchar_t *)0x0) {\n    _Var5 = 0xffffffffffffffff;\n    if ((local_40.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n      do {\n        _Var5 = _Var5 + 1;\n      } while (local_res10[_Var5] != 0);\n      goto LAB_1400189a7;\n    }\n    iVar2 = __acrt_MultiByteToWideChar(UVar1,9,(LPCSTR)local_res10,-1,(LPWSTR)0x0,0);\n    if (iVar2 == 0) {\n      puVar4 = __doserrno();\n      *puVar4 = 0x2a;\n      goto LAB_1400189a7;\n    }\n  }\n  else {\n    if ((local_40.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n      if (param_3 != 0) {\n        do {\n          *param_1 = (ushort)local_res10[_Var5];\n          if (local_res10[_Var5] == 0) break;\n          _Var5 = _Var5 + 1;\n          param_1 = param_1 + 1;\n        } while (_Var5 < param_3);\n      }\n      goto LAB_1400189a7;\n    }\n    uVar7 = (uint)param_3;\n    iVar2 = __acrt_MultiByteToWideChar(UVar1,9,(LPCSTR)local_res10,-1,param_1,uVar7);\n    if (iVar2 == 0) {\n      DVar3 = GetLastError();\n      if (DVar3 == 0x7a) {\n        uVar9 = param_3 & 0xffffffff;\n        pbVar6 = local_res10;\n        uVar8 = uVar7;\n        while (uVar8 != 0) {\n          uVar8 = (int)uVar9 - 1;\n          uVar9 = (ulonglong)uVar8;\n          if (*pbVar6 == 0) break;\n          iVar2 = _isleadbyte_l((uint)*pbVar6,&local_40);\n          if ((iVar2 != 0) && (pbVar6 = pbVar6 + 1, *pbVar6 == 0)) goto LAB_140018942;\n          pbVar6 = pbVar6 + 1;\n        }\n        iVar2 = __acrt_MultiByteToWideChar\n                          ((local_40.locinfo)->lc_time_cp,1,(LPCSTR)local_res10,\n                           (int)pbVar6 - (int)local_res10,param_1,uVar7);\n        _Var5 = (__uint64)iVar2;\n        if (iVar2 != 0) goto LAB_1400189a7;\n      }\nLAB_140018942:\n      puVar4 = __doserrno();\n      *puVar4 = 0x2a;\n      *param_1 = L'\\0';\n      _Var5 = 0xffffffffffffffff;\n      goto LAB_1400189a7;\n    }\n  }\n  _Var5 = (longlong)iVar2 - 1;\nLAB_1400189a7:\n  if (local_30 != '\\0') {\n    *(uint *)(local_48 + 0x3a8) = *(uint *)(local_48 + 0x3a8) & 0xfffffffd;\n  }\n  return _Var5;\n}\n\n",
  "common_fseek": "\n/* Library Function - Single Match\n    int __cdecl common_fseek(class __crt_stdio_stream,__int64,int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nulonglong __cdecl common_fseek(FILE *param_1,longlong param_2,uint param_3)\n\n{\n  ulong *puVar1;\n  ulonglong uVar2;\n  \n  if ((param_1 == (FILE *)0x0) || (2 < param_3)) {\n    puVar1 = __doserrno();\n    *puVar1 = 0x16;\n    FUN_14000d030();\n    uVar2 = 0xffffffff;\n  }\n  else {\n    FUN_14000d384((longlong)param_1);\n    uVar2 = common_fseek_nolock(param_1,param_2,param_3);\n    uVar2 = uVar2 & 0xffffffff;\n    FUN_14000d390((longlong)param_1);\n  }\n  return uVar2;\n}\n\n",
  "_lock_locales": "\n/* Library Function - Single Match\n    _lock_locales\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _lock_locales(void)\n\n{\n  __acrt_eagerly_load_locale_apis();\n                    /* WARNING: Could not recover jumptable at 0x00014000d194. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  EnterCriticalSection((LPCRITICAL_SECTION)&DAT_140036f40);\n  return;\n}\n\n",
  "FUN_140012770": "\nbool FUN_140012770(int param_1)\n\n{\n  return param_1 == -0x1f928c9d;\n}\n\n",
  "fgetpos": "\n/* Library Function - Single Match\n    fgetpos\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl fgetpos(FILE *_File,fpos_t *_Pos)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  ulonglong uVar3;\n  \n  if ((_File == (FILE *)0x0) || (_Pos == (fpos_t *)0x0)) {\n    puVar2 = __doserrno();\n    *puVar2 = 0x16;\n    FUN_14000d030();\n    iVar1 = -1;\n  }\n  else {\n    uVar3 = common_ftell<__int64>(_File);\n    *_Pos = uVar3;\n    iVar1 = (uVar3 != 0xffffffffffffffff) - 1;\n  }\n  return iVar1;\n}\n\n",
  "ProcessCodePage": "\n/* Library Function - Single Match\n    ProcessCodePage\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nlong ProcessCodePage(wchar_t *param_1,longlong param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  ulonglong uVar3;\n  LCTYPE LVar4;\n  int local_res8 [2];\n  \n  if (((param_1 == (wchar_t *)0x0) || (*param_1 == L'\\0')) ||\n     (iVar1 = wcscmp(param_1,L\"ACP\"), iVar1 == 0)) {\n    LVar4 = 0x20001004;\n  }\n  else {\n    uVar3 = FUN_14001a634((ushort *)param_1,(ushort *)L\"utf8\");\n    if ((int)uVar3 == 0) {\n      return 0xfde9;\n    }\n    uVar3 = FUN_14001a634((ushort *)param_1,(ushort *)L\"utf-8\");\n    if ((int)uVar3 == 0) {\n      return 0xfde9;\n    }\n    iVar1 = wcscmp(param_1,L\"OCP\");\n    if (iVar1 != 0) {\n      lVar2 = _wtol(param_1);\n      return lVar2;\n    }\n    LVar4 = 0x2000000b;\n  }\n  iVar1 = __acrt_GetLocaleInfoEx((ushort *)(param_2 + 600),LVar4,(LPWSTR)local_res8,2);\n  if (iVar1 == 0) {\n    return 0;\n  }\n  if (local_res8[0] < 3) {\n    return 0xfde9;\n  }\n  return local_res8[0];\n}\n\n",
  "_get_fpsr": "\n/* Library Function - Single Match\n    _get_fpsr\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined4 _get_fpsr(void)\n\n{\n  return MXCSR;\n}\n\n",
  "StateFromIp": "\n/* Library Function - Single Match\n    public: static int __cdecl __FrameHandler4::StateFromIp(struct FH4::FuncInfo4 * __ptr64,struct\n   _xDISPATCHER_CONTEXT * __ptr64,unsigned __int64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\n__FrameHandler4::StateFromIp(FuncInfo4 *param_1,_xDISPATCHER_CONTEXT *param_2,__uint64 param_3)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  \n  if (*(int *)(param_1 + 0x10) != 0) {\n    uVar4 = 0;\n    pbVar6 = (byte *)((longlong)*(int *)(param_1 + 0x10) + *(longlong *)(param_2 + 8));\n    iVar3 = -1;\n    uVar5 = 0;\n    uVar2 = *pbVar6 & 0xf;\n    pbVar6 = pbVar6 + -(longlong)(char)(&DAT_140024780)[uVar2];\n    puVar1 = (uint *)(pbVar6 + -4);\n    if (*puVar1 >> ((&DAT_140024790)[uVar2] & 0x1f) != 0) {\n      do {\n        pbVar7 = pbVar6 + -(longlong)(char)(&DAT_140024780)[*pbVar6 & 0xf];\n        uVar4 = uVar4 + (*(uint *)(pbVar7 + -4) >> ((&DAT_140024790)[*pbVar6 & 0xf] & 0x1f));\n        if (param_3 < (ulonglong)uVar4 + (ulonglong)**(uint **)(param_2 + 0x10) +\n                      *(longlong *)(param_2 + 8)) break;\n        uVar5 = uVar5 + 1;\n        pbVar6 = pbVar7 + -(longlong)(char)(&DAT_140024780)[*pbVar7 & 0xf];\n        iVar3 = (*(uint *)(pbVar6 + -4) >> ((&DAT_140024790)[*pbVar7 & 0xf] & 0x1f)) - 1;\n      } while (uVar5 < *puVar1 >> ((&DAT_140024790)[uVar2] & 0x1f));\n      if (uVar5 != 0) {\n        return iVar3;\n      }\n    }\n  }\n  return -1;\n}\n\n",
  "_raise_excf": "\n/* Library Function - Single Match\n    _raise_excf\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _raise_excf(uint *param_1,ulonglong *param_2,ulonglong param_3,uint param_4,uint *param_5,\n                uint *param_6)\n\n{\n  _raise_exc_ex(param_1,param_2,param_3,param_4,param_5,param_6,1);\n  return;\n}\n\n",
  "FUN_14001f6b0": "\nvoid FUN_14001f6b0(undefined4 param_1)\n\n{\n  MXCSR = param_1;\n  return;\n}\n\n",
  "CatchTryBlock": "\n/* Library Function - Single Match\n    public: static struct _s_TryBlockMapEntry const * __ptr64 __cdecl\n   __FrameHandler3::CatchTryBlock(struct _s_FuncInfo const * __ptr64,int)\n   \n   Library: Visual Studio 2019 Release */\n\n_s_TryBlockMapEntry * __cdecl __FrameHandler3::CatchTryBlock(_s_FuncInfo *param_1,int param_2)\n\n{\n  longlong lVar1;\n  _s_TryBlockMapEntry *p_Var2;\n  ulonglong uVar3;\n  \n  uVar3 = (ulonglong)param_1->nTryBlocks;\n  do {\n    if ((int)uVar3 == 0) {\n      return (_s_TryBlockMapEntry *)0x0;\n    }\n    uVar3 = (ulonglong)((int)uVar3 - 1);\n    lVar1 = FUN_140008b20();\n    p_Var2 = (_s_TryBlockMapEntry *)\n             ((longlong)(int)param_1->dispTryBlockMap + *(longlong *)(lVar1 + 0x60) + uVar3 * 0x14);\n  } while ((param_2 <= *(int *)(p_Var2 + 4)) || (*(int *)(p_Var2 + 8) < param_2));\n  return p_Var2;\n}\n\n",
  "_fclose_nolock": "\n/* Library Function - Single Match\n    _fclose_nolock\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _fclose_nolock(FILE *_File)\n\n{\n  int iVar1;\n  int iVar2;\n  ulong *puVar3;\n  undefined8 uVar4;\n  \n  if (_File == (FILE *)0x0) {\n    puVar3 = __doserrno();\n    *puVar3 = 0x16;\n    FUN_14000d030();\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = -1;\n    if ((*(uint *)((longlong)&_File->_base + 4) >> 0xd & 1) != 0) {\n      uVar4 = __acrt_stdio_flush_nolock(_File);\n      iVar1 = (int)uVar4;\n      __acrt_stdio_free_buffer_nolock(&_File->_ptr);\n      iVar2 = _fileno(_File);\n      iVar2 = _close(iVar2);\n      if (iVar2 < 0) {\n        iVar1 = -1;\n      }\n      else if (_File->_tmpfname != (char *)0x0) {\n        _free_base(_File->_tmpfname);\n        _File->_tmpfname = (char *)0x0;\n      }\n    }\n    __acrt_stdio_free_stream(&_File->_ptr);\n  }\n  return iVar1;\n}\n\n",
  "_Locinfo_dtor": "\n/* Library Function - Single Match\n    public: static void __cdecl std::_Locinfo::_Locinfo_dtor(class std::_Locinfo * __ptr64)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl std::_Locinfo::_Locinfo_dtor(_Locinfo *param_1)\n\n{\n  if (*(char **)(param_1 + 0x48) != (char *)0x0) {\n    setlocale(0,*(char **)(param_1 + 0x48));\n  }\n  return;\n}\n\n",
  "__acrt_unlock": "\n/* Library Function - Single Match\n    __acrt_unlock\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_unlock(int param_1)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00014000d176. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  LeaveCriticalSection((LPCRITICAL_SECTION)(&DAT_140036ea0 + (longlong)param_1 * 0x28));\n  return;\n}\n\n",
  "FUN_14001299c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined FUN_14001299c(void)\n\n{\n  DAT_140037270 = GetCommandLineA();\n  _DAT_140037278 = GetCommandLineW();\n  return 1;\n}\n\n",
  "FrameUnwindToEmptyState": "\n/* Library Function - Single Match\n    public: static void __cdecl __FrameHandler3::FrameUnwindToEmptyState(unsigned __int64 *\n   __ptr64,struct _xDISPATCHER_CONTEXT * __ptr64,struct _s_FuncInfo const * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl\n__FrameHandler3::FrameUnwindToEmptyState\n          (__uint64 *param_1,_xDISPATCHER_CONTEXT *param_2,_s_FuncInfo *param_3)\n\n{\n  int iVar1;\n  __uint64 *p_Var2;\n  _s_TryBlockMapEntry *p_Var3;\n  __uint64 local_res20;\n  \n  p_Var2 = GetEstablisherFrame(param_1,param_2,param_3,&local_res20);\n  iVar1 = FUN_140008d54((longlong)param_3,(ulonglong *)param_2);\n  p_Var3 = CatchTryBlock(param_3,iVar1);\n  if (p_Var3 == (_s_TryBlockMapEntry *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = *(int *)(p_Var3 + 4);\n  }\n  FrameUnwindToState(p_Var2,param_2,param_3,iVar1);\n  return;\n}\n\n",
  "_GetThrowImageBase": "\n/* Library Function - Single Match\n    _GetThrowImageBase\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 _GetThrowImageBase(void)\n\n{\n  longlong lVar1;\n  \n  lVar1 = FUN_140008b20();\n  return *(undefined8 *)(lVar1 + 0x68);\n}\n\n",
  "write_text_utf8_nolock": "\n/* WARNING: Function: __chkstk replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    struct `anonymous namespace'::write_result __cdecl write_text_utf8_nolock(int,char const *\n   __ptr64 const,unsigned int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl write_text_utf8_nolock(DWORD *param_1,uint param_2,WCHAR *param_3,uint param_4)\n\n{\n  WCHAR WVar1;\n  HANDLE hFile;\n  uint uVar2;\n  BOOL BVar3;\n  DWORD DVar4;\n  WCHAR *pWVar5;\n  uint uVar6;\n  ulonglong uVar7;\n  WCHAR *pWVar8;\n  WCHAR *pWVar9;\n  bool bVar10;\n  undefined auStackY_1498 [32];\n  DWORD local_1458 [4];\n  WCHAR local_1448 [856];\n  CHAR local_d98 [3424];\n  ulonglong local_38;\n  undefined8 uStack_30;\n  \n  uStack_30 = 0x140016b64;\n  local_38 = DAT_140035020 ^ (ulonglong)auStackY_1498;\n  pWVar9 = (WCHAR *)((ulonglong)param_4 + (longlong)param_3);\n  hFile = *(HANDLE *)\n           ((&DAT_140037490)[(longlong)(int)param_2 >> 6] + 0x28 +\n           (ulonglong)(param_2 & 0x3f) * 0x48);\n  *(undefined8 *)param_1 = 0;\n  bVar10 = param_3 < pWVar9;\n  param_1[2] = 0;\n  pWVar8 = param_3;\n  do {\n    if (!bVar10) {\nLAB_140016c89:\n      FUN_140006060(local_38 ^ (ulonglong)auStackY_1498);\n      return;\n    }\n    pWVar5 = local_1448;\n    do {\n      if (pWVar9 <= pWVar8) break;\n      WVar1 = *pWVar8;\n      pWVar8 = pWVar8 + 1;\n      if (WVar1 == L'\\n') {\n        *pWVar5 = L'\\r';\n        pWVar5 = pWVar5 + 1;\n      }\n      *pWVar5 = WVar1;\n      pWVar5 = pWVar5 + 1;\n    } while (pWVar5 < local_1448 + 0x354);\n    uVar2 = __acrt_WideCharToMultiByte\n                      (0xfde9,0,local_1448,(int)((longlong)pWVar5 - (longlong)local_1448 >> 1),\n                       local_d98,0xd55,(LPBOOL)0x0,(LPBOOL)0x0);\n    if (uVar2 == 0) {\nLAB_140016c81:\n      DVar4 = GetLastError();\n      *param_1 = DVar4;\n      goto LAB_140016c89;\n    }\n    uVar7 = 0;\n    if (uVar2 != 0) {\n      do {\n        BVar3 = WriteFile(hFile,local_d98 + uVar7,uVar2 - (int)uVar7,local_1458,(LPOVERLAPPED)0x0);\n        if (BVar3 == 0) goto LAB_140016c81;\n        uVar6 = (int)uVar7 + local_1458[0];\n        uVar7 = (ulonglong)uVar6;\n      } while (uVar6 < uVar2);\n    }\n    param_1[1] = (int)pWVar8 - (int)param_3;\n    bVar10 = pWVar8 < pWVar9;\n  } while( true );\n}\n\n",
  "FUN_1400198e0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_1400198e0(undefined8 param_1)\n\n{\n  _DAT_1400378a8 = param_1;\n  _DAT_1400378b0 = param_1;\n  _DAT_1400378b8 = param_1;\n  _DAT_1400378c0 = param_1;\n  return;\n}\n\n",
  "FUN_140003814": "\nundefined8 * FUN_140003814(undefined8 *param_1)\n\n{\n  param_1[2] = 0;\n  param_1[1] = \"bad allocation\";\n  *param_1 = std::bad_alloc::vftable;\n  return param_1;\n}\n\n",
  "seekoff": "\n/* Library Function - Single Match\n    protected: virtual class std::fpos<struct _Mbstatet> __cdecl std::basic_filebuf<char,struct\n   std::char_traits<char> >::seekoff(__int64,int,int) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nfpos_t * __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::seekoff\n          (basic_filebuf<char,struct_std::char_traits<char>_> *this,fpos_t *param_1,\n          longlong param_3_00,uint param_3)\n\n{\n  basic_filebuf<char,struct_std::char_traits<char>_> *pbVar1;\n  undefined8 uVar2;\n  bool bVar3;\n  int iVar4;\n  ulonglong uVar5;\n  fpos_t fVar6;\n  fpos_t local_res8;\n  \n  if (((**(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x38) == this + 0x70) &&\n      (param_3 == 1)) && (*(longlong *)(this + 0x68) == 0)) {\n    param_3_00 = param_3_00 + -1;\n  }\n  if (*(longlong *)(this + 0x80) != 0) {\n    bVar3 = _Endwrite(this);\n    if (bVar3) {\n      if ((param_3_00 != 0) || (param_3 != 1)) {\n        uVar5 = common_fseek(*(FILE **)(this + 0x80),param_3_00,param_3);\n        if ((int)uVar5 != 0) goto LAB_1400049bf;\n      }\n      iVar4 = fgetpos(*(FILE **)(this + 0x80),&local_res8);\n      if (iVar4 == 0) {\n        if (**(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x18) == this + 0x70)\n        {\n          pbVar1 = *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x88);\n          uVar2 = *(undefined8 *)(this + 0x90);\n          **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x18) = pbVar1;\n          **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x38) = pbVar1;\n          **(int **)(this + 0x50) = (int)uVar2 - (int)pbVar1;\n        }\n        fVar6 = *(fpos_t *)(this + 0x74);\n        param_1[1] = 0;\n        *param_1 = local_res8;\n        goto LAB_1400049ca;\n      }\n    }\n  }\nLAB_1400049bf:\n  *param_1 = -1;\n  param_1[1] = 0;\n  fVar6 = 0;\nLAB_1400049ca:\n  param_1[2] = fVar6;\n  return param_1;\n}\n\n",
  "FUN_140006a98": "\nundefined * FUN_140006a98(void)\n\n{\n  return &DAT_140036d10;\n}\n\n",
  "FUN_140011e34": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_140011e34(undefined8 param_1)\n\n{\n  _DAT_140037108 = param_1;\n  return;\n}\n\n",
  "FUN_14000716c": "\nbyte FUN_14000716c(undefined8 param_1,byte *param_2)\n\n{\n  return *param_2 & 1;\n}\n\n",
  "destroy_ptd_array": "\n/* Library Function - Single Match\n    void __cdecl destroy_ptd_array(struct __acrt_ptd * __ptr64 const)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl destroy_ptd_array(__acrt_ptd *param_1)\n\n{\n  undefined local_res10 [8];\n  int local_res18 [2];\n  int local_res20 [2];\n  int local_28 [2];\n  __acrt_ptd *local_20;\n  __acrt_ptd **local_18;\n  __acrt_ptd **local_10;\n  \n  local_18 = &local_20;\n  local_res18[0] = 5;\n  local_res20[0] = 5;\n  local_10 = &local_20;\n  local_28[0] = 4;\n  local_28[1] = 4;\n  local_20 = param_1;\n  if (*(undefined **)param_1 != &DAT_140027e30) {\n    _free_base(*(undefined **)param_1);\n  }\n  _free_base(*(LPVOID *)(local_20 + 0x70));\n  _free_base(*(LPVOID *)(local_20 + 0x58));\n  _free_base(*(LPVOID *)(local_20 + 0x60));\n  _free_base(*(LPVOID *)(local_20 + 0x68));\n  _free_base(*(LPVOID *)(local_20 + 0x48));\n  _free_base(*(LPVOID *)(local_20 + 0x50));\n  _free_base(*(LPVOID *)(local_20 + 0x78));\n  _free_base(*(LPVOID *)(local_20 + 0x80));\n  _free_base(*(LPVOID *)(local_20 + 0x3c0));\n  operator()<>(local_res10,local_res20,(longlong **)&local_18,local_res18);\n  operator()<>(local_res10,local_28 + 1,&local_10,local_28);\n  return;\n}\n\n",
  "FUN_140002720": "\nvoid FUN_140002720(longlong param_1)\n\n{\n  code *pcVar1;\n  ulonglong uVar2;\n  _Facet_base *p_Var3;\n  longlong lVar4;\n  longlong lVar5;\n  undefined auStack_48 [32];\n  _Lockit local_28 [4];\n  _Lockit local_24 [4];\n  _Facet_base *local_20;\n  ulonglong local_18;\n  \n  local_18 = DAT_140035020 ^ (ulonglong)auStack_48;\n  std::_Lockit::_Lockit(local_24,0);\n  p_Var3 = DAT_1400379f0;\n  local_20 = DAT_1400379f0;\n  if (DAT_140036398 == 0) {\n    std::_Lockit::_Lockit(local_28,0);\n    if (DAT_140036398 == 0) {\n      DAT_140036380 = DAT_140036380 + 1;\n      DAT_140036398 = (ulonglong)DAT_140036380;\n    }\n    std::_Lockit::~_Lockit(local_28);\n  }\n  uVar2 = DAT_140036398;\n  lVar4 = *(longlong *)(param_1 + 8);\n  if ((DAT_140036398 < *(ulonglong *)(lVar4 + 0x18)) &&\n     (*(longlong *)(*(longlong *)(lVar4 + 0x10) + DAT_140036398 * 8) != 0)) goto LAB_140002820;\n  lVar5 = 0;\n  if (*(char *)(lVar4 + 0x24) == '\\0') {\nLAB_1400027dc:\n    if (lVar5 != 0) goto LAB_140002820;\n  }\n  else {\n    lVar4 = FUN_14000543c();\n    if (uVar2 < *(ulonglong *)(lVar4 + 0x18)) {\n      lVar5 = *(longlong *)(*(longlong *)(lVar4 + 0x10) + uVar2 * 8);\n      goto LAB_1400027dc;\n    }\n  }\n  if (p_Var3 == (_Facet_base *)0x0) {\n    lVar4 = FUN_140001ac0((longlong *)&local_20,param_1);\n    p_Var3 = local_20;\n    if (lVar4 == -1) {\n      FUN_1400018c0();\n      pcVar1 = (code *)swi(3);\n      (*pcVar1)();\n      return;\n    }\n    std::_Facet_Register(local_20);\n    (**(code **)(*(longlong *)p_Var3 + 8))(p_Var3);\n    DAT_1400379f0 = p_Var3;\n  }\nLAB_140002820:\n  std::_Lockit::~_Lockit(local_24);\n  FUN_140006060(local_18 ^ (ulonglong)auStack_48);\n  return;\n}\n\n",
  "__vcrt_initialize_ptd": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    __vcrt_initialize_ptd\n   \n   Library: Visual Studio 2019 Release */\n\nuint __vcrt_initialize_ptd(void)\n\n{\n  uint uVar1;\n  int iVar2;\n  \n  uVar1 = __vcrt_FlsAlloc(&LAB_140008b00);\n  DAT_140035050 = uVar1;\n  if (uVar1 != 0xffffffff) {\n    iVar2 = __vcrt_FlsSetValue(uVar1,&DAT_140036d30);\n    if (iVar2 != 0) {\n      _DAT_140036da8 = 0xfffffffe;\n      return CONCAT31((int3)((uint)iVar2 >> 8),1);\n    }\n    uVar1 = __vcrt_uninitialize_ptd();\n  }\n  return uVar1 & 0xffffff00;\n}\n\n",
  "__vcrt_InitializeCriticalSectionEx": "\n/* Library Function - Single Match\n    __vcrt_InitializeCriticalSectionEx\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __vcrt_InitializeCriticalSectionEx(LPCRITICAL_SECTION param_1,DWORD param_2,undefined4 param_3)\n\n{\n  FARPROC pFVar1;\n  \n  pFVar1 = FUN_14000bdf8(4,\"InitializeCriticalSectionEx\",(uint *)&DAT_1400257d8,\n                         (uint *)\"InitializeCriticalSectionEx\");\n  if (pFVar1 == (FARPROC)0x0) {\n    InitializeCriticalSectionAndSpinCount(param_1,param_2);\n  }\n  else {\n    (*(code *)PTR__guard_dispatch_icall_140023298)(param_1,param_2,param_3);\n  }\n  return;\n}\n\n",
  "__acrt_LCIDToLocaleName": "\n/* Library Function - Single Match\n    __acrt_LCIDToLocaleName\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_LCIDToLocaleName(uint param_1,wchar_t *param_2,int param_3)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = try_get_function(0x15,\"LCIDToLocaleName\",(module_id *)&DAT_140028e98,\n                            (module_id *)\"LCIDToLocaleName\");\n  if (pvVar1 == (void *)0x0) {\n    __acrt_DownlevelLCIDToLocaleName(param_1,param_2,param_3);\n  }\n  else {\n    (*(code *)PTR__guard_dispatch_icall_140023298)();\n  }\n  return;\n}\n\n",
  "common_ftell_translated_utf8_nolock": "\n/* WARNING: Function: __chkstk replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    __int64 __cdecl common_ftell_translated_utf8_nolock(class __crt_stdio_stream,__int64)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\n__int64 __cdecl common_ftell_translated_utf8_nolock(FILE *param_1,__int64 param_2)\n\n{\n  uint uVar1;\n  BOOL BVar2;\n  longlong lVar3;\n  ulonglong uVar4;\n  __int64 _Var5;\n  byte *pbVar6;\n  longlong lVar7;\n  undefined auStackY_1078 [32];\n  uint local_1048 [3];\n  byte abStack_1039 [4097];\n  ulonglong local_38;\n  undefined8 uStack_30;\n  \n  uStack_30 = 0x1400174de;\n  local_38 = DAT_140035020 ^ (ulonglong)auStackY_1078;\n  uVar1 = _fileno(param_1);\n  lVar7 = 0;\n  if (*(int *)&param_1->_base != 0) {\n    uVar4 = (ulonglong)(uVar1 & 0x3f);\n    lVar3 = ((longlong)param_1->_ptr - *(longlong *)&param_1->_cnt) / 2;\n    _Var5 = common_lseek<__int64>\n                      (uVar1,*(__int64 *)\n                              ((&DAT_140037490)[(longlong)(int)uVar1 >> 6] + 0x30 + uVar4 * 0x48),0)\n    ;\n    if ((((_Var5 == *(longlong *)((&DAT_140037490)[(longlong)(int)uVar1 >> 6] + 0x30 + uVar4 * 0x48)\n          ) && (BVar2 = ReadFile(*(HANDLE *)\n                                  ((&DAT_140037490)[(longlong)(int)uVar1 >> 6] + 0x28 + uVar4 * 0x48\n                                  ),abStack_1039 + 1,0x1000,local_1048,(LPOVERLAPPED)0x0),\n               BVar2 != 0)) && (_Var5 = common_lseek<__int64>(uVar1,param_2,0), -1 < _Var5)) &&\n       (uVar4 = (ulonglong)local_1048[0], lVar3 <= (longlong)uVar4)) {\n      pbVar6 = abStack_1039;\n      if (lVar3 != 0) {\n        do {\n          pbVar6 = pbVar6 + 1;\n          if (abStack_1039 + uVar4 + 1 <= pbVar6) break;\n          if (*pbVar6 == 0xd) {\n            if ((pbVar6 < abStack_1039 + uVar4) && (pbVar6[1] == 10)) {\n              pbVar6 = pbVar6 + 1;\n            }\n          }\n          else {\n            pbVar6 = pbVar6 + (char)(&DAT_140035420)[*pbVar6];\n          }\n          lVar7 = lVar7 + 1;\n        } while (lVar7 != lVar3);\n      }\n    }\n  }\n  _Var5 = FUN_140006060(local_38 ^ (ulonglong)auStackY_1078);\n  return _Var5;\n}\n\n",
  "FUN_1400075a4": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_1400075a4(PVOID *param_1,ULONG_PTR param_2,ULONG_PTR param_3,ULONG_PTR param_4,\n                  ULONG_PTR param_5,ULONG_PTR param_6,int param_7,undefined8 param_8,\n                  undefined8 param_9,PVOID *param_10,byte param_11)\n\n{\n  undefined auStackY_e8 [32];\n  EXCEPTION_RECORD local_b8;\n  ulonglong local_18;\n  \n  local_18 = DAT_140035020 ^ (ulonglong)auStackY_e8;\n  local_b8.ExceptionCode = _DAT_140024840;\n  local_b8.ExceptionFlags = _UNK_140024844;\n  local_b8.ExceptionRecord._0_4_ = _UNK_140024848;\n  local_b8.ExceptionRecord._4_4_ = _UNK_14002484c;\n  local_b8.ExceptionAddress._0_4_ = _DAT_140024850;\n  local_b8.ExceptionAddress._4_4_ = _UNK_140024854;\n  local_b8.NumberParameters = _UNK_140024858;\n  local_b8._28_4_ = _UNK_14002485c;\n  local_b8.ExceptionInformation[9]._0_4_ = _UNK_1400248a8;\n  local_b8.ExceptionInformation[9]._4_4_ = _UNK_1400248ac;\n  local_b8.ExceptionInformation[10]._0_4_ = _DAT_1400248b0;\n  local_b8.ExceptionInformation[10]._4_4_ = _UNK_1400248b4;\n  local_b8.ExceptionInformation[0xb]._0_4_ = _UNK_1400248b8;\n  local_b8.ExceptionInformation[0xb]._4_4_ = _UNK_1400248bc;\n  local_b8.ExceptionInformation[0xc]._0_4_ = _DAT_1400248c0;\n  local_b8.ExceptionInformation[0xc]._4_4_ = _UNK_1400248c4;\n  local_b8.ExceptionInformation[0xd]._0_4_ = _UNK_1400248c8;\n  local_b8.ExceptionInformation[0xd]._4_4_ = _UNK_1400248cc;\n  local_b8.ExceptionInformation[0xe] = DAT_1400248d0;\n  local_b8.ExceptionInformation[0] = (ULONG_PTR)&LAB_14000adb0;\n  local_b8.ExceptionInformation[2] = param_5;\n  local_b8.ExceptionInformation[3] = (ULONG_PTR)param_7;\n  local_b8.ExceptionInformation[5] = param_6;\n  local_b8.ExceptionInformation[7] = (ULONG_PTR)param_11;\n  local_b8.ExceptionInformation[8] = 0x19930520;\n  local_b8.ExceptionInformation[1] = param_4;\n  local_b8.ExceptionInformation[4] = param_3;\n  local_b8.ExceptionInformation[6] = param_2;\n  RtlUnwindEx(*param_1,*param_10,&local_b8,(PVOID)0x0,(PCONTEXT)param_10[5],\n              (PUNWIND_HISTORY_TABLE)param_10[8]);\n  FUN_140006060(local_18 ^ (ulonglong)auStackY_e8);\n  return;\n}\n\n",
  "FUN_140006aa0": "\nvoid FUN_140006aa0(void)\n\n{\n  ulonglong *puVar1;\n  \n  puVar1 = FUN_140005d44();\n  *puVar1 = *puVar1 | 0x24;\n  puVar1 = (ulonglong *)FUN_140006a98();\n  *puVar1 = *puVar1 | 2;\n  return;\n}\n\n",
  "FUN_140021d54": "\nchar * FUN_140021d54(ulonglong param_1,char param_2)\n\n{\n  uint uVar1;\n  ushort uVar2;\n  uint uVar3;\n  char *pcVar4;\n  char *pcVar5;\n  undefined auVar6 [16];\n  char cVar7;\n  char cVar11;\n  char cVar12;\n  char cVar13;\n  undefined in_XMM1 [16];\n  undefined auVar8 [16];\n  undefined auVar9 [16];\n  undefined auVar10 [16];\n  \n  pcVar4 = (char *)(param_1 & 0xfffffffffffffff0);\n  auVar8 = pshuflw(in_XMM1,ZEXT216(CONCAT11(param_2,param_2)),0);\n  auVar6[0] = -(*pcVar4 == '\\0');\n  auVar6[1] = -(pcVar4[1] == '\\0');\n  auVar6[2] = -(pcVar4[2] == '\\0');\n  auVar6[3] = -(pcVar4[3] == '\\0');\n  auVar6[4] = -(pcVar4[4] == '\\0');\n  auVar6[5] = -(pcVar4[5] == '\\0');\n  auVar6[6] = -(pcVar4[6] == '\\0');\n  auVar6[7] = -(pcVar4[7] == '\\0');\n  auVar6[8] = -(pcVar4[8] == '\\0');\n  auVar6[9] = -(pcVar4[9] == '\\0');\n  auVar6[10] = -(pcVar4[10] == '\\0');\n  auVar6[0xb] = -(pcVar4[0xb] == '\\0');\n  auVar6[0xc] = -(pcVar4[0xc] == '\\0');\n  auVar6[0xd] = -(pcVar4[0xd] == '\\0');\n  auVar6[0xe] = -(pcVar4[0xe] == '\\0');\n  auVar6[0xf] = -(pcVar4[0xf] == '\\0');\n  cVar7 = auVar8[0];\n  auVar9[0] = -(cVar7 == *pcVar4);\n  cVar11 = auVar8[1];\n  auVar9[1] = -(cVar11 == pcVar4[1]);\n  cVar12 = auVar8[2];\n  auVar9[2] = -(cVar12 == pcVar4[2]);\n  cVar13 = auVar8[3];\n  auVar9[3] = -(cVar13 == pcVar4[3]);\n  auVar9[4] = -(cVar7 == pcVar4[4]);\n  auVar9[5] = -(cVar11 == pcVar4[5]);\n  auVar9[6] = -(cVar12 == pcVar4[6]);\n  auVar9[7] = -(cVar13 == pcVar4[7]);\n  auVar9[8] = -(cVar7 == pcVar4[8]);\n  auVar9[9] = -(cVar11 == pcVar4[9]);\n  auVar9[10] = -(cVar12 == pcVar4[10]);\n  auVar9[0xb] = -(cVar13 == pcVar4[0xb]);\n  auVar9[0xc] = -(cVar7 == pcVar4[0xc]);\n  auVar9[0xd] = -(cVar11 == pcVar4[0xd]);\n  auVar9[0xe] = -(cVar12 == pcVar4[0xe]);\n  auVar9[0xf] = -(cVar13 == pcVar4[0xf]);\n  auVar9 = auVar9 | auVar6;\n  uVar3 = (uint)(ushort)((ushort)(SUB161(auVar9 >> 7,0) & 1) |\n                         (ushort)(SUB161(auVar9 >> 0xf,0) & 1) << 1 |\n                         (ushort)(SUB161(auVar9 >> 0x17,0) & 1) << 2 |\n                         (ushort)(SUB161(auVar9 >> 0x1f,0) & 1) << 3 |\n                         (ushort)(SUB161(auVar9 >> 0x27,0) & 1) << 4 |\n                         (ushort)(SUB161(auVar9 >> 0x2f,0) & 1) << 5 |\n                         (ushort)(SUB161(auVar9 >> 0x37,0) & 1) << 6 |\n                         (ushort)(SUB161(auVar9 >> 0x3f,0) & 1) << 7 |\n                         (ushort)(SUB161(auVar9 >> 0x47,0) & 1) << 8 |\n                         (ushort)(SUB161(auVar9 >> 0x4f,0) & 1) << 9 |\n                         (ushort)(SUB161(auVar9 >> 0x57,0) & 1) << 10 |\n                         (ushort)(SUB161(auVar9 >> 0x5f,0) & 1) << 0xb |\n                         (ushort)(SUB161(auVar9 >> 0x67,0) & 1) << 0xc |\n                         (ushort)(SUB161(auVar9 >> 0x6f,0) & 1) << 0xd |\n                         (ushort)(SUB161(auVar9 >> 0x77,0) & 1) << 0xe |\n                        (ushort)(byte)(auVar9[0xf] >> 7) << 0xf) & -1 << ((byte)param_1 & 0xf);\n  pcVar5 = pcVar4;\n  if (uVar3 == 0) {\n    do {\n      pcVar4 = pcVar5 + 0x10;\n      auVar10[0] = -(cVar7 == *pcVar4);\n      auVar10[1] = -(cVar11 == pcVar5[0x11]);\n      auVar10[2] = -(cVar12 == pcVar5[0x12]);\n      auVar10[3] = -(cVar13 == pcVar5[0x13]);\n      auVar10[4] = -(cVar7 == pcVar5[0x14]);\n      auVar10[5] = -(cVar11 == pcVar5[0x15]);\n      auVar10[6] = -(cVar12 == pcVar5[0x16]);\n      auVar10[7] = -(cVar13 == pcVar5[0x17]);\n      auVar10[8] = -(cVar7 == pcVar5[0x18]);\n      auVar10[9] = -(cVar11 == pcVar5[0x19]);\n      auVar10[10] = -(cVar12 == pcVar5[0x1a]);\n      auVar10[0xb] = -(cVar13 == pcVar5[0x1b]);\n      auVar10[0xc] = -(cVar7 == pcVar5[0x1c]);\n      auVar10[0xd] = -(cVar11 == pcVar5[0x1d]);\n      auVar10[0xe] = -(cVar12 == pcVar5[0x1e]);\n      auVar10[0xf] = -(cVar13 == pcVar5[0x1f]);\n      auVar8[0] = -(*pcVar4 == '\\0');\n      auVar8[1] = -(pcVar5[0x11] == '\\0');\n      auVar8[2] = -(pcVar5[0x12] == '\\0');\n      auVar8[3] = -(pcVar5[0x13] == '\\0');\n      auVar8[4] = -(pcVar5[0x14] == '\\0');\n      auVar8[5] = -(pcVar5[0x15] == '\\0');\n      auVar8[6] = -(pcVar5[0x16] == '\\0');\n      auVar8[7] = -(pcVar5[0x17] == '\\0');\n      auVar8[8] = -(pcVar5[0x18] == '\\0');\n      auVar8[9] = -(pcVar5[0x19] == '\\0');\n      auVar8[10] = -(pcVar5[0x1a] == '\\0');\n      auVar8[0xb] = -(pcVar5[0x1b] == '\\0');\n      auVar8[0xc] = -(pcVar5[0x1c] == '\\0');\n      auVar8[0xd] = -(pcVar5[0x1d] == '\\0');\n      auVar8[0xe] = -(pcVar5[0x1e] == '\\0');\n      auVar8[0xf] = -(pcVar5[0x1f] == '\\0');\n      auVar10 = auVar10 | auVar8;\n      uVar2 = (ushort)(SUB161(auVar10 >> 7,0) & 1) | (ushort)(SUB161(auVar10 >> 0xf,0) & 1) << 1 |\n              (ushort)(SUB161(auVar10 >> 0x17,0) & 1) << 2 |\n              (ushort)(SUB161(auVar10 >> 0x1f,0) & 1) << 3 |\n              (ushort)(SUB161(auVar10 >> 0x27,0) & 1) << 4 |\n              (ushort)(SUB161(auVar10 >> 0x2f,0) & 1) << 5 |\n              (ushort)(SUB161(auVar10 >> 0x37,0) & 1) << 6 |\n              (ushort)(SUB161(auVar10 >> 0x3f,0) & 1) << 7 |\n              (ushort)(SUB161(auVar10 >> 0x47,0) & 1) << 8 |\n              (ushort)(SUB161(auVar10 >> 0x4f,0) & 1) << 9 |\n              (ushort)(SUB161(auVar10 >> 0x57,0) & 1) << 10 |\n              (ushort)(SUB161(auVar10 >> 0x5f,0) & 1) << 0xb |\n              (ushort)(SUB161(auVar10 >> 0x67,0) & 1) << 0xc |\n              (ushort)(SUB161(auVar10 >> 0x6f,0) & 1) << 0xd |\n              (ushort)(SUB161(auVar10 >> 0x77,0) & 1) << 0xe |\n              (ushort)(byte)(auVar10[0xf] >> 7) << 0xf;\n      uVar3 = (uint)uVar2;\n      pcVar5 = pcVar4;\n    } while (uVar2 == 0);\n  }\n  uVar1 = 0;\n  if (uVar3 != 0) {\n    for (; (uVar3 >> uVar1 & 1) == 0; uVar1 = uVar1 + 1) {\n    }\n  }\n  pcVar5 = (char *)0x0;\n  if (pcVar4[uVar1] == param_2) {\n    pcVar5 = pcVar4 + uVar1;\n  }\n  return pcVar5;\n}\n\n",
  "FUN_140001220": "\nchar * FUN_140001220(longlong param_1)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = \"Unknown exception\";\n  if (*(char **)(param_1 + 8) != (char *)0x0) {\n    pcVar1 = *(char **)(param_1 + 8);\n  }\n  return pcVar1;\n}\n\n",
  "__acrt_WideCharToMultiByte": "\n/* Library Function - Single Match\n    __acrt_WideCharToMultiByte\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_WideCharToMultiByte\n               (uint param_1,uint param_2,LPCWSTR param_3,int param_4,LPSTR param_5,int param_6,\n               LPBOOL param_7,LPBOOL param_8)\n\n{\n  DWORD dwFlags;\n  bool bVar1;\n  \n  dwFlags = 0;\n  if (param_1 < 0xc436) {\n    if ((param_1 - 0xc42c < 10) && ((0x2a7U >> (param_1 - 0xc42c & 0x1f) & 1) != 0))\n    goto LAB_14001a5c8;\n    bVar1 = param_1 == 0x2a;\nLAB_14001a5be:\n    if (bVar1) goto LAB_14001a5c8;\n  }\n  else {\n    if (param_1 == 0xd698) goto LAB_14001a5c8;\n    if (0xdea9 < param_1) {\n      if ((param_1 < 0xdeb4) || (param_1 == 65000)) goto LAB_14001a5c8;\n      bVar1 = param_1 == 0xfde9;\n      goto LAB_14001a5be;\n    }\n  }\n  dwFlags = param_2 & 0xffffff7f;\nLAB_14001a5c8:\n  if (param_1 - 65000 < 2) {\n    param_8 = (LPBOOL)0x0;\n    param_7 = (LPBOOL)0x0;\n  }\n                    /* WARNING: Could not recover jumptable at 0x00014001a5eb. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  WideCharToMultiByte(param_1,dwFlags,param_3,param_4,param_5,param_6,(LPCSTR)param_7,param_8);\n  return;\n}\n\n",
  "~sentry": "\n/* Library Function - Multiple Matches With Same Base Name\n    public: __cdecl std::basic_ostream<char,struct std::char_traits<char> >::sentry::~sentry(void)\n   __ptr64\n    public: __cdecl std::basic_ostream<unsigned short,struct std::char_traits<unsigned short>\n   >::sentry::~sentry(void) __ptr64\n    public: __cdecl std::basic_ostream<wchar_t,struct std::char_traits<wchar_t>\n   >::sentry::~sentry(void) __ptr64\n   \n   Library: Visual Studio 2012 Release */\n\nvoid ~sentry(longlong **param_1)\n\n{\n  longlong *plVar1;\n  bool bVar2;\n  \n  bVar2 = __uncaught_exception();\n  if (!bVar2) {\n    FUN_140002ee0(*param_1);\n  }\n  plVar1 = *(longlong **)((longlong)*(int *)(**param_1 + 4) + 0x48 + (longlong)*param_1);\n  if (plVar1 != (longlong *)0x0) {\n    (**(code **)(*plVar1 + 0x10))();\n  }\n  return;\n}\n\n",
  "initialize_stdio_handles_nolock": "\n/* Library Function - Single Match\n    void __cdecl initialize_stdio_handles_nolock(void)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl initialize_stdio_handles_nolock(void)\n\n{\n  byte *pbVar1;\n  longlong lVar2;\n  uint uVar3;\n  HANDLE hFile;\n  DWORD nStdHandle;\n  ulonglong uVar4;\n  uint uVar5;\n  longlong lVar6;\n  \n  uVar5 = 0;\n  lVar6 = 0;\n  do {\n    uVar4 = (ulonglong)(uVar5 & 0x3f);\n    lVar2 = (&DAT_140037490)[(longlong)(int)uVar5 >> 6];\n    if (*(longlong *)(lVar2 + 0x28 + uVar4 * 0x48) + 2U < 2) {\n      *(undefined *)(lVar2 + 0x38 + uVar4 * 0x48) = 0x81;\n      if (uVar5 == 0) {\n        nStdHandle = 0xfffffff6;\n      }\n      else if (uVar5 == 1) {\n        nStdHandle = 0xfffffff5;\n      }\n      else {\n        nStdHandle = 0xfffffff4;\n      }\n      hFile = GetStdHandle(nStdHandle);\n      if ((longlong)hFile + 1U < 2) {\n        uVar3 = 0;\n      }\n      else {\n        uVar3 = GetFileType(hFile);\n      }\n      if (uVar3 == 0) {\n        pbVar1 = (byte *)(lVar2 + 0x38 + uVar4 * 0x48);\n        *pbVar1 = *pbVar1 | 0x40;\n        *(undefined8 *)(lVar2 + 0x28 + uVar4 * 0x48) = 0xfffffffffffffffe;\n        if (DAT_1400370e0 != 0) {\n          *(undefined4 *)(*(longlong *)(lVar6 + DAT_1400370e0) + 0x18) = 0xfffffffe;\n        }\n      }\n      else {\n        *(HANDLE *)(lVar2 + 0x28 + uVar4 * 0x48) = hFile;\n        if ((uVar3 & 0xff) == 2) {\n          pbVar1 = (byte *)(lVar2 + 0x38 + uVar4 * 0x48);\n          *pbVar1 = *pbVar1 | 0x40;\n        }\n        else if ((uVar3 & 0xff) == 3) {\n          pbVar1 = (byte *)(lVar2 + 0x38 + uVar4 * 0x48);\n          *pbVar1 = *pbVar1 | 8;\n        }\n      }\n    }\n    else {\n      pbVar1 = (byte *)(lVar2 + 0x38 + uVar4 * 0x48);\n      *pbVar1 = *pbVar1 | 0x80;\n    }\n    uVar5 = uVar5 + 1;\n    lVar6 = lVar6 + 8;\n  } while (uVar5 != 3);\n  return;\n}\n\n",
  "_get_osfhandle": "\n/* Library Function - Single Match\n    _get_osfhandle\n   \n   Library: Visual Studio 2019 Release */\n\nintptr_t __cdecl _get_osfhandle(int _FileHandle)\n\n{\n  ulong *puVar1;\n  \n  if (_FileHandle == -2) {\n    puVar1 = __doserrno();\n    *puVar1 = 0;\n    puVar1 = __doserrno();\n    *puVar1 = 9;\n  }\n  else {\n    if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_140037890)) {\n      if ((*(byte *)((&DAT_140037490)[(longlong)_FileHandle >> 6] + 0x38 +\n                    (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) != 0) {\n        return *(intptr_t *)\n                ((&DAT_140037490)[(longlong)_FileHandle >> 6] + 0x28 +\n                (ulonglong)(_FileHandle & 0x3f) * 0x48);\n      }\n    }\n    puVar1 = __doserrno();\n    *puVar1 = 0;\n    puVar1 = __doserrno();\n    *puVar1 = 9;\n    FUN_14000d030();\n  }\n  return -1;\n}\n\n",
  "_Facet_Register": "\n/* Library Function - Single Match\n    void __cdecl std::_Facet_Register(class std::_Facet_base * __ptr64)\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl std::_Facet_Register(_Facet_base *param_1)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)operator_new(0x10);\n  if (puVar1 != (undefined8 *)0x0) {\n    *puVar1 = DAT_1400363c8;\n    puVar1[1] = param_1;\n  }\n  DAT_1400363c8 = puVar1;\n  return;\n}\n\n",
  "update_thread_multibyte_data_internal": "\n/* Library Function - Single Match\n    struct __crt_multibyte_data * __ptr64 __cdecl update_thread_multibyte_data_internal(struct\n   __acrt_ptd * __ptr64 const,struct __crt_multibyte_data * __ptr64 * __ptr64 const)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\n__crt_multibyte_data * __cdecl\nupdate_thread_multibyte_data_internal(__acrt_ptd *param_1,__crt_multibyte_data **param_2)\n\n{\n  int iVar1;\n  __crt_multibyte_data *p_Var2;\n  \n  if (((*(uint *)(param_1 + 0x3a8) & DAT_140035520) == 0) || (*(longlong *)(param_1 + 0x90) == 0)) {\n    __acrt_lock(5);\n    p_Var2 = *(__crt_multibyte_data **)(param_1 + 0x88);\n    if (p_Var2 != *param_2) {\n      if (p_Var2 != (__crt_multibyte_data *)0x0) {\n        LOCK();\n        iVar1 = *(int *)p_Var2;\n        *(int *)p_Var2 = *(int *)p_Var2 + -1;\n        UNLOCK();\n        if ((iVar1 == 1) && (p_Var2 != (__crt_multibyte_data *)&DAT_1400355c0)) {\n          _free_base(p_Var2);\n        }\n      }\n      p_Var2 = *param_2;\n      *(__crt_multibyte_data **)(param_1 + 0x88) = p_Var2;\n      LOCK();\n      *(int *)p_Var2 = *(int *)p_Var2 + 1;\n      UNLOCK();\n    }\n    __acrt_unlock(5);\n  }\n  else {\n    p_Var2 = *(__crt_multibyte_data **)(param_1 + 0x88);\n  }\n  if (p_Var2 != (__crt_multibyte_data *)0x0) {\n    return p_Var2;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_140001340": "\nundefined8 * FUN_140001340(undefined8 *param_1,longlong param_2)\n\n{\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  __std_exception_copy((char **)(param_2 + 8),(char **)(param_1 + 1));\n  *param_1 = std::bad_alloc::vftable;\n  return param_1;\n}\n\n",
  "FUN_140022687": "\nvoid FUN_140022687(undefined8 param_1,longlong param_2)\n\n{\n  FUN_14000d390(*(longlong *)(param_2 + 0x40));\n  return;\n}\n\n",
  "__vcrt_FlsAlloc": "\n/* Library Function - Single Match\n    __vcrt_FlsAlloc\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __vcrt_FlsAlloc(undefined8 param_1)\n\n{\n  FARPROC pFVar1;\n  \n  pFVar1 = FUN_14000bdf8(0,\"FlsAlloc\",(uint *)&DAT_140025780,(uint *)\"FlsAlloc\");\n  if (pFVar1 != (FARPROC)0x0) {\n    (*(code *)PTR__guard_dispatch_icall_140023298)(param_1);\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x00014000bf86. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  TlsAlloc();\n  return;\n}\n\n",
  "__acrt_stdio_refill_and_read_narrow_nolock": "\n/* Library Function - Single Match\n    __acrt_stdio_refill_and_read_narrow_nolock\n   \n   Library: Visual Studio 2019 Release */\n\nulonglong __acrt_stdio_refill_and_read_narrow_nolock(FILE *param_1)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  char *_DstBuf;\n  int iVar3;\n  uint uVar4;\n  ulong *puVar5;\n  undefined *puVar6;\n  \n  if (param_1 == (FILE *)0x0) {\n    puVar5 = __doserrno();\n    *puVar5 = 0x16;\n    FUN_14000d030();\n  }\n  else if (((*(uint *)((longlong)&param_1->_base + 4) >> 0xd & 1) != 0) &&\n          ((*(uint *)((longlong)&param_1->_base + 4) >> 0xc & 1) == 0)) {\n    if ((*(uint *)((longlong)&param_1->_base + 4) >> 1 & 1) == 0) {\n      LOCK();\n      puVar1 = (uint *)((longlong)&param_1->_base + 4);\n      *puVar1 = *puVar1 | 1;\n      UNLOCK();\n      if ((*(uint *)((longlong)&param_1->_base + 4) & 0x4c0) == 0) {\n        __acrt_stdio_allocate_buffer_nolock(&param_1->_ptr);\n      }\n      _DstBuf = *(char **)&param_1->_cnt;\n      param_1->_ptr = _DstBuf;\n      iVar3 = _fileno(param_1);\n      iVar3 = _read(iVar3,_DstBuf,param_1->_charbuf);\n      *(int *)&param_1->_base = iVar3;\n      if (1 < iVar3 + 1U) {\n        if ((*(uint *)((longlong)&param_1->_base + 4) & 6) == 0) {\n          iVar3 = _fileno(param_1);\n          if ((iVar3 == -1) || (iVar3 = _fileno(param_1), iVar3 == -2)) {\n            puVar6 = &DAT_1400353d0;\n          }\n          else {\n            iVar3 = _fileno(param_1);\n            uVar4 = _fileno(param_1);\n            puVar6 = (undefined *)\n                     ((&DAT_140037490)[(longlong)iVar3 >> 6] + (ulonglong)(uVar4 & 0x3f) * 0x48);\n          }\n          if ((puVar6[0x38] & 0x82) == 0x82) {\n            LOCK();\n            puVar1 = (uint *)((longlong)&param_1->_base + 4);\n            *puVar1 = *puVar1 | 0x20;\n            UNLOCK();\n          }\n        }\n        if (((param_1->_charbuf == 0x200) &&\n            ((*(uint *)((longlong)&param_1->_base + 4) >> 6 & 1) != 0)) &&\n           ((*(uint *)((longlong)&param_1->_base + 4) >> 8 & 1) == 0)) {\n          param_1->_charbuf = 0x1000;\n        }\n        *(int *)&param_1->_base = *(int *)&param_1->_base + -1;\n        bVar2 = *param_1->_ptr;\n        param_1->_ptr = param_1->_ptr + 1;\n        return (ulonglong)bVar2;\n      }\n      LOCK();\n      puVar1 = (uint *)((longlong)&param_1->_base + 4);\n      *puVar1 = *puVar1 | (-(uint)(iVar3 != 0) & 8) + 8;\n      UNLOCK();\n      *(undefined4 *)&param_1->_base = 0;\n    }\n    else {\n      LOCK();\n      puVar1 = (uint *)((longlong)&param_1->_base + 4);\n      *puVar1 = *puVar1 | 0x10;\n      UNLOCK();\n    }\n  }\n  return 0xffffffff;\n}\n\n",
  "CatchIt<class___FrameHandler3>": "\n/* Library Function - Single Match\n    void __cdecl CatchIt<class __FrameHandler3>(struct EHExceptionRecord * __ptr64,unsigned __int64\n   * __ptr64,struct _CONTEXT * __ptr64,struct _xDISPATCHER_CONTEXT * __ptr64,struct _s_FuncInfo\n   const * __ptr64,struct _s_HandlerType const * __ptr64,struct _s_CatchableType const *\n   __ptr64,struct _s_TryBlockMapEntry const * __ptr64,int,unsigned __int64 * __ptr64,unsigned\n   char,unsigned char)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl\nCatchIt<class___FrameHandler3>\n          (EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n          _xDISPATCHER_CONTEXT *param_4,_s_FuncInfo *param_5,_s_HandlerType *param_6,\n          _s_CatchableType *param_7,_s_TryBlockMapEntry *param_8,int param_9,__uint64 *param_10,\n          uchar param_11,uchar param_12)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  __uint64 *p_Var3;\n  longlong lVar4;\n  __uint64 local_res10;\n  _CONTEXT *local_res18;\n  undefined4 in_stack_ffffffffffffffa4;\n  \n  local_res18 = param_3;\n  p_Var3 = __FrameHandler3::GetEstablisherFrame(param_2,param_4,param_5,&local_res10);\n  if (param_7 != (_s_CatchableType *)0x0) {\n    BuildCatchObjectInternal<class___FrameHandler3>(param_1,p_Var3,param_6,param_7);\n  }\n  uVar1 = *(undefined4 *)(param_8 + 8);\n  iVar2 = *(int *)param_8;\n  lVar4 = _GetImageBase();\n  FUN_1400075a4((PVOID *)param_2,(ULONG_PTR)param_1,(ULONG_PTR)local_res18,(ULONG_PTR)p_Var3,\n                lVar4 + *(int *)(param_6 + 0xc),(ULONG_PTR)param_5,iVar2,\n                CONCAT44(in_stack_ffffffffffffffa4,uVar1),param_6,(PVOID *)param_4,param_12);\n  return;\n}\n\n",
  "operator()<class_<lambda_1d892b297fdedeee07ed8124eeb2f2fa>,class_<lambda_ffc046909424fd52df0ac47e64813305>&___ptr64,class_<lambda_01a7098693036236037e7cdb9bca3d73>_>": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    public: void __cdecl __crt_seh_guarded_call<void>::operator()<class\n   <lambda_1d892b297fdedeee07ed8124eeb2f2fa>,class <lambda_ffc046909424fd52df0ac47e64813305> &\n   __ptr64,class <lambda_01a7098693036236037e7cdb9bca3d73> >(class\n   <lambda_1d892b297fdedeee07ed8124eeb2f2fa> && __ptr64,class\n   <lambda_ffc046909424fd52df0ac47e64813305> & __ptr64,class\n   <lambda_01a7098693036236037e7cdb9bca3d73> && __ptr64) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_1d892b297fdedeee07ed8124eeb2f2fa>,class_<lambda_ffc046909424fd52df0ac47e64813305>&___ptr64,class_<lambda_01a7098693036236037e7cdb9bca3d73>_>\n          (__crt_seh_guarded_call<void> *this,<lambda_1d892b297fdedeee07ed8124eeb2f2fa> *param_1,\n          <lambda_ffc046909424fd52df0ac47e64813305> *param_2,\n          <lambda_01a7098693036236037e7cdb9bca3d73> *param_3)\n\n{\n  short sVar1;\n  short sVar2;\n  longlong lVar3;\n  short *psVar4;\n  \n  __acrt_lock(*(int *)param_1);\n  FUN_140012fec((undefined4 *)**(undefined8 **)param_2,\n                *(undefined4 **)(**(longlong **)(param_2 + 8) + 0x90));\n  lVar3 = _wsetlocale_nolock(**(longlong **)param_2,**(int **)(param_2 + 0x18),\n                             **(wchar_t ***)(param_2 + 0x20));\n  **(longlong **)(param_2 + 0x10) = lVar3;\n  if (lVar3 == 0) {\n    __acrt_release_locale_ref(**(longlong **)param_2);\n    __acrt_free_locale(**(LPVOID **)param_2);\n  }\n  else {\n    psVar4 = **(short ***)(param_2 + 0x20);\n    if (psVar4 != (short *)0x0) {\n      lVar3 = (longlong)&DAT_1400353c8 - (longlong)psVar4;\n      do {\n        sVar1 = *psVar4;\n        sVar2 = *(short *)((longlong)psVar4 + lVar3);\n        if (sVar1 != sVar2) break;\n        psVar4 = psVar4 + 1;\n      } while (sVar2 != 0);\n      if (sVar1 != sVar2) {\n        LOCK();\n        DAT_140037280 = 1;\n        UNLOCK();\n      }\n    }\n    _updatetlocinfoEx_nolock\n              ((LPVOID *)(**(longlong **)(param_2 + 8) + 0x90),\n               (undefined **)**(undefined8 **)param_2);\n    __acrt_release_locale_ref(**(longlong **)param_2);\n    if (((*(byte *)(**(longlong **)(param_2 + 8) + 0x3a8) & 2) == 0) &&\n       (((byte)DAT_140035520 & 1) == 0)) {\n      _updatetlocinfoEx_nolock(&DAT_1400372c0,*(undefined ***)(**(longlong **)(param_2 + 8) + 0x90))\n      ;\n      PTR_PTR_DAT_140035228 = (undefined *)DAT_1400372c0[0x1f];\n      PTR_DAT_140035178 = (undefined *)*DAT_1400372c0;\n      _DAT_1400353cc = *(undefined4 *)(DAT_1400372c0 + 1);\n    }\n  }\n  __acrt_unlock(*(int *)param_3);\n  return;\n}\n\n",
  "__acrt_free_locale": "\n/* Library Function - Single Match\n    __acrt_free_locale\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_free_locale(LPVOID param_1)\n\n{\n  int *piVar1;\n  longlong lVar2;\n  LPVOID *ppvVar3;\n  int **ppiVar4;\n  \n  if ((((*(undefined ***)((longlong)param_1 + 0xf8) != (undefined **)0x0) &&\n       (*(undefined ***)((longlong)param_1 + 0xf8) != &PTR_DAT_140035190)) &&\n      (*(int **)((longlong)param_1 + 0xe0) != (int *)0x0)) &&\n     (**(int **)((longlong)param_1 + 0xe0) == 0)) {\n    piVar1 = *(int **)((longlong)param_1 + 0xf0);\n    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {\n      _free_base(piVar1);\n      __acrt_locale_free_monetary(*(longlong *)((longlong)param_1 + 0xf8));\n    }\n    piVar1 = *(int **)((longlong)param_1 + 0xe8);\n    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {\n      _free_base(piVar1);\n      __acrt_locale_free_numeric(*(LPVOID **)((longlong)param_1 + 0xf8));\n    }\n    _free_base(*(LPVOID *)((longlong)param_1 + 0xe0));\n    _free_base(*(LPVOID *)((longlong)param_1 + 0xf8));\n  }\n  if ((*(int **)((longlong)param_1 + 0x100) != (int *)0x0) &&\n     (**(int **)((longlong)param_1 + 0x100) == 0)) {\n    _free_base((LPVOID)(*(longlong *)((longlong)param_1 + 0x108) + -0xfe));\n    _free_base((LPVOID)(*(longlong *)((longlong)param_1 + 0x110) + -0x80));\n    _free_base((LPVOID)(*(longlong *)((longlong)param_1 + 0x118) + -0x80));\n    _free_base(*(LPVOID *)((longlong)param_1 + 0x100));\n  }\n  __acrt_locale_free_lc_time_if_unreferenced(*(undefined ***)((longlong)param_1 + 0x120));\n  ppvVar3 = (LPVOID *)((longlong)param_1 + 0x128);\n  lVar2 = 6;\n  ppiVar4 = (int **)((longlong)param_1 + 0x38);\n  do {\n    if (((ppiVar4[-2] != (int *)&DAT_1400353c8) && (piVar1 = *ppiVar4, piVar1 != (int *)0x0)) &&\n       (*piVar1 == 0)) {\n      _free_base(piVar1);\n      _free_base(*ppvVar3);\n    }\n    if (((ppiVar4[-3] != (int *)0x0) && (piVar1 = ppiVar4[-1], piVar1 != (int *)0x0)) &&\n       (*piVar1 == 0)) {\n      _free_base(piVar1);\n    }\n    ppvVar3 = ppvVar3 + 1;\n    ppiVar4 = ppiVar4 + 4;\n    lVar2 = lVar2 + -1;\n  } while (lVar2 != 0);\n  _free_base(param_1);\n  return;\n}\n\n",
  "__std_exception_copy": "\n/* Library Function - Single Match\n    __std_exception_copy\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __std_exception_copy(char **param_1,char **param_2)\n\n{\n  longlong lVar1;\n  char *_Dst;\n  longlong lVar2;\n  \n  if ((*(char *)(param_1 + 1) == '\\0') || (*param_1 == (char *)0x0)) {\n    *param_2 = *param_1;\n    *(undefined *)(param_2 + 1) = 0;\n  }\n  else {\n    lVar1 = -1;\n    do {\n      lVar2 = lVar1;\n      lVar1 = lVar2 + 1;\n    } while ((*param_1)[lVar2 + 1] != '\\0');\n    _Dst = (char *)_malloc_base(lVar2 + 2);\n    if (_Dst != (char *)0x0) {\n      strcpy_s(_Dst,lVar2 + 2,*param_1);\n      *(undefined *)(param_2 + 1) = 1;\n      *param_2 = _Dst;\n      _Dst = (char *)0x0;\n    }\n    FUN_14000ce08(_Dst);\n  }\n  return;\n}\n\n",
  "_ValidateImageBase": "\n/* Library Function - Single Match\n    _ValidateImageBase\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nBOOL __cdecl _ValidateImageBase(PBYTE pImageBase)\n\n{\n  if (((*(short *)pImageBase == 0x5a4d) &&\n      (*(int *)(pImageBase + *(int *)(pImageBase + 0x3c)) == 0x4550)) &&\n     (*(short *)((longlong)(pImageBase + *(int *)(pImageBase + 0x3c)) + 0x18) == 0x20b)) {\n    return 1;\n  }\n  return 0;\n}\n\n",
  "__acrt_execute_initializers": "\n/* Library Function - Single Match\n    __acrt_execute_initializers\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 __acrt_execute_initializers(undefined **param_1,undefined **param_2)\n\n{\n  undefined **in_RAX;\n  undefined **ppuVar1;\n  \n  ppuVar1 = param_1;\n  if (param_1 != param_2) {\n    do {\n      in_RAX = (undefined **)*ppuVar1;\n      if ((in_RAX != (undefined **)0x0) &&\n         (in_RAX = (undefined **)(*(code *)PTR__guard_dispatch_icall_140023298)(),\n         (char)in_RAX == '\\0')) break;\n      ppuVar1 = ppuVar1 + 2;\n    } while (ppuVar1 != param_2);\n    if (ppuVar1 != param_2) {\n      if (ppuVar1 != param_1) {\n        ppuVar1 = ppuVar1 + -1;\n        do {\n          if ((ppuVar1[-1] != (undefined *)0x0) && (*ppuVar1 != (undefined *)0x0)) {\n            (*(code *)PTR__guard_dispatch_icall_140023298)(0);\n          }\n          in_RAX = ppuVar1 + -1;\n          ppuVar1 = ppuVar1 + -2;\n        } while (in_RAX != param_1);\n      }\n      return (ulonglong)in_RAX & 0xffffffffffffff00;\n    }\n  }\n  return CONCAT71((int7)((ulonglong)in_RAX >> 8),1);\n}\n\n",
  "_get_initial_narrow_environment": "\n/* Library Function - Single Match\n    _get_initial_narrow_environment\n   \n   Library: Visual Studio 2019 Release */\n\nvoid _get_initial_narrow_environment(void)\n\n{\n  longlong lVar1;\n  int iVar2;\n  \n  lVar1 = DAT_140037230;\n  if (((DAT_140037230 == 0) && (lVar1 = DAT_140037218, DAT_140037218 == 0)) &&\n     ((DAT_140037220 == 0 ||\n      ((iVar2 = common_initialize_environment_nolock<char>(), lVar1 = DAT_140037218, iVar2 != 0 &&\n       (iVar2 = initialize_environment_by_cloning_nolock<char>(), lVar1 = DAT_140037218, iVar2 != 0)\n       ))))) {\n    lVar1 = 0;\n  }\n  DAT_140037230 = lVar1;\n  return;\n}\n\n",
  "FUN_140007dc8": "\nlonglong FUN_140007dc8(void)\n\n{\n  longlong lVar1;\n  \n  lVar1 = FUN_140008b20();\n  return lVar1 + 0x20;\n}\n\n",
  "_CallMemberFunction2": "\n/* Library Function - Single Match\n    void __cdecl _CallMemberFunction2(void * __ptr64 const,void * __ptr64 const,void * __ptr64\n   const,int)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl _CallMemberFunction2(void *param_1,void *param_2,void *param_3,int param_4)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00014000bb68. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)param_2)(param_1,param_3,param_4);\n  return;\n}\n\n",
  "sync": "\n/* Library Function - Single Match\n    protected: virtual int __cdecl std::basic_filebuf<char,struct std::char_traits<char>\n   >::sync(void) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nint __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::sync\n          (basic_filebuf<char,struct_std::char_traits<char>_> *this)\n\n{\n  int iVar1;\n  \n  if (((*(longlong *)(this + 0x80) != 0) &&\n      (iVar1 = (*(code *)PTR__guard_dispatch_icall_140023298)(this,0xffffffff), iVar1 != -1)) &&\n     (iVar1 = fflush(*(FILE **)(this + 0x80)), iVar1 < 0)) {\n    return -1;\n  }\n  return 0;\n}\n\n",
  "FUN_140003870": "\nundefined8 * FUN_140003870(undefined8 *param_1,char *param_2)\n\n{\n  char *local_18;\n  undefined local_10;\n  \n  local_10 = 1;\n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  local_18 = param_2;\n  __std_exception_copy(&local_18,(char **)(param_1 + 1));\n  *param_1 = std::invalid_argument::vftable;\n  return param_1;\n}\n\n",
  "FUN_140001450": "\nundefined4 * FUN_140001450(undefined4 *param_1,undefined4 param_2)\n\n{\n  *param_1 = param_2;\n  *(undefined ***)(param_1 + 2) = &PTR_vftable_140035b10;\n  return param_1;\n}\n\n",
  "FUN_140005818": "\nchar * FUN_140005818(int param_1)\n\n{\n  int *piVar1;\n  \n  piVar1 = &DAT_1400239f0;\n  do {\n    if (*piVar1 == param_1) {\n      return *(char **)(piVar1 + 2);\n    }\n    piVar1 = piVar1 + 4;\n  } while (piVar1 != (int *)\"address family not supported\");\n  return \"unknown error\";\n}\n\n",
  "__acrt_update_locale_info": "\n/* Library Function - Single Match\n    __acrt_update_locale_info\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_update_locale_info(longlong param_1,longlong *param_2)\n\n{\n  undefined **ppuVar1;\n  \n  if ((*param_2 != DAT_1400372c0) && ((DAT_140035520 & *(uint *)(param_1 + 0x3a8)) == 0)) {\n    ppuVar1 = __acrt_update_thread_locale_data();\n    *param_2 = (longlong)ppuVar1;\n  }\n  return;\n}\n\n",
  "abort": "\n/* Library Function - Single Match\n    abort\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl abort(void)\n\n{\n  code *pcVar1;\n  longlong lVar2;\n  BOOL BVar3;\n  undefined *puVar4;\n  undefined auStack_28 [8];\n  undefined auStack_20 [32];\n  \n  puVar4 = auStack_28;\n  lVar2 = __acrt_get_sigabrt_handler();\n  if (lVar2 != 0) {\n    raise(0x16);\n  }\n  if ((DAT_140035188 & 2) != 0) {\n    BVar3 = IsProcessorFeaturePresent(0x17);\n    puVar4 = auStack_28;\n    if (BVar3 != 0) {\n      pcVar1 = (code *)swi(0x29);\n      (*pcVar1)(7);\n      puVar4 = auStack_20;\n    }\n    *(undefined8 *)(puVar4 + -8) = 0x14000f21f;\n    __acrt_call_reportfault(3,0x40000015,1);\n  }\n  *(undefined8 *)(puVar4 + -8) = 0x14000f229;\n  FUN_140012908(3);\n  pcVar1 = (code *)swi(3);\n  (*pcVar1)();\n  return;\n}\n\n",
  "CatchIt<class___FrameHandler4>": "\n/* Library Function - Single Match\n    void __cdecl CatchIt<class __FrameHandler4>(struct EHExceptionRecord * __ptr64,unsigned __int64\n   * __ptr64,struct _CONTEXT * __ptr64,struct _xDISPATCHER_CONTEXT * __ptr64,struct FH4::FuncInfo4 *\n   __ptr64,struct FH4::HandlerType4 * __ptr64,struct _s_CatchableType const * __ptr64,struct\n   FH4::TryBlockMapEntry4 * __ptr64,int,unsigned __int64 * __ptr64,unsigned char,unsigned char)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl\nCatchIt<class___FrameHandler4>\n          (EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n          _xDISPATCHER_CONTEXT *param_4,FuncInfo4 *param_5,HandlerType4 *param_6,\n          _s_CatchableType *param_7,TryBlockMapEntry4 *param_8,int param_9,__uint64 *param_10,\n          uchar param_11,uchar param_12)\n\n{\n  int iVar1;\n  int iVar2;\n  __uint64 *p_Var3;\n  longlong lVar4;\n  __uint64 local_res10;\n  _CONTEXT *local_res18;\n  \n  local_res18 = param_3;\n  p_Var3 = __FrameHandler4::GetEstablisherFrame(param_2,param_4,param_5,&local_res10);\n  if (param_7 != (_s_CatchableType *)0x0) {\n    BuildCatchObjectInternal<class___FrameHandler4>(param_1,p_Var3,param_6,param_7);\n  }\n  iVar1 = *(int *)(param_8 + 8);\n  iVar2 = *(int *)param_8;\n  lVar4 = _GetImageBase();\n  FUN_1400076a8((PVOID *)param_2,(ULONG_PTR)param_1,(ULONG_PTR)local_res18,(ULONG_PTR)p_Var3,\n                lVar4 + *(int *)(param_6 + 0x10),param_5,iVar2,iVar1,(longlong)param_6,\n                (PVOID *)param_4,param_12);\n  return;\n}\n\n",
  "FUN_140001d40": "\nlonglong FUN_140001d40(undefined8 param_1,undefined8 *param_2,longlong param_3,undefined8 param_4,\n                      undefined8 *param_5)\n\n{\n  FUN_140007ed0(param_5,param_2,param_3 - (longlong)param_2);\n  return param_3;\n}\n\n",
  "__lc_lctowcs": "\n/* Library Function - Single Match\n    __lc_lctowcs\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __lc_lctowcs(wchar_t *param_1,rsize_t param_2,wchar_t *param_3)\n\n{\n  errno_t eVar1;\n  \n  eVar1 = wcscpy_s(param_1,param_2,param_3);\n  if (eVar1 == 0) {\n    if (param_3[0x40] != L'\\0') {\n      _wcscats(param_1,param_2,2,&DAT_1400280e8);\n    }\n    if (param_3[0x80] != L'\\0') {\n      _wcscats(param_1,param_2,2,&DAT_1400280ec);\n    }\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n\n",
  "FID_conflict:fallbackMethod": "\n/* Library Function - Multiple Matches With Different Base Names\n    fallbackMethod\n    strpbrk\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nchar * __cdecl FID_conflict_fallbackMethod(char *_Str,char *_Control)\n\n{\n  code *pcVar1;\n  byte bVar2;\n  ulonglong uVar3;\n  char *pcVar4;\n  undefined auStack_58 [32];\n  byte abStack_38 [32];\n  ulonglong local_18;\n  \n  local_18 = DAT_140035020 ^ (ulonglong)auStack_58;\n  uVar3 = 0;\n  do {\n    if (0x1f < uVar3) {\n      __report_rangecheckfailure();\n      pcVar1 = (code *)swi(3);\n      pcVar4 = (char *)(*pcVar1)();\n      return pcVar4;\n    }\n    abStack_38[uVar3] = 0;\n    uVar3 = uVar3 + 1;\n  } while ((longlong)uVar3 < 0x20);\n  bVar2 = *_Control;\n  while (bVar2 != 0) {\n    _Control = (char *)((byte *)_Control + 1);\n    abStack_38[bVar2 >> 3] = abStack_38[bVar2 >> 3] | (byte)(1 << (bVar2 & 7));\n    bVar2 = *_Control;\n  }\n  while ((bVar2 = *_Str, bVar2 != 0 && ((abStack_38[bVar2 >> 3] & (byte)(1 << (bVar2 & 7))) == 0)))\n  {\n    _Str = (char *)((byte *)_Str + 1);\n  }\n  pcVar4 = (char *)FUN_140006060(local_18 ^ (ulonglong)auStack_58);\n  return pcVar4;\n}\n\n",
  "__acrt_get_sigabrt_handler": "\n/* Library Function - Single Match\n    __acrt_get_sigabrt_handler\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_get_sigabrt_handler(void)\n\n{\n  undefined local_res8 [8];\n  int local_res10 [2];\n  int local_res18 [4];\n  \n  local_res10[0] = 3;\n  local_res18[0] = 3;\n  operator()<>(local_res8,local_res18,local_res8,local_res10);\n  return;\n}\n\n",
  "__vcrt_FlsGetValue": "\n/* Library Function - Single Match\n    __vcrt_FlsGetValue\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __vcrt_FlsGetValue(undefined4 param_1)\n\n{\n  FARPROC pFVar1;\n  \n  pFVar1 = FUN_14000bdf8(2,\"FlsGetValue\",(uint *)&DAT_1400257a8,(uint *)\"FlsGetValue\");\n  if (pFVar1 != (FARPROC)0x0) {\n    (*(code *)PTR__guard_dispatch_icall_140023298)();\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x00014000c017. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  TlsGetValue(param_1);\n  return;\n}\n\n",
  "underflow": "\n/* Library Function - Single Match\n    protected: virtual int __cdecl std::basic_filebuf<char,struct std::char_traits<char>\n   >::underflow(void) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::underflow\n          (basic_filebuf<char,struct_std::char_traits<char>_> *this)\n\n{\n  byte *pbVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  pbVar1 = **(byte ***)(this + 0x38);\n  if ((pbVar1 == (byte *)0x0) || (pbVar1 + **(int **)(this + 0x50) <= pbVar1)) {\n    uVar2 = (*(code *)PTR__guard_dispatch_icall_140023298)();\n    uVar3 = 0xffffffff;\n    if (uVar2 != 0xffffffff) {\n      (*(code *)PTR__guard_dispatch_icall_140023298)(this,uVar2);\n      uVar3 = uVar2;\n    }\n  }\n  else {\n    uVar3 = (uint)*pbVar1;\n  }\n  return uVar3;\n}\n\n",
  "__acrt_lock": "\n/* Library Function - Multiple Matches With Different Base Names\n    __acrt_lock\n    __acrt_unlock\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_lock(int param_1)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00014000d122. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  EnterCriticalSection((LPCRITICAL_SECTION)(&DAT_140036ea0 + (longlong)param_1 * 0x28));\n  return;\n}\n\n",
  "_putwch_nolock": "\n/* Library Function - Single Match\n    _putwch_nolock\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nwint_t __cdecl _putwch_nolock(wchar_t _WCh)\n\n{\n  bool bVar1;\n  BOOL BVar2;\n  undefined7 extraout_var;\n  wchar_t local_res8 [4];\n  DWORD local_res10 [6];\n  \n  local_res8[0] = _WCh;\n  bVar1 = __dcrt_lowio_ensure_console_output_initialized();\n  if (((int)CONCAT71(extraout_var,bVar1) == 0) ||\n     (BVar2 = __dcrt_write_console(local_res8,1,local_res10), BVar2 == 0)) {\n    local_res8[0] = L'\\xffff';\n  }\n  return local_res8[0];\n}\n\n",
  "FUN_140004830": "\nundefined8 FUN_140004830(void)\n\n{\n  return 0xffffffff;\n}\n\n",
  "GetStringTypeW": "\nBOOL __stdcall GetStringTypeW(DWORD dwInfoType,LPCWSTR lpSrcStr,int cchSrc,LPWORD lpCharType)\n\n{\n  BOOL BVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00014001f098. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  BVar1 = GetStringTypeW(dwInfoType,lpSrcStr,cchSrc,lpCharType);\n  return BVar1;\n}\n\n",
  "GetHandlerSearchState": "\n/* Library Function - Single Match\n    public: static int __cdecl __FrameHandler3::GetHandlerSearchState(unsigned __int64 *\n   __ptr64,struct _xDISPATCHER_CONTEXT * __ptr64,struct _s_FuncInfo const * __ptr64)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl\n__FrameHandler3::GetHandlerSearchState\n          (__uint64 *param_1,_xDISPATCHER_CONTEXT *param_2,_s_FuncInfo *param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  __uint64 local_res20;\n  \n  iVar1 = FUN_140008d54((longlong)param_3,(ulonglong *)param_2);\n  GetEstablisherFrame(param_1,param_2,param_3,&local_res20);\n  iVar2 = GetUnwindTryBlock(param_1,param_2,param_3);\n  if (iVar2 < iVar1) {\n    SetState(&local_res20,param_3,iVar1);\n    SetUnwindTryBlock(param_1,param_2,param_3,iVar1);\n  }\n  else {\n    iVar1 = GetUnwindTryBlock(param_1,param_2,param_3);\n  }\n  return iVar1;\n}\n\n",
  "_updatetlocinfoEx_nolock": "\n/* Library Function - Single Match\n    _updatetlocinfoEx_nolock\n   \n   Library: Visual Studio 2019 Release */\n\nundefined ** _updatetlocinfoEx_nolock(LPVOID *param_1,undefined **param_2)\n\n{\n  undefined **ppuVar1;\n  \n  if ((param_2 == (undefined **)0x0) || (param_1 == (LPVOID *)0x0)) {\n    param_2 = (undefined **)0x0;\n  }\n  else {\n    ppuVar1 = (undefined **)*param_1;\n    if (ppuVar1 != param_2) {\n      *param_1 = param_2;\n      __acrt_add_locale_ref((longlong)param_2);\n      if (((ppuVar1 != (undefined **)0x0) &&\n          (__acrt_release_locale_ref((longlong)ppuVar1), *(int *)(ppuVar1 + 2) == 0)) &&\n         (ppuVar1 != &PTR_DAT_140035260)) {\n        __acrt_free_locale(ppuVar1);\n      }\n    }\n  }\n  return param_2;\n}\n\n",
  "parse_command_line<char>": "\n/* Library Function - Single Match\n    void __cdecl parse_command_line<char>(char * __ptr64,char * __ptr64 * __ptr64,char *\n   __ptr64,unsigned __int64 * __ptr64,unsigned __int64 * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl\nparse_command_line<char>\n          (char *param_1,char **param_2,char *param_3,__uint64 *param_4,__uint64 *param_5)\n\n{\n  bool bVar1;\n  bool bVar2;\n  char cVar3;\n  uint uVar4;\n  int iVar5;\n  char *pcVar6;\n  char *pcVar7;\n  \n  *param_5 = 0;\n  *param_4 = 1;\n  if (param_2 != (char **)0x0) {\n    *param_2 = param_3;\n    param_2 = param_2 + 1;\n  }\n  bVar2 = false;\n  do {\n    if (*param_1 == '\\\"') {\n      bVar2 = !bVar2;\n      cVar3 = '\\\"';\n      pcVar6 = param_1 + 1;\n    }\n    else {\n      *param_5 = *param_5 + 1;\n      if (param_3 != (char *)0x0) {\n        *param_3 = *param_1;\n        param_3 = param_3 + 1;\n      }\n      cVar3 = *param_1;\n      pcVar6 = param_1 + 1;\n      iVar5 = _ismbblead((int)cVar3);\n      if (iVar5 != 0) {\n        *param_5 = *param_5 + 1;\n        if (param_3 != (char *)0x0) {\n          *param_3 = *pcVar6;\n          param_3 = param_3 + 1;\n        }\n        pcVar6 = param_1 + 2;\n      }\n      if (cVar3 == '\\0') {\n        pcVar6 = pcVar6 + -1;\n        goto LAB_140011f46;\n      }\n    }\n    param_1 = pcVar6;\n  } while ((bVar2) || ((cVar3 != ' ' && (cVar3 != '\\t'))));\n  if (param_3 != (char *)0x0) {\n    param_3[-1] = '\\0';\n  }\nLAB_140011f46:\n  bVar2 = false;\n  while (cVar3 = *pcVar6, pcVar7 = pcVar6, cVar3 != '\\0') {\n    while ((cVar3 == ' ' || (cVar3 == '\\t'))) {\n      pcVar7 = pcVar7 + 1;\n      cVar3 = *pcVar7;\n    }\n    if (cVar3 == '\\0') break;\n    if (param_2 != (char **)0x0) {\n      *param_2 = param_3;\n      param_2 = param_2 + 1;\n    }\n    *param_4 = *param_4 + 1;\n    while( true ) {\n      bVar1 = true;\n      uVar4 = 0;\n      for (; *pcVar7 == '\\\\'; pcVar7 = pcVar7 + 1) {\n        uVar4 = uVar4 + 1;\n      }\n      pcVar6 = pcVar7;\n      if (*pcVar7 == '\\\"') {\n        if (((uVar4 & 1) == 0) && ((!bVar2 || (pcVar6 = pcVar7 + 1, *pcVar6 != '\\\"')))) {\n          bVar1 = false;\n          bVar2 = !bVar2;\n          pcVar6 = pcVar7;\n        }\n        uVar4 = uVar4 >> 1;\n      }\n      while (uVar4 != 0) {\n        uVar4 = uVar4 - 1;\n        if (param_3 != (char *)0x0) {\n          *param_3 = '\\\\';\n          param_3 = param_3 + 1;\n        }\n        *param_5 = *param_5 + 1;\n      }\n      cVar3 = *pcVar6;\n      if ((cVar3 == '\\0') || ((!bVar2 && ((cVar3 == ' ' || (cVar3 == '\\t')))))) break;\n      if (bVar1) {\n        if (param_3 != (char *)0x0) {\n          *param_3 = cVar3;\n          param_3 = param_3 + 1;\n          cVar3 = *pcVar6;\n        }\n        iVar5 = _ismbblead((int)cVar3);\n        if (iVar5 != 0) {\n          *param_5 = *param_5 + 1;\n          pcVar6 = pcVar6 + 1;\n          if (param_3 != (char *)0x0) {\n            *param_3 = *pcVar6;\n            param_3 = param_3 + 1;\n          }\n        }\n        *param_5 = *param_5 + 1;\n      }\n      pcVar7 = pcVar6 + 1;\n    }\n    if (param_3 != (char *)0x0) {\n      *param_3 = '\\0';\n      param_3 = param_3 + 1;\n    }\n    *param_5 = *param_5 + 1;\n  }\n  if (param_2 != (char **)0x0) {\n    *param_2 = (char *)0x0;\n  }\n  *param_4 = *param_4 + 1;\n  return;\n}\n\n",
  "_wcscats": "\n/* Library Function - Single Match\n    _wcscats\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _wcscats(wchar_t *param_1,rsize_t param_2,int param_3,undefined8 param_4)\n\n{\n  errno_t eVar1;\n  int iVar2;\n  wchar_t **ppwVar3;\n  int local_res18 [2];\n  wchar_t *local_res20;\n  \n  if (0 < param_3) {\n    local_res20 = (wchar_t *)param_4;\n    iVar2 = 0;\n    ppwVar3 = (wchar_t **)local_res18;\n    local_res18[0] = param_3;\n    do {\n      ppwVar3 = ppwVar3 + 1;\n      eVar1 = wcscat_s(param_1,param_2,*ppwVar3);\n      if (eVar1 != 0) {\n                    /* WARNING: Subroutine does not return */\n        _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n      }\n      iVar2 = iVar2 + 1;\n    } while (iVar2 < local_res18[0]);\n  }\n  return;\n}\n\n",
  "FUN_140007ed0": "\nundefined8 * FUN_140007ed0(undefined8 *param_1,undefined8 *param_2,ulonglong param_3)\n\n{\n  undefined auVar1 [16];\n  undefined auVar2 [16];\n  undefined auVar3 [32];\n  undefined auVar4 [32];\n  undefined auVar5 [32];\n  undefined auVar6 [32];\n  undefined uVar7;\n  undefined2 uVar8;\n  undefined4 uVar9;\n  undefined8 uVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  undefined8 uVar13;\n  undefined4 uVar14;\n  undefined4 uVar15;\n  undefined4 uVar16;\n  undefined4 uVar17;\n  undefined4 uVar18;\n  undefined4 uVar19;\n  undefined4 uVar20;\n  undefined4 uVar21;\n  undefined4 uVar22;\n  undefined4 uVar23;\n  undefined4 uVar24;\n  undefined4 uVar25;\n  undefined4 uVar26;\n  undefined4 uVar27;\n  undefined4 uVar28;\n  undefined4 uVar29;\n  undefined4 uVar30;\n  undefined4 uVar31;\n  undefined4 uVar32;\n  undefined4 uVar33;\n  undefined4 uVar34;\n  undefined4 uVar35;\n  undefined4 uVar36;\n  undefined4 uVar37;\n  undefined4 uVar38;\n  undefined4 uVar39;\n  undefined4 uVar40;\n  undefined4 uVar41;\n  undefined4 uVar42;\n  undefined4 uVar43;\n  undefined8 *puVar44;\n  undefined (*pauVar45) [32];\n  undefined (*pauVar46) [32];\n  undefined4 *puVar47;\n  undefined (*pauVar48) [16];\n  undefined (*pauVar49) [16];\n  undefined (*pauVar50) [32];\n  undefined (*pauVar51) [32];\n  undefined4 *puVar52;\n  ulonglong uVar53;\n  longlong lVar54;\n  ulonglong uVar55;\n  undefined auVar56 [16];\n  \n  puVar44 = param_1;\n  switch(param_3) {\n  case 0:\n    return puVar44;\n  case 1:\n    *(undefined *)param_1 = *(undefined *)param_2;\n    return puVar44;\n  case 2:\n    *(undefined2 *)param_1 = *(undefined2 *)param_2;\n    return puVar44;\n  case 3:\n    uVar7 = *(undefined *)((longlong)param_2 + 2);\n    *(undefined2 *)param_1 = *(undefined2 *)param_2;\n    *(undefined *)((longlong)param_1 + 2) = uVar7;\n    return puVar44;\n  case 4:\n    *(undefined4 *)param_1 = *(undefined4 *)param_2;\n    return puVar44;\n  case 5:\n    uVar7 = *(undefined *)((longlong)param_2 + 4);\n    *(undefined4 *)param_1 = *(undefined4 *)param_2;\n    *(undefined *)((longlong)param_1 + 4) = uVar7;\n    return puVar44;\n  case 6:\n    uVar8 = *(undefined2 *)((longlong)param_2 + 4);\n    *(undefined4 *)param_1 = *(undefined4 *)param_2;\n    *(undefined2 *)((longlong)param_1 + 4) = uVar8;\n    return puVar44;\n  case 7:\n    uVar8 = *(undefined2 *)((longlong)param_2 + 4);\n    uVar7 = *(undefined *)((longlong)param_2 + 6);\n    *(undefined4 *)param_1 = *(undefined4 *)param_2;\n    *(undefined2 *)((longlong)param_1 + 4) = uVar8;\n    *(undefined *)((longlong)param_1 + 6) = uVar7;\n    return puVar44;\n  case 8:\n    *param_1 = *param_2;\n    return puVar44;\n  case 9:\n    uVar7 = *(undefined *)(param_2 + 1);\n    *param_1 = *param_2;\n    *(undefined *)(param_1 + 1) = uVar7;\n    return puVar44;\n  case 10:\n    uVar8 = *(undefined2 *)(param_2 + 1);\n    *param_1 = *param_2;\n    *(undefined2 *)(param_1 + 1) = uVar8;\n    return puVar44;\n  case 0xb:\n    uVar8 = *(undefined2 *)(param_2 + 1);\n    uVar7 = *(undefined *)((longlong)param_2 + 10);\n    *param_1 = *param_2;\n    *(undefined2 *)(param_1 + 1) = uVar8;\n    *(undefined *)((longlong)param_1 + 10) = uVar7;\n    return puVar44;\n  case 0xc:\n    uVar9 = *(undefined4 *)(param_2 + 1);\n    *param_1 = *param_2;\n    *(undefined4 *)(param_1 + 1) = uVar9;\n    return puVar44;\n  case 0xd:\n    uVar9 = *(undefined4 *)(param_2 + 1);\n    uVar7 = *(undefined *)((longlong)param_2 + 0xc);\n    *param_1 = *param_2;\n    *(undefined4 *)(param_1 + 1) = uVar9;\n    *(undefined *)((longlong)param_1 + 0xc) = uVar7;\n    return puVar44;\n  case 0xe:\n    uVar9 = *(undefined4 *)(param_2 + 1);\n    uVar8 = *(undefined2 *)((longlong)param_2 + 0xc);\n    *param_1 = *param_2;\n    *(undefined4 *)(param_1 + 1) = uVar9;\n    *(undefined2 *)((longlong)param_1 + 0xc) = uVar8;\n    return puVar44;\n  case 0xf:\n    uVar9 = *(undefined4 *)(param_2 + 1);\n    uVar8 = *(undefined2 *)((longlong)param_2 + 0xc);\n    uVar7 = *(undefined *)((longlong)param_2 + 0xe);\n    *param_1 = *param_2;\n    *(undefined4 *)(param_1 + 1) = uVar9;\n    *(undefined2 *)((longlong)param_1 + 0xc) = uVar8;\n    *(undefined *)((longlong)param_1 + 0xe) = uVar7;\n    return puVar44;\n  }\n  if (param_3 < 0x21) {\n    uVar9 = *(undefined4 *)((longlong)param_2 + 4);\n    uVar14 = *(undefined4 *)(param_2 + 1);\n    uVar15 = *(undefined4 *)((longlong)param_2 + 0xc);\n    puVar47 = (undefined4 *)((longlong)param_2 + (param_3 - 0x10));\n    uVar16 = *puVar47;\n    uVar17 = puVar47[1];\n    uVar18 = puVar47[2];\n    uVar19 = puVar47[3];\n    *(undefined4 *)param_1 = *(undefined4 *)param_2;\n    *(undefined4 *)((longlong)param_1 + 4) = uVar9;\n    *(undefined4 *)(param_1 + 1) = uVar14;\n    *(undefined4 *)((longlong)param_1 + 0xc) = uVar15;\n    puVar47 = (undefined4 *)((longlong)param_1 + (param_3 - 0x10));\n    *puVar47 = uVar16;\n    puVar47[1] = uVar17;\n    puVar47[2] = uVar18;\n    puVar47[3] = uVar19;\n    return puVar44;\n  }\n  if ((param_2 < param_1) && (param_1 < (undefined8 *)((longlong)param_2 + param_3))) {\n    lVar54 = (longlong)param_2 - (longlong)param_1;\n    auVar1 = *(undefined (*) [16])((longlong)param_1 + lVar54 + (param_3 - 0x10));\n    pauVar48 = (undefined (*) [16])((longlong)param_1 + (param_3 - 0x10));\n    uVar53 = param_3 - 0x10;\n    pauVar49 = pauVar48;\n    auVar56 = auVar1;\n    if (((ulonglong)pauVar48 & 0xf) != 0) {\n      pauVar49 = (undefined (*) [16])((ulonglong)pauVar48 & 0xfffffffffffffff0);\n      auVar56 = *(undefined (*) [16])((longlong)pauVar49 + lVar54);\n      *pauVar48 = auVar1;\n      uVar53 = (longlong)pauVar49 - (longlong)param_1;\n    }\n    uVar55 = uVar53 >> 7;\n    if (uVar55 != 0) {\n      *pauVar49 = auVar56;\n      pauVar48 = pauVar49;\n      while( true ) {\n        puVar47 = (undefined4 *)((longlong)pauVar48 + lVar54 + -0x10);\n        uVar9 = puVar47[1];\n        uVar14 = puVar47[2];\n        uVar15 = puVar47[3];\n        puVar52 = (undefined4 *)((longlong)pauVar48 + lVar54 + -0x20);\n        uVar16 = *puVar52;\n        uVar17 = puVar52[1];\n        uVar18 = puVar52[2];\n        uVar19 = puVar52[3];\n        pauVar49 = pauVar48 + -8;\n        *(undefined4 *)pauVar48[-1] = *puVar47;\n        *(undefined4 *)(pauVar48[-1] + 4) = uVar9;\n        *(undefined4 *)(pauVar48[-1] + 8) = uVar14;\n        *(undefined4 *)(pauVar48[-1] + 0xc) = uVar15;\n        *(undefined4 *)pauVar48[-2] = uVar16;\n        *(undefined4 *)(pauVar48[-2] + 4) = uVar17;\n        *(undefined4 *)(pauVar48[-2] + 8) = uVar18;\n        *(undefined4 *)(pauVar48[-2] + 0xc) = uVar19;\n        puVar47 = (undefined4 *)((longlong)pauVar48 + lVar54 + -0x30);\n        uVar9 = puVar47[1];\n        uVar14 = puVar47[2];\n        uVar15 = puVar47[3];\n        puVar52 = (undefined4 *)((longlong)pauVar48 + lVar54 + -0x40);\n        uVar16 = *puVar52;\n        uVar17 = puVar52[1];\n        uVar18 = puVar52[2];\n        uVar19 = puVar52[3];\n        uVar55 = uVar55 - 1;\n        *(undefined4 *)pauVar48[-3] = *puVar47;\n        *(undefined4 *)(pauVar48[-3] + 4) = uVar9;\n        *(undefined4 *)(pauVar48[-3] + 8) = uVar14;\n        *(undefined4 *)(pauVar48[-3] + 0xc) = uVar15;\n        *(undefined4 *)pauVar48[-4] = uVar16;\n        *(undefined4 *)(pauVar48[-4] + 4) = uVar17;\n        *(undefined4 *)(pauVar48[-4] + 8) = uVar18;\n        *(undefined4 *)(pauVar48[-4] + 0xc) = uVar19;\n        puVar47 = (undefined4 *)((longlong)pauVar48 + lVar54 + -0x50);\n        uVar9 = puVar47[1];\n        uVar14 = puVar47[2];\n        uVar15 = puVar47[3];\n        puVar52 = (undefined4 *)((longlong)pauVar48 + lVar54 + -0x60);\n        uVar16 = *puVar52;\n        uVar17 = puVar52[1];\n        uVar18 = puVar52[2];\n        uVar19 = puVar52[3];\n        *(undefined4 *)pauVar48[-5] = *puVar47;\n        *(undefined4 *)(pauVar48[-5] + 4) = uVar9;\n        *(undefined4 *)(pauVar48[-5] + 8) = uVar14;\n        *(undefined4 *)(pauVar48[-5] + 0xc) = uVar15;\n        *(undefined4 *)pauVar48[-6] = uVar16;\n        *(undefined4 *)(pauVar48[-6] + 4) = uVar17;\n        *(undefined4 *)(pauVar48[-6] + 8) = uVar18;\n        *(undefined4 *)(pauVar48[-6] + 0xc) = uVar19;\n        puVar47 = (undefined4 *)((longlong)pauVar48 + lVar54 + -0x70);\n        uVar9 = puVar47[1];\n        uVar14 = puVar47[2];\n        uVar15 = puVar47[3];\n        auVar56 = *(undefined (*) [16])((longlong)pauVar49 + lVar54);\n        if (uVar55 == 0) break;\n        *(undefined4 *)pauVar48[-7] = *puVar47;\n        *(undefined4 *)(pauVar48[-7] + 4) = uVar9;\n        *(undefined4 *)(pauVar48[-7] + 8) = uVar14;\n        *(undefined4 *)(pauVar48[-7] + 0xc) = uVar15;\n        *pauVar49 = auVar56;\n        pauVar48 = pauVar49;\n      }\n      *(undefined4 *)pauVar48[-7] = *puVar47;\n      *(undefined4 *)(pauVar48[-7] + 4) = uVar9;\n      *(undefined4 *)(pauVar48[-7] + 8) = uVar14;\n      *(undefined4 *)(pauVar48[-7] + 0xc) = uVar15;\n      uVar53 = uVar53 & 0x7f;\n    }\n    for (uVar55 = uVar53 >> 4; uVar55 != 0; uVar55 = uVar55 - 1) {\n      *pauVar49 = auVar56;\n      pauVar49 = pauVar49 + -1;\n      auVar56 = *(undefined (*) [16])((longlong)pauVar49 + lVar54);\n    }\n    if ((uVar53 & 0xf) != 0) {\n      uVar9 = *(undefined4 *)((longlong)param_2 + 4);\n      uVar14 = *(undefined4 *)(param_2 + 1);\n      uVar15 = *(undefined4 *)((longlong)param_2 + 0xc);\n      *(undefined4 *)param_1 = *(undefined4 *)param_2;\n      *(undefined4 *)((longlong)param_1 + 4) = uVar9;\n      *(undefined4 *)(param_1 + 1) = uVar14;\n      *(undefined4 *)((longlong)param_1 + 0xc) = uVar15;\n    }\n    *pauVar49 = auVar56;\n    return param_1;\n  }\n  if (DAT_140035038 < 3) {\n    if ((param_3 < 0x801) || (((byte)DAT_140036d1c & 2) == 0)) {\n      if (0x80 < param_3) {\n        lVar54 = ((ulonglong)param_1 & 0xf) - 0x10;\n        puVar47 = (undefined4 *)((longlong)param_1 - lVar54);\n        puVar52 = (undefined4 *)((longlong)param_2 - lVar54);\n        param_3 = param_3 + lVar54;\n        if (0x80 < param_3) {\n          do {\n            uVar9 = puVar52[1];\n            uVar14 = puVar52[2];\n            uVar15 = puVar52[3];\n            uVar16 = puVar52[4];\n            uVar17 = puVar52[5];\n            uVar18 = puVar52[6];\n            uVar19 = puVar52[7];\n            uVar20 = puVar52[8];\n            uVar21 = puVar52[9];\n            uVar22 = puVar52[10];\n            uVar23 = puVar52[0xb];\n            uVar24 = puVar52[0xc];\n            uVar25 = puVar52[0xd];\n            uVar26 = puVar52[0xe];\n            uVar27 = puVar52[0xf];\n            *puVar47 = *puVar52;\n            puVar47[1] = uVar9;\n            puVar47[2] = uVar14;\n            puVar47[3] = uVar15;\n            puVar47[4] = uVar16;\n            puVar47[5] = uVar17;\n            puVar47[6] = uVar18;\n            puVar47[7] = uVar19;\n            puVar47[8] = uVar20;\n            puVar47[9] = uVar21;\n            puVar47[10] = uVar22;\n            puVar47[0xb] = uVar23;\n            puVar47[0xc] = uVar24;\n            puVar47[0xd] = uVar25;\n            puVar47[0xe] = uVar26;\n            puVar47[0xf] = uVar27;\n            auVar1 = *(undefined (*) [16])(puVar52 + 0x14);\n            auVar56 = *(undefined (*) [16])(puVar52 + 0x18);\n            auVar2 = *(undefined (*) [16])(puVar52 + 0x1c);\n            *(undefined (*) [16])(puVar47 + 0x10) = *(undefined (*) [16])(puVar52 + 0x10);\n            *(undefined (*) [16])(puVar47 + 0x14) = auVar1;\n            *(undefined (*) [16])(puVar47 + 0x18) = auVar56;\n            *(undefined (*) [16])(puVar47 + 0x1c) = auVar2;\n            puVar47 = puVar47 + 0x20;\n            puVar52 = puVar52 + 0x20;\n            param_3 = param_3 - 0x80;\n          } while (0x7f < param_3);\n        }\n      }\n                    /* WARNING: Could not recover jumptable at 0x0001400083e6. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      puVar44 = (undefined8 *)\n                (*(code *)(IMAGE_DOS_HEADER_140000000.e_magic +\n                          *(uint *)(&DAT_14003a088 + (param_3 + 0xf >> 4) * 4)))();\n      return puVar44;\n    }\n  }\n  else if (((param_3 < 0x2001) || (0x180000 < param_3)) || (((byte)DAT_140036d1c & 2) == 0)) {\n    uVar10 = *param_2;\n    uVar11 = param_2[1];\n    uVar12 = param_2[2];\n    uVar13 = param_2[3];\n    puVar47 = (undefined4 *)((longlong)param_2 + (param_3 - 0x20));\n    uVar9 = *puVar47;\n    uVar14 = puVar47[1];\n    uVar15 = puVar47[2];\n    uVar16 = puVar47[3];\n    uVar17 = puVar47[4];\n    uVar18 = puVar47[5];\n    uVar19 = puVar47[6];\n    uVar20 = puVar47[7];\n    if (0x100 < param_3) {\n      lVar54 = ((ulonglong)param_1 & 0x1f) - 0x20;\n      pauVar45 = (undefined (*) [32])((longlong)param_1 - lVar54);\n      pauVar50 = (undefined (*) [32])((longlong)param_2 - lVar54);\n      param_3 = param_3 + lVar54;\n      if (0x100 < param_3) {\n        if (0x180000 < param_3) {\n          do {\n            uVar53 = param_3;\n            pauVar51 = pauVar50;\n            pauVar46 = pauVar45;\n            auVar3 = pauVar51[1];\n            auVar4 = pauVar51[2];\n            auVar5 = pauVar51[3];\n            auVar6 = vmovntdq_avx(*pauVar51);\n            *pauVar46 = auVar6;\n            auVar3 = vmovntdq_avx(auVar3);\n            pauVar46[1] = auVar3;\n            auVar3 = vmovntdq_avx(auVar4);\n            pauVar46[2] = auVar3;\n            auVar3 = vmovntdq_avx(auVar5);\n            pauVar46[3] = auVar3;\n            auVar3 = pauVar51[5];\n            auVar4 = pauVar51[6];\n            auVar5 = pauVar51[7];\n            auVar6 = vmovntdq_avx(pauVar51[4]);\n            pauVar46[4] = auVar6;\n            auVar3 = vmovntdq_avx(auVar3);\n            pauVar46[5] = auVar3;\n            auVar3 = vmovntdq_avx(auVar4);\n            pauVar46[6] = auVar3;\n            auVar3 = vmovntdq_avx(auVar5);\n            pauVar46[7] = auVar3;\n            pauVar45 = pauVar46 + 8;\n            pauVar50 = pauVar51 + 8;\n            param_3 = uVar53 - 0x100;\n          } while (0xff < uVar53 - 0x100);\n          uVar55 = uVar53 - 0xe1 & 0xffffffffffffffe0;\n          switch(uVar53) {\n          case 0x1e1:\n          case 0x1e2:\n          case 0x1e3:\n          case 0x1e4:\n          case 0x1e5:\n          case 0x1e6:\n          case 0x1e7:\n          case 0x1e8:\n          case 0x1e9:\n          case 0x1ea:\n          case 0x1eb:\n          case 0x1ec:\n          case 0x1ed:\n          case 0x1ee:\n          case 0x1ef:\n          case 0x1f0:\n          case 0x1f1:\n          case 0x1f2:\n          case 499:\n          case 500:\n          case 0x1f5:\n          case 0x1f6:\n          case 0x1f7:\n          case 0x1f8:\n          case 0x1f9:\n          case 0x1fa:\n          case 0x1fb:\n          case 0x1fc:\n          case 0x1fd:\n          case 0x1fe:\n          case 0x1ff:\n            auVar3 = vmovntdq_avx(*(undefined (*) [32])(*pauVar51 + uVar55));\n            *(undefined (*) [32])(*pauVar46 + uVar55) = auVar3;\n          case 0x1c1:\n          case 0x1c2:\n          case 0x1c3:\n          case 0x1c4:\n          case 0x1c5:\n          case 0x1c6:\n          case 0x1c7:\n          case 0x1c8:\n          case 0x1c9:\n          case 0x1ca:\n          case 0x1cb:\n          case 0x1cc:\n          case 0x1cd:\n          case 0x1ce:\n          case 0x1cf:\n          case 0x1d0:\n          case 0x1d1:\n          case 0x1d2:\n          case 0x1d3:\n          case 0x1d4:\n          case 0x1d5:\n          case 0x1d6:\n          case 0x1d7:\n          case 0x1d8:\n          case 0x1d9:\n          case 0x1da:\n          case 0x1db:\n          case 0x1dc:\n          case 0x1dd:\n          case 0x1de:\n          case 0x1df:\n          case 0x1e0:\n            auVar3 = vmovntdq_avx(*(undefined (*) [32])(pauVar51[1] + uVar55));\n            *(undefined (*) [32])(pauVar46[1] + uVar55) = auVar3;\n          case 0x1a1:\n          case 0x1a2:\n          case 0x1a3:\n          case 0x1a4:\n          case 0x1a5:\n          case 0x1a6:\n          case 0x1a7:\n          case 0x1a8:\n          case 0x1a9:\n          case 0x1aa:\n          case 0x1ab:\n          case 0x1ac:\n          case 0x1ad:\n          case 0x1ae:\n          case 0x1af:\n          case 0x1b0:\n          case 0x1b1:\n          case 0x1b2:\n          case 0x1b3:\n          case 0x1b4:\n          case 0x1b5:\n          case 0x1b6:\n          case 0x1b7:\n          case 0x1b8:\n          case 0x1b9:\n          case 0x1ba:\n          case 0x1bb:\n          case 0x1bc:\n          case 0x1bd:\n          case 0x1be:\n          case 0x1bf:\n          case 0x1c0:\n            auVar3 = vmovntdq_avx(*(undefined (*) [32])(pauVar51[2] + uVar55));\n            *(undefined (*) [32])(pauVar46[2] + uVar55) = auVar3;\n          case 0x181:\n          case 0x182:\n          case 0x183:\n          case 0x184:\n          case 0x185:\n          case 0x186:\n          case 0x187:\n          case 0x188:\n          case 0x189:\n          case 0x18a:\n          case 0x18b:\n          case 0x18c:\n          case 0x18d:\n          case 0x18e:\n          case 399:\n          case 400:\n          case 0x191:\n          case 0x192:\n          case 0x193:\n          case 0x194:\n          case 0x195:\n          case 0x196:\n          case 0x197:\n          case 0x198:\n          case 0x199:\n          case 0x19a:\n          case 0x19b:\n          case 0x19c:\n          case 0x19d:\n          case 0x19e:\n          case 0x19f:\n          case 0x1a0:\n            auVar3 = vmovntdq_avx(*(undefined (*) [32])(pauVar51[3] + uVar55));\n            *(undefined (*) [32])(pauVar46[3] + uVar55) = auVar3;\n          case 0x161:\n          case 0x162:\n          case 0x163:\n          case 0x164:\n          case 0x165:\n          case 0x166:\n          case 0x167:\n          case 0x168:\n          case 0x169:\n          case 0x16a:\n          case 0x16b:\n          case 0x16c:\n          case 0x16d:\n          case 0x16e:\n          case 0x16f:\n          case 0x170:\n          case 0x171:\n          case 0x172:\n          case 0x173:\n          case 0x174:\n          case 0x175:\n          case 0x176:\n          case 0x177:\n          case 0x178:\n          case 0x179:\n          case 0x17a:\n          case 0x17b:\n          case 0x17c:\n          case 0x17d:\n          case 0x17e:\n          case 0x17f:\n          case 0x180:\n            auVar3 = vmovntdq_avx(*(undefined (*) [32])(pauVar51[4] + uVar55));\n            *(undefined (*) [32])(pauVar46[4] + uVar55) = auVar3;\n          case 0x141:\n          case 0x142:\n          case 0x143:\n          case 0x144:\n          case 0x145:\n          case 0x146:\n          case 0x147:\n          case 0x148:\n          case 0x149:\n          case 0x14a:\n          case 0x14b:\n          case 0x14c:\n          case 0x14d:\n          case 0x14e:\n          case 0x14f:\n          case 0x150:\n          case 0x151:\n          case 0x152:\n          case 0x153:\n          case 0x154:\n          case 0x155:\n          case 0x156:\n          case 0x157:\n          case 0x158:\n          case 0x159:\n          case 0x15a:\n          case 0x15b:\n          case 0x15c:\n          case 0x15d:\n          case 0x15e:\n          case 0x15f:\n          case 0x160:\n            auVar3 = vmovntdq_avx(*(undefined (*) [32])(pauVar51[5] + uVar55));\n            *(undefined (*) [32])(pauVar46[5] + uVar55) = auVar3;\n          case 0x121:\n          case 0x122:\n          case 0x123:\n          case 0x124:\n          case 0x125:\n          case 0x126:\n          case 0x127:\n          case 0x128:\n          case 0x129:\n          case 0x12a:\n          case 299:\n          case 300:\n          case 0x12d:\n          case 0x12e:\n          case 0x12f:\n          case 0x130:\n          case 0x131:\n          case 0x132:\n          case 0x133:\n          case 0x134:\n          case 0x135:\n          case 0x136:\n          case 0x137:\n          case 0x138:\n          case 0x139:\n          case 0x13a:\n          case 0x13b:\n          case 0x13c:\n          case 0x13d:\n          case 0x13e:\n          case 0x13f:\n          case 0x140:\n            auVar3 = vmovntdq_avx(*(undefined (*) [32])(pauVar51[6] + uVar55));\n            *(undefined (*) [32])(pauVar46[6] + uVar55) = auVar3;\n          default:\n            puVar47 = (undefined4 *)(pauVar46[-1] + uVar53);\n            *puVar47 = uVar9;\n            puVar47[1] = uVar14;\n            puVar47[2] = uVar15;\n            puVar47[3] = uVar16;\n            puVar47[4] = uVar17;\n            puVar47[5] = uVar18;\n            puVar47[6] = uVar19;\n            puVar47[7] = uVar20;\n          case 0x100:\n            *param_1 = uVar10;\n            param_1[1] = uVar11;\n            param_1[2] = uVar12;\n            param_1[3] = uVar13;\n            return puVar44;\n          }\n        }\n        do {\n          uVar9 = *(undefined4 *)(*pauVar50 + 4);\n          uVar14 = *(undefined4 *)(*pauVar50 + 8);\n          uVar15 = *(undefined4 *)(*pauVar50 + 0xc);\n          uVar16 = *(undefined4 *)(*pauVar50 + 0x10);\n          uVar17 = *(undefined4 *)(*pauVar50 + 0x14);\n          uVar18 = *(undefined4 *)(*pauVar50 + 0x18);\n          uVar19 = *(undefined4 *)(*pauVar50 + 0x1c);\n          uVar20 = *(undefined4 *)pauVar50[1];\n          uVar21 = *(undefined4 *)(pauVar50[1] + 4);\n          uVar22 = *(undefined4 *)(pauVar50[1] + 8);\n          uVar23 = *(undefined4 *)(pauVar50[1] + 0xc);\n          uVar24 = *(undefined4 *)(pauVar50[1] + 0x10);\n          uVar25 = *(undefined4 *)(pauVar50[1] + 0x14);\n          uVar26 = *(undefined4 *)(pauVar50[1] + 0x18);\n          uVar27 = *(undefined4 *)(pauVar50[1] + 0x1c);\n          uVar28 = *(undefined4 *)pauVar50[2];\n          uVar29 = *(undefined4 *)(pauVar50[2] + 4);\n          uVar30 = *(undefined4 *)(pauVar50[2] + 8);\n          uVar31 = *(undefined4 *)(pauVar50[2] + 0xc);\n          uVar32 = *(undefined4 *)(pauVar50[2] + 0x10);\n          uVar33 = *(undefined4 *)(pauVar50[2] + 0x14);\n          uVar34 = *(undefined4 *)(pauVar50[2] + 0x18);\n          uVar35 = *(undefined4 *)(pauVar50[2] + 0x1c);\n          uVar36 = *(undefined4 *)pauVar50[3];\n          uVar37 = *(undefined4 *)(pauVar50[3] + 4);\n          uVar38 = *(undefined4 *)(pauVar50[3] + 8);\n          uVar39 = *(undefined4 *)(pauVar50[3] + 0xc);\n          uVar40 = *(undefined4 *)(pauVar50[3] + 0x10);\n          uVar41 = *(undefined4 *)(pauVar50[3] + 0x14);\n          uVar42 = *(undefined4 *)(pauVar50[3] + 0x18);\n          uVar43 = *(undefined4 *)(pauVar50[3] + 0x1c);\n          *(undefined4 *)*pauVar45 = *(undefined4 *)*pauVar50;\n          *(undefined4 *)(*pauVar45 + 4) = uVar9;\n          *(undefined4 *)(*pauVar45 + 8) = uVar14;\n          *(undefined4 *)(*pauVar45 + 0xc) = uVar15;\n          *(undefined4 *)(*pauVar45 + 0x10) = uVar16;\n          *(undefined4 *)(*pauVar45 + 0x14) = uVar17;\n          *(undefined4 *)(*pauVar45 + 0x18) = uVar18;\n          *(undefined4 *)(*pauVar45 + 0x1c) = uVar19;\n          *(undefined4 *)pauVar45[1] = uVar20;\n          *(undefined4 *)(pauVar45[1] + 4) = uVar21;\n          *(undefined4 *)(pauVar45[1] + 8) = uVar22;\n          *(undefined4 *)(pauVar45[1] + 0xc) = uVar23;\n          *(undefined4 *)(pauVar45[1] + 0x10) = uVar24;\n          *(undefined4 *)(pauVar45[1] + 0x14) = uVar25;\n          *(undefined4 *)(pauVar45[1] + 0x18) = uVar26;\n          *(undefined4 *)(pauVar45[1] + 0x1c) = uVar27;\n          *(undefined4 *)pauVar45[2] = uVar28;\n          *(undefined4 *)(pauVar45[2] + 4) = uVar29;\n          *(undefined4 *)(pauVar45[2] + 8) = uVar30;\n          *(undefined4 *)(pauVar45[2] + 0xc) = uVar31;\n          *(undefined4 *)(pauVar45[2] + 0x10) = uVar32;\n          *(undefined4 *)(pauVar45[2] + 0x14) = uVar33;\n          *(undefined4 *)(pauVar45[2] + 0x18) = uVar34;\n          *(undefined4 *)(pauVar45[2] + 0x1c) = uVar35;\n          *(undefined4 *)pauVar45[3] = uVar36;\n          *(undefined4 *)(pauVar45[3] + 4) = uVar37;\n          *(undefined4 *)(pauVar45[3] + 8) = uVar38;\n          *(undefined4 *)(pauVar45[3] + 0xc) = uVar39;\n          *(undefined4 *)(pauVar45[3] + 0x10) = uVar40;\n          *(undefined4 *)(pauVar45[3] + 0x14) = uVar41;\n          *(undefined4 *)(pauVar45[3] + 0x18) = uVar42;\n          *(undefined4 *)(pauVar45[3] + 0x1c) = uVar43;\n          uVar9 = *(undefined4 *)(pauVar50[4] + 4);\n          uVar14 = *(undefined4 *)(pauVar50[4] + 8);\n          uVar15 = *(undefined4 *)(pauVar50[4] + 0xc);\n          uVar16 = *(undefined4 *)(pauVar50[4] + 0x10);\n          uVar17 = *(undefined4 *)(pauVar50[4] + 0x14);\n          uVar18 = *(undefined4 *)(pauVar50[4] + 0x18);\n          uVar19 = *(undefined4 *)(pauVar50[4] + 0x1c);\n          uVar20 = *(undefined4 *)pauVar50[5];\n          uVar21 = *(undefined4 *)(pauVar50[5] + 4);\n          uVar22 = *(undefined4 *)(pauVar50[5] + 8);\n          uVar23 = *(undefined4 *)(pauVar50[5] + 0xc);\n          uVar24 = *(undefined4 *)(pauVar50[5] + 0x10);\n          uVar25 = *(undefined4 *)(pauVar50[5] + 0x14);\n          uVar26 = *(undefined4 *)(pauVar50[5] + 0x18);\n          uVar27 = *(undefined4 *)(pauVar50[5] + 0x1c);\n          uVar28 = *(undefined4 *)pauVar50[6];\n          uVar29 = *(undefined4 *)(pauVar50[6] + 4);\n          uVar30 = *(undefined4 *)(pauVar50[6] + 8);\n          uVar31 = *(undefined4 *)(pauVar50[6] + 0xc);\n          uVar32 = *(undefined4 *)(pauVar50[6] + 0x10);\n          uVar33 = *(undefined4 *)(pauVar50[6] + 0x14);\n          uVar34 = *(undefined4 *)(pauVar50[6] + 0x18);\n          uVar35 = *(undefined4 *)(pauVar50[6] + 0x1c);\n          uVar36 = *(undefined4 *)pauVar50[7];\n          uVar37 = *(undefined4 *)(pauVar50[7] + 4);\n          uVar38 = *(undefined4 *)(pauVar50[7] + 8);\n          uVar39 = *(undefined4 *)(pauVar50[7] + 0xc);\n          uVar40 = *(undefined4 *)(pauVar50[7] + 0x10);\n          uVar41 = *(undefined4 *)(pauVar50[7] + 0x14);\n          uVar42 = *(undefined4 *)(pauVar50[7] + 0x18);\n          uVar43 = *(undefined4 *)(pauVar50[7] + 0x1c);\n          *(undefined4 *)pauVar45[4] = *(undefined4 *)pauVar50[4];\n          *(undefined4 *)(pauVar45[4] + 4) = uVar9;\n          *(undefined4 *)(pauVar45[4] + 8) = uVar14;\n          *(undefined4 *)(pauVar45[4] + 0xc) = uVar15;\n          *(undefined4 *)(pauVar45[4] + 0x10) = uVar16;\n          *(undefined4 *)(pauVar45[4] + 0x14) = uVar17;\n          *(undefined4 *)(pauVar45[4] + 0x18) = uVar18;\n          *(undefined4 *)(pauVar45[4] + 0x1c) = uVar19;\n          *(undefined4 *)pauVar45[5] = uVar20;\n          *(undefined4 *)(pauVar45[5] + 4) = uVar21;\n          *(undefined4 *)(pauVar45[5] + 8) = uVar22;\n          *(undefined4 *)(pauVar45[5] + 0xc) = uVar23;\n          *(undefined4 *)(pauVar45[5] + 0x10) = uVar24;\n          *(undefined4 *)(pauVar45[5] + 0x14) = uVar25;\n          *(undefined4 *)(pauVar45[5] + 0x18) = uVar26;\n          *(undefined4 *)(pauVar45[5] + 0x1c) = uVar27;\n          *(undefined4 *)pauVar45[6] = uVar28;\n          *(undefined4 *)(pauVar45[6] + 4) = uVar29;\n          *(undefined4 *)(pauVar45[6] + 8) = uVar30;\n          *(undefined4 *)(pauVar45[6] + 0xc) = uVar31;\n          *(undefined4 *)(pauVar45[6] + 0x10) = uVar32;\n          *(undefined4 *)(pauVar45[6] + 0x14) = uVar33;\n          *(undefined4 *)(pauVar45[6] + 0x18) = uVar34;\n          *(undefined4 *)(pauVar45[6] + 0x1c) = uVar35;\n          *(undefined4 *)pauVar45[7] = uVar36;\n          *(undefined4 *)(pauVar45[7] + 4) = uVar37;\n          *(undefined4 *)(pauVar45[7] + 8) = uVar38;\n          *(undefined4 *)(pauVar45[7] + 0xc) = uVar39;\n          *(undefined4 *)(pauVar45[7] + 0x10) = uVar40;\n          *(undefined4 *)(pauVar45[7] + 0x14) = uVar41;\n          *(undefined4 *)(pauVar45[7] + 0x18) = uVar42;\n          *(undefined4 *)(pauVar45[7] + 0x1c) = uVar43;\n          pauVar45 = pauVar45 + 8;\n          pauVar50 = pauVar50 + 8;\n          param_3 = param_3 - 0x100;\n        } while (0xff < param_3);\n      }\n    }\n                    /* WARNING: Could not recover jumptable at 0x000140008142. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    puVar44 = (undefined8 *)\n              (*(code *)(IMAGE_DOS_HEADER_140000000.e_magic +\n                        *(uint *)(&DAT_14003a040 + (param_3 + 0x1f >> 5) * 4)))();\n    return puVar44;\n  }\n  for (; param_3 != 0; param_3 = param_3 - 1) {\n    *(undefined *)param_1 = *(undefined *)param_2;\n    param_2 = (undefined8 *)((longlong)param_2 + 1);\n    param_1 = (undefined8 *)((longlong)param_1 + 1);\n  }\n  return puVar44;\n}\n\n",
  "FUN_14000d050": "\nvoid FUN_14000d050(void)\n\n{\n  _invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n                    /* WARNING: Subroutine does not return */\n  _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n\n",
  "__ascii_wcsicmp": "\n/* Library Function - Single Match\n    __ascii_wcsicmp\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __ascii_wcsicmp(ushort *param_1,ushort *param_2)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  do {\n    uVar1 = *param_1;\n    param_1 = param_1 + 1;\n    uVar2 = *param_2;\n    param_2 = param_2 + 1;\n    uVar3 = uVar1 + 0x20;\n    if (0x19 < uVar1 - 0x41) {\n      uVar3 = (uint)uVar1;\n    }\n    uVar4 = uVar2 + 0x20;\n    if (0x19 < uVar2 - 0x41) {\n      uVar4 = (uint)uVar2;\n    }\n  } while ((uVar3 == uVar4) && (uVar3 != 0));\n  return;\n}\n\n",
  "FUN_1400108d0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nulonglong FUN_1400108d0(void)\n\n{\n  undefined auVar1 [16];\n  undefined auVar2 [16];\n  undefined auVar3 [16];\n  undefined auVar4 [16];\n  undefined auVar5 [16];\n  undefined auVar6 [16];\n  undefined auVar7 [16];\n  undefined auVar8 [16];\n  undefined auVar9 [16];\n  uint uVar10;\n  float fVar11;\n  uint uVar12;\n  float fVar13;\n  float fVar14;\n  bool bVar15;\n  undefined auVar17 [16];\n  undefined auVar18 [16];\n  undefined auVar19 [16];\n  ulonglong uVar16;\n  undefined in_ZMM0 [64];\n  undefined auVar20 [64];\n  undefined auVar21 [64];\n  undefined auVar22 [64];\n  undefined auVar23 [64];\n  undefined auVar24 [64];\n  undefined auVar25 [64];\n  undefined auVar26 [64];\n  undefined auVar27 [64];\n  undefined auVar28 [64];\n  undefined auVar29 [64];\n  undefined auVar30 [64];\n  undefined auVar31 [64];\n  undefined auVar32 [64];\n  undefined auVar33 [64];\n  undefined auVar34 [64];\n  undefined auVar35 [64];\n  undefined auVar36 [64];\n  undefined auVar37 [64];\n  undefined auVar38 [64];\n  undefined auVar39 [64];\n  undefined auVar40 [64];\n  undefined auVar41 [64];\n  undefined auVar42 [64];\n  undefined auVar43 [64];\n  undefined auVar44 [64];\n  undefined auVar45 [64];\n  float fVar46;\n  double dVar47;\n  double dVar48;\n  undefined auVar49 [16];\n  undefined auVar50 [16];\n  undefined auVar51 [16];\n  undefined auVar52 [16];\n  undefined in_ZMM1 [64];\n  float fVar53;\n  double dVar54;\n  undefined auVar55 [16];\n  double dVar57;\n  undefined auVar56 [16];\n  undefined auVar58 [16];\n  undefined auVar59 [16];\n  undefined auVar60 [16];\n  undefined auVar61 [16];\n  undefined auVar62 [16];\n  ulonglong in_XMM5_Qa;\n  undefined auVar63 [16];\n  undefined auVar65 [16];\n  undefined auVar66 [16];\n  double dVar67;\n  undefined auVar64 [16];\n  undefined extraout_var [60];\n  undefined extraout_var_00 [60];\n  undefined extraout_var_01 [60];\n  undefined extraout_var_02 [60];\n  undefined extraout_var_03 [60];\n  undefined extraout_var_04 [60];\n  undefined extraout_var_05 [60];\n  undefined extraout_var_06 [60];\n  undefined extraout_var_07 [60];\n  undefined extraout_var_08 [60];\n  undefined extraout_var_09 [60];\n  undefined extraout_var_10 [60];\n  undefined extraout_var_11 [60];\n  undefined extraout_var_12 [60];\n  undefined extraout_var_13 [60];\n  undefined extraout_var_14 [60];\n  undefined extraout_var_15 [60];\n  undefined extraout_var_16 [60];\n  undefined extraout_var_17 [60];\n  undefined extraout_var_18 [60];\n  undefined extraout_var_19 [60];\n  undefined extraout_var_20 [60];\n  undefined extraout_var_21 [60];\n  \n  fVar11 = in_ZMM0._0_4_;\n  auVar34._16_48_ = in_ZMM0._16_48_;\n  if (DAT_1400378d4 != 0) {\n    auVar58 = vpunpckldq_avx(in_ZMM1._0_16_,in_ZMM0._0_16_);\n    auVar64 = (undefined  [16])0x0;\n    auVar63 = (undefined  [16])0x0;\n    fVar46 = auVar58._0_4_;\n    uVar10 = (uint)fVar46 & 0x7fffffff;\n    uVar12 = (uint)fVar11 & 0x7fffffff;\n    if (uVar10 < 0x7f800000) {\n      if (uVar10 < 0x3f800001) {\n        if ((auVar58 & (undefined  [16])0x7fffffff) == (undefined  [16])0x0) {\n          if (uVar12 < 0x7f800001) {\n            return 0x3f800000;\n          }\n          if (0x7fbfffff < uVar12) {\n            return 0x3f800000;\n          }\n          auVar37._0_4_ = FUN_14001a374(fVar11,fVar46,(float)(uVar12 | 0x400000),DAT_140027538);\n          auVar37._4_60_ = extraout_var_13;\n          return auVar37._0_8_;\n        }\n        if (fVar46 == 1.0) {\n          if (uVar12 < 0x7f800001) {\n            return in_ZMM0._0_8_;\n          }\n          auVar36._0_4_ = FUN_14001a374(fVar11,1.0,(float)((uint)fVar11 | 0x400000),DAT_140027538);\n          auVar36._4_60_ = extraout_var_12;\n          return auVar36._0_8_;\n        }\n      }\n      if (uVar12 < 0x7f800000) {\n        auVar51 = vcvtps2pd_avx(auVar58);\n        auVar34 = ZEXT1664(auVar51);\n        if ((int)fVar11 < 0x3f880000) {\n          auVar63 = auVar64;\n          if ((int)fVar11 < 1) {\n            if ((in_ZMM0 & (undefined  [64])0x7fffffff) == (undefined  [64])0x0) {\n              fVar13 = fVar46;\n              if ((int)fVar46 < 0) {\n                fVar13 = INFINITY;\n              }\n              fVar14 = 0.0;\n              if ((int)fVar46 < 0) {\n                fVar14 = INFINITY;\n              }\n              uVar10 = 0;\n              if (0 < (int)fVar46) {\n                fVar13 = 0.0;\n              }\n              if (((uint)fVar46 & 0x7f800000) < 0x4b000001) {\n                uVar10 = vstmxcsr_avx();\n                vldmxcsr_avx(uVar10 | 0x1f80);\n                uVar12 = vcvtss2si_avx(auVar58);\n                fVar53 = (float)uVar12;\n                vldmxcsr_avx(uVar10);\n                uVar10 = 0x80000000;\n                if ((!NAN(fVar53) && !NAN(fVar46)) && fVar53 != fVar46) {\n                  uVar10 = 0;\n                }\n                if (fVar53 == fVar46) {\n                  if ((uVar12 & 1) == 0) {\n                    uVar10 = 0;\n                  }\n                  else {\n                    uVar10 = (uint)fVar11 & 0x80000000;\n                  }\n                }\n              }\n              fVar13 = (float)(uVar10 | (uint)fVar13);\n              if (fVar14 == 0.0) {\n                return (ulonglong)(uint)fVar13;\n              }\n              auVar35._0_4_ = FUN_14001a374(fVar13,fVar46,fVar13,DAT_140027534);\n              auVar35._4_60_ = extraout_var_11;\n              return auVar35._0_8_;\n            }\n            if (((uint)fVar46 & 0x7f800000) < 0x4b000001) {\n              uVar10 = vstmxcsr_avx();\n              vldmxcsr_avx(uVar10 | 0x1f80);\n              uVar12 = vcvtss2si_avx(auVar58);\n              vldmxcsr_avx(uVar10);\n              if ((float)uVar12 != fVar46) {\n                auVar45._0_4_ = FUN_14001a374(auVar51._0_4_,fVar46,-NAN,DAT_140027544);\n                auVar45._4_60_ = extraout_var_21;\n                return auVar45._0_8_;\n              }\n              if ((uVar12 & 1) != 0) {\n                auVar63 = ZEXT416(DAT_14002759c);\n              }\n            }\n          }\n          auVar58 = vpshufd_avx(auVar51,0xee);\n          dVar47 = auVar58._0_8_ - DAT_14002758c;\n          if (((ulonglong)dVar47 & 0x7fffffffffffffff) < DAT_140027584) {\n            auVar58 = vpshufd_avx(auVar63,0x44);\n            auVar65._8_8_ = auVar58._8_8_;\n            auVar65._0_8_ = dVar47;\n            auVar58._8_8_ = 0;\n            auVar58._0_8_ = dVar47 + DAT_140027594;\n            auVar58 = vdivsd_avx(auVar65,auVar58);\n            dVar57 = auVar58._0_8_;\n            dVar48 = dVar57 + dVar57;\n            dVar54 = dVar48 * dVar48;\n            auVar51._8_8_ = 0;\n            auVar51._0_8_ = dVar54;\n            auVar58 = vpshufd_avx(auVar51,0x44);\n            auVar63._8_8_ = _UNK_1400275b8;\n            auVar63._0_8_ = _DAT_1400275b0;\n            auVar58 = vmulpd_avx(auVar58,auVar63);\n            auVar64._8_8_ = _UNK_1400275c8;\n            auVar64._0_8_ = _DAT_1400275c0;\n            auVar58 = vaddpd_avx(auVar58,auVar64);\n            auVar52._8_8_ = 0;\n            auVar52._0_8_ = dVar54 * dVar54 * dVar48 * dVar54;\n            auVar56._8_8_ = 0;\n            auVar56._0_8_ = dVar48 * dVar54;\n            auVar63 = vunpcklpd_avx(auVar56,auVar52);\n            auVar58 = vmulpd_avx(auVar63,auVar58);\n            auVar63 = vpshufd_avx(auVar58,0xee);\n            fVar11 = auVar63._0_4_;\n            auVar66._8_8_ = 0;\n            auVar66._0_8_ = dVar57 * dVar47;\n            auVar64 = vpshufd_avx(auVar66,0xee);\n            in_XMM5_Qa = auVar64._0_8_;\n            dVar47 = dVar47 + ((auVar63._0_8_ + auVar58._0_8_) - dVar57 * dVar47);\n            goto LAB_1400109ce;\n          }\n        }\n        auVar58 = vpshufd_avx(auVar51,0xee);\n        auVar58 = vpand_avx(auVar58,_DAT_140027610);\n        uVar10 = (auVar58._4_4_ >> 0xc) + (uint)((auVar58._0_8_ >> 0x2b & 1) != 0);\n        auVar8._8_8_ = _UNK_1400275f8;\n        auVar8._0_8_ = DAT_1400275f0;\n        auVar64 = vpor_avx(auVar58,auVar8);\n        auVar58 = vpshufd_avx(auVar64,0xee);\n        auVar58 = vpsrlq_avx(auVar58,0x34);\n        auVar9._4_12_ = _UNK_140027604;\n        auVar9._0_4_ = _DAT_140027600;\n        auVar58 = vpsubq_avx(auVar58,auVar9);\n        auVar58 = vcvtdq2pd_avx(auVar58);\n        dVar47 = ((double)((ulonglong)(uVar10 | 0x3fe00) << 0x2c) - auVar64._0_8_) *\n                 *(double *)(&DAT_14002a570 + (ulonglong)uVar10 * 8);\n        auVar49._8_8_ = 0;\n        auVar49._0_8_ = dVar47;\n        auVar62._8_8_ = 0;\n        auVar62._0_8_ = DAT_140027554;\n        auVar1._8_8_ = 0;\n        auVar1._0_8_ = DAT_1400275f0;\n        auVar64 = vfmadd213sd_fma(auVar62,auVar49,auVar1);\n        auVar2._8_8_ = 0;\n        auVar2._0_8_ = DAT_14002758c;\n        auVar50._8_8_ = 0;\n        auVar50._0_8_ = dVar47;\n        auVar64 = vfmadd213sd_fma(auVar64,auVar50,auVar2);\n        dVar47 = dVar47 * auVar64._0_8_;\n        dVar48 = auVar51._0_8_ *\n                 ((auVar58._0_8_ * DAT_14002755c +\n                  *(double *)(&DAT_140027620 + (ulonglong)uVar10 * 8)) - dVar47);\n        fVar11 = SUB84(dVar47,0);\n        if (DAT_140027564 < dVar48) {\n          auVar58 = vorps_avx(ZEXT416(0x7f800000),auVar63);\n          auVar44._0_4_ = FUN_14001a374(SUB84(dVar48,0),fVar11,auVar58._0_4_,DAT_140027550);\n          auVar44._4_60_ = extraout_var_20;\n          return auVar44._0_8_;\n        }\n        if (DAT_14002756c < dVar48) {\n          auVar17._8_8_ = 0;\n          auVar17._0_8_ = dVar48;\n          auVar6._8_8_ = _UNK_1400275e8;\n          auVar6._0_8_ = _DAT_1400275e0;\n          auVar58 = vmulpd_avx(auVar17,auVar6);\n          auVar64 = vcvtpd2dq_avx(auVar58);\n          auVar58 = vcvtdq2pd_avx(auVar64);\n          auVar3._8_8_ = 0;\n          auVar3._0_8_ = DAT_140027574;\n          auVar51 = vfnmadd231sd_fma(auVar17,auVar58,auVar3);\n          auVar59._8_8_ = 0;\n          auVar59._0_8_ = DAT_14002757c;\n          auVar4._8_8_ = 0;\n          auVar4._0_8_ = DAT_1400275f0;\n          auVar58 = vfmadd213sd_fma(auVar59,auVar51,auVar4);\n          auVar5._8_8_ = 0;\n          auVar5._0_8_ = DAT_14002758c;\n          auVar58 = vfmadd213sd_fma(auVar58,auVar51,auVar5);\n          auVar60._8_8_ = 0;\n          auVar60._0_8_ = *(ulonglong *)(&DAT_14002a370 + (ulonglong)(auVar64._0_4_ & 0x3f) * 8);\n          auVar18._8_8_ = 0;\n          auVar18._0_8_ = auVar51._0_8_ * auVar58._0_8_;\n          auVar51 = vfmadd213sd_fma(auVar18,auVar60,auVar60);\n          auVar58 = vpsrad_avx(auVar64,6);\n          auVar58 = vpsllq_avx(auVar58,0x34);\n          auVar58 = vpaddq_avx(auVar58,auVar51);\n          auVar19._0_4_ = (float)auVar58._0_8_;\n          auVar19._4_12_ = auVar51._4_12_;\n          auVar58 = vorps_avx(auVar19,auVar63);\n          return auVar58._0_8_;\n        }\n        auVar58 = vorps_avx((undefined  [16])0x0,auVar63);\n        auVar43._0_4_ = FUN_14001a374(SUB84(dVar48,0),fVar11,auVar58._0_4_,DAT_140027548);\n        auVar43._4_60_ = extraout_var_19;\n        return auVar43._0_8_;\n      }\n      if ((auVar58 & (undefined  [16])0x7fffffff) == (undefined  [16])0x0) {\n        return 0x3f800000;\n      }\n      if (fVar11 == INFINITY) {\n        if (-1 < (int)fVar46) {\n          return 0x7f800000;\n        }\n        return 0;\n      }\n      if (fVar11 == -INFINITY) {\n        uVar10 = 0;\n        fVar11 = fVar46;\n        if ((int)fVar46 < 0) {\n          fVar11 = 0.0;\n        }\n        if (0 < (int)fVar46) {\n          fVar11 = INFINITY;\n        }\n        if (((uint)fVar46 & 0x7f800000) < 0x4b000001) {\n          uVar10 = vstmxcsr_avx();\n          vldmxcsr_avx(uVar10 | 0x1f80);\n          uVar12 = vcvtss2si_avx(auVar58);\n          fVar13 = (float)uVar12;\n          vldmxcsr_avx(uVar10);\n          uVar10 = 0x80000000;\n          if ((!NAN(fVar13) && !NAN(fVar46)) && fVar13 != fVar46) {\n            uVar10 = 0;\n          }\n          if ((fVar13 == fVar46) && ((uVar12 & 1) == 0)) {\n            uVar10 = 0;\n          }\n        }\n        return (ulonglong)(uVar10 | (uint)fVar11);\n      }\n    }\n    else {\n      if (0x7f800000 < uVar10) {\n        if (0x7f800000 < uVar12) {\n          if (fVar11 != -NAN) {\n            auVar41._0_4_ =\n                 FUN_14001a374(fVar11,fVar46,(float)((uint)fVar11 | 0x400000),DAT_140027540);\n            auVar41._4_60_ = extraout_var_17;\n            return auVar41._0_8_;\n          }\n          auVar42._0_4_ = FUN_14001a374(-NAN,fVar46,(float)((uint)fVar46 | 0x400000),DAT_140027540);\n          auVar42._4_60_ = extraout_var_18;\n          return auVar42._0_8_;\n        }\n        if (fVar11 == 1.0) {\n          if (0x7fbfffff < uVar10) {\n            return 0x3f800000;\n          }\n          auVar38._0_4_ = FUN_14001a374(1.0,fVar46,1.0,DAT_14002753c);\n          auVar38._4_60_ = extraout_var_14;\n          return auVar38._0_8_;\n        }\n        auVar40._0_4_ = FUN_14001a374(fVar46,fVar46,(float)((uint)fVar46 | 0x400000),DAT_14002753c);\n        auVar40._4_60_ = extraout_var_16;\n        return auVar40._0_8_;\n      }\n      if (uVar12 < 0x7f800001) {\n        if (uVar12 == 0x3f800000) {\n          return 0x3f800000;\n        }\n        if (-1 < (int)fVar46) {\n          if (0x3f7fffff < uVar12) {\n            return 0x7f800000;\n          }\n          return 0;\n        }\n        uVar10 = 0;\n        if (uVar12 < 0x3f800000) {\n          uVar10 = 0x7f800000;\n        }\n        return (ulonglong)uVar10;\n      }\n    }\n    auVar39._0_4_ = FUN_14001a374(fVar11,fVar46,(float)((uint)fVar11 | 0x400000),DAT_140027538);\n    auVar39._4_60_ = extraout_var_15;\n    return auVar39._0_8_;\n  }\n  fVar46 = in_ZMM1._0_4_;\n  uVar10 = (uint)fVar46 & 0x7fffffff;\n  uVar12 = (uint)fVar11 & 0x7fffffff;\n  if (0x7f7fffff < uVar10) {\n    if (0x7f800000 < uVar10) {\n      if (0x7f800000 < uVar12) {\n        if (fVar11 != -NAN) {\n          auVar29._0_4_ =\n               FUN_14001a374(fVar11,fVar46,(float)((uint)fVar11 | 0x400000),DAT_140027540);\n          auVar29._4_60_ = extraout_var_06;\n          return auVar29._0_8_;\n        }\n        auVar30._0_4_ = FUN_14001a374(-NAN,fVar46,(float)((uint)fVar46 | 0x400000),DAT_140027540);\n        auVar30._4_60_ = extraout_var_07;\n        return auVar30._0_8_;\n      }\n      if (fVar11 == 1.0) {\n        if (0x7fbfffff < uVar10) {\n          return 0x3f800000;\n        }\n        auVar26._0_4_ = FUN_14001a374(1.0,fVar46,1.0,DAT_14002753c);\n        auVar26._4_60_ = extraout_var_03;\n        return auVar26._0_8_;\n      }\n      auVar28._0_4_ = FUN_14001a374(fVar11,fVar46,(float)((uint)fVar46 | 0x400000),DAT_14002753c);\n      auVar28._4_60_ = extraout_var_05;\n      return auVar28._0_8_;\n    }\n    if (uVar12 < 0x7f800001) {\n      if (uVar12 == 0x3f800000) {\n        return 0x3f800000;\n      }\n      if ((int)fVar46 < 0) {\n        bVar15 = (in_ZMM0 & (undefined  [64])0x7fffffff) != (undefined  [64])0x0;\n        if (bVar15) {\n          fVar11 = 0.0;\n          if (uVar12 < 0x3f800000) {\n            fVar11 = INFINITY;\n          }\n          uVar16 = (ulonglong)(uint)fVar11;\n          if (!bVar15) {\n            auVar23._0_4_ = FUN_14001a374(fVar11,fVar46,fVar11,DAT_140027534);\n            auVar23._4_60_ = extraout_var_00;\n            uVar16 = auVar23._0_8_;\n          }\n          return uVar16;\n        }\n      }\n      else if (uVar12 < 0x3f800000) {\n        return 0;\n      }\n      return 0x7f800000;\n    }\nLAB_140010ef0:\n    auVar27._0_4_ = FUN_14001a374(fVar11,fVar46,(float)((uint)fVar11 | 0x400000),DAT_140027538);\n    auVar27._4_60_ = extraout_var_04;\n    return auVar27._0_8_;\n  }\n  if (uVar10 < 0x3f800001) {\n    if ((in_ZMM1 & (undefined  [64])0x7fffffff) == (undefined  [64])0x0) {\n      if (uVar12 < 0x7f800001) {\n        return 0x3f800000;\n      }\n      if (0x7fbfffff < uVar12) {\n        return 0x3f800000;\n      }\n      auVar25._0_4_ = FUN_14001a374(fVar11,fVar46,(float)(uVar12 | 0x400000),DAT_140027538);\n      auVar25._4_60_ = extraout_var_02;\n      return auVar25._0_8_;\n    }\n    if (fVar46 == 1.0) {\n      if (((uint)fVar11 & 0x7fffffff) < 0x7f800001) {\n        return in_ZMM0._0_8_;\n      }\n      auVar24._0_4_ = FUN_14001a374(fVar11,1.0,(float)((uint)fVar11 | 0x400000),DAT_140027538);\n      auVar24._4_60_ = extraout_var_01;\n      return auVar24._0_8_;\n    }\n  }\n  if (0x7f7fffff < uVar12) {\n    if ((in_ZMM1 & (undefined  [64])0x7fffffff) == (undefined  [64])0x0) {\n      return 0x3f800000;\n    }\n    if (fVar11 == INFINITY) {\n      if (-1 < (int)fVar46) {\n        return 0x7f800000;\n      }\n      return 0;\n    }\n    if (fVar11 == -INFINITY) {\n      uVar10 = 0;\n      fVar11 = fVar46;\n      if ((int)fVar46 < 0) {\n        fVar11 = 0.0;\n      }\n      if (0 < (int)fVar46) {\n        fVar11 = INFINITY;\n      }\n      if (((uint)fVar46 & 0x7f800000) < 0x4b000001) {\n        fVar13 = (float)(int)ROUND(fVar46);\n        uVar10 = 0x80000000;\n        if ((!NAN(fVar13) && !NAN(fVar46)) && fVar13 != fVar46) {\n          uVar10 = 0;\n        }\n        if ((fVar13 == fVar46) && (((uint)ROUND(fVar46) & 1) == 0)) {\n          uVar10 = 0;\n        }\n      }\n      return (ulonglong)(uVar10 | (uint)fVar11);\n    }\n    goto LAB_140010ef0;\n  }\n  auVar34._0_8_ = (double)fVar46;\n  auVar34._8_8_ = (double)fVar11;\n  if ((int)fVar11 < 0x3f880000) {\n    if ((int)fVar11 < 1) {\n      if ((in_ZMM0 & (undefined  [64])0x7fffffff) == (undefined  [64])0x0) {\n        fVar13 = fVar46;\n        if ((int)fVar46 < 0) {\n          fVar13 = INFINITY;\n        }\n        fVar14 = 0.0;\n        if ((int)fVar46 < 0) {\n          fVar14 = INFINITY;\n        }\n        uVar10 = 0;\n        if (0 < (int)fVar46) {\n          fVar13 = 0.0;\n        }\n        if (((uint)fVar46 & 0x7f800000) < 0x4b000001) {\n          fVar53 = (float)(int)ROUND(fVar46);\n          uVar10 = 0x80000000;\n          if ((!NAN(fVar53) && !NAN(fVar46)) && fVar53 != fVar46) {\n            uVar10 = 0;\n          }\n          if (fVar53 == fVar46) {\n            if (((uint)ROUND(fVar46) & 1) == 0) {\n              uVar10 = 0;\n            }\n            else {\n              uVar10 = (uint)fVar11 & 0x80000000;\n            }\n          }\n        }\n        fVar13 = (float)(uVar10 | (uint)fVar13);\n        uVar16 = (ulonglong)(uint)fVar13;\n        if (fVar14 != 0.0) {\n          auVar22._0_4_ = FUN_14001a374(fVar13,fVar46,fVar13,DAT_140027534);\n          auVar22._4_60_ = extraout_var;\n          uVar16 = auVar22._0_8_;\n        }\n        return uVar16;\n      }\n      if (((uint)fVar46 & 0x7f800000) < 0x4b000001) {\n        if ((float)(int)ROUND(fVar46) != fVar46) {\n          auVar33._0_4_ = FUN_14001a374(SUB84(auVar34._0_8_,0),fVar46,-NAN,DAT_140027544);\n          auVar33._4_60_ = extraout_var_10;\n          return auVar33._0_8_;\n        }\n        if (((uint)ROUND(fVar46) & 1) != 0) {\n          in_XMM5_Qa = (ulonglong)DAT_14002759c;\n        }\n      }\n    }\n    dVar47 = auVar34._8_8_ - DAT_14002758c;\n    if (((ulonglong)dVar47 & 0x7fffffffffffffff) < DAT_140027584) {\n      dVar67 = dVar47 / (dVar47 + DAT_140027594);\n      dVar54 = dVar67 + dVar67;\n      dVar48 = dVar54 * dVar54;\n      auVar61._8_4_ = SUB84(dVar48,0);\n      auVar61._0_8_ = dVar48;\n      auVar61._12_4_ = (int)((ulonglong)dVar48 >> 0x20);\n      dVar57 = dVar48 * dVar48 * dVar54 * dVar48 * (auVar61._8_8_ * _UNK_1400275b8 + _UNK_1400275c8)\n      ;\n      fVar11 = SUB84(dVar57,0);\n      dVar47 = dVar47 + ((dVar54 * dVar48 * (dVar48 * _DAT_1400275b0 + _DAT_1400275c0) + dVar57) -\n                        dVar67 * dVar47);\n      goto LAB_1400109ce;\n    }\n  }\n  auVar55._8_4_ = SUB84(auVar34._8_8_,0);\n  auVar55._0_8_ = auVar34._8_8_;\n  auVar55._12_4_ = (int)((ulonglong)auVar34._8_8_ >> 0x20);\n  auVar55 = auVar55 & _DAT_140027610;\n  uVar10 = (auVar55._4_4_ >> 0xc) + (uint)((auVar55._0_8_ >> 0x2b & 1) != 0);\n  auVar7._8_8_ = _UNK_1400275f8;\n  auVar7._0_8_ = DAT_1400275f0;\n  dVar47 = ((double)((ulonglong)(uVar10 | 0x3fe00) << 0x2c) - SUB168(auVar55 | auVar7,0)) *\n           *(double *)(&DAT_14002a570 + (ulonglong)uVar10 * 8);\n  dVar47 = dVar47 * dVar47 * (DAT_140027554 * dVar47 + DAT_1400275f0) + dVar47;\n  fVar11 = SUB84(dVar47,0);\n  dVar47 = ((double)((SUB164(auVar55 | auVar7,0xc) >> 0x14) - _DAT_140027600) * DAT_14002755c +\n           *(double *)(&DAT_140027620 + (ulonglong)uVar10 * 8)) - dVar47;\nLAB_1400109ce:\n  auVar20._8_56_ = auVar34._8_56_;\n  dVar47 = auVar34._0_8_ * dVar47;\n  if (DAT_140027564 < dVar47) {\n    auVar32._0_4_ =\n         FUN_14001a374(SUB84(dVar47,0),fVar11,(float)((uint)(float)in_XMM5_Qa | 0x7f800000),\n                       DAT_140027550);\n    auVar32._4_60_ = extraout_var_09;\n    return auVar32._0_8_;\n  }\n  if (DAT_14002756c < dVar47) {\n    uVar10 = (uint)(dVar47 * _DAT_1400275e0);\n    dVar47 = dVar47 - (double)uVar10 * DAT_140027574;\n    auVar20._0_8_ =\n         (dVar47 * dVar47 * (DAT_14002757c * dVar47 + DAT_1400275f0) + dVar47) *\n         *(double *)(&DAT_14002a370 + (ulonglong)(uVar10 & 0x3f) * 8) +\n         *(double *)(&DAT_14002a370 + (ulonglong)(uVar10 & 0x3f) * 8);\n    auVar21._4_60_ = auVar20._4_60_;\n    auVar21._0_4_ =\n         (float)(double)(((ulonglong)(uint)((int)uVar10 >> 6) << 0x34) + (longlong)auVar20._0_8_);\n    return auVar21._0_8_ | in_XMM5_Qa;\n  }\n  auVar31._0_4_ = FUN_14001a374(SUB84(dVar47,0),fVar11,(float)in_XMM5_Qa,DAT_140027548);\n  auVar31._4_60_ = extraout_var_08;\n  return auVar31._0_8_;\n}\n\n",
  "_CallSETranslator<class___FrameHandler4>": "\n/* Library Function - Single Match\n    int __cdecl _CallSETranslator<class __FrameHandler4>(struct EHExceptionRecord * __ptr64,unsigned\n   __int64 * __ptr64,struct _CONTEXT * __ptr64,struct _xDISPATCHER_CONTEXT * __ptr64,struct\n   FH4::FuncInfo4 * __ptr64,unsigned long,unsigned __int64 * __ptr64,int)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\n_CallSETranslator<class___FrameHandler4>\n          (EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n          _xDISPATCHER_CONTEXT *param_4,FuncInfo4 *param_5,ulong param_6,__uint64 *param_7,\n          int param_8)\n\n{\n  EHExceptionRecord *local_20;\n  _CONTEXT *local_18;\n  \n  local_20 = param_1;\n  local_18 = param_3;\n  FUN_140008b20();\n  (*(code *)PTR__guard_dispatch_icall_140023298)(*(undefined4 *)param_1,&local_20);\n  return 0;\n}\n\n",
  "FUN_14001dfb0": "\nvoid FUN_14001dfb0(wchar_t *param_1)\n\n{\n  int iVar1;\n  errno_t eVar2;\n  longlong lVar3;\n  ulonglong uVar4;\n  longlong lVar5;\n  undefined auStackY_138 [32];\n  WCHAR local_108 [120];\n  ulonglong local_18;\n  longlong lVar6;\n  \n  local_18 = DAT_140035020 ^ (ulonglong)auStackY_138;\n  lVar3 = FUN_140014d84();\n  iVar1 = __acrt_GetLocaleInfoEx\n                    ((ushort *)param_1,(-(uint)(*(int *)(lVar3 + 0xb0) != 0) & 0xfffff002) + 0x1001,\n                     local_108,0x78);\n  if (iVar1 == 0) {\n    *(undefined4 *)(lVar3 + 0xa8) = 0;\n  }\n  else {\n    uVar4 = FUN_14001a634(*(ushort **)(lVar3 + 0x98),(ushort *)local_108);\n    if ((int)uVar4 == 0) {\n      lVar5 = -1;\n      do {\n        lVar6 = lVar5;\n        lVar5 = lVar6 + 1;\n      } while (param_1[lVar5] != L'\\0');\n      eVar2 = wcsncpy_s((wchar_t *)(lVar3 + 0x2f0),0x55,param_1,lVar6 + 2);\n      if (eVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n        _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n      }\n      *(uint *)(lVar3 + 0xa8) = *(uint *)(lVar3 + 0xa8) | 4;\n    }\n  }\n  FUN_140006060(local_18 ^ (ulonglong)auStackY_138);\n  return;\n}\n\n",
  "__acrt_get_qualified_locale_downlevel": "\n/* Library Function - Single Match\n    __acrt_get_qualified_locale_downlevel\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_get_qualified_locale_downlevel(longlong param_1,UINT *param_2,LPWSTR param_3)\n\n{\n  ushort **ppuVar1;\n  ushort *puVar2;\n  UINT _Val;\n  BOOL BVar3;\n  int iVar4;\n  longlong lVar5;\n  longlong lVar6;\n  ulonglong uVar7;\n  longlong lVar8;\n  undefined auStack_78 [32];\n  undefined8 local_58;\n  LCID local_50;\n  ulonglong local_48;\n  \n  local_48 = DAT_140035020 ^ (ulonglong)auStack_78;\n  lVar5 = FUN_140014d84();\n  local_58 = 0;\n  local_50 = 0;\n  lVar6 = FUN_140014d84();\n  ppuVar1 = (ushort **)(lVar5 + 0xa0);\n  *(undefined8 **)(lVar6 + 0x3a0) = &local_58;\n  puVar2 = (ushort *)(param_1 + 0x80);\n  *(longlong *)(lVar5 + 0x98) = param_1;\n  *ppuVar1 = puVar2;\n  if ((puVar2 != (ushort *)0x0) && (*puVar2 != 0)) {\n    TranslateName(0x14002b200,DAT_14002b370 + -1,ppuVar1);\n  }\n  uVar7 = local_58;\n  local_58 = local_58 & 0xffffffff00000000;\n  if ((*(short **)(lVar5 + 0x98) == (short *)0x0) || (**(short **)(lVar5 + 0x98) == 0)) {\n    if ((*ppuVar1 == (ushort *)0x0) || (**ppuVar1 == 0)) {\n      local_58._4_4_ = SUB84(uVar7,4);\n      local_58 = CONCAT44(local_58._4_4_,0x104);\n      local_50 = GetUserDefaultLCID();\n      local_58 = CONCAT44(local_50,(uint)local_58);\n    }\n    else {\n      lVar6 = FUN_140014d84();\n      lVar8 = -1;\n      do {\n        lVar8 = lVar8 + 1;\n      } while (*(short *)(*(longlong *)(lVar6 + 0xa0) + lVar8 * 2) != 0);\n      *(uint *)(lVar6 + 0xb4) = (uint)(lVar8 == 3);\n      EnumSystemLocalesW((LOCALE_ENUMPROCW)&LAB_14001e4cc,1);\n      if ((local_58 & 4) == 0) {\n        local_58 = local_58 & 0xffffffff00000000;\n      }\n    }\nLAB_14001ee18:\n    if ((uint)local_58 == 0) goto LAB_14001eeff;\n  }\n  else {\n    if ((*ppuVar1 == (ushort *)0x0) || (**ppuVar1 == 0)) {\n      GetLcidFromLanguage((byte *)&local_58);\n    }\n    else {\n      GetLcidFromLangCountry((uint *)&local_58);\n    }\n    if ((uint)local_58 == 0) {\n      uVar7 = TranslateName(0x14002ade0,DAT_14002b1f0 + -1,(ushort **)(lVar5 + 0x98));\n      if ((char)uVar7 != '\\0') {\n        if ((*ppuVar1 == (ushort *)0x0) || (**ppuVar1 == 0)) {\n          GetLcidFromLanguage((byte *)&local_58);\n        }\n        else {\n          GetLcidFromLangCountry((uint *)&local_58);\n        }\n      }\n      goto LAB_14001ee18;\n    }\n  }\n  _Val = ProcessCodePage((wchar_t *)(-(ulonglong)(param_1 != 0) & param_1 + 0x100U),\n                         (longlong)&local_58);\n  if ((_Val != 0) && (BVar3 = IsValidCodePage(_Val & 0xffff), BVar3 != 0)) {\n    BVar3 = IsValidLocale(local_58._4_4_,1);\n    if (BVar3 != 0) {\n      if (param_2 != (UINT *)0x0) {\n        *param_2 = _Val;\n      }\n      __acrt_LCIDToLocaleName(local_58._4_4_,(wchar_t *)(lVar5 + 0x2f0),0x55);\n      if (param_3 != (LPWSTR)0x0) {\n        __acrt_LCIDToLocaleName(local_58._4_4_,param_3 + 0x90,0x55);\n        iVar4 = GetLocaleInfoW(local_58._4_4_,0x1001,param_3,0x40);\n        if ((iVar4 != 0) &&\n           (iVar4 = GetLocaleInfoW(local_50,0x1002,param_3 + 0x40,0x40), iVar4 != 0)) {\n          _itow_s(_Val,param_3 + 0x80,0x10,10);\n        }\n      }\n    }\n  }\nLAB_14001eeff:\n  FUN_140006060(local_48 ^ (ulonglong)auStack_78);\n  return;\n}\n\n",
  "FUN_140012d38": "\nundefined4 FUN_140012d38(void)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = DAT_140037280;\n  LOCK();\n  DAT_140037280 = 1;\n  UNLOCK();\n  return uVar1;\n}\n\n",
  "__acrt_mbs_to_wcs_cp<struct___crt_win32_buffer_internal_dynamic_resizing>": "\n/* Library Function - Single Match\n    int __cdecl __acrt_mbs_to_wcs_cp<struct __crt_win32_buffer_internal_dynamic_resizing>(char const\n   * __ptr64 const,class __crt_win32_buffer<wchar_t,struct\n   __crt_win32_buffer_internal_dynamic_resizing> & __ptr64,unsigned int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl\n__acrt_mbs_to_wcs_cp<struct___crt_win32_buffer_internal_dynamic_resizing>\n          (char *param_1,\n          __crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing> *param_2,\n          uint param_3)\n\n{\n  int iVar1;\n  DWORD DVar2;\n  LPVOID pvVar3;\n  ulong *puVar4;\n  ulonglong uVar5;\n  uint uVar6;\n  ulonglong uVar7;\n  ulonglong uVar8;\n  \n  uVar7 = 0;\n  if (param_1 == (char *)0x0) {\n    if (param_2[0x28] !=\n        (__crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing>)0x0) {\n      _free_base(*(LPVOID *)(param_2 + 0x10));\n      param_2[0x28] =\n           (__crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing>)0x0;\n    }\n    *(undefined8 *)(param_2 + 0x10) = 0;\n    *(undefined8 *)(param_2 + 0x18) = 0;\n  }\n  else {\n    if (*param_1 != '\\0') {\n      iVar1 = __acrt_MultiByteToWideChar(param_3,9,param_1,-1,(LPWSTR)0x0,0);\n      uVar8 = (ulonglong)iVar1;\n      if (iVar1 != 0) {\n        uVar5 = *(ulonglong *)(param_2 + 0x18);\n        if (uVar5 < uVar8) {\n          if (param_2[0x28] !=\n              (__crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing>)0x0)\n          {\n            _free_base(*(LPVOID *)(param_2 + 0x10));\n            param_2[0x28] =\n                 (__crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing>)\n                 0x0;\n          }\n          pvVar3 = _malloc_base(uVar8 * 2);\n          *(LPVOID *)(param_2 + 0x10) = pvVar3;\n          uVar6 = ~-(uint)(pvVar3 != (LPVOID)0x0) & 0xc;\n          uVar5 = 0;\n          if (uVar6 == 0) {\n            uVar5 = uVar8;\n          }\n          param_2[0x28] =\n               (__crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing>)\n               (uVar6 == 0);\n          *(ulonglong *)(param_2 + 0x18) = uVar5;\n          if (uVar6 != 0) goto LAB_140011844;\n        }\n        iVar1 = __acrt_MultiByteToWideChar\n                          (param_3,9,param_1,-1,*(LPWSTR *)(param_2 + 0x10),(int)uVar5);\n        if (iVar1 != 0) {\n          *(longlong *)(param_2 + 0x20) = (longlong)iVar1 + -1;\n          goto LAB_140011909;\n        }\n      }\n      DVar2 = GetLastError();\n      __acrt_errno_map_os_error(DVar2);\n      puVar4 = __doserrno();\n      uVar7 = (ulonglong)*puVar4;\n      goto LAB_140011909;\n    }\n    if (*(longlong *)(param_2 + 0x18) == 0) {\n      if (param_2[0x28] !=\n          (__crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing>)0x0) {\n        _free_base(*(LPVOID *)(param_2 + 0x10));\n        param_2[0x28] =\n             (__crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing>)0x0;\n      }\n      pvVar3 = _malloc_base(2);\n      *(LPVOID *)(param_2 + 0x10) = pvVar3;\n      uVar6 = ~-(uint)(pvVar3 != (LPVOID)0x0) & 0xc;\n      param_2[0x28] =\n           (__crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing>)\n           (uVar6 == 0);\n      *(ulonglong *)(param_2 + 0x18) = (ulonglong)(uVar6 == 0);\n      if (uVar6 != 0) {\nLAB_140011844:\n        uVar7 = (ulonglong)uVar6;\n        goto LAB_140011909;\n      }\n    }\n    **(undefined2 **)(param_2 + 0x10) = 0;\n  }\n  *(undefined8 *)(param_2 + 0x20) = 0;\n  uVar7 = 0;\nLAB_140011909:\n  return (int)uVar7;\n}\n\n",
  "_FindPESection": "\n/* Library Function - Single Match\n    _FindPESection\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nPIMAGE_SECTION_HEADER __cdecl _FindPESection(PBYTE pImageBase,DWORD_PTR rva)\n\n{\n  int iVar1;\n  PIMAGE_SECTION_HEADER p_Var2;\n  uint uVar3;\n  \n  iVar1 = *(int *)(pImageBase + 0x3c);\n  uVar3 = 0;\n  p_Var2 = (PIMAGE_SECTION_HEADER)\n           (pImageBase +\n           (ulonglong)*(ushort *)(pImageBase + (longlong)iVar1 + 0x14) + 0x18 + (longlong)iVar1);\n  if (*(ushort *)(pImageBase + (longlong)iVar1 + 6) != 0) {\n    do {\n      if ((p_Var2->VirtualAddress <= rva) &&\n         (rva < (p_Var2->Misc).PhysicalAddress + p_Var2->VirtualAddress)) {\n        return p_Var2;\n      }\n      uVar3 = uVar3 + 1;\n      p_Var2 = p_Var2 + 1;\n    } while (uVar3 < *(ushort *)(pImageBase + (longlong)iVar1 + 6));\n  }\n  return (PIMAGE_SECTION_HEADER)0x0;\n}\n\n",
  "__acrt_MultiByteToWideChar": "\n/* Library Function - Single Match\n    __acrt_MultiByteToWideChar\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_MultiByteToWideChar\n               (UINT param_1,DWORD param_2,LPCSTR param_3,int param_4,LPWSTR param_5,int param_6)\n\n{\n  if (param_1 < 0xc436) {\n    if (((9 < param_1 - 0xc42c) || ((0x2a7U >> (param_1 - 0xc42c & 0x1f) & 1) == 0)) &&\n       (param_1 != 0x2a)) goto LAB_14001a553;\nLAB_14001a524:\n    param_2 = 0;\n  }\n  else {\n    if (param_1 != 0xd698) {\n      if (param_1 < 0xdeaa) goto LAB_14001a553;\n      if ((param_1 < 0xdeb4) || (param_1 == 65000)) goto LAB_14001a524;\n      if (param_1 != 0xfde9) goto LAB_14001a553;\n    }\n    param_2 = param_2 & 8;\n  }\nLAB_14001a553:\n                    /* WARNING: Could not recover jumptable at 0x00014001a553. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  MultiByteToWideChar(param_1,param_2,param_3,param_4,param_5,param_6);\n  return;\n}\n\n",
  "FUN_1400061a8": "\nundefined8 FUN_1400061a8(void)\n\n{\n  FUN_140006aa0();\n  return 0;\n}\n\n",
  "FUN_140002d00": "\nlonglong ** FUN_140002d00(longlong **param_1,longlong *param_2)\n\n{\n  longlong *plVar1;\n  longlong lVar2;\n  bool bVar3;\n  \n  *param_1 = param_2;\n  lVar2 = *param_2;\n  plVar1 = *(longlong **)((longlong)*(int *)(lVar2 + 4) + 0x48 + (longlong)param_2);\n  if (plVar1 != (longlong *)0x0) {\n    (**(code **)(*plVar1 + 8))();\n    lVar2 = *param_2;\n  }\n  if (*(int *)((longlong)*(int *)(lVar2 + 4) + 0x10 + (longlong)param_2) == 0) {\n    plVar1 = *(longlong **)((longlong)*(int *)(lVar2 + 4) + 0x50 + (longlong)param_2);\n    if ((plVar1 == (longlong *)0x0) || (plVar1 == param_2)) {\n      bVar3 = true;\n    }\n    else {\n      FUN_140002dd0(plVar1);\n      bVar3 = *(int *)((longlong)*(int *)(*param_2 + 4) + 0x10 + (longlong)param_2) == 0;\n    }\n  }\n  else {\n    bVar3 = false;\n  }\n  *(bool *)(param_1 + 1) = bVar3;\n  return param_1;\n}\n\n",
  "_close_nolock": "\n/* Library Function - Single Match\n    _close_nolock\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _close_nolock(int _FileHandle)\n\n{\n  BOOL BVar1;\n  DWORD DVar2;\n  int iVar3;\n  intptr_t iVar4;\n  intptr_t iVar5;\n  HANDLE hObject;\n  \n  iVar4 = _get_osfhandle(_FileHandle);\n  if (iVar4 != -1) {\n    if (((_FileHandle == 1) && ((*(byte *)(DAT_140037490 + 200) & 1) != 0)) ||\n       ((_FileHandle == 2 && ((*(byte *)(DAT_140037490 + 0x80) & 1) != 0)))) {\n      iVar4 = _get_osfhandle(2);\n      iVar5 = _get_osfhandle(1);\n      if (iVar5 == iVar4) goto LAB_14001624e;\n    }\n    hObject = (HANDLE)_get_osfhandle(_FileHandle);\n    BVar1 = CloseHandle(hObject);\n    if (BVar1 == 0) {\n      DVar2 = GetLastError();\n      goto LAB_1400162ac;\n    }\n  }\nLAB_14001624e:\n  DVar2 = 0;\nLAB_1400162ac:\n  _free_osfhnd(_FileHandle);\n  *(undefined *)\n   ((&DAT_140037490)[(longlong)_FileHandle >> 6] + 0x38 + (ulonglong)(_FileHandle & 0x3f) * 0x48) =\n       0;\n  if (DVar2 == 0) {\n    iVar3 = 0;\n  }\n  else {\n    __acrt_errno_map_os_error(DVar2);\n    iVar3 = -1;\n  }\n  return iVar3;\n}\n\n",
  "__acrt_update_thread_multibyte_data": "\n/* Library Function - Single Match\n    __acrt_update_thread_multibyte_data\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_update_thread_multibyte_data(void)\n\n{\n  __acrt_ptd *p_Var1;\n  \n  p_Var1 = (__acrt_ptd *)FUN_140014d84();\n  update_thread_multibyte_data_internal(p_Var1,(__crt_multibyte_data **)&DAT_1400379c0);\n  return;\n}\n\n",
  "GetLcidFromLangCountry": "\n/* Library Function - Single Match\n    GetLcidFromLangCountry\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid GetLcidFromLangCountry(uint *param_1)\n\n{\n  short sVar1;\n  uint uVar2;\n  longlong lVar3;\n  short *psVar4;\n  int iVar5;\n  longlong lVar6;\n  longlong lVar7;\n  int iVar8;\n  \n  lVar3 = FUN_140014d84();\n  lVar6 = -1;\n  lVar7 = -1;\n  iVar8 = 0;\n  do {\n    lVar7 = lVar7 + 1;\n  } while ((*(short **)(lVar3 + 0x98))[lVar7] != 0);\n  *(uint *)(lVar3 + 0xb0) = (uint)(lVar7 == 3);\n  do {\n    lVar6 = lVar6 + 1;\n  } while (*(short *)(*(longlong *)(lVar3 + 0xa0) + lVar6 * 2) != 0);\n  *(uint *)(lVar3 + 0xb4) = (uint)(lVar6 == 3);\n  param_1[1] = 0;\n  iVar5 = 2;\n  if (*(int *)(lVar3 + 0xb0) == 0) {\n    psVar4 = *(short **)(lVar3 + 0x98);\n    while( true ) {\n      sVar1 = *psVar4;\n      psVar4 = psVar4 + 1;\n      if ((0x19 < (ushort)(sVar1 - 0x41U)) && (iVar5 = iVar8, 0x19 < (ushort)(sVar1 - 0x61U)))\n      break;\n      iVar8 = iVar8 + 1;\n    }\n  }\n  *(int *)(lVar3 + 0xac) = iVar5;\n  EnumSystemLocalesW((LOCALE_ENUMPROCW)&LAB_14001e71c,1);\n  uVar2 = *param_1;\n  if ((uVar2 >> 8 & 1) == 0 || ((uVar2 & 7) == 0 || (uVar2 >> 9 & 1) == 0)) {\n    *param_1 = 0;\n  }\n  return;\n}\n\n",
  "fclose": "\n/* Library Function - Single Match\n    fclose\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl fclose(FILE *_File)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  \n  if (_File == (FILE *)0x0) {\n    puVar2 = __doserrno();\n    *puVar2 = 0x16;\n    FUN_14000d030();\n  }\n  else {\n    if ((*(uint *)((longlong)&_File->_base + 4) >> 0xc & 1) == 0) {\n      FUN_14000d384((longlong)_File);\n      iVar1 = _fclose_nolock(_File);\n      FUN_14000d390((longlong)_File);\n      return iVar1;\n    }\n    __acrt_stdio_free_stream(&_File->_ptr);\n  }\n  return -1;\n}\n\n",
  "__crtLCMapStringA": "\n/* WARNING: Function: __chkstk replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    __crtLCMapStringA\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\n__crtLCMapStringA(_locale_t _Plocinfo,LPCWSTR _LocaleName,DWORD _DwMapFlag,LPCSTR _LpSrcStr,\n                 int _CchSrc,LPSTR _LpDestStr,int _CchDest,int _Code_page,BOOL _BError)\n\n{\n  longlong lVar1;\n  DWORD dwMapFlags;\n  _locale_t lpLocaleName;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  size_t sVar5;\n  ulonglong uVar6;\n  LPCWSTR lpSrcStr;\n  LPCWSTR lpWideCharStr;\n  ulonglong uVar7;\n  undefined *puVar8;\n  undefined *puVar9;\n  undefined *puVar10;\n  undefined *puVar11;\n  undefined4 in_register_00000084;\n  char *_String;\n  undefined4 in_stack_0000002c;\n  undefined auStackY_78 [32];\n  _locale_t local_28;\n  ulonglong local_20;\n  \n  _String = (char *)CONCAT44(in_register_00000084,_DwMapFlag);\n  puVar8 = auStackY_78;\n  puVar10 = auStackY_78;\n  local_20 = DAT_140035020 ^ (ulonglong)&local_28;\n  iVar3 = (int)_LpSrcStr;\n  dwMapFlags = (DWORD)_LocaleName;\n  iVar4 = iVar3;\n  local_28 = _Plocinfo;\n  if (0 < iVar3) {\n    sVar5 = __strncnt(_String,(longlong)iVar3);\n    iVar2 = (int)sVar5;\n    iVar4 = iVar2 + 1;\n    if (iVar3 <= iVar2) {\n      iVar4 = iVar2;\n    }\n  }\n  iVar3 = MultiByteToWideChar(_CchDest,(-(uint)(_Code_page != 0) & 8) + 1,_String,iVar4,(LPWSTR)0x0,\n                              0);\n  puVar11 = auStackY_78;\n  if (iVar3 == 0) goto LAB_140006023;\n  uVar6 = (longlong)iVar3 * 2 + 0x10;\n  uVar6 = -(ulonglong)((ulonglong)((longlong)iVar3 * 2) < uVar6) & uVar6;\n  if (uVar6 == 0) {\n    lpSrcStr = (LPCWSTR)0x0;\nLAB_14000600b:\n    puVar11 = puVar10;\n    if (lpSrcStr == (LPCWSTR)0x0) goto LAB_140006023;\n  }\n  else {\n    if (uVar6 < 0x401) {\n      uVar7 = uVar6 + 0xf;\n      if (uVar7 <= uVar6) {\n        uVar7 = 0xffffffffffffff0;\n      }\n      lVar1 = -(uVar7 & 0xfffffffffffffff0);\n      puVar8 = auStackY_78 + lVar1;\n      lpSrcStr = (LPCWSTR)((longlong)&local_28 + lVar1);\n      puVar10 = auStackY_78 + lVar1;\n      if (lpSrcStr != (LPCWSTR)0x0) {\n        *(undefined4 *)lpSrcStr = 0xcccc;\nLAB_140005e3e:\n        lpSrcStr = lpSrcStr + 8;\n        puVar10 = puVar8;\n      }\n    }\n    else {\n      lpSrcStr = (LPCWSTR)_malloc_base(uVar6);\n      puVar10 = auStackY_78;\n      if (lpSrcStr != (LPCWSTR)0x0) {\n        *(undefined4 *)lpSrcStr = 0xdddd;\n        goto LAB_140005e3e;\n      }\n    }\n    if (lpSrcStr == (LPCWSTR)0x0) goto LAB_14000600b;\n    *(int *)(puVar10 + 0x28) = iVar3;\n    *(LPCWSTR *)(puVar10 + 0x20) = lpSrcStr;\n    *(undefined8 *)(puVar10 + -8) = 0x140005e6c;\n    iVar4 = MultiByteToWideChar(_CchDest,1,_String,iVar4,*(LPWSTR *)(puVar10 + 0x20),\n                                *(int *)(puVar10 + 0x28));\n    if (iVar4 == 0) goto LAB_14000600b;\n    *(undefined8 *)(puVar10 + 0x40) = 0;\n    *(undefined8 *)(puVar10 + 0x38) = 0;\n    *(undefined8 *)(puVar10 + 0x30) = 0;\n    lpLocaleName = local_28;\n    *(undefined4 *)(puVar10 + 0x28) = 0;\n    *(undefined8 *)(puVar10 + 0x20) = 0;\n    *(undefined8 *)(puVar10 + -8) = 0x140005ea7;\n    iVar4 = LCMapStringEx((LPCWSTR)lpLocaleName,dwMapFlags,lpSrcStr,iVar3,\n                          *(LPWSTR *)(puVar10 + 0x20),*(int *)(puVar10 + 0x28),\n                          *(LPNLSVERSIONINFO *)(puVar10 + 0x30),*(LPVOID *)(puVar10 + 0x38),\n                          *(LPARAM *)(puVar10 + 0x40));\n    if (iVar4 == 0) goto LAB_14000600b;\n    if (((ulonglong)_LocaleName & 0x400) == 0) {\n      uVar6 = (longlong)iVar4 * 2 + 0x10;\n      uVar6 = -(ulonglong)((ulonglong)((longlong)iVar4 * 2) < uVar6) & uVar6;\n      if (uVar6 != 0) {\n        if (uVar6 < 0x401) {\n          uVar7 = uVar6 + 0xf;\n          if (uVar7 <= uVar6) {\n            uVar7 = 0xffffffffffffff0;\n          }\n          *(undefined8 *)(puVar10 + -8) = 0x140005f47;\n          lVar1 = -(uVar7 & 0xfffffffffffffff0);\n          puVar9 = puVar10 + lVar1;\n          lpWideCharStr = (LPCWSTR)(puVar10 + lVar1 + 0x50);\n          puVar10 = puVar10 + lVar1;\n          if (lpWideCharStr == (LPCWSTR)0x0) goto LAB_140006010;\n          *(undefined4 *)lpWideCharStr = 0xcccc;\n          puVar10 = puVar9;\nLAB_140005f73:\n          lpWideCharStr = lpWideCharStr + 8;\n        }\n        else {\n          *(undefined8 *)(puVar10 + -8) = 0x140005f65;\n          lpWideCharStr = (LPCWSTR)_malloc_base(uVar6);\n          if (lpWideCharStr != (LPCWSTR)0x0) {\n            *(undefined4 *)lpWideCharStr = 0xdddd;\n            goto LAB_140005f73;\n          }\n        }\n        if (lpWideCharStr != (LPCWSTR)0x0) {\n          *(undefined8 *)(puVar10 + 0x40) = 0;\n          *(undefined8 *)(puVar10 + 0x38) = 0;\n          *(undefined8 *)(puVar10 + 0x30) = 0;\n          *(int *)(puVar10 + 0x28) = iVar4;\n          *(LPCWSTR *)(puVar10 + 0x20) = lpWideCharStr;\n          *(undefined8 *)(puVar10 + -8) = 0x140005fad;\n          iVar3 = LCMapStringEx((LPCWSTR)lpLocaleName,dwMapFlags,lpSrcStr,iVar3,\n                                *(LPWSTR *)(puVar10 + 0x20),*(int *)(puVar10 + 0x28),\n                                *(LPNLSVERSIONINFO *)(puVar10 + 0x30),*(LPVOID *)(puVar10 + 0x38),\n                                *(LPARAM *)(puVar10 + 0x40));\n          if (iVar3 != 0) {\n            *(undefined8 *)(puVar10 + 0x38) = 0;\n            *(undefined8 *)(puVar10 + 0x30) = 0;\n            if ((int)_LpDestStr == 0) {\n              *(undefined4 *)(puVar10 + 0x28) = 0;\n              *(undefined8 *)(puVar10 + 0x20) = 0;\n            }\n            else {\n              *(int *)(puVar10 + 0x28) = (int)_LpDestStr;\n              *(ulonglong *)(puVar10 + 0x20) = CONCAT44(in_stack_0000002c,_CchSrc);\n            }\n            *(undefined8 *)(puVar10 + -8) = 0x140005fef;\n            WideCharToMultiByte(_CchDest,0,lpWideCharStr,iVar4,*(LPSTR *)(puVar10 + 0x20),\n                                *(int *)(puVar10 + 0x28),*(LPCSTR *)(puVar10 + 0x30),\n                                *(LPBOOL *)(puVar10 + 0x38));\n          }\n          if (*(int *)(lpWideCharStr + -8) == 0xdddd) {\n            *(undefined8 *)(puVar10 + -8) = 0x140006002;\n            FUN_14000ce08(lpWideCharStr + -8);\n          }\n        }\n      }\n    }\n    else if ((int)_LpDestStr != 0) {\n      if (iVar4 <= (int)_LpDestStr) {\n        *(undefined8 *)(puVar10 + 0x40) = 0;\n        *(undefined8 *)(puVar10 + 0x38) = 0;\n        *(undefined8 *)(puVar10 + 0x30) = 0;\n        *(int *)(puVar10 + 0x28) = (int)_LpDestStr;\n        *(ulonglong *)(puVar10 + 0x20) = CONCAT44(in_stack_0000002c,_CchSrc);\n        *(undefined8 *)(puVar10 + -8) = 0x140005f00;\n        iVar4 = LCMapStringEx((LPCWSTR)lpLocaleName,dwMapFlags,lpSrcStr,iVar3,\n                              *(LPWSTR *)(puVar10 + 0x20),*(int *)(puVar10 + 0x28),\n                              *(LPNLSVERSIONINFO *)(puVar10 + 0x30),*(LPVOID *)(puVar10 + 0x38),\n                              *(LPARAM *)(puVar10 + 0x40));\n        if (iVar4 != 0) goto LAB_140006010;\n      }\n      goto LAB_14000600b;\n    }\n  }\nLAB_140006010:\n  puVar11 = puVar10;\n  if (*(int *)(lpSrcStr + -8) == 0xdddd) {\n    *(undefined8 *)(puVar10 + -8) = 0x140006021;\n    FUN_14000ce08(lpSrcStr + -8);\n  }\nLAB_140006023:\n  uVar6 = local_20 ^ (ulonglong)&local_28;\n  *(undefined8 *)(puVar11 + -8) = 0x14000602f;\n  iVar4 = FUN_140006060(uVar6);\n  return iVar4;\n}\n\n",
  "FUN_140001430": "\nlonglong FUN_140001430(longlong param_1,int *param_2,int param_3)\n\n{\n  uint7 uVar1;\n  \n  uVar1 = (uint7)((ulonglong)*(longlong *)(param_2 + 2) >> 8);\n  if ((*(longlong *)(param_1 + 8) == *(longlong *)(*(longlong *)(param_2 + 2) + 8)) &&\n     (*param_2 == param_3)) {\n    return CONCAT71(uVar1,1);\n  }\n  return (ulonglong)uVar1 << 8;\n}\n\n",
  "FUN_140002520": "\nlonglong ** FUN_140002520(longlong **param_1,undefined8 *param_2,longlong *param_3)\n\n{\n  longlong *plVar1;\n  code *pcVar2;\n  void *pvVar3;\n  longlong **pplVar4;\n  longlong *plVar5;\n  __uint64 _Var6;\n  longlong *plVar7;\n  longlong *plVar8;\n  \n  plVar1 = param_1[3];\n  if (param_3 <= plVar1) {\n    pplVar4 = param_1;\n    if ((longlong *)0xf < plVar1) {\n      pplVar4 = (longlong **)*param_1;\n    }\n    param_1[2] = param_3;\n    FUN_140007ed0(pplVar4,param_2,(ulonglong)param_3);\n    *(undefined *)((longlong)param_3 + (longlong)pplVar4) = 0;\n    return param_1;\n  }\n  if ((longlong *)0x7fffffffffffffff < param_3) {\n    FUN_140001380();\n    pcVar2 = (code *)swi(3);\n    pplVar4 = (longlong **)(*pcVar2)();\n    return pplVar4;\n  }\n  plVar5 = (longlong *)((ulonglong)param_3 | 0xf);\n  plVar8 = (longlong *)0x7fffffffffffffff;\n  if (((plVar5 < (longlong *)0x8000000000000000) &&\n      (plVar1 <= (longlong *)(0x7fffffffffffffff - ((ulonglong)plVar1 >> 1)))) &&\n     (plVar7 = (longlong *)(((ulonglong)plVar1 >> 1) + (longlong)plVar1), plVar8 = plVar5,\n     plVar5 < plVar7)) {\n    plVar8 = plVar7;\n  }\n  _Var6 = (longlong)plVar8 + 1;\n  if (plVar8 == (longlong *)0xffffffffffffffff) {\n    _Var6 = 0xffffffffffffffff;\n  }\n  if (_Var6 < 0x1000) {\n    if (_Var6 == 0) {\n      plVar5 = (longlong *)0x0;\n    }\n    else {\n      plVar5 = (longlong *)operator_new(_Var6);\n    }\n  }\n  else {\n    if (_Var6 + 0x27 <= _Var6) {\n      FUN_1400012e0();\n      pcVar2 = (code *)swi(3);\n      pplVar4 = (longlong **)(*pcVar2)();\n      return pplVar4;\n    }\n    pvVar3 = operator_new(_Var6 + 0x27);\n    if (pvVar3 == (void *)0x0) goto LAB_140002670;\n    plVar5 = (longlong *)((longlong)pvVar3 + 0x27U & 0xffffffffffffffe0);\n    plVar5[-1] = (longlong)pvVar3;\n  }\n  param_1[2] = param_3;\n  param_1[3] = plVar8;\n  FUN_140007ed0(plVar5,param_2,(ulonglong)param_3);\n  *(undefined *)((longlong)param_3 + (longlong)plVar5) = 0;\n  if ((longlong *)0xf < plVar1) {\n    plVar8 = *param_1;\n    plVar7 = plVar8;\n    if ((0xfff < (longlong)plVar1 + 1U) &&\n       (plVar7 = (longlong *)plVar8[-1],\n       0x1f < (ulonglong)((longlong)plVar8 + (-8 - (longlong)plVar7)))) {\nLAB_140002670:\n      FUN_14000d050();\n      pcVar2 = (code *)swi(3);\n      pplVar4 = (longlong **)(*pcVar2)();\n      return pplVar4;\n    }\n    thunk_FUN_14000ce08(plVar7);\n  }\n  *param_1 = plVar5;\n  return param_1;\n}\n\n",
  "FUN_14001fb2c": "\nulonglong FUN_14001fb2c(ulonglong param_1)\n\n{\n  return param_1 | 0x8000000000000;\n}\n\n",
  "FUN_140022476": "\nvoid FUN_140022476(_EXCEPTION_POINTERS *param_1,longlong param_2)\n\n{\n  *(_EXCEPTION_POINTERS **)(param_2 + 0x58) = param_1;\n  ExFilterRethrow(param_1,*(EHExceptionRecord **)(param_2 + 0xb8),(int *)(param_2 + 0x20));\n  return;\n}\n\n",
  "__acrt_execute_uninitializers": "\n/* Library Function - Single Match\n    __acrt_execute_uninitializers\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 __acrt_execute_uninitializers(longlong param_1,longlong param_2)\n\n{\n  longlong in_RAX;\n  \n  if (param_1 != param_2) {\n    do {\n      in_RAX = *(longlong *)(param_2 + -8);\n      if (in_RAX != 0) {\n        in_RAX = (*(code *)PTR__guard_dispatch_icall_140023298)(0);\n      }\n      param_2 = param_2 + -0x10;\n    } while (param_2 != param_1);\n  }\n  return CONCAT71((int7)((ulonglong)in_RAX >> 8),1);\n}\n\n",
  "FUN_140014740": "\nundefined8 FUN_140014740(void)\n\n{\n  undefined8 uVar1;\n  \n  _initialize_onexit_table((longlong *)&DAT_140037290);\n  uVar1 = _initialize_onexit_table((longlong *)&DAT_1400372a8);\n  return CONCAT71((int7)((ulonglong)uVar1 >> 8),1);\n}\n\n",
  "_commit": "\n/* Library Function - Single Match\n    _commit\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _commit(int _FileHandle)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  int local_res8 [2];\n  __crt_seh_guarded_call<int> local_res10 [8];\n  int local_res18 [2];\n  int local_res20 [2];\n  int *local_18 [3];\n  \n  local_res8[0] = _FileHandle;\n  if (_FileHandle == -2) {\n    puVar2 = __doserrno();\n    *puVar2 = 9;\n  }\n  else {\n    if (((-1 < _FileHandle) && ((uint)_FileHandle < DAT_140037890)) &&\n       ((*(byte *)((&DAT_140037490)[(longlong)_FileHandle >> 6] + 0x38 +\n                  (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) != 0)) {\n      local_18[0] = local_res8;\n      local_res18[0] = _FileHandle;\n      local_res20[0] = _FileHandle;\n      iVar1 = __crt_seh_guarded_call<int>::\n              operator()<class_<lambda_a37b2b86f63e897a80ea819b0eb08c01>,class_<lambda_38ce7e780aa69e748d6df282ebc68efe>&___ptr64,class_<lambda_99fb1378e971ab6e7edea83e3a7a83a2>_>\n                        (local_res10,(<lambda_a37b2b86f63e897a80ea819b0eb08c01> *)local_res20,\n                         (<lambda_38ce7e780aa69e748d6df282ebc68efe> *)local_18,\n                         (<lambda_99fb1378e971ab6e7edea83e3a7a83a2> *)local_res18);\n      return iVar1;\n    }\n    puVar2 = __doserrno();\n    *puVar2 = 9;\n    FUN_14000d030();\n  }\n  return -1;\n}\n\n",
  "FUN_140001d20": "\nlonglong FUN_140001d20(undefined8 param_1,undefined8 *param_2,longlong param_3,undefined8 *param_4)\n\n{\n  FUN_140007ed0(param_4,param_2,param_3 - (longlong)param_2);\n  return param_3;\n}\n\n",
  "FUN_140011e6c": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_140011e6c(ulonglong param_1)\n\n{\n  byte bVar1;\n  \n  bVar1 = 0x40 - ((byte)DAT_140035020 & 0x3f) & 0x3f;\n  _DAT_140037108 = (param_1 >> bVar1 | param_1 << 0x40 - bVar1) ^ DAT_140035020;\n  return;\n}\n\n",
  "copy_and_add_argument_to_buffer<char>": "\n/* Library Function - Single Match\n    int __cdecl copy_and_add_argument_to_buffer<char>(char const * __ptr64 const,char const *\n   __ptr64 const,unsigned __int64,class `anonymous namespace'::argument_list<char> & __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\ncopy_and_add_argument_to_buffer<char>\n          (char *param_1,char *param_2,__uint64 param_3,argument_list<char> *param_4)\n\n{\n  errno_t eVar1;\n  char *_Dst;\n  LPVOID pvVar2;\n  char **ppcVar3;\n  longlong lVar4;\n  ulonglong uVar6;\n  int iVar7;\n  ulonglong _SizeInBytes;\n  longlong lVar5;\n  \n  iVar7 = 0;\n  lVar4 = -1;\n  do {\n    lVar5 = lVar4;\n    lVar4 = lVar5 + 1;\n  } while (param_1[lVar4] != '\\0');\n  uVar6 = lVar5 + 2;\n  if (~param_3 < uVar6) {\n    return 0xc;\n  }\n  _SizeInBytes = param_3 + 1 + uVar6;\n  _Dst = (char *)_calloc_base(_SizeInBytes,1);\n  if (((param_3 != 0) && (eVar1 = strncpy_s(_Dst,_SizeInBytes,param_2,param_3), eVar1 != 0)) ||\n     (eVar1 = strncpy_s(_Dst + param_3,_SizeInBytes - param_3,param_1,uVar6), eVar1 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n  }\n  ppcVar3 = *(char ***)(param_4 + 8);\n  if (ppcVar3 == *(char ***)(param_4 + 0x10)) {\n    if (*(longlong *)param_4 == 0) {\n      pvVar2 = _calloc_base(4,8);\n      *(LPVOID *)param_4 = pvVar2;\n      _free_base((LPVOID)0x0);\n      ppcVar3 = *(char ***)param_4;\n      if (ppcVar3 != (char **)0x0) {\n        *(char ***)(param_4 + 8) = ppcVar3;\n        *(char ***)(param_4 + 0x10) = ppcVar3 + 4;\n        goto LAB_14001aead;\n      }\n    }\n    else {\n      uVar6 = (longlong)*(char ***)(param_4 + 0x10) - *(longlong *)param_4 >> 3;\n      if (uVar6 < 0x8000000000000000) {\n        pvVar2 = _recalloc_base(*(LPVOID *)param_4,uVar6 * 2,8);\n        if (pvVar2 != (LPVOID)0x0) {\n          *(LPVOID *)param_4 = pvVar2;\n          *(LPVOID *)(param_4 + 8) = (LPVOID)((longlong)pvVar2 + uVar6 * 8);\n          *(LPVOID *)(param_4 + 0x10) = (LPVOID)((longlong)pvVar2 + uVar6 * 0x10);\n          _free_base((LPVOID)0x0);\n          ppcVar3 = *(char ***)(param_4 + 8);\n          goto LAB_14001aead;\n        }\n        _free_base((LPVOID)0x0);\n      }\n    }\n    _free_base(_Dst);\n    iVar7 = 0xc;\n  }\n  else {\nLAB_14001aead:\n    *ppcVar3 = _Dst;\n    *(longlong *)(param_4 + 8) = *(longlong *)(param_4 + 8) + 8;\n  }\n  _free_base((LPVOID)0x0);\n  return iVar7;\n}\n\n",
  "__acrt_locale_free_numeric": "\n/* Library Function - Single Match\n    __acrt_locale_free_numeric\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_locale_free_numeric(LPVOID *param_1)\n\n{\n  if (param_1 != (LPVOID *)0x0) {\n    if ((undefined *)*param_1 != PTR_DAT_140035190) {\n      _free_base(*param_1);\n    }\n    if ((undefined *)param_1[1] != PTR_DAT_140035198) {\n      _free_base(param_1[1]);\n    }\n    if ((undefined *)param_1[2] != PTR_DAT_1400351a0) {\n      _free_base(param_1[2]);\n    }\n    if ((undefined *)param_1[0xb] != PTR_DAT_1400351e8) {\n      _free_base(param_1[0xb]);\n    }\n    if ((undefined *)param_1[0xc] != PTR_DAT_1400351f0) {\n      _free_base(param_1[0xc]);\n    }\n  }\n  return;\n}\n\n",
  "TestDefaultLanguage": "\n/* Library Function - Single Match\n    TestDefaultLanguage\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 TestDefaultLanguage(uint param_1,int param_2)\n\n{\n  short sVar1;\n  short *psVar2;\n  int iVar3;\n  longlong lVar4;\n  undefined8 uVar5;\n  short *psVar6;\n  uint local_res8 [2];\n  \n  lVar4 = FUN_140014d84();\n  iVar3 = GetLocaleInfoW(param_1 & 0x3ff | 0x400,0x20000001,(LPWSTR)local_res8,2);\n  if (iVar3 == 0) {\nLAB_14001ec09:\n    uVar5 = 0;\n  }\n  else {\n    if ((param_1 != local_res8[0]) && (param_2 != 0)) {\n      psVar2 = *(short **)(lVar4 + 0x98);\n      iVar3 = 0;\n      sVar1 = *psVar2;\n      psVar6 = psVar2;\n      while ((psVar6 = psVar6 + 1, (ushort)(sVar1 - 0x41U) < 0x1a ||\n             ((ushort)(sVar1 - 0x61U) < 0x1a))) {\n        iVar3 = iVar3 + 1;\n        sVar1 = *psVar6;\n      }\n      lVar4 = -1;\n      do {\n        lVar4 = lVar4 + 1;\n      } while (psVar2[lVar4] != 0);\n      if (iVar3 == (int)lVar4) goto LAB_14001ec09;\n    }\n    uVar5 = 1;\n  }\n  return uVar5;\n}\n\n",
  "SetState": "\n/* Library Function - Single Match\n    public: static void __cdecl __FrameHandler3::SetState(unsigned __int64 * __ptr64,struct\n   _s_FuncInfo const * __ptr64,int)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl __FrameHandler3::SetState(__uint64 *param_1,_s_FuncInfo *param_2,int param_3)\n\n{\n  *(int *)((longlong)param_2->dispUnwindHelp + *param_1) = param_3;\n  return;\n}\n\n",
  "_statfp": "\n/* Library Function - Single Match\n    _statfp\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nuint _statfp(void)\n\n{\n  uint uVar1;\n  \n  uVar1 = _get_fpsr();\n  return uVar1 & 0x3f;\n}\n\n",
  "operator=": "\n/* Library Function - Single Match\n    public: class std::_Yarn<char> & __ptr64 __cdecl std::_Yarn<char>::operator=(char const *\n   __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\n_Yarn<char> * __thiscall std::_Yarn<char>::operator=(_Yarn<char> *this,char *param_1)\n\n{\n  char cVar1;\n  undefined8 *puVar2;\n  char *pcVar3;\n  \n  pcVar3 = *(char **)this;\n  if (pcVar3 != param_1) {\n    if (pcVar3 != (char *)0x0) {\n      FUN_14000ce08(pcVar3);\n    }\n    *(undefined8 *)this = 0;\n    if (param_1 != (char *)0x0) {\n      cVar1 = *param_1;\n      pcVar3 = param_1;\n      while (cVar1 != '\\0') {\n        pcVar3 = pcVar3 + 1;\n        cVar1 = *pcVar3;\n      }\n      puVar2 = (undefined8 *)_malloc_base((ulonglong)(pcVar3 + (1 - (longlong)param_1)));\n      *(undefined8 **)this = puVar2;\n      if (puVar2 != (undefined8 *)0x0) {\n        FUN_140007ed0(puVar2,(undefined8 *)param_1,(ulonglong)(pcVar3 + (1 - (longlong)param_1)));\n      }\n    }\n  }\n  return this;\n}\n\n",
  "FUN_140012950": "\nvoid FUN_140012950(int param_1)\n\n{\n  common_exit(param_1,0,0);\n  return;\n}\n\n",
  "parse_bcp47_code_page": "\n/* Library Function - Single Match\n    parse_bcp47_code_page\n   \n   Library: Visual Studio 2019 Release */\n\nuint parse_bcp47_code_page(longlong param_1,wchar_t **param_2)\n\n{\n  uint in_EAX;\n  uint uVar1;\n  errno_t eVar2;\n  \n  if (*(int *)(param_2 + 2) == 2) {\n    eVar2 = wcsncpy_s((wchar_t *)(param_1 + 0x100),0x10,*param_2,(rsize_t)param_2[1]);\n    if (eVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n      _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n    }\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = in_EAX & 0xffffff00;\n  }\n  return uVar1;\n}\n\n",
  "_read": "\n/* Library Function - Single Match\n    _read\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _read(int _FileHandle,void *_DstBuf,uint _MaxCharCount)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  \n  if (_FileHandle == -2) {\n    puVar2 = __doserrno();\n    *puVar2 = 0;\n    puVar2 = __doserrno();\n    *puVar2 = 9;\n    return -1;\n  }\n  if ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_140037890)) {\n    if ((*(byte *)((&DAT_140037490)[(longlong)_FileHandle >> 6] + 0x38 +\n                  (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) != 0) {\n      if (_MaxCharCount < 0x80000000) {\n        FID_conflict___acrt_lowio_lock_fh(_FileHandle);\n        iVar1 = -1;\n        if ((*(byte *)((&DAT_140037490)[(longlong)_FileHandle >> 6] + 0x38 +\n                      (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) == 0) {\n          puVar2 = __doserrno();\n          *puVar2 = 9;\n          puVar2 = __doserrno();\n          *puVar2 = 0;\n        }\n        else {\n          iVar1 = _read_nolock(_FileHandle,_DstBuf,_MaxCharCount);\n        }\n        FID_conflict___acrt_lowio_lock_fh(_FileHandle);\n        return iVar1;\n      }\n      puVar2 = __doserrno();\n      *puVar2 = 0;\n      puVar2 = __doserrno();\n      *puVar2 = 0x16;\n      goto LAB_140017fe7;\n    }\n  }\n  puVar2 = __doserrno();\n  *puVar2 = 0;\n  puVar2 = __doserrno();\n  *puVar2 = 9;\nLAB_140017fe7:\n  FUN_14000d030();\n  return -1;\n}\n\n",
  "FUN_1400079c4": "\nvoid FUN_1400079c4(longlong param_1)\n\n{\n  longlong lVar1;\n  longlong lVar2;\n  bool bVar3;\n  \n  lVar2 = FUN_140008b20();\n  if (param_1 == *(longlong *)(lVar2 + 0x58)) {\n    lVar2 = FUN_140008b20();\n    lVar2 = *(longlong *)(lVar2 + 0x58);\n    while (lVar2 != 0) {\n      lVar1 = *(longlong *)(lVar2 + 8);\n      bVar3 = param_1 == lVar2;\n      lVar2 = lVar1;\n      if (bVar3) {\n        lVar2 = FUN_140008b20();\n        *(longlong *)(lVar2 + 0x58) = lVar1;\n        return;\n      }\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "common_xtox<unsigned_long,wchar_t>": "\n/* Library Function - Single Match\n    int __cdecl common_xtox<unsigned long,wchar_t>(unsigned long,wchar_t * __ptr64 const,unsigned\n   __int64,unsigned int,bool)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl\ncommon_xtox<unsigned_long,wchar_t>\n          (ulong param_1,wchar_t *param_2,__uint64 param_3,uint param_4,bool param_5)\n\n{\n  wchar_t wVar1;\n  wchar_t *pwVar2;\n  short sVar3;\n  ulonglong uVar4;\n  ulong *puVar5;\n  int iVar6;\n  ulonglong uVar7;\n  wchar_t *pwVar8;\n  wchar_t *pwVar9;\n  \n  pwVar8 = param_2;\n  if (param_5) {\n    param_1 = -param_1;\n    *param_2 = L'-';\n    pwVar8 = param_2 + 1;\n  }\n  uVar7 = (ulonglong)param_5;\n  pwVar2 = pwVar8;\n  do {\n    pwVar9 = pwVar2;\n    uVar4 = (ulonglong)param_1;\n    param_1 = param_1 / param_4;\n    sVar3 = 0x57;\n    if ((uint)(uVar4 % (ulonglong)param_4) < 10) {\n      sVar3 = 0x30;\n    }\n    uVar7 = uVar7 + 1;\n    *pwVar9 = sVar3 + (short)(uVar4 % (ulonglong)param_4);\n  } while ((param_1 != 0) && (pwVar2 = pwVar9 + 1, uVar7 < param_3));\n  if (uVar7 < param_3) {\n    pwVar9[1] = L'\\0';\n    do {\n      wVar1 = *pwVar9;\n      *pwVar9 = *pwVar8;\n      pwVar9 = pwVar9 + -1;\n      *pwVar8 = wVar1;\n      pwVar8 = pwVar8 + 1;\n    } while (pwVar8 < pwVar9);\n    iVar6 = 0;\n  }\n  else {\n    *param_2 = L'\\0';\n    puVar5 = __doserrno();\n    iVar6 = 0x22;\n    *puVar5 = 0x22;\n    FUN_14000d030();\n  }\n  return iVar6;\n}\n\n",
  "__acrt_stdio_free_buffer_nolock": "\n/* Library Function - Single Match\n    __acrt_stdio_free_buffer_nolock\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_stdio_free_buffer_nolock(undefined8 *param_1)\n\n{\n  if (((*(uint *)((longlong)param_1 + 0x14) >> 0xd & 1) != 0) &&\n     ((*(uint *)((longlong)param_1 + 0x14) >> 6 & 1) != 0)) {\n    _free_base((LPVOID)param_1[1]);\n    LOCK();\n    *(uint *)((longlong)param_1 + 0x14) = *(uint *)((longlong)param_1 + 0x14) & 0xfffffebf;\n    UNLOCK();\n    param_1[1] = 0;\n    *param_1 = 0;\n    *(undefined4 *)(param_1 + 2) = 0;\n  }\n  return;\n}\n\n",
  "FUN_140022880": "\nbool FUN_140022880(int **param_1)\n\n{\n  return **param_1 == -0x3ffffffb;\n}\n\n",
  "__doserrno": "\n/* Library Function - Single Match\n    __doserrno\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nulong * __cdecl __doserrno(void)\n\n{\n  ulonglong uVar1;\n  ulong *puVar2;\n  \n  uVar1 = __acrt_getptd_noexit();\n  if (uVar1 == 0) {\n    puVar2 = &DAT_140035064;\n  }\n  else {\n    puVar2 = (ulong *)(uVar1 + 0x24);\n  }\n  return puVar2;\n}\n\n",
  "_CxxThrowException": "\n/* Library Function - Single Match\n    _CxxThrowException\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __stdcall _CxxThrowException(void *pExceptionObject,ThrowInfo *pThrowInfo)\n\n{\n  ULONG_PTR UVar1;\n  PVOID local_38;\n  ULONG_PTR local_30;\n  void *local_28;\n  ThrowInfo *local_20;\n  PVOID local_18;\n  \n  UVar1 = 0x19930520;\n  if ((pThrowInfo != (ThrowInfo *)0x0) && ((*(byte *)&pThrowInfo->attributes & 0x10) != 0)) {\n                    /* WARNING: Load size is inaccurate */\n    pThrowInfo = *(ThrowInfo **)(*(longlong *)(*pExceptionObject + -8) + 0x30);\n    (*(code *)PTR__guard_dispatch_icall_140023298)();\n  }\n  local_38 = RtlPcToFileHeader(pThrowInfo,&local_38);\n  if ((pThrowInfo != (ThrowInfo *)0x0) &&\n     (((*(byte *)&pThrowInfo->attributes & 8) != 0 || (local_38 == (PVOID)0x0)))) {\n    UVar1 = 0x1994000;\n  }\n  local_30 = UVar1;\n  local_28 = pExceptionObject;\n  local_20 = pThrowInfo;\n  local_18 = local_38;\n  RaiseException(0xe06d7363,1,4,&local_30);\n  return;\n}\n\n",
  "wcscat_s": "\n/* Library Function - Single Match\n    wcscat_s\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nerrno_t __cdecl wcscat_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src)\n\n{\n  wchar_t wVar1;\n  ulong *puVar2;\n  wchar_t *pwVar3;\n  ulong uVar4;\n  longlong lVar5;\n  \n  if ((_Dst != (wchar_t *)0x0) && (_SizeInWords != 0)) {\n    pwVar3 = _Dst;\n    if (_Src == (wchar_t *)0x0) {\n      *_Dst = L'\\0';\n    }\n    else {\n      do {\n        if (*pwVar3 == L'\\0') break;\n        pwVar3 = pwVar3 + 1;\n        _SizeInWords = _SizeInWords - 1;\n      } while (_SizeInWords != 0);\n      if (_SizeInWords != 0) {\n        lVar5 = (longlong)_Src - (longlong)pwVar3;\n        do {\n          wVar1 = *(wchar_t *)(lVar5 + (longlong)pwVar3);\n          *pwVar3 = wVar1;\n          pwVar3 = pwVar3 + 1;\n          if (wVar1 == L'\\0') break;\n          _SizeInWords = _SizeInWords - 1;\n        } while (_SizeInWords != 0);\n        if (_SizeInWords != 0) {\n          return 0;\n        }\n        *_Dst = L'\\0';\n        puVar2 = __doserrno();\n        uVar4 = 0x22;\n        goto LAB_14001a85b;\n      }\n      *_Dst = L'\\0';\n    }\n  }\n  puVar2 = __doserrno();\n  uVar4 = 0x16;\nLAB_14001a85b:\n  *puVar2 = uVar4;\n  FUN_14000d030();\n  return uVar4;\n}\n\n",
  "__acrt_stdio_flush_and_write_narrow_nolock": "\n/* Library Function - Single Match\n    __acrt_stdio_flush_and_write_narrow_nolock\n   \n   Library: Visual Studio 2019 Release */\n\nulonglong __acrt_stdio_flush_and_write_narrow_nolock(byte param_1,FILE *param_2)\n\n{\n  uint *puVar1;\n  bool bVar2;\n  int iVar3;\n  ulong *puVar4;\n  FILE *pFVar5;\n  \n  iVar3 = _fileno(param_2);\n  if ((*(uint *)((longlong)&param_2->_base + 4) & 6) == 0) {\n    puVar4 = __doserrno();\n    *puVar4 = 9;\n  }\n  else if ((*(uint *)((longlong)&param_2->_base + 4) >> 0xc & 1) == 0) {\n    if ((*(uint *)((longlong)&param_2->_base + 4) & 1) != 0) {\n      bVar2 = stream_is_at_end_of_file_nolock((longlong *)param_2);\n      *(undefined4 *)&param_2->_base = 0;\n      if (!bVar2) goto LAB_14001785f;\n      param_2->_ptr = *(char **)&param_2->_cnt;\n      LOCK();\n      puVar1 = (uint *)((longlong)&param_2->_base + 4);\n      *puVar1 = *puVar1 & 0xfffffffe;\n      UNLOCK();\n    }\n    LOCK();\n    puVar1 = (uint *)((longlong)&param_2->_base + 4);\n    *puVar1 = *puVar1 | 2;\n    UNLOCK();\n    LOCK();\n    puVar1 = (uint *)((longlong)&param_2->_base + 4);\n    *puVar1 = *puVar1 & 0xfffffff7;\n    UNLOCK();\n    *(undefined4 *)&param_2->_base = 0;\n    if (((*(uint *)((longlong)&param_2->_base + 4) & 0x4c0) == 0) &&\n       (((pFVar5 = (FILE *)__acrt_iob_func(1), param_2 != pFVar5 &&\n         (pFVar5 = (FILE *)__acrt_iob_func(2), param_2 != pFVar5)) ||\n        (iVar3 = _isatty(iVar3), iVar3 == 0)))) {\n      __acrt_stdio_allocate_buffer_nolock(&param_2->_ptr);\n    }\n    bVar2 = write_buffer_nolock<char>(param_1,param_2);\n    if (bVar2) {\n      return (ulonglong)param_1;\n    }\n  }\n  else {\n    puVar4 = __doserrno();\n    *puVar4 = 0x22;\n  }\nLAB_14001785f:\n  LOCK();\n  puVar1 = (uint *)((longlong)&param_2->_base + 4);\n  *puVar1 = *puVar1 | 0x10;\n  UNLOCK();\n  return 0xffffffff;\n}\n\n",
  "_ischartype_l": "\n/* Library Function - Single Match\n    _ischartype_l\n   \n   Library: Visual Studio 2019 Release */\n\nuint _ischartype_l(int param_1,uint param_2,_locale_t param_3)\n\n{\n  uint uVar1;\n  ushort *puVar2;\n  \n  uVar1 = 0;\n  if (param_3 == (_locale_t)0x0) {\n    puVar2 = __pctype_func();\n    if (param_1 + 1U < 0x101) {\n      uVar1 = puVar2[param_1] & param_2;\n    }\n  }\n  else if (param_1 + 1U < 0x101) {\n    uVar1 = *(ushort *)(*(longlong *)param_3->locinfo + (longlong)param_1 * 2) & param_2;\n  }\n  else if ((int)param_3->locinfo->lc_collate_cp < 2) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = _isctype_l(param_1,param_2,param_3);\n  }\n  return uVar1;\n}\n\n",
  "operator()<>": "\n/* Library Function - Multiple Matches With Same Base Name\n    public: unsigned __int64 __cdecl __crt_seh_guarded_call<unsigned __int64>::operator()<class\n   <lambda_2831f20263db5b546e098b45503eb778>,class <lambda_5856287d7ecd2be6c9197bb4007c3f6e> &\n   __ptr64,class <lambda_0838d7e100fbcbd261b69cfea6abb102> >(class\n   <lambda_2831f20263db5b546e098b45503eb778> && __ptr64,class\n   <lambda_5856287d7ecd2be6c9197bb4007c3f6e> & __ptr64,class\n   <lambda_0838d7e100fbcbd261b69cfea6abb102> && __ptr64) __ptr64\n    public: unsigned __int64 __cdecl __crt_seh_guarded_call<unsigned __int64>::operator()<class\n   <lambda_5d4c3fee44080f75d5d9762853974fe0>,class <lambda_532e024f4337e6fc7ad266c2bef9f4ed> &\n   __ptr64,class <lambda_c87bdc10097eb2402edb8ba9bdf0697b> >(class\n   <lambda_5d4c3fee44080f75d5d9762853974fe0> && __ptr64,class\n   <lambda_532e024f4337e6fc7ad266c2bef9f4ed> & __ptr64,class\n   <lambda_c87bdc10097eb2402edb8ba9bdf0697b> && __ptr64) __ptr64\n    public: unsigned __int64 __cdecl __crt_seh_guarded_call<unsigned __int64>::operator()<class\n   <lambda_bdbcead8b570fa3d5ec6d9679862a6e5>,class <lambda_96f4279ff90247a4c5c5d9824f56f8c1> &\n   __ptr64,class <lambda_4606be27f17b5e5579e09050fab91818> >(class\n   <lambda_bdbcead8b570fa3d5ec6d9679862a6e5> && __ptr64,class\n   <lambda_96f4279ff90247a4c5c5d9824f56f8c1> & __ptr64,class\n   <lambda_4606be27f17b5e5579e09050fab91818> && __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\n__uint64 operator()<>(undefined8 param_1,longlong *param_2,\n                     <lambda_5856287d7ecd2be6c9197bb4007c3f6e> *param_3,longlong *param_4)\n\n{\n  __uint64 _Var1;\n  \n  FUN_14000d384(*param_2);\n  _Var1 = <lambda_5856287d7ecd2be6c9197bb4007c3f6e>::operator()(param_3);\n  FUN_14000d390(*param_4);\n  return _Var1;\n}\n\n",
  "__GSHandlerCheckCommon": "\n/* Library Function - Single Match\n    __GSHandlerCheckCommon\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __GSHandlerCheckCommon(ulonglong param_1,longlong param_2,uint *param_3)\n\n{\n  ulonglong uVar1;\n  ulonglong uVar2;\n  \n  uVar2 = param_1;\n  if ((*(byte *)param_3 & 4) != 0) {\n    uVar2 = (longlong)(int)param_3[1] + param_1 & (longlong)(int)-param_3[2];\n  }\n  uVar1 = (ulonglong)*(uint *)(*(longlong *)(param_2 + 0x10) + 8);\n  if ((*(byte *)(uVar1 + 3 + *(longlong *)(param_2 + 8)) & 0xf) != 0) {\n    param_1 = param_1 + (*(byte *)(uVar1 + 3 + *(longlong *)(param_2 + 8)) & 0xfffffff0);\n  }\n  FUN_140006060(param_1 ^ *(ulonglong *)((longlong)(int)(*param_3 & 0xfffffff8) + uVar2));\n  return;\n}\n\n",
  "___lc_codepage_func": "\n/* Library Function - Single Match\n    ___lc_codepage_func\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nUINT __cdecl ___lc_codepage_func(void)\n\n{\n  longlong lVar1;\n  longlong local_res8 [4];\n  \n  lVar1 = FUN_140014d84();\n  local_res8[0] = *(longlong *)(lVar1 + 0x90);\n  __acrt_update_locale_info(lVar1,local_res8);\n  return *(UINT *)(local_res8[0] + 0xc);\n}\n\n",
  "FUN_140006c88": "\nvoid FUN_140006c88(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x000140006c8f. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)&LAB_140006c98);\n  return;\n}\n\n",
  "FUN_140005b98": "\nvoid FUN_140005b98(longlong param_1)\n\n{\n  longlong lVar1;\n  ulonglong uVar2;\n  _Lockit local_res8 [32];\n  \n  std::_Lockit::_Lockit(local_res8,2);\n  *(undefined8 *)(param_1 + 8) = 1;\n  uVar2 = 1;\n  do {\n    lVar1 = *(longlong *)(uVar2 * 8 + 0x140036530);\n    if ((lVar1 == 0) || (lVar1 == param_1)) break;\n    uVar2 = uVar2 + 1;\n    *(ulonglong *)(param_1 + 8) = uVar2;\n  } while (uVar2 < 8);\n  (&DAT_140036580)[uVar2] = (&DAT_140036580)[uVar2] + '\\x01';\n  *(longlong *)(uVar2 * 8 + 0x140036530) = param_1;\n  std::_Lockit::~_Lockit(local_res8);\n  return;\n}\n\n",
  "_wsetlocale_get_all": "\n/* Library Function - Single Match\n    _wsetlocale_get_all\n   \n   Library: Visual Studio 2019 Release */\n\nwchar_t * _wsetlocale_get_all(longlong param_1)\n\n{\n  int iVar1;\n  short sVar2;\n  short sVar3;\n  int *piVar4;\n  bool bVar5;\n  bool bVar6;\n  errno_t eVar7;\n  wchar_t *pwVar8;\n  wchar_t *_Dst;\n  short *psVar9;\n  longlong lVar10;\n  undefined **ppuVar11;\n  short **ppsVar12;\n  \n  pwVar8 = (wchar_t *)_malloc_base(0x6a6);\n  _Dst = pwVar8;\n  if (pwVar8 != (wchar_t *)0x0) {\n    _Dst = pwVar8 + 2;\n    *_Dst = L'\\0';\n    ppsVar12 = (short **)(param_1 + 0x48);\n    *(undefined4 *)pwVar8 = 1;\n    _wcscats(_Dst,0x351,3,PTR_u_LC_COLLATE_140027fc8);\n    ppuVar11 = &PTR_u_LC_COLLATE_140027fc8;\n    bVar6 = true;\n    do {\n      eVar7 = wcscat_s(_Dst,0x351,L\";\");\n      if (eVar7 != 0) {\n                    /* WARNING: Subroutine does not return */\n        _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n      }\n      psVar9 = *ppsVar12;\n      lVar10 = (longlong)ppsVar12[4] - (longlong)psVar9;\n      do {\n        sVar2 = *psVar9;\n        sVar3 = *(short *)((longlong)psVar9 + lVar10);\n        if (sVar2 != sVar3) break;\n        psVar9 = psVar9 + 1;\n      } while (sVar3 != 0);\n      bVar5 = false;\n      if (sVar2 == sVar3) {\n        bVar5 = bVar6;\n      }\n      ppuVar11 = ppuVar11 + 3;\n      ppsVar12 = ppsVar12 + 4;\n      _wcscats(_Dst,0x351,3,*ppuVar11);\n      bVar6 = bVar5;\n    } while ((longlong)ppuVar11 < 0x140028028);\n    if (bVar5) {\n      _free_base(pwVar8);\n      piVar4 = *(int **)(param_1 + 0x38);\n      if (piVar4 != (int *)0x0) {\n        LOCK();\n        iVar1 = *piVar4;\n        *piVar4 = *piVar4 + -1;\n        UNLOCK();\n        if (iVar1 == 1) {\n          _free_base(*(LPVOID *)(param_1 + 0x38));\n        }\n      }\n      piVar4 = *(int **)(param_1 + 0x30);\n      if (piVar4 != (int *)0x0) {\n        LOCK();\n        iVar1 = *piVar4;\n        *piVar4 = *piVar4 + -1;\n        UNLOCK();\n        if (iVar1 == 1) {\n          _free_base(*(LPVOID *)(param_1 + 0x30));\n        }\n      }\n      _Dst = *(wchar_t **)(param_1 + 0x68);\n      *(undefined8 *)(param_1 + 0x30) = 0;\n      *(undefined8 *)(param_1 + 0x20) = 0;\n      *(undefined8 *)(param_1 + 0x38) = 0;\n      *(undefined8 *)(param_1 + 0x28) = 0;\n    }\n    else {\n      piVar4 = *(int **)(param_1 + 0x38);\n      if (piVar4 != (int *)0x0) {\n        LOCK();\n        iVar1 = *piVar4;\n        *piVar4 = *piVar4 + -1;\n        UNLOCK();\n        if (iVar1 == 1) {\n          _free_base(*(LPVOID *)(param_1 + 0x38));\n        }\n      }\n      piVar4 = *(int **)(param_1 + 0x30);\n      if (piVar4 != (int *)0x0) {\n        LOCK();\n        iVar1 = *piVar4;\n        *piVar4 = *piVar4 + -1;\n        UNLOCK();\n        if (iVar1 == 1) {\n          _free_base(*(LPVOID *)(param_1 + 0x30));\n        }\n      }\n      *(undefined8 *)(param_1 + 0x30) = 0;\n      *(undefined8 *)(param_1 + 0x20) = 0;\n      *(wchar_t **)(param_1 + 0x38) = pwVar8;\n      *(wchar_t **)(param_1 + 0x28) = _Dst;\n    }\n  }\n  return _Dst;\n}\n\n",
  "__dcrt_get_narrow_environment_from_os": "\n/* Library Function - Single Match\n    __dcrt_get_narrow_environment_from_os\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nLPSTR __dcrt_get_narrow_environment_from_os(void)\n\n{\n  WCHAR WVar1;\n  int iVar2;\n  LPWCH pWVar3;\n  longlong lVar4;\n  LPSTR pCVar6;\n  int iVar7;\n  WCHAR *pWVar8;\n  LPSTR pCVar9;\n  LPSTR pCVar10;\n  longlong lVar5;\n  \n  pWVar3 = GetEnvironmentStringsW();\n  pCVar10 = (LPSTR)0x0;\n  if (pWVar3 != (LPWCH)0x0) {\n    WVar1 = *pWVar3;\n    pWVar8 = pWVar3;\n    while (WVar1 != L'\\0') {\n      lVar4 = -1;\n      do {\n        lVar5 = lVar4;\n        lVar4 = lVar5 + 1;\n      } while (pWVar8[lVar4] != L'\\0');\n      pWVar8 = pWVar8 + lVar5 + 2;\n      WVar1 = *pWVar8;\n    }\n    iVar7 = (int)((longlong)pWVar8 + (2 - (longlong)pWVar3) >> 1);\n    iVar2 = __acrt_WideCharToMultiByte(0,0,pWVar3,iVar7,(LPSTR)0x0,0,(LPBOOL)0x0,(LPBOOL)0x0);\n    if (iVar2 != 0) {\n      pCVar6 = (LPSTR)_malloc_base((longlong)iVar2);\n      pCVar9 = pCVar10;\n      if ((pCVar6 != (LPSTR)0x0) &&\n         (iVar2 = __acrt_WideCharToMultiByte(0,0,pWVar3,iVar7,pCVar6,iVar2,(LPBOOL)0x0,(LPBOOL)0x0),\n         iVar2 != 0)) {\n        pCVar9 = pCVar6;\n        pCVar6 = pCVar10;\n      }\n      _free_base(pCVar6);\n      pCVar10 = pCVar9;\n    }\n  }\n  if (pWVar3 != (LPWCH)0x0) {\n    FreeEnvironmentStringsW(pWVar3);\n  }\n  return pCVar10;\n}\n\n",
  "_configure_narrow_argv": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    _configure_narrow_argv\n   \n   Library: Visual Studio 2019 Release */\n\nint _configure_narrow_argv(int param_1)\n\n{\n  __uint64 _Var1;\n  int iVar2;\n  ulong *puVar3;\n  char **ppcVar4;\n  char **ppcVar5;\n  int iVar6;\n  char *pcVar7;\n  char **local_res10;\n  __uint64 local_res18;\n  __uint64 local_res20;\n  \n  iVar6 = 0;\n  if (param_1 != 0) {\n    if (param_1 - 1U < 2) {\n      __acrt_initialize_multibyte();\n      __acrt_GetModuleFileNameA((HMODULE)0x0,&DAT_140037110,0x104);\n      _DAT_140037250 = &DAT_140037110;\n      if ((DAT_140037270 == (char *)0x0) || (pcVar7 = DAT_140037270, *DAT_140037270 == '\\0')) {\n        pcVar7 = &DAT_140037110;\n      }\n      local_res18 = 0;\n      local_res20 = 0;\n      parse_command_line<char>(pcVar7,(char **)0x0,(char *)0x0,&local_res18,&local_res20);\n      _Var1 = local_res18;\n      ppcVar4 = (char **)__acrt_allocate_buffer_for_argv(local_res18,local_res20,1);\n      if (ppcVar4 == (char **)0x0) {\n        puVar3 = __doserrno();\n        iVar6 = 0xc;\n        *puVar3 = 0xc;\n        _free_base((LPVOID)0x0);\n      }\n      else {\n        parse_command_line<char>(pcVar7,ppcVar4,(char *)(ppcVar4 + _Var1),&local_res18,&local_res20)\n        ;\n        if (param_1 == 1) {\n          _DAT_140037258 = (int)local_res18 + -1;\n          ppcVar5 = (char **)0x0;\n          DAT_140037260 = ppcVar4;\n        }\n        else {\n          local_res10 = (char **)0x0;\n          iVar2 = common_expand_argv_wildcards<char>(ppcVar4,&local_res10);\n          ppcVar5 = local_res10;\n          if (iVar2 != 0) {\n            _free_base(local_res10);\n            local_res10 = (char **)0x0;\n            _free_base(ppcVar4);\n            return iVar2;\n          }\n          _DAT_140037258 = 0;\n          pcVar7 = *local_res10;\n          while (pcVar7 != (char *)0x0) {\n            local_res10 = local_res10 + 1;\n            _DAT_140037258 = _DAT_140037258 + 1;\n            pcVar7 = *local_res10;\n          }\n          local_res10 = (char **)0x0;\n          DAT_140037260 = ppcVar5;\n          _free_base((LPVOID)0x0);\n          local_res10 = (char **)0x0;\n          ppcVar5 = ppcVar4;\n        }\n        _free_base(ppcVar5);\n      }\n    }\n    else {\n      puVar3 = __doserrno();\n      iVar6 = 0x16;\n      *puVar3 = 0x16;\n      FUN_14000d030();\n    }\n  }\n  return iVar6;\n}\n\n",
  "translate_ansi_or_utf8_nolock": "\n/* Library Function - Single Match\n    int __cdecl translate_ansi_or_utf8_nolock(int,char * __ptr64 const,unsigned __int64,wchar_t *\n   __ptr64 const,unsigned __int64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\ntranslate_ansi_or_utf8_nolock\n          (int param_1,char *param_2,__uint64 param_3,wchar_t *param_4,__uint64 param_5)\n\n{\n  byte bVar1;\n  longlong lVar2;\n  int iVar3;\n  DWORD DVar4;\n  ulonglong uVar5;\n  ulong *puVar6;\n  uint uVar7;\n  ulonglong uVar8;\n  int iVar9;\n  byte *pbVar10;\n  byte *pbVar11;\n  longlong lVar12;\n  \n  iVar3 = translate_text_mode_nolock<char>(param_1,param_2,param_3);\n  if (iVar3 == 0) {\n    return 0;\n  }\n  uVar5 = (ulonglong)(param_1 & 0x3f);\n  lVar12 = (longlong)param_1 >> 6;\n  lVar2 = (&DAT_140037490)[lVar12];\n  if (*(char *)(lVar2 + 0x39 + uVar5 * 0x48) != '\\0') {\n    pbVar10 = (byte *)(param_2 + iVar3);\n    if ((char)pbVar10[-1] < '\\0') {\n      uVar8 = 1;\n      for (pbVar10 = pbVar10 + -1;\n          ((uVar7 = (uint)uVar8, (&DAT_140035420)[*pbVar10] == '\\0' && (uVar7 < 5)) &&\n          (param_2 <= pbVar10)); pbVar10 = pbVar10 + -1) {\n        uVar8 = (ulonglong)(uVar7 + 1);\n      }\n      if ((&DAT_140035420)[*pbVar10] == '\\0') {\n        puVar6 = __doserrno();\n        *puVar6 = 0x2a;\n        return -1;\n      }\n      if ((int)(char)(&DAT_140035420)[*pbVar10] + 1U == uVar7) {\n        pbVar10 = pbVar10 + uVar8;\n      }\n      else if ((*(byte *)(lVar2 + 0x38 + uVar5 * 0x48) & 0x48) == 0) {\n        common_lseek_nolock<__int64>(param_1,(longlong)(int)-uVar7,1);\n      }\n      else {\n        pbVar11 = pbVar10 + 1;\n        *(byte *)(lVar2 + 0x3a + uVar5 * 0x48) = *pbVar10;\n        if (1 < uVar7) {\n          bVar1 = *pbVar11;\n          pbVar11 = pbVar10 + 2;\n          *(byte *)((&DAT_140037490)[lVar12] + 0x3b + uVar5 * 0x48) = bVar1;\n        }\n        if (uVar7 == 3) {\n          bVar1 = *pbVar11;\n          pbVar11 = pbVar11 + 1;\n          *(byte *)((&DAT_140037490)[lVar12] + 0x3c + uVar5 * 0x48) = bVar1;\n        }\n        pbVar10 = pbVar11 + -uVar8;\n      }\n    }\n    iVar9 = (int)pbVar10 - (int)param_2;\n    iVar3 = __acrt_MultiByteToWideChar(0xfde9,0,param_2,iVar9,param_4,(int)param_5);\n    if (iVar3 == 0) {\n      DVar4 = GetLastError();\n      __acrt_errno_map_os_error(DVar4);\n      return -1;\n    }\n    lVar2 = (&DAT_140037490)[lVar12];\n    pbVar10 = (byte *)(lVar2 + 0x3d + uVar5 * 0x48);\n    *pbVar10 = *pbVar10 & 0xfd;\n    pbVar10 = (byte *)(lVar2 + 0x3d + uVar5 * 0x48);\n    *pbVar10 = *pbVar10 | -(iVar3 != iVar9) & 2U;\n    return iVar3 * 2;\n  }\n  return iVar3;\n}\n\n",
  "expand_argument_wildcards<char>": "\n/* Library Function - Single Match\n    int __cdecl expand_argument_wildcards<char>(char * __ptr64 const,char * __ptr64 const,class\n   `anonymous namespace'::argument_list<char> & __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\nexpand_argument_wildcards<char>(char *param_1,char *param_2,argument_list<char> *param_3)\n\n{\n  byte bVar1;\n  char *pcVar2;\n  BOOL BVar3;\n  int iVar4;\n  HANDLE hFindFile;\n  undefined8 uVar5;\n  LPCWSTR lpFileName;\n  char *pcVar6;\n  longlong lVar7;\n  uint uVar8;\n  byte bVar9;\n  longlong lVar10;\n  undefined auStackY_368 [32];\n  longlong local_338;\n  longlong local_330;\n  char local_320;\n  longlong local_318;\n  longlong local_310;\n  char local_300;\n  undefined8 local_2f8;\n  undefined8 local_2f0;\n  char *local_2e8;\n  undefined8 local_2e0;\n  undefined8 local_2d8;\n  char local_2d0;\n  undefined8 local_2c8;\n  undefined8 local_2c0;\n  LPCWSTR local_2b8;\n  undefined8 local_2b0;\n  undefined8 local_2a8;\n  char local_2a0;\n  _WIN32_FIND_DATAW local_298;\n  ulonglong local_48;\n  \n  local_48 = DAT_140035020 ^ (ulonglong)auStackY_368;\n  if (param_2 != param_1) {\n    do {\n      if (((byte)(*param_2 - 0x2fU) < 0x2e) &&\n         ((0x200000000801U >> ((longlong)(char)(*param_2 - 0x2fU) & 0x3fU) & 1) != 0)) break;\n      param_2 = (char *)FUN_140020450((byte *)param_1,(byte *)param_2);\n    } while (param_2 != param_1);\n  }\n  if ((*param_2 == 0x3a) && (param_2 != param_1 + 1)) {\n    copy_and_add_argument_to_buffer<char>(param_1,(char *)0x0,0,param_3);\n  }\n  else {\n    bVar9 = *param_2 - 0x2f;\n    if ((0x2d < bVar9) || (bVar1 = 1, (0x200000000801U >> ((longlong)(char)bVar9 & 0x3fU) & 1) == 0)\n       ) {\n      bVar1 = 0;\n    }\n    local_2c8 = 0;\n    local_2c0 = 0;\n    local_2b8 = (LPCWSTR)0x0;\n    local_2b0 = 0;\n    local_2a8 = 0;\n    local_2a0 = '\\0';\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_338,(__crt_locale_pointers *)0x0);\n    uVar8 = 0xfde9;\n    if (*(int *)(local_330 + 0xc) == 0xfde9) {\n      if (local_320 != '\\0') {\n        *(uint *)(local_338 + 0x3a8) = *(uint *)(local_338 + 0x3a8) & 0xfffffffd;\n      }\n    }\n    else {\n      uVar5 = __acrt_AreFileApisANSI();\n      if ((int)uVar5 == 0) {\n        if (local_320 != '\\0') {\n          *(uint *)(local_338 + 0x3a8) = *(uint *)(local_338 + 0x3a8) & 0xfffffffd;\n        }\n        uVar8 = 1;\n      }\n      else {\n        uVar8 = 0;\n        if (local_320 != '\\0') {\n          *(uint *)(local_338 + 0x3a8) = *(uint *)(local_338 + 0x3a8) & 0xfffffffd;\n        }\n      }\n    }\n    iVar4 = __acrt_mbs_to_wcs_cp<struct___crt_win32_buffer_internal_dynamic_resizing>\n                      (param_1,(__crt_win32_buffer<wchar_t,struct___crt_win32_buffer_internal_dynamic_resizing>\n                                *)&local_2c8,uVar8);\n    lpFileName = local_2b8;\n    if (iVar4 != 0) {\n      lpFileName = (LPCWSTR)0x0;\n    }\n    hFindFile = FindFirstFileExW(lpFileName,FindExInfoStandard,&local_298,FindExSearchNameMatch,\n                                 (LPVOID)0x0,0);\n    if (hFindFile == (HANDLE)0xffffffffffffffff) {\n      copy_and_add_argument_to_buffer<char>(param_1,(char *)0x0,0,param_3);\n    }\n    else {\n      lVar10 = *(longlong *)(param_3 + 8) - *(longlong *)param_3 >> 3;\n      do {\n        local_2f8 = 0;\n        local_2f0 = 0;\n        local_2e8 = (char *)0x0;\n        local_2e0 = 0;\n        local_2d8 = 0;\n        local_2d0 = '\\0';\n        _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_318,(__crt_locale_pointers *)0x0);\n        uVar8 = 0xfde9;\n        if (*(int *)(local_310 + 0xc) == 0xfde9) {\n          if (local_300 != '\\0') {\n            *(uint *)(local_318 + 0x3a8) = *(uint *)(local_318 + 0x3a8) & 0xfffffffd;\n          }\n        }\n        else {\n          uVar5 = __acrt_AreFileApisANSI();\n          if ((int)uVar5 == 0) {\n            if (local_300 != '\\0') {\n              *(uint *)(local_318 + 0x3a8) = *(uint *)(local_318 + 0x3a8) & 0xfffffffd;\n            }\n            uVar8 = 1;\n          }\n          else {\n            if (local_300 != '\\0') {\n              *(uint *)(local_318 + 0x3a8) = *(uint *)(local_318 + 0x3a8) & 0xfffffffd;\n            }\n            uVar8 = 0;\n          }\n        }\n        iVar4 = __acrt_wcs_to_mbs_cp<struct___crt_win32_buffer_internal_dynamic_resizing>\n                          (local_298.cFileName,\n                           (__crt_win32_buffer<char,struct___crt_win32_buffer_internal_dynamic_resizing>\n                            *)&local_2f8,uVar8);\n        pcVar2 = local_2e8;\n        pcVar6 = local_2e8;\n        if (iVar4 != 0) {\n          pcVar6 = (char *)0x0;\n        }\n        if (((*pcVar6 != '.') ||\n            ((pcVar6[1] != '\\0' && ((pcVar6[1] != '.' || (pcVar6[2] != '\\0')))))) &&\n           (iVar4 = copy_and_add_argument_to_buffer<char>\n                              (pcVar6,param_1,\n                               -(ulonglong)bVar1 &\n                               (ulonglong)((byte *)param_2 + (1 - (longlong)param_1)),param_3),\n           iVar4 != 0)) {\n          if (local_2d0 != '\\0') {\n            _free_base(pcVar2);\n          }\n          goto LAB_14001b196;\n        }\n        if (local_2d0 != '\\0') {\n          _free_base(pcVar2);\n        }\n        BVar3 = FindNextFileW(hFindFile,&local_298);\n      } while (BVar3 != 0);\n      lVar7 = *(longlong *)(param_3 + 8) - *(longlong *)param_3 >> 3;\n      if (lVar10 != lVar7) {\n        qsort((void *)(*(longlong *)param_3 + lVar10 * 8),lVar7 - lVar10,8,\n              (_PtFuncCompare *)&LAB_14001a998);\n      }\nLAB_14001b196:\n      FindClose(hFindFile);\n    }\n    if (local_2a0 != '\\0') {\n      _free_base(local_2b8);\n    }\n  }\n  iVar4 = FUN_140006060(local_48 ^ (ulonglong)auStackY_368);\n  return iVar4;\n}\n\n",
  "FUN_14000c214": "\nvoid FUN_14000c214(undefined4 param_1)\n\n{\n  longlong lVar1;\n  \n  lVar1 = FUN_140014d84();\n  *(undefined4 *)(lVar1 + 0x28) = param_1;\n  return;\n}\n\n",
  "fsetpos": "\n/* Library Function - Single Match\n    fsetpos\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl fsetpos(FILE *_File,fpos_t *_Pos)\n\n{\n  ulong *puVar1;\n  ulonglong uVar2;\n  \n  if ((_File != (FILE *)0x0) && (_Pos != (fpos_t *)0x0)) {\n    uVar2 = common_fseek(_File,*_Pos,0);\n    return (int)uVar2;\n  }\n  puVar1 = __doserrno();\n  *puVar1 = 0x16;\n  FUN_14000d030();\n  return -1;\n}\n\n",
  "__acrt_DownlevelLCIDToLocaleName": "\n/* Library Function - Single Match\n    __acrt_DownlevelLCIDToLocaleName\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __acrt_DownlevelLCIDToLocaleName(uint param_1,wchar_t *param_2,int param_3)\n\n{\n  undefined (*_Src) [32];\n  int iVar1;\n  int iVar2;\n  errno_t eVar3;\n  ulonglong uVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  \n  if (((((param_1 & 0xfffff3ff) != 0) || (param_1 == 0xc00)) &&\n      ((param_2 != (wchar_t *)0x0 || (param_3 < 1)))) && (-1 < param_3)) {\n    iVar6 = 0;\n    iVar7 = 0xe3;\n    do {\n      iVar2 = (iVar7 + iVar6) / 2;\n      iVar5 = param_1 - *(uint *)(&DAT_14002bdd0 + (longlong)iVar2 * 0x10);\n      if (param_1 == *(uint *)(&DAT_14002bdd0 + (longlong)iVar2 * 0x10)) goto LAB_14001f12a;\n      iVar1 = iVar2 + -1;\n      if (-1 < iVar5) {\n        iVar1 = iVar7;\n      }\n      iVar7 = iVar1;\n      if (-1 < iVar5) {\n        iVar6 = iVar2 + 1;\n      }\n    } while (iVar6 <= iVar7);\n    iVar2 = -1;\nLAB_14001f12a:\n    if (-1 < iVar2) {\n      _Src = *(undefined (**) [32])(&UNK_14002bdd8 + (longlong)iVar2 * 0x10);\n      uVar4 = FUN_140011a3c(_Src,0x55);\n      if (0 < param_3) {\n        if (param_3 <= (int)uVar4) {\n          return 0;\n        }\n        eVar3 = wcscpy_s(param_2,(longlong)param_3,(wchar_t *)_Src);\n        if (eVar3 != 0) {\n                    /* WARNING: Subroutine does not return */\n          _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n        }\n      }\n      return (int)uVar4 + 1;\n    }\n  }\n  return 0;\n}\n\n",
  "__acrt_uninitialize_stdio": "\n/* Library Function - Single Match\n    __acrt_uninitialize_stdio\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_uninitialize_stdio(bool param_1)\n\n{\n  longlong lVar1;\n  \n  common_flush_all(param_1);\n  _fcloseall();\n  lVar1 = 0;\n  do {\n    __acrt_stdio_free_buffer_nolock(*(undefined8 **)(lVar1 + (longlong)DAT_1400370e0));\n    DeleteCriticalSection\n              ((LPCRITICAL_SECTION)(*(longlong *)(lVar1 + (longlong)DAT_1400370e0) + 0x30));\n    lVar1 = lVar1 + 8;\n  } while (lVar1 != 0x18);\n  _free_base(DAT_1400370e0);\n  DAT_1400370e0 = (LPVOID)0x0;\n  return;\n}\n\n",
  "_recalloc_base": "\n/* Library Function - Single Match\n    _recalloc_base\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nLPVOID _recalloc_base(LPVOID param_1,ulonglong param_2,ulonglong param_3)\n\n{\n  ulong *puVar1;\n  ulonglong uVar2;\n  LPVOID pvVar3;\n  ulonglong uVar4;\n  \n  if ((param_2 == 0) || (param_3 <= 0xffffffffffffffe0 / param_2)) {\n    if (param_1 == (LPVOID)0x0) {\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = _msize_base((longlong)param_1);\n    }\n    uVar4 = param_2 * param_3;\n    pvVar3 = _realloc_base(param_1,uVar4);\n    if ((pvVar3 != (LPVOID)0x0) && (uVar2 < uVar4)) {\n      FUN_140008580((undefined (*) [16])((longlong)pvVar3 + uVar2),0,uVar4 - uVar2);\n    }\n  }\n  else {\n    puVar1 = __doserrno();\n    *puVar1 = 0xc;\n    pvVar3 = (LPVOID)0x0;\n  }\n  return pvVar3;\n}\n\n",
  "__std_type_info_compare": "\n/* Library Function - Single Match\n    __std_type_info_compare\n   \n   Library: Visual Studio 2019 Release */\n\nuint __std_type_info_compare(longlong param_1,longlong param_2)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  longlong lVar3;\n  \n  if (param_1 != param_2) {\n    pbVar2 = (byte *)(param_1 + 9);\n    lVar3 = (param_2 + 9) - (longlong)pbVar2;\n    do {\n      bVar1 = *pbVar2;\n      if (bVar1 != pbVar2[lVar3]) {\n        return -(uint)(bVar1 < pbVar2[lVar3]) | 1;\n      }\n      pbVar2 = pbVar2 + 1;\n    } while (bVar1 != 0);\n  }\n  return 0;\n}\n\n",
  "_wtol": "\n/* Library Function - Single Match\n    _wtol\n   \n   Library: Visual Studio 2019 Release */\n\nlong __cdecl _wtol(wchar_t *_Str)\n\n{\n  uint uVar1;\n  wchar_t *local_18;\n  undefined8 local_10;\n  \n  local_10 = 0;\n  local_18 = _Str;\n  uVar1 = __crt_strtox::\n          parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<wchar_t>_>\n                    ((__crt_locale_pointers *)0x0,(wint_t **)&local_18,10,1);\n  return uVar1;\n}\n\n",
  "__except_validate_context_record": "\n/* Library Function - Single Match\n    __except_validate_context_record\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __except_validate_context_record(longlong param_1)\n\n{\n  code *pcVar1;\n  \n  if ((code *)PTR__guard_check_icall_140023288 != _guard_check_icall) {\n    if ((*(ulonglong *)(param_1 + 0x98) < *(ulonglong *)((longlong)Self + 0x10)) ||\n       (*(ulonglong *)((longlong)Self + 8) < *(ulonglong *)(param_1 + 0x98))) {\n      pcVar1 = (code *)swi(0x29);\n      (*pcVar1)(0xd);\n    }\n  }\n  return;\n}\n\n",
  "_fclrf": "\n/* Library Function - Single Match\n    _fclrf\n   \n   Library: Visual Studio */\n\nvoid _fclrf(void)\n\n{\n  MXCSR = MXCSR & 0xffffffc0;\n  return;\n}\n\n",
  "FUN_14000cf78": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_14000cf78(undefined8 param_1)\n\n{\n  _DAT_140036e90 = param_1;\n  return;\n}\n\n",
  "fread": "\n/* Library Function - Single Match\n    fread\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nsize_t __cdecl fread(void *_DstBuf,size_t _ElementSize,size_t _Count,FILE *_File)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread_s(_DstBuf,0xffffffffffffffff,_ElementSize,_Count,_File);\n  return sVar1;\n}\n\n",
  "FUN_140001ac0": "\nundefined8 FUN_140001ac0(longlong *param_1,longlong param_2)\n\n{\n  longlong lVar1;\n  code *pcVar2;\n  UINT UVar3;\n  UINT UVar4;\n  UINT UVar5;\n  undefined8 *puVar6;\n  UINT *pUVar7;\n  undefined8 uVar8;\n  char *pcVar9;\n  _Lockit local_a8 [8];\n  LPVOID local_a0;\n  undefined local_98;\n  LPVOID local_90;\n  undefined local_88;\n  LPVOID local_80;\n  undefined2 local_78;\n  LPVOID local_70;\n  undefined2 local_68;\n  LPVOID local_60;\n  undefined local_58;\n  LPVOID local_50;\n  undefined local_48;\n  UINT local_40 [10];\n  \n  if ((param_1 != (longlong *)0x0) && (*param_1 == 0)) {\n    puVar6 = (undefined8 *)operator_new(0x30);\n    lVar1 = *(longlong *)(param_2 + 8);\n    if (lVar1 == 0) {\n      pcVar9 = \"\";\n    }\n    else {\n      pcVar9 = *(char **)(lVar1 + 0x28);\n      if (pcVar9 == (char *)0x0) {\n        pcVar9 = (char *)(lVar1 + 0x30);\n      }\n    }\n    std::_Lockit::_Lockit(local_a8,0);\n    local_a0 = (LPVOID)0x0;\n    local_98 = 0;\n    local_90 = (LPVOID)0x0;\n    local_88 = 0;\n    local_80 = (LPVOID)0x0;\n    local_78 = 0;\n    local_70 = (LPVOID)0x0;\n    local_68 = 0;\n    local_60 = (LPVOID)0x0;\n    local_58 = 0;\n    local_50 = (LPVOID)0x0;\n    local_48 = 0;\n    if (pcVar9 == (char *)0x0) {\n      std::_Xruntime_error(\"bad locale name\");\n      pcVar2 = (code *)swi(3);\n      uVar8 = (*pcVar2)();\n      return uVar8;\n    }\n    std::_Locinfo::_Locinfo_ctor((_Locinfo *)local_a8,pcVar9);\n    *(undefined4 *)(puVar6 + 1) = 0;\n    *puVar6 = std::ctype<char>::vftable;\n    pUVar7 = FUN_140005840(local_40);\n    UVar3 = pUVar7[1];\n    UVar4 = pUVar7[2];\n    UVar5 = pUVar7[3];\n    *(UINT *)(puVar6 + 2) = *pUVar7;\n    *(UINT *)((longlong)puVar6 + 0x14) = UVar3;\n    *(UINT *)(puVar6 + 3) = UVar4;\n    *(UINT *)((longlong)puVar6 + 0x1c) = UVar5;\n    UVar3 = pUVar7[5];\n    UVar4 = pUVar7[6];\n    UVar5 = pUVar7[7];\n    *(UINT *)(puVar6 + 4) = pUVar7[4];\n    *(UINT *)((longlong)puVar6 + 0x24) = UVar3;\n    *(UINT *)(puVar6 + 5) = UVar4;\n    *(UINT *)((longlong)puVar6 + 0x2c) = UVar5;\n    *param_1 = (longlong)puVar6;\n    std::_Locinfo::_Locinfo_dtor((_Locinfo *)local_a8);\n    if (local_50 != (LPVOID)0x0) {\n      FUN_14000ce08(local_50);\n    }\n    local_50 = (LPVOID)0x0;\n    if (local_60 != (LPVOID)0x0) {\n      FUN_14000ce08(local_60);\n    }\n    local_60 = (LPVOID)0x0;\n    if (local_70 != (LPVOID)0x0) {\n      FUN_14000ce08(local_70);\n    }\n    local_70 = (LPVOID)0x0;\n    if (local_80 != (LPVOID)0x0) {\n      FUN_14000ce08(local_80);\n    }\n    local_80 = (LPVOID)0x0;\n    if (local_90 != (LPVOID)0x0) {\n      FUN_14000ce08(local_90);\n    }\n    local_90 = (LPVOID)0x0;\n    if (local_a0 != (LPVOID)0x0) {\n      FUN_14000ce08(local_a0);\n    }\n    local_a0 = (LPVOID)0x0;\n    std::_Lockit::~_Lockit(local_a8);\n  }\n  return 2;\n}\n\n",
  "FUN_140022771": "\nvoid FUN_140022771(void)\n\n{\n  __acrt_unlock(8);\n  return;\n}\n\n",
  "FrameUnwindToState": "\n/* Library Function - Single Match\n    public: static void __cdecl __FrameHandler3::FrameUnwindToState(unsigned __int64 *\n   __ptr64,struct _xDISPATCHER_CONTEXT * __ptr64,struct _s_FuncInfo const * __ptr64,int)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl\n__FrameHandler3::FrameUnwindToState\n          (__uint64 *param_1,_xDISPATCHER_CONTEXT *param_2,_s_FuncInfo *param_3,int param_4)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  longlong lVar4;\n  longlong lVar5;\n  \n  uVar3 = _GetImageBase();\n  iVar2 = GetCurrentState(param_1,param_2,param_3);\n  lVar4 = FUN_140008b20();\n  *(int *)(lVar4 + 0x30) = *(int *)(lVar4 + 0x30) + 1;\n  while ((iVar2 != -1 && (param_4 < iVar2))) {\n    if ((iVar2 < 0) || (param_3->maxState <= iVar2)) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    lVar5 = (longlong)iVar2;\n    lVar4 = _GetImageBase();\n    iVar2 = *(int *)((longlong)(int)param_3->dispUnwindMap + lVar4 + lVar5 * 8);\n    lVar4 = _GetImageBase();\n    if (*(int *)((longlong)(int)param_3->dispUnwindMap + 4 + lVar4 + lVar5 * 8) == 0) {\n      lVar4 = 0;\n    }\n    else {\n      lVar4 = _GetImageBase();\n      iVar1 = *(int *)((longlong)(int)param_3->dispUnwindMap + 4 + lVar4 + lVar5 * 8);\n      lVar4 = _GetImageBase();\n      lVar4 = lVar4 + iVar1;\n    }\n    if (lVar4 != 0) {\n      SetState(param_1,param_3,iVar2);\n      lVar4 = _GetImageBase();\n      if (*(int *)((longlong)(int)param_3->dispUnwindMap + 4 + lVar4 + lVar5 * 8) != 0) {\n        _GetImageBase();\n        _GetImageBase();\n      }\n      _CallSettingFrame();\n      _SetImageBase(uVar3);\n    }\n  }\n  lVar4 = FUN_140008b20();\n  if (0 < *(int *)(lVar4 + 0x30)) {\n    lVar4 = FUN_140008b20();\n    *(int *)(lVar4 + 0x30) = *(int *)(lVar4 + 0x30) + -1;\n  }\n  if ((iVar2 != -1) && (param_4 < iVar2)) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  SetState(param_1,param_3,iVar2);\n  return;\n}\n\n",
  "_Ios_base_dtor": "\n/* Library Function - Single Match\n    private: static void __cdecl std::ios_base::_Ios_base_dtor(class std::ios_base * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl std::ios_base::_Ios_base_dtor(ios_base *param_1)\n\n{\n  LPVOID pvVar1;\n  longlong lVar2;\n  \n  lVar2 = *(longlong *)(param_1 + 8);\n  if ((lVar2 == 0) ||\n     ((&DAT_140036580)[lVar2] = (&DAT_140036580)[lVar2] + -1, (char)(&DAT_140036580)[lVar2] < '\\x01'\n     )) {\n    _Tidy(param_1);\n    pvVar1 = *(LPVOID *)(param_1 + 0x40);\n    if (pvVar1 != (LPVOID)0x0) {\n      if (*(longlong *)((longlong)pvVar1 + 8) != 0) {\n        lVar2 = (*(code *)PTR__guard_dispatch_icall_140023298)();\n        if (lVar2 != 0) {\n          (*(code *)PTR__guard_dispatch_icall_140023298)(lVar2,1);\n        }\n      }\n      thunk_FUN_14000ce08(pvVar1);\n    }\n  }\n  return;\n}\n\n",
  "imbue": "\n/* Library Function - Multiple Matches With Same Base Name\n    protected: virtual void __cdecl std::basic_filebuf<char,struct std::char_traits<char>\n   >::imbue(class std::locale const & __ptr64) __ptr64\n    protected: virtual void __cdecl std::basic_filebuf<unsigned short,struct\n   std::char_traits<unsigned short> >::imbue(class std::locale const & __ptr64) __ptr64\n    protected: virtual void __cdecl std::basic_filebuf<wchar_t,struct std::char_traits<wchar_t>\n   >::imbue(class std::locale const & __ptr64) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nvoid imbue(longlong param_1,locale *param_2)\n\n{\n  codecvt<char,char,struct__Mbstatet> *pcVar1;\n  \n  pcVar1 = std::use_facet<class_std::codecvt<char,char,struct__Mbstatet>_>(param_2);\n  Initcvt(param_1,(longlong *)pcVar1);\n  return;\n}\n\n",
  "LeaveCriticalSection": "\nvoid __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x000140005b90. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  LeaveCriticalSection(lpCriticalSection);\n  return;\n}\n\n",
  "__acrt_locale_free_monetary": "\n/* Library Function - Single Match\n    __acrt_locale_free_monetary\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_locale_free_monetary(longlong param_1)\n\n{\n  if (param_1 != 0) {\n    if (*(undefined **)(param_1 + 0x18) != PTR_DAT_1400351a8) {\n      _free_base(*(undefined **)(param_1 + 0x18));\n    }\n    if (*(undefined **)(param_1 + 0x20) != PTR_DAT_1400351b0) {\n      _free_base(*(undefined **)(param_1 + 0x20));\n    }\n    if (*(undefined **)(param_1 + 0x28) != PTR_DAT_1400351b8) {\n      _free_base(*(undefined **)(param_1 + 0x28));\n    }\n    if (*(undefined **)(param_1 + 0x30) != PTR_DAT_1400351c0) {\n      _free_base(*(undefined **)(param_1 + 0x30));\n    }\n    if (*(undefined **)(param_1 + 0x38) != PTR_DAT_1400351c8) {\n      _free_base(*(undefined **)(param_1 + 0x38));\n    }\n    if (*(undefined **)(param_1 + 0x40) != PTR_DAT_1400351d0) {\n      _free_base(*(undefined **)(param_1 + 0x40));\n    }\n    if (*(undefined **)(param_1 + 0x48) != PTR_DAT_1400351d8) {\n      _free_base(*(undefined **)(param_1 + 0x48));\n    }\n    if (*(undefined **)(param_1 + 0x68) != PTR_DAT_1400351f8) {\n      _free_base(*(undefined **)(param_1 + 0x68));\n    }\n    if (*(undefined **)(param_1 + 0x70) != PTR_DAT_140035200) {\n      _free_base(*(undefined **)(param_1 + 0x70));\n    }\n    if (*(undefined **)(param_1 + 0x78) != PTR_DAT_140035208) {\n      _free_base(*(undefined **)(param_1 + 0x78));\n    }\n    if (*(undefined **)(param_1 + 0x80) != PTR_DAT_140035210) {\n      _free_base(*(undefined **)(param_1 + 0x80));\n    }\n    if (*(undefined **)(param_1 + 0x88) != PTR_DAT_140035218) {\n      _free_base(*(undefined **)(param_1 + 0x88));\n    }\n    if (*(undefined **)(param_1 + 0x90) != PTR_DAT_140035220) {\n      _free_base(*(undefined **)(param_1 + 0x90));\n    }\n  }\n  return;\n}\n\n",
  "common_fseek_binary_mode_read_only_fast_track_nolock": "\n/* Library Function - Single Match\n    bool __cdecl common_fseek_binary_mode_read_only_fast_track_nolock(class\n   __crt_stdio_stream,__int64,int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nulonglong __cdecl\ncommon_fseek_binary_mode_read_only_fast_track_nolock(longlong *param_1,longlong param_2,int param_3)\n\n{\n  uint uVar1;\n  ulonglong in_RAX;\n  longlong lVar2;\n  longlong lVar3;\n  int iVar4;\n  \n  if ((((param_3 != 2) &&\n       (in_RAX = (ulonglong)*(uint *)((longlong)param_1 + 0x14),\n       (*(uint *)((longlong)param_1 + 0x14) & 0x4c0) != 0)) &&\n      (in_RAX = (ulonglong)*(uint *)((longlong)param_1 + 0x14),\n      (*(uint *)((longlong)param_1 + 0x14) & 6) == 0)) && (0 < *(int *)(param_1 + 2))) {\n    uVar1 = *(uint *)(param_1 + 3);\n    in_RAX = (longlong)(int)uVar1 >> 6;\n    if ((-1 < *(char *)((&DAT_140037490)[in_RAX] + 0x38 + (ulonglong)(uVar1 & 0x3f) * 0x48)) &&\n       (*(char *)((&DAT_140037490)[in_RAX] + 0x39 + (ulonglong)(uVar1 & 0x3f) * 0x48) == '\\0')) {\n      lVar3 = param_2;\n      if (param_3 == 0) {\n        in_RAX = common_lseek_nolock<__int64>(uVar1,0,1);\n        if ((longlong)in_RAX < 0) goto LAB_14000df65;\n        lVar2 = in_RAX - (longlong)*(int *)(param_1 + 2);\n        lVar3 = param_2 - lVar2;\n        iVar4 = -(int)(param_2 >> 0x3f);\n        in_RAX = (longlong)*(int *)(param_1 + 2);\n        if ((iVar4 != -(int)(lVar2 >> 0x3f)) && (in_RAX = 0, iVar4 != -(int)(lVar3 >> 0x3f)))\n        goto LAB_14000df65;\n      }\n      if ((param_1[1] - *param_1 <= lVar3) && (lVar3 <= *(int *)(param_1 + 2))) {\n        *param_1 = *param_1 + lVar3;\n        *(int *)(param_1 + 2) = *(int *)(param_1 + 2) - (int)lVar3;\n        return CONCAT71((int7)(in_RAX >> 8),1);\n      }\n    }\n  }\nLAB_14000df65:\n  return in_RAX & 0xffffffffffffff00;\n}\n\n",
  "__scrt_initialize_crt": "\n/* Library Function - Single Match\n    __scrt_initialize_crt\n   \n   Library: Visual Studio 2019 Release */\n\nulonglong __scrt_initialize_crt(int param_1)\n\n{\n  ulonglong uVar1;\n  undefined8 uVar2;\n  \n  if (param_1 == 0) {\n    DAT_140036750 = 1;\n  }\n  __isa_available_init();\n  uVar1 = __vcrt_initialize();\n  if ((char)uVar1 != '\\0') {\n    uVar2 = FUN_140014858();\n    if ((char)uVar2 != '\\0') {\n      return CONCAT71((int7)((ulonglong)uVar2 >> 8),1);\n    }\n    uVar1 = __vcrt_uninitialize('\\0');\n  }\n  return uVar1 & 0xffffffffffffff00;\n}\n\n",
  "_register_onexit_function": "\n/* Library Function - Single Match\n    _register_onexit_function\n   \n   Library: Visual Studio 2019 Release */\n\nvoid _register_onexit_function(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 local_res8;\n  undefined8 local_res10;\n  __crt_seh_guarded_call<int> local_res18 [8];\n  undefined4 local_res20 [2];\n  undefined4 local_28 [2];\n  undefined8 *local_20;\n  undefined8 *local_18;\n  \n  local_20 = &local_res8;\n  local_18 = &local_res10;\n  local_res20[0] = 2;\n  local_28[0] = 2;\n  local_res8 = param_1;\n  local_res10 = param_2;\n  __crt_seh_guarded_call<int>::\n  operator()<class_<lambda_638799b9deba96c50f710eeac98168cd>,class_<lambda_22ebabd17bc4fa466a2aca6d8deb888d>&___ptr64,class_<lambda_a6f7d7db0129f75315ebf26d50c089f1>_>\n            (local_res18,(<lambda_638799b9deba96c50f710eeac98168cd> *)local_28,\n             (<lambda_22ebabd17bc4fa466a2aca6d8deb888d> *)&local_20,\n             (<lambda_a6f7d7db0129f75315ebf26d50c089f1> *)local_res20);\n  return;\n}\n\n",
  "terminate": "\n/* Library Function - Single Match\n    terminate\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid terminate(void)\n\n{\n  longlong lVar1;\n  \n  lVar1 = FUN_140014d84();\n  if (*(longlong *)(lVar1 + 0x18) != 0) {\n    (*(code *)PTR__guard_dispatch_icall_140023298)();\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "_close": "\n/* Library Function - Single Match\n    _close\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _close(int _FileHandle)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  int local_res8 [2];\n  __crt_seh_guarded_call<int> local_res10 [8];\n  int local_res18 [2];\n  int local_res20 [2];\n  int *local_18 [3];\n  \n  local_res8[0] = _FileHandle;\n  if (_FileHandle == -2) {\n    puVar2 = __doserrno();\n    *puVar2 = 0;\n    puVar2 = __doserrno();\n    *puVar2 = 9;\n  }\n  else {\n    if (((-1 < _FileHandle) && ((uint)_FileHandle < DAT_140037890)) &&\n       ((*(byte *)((&DAT_140037490)[(longlong)_FileHandle >> 6] + 0x38 +\n                  (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) != 0)) {\n      local_18[0] = local_res8;\n      local_res18[0] = _FileHandle;\n      local_res20[0] = _FileHandle;\n      iVar1 = __crt_seh_guarded_call<int>::\n              operator()<class_<lambda_751a882b2c74d4b022dec766aa51a29a>,class_<lambda_628dfdc04ba53c8bfc02c9951375f3f5>&___ptr64,class_<lambda_f6c7be5f7998530c34de24c7437d6b54>_>\n                        (local_res10,(<lambda_751a882b2c74d4b022dec766aa51a29a> *)local_res20,\n                         (<lambda_628dfdc04ba53c8bfc02c9951375f3f5> *)local_18,\n                         (<lambda_f6c7be5f7998530c34de24c7437d6b54> *)local_res18);\n      return iVar1;\n    }\n    puVar2 = __doserrno();\n    *puVar2 = 0;\n    puVar2 = __doserrno();\n    *puVar2 = 9;\n    FUN_14000d030();\n  }\n  return -1;\n}\n\n",
  "FUN_14000ad90": "\nundefined8 * FUN_14000ad90(undefined8 *param_1)\n\n{\n  param_1[2] = 0;\n  param_1[1] = \"bad exception\";\n  *param_1 = std::bad_exception::vftable;\n  return param_1;\n}\n\n",
  "InternalGetLocaleInfoA": "\n/* WARNING: Function: __chkstk replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    int __cdecl InternalGetLocaleInfoA(struct __crt_locale_pointers * __ptr64 const,wchar_t const *\n   __ptr64 const,unsigned long,char * __ptr64 const,int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl\nInternalGetLocaleInfoA\n          (__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5)\n\n{\n  uint uVar1;\n  longlong lVar2;\n  int iVar3;\n  ulonglong uVar4;\n  LPWSTR pWVar5;\n  ulonglong uVar6;\n  undefined *puVar7;\n  undefined *puVar8;\n  undefined auStack_88 [64];\n  longlong local_48;\n  longlong local_40;\n  char local_30;\n  ulonglong local_28;\n  \n  puVar7 = auStack_88;\n  puVar8 = auStack_88;\n  local_28 = DAT_140035020 ^ (ulonglong)&local_48;\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_48,param_1);\n  uVar1 = *(uint *)(local_40 + 0xc);\n  iVar3 = __acrt_GetLocaleInfoEx((ushort *)param_2,param_3,(LPWSTR)0x0,0);\n  if (iVar3 == 0) goto LAB_1400190bc;\n  uVar6 = (longlong)iVar3 * 2 + 0x10;\n  uVar6 = -(ulonglong)((ulonglong)((longlong)iVar3 * 2) < uVar6) & uVar6;\n  if (uVar6 == 0) {\n    pWVar5 = (LPWSTR)0x0;\n    puVar8 = auStack_88;\nLAB_140019051:\n    if (pWVar5 != (LPWSTR)0x0) {\n      *(undefined8 *)(puVar8 + -8) = 0x140019066;\n      iVar3 = __acrt_GetLocaleInfoEx((ushort *)param_2,param_3,pWVar5,iVar3);\n      if (iVar3 != 0) {\n        *(undefined8 *)(puVar8 + 0x38) = 0;\n        *(undefined8 *)(puVar8 + 0x30) = 0;\n        *(int *)(puVar8 + 0x28) = param_5;\n        *(ulonglong *)(puVar8 + 0x20) = -(ulonglong)(param_5 != 0) & (ulonglong)param_4;\n        *(undefined8 *)(puVar8 + -8) = 0x1400190a0;\n        __acrt_WideCharToMultiByte\n                  (uVar1,0,pWVar5,-1,*(LPSTR *)(puVar8 + 0x20),*(int *)(puVar8 + 0x28),\n                   *(LPBOOL *)(puVar8 + 0x30),*(LPBOOL *)(puVar8 + 0x38));\n      }\n    }\n  }\n  else {\n    if (0x400 < uVar6) {\n      pWVar5 = (LPWSTR)_malloc_base(uVar6);\n      puVar8 = auStack_88;\n      if (pWVar5 != (LPWSTR)0x0) {\n        *(undefined4 *)pWVar5 = 0xdddd;\n        goto LAB_140019049;\n      }\n      goto LAB_140019051;\n    }\n    uVar4 = uVar6 + 0xf;\n    if (uVar4 <= uVar6) {\n      uVar4 = 0xffffffffffffff0;\n    }\n    lVar2 = -(uVar4 & 0xfffffffffffffff0);\n    puVar8 = auStack_88 + lVar2;\n    puVar7 = auStack_88 + lVar2;\n    pWVar5 = (LPWSTR)((longlong)&local_48 + lVar2);\n    if (pWVar5 != (LPWSTR)0x0) {\n      *(undefined4 *)pWVar5 = 0xcccc;\nLAB_140019049:\n      pWVar5 = pWVar5 + 8;\n      puVar8 = puVar7;\n      goto LAB_140019051;\n    }\n  }\n  if ((pWVar5 != (LPWSTR)0x0) && (*(int *)(pWVar5 + -8) == 0xdddd)) {\n    *(undefined8 *)(puVar8 + -8) = 0x1400190bc;\n    _free_base(pWVar5 + -8);\n  }\nLAB_1400190bc:\n  if (local_30 != '\\0') {\n    *(uint *)(local_48 + 0x3a8) = *(uint *)(local_48 + 0x3a8) & 0xfffffffd;\n  }\n  uVar6 = local_28 ^ (ulonglong)&local_48;\n  *(undefined8 *)(puVar8 + -8) = 0x1400190db;\n  iVar3 = FUN_140006060(uVar6);\n  return iVar3;\n}\n\n",
  "_fread_nolock_s": "\n/* Library Function - Single Match\n    _fread_nolock_s\n   \n   Library: Visual Studio 2019 Release */\n\nsize_t __cdecl\n_fread_nolock_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  char *pcVar3;\n  undefined auVar4 [16];\n  undefined auVar5 [16];\n  FILE *_File_00;\n  int iVar6;\n  ulong *puVar7;\n  ulonglong uVar8;\n  ulonglong uVar9;\n  undefined (*_DstBuf_00) [16];\n  ulonglong uVar10;\n  ulonglong uVar11;\n  \n  _File_00 = _File;\n  if ((_ElementSize != 0) && (_Count != 0)) {\n    if (_DstBuf != (void *)0x0) {\n      if ((_File != (FILE *)0x0) &&\n         (auVar4._8_8_ = 0, auVar4._0_8_ = _ElementSize,\n         _Count <= SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / auVar4,0))) {\nLAB_14000db32:\n        if ((*(uint *)((longlong)&_File->_base + 4) & 0x4c0) == 0) {\n          _File._0_4_ = 0x1000;\n        }\n        else {\n          _File._0_4_ = _File->_charbuf;\n        }\n        uVar9 = _ElementSize * _Count;\n        _DstBuf_00 = (undefined (*) [16])_DstBuf;\n        uVar10 = _DstSize;\n        do {\n          if (uVar9 == 0) {\n            return _Count;\n          }\n          if ((*(uint *)((longlong)&_File_00->_base + 4) & 0x4c0) == 0) {\nLAB_14000dc22:\n            if (uVar9 < (uint)_File) {\n              uVar8 = __acrt_stdio_refill_and_read_narrow_nolock(_File_00);\n              if ((int)uVar8 == -1) goto LAB_14000dd14;\n              if (uVar10 == 0) goto LAB_14000dce5;\n              uVar9 = uVar9 - 1;\n              uVar10 = uVar10 - 1;\n              uVar11 = 1;\n              (*_DstBuf_00)[0] = (char)uVar8;\n              _File._0_4_ = _File_00->_charbuf;\n            }\n            else {\n              uVar11 = uVar9 & 0xffffffff;\n              if (0x7fffffff < uVar9) {\n                uVar11 = 0x7fffffff;\n              }\n              if ((uint)_File != 0) {\n                uVar11 = (ulonglong)(uint)((int)uVar11 - (int)(uVar11 % (ulonglong)(uint)_File));\n              }\n              if (uVar10 < uVar11) {\nLAB_14000dce5:\n                if (_DstSize != 0xffffffffffffffff) {\n                  FUN_140008580((undefined (*) [16])_DstBuf,0,_DstSize);\n                }\n                puVar7 = __doserrno();\n                *puVar7 = 0x22;\n                goto LAB_14000dad0;\n              }\n              *(undefined4 *)&_File_00->_base = 0;\n              _File_00->_ptr = *(char **)&_File_00->_cnt;\n              iVar6 = _fileno(_File_00);\n              iVar6 = _read_nolock(iVar6,_DstBuf_00,(uint)uVar11);\n              if (iVar6 == 0) {\n                LOCK();\n                puVar1 = (uint *)((longlong)&_File_00->_base + 4);\n                *puVar1 = *puVar1 | 8;\n                UNLOCK();\n                goto LAB_14000dd14;\n              }\n              if (iVar6 < 0) goto LAB_14000dd08;\n              uVar11 = (ulonglong)iVar6;\n              uVar9 = uVar9 - uVar11;\n              uVar10 = uVar10 - uVar11;\n            }\n          }\n          else {\n            uVar2 = *(uint *)&_File_00->_base;\n            if (uVar2 == 0) goto LAB_14000dc22;\n            if ((int)uVar2 < 0) {\nLAB_14000dd08:\n              LOCK();\n              puVar1 = (uint *)((longlong)&_File_00->_base + 4);\n              *puVar1 = *puVar1 | 0x10;\n              UNLOCK();\nLAB_14000dd14:\n              return (_ElementSize * _Count - uVar9) / _ElementSize;\n            }\n            uVar11 = (ulonglong)uVar2;\n            if (uVar9 < (ulonglong)(longlong)(int)uVar2) {\n              uVar11 = uVar9 & 0xffffffff;\n            }\n            if (uVar10 < uVar11) goto LAB_14000dce5;\n            pcVar3 = _File_00->_ptr;\n            if (uVar11 != 0) {\n              if (_DstBuf_00 == (undefined (*) [16])0x0) {\nLAB_14000dbb3:\n                puVar7 = __doserrno();\n                *puVar7 = 0x16;\n              }\n              else {\n                if ((pcVar3 != (char *)0x0) && (uVar11 <= uVar10)) {\n                  FUN_140007ed0((undefined8 *)_DstBuf_00,(undefined8 *)pcVar3,uVar11);\n                  goto LAB_14000dc09;\n                }\n                FUN_140008580(_DstBuf_00,0,uVar10);\n                if (pcVar3 == (char *)0x0) goto LAB_14000dbb3;\n                if (uVar11 <= uVar10) goto LAB_14000dc09;\n                puVar7 = __doserrno();\n                *puVar7 = 0x22;\n              }\n              FUN_14000d030();\n            }\nLAB_14000dc09:\n            *(int *)&_File_00->_base = *(int *)&_File_00->_base - (int)uVar11;\n            uVar9 = uVar9 - uVar11;\n            _File_00->_ptr = _File_00->_ptr + uVar11;\n            uVar10 = uVar10 - uVar11;\n          }\n          _DstBuf_00 = (undefined (*) [16])(*_DstBuf_00 + uVar11);\n        } while( true );\n      }\n      if (_DstSize != 0xffffffffffffffff) {\n        FUN_140008580((undefined (*) [16])_DstBuf,0,_DstSize);\n      }\n      if ((_File != (FILE *)0x0) &&\n         (auVar5._8_8_ = 0, auVar5._0_8_ = _ElementSize,\n         _Count <= SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / auVar5,0)))\n      goto LAB_14000db32;\n    }\n    puVar7 = __doserrno();\n    *puVar7 = 0x16;\nLAB_14000dad0:\n    FUN_14000d030();\n  }\n  return 0;\n}\n\n",
  "common_lseek_nolock<__int64>": "\n/* Library Function - Single Match\n    __int64 __cdecl common_lseek_nolock<__int64>(int,__int64,int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\n__int64 __cdecl common_lseek_nolock<__int64>(int param_1,__int64 param_2,int param_3)\n\n{\n  byte *pbVar1;\n  BOOL BVar2;\n  DWORD DVar3;\n  HANDLE hFile;\n  ulong *puVar4;\n  LARGE_INTEGER local_res20;\n  \n  hFile = (HANDLE)_get_osfhandle(param_1);\n  if (hFile == (HANDLE)0xffffffffffffffff) {\n    puVar4 = __doserrno();\n    *puVar4 = 9;\n  }\n  else {\n    BVar2 = SetFilePointerEx(hFile,(LARGE_INTEGER)param_2,&local_res20,param_3);\n    if (BVar2 == 0) {\n      DVar3 = GetLastError();\n      __acrt_errno_map_os_error(DVar3);\n    }\n    else if (local_res20.QuadPart != -1) {\n      pbVar1 = (byte *)((&DAT_140037490)[(longlong)param_1 >> 6] + 0x38 +\n                       (ulonglong)(param_1 & 0x3f) * 0x48);\n      *pbVar1 = *pbVar1 & 0xfd;\n      return (__int64)local_res20.s;\n    }\n  }\n  return -1;\n}\n\n",
  "wcscpy_s": "\n/* Library Function - Single Match\n    wcscpy_s\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nerrno_t __cdecl wcscpy_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src)\n\n{\n  wchar_t wVar1;\n  ulong *puVar2;\n  ulong uVar3;\n  wchar_t *pwVar4;\n  \n  if ((_Dst != (wchar_t *)0x0) && (_SizeInWords != 0)) {\n    if (_Src != (wchar_t *)0x0) {\n      pwVar4 = _Dst;\n      do {\n        wVar1 = *(wchar_t *)(((longlong)_Src - (longlong)_Dst) + (longlong)pwVar4);\n        *pwVar4 = wVar1;\n        pwVar4 = pwVar4 + 1;\n        if (wVar1 == L'\\0') break;\n        _SizeInWords = _SizeInWords - 1;\n      } while (_SizeInWords != 0);\n      if (_SizeInWords != 0) {\n        return 0;\n      }\n      *_Dst = L'\\0';\n      puVar2 = __doserrno();\n      uVar3 = 0x22;\n      goto LAB_140019824;\n    }\n    *_Dst = L'\\0';\n  }\n  puVar2 = __doserrno();\n  uVar3 = 0x16;\nLAB_140019824:\n  *puVar2 = uVar3;\n  FUN_14000d030();\n  return uVar3;\n}\n\n",
  "FUN_1400045b8": "\nundefined8\nFUN_1400045b8(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n             undefined8 *param_5)\n\n{\n  *param_5 = param_3;\n  return 3;\n}\n\n",
  "__acrt_initialize_fma3": "\n/* WARNING: Removing unreachable block (ram,0x00014001a1f9) */\n/* Library Function - Single Match\n    __acrt_initialize_fma3\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 __acrt_initialize_fma3(void)\n\n{\n  longlong lVar1;\n  byte in_XCR0;\n  \n  DAT_1400378d0 = 0;\n  lVar1 = cpuid_Version_info(1);\n  if ((*(uint *)(lVar1 + 0xc) & 0x18001000) == 0x18001000) {\n    DAT_1400378d0 = (uint)((in_XCR0 & 6) == 6);\n  }\n  DAT_1400378d4 = DAT_1400378d0;\n  return 0;\n}\n\n",
  "__acrt_DownlevelLocaleNameToLCID": "\n/* Library Function - Single Match\n    __acrt_DownlevelLocaleNameToLCID\n   \n   Library: Visual Studio 2019 Release */\n\nundefined4 __acrt_DownlevelLocaleNameToLCID(ushort *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  \n  if (param_1 != (ushort *)0x0) {\n    iVar4 = 0;\n    iVar5 = 0xe3;\n    do {\n      iVar1 = (iVar5 + iVar4) / 2;\n      iVar2 = __ascii_wcsnicmp(param_1,*(ushort **)(&UNK_14002d820 + (longlong)iVar1 * 0x10),0x55);\n      if (iVar2 == 0) {\n        uVar3 = *(uint *)(&UNK_14002d828 + (longlong)iVar1 * 0x10);\n        goto LAB_14001f20e;\n      }\n      if (iVar2 < 0) {\n        iVar5 = iVar1 + -1;\n      }\n      else {\n        iVar4 = iVar1 + 1;\n      }\n    } while (iVar4 <= iVar5);\n    uVar3 = 0xffffffff;\nLAB_14001f20e:\n    if ((-1 < (int)uVar3) && (uVar3 < 0xe4)) {\n      return *(undefined4 *)(&DAT_14002bdd0 + (longlong)(int)uVar3 * 0x10);\n    }\n  }\n  return 0;\n}\n\n",
  "FUN_14002264f": "\nvoid FUN_14002264f(undefined8 param_1,longlong param_2)\n\n{\n  FUN_14000d390(**(longlong **)(param_2 + 0x48));\n  return;\n}\n\n",
  "_mbtowc_l": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    _mbtowc_l\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _mbtowc_l(wchar_t *_DstCh,char *_SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale)\n\n{\n  int iVar1;\n  __uint64 _Var2;\n  ulong *puVar3;\n  uint uVar4;\n  longlong local_28;\n  localeinfo_struct local_20;\n  char local_10;\n  \n  if ((_SrcCh == (char *)0x0) || (_SrcSizeInBytes == 0)) {\n    _DAT_1400378c8 = 0;\n    return 0;\n  }\n  if (*_SrcCh == '\\0') {\n    if (_DstCh == (wchar_t *)0x0) {\n      return 0;\n    }\n    *_DstCh = L'\\0';\n    return 0;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,(__crt_locale_pointers *)_Locale);\n  if ((local_20.locinfo)->lc_time_cp == 0xfde9) {\n    _Var2 = __crt_mbstring::__mbrtowc_utf8\n                      (_DstCh,_SrcCh,_SrcSizeInBytes,(_Mbstatet *)&DAT_1400378c8);\n    uVar4 = (uint)_Var2;\n    if ((int)uVar4 < 0) {\n      uVar4 = 0xffffffff;\n    }\n    goto LAB_14001a0e9;\n  }\n  if ((local_20.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n    if (_DstCh != (wchar_t *)0x0) {\n      *_DstCh = (ushort)(byte)*_SrcCh;\n    }\nLAB_14001a0e4:\n    uVar4 = 1;\n  }\n  else {\n    iVar1 = _isleadbyte_l((uint)(byte)*_SrcCh,&local_20);\n    if (iVar1 == 0) {\n      iVar1 = __acrt_MultiByteToWideChar\n                        ((local_20.locinfo)->lc_time_cp,9,_SrcCh,1,_DstCh,\n                         (uint)(_DstCh != (wchar_t *)0x0));\n      if (iVar1 != 0) goto LAB_14001a0e4;\n    }\n    else {\n      uVar4 = (local_20.locinfo)->lc_collate_cp;\n      if ((((1 < (int)uVar4) && ((int)uVar4 <= (int)_SrcSizeInBytes)) &&\n          (iVar1 = __acrt_MultiByteToWideChar\n                             ((local_20.locinfo)->lc_time_cp,9,_SrcCh,uVar4,_DstCh,\n                              (uint)(_DstCh != (wchar_t *)0x0)), iVar1 != 0)) ||\n         (((ulonglong)(longlong)(int)(local_20.locinfo)->lc_collate_cp <= _SrcSizeInBytes &&\n          (_SrcCh[1] != '\\0')))) {\n        uVar4 = (local_20.locinfo)->lc_collate_cp;\n        goto LAB_14001a0e9;\n      }\n    }\n    puVar3 = __doserrno();\n    uVar4 = 0xffffffff;\n    *puVar3 = 0x2a;\n  }\nLAB_14001a0e9:\n  if (local_10 != '\\0') {\n    *(uint *)(local_28 + 0x3a8) = *(uint *)(local_28 + 0x3a8) & 0xfffffffd;\n    return uVar4;\n  }\n  return uVar4;\n}\n\n",
  "__acrt_FlsAlloc": "\n/* WARNING: Switch with 1 destination removed at 0x0001400156fd */\n/* Library Function - Single Match\n    __acrt_FlsAlloc\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_FlsAlloc(undefined8 param_1)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  \n  UNRECOVERED_JUMPTABLE =\n       (code *)try_get_function(3,\"FlsAlloc\",(module_id *)&DAT_140028dc8,(module_id *)&DAT_140028dd0\n                               );\n  if (UNRECOVERED_JUMPTABLE == (code *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x000140015709. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    TlsAlloc();\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x000140021e60. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)(param_1);\n  return;\n}\n\n",
  "_seh_filter_exe": "\n/* Library Function - Single Match\n    _seh_filter_exe\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined4 _seh_filter_exe(int param_1,int *param_2)\n\n{\n  undefined4 uVar1;\n  int *piVar2;\n  longlong lVar3;\n  int **ppiVar4;\n  int *piVar5;\n  int *piVar6;\n  int *piVar7;\n  undefined4 uVar8;\n  \n  ppiVar4 = (int **)__acrt_getptd_noexit();\n  if (ppiVar4 == (int **)0x0) {\n    return 0;\n  }\n  piVar2 = *ppiVar4;\n  for (piVar5 = piVar2;\n      (piVar6 = (int *)0x0, piVar5 != piVar2 + 0x30 && (piVar6 = piVar5, *piVar5 != param_1));\n      piVar5 = piVar5 + 4) {\n  }\n  if (piVar6 == (int *)0x0) {\n    return 0;\n  }\n  lVar3 = *(longlong *)(piVar6 + 2);\n  if (lVar3 == 0) {\n    return 0;\n  }\n  if (lVar3 == 5) {\n    *(undefined8 *)(piVar6 + 2) = 0;\n    return 1;\n  }\n  if (lVar3 == 1) {\n    return 0xffffffff;\n  }\n  piVar5 = ppiVar4[1];\n  ppiVar4[1] = param_2;\n  if (piVar6[1] != 8) {\n    *(undefined8 *)(piVar6 + 2) = 0;\n    (*(code *)PTR__guard_dispatch_icall_140023298)(piVar6[1]);\n    goto LAB_140011de2;\n  }\n  for (piVar7 = piVar2 + 0xc; piVar7 != piVar2 + 0x30; piVar7 = piVar7 + 4) {\n    *(undefined8 *)(piVar7 + 2) = 0;\n  }\n  uVar1 = *(undefined4 *)(ppiVar4 + 2);\n  if (*piVar6 == -0x3fffff73) {\n    uVar8 = 0x82;\nLAB_140011dbc:\n    *(undefined4 *)(ppiVar4 + 2) = uVar8;\n  }\n  else {\n    if (*piVar6 == -0x3fffff72) {\n      uVar8 = 0x83;\n      goto LAB_140011dbc;\n    }\n    if (*piVar6 == -0x3fffff71) {\n      uVar8 = 0x86;\n      goto LAB_140011dbc;\n    }\n    if (*piVar6 == -0x3fffff70) {\n      uVar8 = 0x81;\n      goto LAB_140011dbc;\n    }\n    if (*piVar6 == -0x3fffff6f) {\n      uVar8 = 0x84;\n      goto LAB_140011dbc;\n    }\n    if (*piVar6 == -0x3fffff6e) {\n      uVar8 = 0x8a;\n      goto LAB_140011dbc;\n    }\n    if (*piVar6 == -0x3fffff6d) {\n      uVar8 = 0x85;\n      goto LAB_140011dbc;\n    }\n    if (*piVar6 == -0x3ffffd4c) {\n      uVar8 = 0x8e;\n      goto LAB_140011dbc;\n    }\n    uVar8 = uVar1;\n    if (*piVar6 == -0x3ffffd4b) {\n      uVar8 = 0x8d;\n      goto LAB_140011dbc;\n    }\n  }\n  (*(code *)PTR__guard_dispatch_icall_140023298)(8,uVar8);\n  *(undefined4 *)(ppiVar4 + 2) = uVar1;\nLAB_140011de2:\n  ppiVar4[1] = piVar5;\n  return 0xffffffff;\n}\n\n",
  "operator()<class_<lambda_886d6c58226a84441f68b9f2b8217b83>,class_<lambda_ab61a845afdef5b7c387490eaf3616ee>&___ptr64,class_<lambda_f7f22ab5edc0698d5f6905b0d3f44752>_>": "\n/* Library Function - Single Match\n    public: void __cdecl __crt_seh_guarded_call<void>::operator()<class\n   <lambda_886d6c58226a84441f68b9f2b8217b83>,class <lambda_ab61a845afdef5b7c387490eaf3616ee> &\n   __ptr64,class <lambda_f7f22ab5edc0698d5f6905b0d3f44752> >(class\n   <lambda_886d6c58226a84441f68b9f2b8217b83> && __ptr64,class\n   <lambda_ab61a845afdef5b7c387490eaf3616ee> & __ptr64,class\n   <lambda_f7f22ab5edc0698d5f6905b0d3f44752> && __ptr64) __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_886d6c58226a84441f68b9f2b8217b83>,class_<lambda_ab61a845afdef5b7c387490eaf3616ee>&___ptr64,class_<lambda_f7f22ab5edc0698d5f6905b0d3f44752>_>\n          (__crt_seh_guarded_call<void> *this,<lambda_886d6c58226a84441f68b9f2b8217b83> *param_1,\n          <lambda_ab61a845afdef5b7c387490eaf3616ee> *param_2,\n          <lambda_f7f22ab5edc0698d5f6905b0d3f44752> *param_3)\n\n{\n  longlong *plVar1;\n  uint uVar2;\n  longlong *plVar3;\n  __crt_seh_guarded_call<void> local_res10 [16];\n  <lambda_f7f22ab5edc0698d5f6905b0d3f44752> *local_res20;\n  longlong local_58;\n  longlong local_50;\n  longlong local_48;\n  longlong *local_40;\n  longlong *local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  \n  local_res20 = param_3;\n  __acrt_lock(*(int *)param_1);\n  plVar1 = DAT_1400370e0 + DAT_1400370d8;\n  for (plVar3 = DAT_1400370e0; local_40 = plVar3, plVar3 != plVar1; plVar3 = plVar3 + 1) {\n    local_58 = *plVar3;\n    if ((local_58 != 0) && (uVar2 = *(uint *)(local_58 + 0x14), (uVar2 >> 0xd & 1) != 0)) {\n      if (((((byte)uVar2 & 3) == 2) && ((uVar2 & 0xc0) != 0)) || ((uVar2 >> 0xb & 1) != 0)) {\n        local_20 = *(undefined8 *)(param_2 + 0x10);\n        local_28 = *(undefined8 *)(param_2 + 8);\n        local_30 = *(undefined8 *)param_2;\n        local_38 = &local_58;\n        local_50 = local_58;\n        local_48 = local_58;\n        operator()<class_<lambda_842d9ff0dc9ef11c61343bbaebe7f885>,class_<lambda_c5860995281e5c4ce005b3de8f5874ee>&___ptr64,class_<lambda_d90129c13df834fdcbf8d2b88dafcf2d>_>\n                  (local_res10,(<lambda_842d9ff0dc9ef11c61343bbaebe7f885> *)&local_48,\n                   (<lambda_c5860995281e5c4ce005b3de8f5874ee> *)&local_38,\n                   (<lambda_d90129c13df834fdcbf8d2b88dafcf2d> *)&local_50);\n      }\n      else {\n        **(int **)param_2 = **(int **)param_2 + 1;\n      }\n    }\n  }\n  __acrt_unlock(*(int *)param_3);\n  return;\n}\n\n",
  "FUN_14000bd50": "\nvoid FUN_14000bd50(void)\n\n{\n  return;\n}\n\n",
  "_Init": "\n/* Library Function - Single Match\n    protected: void __cdecl std::basic_filebuf<char,struct std::char_traits<char> >::_Init(struct\n   _iobuf * __ptr64,enum std::basic_filebuf<char,struct std::char_traits<char> >::_Initfl) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::_Init\n          (basic_filebuf<char,struct_std::char_traits<char>_> *this,_iobuf *param_1,_Initfl param_2)\n\n{\n  undefined8 uVar1;\n  longlong local_res8;\n  longlong local_res10;\n  longlong local_res20;\n  \n  this[0x71] = (basic_filebuf<char,struct_std::char_traits<char>_>)0x0;\n  *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x18) = this + 8;\n  *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x38) = this + 0x28;\n  *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x20) = this + 0x10;\n  this[0x7c] = (basic_filebuf<char,struct_std::char_traits<char>_>)(param_2 == 1);\n  *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x50) = this + 0x48;\n  *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x58) = this + 0x4c;\n  *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x40) = this + 0x30;\n  *(undefined8 *)(this + 0x10) = 0;\n  *(undefined8 *)(this + 0x30) = 0;\n  *(undefined4 *)(this + 0x4c) = 0;\n  *(undefined8 *)(this + 8) = 0;\n  *(undefined8 *)(this + 0x28) = 0;\n  *(undefined4 *)(this + 0x48) = 0;\n  if (param_1 != (_iobuf *)0x0) {\n    local_res8 = 0;\n    local_res10 = 0;\n    local_res20 = 0;\n    _get_stream_buffer_pointers((longlong)param_1,&local_res8,&local_res10,&local_res20);\n    *(longlong *)(this + 0x18) = local_res8;\n    *(longlong *)(this + 0x20) = local_res8;\n    *(longlong *)(this + 0x38) = local_res10;\n    *(longlong *)(this + 0x40) = local_res10;\n    *(longlong *)(this + 0x50) = local_res20;\n    *(longlong *)(this + 0x58) = local_res20;\n  }\n  *(_iobuf **)(this + 0x80) = param_1;\n  uVar1 = DAT_140036370;\n  *(undefined8 *)(this + 0x68) = 0;\n  *(undefined8 *)(this + 0x74) = uVar1;\n  return;\n}\n\n",
  "try_get_function": "\n/* Library Function - Single Match\n    void * __ptr64 __cdecl try_get_function(enum `anonymous namespace'::function_id,char const *\n   __ptr64 const,enum A0x391cf84c::module_id const * __ptr64 const,enum A0x391cf84c::module_id const\n   * __ptr64 const)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid * __cdecl\ntry_get_function(function_id param_1,char *param_2,module_id *param_3,module_id *param_4)\n\n{\n  HMODULE pHVar1;\n  module_id mVar2;\n  wchar_t *lpLibFileName;\n  byte bVar3;\n  DWORD DVar4;\n  int iVar5;\n  HMODULE hLibModule;\n  FARPROC pFVar6;\n  void *pvVar7;\n  \n  bVar3 = (byte)DAT_140035020 & 0x3f;\n  pvVar7 = (void *)((DAT_140035020 ^ (&DAT_140037370)[param_1]) >> bVar3 |\n                   (DAT_140035020 ^ (&DAT_140037370)[param_1]) << 0x40 - bVar3);\n  if (pvVar7 != (void *)0xffffffffffffffff) {\n    if (pvVar7 != (void *)0x0) {\n      return pvVar7;\n    }\n    if (param_3 != param_4) {\n      do {\n        mVar2 = *param_3;\n        hLibModule = (HMODULE)(&DAT_1400372d0)[mVar2];\n        if (hLibModule == (HMODULE)0x0) {\n          lpLibFileName = (wchar_t *)(&PTR_u_api_ms_win_core_datetime_l1_1_1_140028870)[mVar2];\n          hLibModule = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0x800);\n          if (hLibModule == (HMODULE)0x0) {\n            DVar4 = GetLastError();\n            if (((DVar4 == 0x57) && (iVar5 = wcsncmp(lpLibFileName,L\"api-ms-\",7), iVar5 != 0)) &&\n               (iVar5 = wcsncmp(lpLibFileName,L\"ext-ms-\",7), iVar5 != 0)) {\n              hLibModule = LoadLibraryExW(lpLibFileName,(HANDLE)0x0,0);\n            }\n            else {\n              hLibModule = (HMODULE)0x0;\n            }\n          }\n          if (hLibModule != (HMODULE)0x0) {\n            LOCK();\n            pHVar1 = (HMODULE)(&DAT_1400372d0)[mVar2];\n            (&DAT_1400372d0)[mVar2] = hLibModule;\n            UNLOCK();\n            if (pHVar1 != (HMODULE)0x0) {\n              FreeLibrary(hLibModule);\n            }\n            goto LAB_140015422;\n          }\n          LOCK();\n          (&DAT_1400372d0)[mVar2] = 0xffffffffffffffff;\n          UNLOCK();\n        }\n        else if (hLibModule != (HMODULE)0xffffffffffffffff) {\nLAB_140015422:\n          if (hLibModule != (HMODULE)0x0) goto LAB_14001543d;\n        }\n        param_3 = param_3 + 1;\n      } while (param_3 != param_4);\n    }\n    hLibModule = (HMODULE)0x0;\nLAB_14001543d:\n    if ((hLibModule != (HMODULE)0x0) &&\n       (pFVar6 = GetProcAddress(hLibModule,param_2), pFVar6 != (FARPROC)0x0)) {\n      bVar3 = 0x40 - ((byte)DAT_140035020 & 0x3f) & 0x3f;\n      LOCK();\n      (&DAT_140037370)[param_1] =\n           ((ulonglong)pFVar6 >> bVar3 | (longlong)pFVar6 << 0x40 - bVar3) ^ DAT_140035020;\n      UNLOCK();\n      return pFVar6;\n    }\n    bVar3 = 0x40 - ((byte)DAT_140035020 & 0x3f) & 0x3f;\n    LOCK();\n    (&DAT_140037370)[param_1] = (0xffffffffffffffffU >> bVar3 | -1L << 0x40 - bVar3) ^ DAT_140035020\n    ;\n    UNLOCK();\n  }\n  return (void *)0x0;\n}\n\n",
  "strtol": "\n/* Library Function - Single Match\n    strtol\n   \n   Library: Visual Studio 2019 Release */\n\nlong __cdecl strtol(char *_Str,char **_EndPtr,int _Radix)\n\n{\n  uint uVar1;\n  byte *local_18;\n  char **local_10;\n  \n  if (_EndPtr != (char **)0x0) {\n    *_EndPtr = _Str;\n  }\n  local_18 = (byte *)_Str;\n  local_10 = _EndPtr;\n  uVar1 = __crt_strtox::\n          parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<char>_>\n                    ((__crt_locale_pointers *)0x0,&local_18,_Radix,1);\n  return uVar1;\n}\n\n",
  "__acrt_initialize_locks": "\n/* Library Function - Single Match\n    __acrt_initialize_locks\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nundefined8 __acrt_initialize_locks(void)\n\n{\n  undefined8 uVar1;\n  ulonglong uVar2;\n  uint uVar3;\n  \n  uVar2 = 0;\n  do {\n    uVar1 = __acrt_InitializeCriticalSectionEx\n                      ((LPCRITICAL_SECTION)(&DAT_140036ea0 + uVar2 * 0x28),4000,0);\n    if ((int)uVar1 == 0) {\n      uVar2 = __acrt_uninitialize_locks();\n      return uVar2 & 0xffffffffffffff00;\n    }\n    DAT_1400370d0 = DAT_1400370d0 + 1;\n    uVar3 = (int)uVar2 + 1;\n    uVar2 = (ulonglong)uVar3;\n  } while (uVar3 < 0xe);\n  return CONCAT71((int7)((ulonglong)uVar1 >> 8),1);\n}\n\n",
  "FUN_140001920": "\nundefined8 * FUN_140001920(undefined8 *param_1,ulonglong param_2)\n\n{\n  *param_1 = std::_Facet_base::vftable;\n  if ((param_2 & 1) != 0) {\n    thunk_FUN_14000ce08(param_1);\n  }\n  return param_1;\n}\n\n",
  "__acrt_LCMapStringEx": "\n/* Library Function - Single Match\n    __acrt_LCMapStringEx\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_LCMapStringEx\n               (ushort *param_1,DWORD param_2,LPCWSTR param_3,int param_4,LPWSTR param_5,int param_6\n               ,undefined8 param_7,undefined8 param_8,undefined8 param_9)\n\n{\n  LCID Locale;\n  void *pvVar1;\n  \n  pvVar1 = try_get_function(0x14,\"LCMapStringEx\",(module_id *)&DAT_140028e80,\n                            (module_id *)\"LCMapStringEx\");\n  if (pvVar1 == (void *)0x0) {\n    Locale = __acrt_LocaleNameToLCID(param_1,0);\n    LCMapStringW(Locale,param_2,param_3,param_4,param_5,param_6);\n  }\n  else {\n    (*(code *)PTR__guard_dispatch_icall_140023298)\n              (param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);\n  }\n  return;\n}\n\n",
  "FUN_140005b78": "\nvoid FUN_140005b78(undefined8 param_1)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x000140005b80. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  InitializeCriticalSectionEx(param_1,4000,0);\n  return;\n}\n\n",
  "FUN_140003a8c": "\nvoid FUN_140003a8c(char *param_1)\n\n{\n  undefined8 local_28 [5];\n  \n  FUN_1400039b4(local_28,param_1);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_28,(ThrowInfo *)&DAT_140033ac0);\n}\n\n",
  "__mbrtoc32_utf8": "\n/* Library Function - Single Match\n    unsigned __int64 __cdecl __crt_mbstring::__mbrtoc32_utf8(char32_t * __ptr64,char const *\n   __ptr64,unsigned __int64,struct _Mbstatet * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\n__uint64 __cdecl\n__crt_mbstring::__mbrtoc32_utf8(wchar32 *param_1,char *param_2,__uint64 param_3,_Mbstatet *param_4)\n\n{\n  byte bVar1;\n  ulong *puVar2;\n  __uint64 _Var3;\n  uint uVar4;\n  _Mbstatet _Var5;\n  uint *puVar6;\n  byte *pbVar7;\n  _Mbstatet _Var8;\n  ulonglong uVar9;\n  _Mbstatet *p_Var10;\n  ulonglong uVar11;\n  undefined auStack_68 [24];\n  uint auStack_50 [6];\n  ulonglong local_38;\n  \n  local_38 = DAT_140035020 ^ (ulonglong)auStack_68;\n  p_Var10 = (_Mbstatet *)&DAT_1400379e0;\n  if (param_4 != (_Mbstatet *)0x0) {\n    p_Var10 = param_4;\n  }\n  pbVar7 = &DAT_14003038b;\n  if (param_2 != (char *)0x0) {\n    pbVar7 = (byte *)param_2;\n  }\n  uVar11 = 1;\n  if (param_2 != (char *)0x0) {\n    uVar11 = param_3;\n  }\n  puVar6 = (uint *)(-(ulonglong)(param_2 != (char *)0x0) & (ulonglong)param_1);\n  if (uVar11 == 0) goto LAB_140020d2a;\n  if (*(short *)(p_Var10 + 6) == 0) {\n    bVar1 = *pbVar7;\n    pbVar7 = pbVar7 + 1;\n    if (-1 < (char)bVar1) {\n      if (puVar6 != (uint *)0x0) {\n        *puVar6 = (uint)bVar1;\n      }\n      goto LAB_140020d2a;\n    }\n    if ((bVar1 & 0xe0) == 0xc0) {\n      _Var8 = (_Mbstatet)0x2;\n    }\n    else if ((bVar1 & 0xf0) == 0xe0) {\n      _Var8 = (_Mbstatet)0x3;\n    }\n    else {\n      if ((bVar1 & 0xf8) != 0xf0) goto LAB_140020d18;\n      _Var8 = (_Mbstatet)0x4;\n    }\n    uVar4 = (1 << (7U - (char)_Var8 & 0x1f)) - 1U & (uint)bVar1;\n    _Var5 = _Var8;\nLAB_140020c72:\n    uVar9 = (ulonglong)(byte)_Var5;\n    if (uVar11 <= (byte)_Var5) {\n      uVar9 = uVar11;\n    }\n    while ((ulonglong)((longlong)pbVar7 - (longlong)param_2) < uVar9) {\n      bVar1 = *pbVar7;\n      pbVar7 = pbVar7 + 1;\n      if ((bVar1 & 0xc0) != 0x80) goto LAB_140020d18;\n      uVar4 = bVar1 & 0x3f | uVar4 << 6;\n    }\n    if (uVar9 < (byte)_Var5) {\n      *(ushort *)(p_Var10 + 4) = (ushort)(byte)_Var8;\n      *(ushort *)(p_Var10 + 6) = (ushort)(byte)((char)_Var5 - (char)uVar9);\n      *(uint *)p_Var10 = uVar4;\n      goto LAB_140020d2a;\n    }\n    if ((0x7ff < uVar4 - 0xd800) && (uVar4 < 0x110000)) {\n      auStack_50[2] = 0x80;\n      auStack_50[3] = 0x800;\n      auStack_50[4] = 0x10000;\n      if (auStack_50[(byte)_Var8] <= uVar4) {\n        if (puVar6 != (uint *)0x0) {\n          *puVar6 = uVar4;\n        }\n        *(undefined8 *)p_Var10 = 0;\n        goto LAB_140020d2a;\n      }\n    }\n  }\n  else {\n    _Var8 = p_Var10[4];\n    uVar4 = *(uint *)p_Var10;\n    _Var5 = p_Var10[6];\n    if ((((byte)((char)_Var8 - 2U) < 3) && (_Var5 != (_Mbstatet)0x0)) && ((byte)_Var5 < (byte)_Var8)\n       ) goto LAB_140020c72;\n  }\nLAB_140020d18:\n  *(undefined8 *)p_Var10 = 0;\n  puVar2 = __doserrno();\n  *puVar2 = 0x2a;\nLAB_140020d2a:\n  _Var3 = FUN_140006060(local_38 ^ (ulonglong)auStack_68);\n  return _Var3;\n}\n\n",
  "common_flush_all": "\n/* Library Function - Single Match\n    int __cdecl common_flush_all(bool)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl common_flush_all(bool param_1)\n\n{\n  char local_res8 [8];\n  __crt_seh_guarded_call<void> local_res10 [8];\n  int local_res18 [2];\n  int local_res20 [2];\n  undefined4 local_28;\n  undefined4 local_24;\n  int *local_20;\n  char *local_18;\n  int *local_10;\n  \n  local_res20[0] = 0;\n  local_20 = local_res20;\n  local_res18[0] = 0;\n  local_18 = local_res8;\n  local_10 = local_res18;\n  local_28 = 8;\n  local_24 = 8;\n  local_res8[0] = param_1;\n  __crt_seh_guarded_call<void>::\n  operator()<class_<lambda_886d6c58226a84441f68b9f2b8217b83>,class_<lambda_ab61a845afdef5b7c387490eaf3616ee>&___ptr64,class_<lambda_f7f22ab5edc0698d5f6905b0d3f44752>_>\n            (local_res10,(<lambda_886d6c58226a84441f68b9f2b8217b83> *)&local_24,\n             (<lambda_ab61a845afdef5b7c387490eaf3616ee> *)&local_20,\n             (<lambda_f7f22ab5edc0698d5f6905b0d3f44752> *)&local_28);\n  if (local_res8[0] != '\\0') {\n    local_res18[0] = local_res20[0];\n  }\n  return local_res18[0];\n}\n\n",
  "_fwrite_nolock": "\n/* Library Function - Single Match\n    _fwrite_nolock\n   \n   Library: Visual Studio 2019 Release */\n\nsize_t __cdecl _fwrite_nolock(void *_DstBuf,size_t _Size,size_t _Count,FILE *_File)\n\n{\n  uint *puVar1;\n  undefined auVar2 [16];\n  int _FileHandle;\n  uint uVar3;\n  ulong *puVar4;\n  undefined8 uVar5;\n  ulonglong uVar6;\n  uint uVar7;\n  uint _MaxCharCount;\n  ulonglong uVar8;\n  uint uVar9;\n  \n  if ((_Size != 0) && (_Count != 0)) {\n    if ((_File != (FILE *)0x0) &&\n       ((_DstBuf != (void *)0x0 &&\n        (auVar2._8_8_ = 0, auVar2._0_8_ = _Size,\n        _Count <= SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / auVar2,0))))) {\n      if ((*(uint *)((longlong)&_File->_base + 4) & 0x4c0) == 0) {\n        uVar9 = 0x1000;\n      }\n      else {\n        uVar9 = _File->_charbuf;\n      }\n      uVar8 = _Size * _Count;\n      do {\n        if (uVar8 == 0) {\n          return _Count;\n        }\n        if (((*(uint *)((longlong)&_File->_base + 4) & 0xc0) == 0) || (*(int *)&_File->_base == 0))\n        {\n          if (uVar9 <= uVar8) {\n            if (((*(uint *)((longlong)&_File->_base + 4) & 0xc0) != 0) &&\n               (uVar5 = __acrt_stdio_flush_nolock(_File), (int)uVar5 != 0)) goto LAB_14000e239;\n            uVar6 = uVar8;\n            if (uVar9 != 0) {\n              uVar6 = uVar8 - uVar8 % (ulonglong)uVar9;\n            }\n            _MaxCharCount = 0xfffffffe;\n            if (uVar6 < 0xfffffffe) {\n              _MaxCharCount = (uint)uVar6;\n            }\n            _FileHandle = _fileno(_File);\n            uVar3 = _write(_FileHandle,_DstBuf,_MaxCharCount);\n            if (uVar3 != 0xffffffff) {\n              uVar7 = uVar3;\n              if (_MaxCharCount < uVar3) {\n                uVar7 = _MaxCharCount;\n              }\n              uVar6 = (ulonglong)uVar7;\n              uVar8 = uVar8 - uVar6;\n              if (_MaxCharCount <= uVar3) goto LAB_14000e26f;\n            }\nLAB_14000e234:\n            LOCK();\n            puVar1 = (uint *)((longlong)&_File->_base + 4);\n            *puVar1 = *puVar1 | 0x10;\n            UNLOCK();\nLAB_14000e239:\n            return (_Size * _Count - uVar8) / _Size;\n          }\n                    /* WARNING: Load size is inaccurate */\n          uVar6 = __acrt_stdio_flush_and_write_narrow_nolock(*_DstBuf,_File);\n          if ((int)uVar6 == -1) goto LAB_14000e239;\n          uVar9 = _File->_charbuf;\n          uVar8 = uVar8 - 1;\n          uVar6 = 1;\n          if ((int)uVar9 < 1) {\n            uVar9 = 1;\n          }\n        }\n        else {\n          if (*(int *)&_File->_base < 0) goto LAB_14000e234;\n          if ((*(uint *)((longlong)&_File->_base + 4) & 1) != 0) goto LAB_14000e239;\n          uVar6 = uVar8;\n          if ((ulonglong)(longlong)*(int *)&_File->_base <= uVar8) {\n            uVar6 = (longlong)*(int *)&_File->_base;\n          }\n          FUN_140007ed0((undefined8 *)_File->_ptr,(undefined8 *)_DstBuf,uVar6);\n          *(int *)&_File->_base = *(int *)&_File->_base - (int)uVar6;\n          uVar8 = uVar8 - uVar6;\n          _File->_ptr = _File->_ptr + uVar6;\n        }\nLAB_14000e26f:\n        _DstBuf = (void *)((longlong)_DstBuf + uVar6);\n      } while( true );\n    }\n    puVar4 = __doserrno();\n    *puVar4 = 0x16;\n    FUN_14000d030();\n  }\n  return 0;\n}\n\n",
  "_Locimp_dtor": "\n/* Library Function - Single Match\n    private: static void __cdecl std::locale::_Locimp::_Locimp_dtor(class std::locale::_Locimp *\n   __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl std::locale::_Locimp::_Locimp_dtor(_Locimp *param_1)\n\n{\n  longlong lVar1;\n  longlong lVar2;\n  _Lockit local_res8 [8];\n  \n  _Lockit::_Lockit(local_res8,0);\n  lVar2 = *(longlong *)(param_1 + 0x18);\n  while (lVar2 != 0) {\n    lVar2 = lVar2 + -1;\n    if (*(longlong *)(*(longlong *)(param_1 + 0x10) + lVar2 * 8) != 0) {\n      lVar1 = (*(code *)PTR__guard_dispatch_icall_140023298)();\n      if (lVar1 != 0) {\n        (*(code *)PTR__guard_dispatch_icall_140023298)(lVar1,1);\n      }\n    }\n  }\n  FUN_14000ce08(*(LPVOID *)(param_1 + 0x10));\n  _Lockit::~_Lockit(local_res8);\n  return;\n}\n\n",
  "_fflush_nolock": "\n/* Library Function - Single Match\n    _fflush_nolock\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _fflush_nolock(FILE *_File)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if (_File == (FILE *)0x0) {\n    iVar1 = common_flush_all(false);\n    return iVar1;\n  }\n  uVar2 = __acrt_stdio_flush_nolock(_File);\n  if ((int)uVar2 == 0) {\n    if ((*(uint *)((longlong)&_File->_base + 4) >> 0xb & 1) != 0) {\n      iVar1 = _fileno(_File);\n      iVar1 = _commit(iVar1);\n      if (iVar1 != 0) goto LAB_14000d75e;\n    }\n    iVar1 = 0;\n  }\n  else {\nLAB_14000d75e:\n    iVar1 = -1;\n  }\n  return iVar1;\n}\n\n",
  "_expandlocale": "\n/* Library Function - Single Match\n    _expandlocale\n   \n   Library: Visual Studio 2019 Release */\n\nvoid _expandlocale(wchar_t *param_1,wchar_t *param_2,rsize_t param_3,wchar_t *param_4,\n                  rsize_t param_5,UINT *param_6)\n\n{\n  wchar_t *_Dst;\n  wchar_t wVar1;\n  wchar_t wVar2;\n  UINT *pUVar3;\n  bool bVar4;\n  char cVar5;\n  errno_t eVar6;\n  int iVar7;\n  longlong lVar8;\n  wchar_t *pwVar9;\n  undefined8 uVar10;\n  uint uVar11;\n  longlong lVar12;\n  rsize_t _MaxCount;\n  char cVar13;\n  ulonglong uVar14;\n  undefined auStackY_2a8 [32];\n  rsize_t local_278;\n  UINT *local_270;\n  wchar_t *local_268;\n  wchar_t *local_260;\n  rsize_t local_258;\n  longlong local_250;\n  char local_248;\n  UINT *local_240;\n  rsize_t local_238;\n  wchar_t *local_230;\n  WCHAR local_228 [128];\n  ushort local_128;\n  ushort local_126;\n  ushort local_124;\n  short local_122;\n  short local_120;\n  short sStack_11e;\n  wchar_t local_108 [88];\n  ulonglong local_58;\n  ulonglong uVar15;\n  \n  local_58 = DAT_140035020 ^ (ulonglong)auStackY_2a8;\n  local_278 = param_5;\n  local_240 = param_6;\n  local_238 = param_3;\n  local_230 = param_2;\n  if (param_1 == (wchar_t *)0x0) goto LAB_140013111;\n  if ((*param_1 == L'C') && (param_1[1] == L'\\0')) {\n    eVar6 = wcscpy_s(param_2,param_3,L\"C\");\n    if (eVar6 == 0) {\n      *param_6 = 0;\n      goto LAB_140013111;\n    }\n    goto LAB_140013501;\n  }\n  lVar8 = FUN_140014d84();\n  local_250 = lVar8 + 0x98;\n  local_258 = param_5;\n  cVar13 = '\\0';\n  local_248 = '\\0';\n  local_270 = (UINT *)(lVar8 + 0xb8);\n  local_268 = (wchar_t *)(lVar8 + 0xbc);\n  _Dst = (wchar_t *)(lVar8 + 0x1c2);\n  local_260 = param_4;\n  eVar6 = wcsncpy_s(param_4,param_5,(wchar_t *)(lVar8 + 0x2f0),0x55);\n  if (eVar6 != 0) goto LAB_140013501;\n  uVar14 = 0xffffffffffffffff;\n  do {\n    uVar15 = uVar14;\n    uVar14 = uVar15 + 1;\n  } while (param_1[uVar14] != L'\\0');\n  if (uVar14 < 0x83) {\n    pwVar9 = _Dst;\n    do {\n      wVar1 = *pwVar9;\n      wVar2 = *(wchar_t *)((longlong)pwVar9 + ((longlong)param_1 - (longlong)_Dst));\n      if (wVar1 != wVar2) break;\n      pwVar9 = pwVar9 + 1;\n    } while (wVar2 != L'\\0');\n    cVar5 = '\\0';\n    if (wVar1 != wVar2) {\n      pwVar9 = local_268;\n      do {\n        wVar1 = *pwVar9;\n        wVar2 = *(wchar_t *)((longlong)pwVar9 + ((longlong)param_1 - (longlong)local_268));\n        if (wVar1 != wVar2) break;\n        pwVar9 = pwVar9 + 1;\n      } while (wVar2 != L'\\0');\n      if (wVar1 != wVar2) goto LAB_140013229;\n    }\nLAB_1400134d5:\n    cVar13 = cVar5;\n    *local_240 = *local_270;\n    eVar6 = wcscpy_s(local_230,local_238,_Dst);\n    if (eVar6 != 0) goto LAB_140013501;\n  }\n  else {\nLAB_140013229:\n    bVar4 = __acrt_can_use_vista_locale_apis();\n    uVar10 = __lc_wcstolc((undefined (*) [16])local_228,param_1);\n    pUVar3 = local_270;\n    if ((int)uVar10 == 0) {\n      if (bVar4) {\n        uVar10 = __acrt_get_qualified_locale((ushort *)local_228,local_270,local_228);\n        iVar7 = (int)uVar10;\n      }\n      else {\n        iVar7 = __acrt_get_qualified_locale_downlevel((longlong)local_228,local_270,local_228);\n      }\n      if (iVar7 == 0) goto LAB_1400132c2;\n      __lc_lctowcs(_Dst,0x83,local_228);\n      lVar8 = -1;\n      do {\n        lVar12 = lVar8;\n        lVar8 = lVar12 + 1;\n      } while (local_108[lVar8] != L'\\0');\n      cVar5 = '\\x01';\n      eVar6 = wcsncpy_s(param_4,local_278,local_108,lVar12 + 2);\n      if (eVar6 != 0) goto LAB_140013516;\nLAB_14001349d:\n      if ((*param_1 == L'\\0') || (0x82 < uVar14)) {\n        *local_268 = L'\\0';\n      }\n      else {\n        eVar6 = wcsncpy_s(local_268,0x83,param_1,uVar15 + 2);\n        if (eVar6 != 0) {\nLAB_140013516:\n                    /* WARNING: Subroutine does not return */\n          _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n        }\n      }\n      goto LAB_1400134d5;\n    }\nLAB_1400132c2:\n    iVar7 = __acrt_IsValidLocaleName((ushort *)param_1);\n    if (iVar7 != 0) {\n      local_278 = local_278 & 0xffffffff00000000;\n      iVar7 = __acrt_GetLocaleInfoEx((ushort *)param_1,0x20001004,(LPWSTR)&local_278,2);\n      if ((iVar7 == 0) || (uVar11 = (uint)local_278, (uint)local_278 == 0)) {\n        uVar11 = 0xfde9;\n      }\n      *pUVar3 = uVar11 & 0xffff;\n      _MaxCount = uVar15 + 2;\n      eVar6 = wcsncpy_s(_Dst,0x83,param_1,_MaxCount);\n      pwVar9 = param_1;\n      if (eVar6 != 0) goto LAB_140013516;\nLAB_14001348e:\n      _expandlocale_locale_name_cache::commit_locale_name\n                ((_expandlocale_locale_name_cache *)&local_260,pwVar9,_MaxCount);\n      cVar5 = local_248;\n      goto LAB_14001349d;\n    }\n    cVar5 = parse_bcp47((undefined (*) [16])local_228,param_1);\n    if ((cVar5 != '\\0') && (iVar7 = __acrt_IsValidLocaleName((ushort *)local_108), iVar7 != 0)) {\n      if (local_128 == 0) {\n        local_278 = local_278 & 0xffffffff00000000;\n        iVar7 = __acrt_GetLocaleInfoEx((ushort *)local_108,0x20001004,(LPWSTR)&local_278,2);\n        if ((iVar7 == 0) || (uVar11 = (uint)local_278, (uint)local_278 == 0)) goto LAB_140013443;\n      }\n      else {\n        uVar11 = local_128 + 0x20;\n        if (0x19 < local_128 - 0x41) {\n          uVar11 = (uint)local_128;\n        }\n        if (uVar11 == 0x75) {\n          uVar11 = local_126 + 0x20;\n          if (0x19 < local_126 - 0x41) {\n            uVar11 = (uint)local_126;\n          }\n          if (uVar11 == 0x74) {\n            uVar11 = local_124 + 0x20;\n            if (0x19 < local_124 - 0x41) {\n              uVar11 = (uint)local_124;\n            }\n            if (((uVar11 == 0x66) && (local_122 == 0x38)) && (local_120 == 0)) goto LAB_140013443;\n          }\n        }\n        if (((local_122 != 0x2d) || (local_120 != 0x38)) || (sStack_11e != 0)) goto LAB_1400133e1;\nLAB_140013443:\n        uVar11 = 0xfde9;\n      }\n      *pUVar3 = uVar11 & 0xffff;\n      eVar6 = wcsncpy_s(_Dst,0x83,param_1,uVar15 + 2);\n      lVar8 = -1;\n      if (eVar6 != 0) goto LAB_140013516;\n      do {\n        lVar12 = lVar8;\n        lVar8 = lVar12 + 1;\n      } while (local_108[lVar8] != L'\\0');\n      _MaxCount = lVar12 + 2;\n      pwVar9 = local_108;\n      goto LAB_14001348e;\n    }\n  }\nLAB_1400133e1:\n  if ((cVar13 != '\\0') ||\n     (eVar6 = wcsncpy_s((wchar_t *)(local_250 + 600),0x55,local_260,local_258), eVar6 == 0)) {\nLAB_140013111:\n    FUN_140006060(local_58 ^ (ulonglong)auStackY_2a8);\n    return;\n  }\nLAB_140013501:\n                    /* WARNING: Subroutine does not return */\n  _invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n\n",
  "__acrt_stdio_end_temporary_buffering_nolock": "\n/* Library Function - Single Match\n    __acrt_stdio_end_temporary_buffering_nolock\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_stdio_end_temporary_buffering_nolock(char param_1,FILE *param_2)\n\n{\n  uint *puVar1;\n  \n  if ((param_1 != '\\0') && ((*(uint *)((longlong)&param_2->_base + 4) >> 9 & 1) != 0)) {\n    __acrt_stdio_flush_nolock(param_2);\n    LOCK();\n    puVar1 = (uint *)((longlong)&param_2->_base + 4);\n    *puVar1 = *puVar1 & 0xfffffd7f;\n    UNLOCK();\n    param_2->_charbuf = 0;\n    *(undefined8 *)&param_2->_cnt = 0;\n    param_2->_ptr = (char *)0x0;\n  }\n  return;\n}\n\n",
  "TryBlockMap4": "\n/* Library Function - Single Match\n    public: __cdecl FH4::TryBlockMap4::TryBlockMap4(struct FH4::FuncInfo4 const * __ptr64,unsigned\n   __int64) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nTryBlockMap4 * __thiscall\nFH4::TryBlockMap4::TryBlockMap4(TryBlockMap4 *this,FuncInfo4 *param_1,__uint64 param_2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  byte *pbVar4;\n  byte *pbVar5;\n  \n  if (*(int *)(param_1 + 0xc) == 0) {\n    *(undefined4 *)this = 0;\n  }\n  else {\n    pbVar4 = (byte *)((longlong)*(int *)(param_1 + 0xc) + param_2);\n    *(byte **)(this + 8) = pbVar4;\n    bVar1 = (&DAT_140024790)[*pbVar4 & 0xf];\n    pbVar4 = pbVar4 + -(longlong)(char)(&DAT_140024780)[*pbVar4 & 0xf];\n    uVar2 = *(uint *)(pbVar4 + -4);\n    *(byte **)(this + 8) = pbVar4;\n    *(uint *)this = uVar2 >> (bVar1 & 0x1f);\n    *(byte **)(this + 0x10) = pbVar4;\n    bVar1 = (&DAT_140024790)[*pbVar4 & 0xf];\n    pbVar4 = pbVar4 + -(longlong)(char)(&DAT_140024780)[*pbVar4 & 0xf];\n    uVar2 = *(uint *)(pbVar4 + -4);\n    *(byte **)(this + 8) = pbVar4;\n    *(uint *)(this + 0x18) = uVar2 >> (bVar1 & 0x1f);\n    bVar1 = (&DAT_140024790)[*pbVar4 & 0xf];\n    pbVar4 = pbVar4 + -(longlong)(char)(&DAT_140024780)[*pbVar4 & 0xf];\n    uVar2 = *(uint *)(pbVar4 + -4);\n    *(byte **)(this + 8) = pbVar4;\n    *(uint *)(this + 0x1c) = uVar2 >> (bVar1 & 0x1f);\n    pbVar5 = pbVar4 + -(longlong)(char)(&DAT_140024780)[*pbVar4 & 0xf];\n    *(uint *)(this + 0x20) = *(uint *)(pbVar5 + -4) >> ((&DAT_140024790)[*pbVar4 & 0xf] & 0x1f);\n    *(byte **)(this + 8) = pbVar5;\n    uVar3 = *(undefined4 *)pbVar5;\n    *(byte **)(this + 8) = pbVar5 + 4;\n    *(undefined4 *)(this + 0x24) = uVar3;\n  }\n  return this;\n}\n\n",
  "FUN_140002dd0": "\nvoid FUN_140002dd0(longlong *param_1)\n\n{\n  longlong *plVar1;\n  bool bVar2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  longlong lVar6;\n  char *pcVar7;\n  undefined auStack_78 [32];\n  undefined4 local_58 [4];\n  char ****local_48 [5];\n  longlong *local_20;\n  char local_18;\n  ulonglong local_10;\n  \n  local_10 = DAT_140035020 ^ (ulonglong)auStack_78;\n  plVar1 = *(longlong **)((longlong)*(int *)(*param_1 + 4) + 0x48 + (longlong)param_1);\n  if (plVar1 != (longlong *)0x0) {\n    FUN_140002d00(&local_20,param_1);\n    if (local_18 != '\\0') {\n      iVar3 = (**(code **)(*plVar1 + 0x68))(plVar1);\n      if (iVar3 == -1) {\n        lVar6 = (longlong)*(int *)(*param_1 + 4);\n        uVar4 = *(uint *)(lVar6 + 0x10 + (longlong)param_1) & 0x13 | 4;\n        *(uint *)(lVar6 + 0x10 + (longlong)param_1) = uVar4;\n        uVar4 = uVar4 & *(uint *)(lVar6 + 0x14 + (longlong)param_1);\n        if (uVar4 != 0) {\n          if ((uVar4 & 4) == 0) {\n            pcVar7 = \"ios_base::failbit set\";\n            if ((uVar4 & 2) == 0) {\n              pcVar7 = \"ios_base::eofbit set\";\n            }\n          }\n          else {\n            pcVar7 = \"ios_base::badbit set\";\n          }\n          puVar5 = (undefined8 *)FUN_140001450(local_58,1);\n          FUN_140001dd0(local_48,(undefined8 *)pcVar7,puVar5);\n                    /* WARNING: Subroutine does not return */\n          _CxxThrowException(local_48,(ThrowInfo *)&DAT_140033c40);\n        }\n      }\n    }\n    bVar2 = __uncaught_exception();\n    if (!bVar2) {\n      FUN_140002ee0(local_20);\n    }\n    plVar1 = *(longlong **)((longlong)*(int *)(*local_20 + 4) + 0x48 + (longlong)local_20);\n    if (plVar1 != (longlong *)0x0) {\n      (**(code **)(*plVar1 + 0x10))();\n    }\n  }\n  FUN_140006060(local_10 ^ (ulonglong)auStack_78);\n  return;\n}\n\n",
  "EnterCriticalSection": "\nvoid __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x000140005b88. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  EnterCriticalSection(lpCriticalSection);\n  return;\n}\n\n",
  "__acrt_GetModuleFileNameA": "\n/* Library Function - Single Match\n    __acrt_GetModuleFileNameA\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __acrt_GetModuleFileNameA(HMODULE param_1,undefined8 param_2,ulonglong param_3)\n\n{\n  DWORD DVar1;\n  undefined8 uVar2;\n  uint uVar3;\n  undefined auStack_298 [32];\n  longlong local_278;\n  longlong local_270;\n  char local_260;\n  undefined8 local_258;\n  ulonglong local_250;\n  undefined8 local_248;\n  ulonglong local_240;\n  undefined8 local_238;\n  undefined local_230;\n  WCHAR local_228 [264];\n  ulonglong local_18;\n  \n  local_18 = DAT_140035020 ^ (ulonglong)auStack_298;\n  DVar1 = GetModuleFileNameW(param_1,local_228,0x105);\n  if (DVar1 == 0) {\n    DVar1 = GetLastError();\n    __acrt_errno_map_os_error(DVar1);\n  }\n  else {\n    local_238 = 0;\n    local_230 = 0;\n    local_258 = param_2;\n    local_250 = param_3 & 0xffffffff;\n    local_248 = param_2;\n    local_240 = param_3 & 0xffffffff;\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_278,(__crt_locale_pointers *)0x0);\n    uVar3 = 0xfde9;\n    if (*(int *)(local_270 + 0xc) == 0xfde9) {\n      if (local_260 != '\\0') {\n        *(uint *)(local_278 + 0x3a8) = *(uint *)(local_278 + 0x3a8) & 0xfffffffd;\n      }\n    }\n    else {\n      uVar2 = __acrt_AreFileApisANSI();\n      if ((int)uVar2 == 0) {\n        if (local_260 != (char)uVar2) {\n          *(uint *)(local_278 + 0x3a8) = *(uint *)(local_278 + 0x3a8) & 0xfffffffd;\n        }\n        uVar3 = 1;\n      }\n      else {\n        if (local_260 != '\\0') {\n          *(uint *)(local_278 + 0x3a8) = *(uint *)(local_278 + 0x3a8) & 0xfffffffd;\n        }\n        uVar3 = 0;\n      }\n    }\n    __acrt_wcs_to_mbs_cp<struct___crt_win32_buffer_no_resizing>\n              (local_228,\n               (__crt_win32_buffer<char,struct___crt_win32_buffer_no_resizing> *)&local_258,uVar3);\n  }\n  FUN_140006060(local_18 ^ (ulonglong)auStack_298);\n  return;\n}\n\n",
  "_wcstombs_l_helper": "\n/* Library Function - Single Match\n    unsigned __int64 __cdecl _wcstombs_l_helper(char * __ptr64,wchar_t const * __ptr64,unsigned\n   __int64,struct __crt_locale_pointers * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\n__uint64 __cdecl\n_wcstombs_l_helper(char *param_1,wchar_t *param_2,__uint64 param_3,__crt_locale_pointers *param_4)\n\n{\n  char cVar1;\n  wchar_t wVar2;\n  WCHAR WVar3;\n  uint uVar4;\n  int iVar5;\n  DWORD DVar6;\n  ulong *puVar7;\n  LPCWSTR pWVar8;\n  __uint64 _Var9;\n  ulonglong uVar10;\n  WCHAR *pWVar11;\n  ulonglong uVar12;\n  ulonglong uVar13;\n  ulonglong uVar14;\n  undefined auStackY_c8 [32];\n  BOOL local_88 [2];\n  wchar_t *local_80;\n  undefined8 local_78;\n  longlong local_70;\n  longlong local_68;\n  char local_58;\n  undefined8 local_50;\n  CHAR local_48 [8];\n  ulonglong local_40;\n  \n  local_50 = 0xfffffffffffffffe;\n  local_40 = DAT_140035020 ^ (ulonglong)auStackY_c8;\n  uVar13 = 0;\n  local_88[0] = 0;\n  local_80 = param_2;\n  if ((param_1 != (char *)0x0) && (param_3 == 0)) goto LAB_140018e6f;\n  if (param_2 == (wchar_t *)0x0) {\n    puVar7 = __doserrno();\n    *puVar7 = 0x16;\n    FUN_14000d030();\n    goto LAB_140018e6f;\n  }\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_70,param_4);\n  uVar4 = *(uint *)(local_68 + 0xc);\n  if (uVar4 == 0xfde9) {\n    local_78 = 0;\n    __crt_mbstring::__wcsrtombs_utf8(param_1,&local_80,param_3,(_Mbstatet *)&local_78);\n  }\n  else if (param_1 == (char *)0x0) {\n    if (*(longlong *)(local_68 + 0x138) == 0) {\n      WVar3 = *local_80;\n      pWVar11 = local_80;\n      while (WVar3 != L'\\0') {\n        if (0xff < (ushort)WVar3) {\n          puVar7 = __doserrno();\n          *puVar7 = 0x2a;\n          break;\n        }\n        pWVar11 = pWVar11 + 1;\n        WVar3 = *pWVar11;\n      }\n    }\n    else {\n      iVar5 = __acrt_WideCharToMultiByte(uVar4,0,local_80,-1,(LPSTR)0x0,0,(LPBOOL)0x0,local_88);\n      if (iVar5 != 0) {\njoined_r0x000140018ce5:\n        if (local_88[0] == 0) goto LAB_140018e5b;\n      }\nLAB_140018e4d:\n      puVar7 = __doserrno();\nLAB_140018e52:\n      *puVar7 = 0x2a;\n    }\n  }\n  else if (*(longlong *)(local_68 + 0x138) == 0) {\n    if (param_3 != 0) {\n      do {\n        if (0xff < (ushort)*local_80) goto LAB_140018c25;\n        param_1[uVar13] = *(char *)local_80;\n        wVar2 = *local_80;\n        local_80 = local_80 + 1;\n      } while ((wVar2 != L'\\0') && (uVar13 = uVar13 + 1, uVar13 < param_3));\n    }\n  }\n  else if (*(int *)(local_68 + 8) == 1) {\n    pWVar8 = local_80;\n    _Var9 = param_3;\n    if (param_3 != 0) {\n      do {\n        if (*pWVar8 == L'\\0') break;\n        pWVar8 = pWVar8 + 1;\n        _Var9 = _Var9 - 1;\n      } while (_Var9 != 0);\n      if ((_Var9 != 0) && (*pWVar8 == L'\\0')) {\n        param_3 = ((longlong)pWVar8 - (longlong)local_80 >> 1) + 1;\n      }\n    }\n    iVar5 = __acrt_WideCharToMultiByte\n                      (uVar4,0,local_80,(int)param_3,param_1,(int)param_3,(LPBOOL)0x0,local_88);\n    if ((iVar5 == 0) || (local_88[0] != 0)) {\nLAB_140018c25:\n      puVar7 = __doserrno();\n      goto LAB_140018e52;\n    }\n  }\n  else {\n    iVar5 = __acrt_WideCharToMultiByte\n                      (uVar4,0,local_80,-1,param_1,(int)param_3,(LPBOOL)0x0,local_88);\n    uVar14 = (ulonglong)iVar5;\n    if (iVar5 != 0) goto joined_r0x000140018ce5;\n    if ((local_88[0] != 0) || (DVar6 = GetLastError(), DVar6 != 0x7a)) goto LAB_140018e4d;\n    if (param_3 != 0) {\n      do {\n        iVar5 = *(int *)(local_68 + 8);\n        if (5 < *(int *)(local_68 + 8)) {\n          iVar5 = 5;\n        }\n        iVar5 = __acrt_WideCharToMultiByte\n                          (*(uint *)(local_68 + 0xc),0,local_80,1,local_48,iVar5,(LPBOOL)0x0,\n                           local_88);\n        if ((((iVar5 == 0) || (local_88[0] != 0)) || (iVar5 < 0)) ||\n           (uVar12 = (ulonglong)iVar5, 5 < uVar12)) goto LAB_140018e4d;\n        if (param_3 < uVar12 + uVar14) break;\n        uVar10 = uVar13;\n        if (0 < (longlong)uVar12) {\n          do {\n            cVar1 = local_48[uVar10];\n            param_1[uVar14] = cVar1;\n            if (cVar1 == '\\0') goto LAB_140018e5b;\n            uVar10 = uVar10 + 1;\n            uVar14 = uVar14 + 1;\n          } while ((longlong)uVar10 < (longlong)uVar12);\n        }\n        local_80 = local_80 + 1;\n      } while (uVar14 < param_3);\n    }\n  }\nLAB_140018e5b:\n  if (local_58 != '\\0') {\n    *(uint *)(local_70 + 0x3a8) = *(uint *)(local_70 + 0x3a8) & 0xfffffffd;\n  }\nLAB_140018e6f:\n  _Var9 = FUN_140006060(local_40 ^ (ulonglong)auStackY_c8);\n  return _Var9;\n}\n\n",
  "_set_errno_from_matherr": "\n/* Library Function - Single Match\n    _set_errno_from_matherr\n   \n   Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,\n   Visual Studio 2019 Release */\n\nvoid _set_errno_from_matherr(int param_1)\n\n{\n  ulong *puVar1;\n  \n  if (param_1 == 1) {\n    puVar1 = __doserrno();\n    *puVar1 = 0x21;\n  }\n  else if (param_1 - 2U < 2) {\n    puVar1 = __doserrno();\n    *puVar1 = 0x22;\n  }\n  return;\n}\n\n",
  "do_tolower": "\n/* Library Function - Single Match\n    protected: virtual char __cdecl std::ctype<char>::do_tolower(char)const __ptr64\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nchar __thiscall std::ctype<char>::do_tolower(ctype<char> *this,char param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = _Tolower((uint)(byte)param_1,(_Ctypevec *)(this + 0x10));\n  return (char)iVar1;\n}\n\n",
  "FUN_14002278a": "\nvoid FUN_14002278a(void)\n\n{\n  __acrt_unlock(7);\n  return;\n}\n\n",
  "FUN_1400012e0": "\nvoid FUN_1400012e0(void)\n\n{\n  undefined8 local_28 [5];\n  \n  FUN_1400012b0(local_28);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_28,(ThrowInfo *)&DAT_140033da8);\n}\n\n",
  "__chkstk": "\n/* WARNING: This is an inlined function */\n/* Library Function - Single Match\n    __chkstk\n   \n   Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2012 */\n\nvoid __chkstk(void)\n\n{\n  undefined *in_RAX;\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined local_res8 [32];\n  \n  puVar1 = local_res8 + -(longlong)in_RAX;\n  if (local_res8 < in_RAX) {\n    puVar1 = (undefined *)0x0;\n  }\n  if (puVar1 < StackLimit) {\n    puVar2 = (undefined *)StackLimit;\n    do {\n      puVar2 = puVar2 + -0x1000;\n      *puVar2 = 0;\n    } while ((undefined *)((ulonglong)puVar1 & 0xfffffffffffff000) != puVar2);\n  }\n  return;\n}\n\n",
  "__acrt_lowio_destroy_handle_array": "\n/* Library Function - Single Match\n    __acrt_lowio_destroy_handle_array\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_lowio_destroy_handle_array(LPCRITICAL_SECTION param_1)\n\n{\n  LPCRITICAL_SECTION lpCriticalSection;\n  \n  if (param_1 != (LPCRITICAL_SECTION)0x0) {\n    lpCriticalSection = param_1;\n    if (param_1 != (LPCRITICAL_SECTION)&param_1[0x73].LockCount) {\n      do {\n        DeleteCriticalSection(lpCriticalSection);\n        lpCriticalSection = (LPCRITICAL_SECTION)&lpCriticalSection[1].SpinCount;\n      } while (lpCriticalSection != (LPCRITICAL_SECTION)&param_1[0x73].LockCount);\n    }\n    _free_base(param_1);\n  }\n  return;\n}\n\n",
  "FUN_14002266a": "\nvoid FUN_14002266a(undefined8 param_1,longlong param_2)\n\n{\n  __acrt_unlock(**(int **)(param_2 + 0x98));\n  return;\n}\n\n",
  "FUN_14000bb6c": "\nvoid FUN_14000bb6c(UWMap4 *param_1,int param_2,int param_3,longlong *param_4,longlong *param_5)\n\n{\n  undefined4 *puVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  bool bVar5;\n  bool bVar6;\n  uchar *puVar7;\n  int iVar8;\n  uchar *puVar9;\n  uchar *local_res8;\n  int local_res10;\n  \n  local_res8 = *(uchar **)(param_1 + 8);\n  bVar5 = false;\n  bVar6 = false;\n  iVar8 = 0;\n  puVar7 = local_res8 + -1;\n  puVar9 = puVar7;\n  local_res10 = param_2;\n  if (0 < *(int *)param_1) {\n    do {\n      if (iVar8 == param_2) {\n        bVar5 = true;\n        puVar7 = local_res8;\n      }\n      if (iVar8 == param_3) {\n        bVar6 = true;\n        puVar9 = local_res8;\n      }\n      if ((bVar5) && (bVar6)) break;\n      FH4::UWMap4::ReadEntry(param_1,&local_res8);\n      iVar8 = iVar8 + 1;\n    } while (iVar8 < *(int *)param_1);\n  }\n  puVar1 = (undefined4 *)*param_4;\n  param_4[1] = (longlong)puVar7;\n  uVar2 = *(undefined4 *)(param_1 + 4);\n  uVar3 = *(undefined4 *)(param_1 + 8);\n  uVar4 = *(undefined4 *)(param_1 + 0xc);\n  *puVar1 = *(undefined4 *)param_1;\n  puVar1[1] = uVar2;\n  puVar1[2] = uVar3;\n  puVar1[3] = uVar4;\n  uVar2 = *(undefined4 *)(param_1 + 0x14);\n  uVar3 = *(undefined4 *)(param_1 + 0x18);\n  uVar4 = *(undefined4 *)(param_1 + 0x1c);\n  puVar1[4] = *(undefined4 *)(param_1 + 0x10);\n  puVar1[5] = uVar2;\n  puVar1[6] = uVar3;\n  puVar1[7] = uVar4;\n  puVar1 = (undefined4 *)*param_5;\n  param_5[1] = (longlong)puVar9;\n  uVar2 = *(undefined4 *)(param_1 + 4);\n  uVar3 = *(undefined4 *)(param_1 + 8);\n  uVar4 = *(undefined4 *)(param_1 + 0xc);\n  *puVar1 = *(undefined4 *)param_1;\n  puVar1[1] = uVar2;\n  puVar1[2] = uVar3;\n  puVar1[3] = uVar4;\n  uVar2 = *(undefined4 *)(param_1 + 0x14);\n  uVar3 = *(undefined4 *)(param_1 + 0x18);\n  uVar4 = *(undefined4 *)(param_1 + 0x1c);\n  puVar1[4] = *(undefined4 *)(param_1 + 0x10);\n  puVar1[5] = uVar2;\n  puVar1[6] = uVar3;\n  puVar1[7] = uVar4;\n  return;\n}\n\n",
  "FUN_1400076a8": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_1400076a8(PVOID *param_1,ULONG_PTR param_2,ULONG_PTR param_3,ULONG_PTR param_4,\n                  ULONG_PTR param_5,undefined8 param_6,int param_7,int param_8,longlong param_9,\n                  PVOID *param_10,byte param_11)\n\n{\n  undefined auStackY_e8 [32];\n  EXCEPTION_RECORD local_b8;\n  ulonglong local_18;\n  \n  local_18 = DAT_140035020 ^ (ulonglong)auStackY_e8;\n  local_b8.ExceptionCode = _DAT_1400247a0;\n  local_b8.ExceptionFlags = _UNK_1400247a4;\n  local_b8.ExceptionRecord._0_4_ = _UNK_1400247a8;\n  local_b8.ExceptionRecord._4_4_ = _UNK_1400247ac;\n  local_b8.ExceptionAddress._0_4_ = _DAT_1400247b0;\n  local_b8.ExceptionAddress._4_4_ = _UNK_1400247b4;\n  local_b8.NumberParameters = _UNK_1400247b8;\n  local_b8._28_4_ = _UNK_1400247bc;\n  local_b8.ExceptionInformation[10]._0_4_ = _DAT_140024810;\n  local_b8.ExceptionInformation[10]._4_4_ = _UNK_140024814;\n  local_b8.ExceptionInformation[0xc]._0_4_ = _DAT_140024820;\n  local_b8.ExceptionInformation[0xc]._4_4_ = _UNK_140024824;\n  local_b8.ExceptionInformation[0xd]._0_4_ = _UNK_140024828;\n  local_b8.ExceptionInformation[0xd]._4_4_ = _UNK_14002482c;\n  local_b8.ExceptionInformation[0xe] = DAT_140024830;\n  local_b8.ExceptionInformation[0] = (ULONG_PTR)&LAB_14000af9c;\n  local_b8.ExceptionInformation[2] = param_5;\n  local_b8.ExceptionInformation[3] = (ULONG_PTR)param_7;\n  local_b8.ExceptionInformation[7] = (ULONG_PTR)param_11;\n  local_b8.ExceptionInformation[5] = *(longlong *)(param_9 + 0x18) + (longlong)param_10[1];\n  local_b8.ExceptionInformation[9] = *(longlong *)(param_9 + 0x20) + (longlong)param_10[1];\n  local_b8.ExceptionInformation[0xb] = (ULONG_PTR)param_8;\n  local_b8.ExceptionInformation[8] = 0x19930520;\n  local_b8.ExceptionInformation[1] = param_4;\n  local_b8.ExceptionInformation[4] = param_3;\n  local_b8.ExceptionInformation[6] = param_2;\n  RtlUnwindEx(*param_1,*param_10,&local_b8,(PVOID)0x0,(PCONTEXT)param_10[5],\n              (PUNWIND_HISTORY_TABLE)param_10[8]);\n  FUN_140006060(local_18 ^ (ulonglong)auStackY_e8);\n  return;\n}\n\n",
  "FUN_1400077c8": "\nvoid FUN_1400077c8(longlong param_1,longlong param_2)\n\n{\n  byte bVar1;\n  undefined4 uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  ulonglong uVar7;\n  \n  pbVar6 = *(byte **)(param_1 + 0x10);\n  *(byte **)(param_1 + 8) = pbVar6;\n  bVar1 = (&DAT_140024790)[*pbVar6 & 0xf];\n  pbVar6 = pbVar6 + -(longlong)(char)(&DAT_140024780)[*pbVar6 & 0xf];\n  uVar4 = *(uint *)(pbVar6 + -4);\n  *(byte **)(param_1 + 8) = pbVar6;\n  *(uint *)(param_1 + 0x18) = uVar4 >> (bVar1 & 0x1f);\n  bVar1 = (&DAT_140024790)[*pbVar6 & 0xf];\n  pbVar6 = pbVar6 + -(longlong)(char)(&DAT_140024780)[*pbVar6 & 0xf];\n  uVar4 = *(uint *)(pbVar6 + -4);\n  *(byte **)(param_1 + 8) = pbVar6;\n  *(uint *)(param_1 + 0x1c) = uVar4 >> (bVar1 & 0x1f);\n  bVar1 = (&DAT_140024790)[*pbVar6 & 0xf];\n  pbVar6 = pbVar6 + -(longlong)(char)(&DAT_140024780)[*pbVar6 & 0xf];\n  uVar4 = *(uint *)(pbVar6 + -4);\n  iVar3 = *(int *)(param_2 + 8);\n  *(byte **)(param_1 + 8) = pbVar6;\n  *(uint *)(param_1 + 0x20) = uVar4 >> (bVar1 & 0x1f);\n  uVar2 = *(undefined4 *)pbVar6;\n  *(byte **)(param_1 + 8) = pbVar6 + 4;\n  *(undefined4 *)(param_1 + 0x24) = uVar2;\n  if (iVar3 != 0) {\n    uVar7 = (ulonglong)*(uint *)(param_2 + 8);\n    do {\n      uVar4 = **(byte **)(param_1 + 8) & 0xf;\n      bVar1 = (&DAT_140024790)[uVar4];\n      pbVar6 = *(byte **)(param_1 + 8) + -(longlong)(char)(&DAT_140024780)[uVar4];\n      uVar4 = *(uint *)(pbVar6 + -4);\n      *(byte **)(param_1 + 8) = pbVar6;\n      *(uint *)(param_1 + 0x18) = uVar4 >> (bVar1 & 0x1f);\n      bVar1 = (&DAT_140024790)[*pbVar6 & 0xf];\n      pbVar6 = pbVar6 + -(longlong)(char)(&DAT_140024780)[*pbVar6 & 0xf];\n      uVar4 = *(uint *)(pbVar6 + -4);\n      *(byte **)(param_1 + 8) = pbVar6;\n      *(uint *)(param_1 + 0x1c) = uVar4 >> (bVar1 & 0x1f);\n      bVar1 = (&DAT_140024790)[*pbVar6 & 0xf];\n      pbVar6 = pbVar6 + -(longlong)(char)(&DAT_140024780)[*pbVar6 & 0xf];\n      uVar4 = *(uint *)(pbVar6 + -4);\n      *(byte **)(param_1 + 8) = pbVar6;\n      *(uint *)(param_1 + 0x20) = uVar4 >> (bVar1 & 0x1f);\n      pbVar5 = pbVar6 + 4;\n      *(undefined4 *)(param_1 + 0x24) = *(undefined4 *)pbVar6;\n      *(byte **)(param_1 + 8) = pbVar5;\n      bVar1 = (&DAT_140024790)[*pbVar5 & 0xf];\n      pbVar5 = pbVar5 + -(longlong)(char)(&DAT_140024780)[*pbVar5 & 0xf];\n      uVar4 = *(uint *)(pbVar5 + -4);\n      *(byte **)(param_1 + 8) = pbVar5;\n      *(uint *)(param_1 + 0x18) = uVar4 >> (bVar1 & 0x1f);\n      bVar1 = (&DAT_140024790)[*pbVar5 & 0xf];\n      pbVar5 = pbVar5 + -(longlong)(char)(&DAT_140024780)[*pbVar5 & 0xf];\n      uVar4 = *(uint *)(pbVar5 + -4);\n      *(byte **)(param_1 + 8) = pbVar5;\n      *(uint *)(param_1 + 0x1c) = uVar4 >> (bVar1 & 0x1f);\n      pbVar6 = pbVar5 + -(longlong)(char)(&DAT_140024780)[*pbVar5 & 0xf];\n      *(uint *)(param_1 + 0x20) = *(uint *)(pbVar6 + -4) >> ((&DAT_140024790)[*pbVar5 & 0xf] & 0x1f)\n      ;\n      *(byte **)(param_1 + 8) = pbVar6;\n      uVar2 = *(undefined4 *)pbVar6;\n      *(byte **)(param_1 + 8) = pbVar6 + 4;\n      *(undefined4 *)(param_1 + 0x24) = uVar2;\n      uVar7 = uVar7 - 1;\n    } while (uVar7 != 0);\n  }\n  return;\n}\n\n",
  "FUN_140001860": "\nLPVOID FUN_140001860(LPVOID param_1,ulonglong param_2)\n\n{\n  if ((param_2 & 1) != 0) {\n    thunk_FUN_14000ce08(param_1);\n  }\n  return param_1;\n}\n\n",
  "FUN_14000c140": "\nvoid FUN_14000c140(void)\n\n{\n  code *pcVar1;\n  \n  pcVar1 = (code *)FUN_14000bd20();\n  (*pcVar1)();\n  FUN_14000bd50();\n  return;\n}\n\n",
  "FUN_1400044ec": "\nvoid FUN_1400044ec(longlong param_1)\n\n{\n  if (*(longlong *)(param_1 + 0x80) != 0) {\n    FUN_14000d390(*(longlong *)(param_1 + 0x80));\n  }\n  return;\n}\n\n",
  "FUN_140007c7c": "\nvoid FUN_140007c7c(void)\n\n{\n  longlong lVar1;\n  \n  lVar1 = FUN_140007c70();\n  if (lVar1 != 0) {\n    (*(code *)PTR__guard_dispatch_icall_140023298)();\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "__raise_securityfailure": "\n/* Library Function - Single Match\n    __raise_securityfailure\n   \n   Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __raise_securityfailure(_EXCEPTION_POINTERS *param_1)\n\n{\n  HANDLE hProcess;\n  \n  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);\n  UnhandledExceptionFilter(param_1);\n  hProcess = GetCurrentProcess();\n                    /* WARNING: Could not recover jumptable at 0x00014000673d. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  TerminateProcess(hProcess,0xc0000409);\n  return;\n}\n\n",
  "FUN_140007a58": "\nvoid FUN_140007a58(undefined8 param_1)\n\n{\n  longlong lVar1;\n  \n  lVar1 = FUN_140008b20();\n  *(undefined8 *)(lVar1 + 0x68) = param_1;\n  return;\n}\n\n",
  "FUN_140022844": "\nvoid FUN_140022844(void)\n\n{\n  __acrt_unlock(5);\n  return;\n}\n\n",
  "__vcrt_FlsFree": "\n/* Library Function - Single Match\n    __vcrt_FlsFree\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __vcrt_FlsFree(undefined4 param_1)\n\n{\n  FARPROC pFVar1;\n  \n  pFVar1 = FUN_14000bdf8(1,\"FlsFree\",(uint *)&DAT_140025798,(uint *)\"FlsFree\");\n  if (pFVar1 != (FARPROC)0x0) {\n    (*(code *)PTR__guard_dispatch_icall_140023298)();\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x00014000bfcf. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  TlsFree(param_1);\n  return;\n}\n\n",
  "_itow_s": "\n/* Library Function - Single Match\n    _itow_s\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nerrno_t __cdecl _itow_s(int _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix)\n\n{\n  bool bVar1;\n  int iVar2;\n  \n  bVar1 = false;\n  if ((_Radix == 10) && (_Val < 0)) {\n    bVar1 = true;\n  }\n  iVar2 = common_xtox_s<unsigned_long,wchar_t>(_Val,_DstBuf,_SizeInWords,_Radix,bVar1);\n  return iVar2;\n}\n\n",
  "FUN_140006a80": "\nundefined8 FUN_140006a80(void)\n\n{\n  return 0x4000;\n}\n\n",
  "TypeMatchHelper<class___FrameHandler3>": "\n/* Library Function - Single Match\n    int __cdecl TypeMatchHelper<class __FrameHandler3>(struct _s_HandlerType const * __ptr64,struct\n   _s_CatchableType const * __ptr64,struct _s_ThrowInfo const * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\nTypeMatchHelper<class___FrameHandler3>\n          (_s_HandlerType *param_1,_s_CatchableType *param_2,_s_ThrowInfo *param_3)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  longlong lVar4;\n  longlong lVar5;\n  char *pcVar6;\n  int iVar7;\n  longlong lVar8;\n  \n  lVar8 = 0;\n  iVar7 = 0;\n  if (*(int *)(param_1 + 4) != 0) {\n    iVar3 = *(int *)(param_1 + 4);\n    lVar4 = _GetImageBase();\n    if (lVar4 + iVar3 != 0) {\n      lVar4 = lVar8;\n      if (iVar3 != 0) {\n        iVar7 = *(int *)(param_1 + 4);\n        lVar4 = _GetImageBase();\n        lVar4 = iVar7 + lVar4;\n      }\n      if ((*(char *)(lVar4 + 0x10) != '\\0') &&\n         ((((byte)*param_1 & 0x80) == 0 || (((byte)*param_2 & 0x10) == 0)))) {\n        lVar4 = lVar8;\n        if (iVar7 != 0) {\n          lVar4 = _GetImageBase();\n          lVar4 = lVar4 + *(int *)(param_1 + 4);\n        }\n        lVar5 = _GetThrowImageBase();\n        if (lVar4 != lVar5 + *(int *)(param_2 + 4)) {\n          lVar4 = lVar8;\n          if (*(int *)(param_1 + 4) != 0) {\n            lVar4 = _GetImageBase();\n            lVar4 = lVar4 + *(int *)(param_1 + 4);\n          }\n          lVar5 = _GetThrowImageBase();\n          pcVar6 = (char *)(lVar4 + 0x10);\n          lVar4 = ((longlong)*(int *)(param_2 + 4) + 0x10 + lVar5) - (longlong)pcVar6;\n          do {\n            cVar1 = *pcVar6;\n            cVar2 = pcVar6[lVar4];\n            if (cVar1 != cVar2) break;\n            pcVar6 = pcVar6 + 1;\n          } while (cVar2 != '\\0');\n          if (cVar1 != cVar2) {\n            return 0;\n          }\n        }\n        if (((((((byte)*param_2 & 2) == 0) || (((byte)*param_1 & 8) != 0)) &&\n             (((*(byte *)&param_3->attributes & 1) == 0 || (((byte)*param_1 & 1) != 0)))) &&\n            (((*(byte *)&param_3->attributes & 4) == 0 || (((byte)*param_1 & 4) != 0)))) &&\n           (((*(byte *)&param_3->attributes & 2) == 0 || (lVar8 = 0, ((byte)*param_1 & 2) != 0)))) {\n          lVar8 = 1;\n        }\n        return (int)lVar8;\n      }\n    }\n  }\n  return 1;\n}\n\n",
  "FUN_140006a88": "\nvoid FUN_140006a88(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x000140006a8f. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  InitializeSListHead(&DAT_140036d00);\n  return;\n}\n\n",
  "__GSHandlerCheck_EH": "\n/* Library Function - Single Match\n    __GSHandlerCheck_EH\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __GSHandlerCheck_EH(EHExceptionRecord *param_1,ulonglong param_2,_CONTEXT *param_3,\n                        _xDISPATCHER_CONTEXT *param_4)\n\n{\n  longlong lVar1;\n  \n  lVar1 = *(longlong *)(param_4 + 0x38);\n  __GSHandlerCheckCommon(param_2,(longlong)param_4,(uint *)(lVar1 + 4));\n  if ((*(uint *)(lVar1 + 4) & ((*(uint *)(param_1 + 4) & 0x66) != 0) + 1) != 0) {\n    __CxxFrameHandler3(param_1,param_2,param_3,param_4);\n  }\n  return;\n}\n\n",
  "FUN_140021f20": "\nvoid FUN_140021f20(undefined8 param_1,longlong param_2)\n\n{\n  thunk_FUN_14000ce08(*(LPVOID *)(param_2 + 0xd0));\n  return;\n}\n\n",
  "_free_osfhnd": "\n/* Library Function - Single Match\n    _free_osfhnd\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl _free_osfhnd(int param_1)\n\n{\n  int iVar1;\n  ulonglong uVar2;\n  ulong *puVar3;\n  DWORD nStdHandle;\n  \n  if ((-1 < param_1) && ((uint)param_1 < DAT_140037890)) {\n    uVar2 = (ulonglong)(param_1 & 0x3f);\n    if (((*(byte *)((&DAT_140037490)[(longlong)param_1 >> 6] + 0x38 + uVar2 * 0x48) & 1) != 0) &&\n       (*(longlong *)((&DAT_140037490)[(longlong)param_1 >> 6] + 0x28 + uVar2 * 0x48) != -1)) {\n      iVar1 = FUN_140011e04();\n      if (iVar1 == 1) {\n        if (param_1 == 0) {\n          nStdHandle = 0xfffffff6;\n        }\n        else if (param_1 == 1) {\n          nStdHandle = 0xfffffff5;\n        }\n        else {\n          if (param_1 != 2) goto LAB_14001c5b4;\n          nStdHandle = 0xfffffff4;\n        }\n        SetStdHandle(nStdHandle,(HANDLE)0x0);\n      }\nLAB_14001c5b4:\n      *(undefined8 *)((&DAT_140037490)[(longlong)param_1 >> 6] + 0x28 + uVar2 * 0x48) =\n           0xffffffffffffffff;\n      return 0;\n    }\n  }\n  puVar3 = __doserrno();\n  *puVar3 = 9;\n  puVar3 = __doserrno();\n  *puVar3 = 0;\n  return -1;\n}\n\n",
  "FUN_14002271b": "\nvoid FUN_14002271b(int **param_1)\n\n{\n  FUN_140012770(**param_1);\n  return;\n}\n\n",
  "__acrt_call_reportfault": "\n/* Library Function - Single Match\n    __acrt_call_reportfault\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_call_reportfault(int param_1,DWORD param_2,DWORD param_3)\n\n{\n  BOOL BVar1;\n  LONG LVar2;\n  PRUNTIME_FUNCTION FunctionEntry;\n  undefined auStackX_8 [8];\n  undefined auStackY_608 [32];\n  DWORD64 local_5c8;\n  _EXCEPTION_POINTERS local_5c0;\n  ulonglong local_5b0;\n  PVOID local_5a8 [2];\n  EXCEPTION_RECORD local_598;\n  _CONTEXT local_4f8;\n  ulonglong local_28;\n  \n  local_28 = DAT_140035020 ^ (ulonglong)auStackY_608;\n  if (param_1 != -1) {\n    FUN_140006ad8();\n  }\n  FUN_140008580((undefined (*) [16])&local_598,0,0x98);\n  FUN_140008580((undefined (*) [16])&local_4f8,0,0x4d0);\n  local_5c0.ExceptionRecord = &local_598;\n  local_5c0.ContextRecord = &local_4f8;\n  RtlCaptureContext(&local_4f8);\n  FunctionEntry = RtlLookupFunctionEntry(local_4f8.Rip,&local_5c8,(PUNWIND_HISTORY_TABLE)0x0);\n  if (FunctionEntry != (PRUNTIME_FUNCTION)0x0) {\n    RtlVirtualUnwind(0,local_5c8,local_4f8.Rip,FunctionEntry,&local_4f8,local_5a8,&local_5b0,\n                     (PKNONVOLATILE_CONTEXT_POINTERS)0x0);\n  }\n  local_4f8.Rsp = (DWORD64)auStackX_8;\n  local_598.ExceptionCode = param_2;\n  local_598.ExceptionFlags = param_3;\n  BVar1 = IsDebuggerPresent();\n  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);\n  LVar2 = UnhandledExceptionFilter(&local_5c0);\n  if (((LVar2 == 0) && (BVar1 == 0)) && (param_1 != -1)) {\n    FUN_140006ad8();\n  }\n  FUN_140006060(local_28 ^ (ulonglong)auStackY_608);\n  return;\n}\n\n",
  "FUN_140011e0c": "\nvoid FUN_140011e0c(undefined4 param_1)\n\n{\n  DAT_140037100 = param_1;\n  return;\n}\n\n",
  "FUN_140006060": "\nvoid FUN_140006060(longlong param_1)\n\n{\n  if ((param_1 == DAT_140035020) && ((short)((ulonglong)param_1 >> 0x30) == 0)) {\n    return;\n  }\n  FUN_140006744();\n  return;\n}\n\n",
  "_initterm": "\n/* Library Function - Single Match\n    _initterm\n   \n   Library: Visual Studio 2019 Release */\n\nvoid _initterm(undefined **param_1,undefined **param_2)\n\n{\n  ulonglong uVar1;\n  ulonglong uVar2;\n  \n  uVar1 = 0;\n  uVar2 = (ulonglong)((longlong)param_2 + (7 - (longlong)param_1)) >> 3;\n  if (param_2 < param_1) {\n    uVar2 = uVar1;\n  }\n  if (uVar2 != 0) {\n    do {\n      if (*param_1 != (undefined *)0x0) {\n        (*(code *)PTR__guard_dispatch_icall_140023298)();\n      }\n      param_1 = param_1 + 1;\n      uVar1 = uVar1 + 1;\n    } while (uVar1 != uVar2);\n  }\n  return;\n}\n\n",
  "__vcrt_FlsSetValue": "\n/* Library Function - Single Match\n    __vcrt_FlsSetValue\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __vcrt_FlsSetValue(DWORD param_1,LPVOID param_2)\n\n{\n  FARPROC pFVar1;\n  \n  pFVar1 = FUN_14000bdf8(3,\"FlsSetValue\",(uint *)&DAT_1400257c0,(uint *)\"FlsSetValue\");\n  if (pFVar1 == (FARPROC)0x0) {\n    TlsSetValue(param_1,param_2);\n  }\n  else {\n    (*(code *)PTR__guard_dispatch_icall_140023298)();\n  }\n  return;\n}\n\n",
  "_Tidy": "\n/* Library Function - Single Match\n    private: void __cdecl std::ios_base::_Tidy(void) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __thiscall std::ios_base::_Tidy(ios_base *this)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  \n  for (puVar2 = *(undefined8 **)(this + 0x38); puVar2 != (undefined8 *)0x0;\n      puVar2 = (undefined8 *)*puVar2) {\n    (*(code *)PTR__guard_dispatch_icall_140023298)(0,this,*(undefined4 *)(puVar2 + 1));\n  }\n  puVar2 = *(undefined8 **)(this + 0x30);\n  while (puVar2 != (undefined8 *)0x0) {\n    puVar1 = (undefined8 *)*puVar2;\n    thunk_FUN_14000ce08(puVar2);\n    puVar2 = puVar1;\n  }\n  *(undefined8 *)(this + 0x30) = 0;\n  puVar2 = *(undefined8 **)(this + 0x38);\n  while (puVar2 != (undefined8 *)0x0) {\n    puVar1 = (undefined8 *)*puVar2;\n    thunk_FUN_14000ce08(puVar2);\n    puVar2 = puVar1;\n  }\n  *(undefined8 *)(this + 0x38) = 0;\n  return;\n}\n\n",
  "_Tolower": "\n/* Library Function - Single Match\n    _Tolower\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _Tolower(int param_1,_Ctypevec *param_2)\n\n{\n  UINT _CchDest;\n  int iVar1;\n  wchar_t **ppwVar2;\n  ushort *puVar3;\n  uint uVar4;\n  _locale_t _Plocinfo;\n  BOOL unaff_EDI;\n  LPCSTR _LpSrcStr;\n  undefined local_res10;\n  undefined local_res11;\n  undefined local_res12;\n  byte local_res18;\n  undefined local_res19;\n  undefined4 in_stack_ffffffffffffffd4;\n  \n  if (param_2 == (_Ctypevec *)0x0) {\n    ppwVar2 = ___lc_locale_name_func();\n    _Plocinfo = (_locale_t)ppwVar2[2];\n    _CchDest = ___lc_codepage_func();\n  }\n  else {\n    _Plocinfo = (_locale_t)param_2->_LocaleName;\n    _CchDest = param_2->_Page;\n  }\n  if (_Plocinfo == (_locale_t)0x0) {\n    if (0x19 < param_1 - 0x41U) {\n      return param_1;\n    }\n    return param_1 + 0x20;\n  }\n  if ((uint)param_1 < 0x100) {\n    if (param_2 != (_Ctypevec *)0x0) {\n      if ((*(byte *)(param_2->_Table + param_1) & 1) == 0) {\n        return param_1;\n      }\n      goto LAB_140005972;\n    }\n    iVar1 = isupper(param_1);\n    if (iVar1 == 0) {\n      return param_1;\n    }\n  }\n  else {\nLAB_140005972:\n    if (param_2 != (_Ctypevec *)0x0) {\n      uVar4 = (uint)(int)param_2->_Table[(longlong)param_1 >> 8 & 0xff] >> 0xf & 1;\n      goto LAB_1400059ab;\n    }\n  }\n  puVar3 = __pctype_func();\n  uVar4 = puVar3[param_1 >> 8 & 0xff] & 0x8000;\nLAB_1400059ab:\n  if (uVar4 == 0) {\n    _LpSrcStr = (LPCSTR)0x1;\n    local_res11 = 0;\n    local_res10 = (char)param_1;\n  }\n  else {\n    _LpSrcStr = (LPCSTR)0x2;\n    local_res12 = 0;\n    local_res10 = (char)((uint)param_1 >> 8);\n    local_res11 = (char)param_1;\n  }\n  iVar1 = __crtLCMapStringA(_Plocinfo,(LPCWSTR)0x100,(DWORD)&local_res10,_LpSrcStr,(int)&local_res18\n                            ,(LPSTR)CONCAT44(in_stack_ffffffffffffffd4,3),_CchDest,1,unaff_EDI);\n  if ((iVar1 != 0) && (param_1 = (int)local_res18, iVar1 != 1)) {\n    param_1 = (int)CONCAT11(local_res18,local_res19);\n  }\n  return param_1;\n}\n\n",
  "GetEstablisherFrame": "\n/* Library Function - Single Match\n    public: static unsigned __int64 * __ptr64 __cdecl __FrameHandler3::GetEstablisherFrame(unsigned\n   __int64 * __ptr64,struct _xDISPATCHER_CONTEXT * __ptr64,struct _s_FuncInfo const *\n   __ptr64,unsigned __int64 * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\n__uint64 * __cdecl\n__FrameHandler3::GetEstablisherFrame\n          (__uint64 *param_1,_xDISPATCHER_CONTEXT *param_2,_s_FuncInfo *param_3,__uint64 *param_4)\n\n{\n  uint uVar1;\n  int iVar2;\n  PRUNTIME_FUNCTION p_Var3;\n  uint uVar4;\n  ulonglong uVar5;\n  int *piVar6;\n  longlong lVar7;\n  ulonglong uVar8;\n  longlong lVar9;\n  ulonglong local_res8;\n  \n  uVar8 = (ulonglong)param_3->nTryBlocks;\n  iVar2 = FUN_140008d54((longlong)param_3,(ulonglong *)param_2);\n  *param_4 = *param_1;\n  do {\n    do {\n      if ((int)uVar8 == 0) {\n        return param_4;\n      }\n      uVar8 = (ulonglong)((int)uVar8 - 1);\n      lVar7 = (longlong)(int)param_3->dispTryBlockMap + uVar8 * 0x14 + *(longlong *)(param_2 + 8);\n    } while ((iVar2 <= *(int *)(lVar7 + 4)) || (*(int *)(lVar7 + 8) < iVar2));\n    p_Var3 = RtlLookupFunctionEntry(*(DWORD64 *)param_2,&local_res8,(PUNWIND_HISTORY_TABLE)0x0);\n    uVar5 = 0;\n    lVar9 = (longlong)*(int *)(lVar7 + 0x10) + local_res8;\n    uVar1 = *(uint *)(lVar7 + 0xc);\n    if (uVar1 != 0) {\n      piVar6 = (int *)(lVar9 + 0xc);\n      do {\n        if ((longlong)*piVar6 == (ulonglong)p_Var3->BeginAddress) goto LAB_1400072a7;\n        uVar4 = (int)uVar5 + 1;\n        uVar5 = (ulonglong)uVar4;\n        piVar6 = piVar6 + 5;\n      } while (uVar4 < uVar1);\n    }\n  } while (uVar1 <= (uint)uVar5);\nLAB_1400072a7:\n  *param_4 = *(__uint64 *)((longlong)*(int *)(lVar9 + 0x10 + uVar5 * 0x14) + *param_1);\n  return param_4;\n}\n\n",
  "FUN_1400142f4": "\nundefined4 FUN_1400142f4(void)\n\n{\n  return DAT_140037284;\n}\n\n",
  "FUN_140008d5c": "\nvoid FUN_140008d5c(FuncInfo4 *param_1,_xDISPATCHER_CONTEXT *param_2)\n\n{\n  __FrameHandler4::StateFromIp(param_1,param_2,*(__uint64 *)param_2);\n  return;\n}\n\n",
  "FUN_1400032e0": "\nvoid FUN_1400032e0(longlong **param_1)\n\n{\n  longlong *plVar1;\n  \n  plVar1 = *(longlong **)((longlong)*(int *)(**param_1 + 4) + 0x48 + (longlong)*param_1);\n  if (plVar1 != (longlong *)0x0) {\n    (**(code **)(*plVar1 + 0x10))();\n  }\n  return;\n}\n\n",
  "_exception_enabled": "\n/* Library Function - Single Match\n    _exception_enabled\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nbool _exception_enabled(uint param_1,ulonglong param_2)\n\n{\n  uint uVar1;\n  \n  uVar1 = param_1 & 0x1f;\n  if (((param_1 & 8) == 0) || (-1 < (char)param_2)) {\n    if (((param_1 & 4) == 0) || ((param_2 >> 9 & 1) == 0)) {\n      if (((param_1 & 1) == 0) || ((param_2 >> 10 & 1) == 0)) {\n        if (((param_1 & 2) != 0) && ((param_2 >> 0xb & 1) != 0)) {\n          if ((param_1 & 0x10) != 0) {\n            _set_statfp(0x10);\n          }\n          uVar1 = param_1 & 0x1d;\n        }\n      }\n      else {\n        _set_statfp(8);\n        uVar1 = param_1 & 0x1e;\n      }\n    }\n    else {\n      _set_statfp(4);\n      uVar1 = param_1 & 0x1b;\n    }\n  }\n  else {\n    _set_statfp(1);\n    uVar1 = param_1 & 0x17;\n  }\n  if (((param_1 & 0x10) != 0) && ((param_2 >> 0xc & 1) != 0)) {\n    _set_statfp(0x20);\n    uVar1 = uVar1 & 0xffffffef;\n  }\n  return uVar1 == 0;\n}\n\n",
  "_isctype_l": "\n/* Library Function - Single Match\n    _isctype_l\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _isctype_l(int _C,int _Type,_locale_t _Locale)\n\n{\n  int iVar1;\n  undefined auStackY_88 [32];\n  CHAR local_48;\n  CHAR local_47;\n  undefined local_46;\n  longlong local_40;\n  longlong *local_38 [2];\n  char local_28;\n  WORD local_20 [4];\n  ulonglong local_18;\n  \n  local_18 = DAT_140035020 ^ (ulonglong)auStackY_88;\n  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_40,(__crt_locale_pointers *)_Locale);\n  if (0x100 < _C + 1U) {\n    iVar1 = 1;\n    if (*(short *)(*local_38[0] + (ulonglong)(_C >> 8 & 0xff) * 2) < 0) {\n      iVar1 = 2;\n      local_46 = 0;\n      local_48 = (CHAR)((uint)_C >> 8);\n      local_47 = (CHAR)_C;\n    }\n    else {\n      local_47 = '\\0';\n      local_48 = (CHAR)_C;\n    }\n    local_20[0] = 0;\n    local_20[1] = 0;\n    local_20[2] = 0;\n    iVar1 = __acrt_GetStringTypeA\n                      ((__crt_locale_pointers *)local_38,1,&local_48,iVar1,local_20,\n                       *(UINT *)((longlong)local_38[0] + 0xc),1);\n    if (iVar1 == 0) {\n      if (local_28 != '\\0') {\n        *(uint *)(local_40 + 0x3a8) = *(uint *)(local_40 + 0x3a8) & 0xfffffffd;\n      }\n      goto LAB_14001517f;\n    }\n  }\n  if (local_28 != '\\0') {\n    *(uint *)(local_40 + 0x3a8) = *(uint *)(local_40 + 0x3a8) & 0xfffffffd;\n  }\nLAB_14001517f:\n  iVar1 = FUN_140006060(local_18 ^ (ulonglong)auStackY_88);\n  return iVar1;\n}\n\n",
  "FUN_140011e14": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nbool FUN_140011e14(void)\n\n{\n  byte bVar1;\n  \n  bVar1 = (byte)DAT_140035020 & 0x3f;\n  return ((DAT_140035020 ^ _DAT_140037108) >> bVar1 |\n         (DAT_140035020 ^ _DAT_140037108) << 0x40 - bVar1) != 0;\n}\n\n",
  "FUN_140022736": "\nvoid FUN_140022736(undefined8 param_1,longlong param_2)\n\n{\n  __acrt_unlock(**(int **)(param_2 + 0x58));\n  return;\n}\n\n",
  "FUN_140002700": "\nvoid FUN_140002700(void)\n\n{\n  code *pcVar1;\n  \n  FUN_140003a8c(\"invalid string position\");\n  pcVar1 = (code *)swi(3);\n  (*pcVar1)();\n  return;\n}\n\n",
  "FUN_140022614": "\nvoid FUN_140022614(void)\n\n{\n  longlong lVar1;\n  \n  lVar1 = FUN_140008b20();\n  if (0 < *(int *)(lVar1 + 0x30)) {\n    lVar1 = FUN_140008b20();\n    *(int *)(lVar1 + 0x30) = *(int *)(lVar1 + 0x30) + -1;\n  }\n  return;\n}\n\n",
  "__acrt_lowio_ensure_fh_exists": "\n/* Library Function - Single Match\n    __acrt_lowio_ensure_fh_exists\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nlonglong __acrt_lowio_ensure_fh_exists(uint param_1)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  longlong lVar3;\n  undefined8 *puVar4;\n  longlong lVar5;\n  \n  if (param_1 < 0x2000) {\n    lVar3 = 0;\n    __acrt_lock(7);\n    lVar5 = lVar3;\n    iVar1 = DAT_140037890;\n    while (iVar1 <= (int)param_1) {\n      if ((&DAT_140037490)[lVar5] == 0) {\n        puVar4 = __acrt_lowio_create_handle_array();\n        (&DAT_140037490)[lVar5] = puVar4;\n        if (puVar4 == (undefined8 *)0x0) {\n          lVar3 = 0xc;\n          break;\n        }\n        iVar1 = DAT_140037890 + 0x40;\n        DAT_140037890 = iVar1;\n      }\n      lVar5 = lVar5 + 1;\n    }\n    __acrt_unlock(7);\n  }\n  else {\n    puVar2 = __doserrno();\n    *puVar2 = 9;\n    FUN_14000d030();\n    lVar3 = 9;\n  }\n  return lVar3;\n}\n\n",
  "__mbsrtowcs_utf8": "\n/* Library Function - Single Match\n    unsigned __int64 __cdecl __crt_mbstring::__mbsrtowcs_utf8(wchar_t * __ptr64,char const * __ptr64\n   * __ptr64,unsigned __int64,struct _Mbstatet * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\n__uint64 __cdecl\n__crt_mbstring::__mbsrtowcs_utf8\n          (wchar_t *param_1,char **param_2,__uint64 param_3,_Mbstatet *param_4)\n\n{\n  ulong *puVar1;\n  wchar32 wVar2;\n  wchar_t *pwVar3;\n  char *pcVar4;\n  char *pcVar5;\n  __uint64 _Var6;\n  wchar32 local_res8 [2];\n  \n  pcVar5 = *param_2;\n  pcVar4 = (char *)0x0;\n  if (param_1 == (wchar_t *)0x0) {\n    while( true ) {\n      if (*pcVar5 == '\\0') {\n        _Var6 = 1;\n      }\n      else if (pcVar5[1] == '\\0') {\n        _Var6 = 2;\n      }\n      else {\n        _Var6 = (ulonglong)(pcVar5[2] != '\\0') + 3;\n      }\n      _Var6 = __mbrtoc32_utf8((wchar32 *)0x0,pcVar5,_Var6,param_4);\n      if (_Var6 == 0xffffffffffffffff) goto LAB_14001f3d9;\n      if (_Var6 == 0) break;\n      if (_Var6 == 4) {\n        pcVar4 = pcVar4 + 1;\n      }\n      pcVar5 = pcVar5 + _Var6;\n      pcVar4 = pcVar4 + 1;\n    }\n  }\n  else {\n    pwVar3 = param_1;\n    if (param_3 != 0) {\n      do {\n        if (*pcVar5 == '\\0') {\n          _Var6 = 1;\n        }\n        else if (pcVar5[1] == '\\0') {\n          _Var6 = 2;\n        }\n        else {\n          _Var6 = (ulonglong)(pcVar5[2] != '\\0') + 3;\n        }\n        _Var6 = __mbrtoc32_utf8(local_res8,pcVar5,_Var6,param_4);\n        if (_Var6 == 0xffffffffffffffff) {\n          *param_2 = pcVar5;\nLAB_14001f3d9:\n          puVar1 = __doserrno();\n          *puVar1 = 0x2a;\n          return 0xffffffffffffffff;\n        }\n        if (_Var6 == 0) {\n          *pwVar3 = L'\\0';\n          pcVar5 = pcVar4;\n          break;\n        }\n        wVar2 = local_res8[0];\n        if (0xffff < (uint)local_res8[0]) {\n          if (param_3 < 2) break;\n          local_res8[0] = local_res8[0] + L'\\xffff0000';\n          param_3 = param_3 - 1;\n          *pwVar3 = (ushort)((uint)local_res8[0] >> 10) | 0xd800;\n          pwVar3 = pwVar3 + 1;\n          wVar2 = (wchar32)((ushort)local_res8[0] & 0x3ff | 0xdc00);\n        }\n        *pwVar3 = (wchar_t)wVar2;\n        pcVar5 = pcVar5 + _Var6;\n        pwVar3 = pwVar3 + 1;\n        param_3 = param_3 - 1;\n      } while (param_3 != 0);\n    }\n    *param_2 = pcVar5;\n    pcVar4 = (char *)((longlong)pwVar3 - (longlong)param_1 >> 1);\n  }\n  return (__uint64)pcVar4;\n}\n\n",
  "FUN_14001b7b4": "\nint FUN_14001b7b4(int param_1,char param_2,__acrt_ptd *param_3,__crt_multibyte_data **param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 *puVar6;\n  int iVar7;\n  __crt_multibyte_data *p_Var8;\n  undefined4 *puVar9;\n  ulong *puVar10;\n  __crt_multibyte_data *p_Var11;\n  longlong lVar12;\n  __crt_multibyte_data *p_Var13;\n  __acrt_ptd *local_res18;\n  __crt_multibyte_data **local_res20;\n  undefined local_38 [4];\n  int local_34 [3];\n  __acrt_ptd **local_28;\n  __crt_multibyte_data ***local_20;\n  \n  local_res18 = param_3;\n  local_res20 = param_4;\n  update_thread_multibyte_data_internal(param_3,param_4);\n  iVar7 = getSystemCP(param_1);\n  if (iVar7 == *(int *)(*(longlong *)(local_res18 + 0x88) + 4)) {\n    return 0;\n  }\n  p_Var8 = (__crt_multibyte_data *)_malloc_base(0x228);\n  if (p_Var8 != (__crt_multibyte_data *)0x0) {\n    lVar12 = 4;\n    puVar6 = *(undefined4 **)(local_res18 + 0x88);\n    p_Var13 = p_Var8;\n    do {\n      p_Var11 = p_Var13;\n      puVar9 = puVar6;\n      uVar3 = puVar9[1];\n      uVar4 = puVar9[2];\n      uVar5 = puVar9[3];\n      *(undefined4 *)p_Var11 = *puVar9;\n      *(undefined4 *)(p_Var11 + 4) = uVar3;\n      *(undefined4 *)(p_Var11 + 8) = uVar4;\n      *(undefined4 *)(p_Var11 + 0xc) = uVar5;\n      uVar3 = puVar9[5];\n      uVar4 = puVar9[6];\n      uVar5 = puVar9[7];\n      *(undefined4 *)(p_Var11 + 0x10) = puVar9[4];\n      *(undefined4 *)(p_Var11 + 0x14) = uVar3;\n      *(undefined4 *)(p_Var11 + 0x18) = uVar4;\n      *(undefined4 *)(p_Var11 + 0x1c) = uVar5;\n      uVar3 = puVar9[9];\n      uVar4 = puVar9[10];\n      uVar5 = puVar9[0xb];\n      *(undefined4 *)(p_Var11 + 0x20) = puVar9[8];\n      *(undefined4 *)(p_Var11 + 0x24) = uVar3;\n      *(undefined4 *)(p_Var11 + 0x28) = uVar4;\n      *(undefined4 *)(p_Var11 + 0x2c) = uVar5;\n      uVar3 = puVar9[0xd];\n      uVar4 = puVar9[0xe];\n      uVar5 = puVar9[0xf];\n      *(undefined4 *)(p_Var11 + 0x30) = puVar9[0xc];\n      *(undefined4 *)(p_Var11 + 0x34) = uVar3;\n      *(undefined4 *)(p_Var11 + 0x38) = uVar4;\n      *(undefined4 *)(p_Var11 + 0x3c) = uVar5;\n      uVar3 = puVar9[0x11];\n      uVar4 = puVar9[0x12];\n      uVar5 = puVar9[0x13];\n      *(undefined4 *)(p_Var11 + 0x40) = puVar9[0x10];\n      *(undefined4 *)(p_Var11 + 0x44) = uVar3;\n      *(undefined4 *)(p_Var11 + 0x48) = uVar4;\n      *(undefined4 *)(p_Var11 + 0x4c) = uVar5;\n      uVar3 = puVar9[0x15];\n      uVar4 = puVar9[0x16];\n      uVar5 = puVar9[0x17];\n      *(undefined4 *)(p_Var11 + 0x50) = puVar9[0x14];\n      *(undefined4 *)(p_Var11 + 0x54) = uVar3;\n      *(undefined4 *)(p_Var11 + 0x58) = uVar4;\n      *(undefined4 *)(p_Var11 + 0x5c) = uVar5;\n      uVar3 = puVar9[0x19];\n      uVar4 = puVar9[0x1a];\n      uVar5 = puVar9[0x1b];\n      *(undefined4 *)(p_Var11 + 0x60) = puVar9[0x18];\n      *(undefined4 *)(p_Var11 + 100) = uVar3;\n      *(undefined4 *)(p_Var11 + 0x68) = uVar4;\n      *(undefined4 *)(p_Var11 + 0x6c) = uVar5;\n      uVar3 = puVar9[0x1d];\n      uVar4 = puVar9[0x1e];\n      uVar5 = puVar9[0x1f];\n      *(undefined4 *)(p_Var11 + 0x70) = puVar9[0x1c];\n      *(undefined4 *)(p_Var11 + 0x74) = uVar3;\n      *(undefined4 *)(p_Var11 + 0x78) = uVar4;\n      *(undefined4 *)(p_Var11 + 0x7c) = uVar5;\n      lVar12 = lVar12 + -1;\n      puVar6 = puVar9 + 0x20;\n      p_Var13 = p_Var11 + 0x80;\n    } while (lVar12 != 0);\n    uVar3 = puVar9[0x21];\n    uVar4 = puVar9[0x22];\n    uVar5 = puVar9[0x23];\n    *(undefined4 *)(p_Var11 + 0x80) = puVar9[0x20];\n    *(undefined4 *)(p_Var11 + 0x84) = uVar3;\n    *(undefined4 *)(p_Var11 + 0x88) = uVar4;\n    *(undefined4 *)(p_Var11 + 0x8c) = uVar5;\n    uVar3 = puVar9[0x25];\n    uVar4 = puVar9[0x26];\n    uVar5 = puVar9[0x27];\n    *(undefined4 *)(p_Var11 + 0x90) = puVar9[0x24];\n    *(undefined4 *)(p_Var11 + 0x94) = uVar3;\n    *(undefined4 *)(p_Var11 + 0x98) = uVar4;\n    *(undefined4 *)(p_Var11 + 0x9c) = uVar5;\n    *(undefined8 *)(p_Var11 + 0xa0) = *(undefined8 *)(puVar9 + 0x28);\n    *(undefined4 *)p_Var8 = 0;\n    iVar7 = _setmbcp_nolock(iVar7,p_Var8);\n    if (iVar7 != -1) {\n      if (param_2 == '\\0') {\n        FUN_140012d38();\n      }\n      piVar2 = *(int **)(local_res18 + 0x88);\n      LOCK();\n      iVar1 = *piVar2;\n      *piVar2 = *piVar2 + -1;\n      UNLOCK();\n      if ((iVar1 == 1) && (*(undefined **)(local_res18 + 0x88) != &DAT_1400355c0)) {\n        _free_base(*(undefined **)(local_res18 + 0x88));\n      }\n      *(undefined4 *)p_Var8 = 1;\n      p_Var13 = (__crt_multibyte_data *)0x0;\n      *(__crt_multibyte_data **)(local_res18 + 0x88) = p_Var8;\n      p_Var8 = p_Var13;\n      if ((((byte)local_res18[0x3a8] & 2) == 0) && (((byte)DAT_140035520 & 1) == 0)) {\n        local_28 = &local_res18;\n        local_20 = &local_res20;\n        local_34[0] = 5;\n        local_34[1] = 5;\n        FUN_14001b304(local_38,local_34 + 1,(longlong **)&local_28,local_34);\n        if (param_2 != '\\0') {\n          PTR_DAT_1400353c0 = *local_res20;\n          p_Var8 = (__crt_multibyte_data *)0x0;\n        }\n      }\n      goto LAB_14001b8ac;\n    }\n    puVar10 = __doserrno();\n    *puVar10 = 0x16;\n  }\n  iVar7 = -1;\nLAB_14001b8ac:\n  _free_base(p_Var8);\n  return iVar7;\n}\n\n",
  "GetUnwindTryBlock": "\n/* Library Function - Single Match\n    public: static int __cdecl __FrameHandler3::GetUnwindTryBlock(unsigned __int64 * __ptr64,struct\n   _xDISPATCHER_CONTEXT * __ptr64,struct _s_FuncInfo const * __ptr64)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl\n__FrameHandler3::GetUnwindTryBlock\n          (__uint64 *param_1,_xDISPATCHER_CONTEXT *param_2,_s_FuncInfo *param_3)\n\n{\n  __uint64 *p_Var1;\n  __uint64 local_res18 [2];\n  \n  p_Var1 = GetEstablisherFrame(param_1,param_2,param_3,local_res18);\n  return *(int *)((longlong)param_3->dispUnwindHelp + 4 + *p_Var1);\n}\n\n",
  "setvbuf": "\n/* Library Function - Single Match\n    setvbuf\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl setvbuf(FILE *_File,char *_Buf,int _Mode,size_t _Size)\n\n{\n  int iVar1;\n  ulong *puVar2;\n  __crt_seh_guarded_call<int> local_res8 [8];\n  char *local_res10;\n  int local_res18 [2];\n  size_t local_res20;\n  FILE *local_48;\n  FILE *local_40;\n  FILE *local_38;\n  size_t *local_30;\n  FILE **local_28;\n  int *local_20;\n  char **local_18;\n  \n  local_res10 = _Buf;\n  local_res18[0] = _Mode;\n  local_res20 = _Size;\n  local_48 = _File;\n  if ((((_File == (FILE *)0x0) || ((_Mode & 0xffffffbbU) != 0)) || (_Mode == 0x44)) ||\n     (((_Mode & 0xffffffbfU) == 0 && (0x7ffffffd < _Size - 2)))) {\n    puVar2 = __doserrno();\n    *puVar2 = 0x16;\n    FUN_14000d030();\n    iVar1 = -1;\n  }\n  else {\n    local_30 = &local_res20;\n    local_28 = &local_48;\n    local_20 = local_res18;\n    local_18 = &local_res10;\n    local_40 = _File;\n    local_38 = _File;\n    iVar1 = __crt_seh_guarded_call<int>::\n            operator()<class_<lambda_84ec643ea9557e2f7dc01bb0e9624395>,class_<lambda_ca71763b3c0644891230e4f79ea54fa6>&___ptr64,class_<lambda_439a761618c59b0600e24586724d733b>_>\n                      (local_res8,(<lambda_84ec643ea9557e2f7dc01bb0e9624395> *)&local_38,\n                       (<lambda_ca71763b3c0644891230e4f79ea54fa6> *)&local_30,\n                       (<lambda_439a761618c59b0600e24586724d733b> *)&local_40);\n  }\n  return iVar1;\n}\n\n",
  "try_cor_exit_process": "\n/* Library Function - Single Match\n    void __cdecl try_cor_exit_process(unsigned int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl try_cor_exit_process(uint param_1)\n\n{\n  BOOL BVar1;\n  FARPROC pFVar2;\n  HMODULE local_res10 [3];\n  \n  local_res10[0] = (HMODULE)0x0;\n  BVar1 = GetModuleHandleExW(0,L\"mscoree.dll\",local_res10);\n  if (BVar1 != 0) {\n    pFVar2 = GetProcAddress(local_res10[0],\"CorExitProcess\");\n    if (pFVar2 != (FARPROC)0x0) {\n      (*(code *)PTR__guard_dispatch_icall_140023298)(param_1);\n    }\n  }\n  if (local_res10[0] != (HMODULE)0x0) {\n    FreeLibrary(local_res10[0]);\n  }\n  return;\n}\n\n",
  "wcsncmp": "\n/* Library Function - Single Match\n    wcsncmp\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl wcsncmp(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount)\n\n{\n  if (_MaxCount == 0) {\n    return 0;\n  }\n  for (; ((_MaxCount = _MaxCount - 1, _MaxCount != 0 && (*_Str1 != L'\\0')) && (*_Str1 == *_Str2));\n      _Str1 = _Str1 + 1) {\n    _Str2 = _Str2 + 1;\n  }\n  return (uint)(ushort)*_Str1 - (uint)(ushort)*_Str2;\n}\n\n",
  "_strnicmp_l": "\n/* Library Function - Single Match\n    _strnicmp_l\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl _strnicmp_l(char *_Str1,char *_Str2,size_t _MaxCount,_locale_t _Locale)\n\n{\n  byte bVar1;\n  byte bVar2;\n  int iVar3;\n  ulong *puVar4;\n  longlong local_28;\n  longlong local_20;\n  char local_10;\n  \n  if (((_Str1 == (char *)0x0) || (_Str2 == (char *)0x0)) || (0x7fffffff < _MaxCount)) {\n    puVar4 = __doserrno();\n    *puVar4 = 0x16;\n    FUN_14000d030();\n    iVar3 = 0x7fffffff;\n  }\n  else if (_MaxCount == 0) {\n    iVar3 = 0;\n  }\n  else {\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_28,(__crt_locale_pointers *)_Locale);\n    do {\n      bVar1 = *_Str1;\n      _Str1 = (char *)((byte *)_Str1 + 1);\n      bVar1 = *(byte *)((ulonglong)bVar1 + *(longlong *)(local_20 + 0x110));\n      bVar2 = *_Str2;\n      _Str2 = (char *)((byte *)_Str2 + 1);\n      iVar3 = (uint)bVar1 - (uint)*(byte *)((ulonglong)bVar2 + *(longlong *)(local_20 + 0x110));\n      if ((iVar3 != 0) || (bVar1 == 0)) break;\n      _MaxCount = _MaxCount - 1;\n    } while (_MaxCount != 0);\n    if (local_10 != '\\0') {\n      *(uint *)(local_28 + 0x3a8) = *(uint *)(local_28 + 0x3a8) & 0xfffffffd;\n    }\n  }\n  return iVar3;\n}\n\n",
  "getStateFromIterators": "\n/* Library Function - Single Match\n    public: static int __cdecl FH4::UWMap4::getStateFromIterators(class FH4::UWMap4::iterator const\n   & __ptr64,int,class FH4::UWMap4::iterator const & __ptr64,int,class FH4::UWMap4::iterator const &\n   __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\nFH4::UWMap4::getStateFromIterators\n          (iterator *param_1,int param_2,iterator *param_3,int param_4,iterator *param_5)\n\n{\n  uchar *puVar1;\n  UWMap4 *pUVar2;\n  uchar *puStack_10;\n  \n  puVar1 = *(uchar **)(param_5 + 8);\n  if ((*(uchar **)(param_3 + 8) < puVar1) || (puVar1 < *(uchar **)(param_1 + 8))) {\n    param_2 = -1;\n  }\n  else if ((longlong)puVar1 - *(longlong *)(param_1 + 8) <\n           *(longlong *)(param_3 + 8) - (longlong)puVar1) {\n    pUVar2 = *(UWMap4 **)param_1;\n    puStack_10 = *(uchar **)(param_1 + 8);\n    if (puStack_10 < puVar1) {\n      do {\n        ReadEntry(pUVar2,&puStack_10);\n        param_2 = param_2 + 1;\n      } while (puStack_10 < *(uchar **)(param_5 + 8));\n    }\n  }\n  else {\n    pUVar2 = *(UWMap4 **)param_5;\n    puStack_10 = *(uchar **)(param_5 + 8);\n    param_2 = param_4;\n    if (puStack_10 < *(uchar **)(param_3 + 8)) {\n      do {\n        ReadEntry(pUVar2,&puStack_10);\n        param_4 = param_4 + -1;\n        param_2 = param_4;\n      } while (puStack_10 < *(uchar **)(param_3 + 8));\n    }\n  }\n  return param_2;\n}\n\n",
  "exit_or_terminate_process": "\n/* Library Function - Single Match\n    void __cdecl exit_or_terminate_process(unsigned int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl exit_or_terminate_process(uint param_1)\n\n{\n  int iVar1;\n  HANDLE hProcess;\n  \n  iVar1 = __acrt_get_process_end_policy();\n  if ((iVar1 != 1) && ((*(uint *)((longlong)ProcessEnvironmentBlock + 0xbc) >> 8 & 1) == 0)) {\n    hProcess = GetCurrentProcess();\n    TerminateProcess(hProcess,param_1);\n  }\n  try_cor_exit_process(param_1);\n                    /* WARNING: Subroutine does not return */\n  ExitProcess(param_1);\n}\n\n",
  "__wcsrtombs_utf8": "\n/* Library Function - Single Match\n    unsigned __int64 __cdecl __crt_mbstring::__wcsrtombs_utf8(char * __ptr64,wchar_t const * __ptr64\n   * __ptr64,unsigned __int64,struct _Mbstatet * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\n__uint64 __cdecl\n__crt_mbstring::__wcsrtombs_utf8\n          (char *param_1,wchar_t **param_2,__uint64 param_3,_Mbstatet *param_4)\n\n{\n  __uint64 _Var1;\n  wchar16 *pwVar2;\n  wchar16 *pwVar3;\n  char *pcVar4;\n  undefined auStack_78 [32];\n  undefined8 local_58;\n  char local_50 [8];\n  ulonglong local_48;\n  \n  local_48 = DAT_140035020 ^ (ulonglong)auStack_78;\n  pwVar2 = *param_2;\n  pwVar3 = pwVar2;\n  local_58 = param_4;\n  if (param_1 == (char *)0x0) {\n    while ((_Var1 = __c16rtomb_utf8(local_50,*pwVar2,param_4), _Var1 != 0xffffffffffffffff &&\n           ((_Var1 == 0 || (local_50[_Var1 - 1] != '\\0'))))) {\n      pwVar2 = pwVar2 + 1;\n    }\n  }\n  else {\n    while( true ) {\n      pcVar4 = local_50;\n      if (3 < param_3) {\n        pcVar4 = param_1;\n      }\n      _Var1 = __c16rtomb_utf8(pcVar4,*pwVar2,local_58);\n      if (_Var1 == 0xffffffffffffffff) {\n        *param_2 = pwVar3;\n        goto LAB_14001f58a;\n      }\n      if (pcVar4 != param_1) {\n        if (param_3 < _Var1) goto LAB_14001f543;\n        FUN_140007ed0((undefined8 *)param_1,(undefined8 *)pcVar4,_Var1);\n      }\n      if ((_Var1 != 0) && (param_1[_Var1 - 1] == '\\0')) break;\n      pwVar2 = pwVar2 + 1;\n      if (_Var1 != 0) {\n        pwVar3 = pwVar2;\n      }\n      param_3 = param_3 - _Var1;\n      param_1 = param_1 + _Var1;\n    }\n    pwVar3 = (wchar16 *)0x0;\nLAB_14001f543:\n    *param_2 = pwVar3;\n  }\nLAB_14001f58a:\n  _Var1 = FUN_140006060(local_48 ^ (ulonglong)auStack_78);\n  return _Var1;\n}\n\n",
  "__acrt_LCMapStringA_stat": "\n/* WARNING: Function: __chkstk replaced with injection: alloca_probe */\n/* Library Function - Single Match\n    int __cdecl __acrt_LCMapStringA_stat(struct __crt_locale_pointers * __ptr64,wchar_t const *\n   __ptr64,unsigned long,char const * __ptr64,int,char * __ptr64,int,int,int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nint __cdecl\n__acrt_LCMapStringA_stat\n          (__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5,\n          char *param_6,int param_7,int param_8,int param_9)\n\n{\n  longlong lVar1;\n  wchar_t *pwVar2;\n  int iVar3;\n  int iVar4;\n  size_t sVar5;\n  ulonglong uVar6;\n  LPCWSTR pWVar7;\n  LPCWSTR pWVar8;\n  ulonglong uVar9;\n  undefined *puVar10;\n  undefined *puVar11;\n  undefined *puVar12;\n  undefined *puVar13;\n  undefined auStackY_88 [32];\n  wchar_t *local_38;\n  ulonglong local_30;\n  \n  puVar10 = auStackY_88;\n  puVar12 = auStackY_88;\n  local_30 = DAT_140035020 ^ (ulonglong)&local_38;\n  iVar4 = param_5;\n  local_38 = param_2;\n  if (0 < param_5) {\n    sVar5 = __strncnt(param_4,(longlong)param_5);\n    iVar3 = (int)sVar5;\n    iVar4 = iVar3 + 1;\n    if (param_5 <= iVar3) {\n      iVar4 = iVar3;\n    }\n  }\n  if (param_8 == 0) {\n    param_8 = *(UINT *)(*(longlong *)param_1 + 0xc);\n  }\n  iVar3 = __acrt_MultiByteToWideChar\n                    (param_8,(-(uint)(param_9 != 0) & 8) + 1,param_4,iVar4,(LPWSTR)0x0,0);\n  puVar13 = auStackY_88;\n  if (iVar3 == 0) goto LAB_14001971d;\n  uVar9 = (longlong)iVar3 * 2 + 0x10;\n  uVar9 = -(ulonglong)((ulonglong)((longlong)iVar3 * 2) < uVar9) & uVar9;\n  if (uVar9 == 0) {\n    pWVar7 = (LPCWSTR)0x0;\nLAB_14001955b:\n    if (pWVar7 != (LPCWSTR)0x0) {\n      *(int *)(puVar12 + 0x28) = iVar3;\n      *(LPCWSTR *)(puVar12 + 0x20) = pWVar7;\n      *(undefined8 *)(puVar12 + -8) = 0x140019581;\n      iVar4 = __acrt_MultiByteToWideChar\n                        (param_8,1,param_4,iVar4,*(LPWSTR *)(puVar12 + 0x20),\n                         *(int *)(puVar12 + 0x28));\n      if (iVar4 != 0) {\n        *(undefined8 *)(puVar12 + 0x40) = 0;\n        *(undefined8 *)(puVar12 + 0x38) = 0;\n        *(undefined8 *)(puVar12 + 0x30) = 0;\n        pwVar2 = local_38;\n        *(undefined4 *)(puVar12 + 0x28) = 0;\n        *(undefined8 *)(puVar12 + 0x20) = 0;\n        *(undefined8 *)(puVar12 + -8) = 0x1400195bb;\n        iVar4 = __acrt_LCMapStringEx\n                          ((ushort *)pwVar2,param_3,pWVar7,iVar3,*(LPWSTR *)(puVar12 + 0x20),\n                           *(int *)(puVar12 + 0x28),*(undefined8 *)(puVar12 + 0x30),\n                           *(undefined8 *)(puVar12 + 0x38),*(undefined8 *)(puVar12 + 0x40));\n        if (iVar4 != 0) {\n          if ((param_3 & 0x400) == 0) {\n            uVar9 = (longlong)iVar4 * 2 + 0x10;\n            uVar9 = -(ulonglong)((ulonglong)((longlong)iVar4 * 2) < uVar9) & uVar9;\n            if (uVar9 == 0) {\n              pWVar8 = (LPCWSTR)0x0;\n            }\n            else {\n              if (uVar9 < 0x401) {\n                uVar6 = uVar9 + 0xf;\n                if (uVar6 <= uVar9) {\n                  uVar6 = 0xffffffffffffff0;\n                }\n                *(undefined8 *)(puVar12 + -8) = 0x140019658;\n                lVar1 = -(uVar6 & 0xfffffffffffffff0);\n                puVar11 = puVar12 + lVar1;\n                pWVar8 = (LPCWSTR)(puVar12 + lVar1 + 0x50);\n                puVar12 = puVar12 + lVar1;\n                if (pWVar8 == (LPCWSTR)0x0) goto LAB_140019705;\n                *(undefined4 *)pWVar8 = 0xcccc;\n                puVar12 = puVar11;\n              }\n              else {\n                *(undefined8 *)(puVar12 + -8) = 0x140019676;\n                pWVar8 = (LPCWSTR)_malloc_base(uVar9);\n                if (pWVar8 == (LPCWSTR)0x0) goto LAB_14001968c;\n                *(undefined4 *)pWVar8 = 0xdddd;\n              }\n              pWVar8 = pWVar8 + 8;\n            }\nLAB_14001968c:\n            if (pWVar8 != (LPCWSTR)0x0) {\n              *(undefined8 *)(puVar12 + 0x40) = 0;\n              *(undefined8 *)(puVar12 + 0x38) = 0;\n              *(undefined8 *)(puVar12 + 0x30) = 0;\n              *(int *)(puVar12 + 0x28) = iVar4;\n              *(LPCWSTR *)(puVar12 + 0x20) = pWVar8;\n              *(undefined8 *)(puVar12 + -8) = 0x1400196bd;\n              iVar3 = __acrt_LCMapStringEx\n                                ((ushort *)pwVar2,param_3,pWVar7,iVar3,*(LPWSTR *)(puVar12 + 0x20),\n                                 *(int *)(puVar12 + 0x28),*(undefined8 *)(puVar12 + 0x30),\n                                 *(undefined8 *)(puVar12 + 0x38),*(undefined8 *)(puVar12 + 0x40));\n              if (iVar3 != 0) {\n                *(undefined8 *)(puVar12 + 0x38) = 0;\n                *(undefined8 *)(puVar12 + 0x30) = 0;\n                if (param_7 == 0) {\n                  *(undefined4 *)(puVar12 + 0x28) = 0;\n                  *(undefined8 *)(puVar12 + 0x20) = 0;\n                }\n                else {\n                  *(int *)(puVar12 + 0x28) = param_7;\n                  *(char **)(puVar12 + 0x20) = param_6;\n                }\n                *(undefined8 *)(puVar12 + -8) = 0x1400196ec;\n                iVar4 = __acrt_WideCharToMultiByte\n                                  (param_8,0,pWVar8,iVar4,*(LPSTR *)(puVar12 + 0x20),\n                                   *(int *)(puVar12 + 0x28),*(LPBOOL *)(puVar12 + 0x30),\n                                   *(LPBOOL *)(puVar12 + 0x38));\n                if (iVar4 != 0) {\n                  if (*(int *)(pWVar8 + -8) == 0xdddd) {\n                    *(undefined8 *)(puVar12 + -8) = 0x140019763;\n                    _free_base(pWVar8 + -8);\n                  }\n                  goto LAB_140019705;\n                }\n              }\n              if (*(int *)(pWVar8 + -8) == 0xdddd) {\n                *(undefined8 *)(puVar12 + -8) = 0x140019703;\n                _free_base(pWVar8 + -8);\n              }\n            }\n          }\n          else if ((param_7 != 0) && (iVar4 <= param_7)) {\n            *(undefined8 *)(puVar12 + 0x40) = 0;\n            *(undefined8 *)(puVar12 + 0x38) = 0;\n            *(undefined8 *)(puVar12 + 0x30) = 0;\n            *(int *)(puVar12 + 0x28) = param_7;\n            *(char **)(puVar12 + 0x20) = param_6;\n            *(undefined8 *)(puVar12 + -8) = 0x140019613;\n            __acrt_LCMapStringEx\n                      ((ushort *)pwVar2,param_3,pWVar7,iVar3,*(LPWSTR *)(puVar12 + 0x20),\n                       *(int *)(puVar12 + 0x28),*(undefined8 *)(puVar12 + 0x30),\n                       *(undefined8 *)(puVar12 + 0x38),*(undefined8 *)(puVar12 + 0x40));\n          }\n        }\n      }\n    }\n  }\n  else {\n    if (0x400 < uVar9) {\n      pWVar7 = (LPCWSTR)_malloc_base(uVar9);\n      puVar12 = auStackY_88;\n      if (pWVar7 != (LPCWSTR)0x0) {\n        *(undefined4 *)pWVar7 = 0xdddd;\n        goto LAB_140019553;\n      }\n      goto LAB_14001955b;\n    }\n    uVar6 = uVar9 + 0xf;\n    if (uVar6 <= uVar9) {\n      uVar6 = 0xffffffffffffff0;\n    }\n    lVar1 = -(uVar6 & 0xfffffffffffffff0);\n    puVar10 = auStackY_88 + lVar1;\n    pWVar7 = (LPCWSTR)((longlong)&local_38 + lVar1);\n    puVar12 = auStackY_88 + lVar1;\n    if (pWVar7 != (LPCWSTR)0x0) {\n      *(undefined4 *)pWVar7 = 0xcccc;\nLAB_140019553:\n      pWVar7 = pWVar7 + 8;\n      puVar12 = puVar10;\n      goto LAB_14001955b;\n    }\n  }\nLAB_140019705:\n  puVar13 = puVar12;\n  if ((pWVar7 != (LPCWSTR)0x0) && (*(int *)(pWVar7 + -8) == 0xdddd)) {\n    *(undefined8 *)(puVar12 + -8) = 0x14001971b;\n    _free_base(pWVar7 + -8);\n  }\nLAB_14001971d:\n  uVar9 = local_30 ^ (ulonglong)&local_38;\n  *(undefined8 *)(puVar13 + -8) = 0x140019729;\n  iVar4 = FUN_140006060(uVar9);\n  return iVar4;\n}\n\n",
  "__scrt_common_main_seh": "\n/* Library Function - Single Match\n    int __cdecl __scrt_common_main_seh(void)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl __scrt_common_main_seh(void)\n\n{\n  bool bVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  longlong *plVar5;\n  ulonglong uVar6;\n  ulonglong *puVar7;\n  undefined8 *puVar8;\n  uint *puVar9;\n  undefined8 unaff_RBX;\n  undefined8 in_R9;\n  \n  iVar2 = (int)unaff_RBX;\n  uVar3 = __scrt_initialize_crt(1);\n  if ((char)uVar3 == '\\0') {\n    FUN_140006ae0(7);\n  }\n  else {\n    bVar1 = false;\n    uVar3 = __scrt_acquire_startup_lock();\n    iVar2 = (int)CONCAT71((int7)((ulonglong)unaff_RBX >> 8),(char)uVar3);\n    if (DAT_140036740 != 1) {\n      if (DAT_140036740 == 0) {\n        DAT_140036740 = 1;\n        uVar4 = _initterm_e((undefined **)&DAT_140023330,(undefined **)&DAT_140023368);\n        if ((int)uVar4 != 0) {\n          return 0xff;\n        }\n        _initterm((undefined **)&DAT_1400232b0,(undefined **)&DAT_140023328);\n        DAT_140036740 = 2;\n      }\n      else {\n        bVar1 = true;\n      }\n      __scrt_release_startup_lock((char)uVar3);\n      plVar5 = (longlong *)FUN_140006ac8();\n      if ((*plVar5 != 0) &&\n         (uVar6 = __scrt_is_nonwritable_in_current_image((longlong)plVar5), (char)uVar6 != '\\0')) {\n        (*(code *)PTR__guard_dispatch_icall_140023298)(0,2);\n      }\n      puVar7 = (ulonglong *)FUN_140006ad0();\n      if ((*puVar7 != 0) &&\n         (uVar6 = __scrt_is_nonwritable_in_current_image((longlong)puVar7), (char)uVar6 != '\\0')) {\n        _register_thread_local_exe_atexit_callback(*puVar7);\n      }\n      uVar4 = _get_initial_narrow_environment();\n      puVar8 = FUN_1400129cc();\n      uVar3 = *puVar8;\n      puVar9 = (uint *)FUN_1400129c4();\n      iVar2 = FUN_140002350((ulonglong)*puVar9,uVar3,uVar4,in_R9);\n      uVar6 = __scrt_is_managed_app();\n      if ((char)uVar6 != '\\0') {\n        if (!bVar1) {\n          _cexit();\n        }\n        __scrt_uninitialize_crt(true,'\\0');\n        return iVar2;\n      }\n      goto LAB_140006340;\n    }\n  }\n  FUN_140006ae0(7);\nLAB_140006340:\n  FUN_140012950(iVar2);\n  FUN_140012908(iVar2);\n  __security_init_cookie();\n  iVar2 = __scrt_common_main_seh();\n  return iVar2;\n}\n\n",
  "atexit": "\n/* Library Function - Single Match\n    atexit\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl atexit(_func_5014 *param_1)\n\n{\n  _onexit_t p_Var1;\n  \n  p_Var1 = _onexit((_onexit_t)param_1);\n  return (p_Var1 != (_onexit_t)0x0) - 1;\n}\n\n",
  "__scrt_acquire_startup_lock": "\n/* Library Function - Single Match\n    __scrt_acquire_startup_lock\n   \n   Library: Visual Studio 2019 Release */\n\nulonglong __scrt_acquire_startup_lock(void)\n\n{\n  ulonglong uVar1;\n  bool bVar2;\n  undefined7 extraout_var;\n  ulonglong uVar3;\n  \n  bVar2 = __scrt_is_ucrt_dll_in_use();\n  uVar3 = CONCAT71(extraout_var,bVar2);\n  if ((int)uVar3 == 0) {\nLAB_140006392:\n    uVar3 = uVar3 & 0xffffffffffffff00;\n  }\n  else {\n    do {\n      uVar3 = 0;\n      LOCK();\n      bVar2 = DAT_140036748 == 0;\n      uVar1 = *(ulonglong *)((longlong)Self + 8);\n      if (!bVar2) {\n        uVar3 = DAT_140036748;\n        uVar1 = DAT_140036748;\n      }\n      DAT_140036748 = uVar1;\n      UNLOCK();\n      if (bVar2) goto LAB_140006392;\n    } while (*(ulonglong *)((longlong)Self + 8) != uVar3);\n    uVar3 = CONCAT71((int7)(uVar3 >> 8),1);\n  }\n  return uVar3;\n}\n\n",
  "FUN_1400045ec": "\nvoid FUN_1400045ec(ios_base *param_1,undefined8 param_2,char param_3)\n\n{\n  ios_base iVar1;\n  uint uVar2;\n  undefined8 *puVar3;\n  char *pcVar4;\n  undefined4 local_48 [4];\n  char ****local_38 [6];\n  \n  std::ios_base::_Init(param_1);\n  *(undefined8 *)(param_1 + 0x50) = 0;\n  *(undefined8 *)(param_1 + 0x48) = param_2;\n  iVar1 = (ios_base)\n          std::basic_ios<char,struct_std::char_traits<char>_>::widen\n                    ((basic_ios<char,struct_std::char_traits<char>_> *)param_1,' ');\n  param_1[0x58] = iVar1;\n  if (*(longlong *)(param_1 + 0x48) == 0) {\n    uVar2 = *(uint *)(param_1 + 0x10) & 0x13 | 4;\n    *(uint *)(param_1 + 0x10) = uVar2;\n    uVar2 = uVar2 & *(uint *)(param_1 + 0x14);\n    if (uVar2 != 0) {\n      if ((uVar2 & 4) == 0) {\n        pcVar4 = \"ios_base::failbit set\";\n        if ((uVar2 & 2) == 0) {\n          pcVar4 = \"ios_base::eofbit set\";\n        }\n      }\n      else {\n        pcVar4 = \"ios_base::badbit set\";\n      }\n      puVar3 = (undefined8 *)FUN_140001450(local_48,1);\n      FUN_140001dd0(local_38,(undefined8 *)pcVar4,puVar3);\n                    /* WARNING: Subroutine does not return */\n      _CxxThrowException(local_38,(ThrowInfo *)&DAT_140033c40);\n    }\n  }\n  if (param_3 != '\\0') {\n    FUN_140005b98((longlong)param_1);\n  }\n  return;\n}\n\n",
  "_raise_exc": "\n/* Library Function - Single Match\n    _raise_exc\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid _raise_exc(uint *param_1,ulonglong *param_2,ulonglong param_3,uint param_4,uint *param_5,\n               uint *param_6)\n\n{\n  _raise_exc_ex(param_1,param_2,param_3,param_4,param_5,param_6,0);\n  return;\n}\n\n",
  "FUN_1400044cc": "\nvoid FUN_1400044cc(longlong param_1)\n\n{\n  if (*(longlong *)(param_1 + 0x80) != 0) {\n    FUN_14000d384(*(longlong *)(param_1 + 0x80));\n  }\n  return;\n}\n\n",
  "_initterm_e": "\n/* Library Function - Single Match\n    _initterm_e\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 _initterm_e(undefined **param_1,undefined **param_2)\n\n{\n  undefined8 uVar1;\n  bool bVar2;\n  \n  bVar2 = param_1 == param_2;\n  while( true ) {\n    if (bVar2) {\n      return 0;\n    }\n    if ((*param_1 != (undefined *)0x0) &&\n       (uVar1 = (*(code *)PTR__guard_dispatch_icall_140023298)(), (int)uVar1 != 0)) break;\n    param_1 = param_1 + 1;\n    bVar2 = param_1 == param_2;\n  }\n  return uVar1;\n}\n\n",
  "common_exit": "\n/* Library Function - Single Match\n    void __cdecl common_exit(int,enum _crt_exit_cleanup_mode,enum _crt_exit_return_mode)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl common_exit(int param_1,_crt_exit_cleanup_mode param_2,_crt_exit_return_mode param_3)\n\n{\n  code *pcVar1;\n  HMODULE pHVar2;\n  int *piVar3;\n  _crt_exit_cleanup_mode local_res10 [2];\n  _crt_exit_return_mode local_res18 [2];\n  undefined local_res20 [8];\n  __crt_seh_guarded_call<void> local_38 [4];\n  undefined4 local_34;\n  undefined4 local_30 [2];\n  _crt_exit_cleanup_mode *local_28;\n  _crt_exit_return_mode *local_20;\n  undefined *local_18;\n  \n  local_res10[0] = param_2;\n  local_res18[0] = param_3;\n  if (param_3 == 0) {\n    pHVar2 = GetModuleHandleW((LPCWSTR)0x0);\n    if ((((pHVar2 != (HMODULE)0x0) && (*(short *)&pHVar2->unused == 0x5a4d)) &&\n        (piVar3 = (int *)((longlong)&pHVar2->unused + (longlong)pHVar2[0xf].unused),\n        *piVar3 == 0x4550)) &&\n       (((*(short *)(piVar3 + 6) == 0x20b && (0xe < (uint)piVar3[0x21])) && (piVar3[0x3e] != 0)))) {\n      try_cor_exit_process(param_1);\n    }\n  }\n  local_28 = local_res10;\n  local_res20[0] = 0;\n  local_20 = local_res18;\n  local_18 = local_res20;\n  local_34 = 2;\n  local_30[0] = 2;\n  __crt_seh_guarded_call<void>::\n  operator()<class_<lambda_d80eeec6fff315bfe5c115232f3240e3>,class_<lambda_6e4b09c48022b2350581041d5f6b0c4c>&___ptr64,class_<lambda_2358e3775559c9db80273638284d5e45>_>\n            (local_38,(<lambda_d80eeec6fff315bfe5c115232f3240e3> *)local_30,\n             (<lambda_6e4b09c48022b2350581041d5f6b0c4c> *)&local_28,\n             (<lambda_2358e3775559c9db80273638284d5e45> *)&local_34);\n  if (local_res18[0] != 0) {\n    return;\n  }\n  exit_or_terminate_process(param_1);\n  pcVar1 = (code *)swi(3);\n  (*pcVar1)();\n  return;\n}\n\n",
  "_Xruntime_error": "\n/* Library Function - Single Match\n    void __cdecl std::_Xruntime_error(char const * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl std::_Xruntime_error(char *param_1)\n\n{\n  undefined8 local_28 [5];\n  \n  FUN_1400039fc(local_28,param_1);\n                    /* WARNING: Subroutine does not return */\n  _CxxThrowException(local_28,(ThrowInfo *)&DAT_140033b28);\n}\n\n",
  "FUN_14000bb50": "\nvoid FUN_14000bb50(undefined8 param_1,undefined *UNRECOVERED_JUMPTABLE,undefined8 param_3)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00014000bb56. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)UNRECOVERED_JUMPTABLE)(param_1,param_3);\n  return;\n}\n\n",
  "FUN_140011e04": "\nundefined4 FUN_140011e04(void)\n\n{\n  return DAT_140037100;\n}\n\n",
  "__scrt_is_ucrt_dll_in_use": "\n/* Library Function - Single Match\n    __scrt_is_ucrt_dll_in_use\n   \n   Library: Visual Studio 2019 Release */\n\nbool __scrt_is_ucrt_dll_in_use(void)\n\n{\n  return DAT_1400379f8 != 0;\n}\n\n",
  "FUN_140001720": "\nundefined8 * FUN_140001720(undefined8 *param_1,longlong param_2)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  \n  *param_1 = std::exception::vftable;\n  *(undefined (*) [16])(param_1 + 1) = ZEXT816(0);\n  __std_exception_copy((char **)(param_2 + 8),(char **)(param_1 + 1));\n  *param_1 = std::_System_error::vftable;\n  uVar1 = *(undefined4 *)(param_2 + 0x18);\n  uVar2 = *(undefined4 *)(param_2 + 0x1c);\n  uVar3 = *(undefined4 *)(param_2 + 0x20);\n  uVar4 = *(undefined4 *)(param_2 + 0x24);\n  *param_1 = std::system_error::vftable;\n  *(undefined4 *)(param_1 + 3) = uVar1;\n  *(undefined4 *)((longlong)param_1 + 0x1c) = uVar2;\n  *(undefined4 *)(param_1 + 4) = uVar3;\n  *(undefined4 *)((longlong)param_1 + 0x24) = uVar4;\n  return param_1;\n}\n\n",
  "_LocaleUpdate": "\n/* Library Function - Single Match\n    public: __cdecl _LocaleUpdate::_LocaleUpdate(struct __crt_locale_pointers * __ptr64 const)\n   __ptr64\n   \n   Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual\n   Studio 2019 Release */\n\n_LocaleUpdate * __thiscall\n_LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this,__crt_locale_pointers *param_1)\n\n{\n  _LocaleUpdate *p_Var1;\n  uint uVar2;\n  undefined auVar3 [16];\n  longlong lVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  \n  this[0x18] = (_LocaleUpdate)0x0;\n  p_Var1 = this + 8;\n  if (param_1 == (__crt_locale_pointers *)0x0) {\n    uVar5 = PTR_PTR_DAT_1400353b8._0_4_;\n    uVar6 = PTR_PTR_DAT_1400353b8._4_4_;\n    uVar7 = PTR_DAT_1400353c0._0_4_;\n    uVar8 = PTR_DAT_1400353c0._4_4_;\n    if (DAT_140037280 != 0) {\n      lVar4 = FUN_140014d84();\n      *(longlong *)this = lVar4;\n      *(longlong *)p_Var1 = *(longlong *)(lVar4 + 0x90);\n      *(undefined8 *)(this + 0x10) = *(undefined8 *)(lVar4 + 0x88);\n      __acrt_update_locale_info(lVar4,(longlong *)p_Var1);\n      __acrt_update_multibyte_info(*(longlong *)this,(longlong *)(this + 0x10));\n      uVar2 = *(uint *)(*(longlong *)this + 0x3a8);\n      if ((uVar2 & 2) != 0) {\n        return this;\n      }\n      *(uint *)(*(longlong *)this + 0x3a8) = uVar2 | 2;\n      this[0x18] = (_LocaleUpdate)0x1;\n      return this;\n    }\n  }\n  else {\n    uVar5 = *(undefined4 *)param_1;\n    uVar6 = *(undefined4 *)(param_1 + 4);\n    uVar7 = *(undefined4 *)(param_1 + 8);\n    uVar8 = *(undefined4 *)(param_1 + 0xc);\n  }\n  auVar3._4_4_ = uVar6;\n  auVar3._0_4_ = uVar5;\n  auVar3._8_4_ = uVar7;\n  auVar3._12_4_ = uVar8;\n  *(undefined (*) [16])p_Var1 = auVar3;\n  return this;\n}\n\n",
  "__acrt_update_multibyte_info": "\n/* Library Function - Single Match\n    __acrt_update_multibyte_info\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_update_multibyte_info(longlong param_1,longlong *param_2)\n\n{\n  longlong lVar1;\n  \n  if ((*param_2 != DAT_1400379c0) && ((DAT_140035520 & *(uint *)(param_1 + 0x3a8)) == 0)) {\n    lVar1 = __acrt_update_thread_multibyte_data();\n    *param_2 = lVar1;\n  }\n  return;\n}\n\n",
  "FUN_140007c70": "\nundefined8 FUN_140007c70(void)\n\n{\n  return DAT_140036db0;\n}\n\n",
  "common_lseek<__int64>": "\n/* Library Function - Single Match\n    __int64 __cdecl common_lseek<__int64>(int,__int64,int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\n__int64 __cdecl common_lseek<__int64>(int param_1,__int64 param_2,int param_3)\n\n{\n  ulong *puVar1;\n  __int64 _Var2;\n  \n  if (param_1 == -2) {\n    puVar1 = __doserrno();\n    *puVar1 = 0;\n    puVar1 = __doserrno();\n    *puVar1 = 9;\n  }\n  else {\n    if ((-1 < param_1) && ((uint)param_1 < DAT_140037890)) {\n      if ((*(byte *)((&DAT_140037490)[(longlong)param_1 >> 6] + 0x38 +\n                    (ulonglong)(param_1 & 0x3f) * 0x48) & 1) != 0) {\n        FID_conflict___acrt_lowio_lock_fh(param_1);\n        _Var2 = -1;\n        if ((*(byte *)((&DAT_140037490)[(longlong)param_1 >> 6] + 0x38 +\n                      (ulonglong)(param_1 & 0x3f) * 0x48) & 1) == 0) {\n          puVar1 = __doserrno();\n          *puVar1 = 9;\n          puVar1 = __doserrno();\n          *puVar1 = 0;\n        }\n        else {\n          _Var2 = common_lseek_nolock<__int64>(param_1,param_2,param_3);\n        }\n        FID_conflict___acrt_lowio_lock_fh(param_1);\n        return _Var2;\n      }\n    }\n    puVar1 = __doserrno();\n    *puVar1 = 0;\n    puVar1 = __doserrno();\n    *puVar1 = 9;\n    FUN_14000d030();\n  }\n  return -1;\n}\n\n",
  "FUN_140008b20": "\nvoid FUN_140008b20(void)\n\n{\n  LPVOID pvVar1;\n  \n  pvVar1 = __vcrt_getptd_noexit();\n  if (pvVar1 != (LPVOID)0x0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_140008d64": "\nundefined4 FUN_140008d64(longlong param_1,longlong param_2,ulonglong param_3)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  ulonglong uVar3;\n  longlong lVar4;\n  \n  if (param_1 != 0) {\n    lVar4 = (longlong)*(int *)(param_1 + 0x18);\n    lVar1 = *(longlong *)(param_2 + 8);\n    if (lVar4 + lVar1 != 0) {\n      uVar3 = 0;\n      if (*(uint *)(param_1 + 0x14) != 0) {\n        do {\n          if (param_3 < (ulonglong)(*(int *)(lVar4 + uVar3 * 8 + lVar1) + lVar1)) break;\n          uVar2 = (int)uVar3 + 1;\n          uVar3 = (ulonglong)uVar2;\n        } while (uVar2 < *(uint *)(param_1 + 0x14));\n        if ((int)uVar3 != 0) {\n          return *(undefined4 *)(lVar4 + (ulonglong)((int)uVar3 - 1) * 8 + 4 + lVar1);\n        }\n      }\n      return 0xffffffff;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "qsort": "\n/* Library Function - Single Match\n    qsort\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __cdecl\nqsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,_PtFuncCompare *_PtFuncCompare)\n\n{\n  ulonglong uVar1;\n  undefined uVar2;\n  bool bVar3;\n  int iVar4;\n  ulong *puVar5;\n  longlong lVar6;\n  undefined *puVar7;\n  undefined *puVar8;\n  undefined *puVar9;\n  undefined *puVar10;\n  size_t sVar11;\n  undefined *puVar12;\n  undefined auStack_468 [32];\n  longlong local_448;\n  undefined8 auStack_438 [62];\n  undefined8 auStack_248 [62];\n  ulonglong local_58;\n  \n  local_58 = DAT_140035020 ^ (ulonglong)auStack_468;\n  if ((((_Base == (void *)0x0) && (_NumOfElements != 0)) || (_SizeOfElements == 0)) ||\n     (_PtFuncCompare == (_PtFuncCompare *)0x0)) {\n    puVar5 = __doserrno();\n    *puVar5 = 0x16;\n    FUN_14000d030();\n  }\n  else if (1 < _NumOfElements) {\n    local_448 = 0;\n    puVar12 = (undefined *)((_NumOfElements - 1) * _SizeOfElements + (longlong)_Base);\nLAB_14001fcc0:\n    while (uVar1 = (ulonglong)((longlong)puVar12 - (longlong)_Base) / _SizeOfElements + 1, 8 < uVar1\n          ) {\n      lVar6 = (uVar1 >> 1) * _SizeOfElements;\n      puVar9 = (undefined *)((longlong)_Base + lVar6);\n      iVar4 = (*(code *)PTR__guard_dispatch_icall_140023298)(_Base,puVar9);\n      if ((0 < iVar4) && (puVar8 = puVar9, sVar11 = _SizeOfElements, (undefined *)_Base != puVar9))\n      {\n        do {\n          uVar2 = puVar8[-lVar6];\n          puVar8[-lVar6] = *puVar8;\n          *puVar8 = uVar2;\n          sVar11 = sVar11 - 1;\n          puVar8 = puVar8 + 1;\n        } while (sVar11 != 0);\n      }\n      iVar4 = (*(code *)PTR__guard_dispatch_icall_140023298)(_Base,puVar12);\n      if ((0 < iVar4) && ((undefined *)_Base != puVar12)) {\n        puVar8 = puVar12;\n        sVar11 = _SizeOfElements;\n        do {\n          uVar2 = puVar8[(longlong)_Base - (longlong)puVar12];\n          puVar8[(longlong)_Base - (longlong)puVar12] = *puVar8;\n          *puVar8 = uVar2;\n          puVar8 = puVar8 + 1;\n          sVar11 = sVar11 - 1;\n        } while (sVar11 != 0);\n      }\n      iVar4 = (*(code *)PTR__guard_dispatch_icall_140023298)(puVar9);\n      puVar8 = (undefined *)_Base;\n      puVar10 = puVar12;\n      if ((0 < iVar4) && (puVar9 != puVar12)) {\n        puVar7 = puVar12;\n        sVar11 = _SizeOfElements;\n        do {\n          uVar2 = puVar7[(longlong)puVar9 - (longlong)puVar12];\n          puVar7[(longlong)puVar9 - (longlong)puVar12] = *puVar7;\n          *puVar7 = uVar2;\n          puVar7 = puVar7 + 1;\n          sVar11 = sVar11 - 1;\n        } while (sVar11 != 0);\n      }\nLAB_14001fe40:\n      puVar7 = puVar9;\n      if (puVar8 < puVar7) {\n        do {\n          puVar8 = puVar8 + _SizeOfElements;\n          if (puVar7 <= puVar8) goto LAB_14001fe65;\n          iVar4 = (*(code *)PTR__guard_dispatch_icall_140023298)(puVar8);\n        } while (iVar4 < 1);\n        if (puVar7 <= puVar8) goto LAB_14001fe65;\n      }\n      else {\nLAB_14001fe65:\n        do {\n          puVar8 = puVar8 + _SizeOfElements;\n          if (puVar12 < puVar8) break;\n          iVar4 = (*(code *)PTR__guard_dispatch_icall_140023298)(puVar8);\n        } while (iVar4 < 1);\n      }\n      do {\n        puVar9 = puVar10;\n        puVar10 = puVar9 + -_SizeOfElements;\n        if (puVar10 <= puVar7) break;\n        iVar4 = (*(code *)PTR__guard_dispatch_icall_140023298)(puVar10);\n      } while (0 < iVar4);\n      if (puVar8 <= puVar10) {\n        if (puVar10 != puVar8) {\n          puVar9 = puVar10;\n          sVar11 = _SizeOfElements;\n          do {\n            uVar2 = puVar9[(longlong)puVar8 - (longlong)puVar10];\n            puVar9[(longlong)puVar8 - (longlong)puVar10] = *puVar9;\n            *puVar9 = uVar2;\n            puVar9 = puVar9 + 1;\n            sVar11 = sVar11 - 1;\n          } while (sVar11 != 0);\n        }\n        puVar9 = puVar8;\n        if (puVar7 != puVar10) {\n          puVar9 = puVar7;\n        }\n        goto LAB_14001fe40;\n      }\n      if (puVar7 < puVar9) {\n        do {\n          puVar9 = puVar9 + -_SizeOfElements;\n          if (puVar9 <= puVar7) goto LAB_14001ff00;\n          iVar4 = (*(code *)PTR__guard_dispatch_icall_140023298)(puVar9);\n        } while (iVar4 == 0);\n        if (puVar9 <= puVar7) goto LAB_14001ff00;\n      }\n      else {\nLAB_14001ff00:\n        do {\n          puVar9 = puVar9 + -_SizeOfElements;\n          if (puVar9 <= _Base) break;\n          iVar4 = (*(code *)PTR__guard_dispatch_icall_140023298)(puVar9);\n        } while (iVar4 == 0);\n      }\n      if ((longlong)puVar9 - (longlong)_Base < (longlong)puVar12 - (longlong)puVar8)\n      goto LAB_14001ff5c;\n      if (_Base < puVar9) {\n        auStack_438[local_448] = _Base;\n        auStack_248[local_448] = puVar9;\n        local_448 = local_448 + 1;\n      }\n      _Base = puVar8;\n      if (puVar12 <= puVar8) goto LAB_14001fd43;\n    }\n    for (; puVar8 = (undefined *)_Base, puVar9 = (undefined *)_Base, _Base < puVar12;\n        puVar12 = puVar12 + -_SizeOfElements) {\n      while (puVar9 = puVar9 + _SizeOfElements, puVar9 <= puVar12) {\n        iVar4 = (*(code *)PTR__guard_dispatch_icall_140023298)(puVar9,puVar8);\n        if (0 < iVar4) {\n          puVar8 = puVar9;\n        }\n      }\n      if (puVar8 != puVar12) {\n        puVar9 = puVar12;\n        sVar11 = _SizeOfElements;\n        do {\n          uVar2 = puVar9[(longlong)puVar8 - (longlong)puVar12];\n          puVar9[(longlong)puVar8 - (longlong)puVar12] = *puVar9;\n          *puVar9 = uVar2;\n          puVar9 = puVar9 + 1;\n          sVar11 = sVar11 - 1;\n        } while (sVar11 != 0);\n      }\n    }\n    goto LAB_14001fd43;\n  }\nLAB_14001ffaf:\n  FUN_140006060(local_58 ^ (ulonglong)auStack_468);\n  return;\nLAB_14001ff5c:\n  if (puVar8 < puVar12) {\n    auStack_438[local_448] = puVar8;\n    auStack_248[local_448] = puVar12;\n    local_448 = local_448 + 1;\n  }\n  puVar12 = puVar9;\n  if (puVar9 <= _Base) {\nLAB_14001fd43:\n    lVar6 = local_448 + -1;\n    bVar3 = 0 < local_448;\n    local_448 = lVar6;\n    if (bVar3) {\n      _Base = (undefined *)auStack_438[lVar6];\n      puVar12 = (undefined *)auStack_248[lVar6];\n      goto LAB_14001fcc0;\n    }\n    goto LAB_14001ffaf;\n  }\n  goto LAB_14001fcc0;\n}\n\n",
  "_initialize_onexit_table": "\n/* Library Function - Single Match\n    _initialize_onexit_table\n   \n   Library: Visual Studio 2019 Release */\n\nundefined8 _initialize_onexit_table(longlong *param_1)\n\n{\n  longlong lVar1;\n  \n  lVar1 = DAT_140035020;\n  if (param_1 == (longlong *)0x0) {\n    return 0xffffffff;\n  }\n  if (*param_1 == param_1[2]) {\n    *param_1 = DAT_140035020;\n    param_1[1] = lVar1;\n    param_1[2] = lVar1;\n  }\n  return 0;\n}\n\n",
  "FUN_140008580": "\nundefined (*) [16] FUN_140008580(undefined (*param_1) [16],byte param_2,ulonglong param_3)\n\n{\n  undefined (*pauVar1) [16];\n  undefined (*pauVar2) [16];\n  undefined uVar3;\n  ulonglong uVar6;\n  undefined auVar7 [16];\n  undefined2 uVar4;\n  undefined4 uVar5;\n  undefined auVar8 [16];\n  undefined auVar9 [16];\n  undefined auVar10 [16];\n  undefined auVar11 [16];\n  undefined auVar12 [16];\n  undefined auVar13 [16];\n  undefined auVar14 [16];\n  undefined auVar15 [16];\n  undefined auVar16 [16];\n  undefined uVar17;\n  \n  uVar6 = (ulonglong)param_2 * 0x101010101010101;\n  uVar3 = (undefined)uVar6;\n  uVar4 = (undefined2)uVar6;\n  uVar5 = (undefined4)uVar6;\n  switch(param_3) {\n  case 0:\n    return param_1;\n  case 8:\n    *(ulonglong *)*param_1 = uVar6;\n    return param_1;\n  case 9:\n    *(ulonglong *)(param_1[-1] + param_3 + 7) = uVar6;\n    param_1[-1][param_3 + 0xf] = uVar3;\n    return param_1;\n  case 10:\n    *(ulonglong *)*param_1 = uVar6;\n    *(undefined2 *)(*param_1 + 8) = uVar4;\n    return param_1;\n  case 0xb:\n    *(ulonglong *)*param_1 = uVar6;\n    *(undefined2 *)(*param_1 + 8) = uVar4;\n    (*param_1)[10] = uVar3;\n    return param_1;\n  case 0xc:\n    *(ulonglong *)(param_1[-1] + param_3 + 4) = uVar6;\n  case 4:\n    *(undefined4 *)(param_1[-1] + param_3 + 0xc) = uVar5;\n    return param_1;\n  case 0xd:\n    *(ulonglong *)(param_1[-1] + param_3 + 3) = uVar6;\n  case 5:\n    *(undefined4 *)(param_1[-1] + param_3 + 0xb) = uVar5;\n    param_1[-1][param_3 + 0xf] = uVar3;\n    return param_1;\n  case 0xe:\n    *(ulonglong *)(param_1[-1] + param_3 + 2) = uVar6;\n  case 6:\n    *(undefined4 *)(param_1[-1] + param_3 + 10) = uVar5;\n  case 2:\n    *(undefined2 *)(param_1[-1] + param_3 + 0xe) = uVar4;\n    return param_1;\n  case 0xf:\n    *(ulonglong *)(param_1[-1] + param_3 + 1) = uVar6;\n  case 7:\n    *(undefined4 *)(param_1[-1] + param_3 + 9) = uVar5;\n  case 3:\n    *(undefined2 *)(param_1[-1] + param_3 + 0xd) = uVar4;\n  case 1:\n    param_1[-1][param_3 + 0xf] = uVar3;\n    return param_1;\n  case 0x10:\n    *(ulonglong *)*param_1 = uVar6;\n    *(ulonglong *)(*param_1 + 8) = uVar6;\n    return param_1;\n  }\n  uVar17 = (undefined)(uVar6 >> 0x38);\n  auVar16._8_6_ = 0;\n  auVar16._0_8_ = uVar6;\n  auVar16[0xe] = uVar17;\n  auVar16[0xf] = uVar17;\n  uVar17 = (undefined)(uVar6 >> 0x30);\n  auVar15._14_2_ = auVar16._14_2_;\n  auVar15._8_5_ = 0;\n  auVar15._0_8_ = uVar6;\n  auVar15[0xd] = uVar17;\n  auVar14._13_3_ = auVar15._13_3_;\n  auVar14._8_4_ = 0;\n  auVar14._0_8_ = uVar6;\n  auVar14[0xc] = uVar17;\n  uVar17 = (undefined)(uVar6 >> 0x28);\n  auVar13._12_4_ = auVar14._12_4_;\n  auVar13._8_3_ = 0;\n  auVar13._0_8_ = uVar6;\n  auVar13[0xb] = uVar17;\n  auVar12._11_5_ = auVar13._11_5_;\n  auVar12._8_2_ = 0;\n  auVar12._0_8_ = uVar6;\n  auVar12[10] = uVar17;\n  uVar17 = (undefined)(uVar6 >> 0x20);\n  auVar11._10_6_ = auVar12._10_6_;\n  auVar11[8] = 0;\n  auVar11._0_8_ = uVar6;\n  auVar11[9] = uVar17;\n  auVar10._9_7_ = auVar11._9_7_;\n  auVar10[8] = uVar17;\n  auVar10._0_8_ = uVar6;\n  uVar17 = (undefined)(uVar6 >> 0x18);\n  auVar9._8_8_ = auVar10._8_8_;\n  auVar9[7] = uVar17;\n  auVar9[6] = uVar17;\n  uVar17 = (undefined)(uVar6 >> 0x10);\n  auVar9[5] = uVar17;\n  auVar9[4] = uVar17;\n  auVar9._0_4_ = uVar5;\n  uVar17 = (undefined)(uVar6 >> 8);\n  auVar8._4_12_ = auVar9._4_12_;\n  auVar8[3] = uVar17;\n  auVar8[2] = uVar17;\n  auVar8._0_2_ = uVar4;\n  auVar7._2_14_ = auVar8._2_14_;\n  auVar7[1] = uVar3;\n  auVar7[0] = uVar3;\n  pauVar1 = param_1;\n  if (0x80 < param_3) {\n    if (((byte)DAT_140036d1c & 2) != 0) {\n      for (; param_3 != 0; param_3 = param_3 - 1) {\n        (*pauVar1)[0] = param_2;\n        pauVar1 = (undefined (*) [16])(*pauVar1 + 1);\n      }\n      return param_1;\n    }\n    *param_1 = auVar7;\n    pauVar1 = (undefined (*) [16])((ulonglong)(param_1 + 1) & 0xfffffffffffffff0);\n    param_3 = (longlong)param_1 + (param_3 - (longlong)pauVar1);\n    uVar6 = param_3 >> 7;\n    if (uVar6 != 0) {\n      if (DAT_140035048 < uVar6) {\n        do {\n          *pauVar1 = auVar7;\n          pauVar1[1] = auVar7;\n          pauVar2 = pauVar1 + 8;\n          pauVar1[2] = auVar7;\n          pauVar1[3] = auVar7;\n          uVar6 = uVar6 - 1;\n          pauVar1[4] = auVar7;\n          pauVar1[5] = auVar7;\n          pauVar1[6] = auVar7;\n          pauVar1[7] = auVar7;\n          pauVar1 = pauVar2;\n        } while (uVar6 != 0);\n        param_3 = param_3 & 0x7f;\n      }\n      else {\n        do {\n          *pauVar1 = auVar7;\n          pauVar1[1] = auVar7;\n          pauVar2 = pauVar1 + 8;\n          pauVar1[2] = auVar7;\n          pauVar1[3] = auVar7;\n          uVar6 = uVar6 - 1;\n          pauVar1[4] = auVar7;\n          pauVar1[5] = auVar7;\n          pauVar1[6] = auVar7;\n          pauVar1[7] = auVar7;\n          pauVar1 = pauVar2;\n        } while (uVar6 != 0);\n        param_3 = param_3 & 0x7f;\n      }\n    }\n  }\n  for (uVar6 = param_3 >> 4; uVar6 != 0; uVar6 = uVar6 - 1) {\n    *pauVar1 = auVar7;\n    pauVar1 = pauVar1 + 1;\n  }\n  if ((param_3 & 0xf) != 0) {\n    *(undefined (*) [16])(pauVar1[-1] + (param_3 & 0xf)) = auVar7;\n  }\n  return param_1;\n}\n\n",
  "FUN_14002285d": "\nvoid FUN_14002285d(void)\n\n{\n  __acrt_unlock(4);\n  return;\n}\n\n",
  "fwrite": "\n/* Library Function - Single Match\n    fwrite\n   \n   Library: Visual Studio 2019 Release */\n\nsize_t __cdecl fwrite(void *_Str,size_t _Size,size_t _Count,FILE *_File)\n\n{\n  ulong *puVar1;\n  __uint64 _Var2;\n  void *local_res8;\n  size_t local_res10;\n  size_t local_res18;\n  FILE *local_res20;\n  undefined local_48 [8];\n  FILE *local_40;\n  FILE *local_38;\n  FILE **local_30;\n  void **local_28;\n  size_t *local_20;\n  size_t *local_18;\n  \n  if ((_Size != 0) && (_Count != 0)) {\n    local_res8 = _Str;\n    local_res10 = _Size;\n    local_res18 = _Count;\n    local_res20 = _File;\n    if (_File != (FILE *)0x0) {\n      local_30 = &local_res20;\n      local_28 = &local_res8;\n      local_20 = &local_res10;\n      local_18 = &local_res18;\n      local_40 = _File;\n      local_38 = _File;\n      _Var2 = operator()<>(local_48,(longlong *)&local_38,\n                           (<lambda_5856287d7ecd2be6c9197bb4007c3f6e> *)&local_30,\n                           (longlong *)&local_40);\n      return _Var2;\n    }\n    puVar1 = __doserrno();\n    *puVar1 = 0x16;\n    FUN_14000d030();\n  }\n  return 0;\n}\n\n",
  "SetUnwindTryBlock": "\n/* Library Function - Single Match\n    public: static void __cdecl __FrameHandler3::SetUnwindTryBlock(unsigned __int64 * __ptr64,struct\n   _xDISPATCHER_CONTEXT * __ptr64,struct _s_FuncInfo const * __ptr64,int)\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __cdecl\n__FrameHandler3::SetUnwindTryBlock\n          (__uint64 *param_1,_xDISPATCHER_CONTEXT *param_2,_s_FuncInfo *param_3,int param_4)\n\n{\n  __uint64 *p_Var1;\n  __uint64 local_res18 [2];\n  \n  p_Var1 = GetEstablisherFrame(param_1,param_2,param_3,local_res18);\n  if (*(int *)((longlong)param_3->dispUnwindHelp + 4 + *p_Var1) < param_4) {\n    *(int *)((longlong)param_3->dispUnwindHelp + 4 + *p_Var1) = param_4;\n  }\n  return;\n}\n\n",
  "__acrt_FlsSetValue": "\n/* Library Function - Single Match\n    __acrt_FlsSetValue\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_FlsSetValue(DWORD param_1,LPVOID param_2)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = try_get_function(6,\"FlsSetValue\",(module_id *)&DAT_140028de0,(module_id *)&DAT_140028de8)\n  ;\n  if (pvVar1 == (void *)0x0) {\n    TlsSetValue(param_1,param_2);\n  }\n  else {\n    (*(code *)PTR__guard_dispatch_icall_140023298)();\n  }\n  return;\n}\n\n",
  "FUN_140020450": "\nbyte * FUN_140020450(byte *param_1,byte *param_2)\n\n{\n  ulong *puVar1;\n  byte *pbVar2;\n  longlong local_28 [2];\n  longlong local_18;\n  char local_10;\n  \n  if ((param_1 == (byte *)0x0) || (param_2 == (byte *)0x0)) {\n    puVar1 = __doserrno();\n    *puVar1 = 0x16;\n    FUN_14000d030();\n  }\n  else if (param_1 < param_2) {\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_28,(__crt_locale_pointers *)0x0);\n    pbVar2 = param_2 + -1;\n    if (*(int *)(local_18 + 8) != 0) {\n      do {\n        pbVar2 = pbVar2 + -1;\n        if (pbVar2 < param_1) break;\n      } while ((*(byte *)((ulonglong)*pbVar2 + 0x19 + local_18) & 4) != 0);\n      pbVar2 = param_2 + (-1 - (ulonglong)((int)param_2 - (int)pbVar2 & 1));\n    }\n    if (local_10 == '\\0') {\n      return pbVar2;\n    }\n    *(uint *)(local_28[0] + 0x3a8) = *(uint *)(local_28[0] + 0x3a8) & 0xfffffffd;\n    return pbVar2;\n  }\n  return (byte *)0x0;\n}\n\n",
  "FUN_140022750": "\nvoid FUN_140022750(undefined8 param_1,longlong param_2)\n\n{\n  uint *puVar1;\n  \n  puVar1 = (uint *)(***(longlong ***)(param_2 + 0x48) + 0x3a8);\n  *puVar1 = *puVar1 & 0xffffffef;\n  return;\n}\n\n",
  "__DestructExceptionObject": "\n/* Library Function - Single Match\n    __DestructExceptionObject\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __DestructExceptionObject(int *param_1)\n\n{\n  byte *pbVar1;\n  \n  if ((((param_1 != (int *)0x0) && (*param_1 == -0x1f928c9d)) && (param_1[6] == 4)) &&\n     ((param_1[8] + 0xe66cfae0U < 3 && (pbVar1 = *(byte **)(param_1 + 0xc), pbVar1 != (byte *)0x0)))\n     ) {\n    if (*(int *)(pbVar1 + 4) == 0) {\n      if (((*pbVar1 & 0x10) != 0) && (**(longlong **)(param_1 + 10) != 0)) {\n        (*(code *)PTR__guard_dispatch_icall_140023298)();\n      }\n    }\n    else {\n      FUN_140007d08(*(undefined8 *)(param_1 + 10),\n                    (undefined *)((longlong)*(int *)(pbVar1 + 4) + *(longlong *)(param_1 + 0xe)));\n    }\n  }\n  return;\n}\n\n",
  "FUN_140008d54": "\nvoid FUN_140008d54(longlong param_1,ulonglong *param_2)\n\n{\n  FUN_140008d64(param_1,(longlong)param_2,*param_2);\n  return;\n}\n\n",
  "fread_s": "\n/* Library Function - Single Match\n    fread_s\n   \n   Library: Visual Studio 2019 Release */\n\nsize_t __cdecl fread_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File)\n\n{\n  ulong *puVar1;\n  size_t sVar2;\n  \n  if ((_ElementSize != 0) && (_Count != 0)) {\n    if (_File != (FILE *)0x0) {\n      FUN_14000d384((longlong)_File);\n      sVar2 = _fread_nolock_s(_DstBuf,_DstSize,_ElementSize,_Count,_File);\n      FUN_14000d390((longlong)_File);\n      return sVar2;\n    }\n    if (_DstSize != 0xffffffffffffffff) {\n      FUN_140008580((undefined (*) [16])_DstBuf,0,_DstSize);\n    }\n    puVar1 = __doserrno();\n    *puVar1 = 0x16;\n    FUN_14000d030();\n  }\n  return 0;\n}\n\n",
  "xsputn": "\n/* Library Function - Single Match\n    protected: virtual __int64 __cdecl std::basic_filebuf<char,struct std::char_traits<char>\n   >::xsputn(char const * __ptr64,__int64) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\n__int64 __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::xsputn\n          (basic_filebuf<char,struct_std::char_traits<char>_> *this,char *param_1,__int64 param_2)\n\n{\n  __int64 _Var1;\n  size_t sVar2;\n  int iVar3;\n  size_t _Count;\n  ulonglong uVar4;\n  \n  if (*(longlong *)(this + 0x68) != 0) {\n    _Var1 = basic_streambuf<char,struct_std::char_traits<char>_>::xsputn\n                      ((basic_streambuf<char,struct_std::char_traits<char>_> *)this,param_1,param_2)\n    ;\n    return _Var1;\n  }\n  if ((undefined8 *)**(undefined8 **)(this + 0x40) == (undefined8 *)0x0) {\n    iVar3 = 0;\n  }\n  else {\n    iVar3 = **(int **)(this + 0x58);\n  }\n  _Count = param_2;\n  if (0 < param_2) {\n    if (0 < iVar3) {\n      uVar4 = (longlong)iVar3;\n      if (param_2 < iVar3) {\n        uVar4 = param_2;\n      }\n      FUN_140007ed0((undefined8 *)**(undefined8 **)(this + 0x40),(undefined8 *)param_1,uVar4);\n      _Count = param_2 - uVar4;\n      param_1 = param_1 + uVar4;\n      **(int **)(this + 0x58) = **(int **)(this + 0x58) - (int)uVar4;\n      **(longlong **)(this + 0x40) = **(longlong **)(this + 0x40) + (longlong)(int)uVar4;\n      if ((longlong)_Count < 1) goto LAB_1400051cd;\n    }\n    if (*(FILE **)(this + 0x80) != (FILE *)0x0) {\n      sVar2 = fwrite(param_1,1,_Count,*(FILE **)(this + 0x80));\n      _Count = _Count - sVar2;\n    }\n  }\nLAB_1400051cd:\n  return param_2 - _Count;\n}\n\n",
  "__vcrt_initialize": "\n/* Library Function - Single Match\n    __vcrt_initialize\n   \n   Library: Visual Studio 2019 Release */\n\nulonglong __vcrt_initialize(void)\n\n{\n  bool bVar1;\n  undefined4 uVar2;\n  undefined7 extraout_var;\n  undefined4 extraout_var_00;\n  ulonglong uVar3;\n  \n  bVar1 = __vcrt_initialize_locks();\n  uVar3 = CONCAT71(extraout_var,bVar1);\n  if (bVar1) {\n    uVar2 = __vcrt_initialize_ptd();\n    if ((char)uVar2 != '\\0') {\n      return CONCAT71((int7)(CONCAT44(extraout_var_00,uVar2) >> 8),1);\n    }\n    uVar3 = __vcrt_uninitialize_locks();\n  }\n  return uVar3 & 0xffffffffffffff00;\n}\n\n",
  "FUN_14000cd50": "\nvoid FUN_14000cd50(longlong *param_1)\n\n{\n  if (*(char *)(param_1 + 3) != '\\0') {\n    *(uint *)(*param_1 + 0x3a8) = *(uint *)(*param_1 + 0x3a8) & 0xfffffffd;\n  }\n  return;\n}\n\n",
  "FUN_140022513": "\nvoid FUN_140022513(_EXCEPTION_POINTERS *param_1,longlong param_2)\n\n{\n  *(_EXCEPTION_POINTERS **)(param_2 + 0x80) = param_1;\n  ExFilterRethrowFH4(param_1,*(EHExceptionRecord **)(param_2 + 0xf8),*(int *)(param_2 + 0xe8),\n                     (int *)(param_2 + 0x20));\n  return;\n}\n\n",
  "FUN_140022637": "\nvoid FUN_140022637(undefined8 param_1,longlong param_2)\n\n{\n  FUN_14000d390(*(longlong *)(param_2 + 0x30));\n  return;\n}\n\n",
  "TypeMatchHelper<class___FrameHandler4>": "\n/* Library Function - Single Match\n    int __cdecl TypeMatchHelper<class __FrameHandler4>(struct FH4::HandlerType4 * __ptr64,struct\n   _s_CatchableType const * __ptr64,struct _s_ThrowInfo const * __ptr64)\n   \n   Library: Visual Studio 2019 Release */\n\nint __cdecl\nTypeMatchHelper<class___FrameHandler4>\n          (HandlerType4 *param_1,_s_CatchableType *param_2,_s_ThrowInfo *param_3)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  longlong lVar4;\n  longlong lVar5;\n  char *pcVar6;\n  int iVar7;\n  longlong lVar8;\n  \n  lVar8 = 0;\n  iVar7 = 0;\n  if (*(int *)(param_1 + 8) != 0) {\n    iVar3 = *(int *)(param_1 + 8);\n    lVar4 = _GetImageBase();\n    if (lVar4 + iVar3 != 0) {\n      lVar4 = lVar8;\n      if (iVar3 != 0) {\n        iVar7 = *(int *)(param_1 + 8);\n        lVar4 = _GetImageBase();\n        lVar4 = iVar7 + lVar4;\n      }\n      if ((*(char *)(lVar4 + 0x10) != '\\0') &&\n         ((((byte)param_1[4] & 0x80) == 0 || (((byte)*param_2 & 0x10) == 0)))) {\n        lVar4 = lVar8;\n        if (iVar7 != 0) {\n          lVar4 = _GetImageBase();\n          lVar4 = lVar4 + *(int *)(param_1 + 8);\n        }\n        lVar5 = _GetThrowImageBase();\n        if (lVar4 != lVar5 + *(int *)(param_2 + 4)) {\n          lVar4 = lVar8;\n          if (*(int *)(param_1 + 8) != 0) {\n            lVar4 = _GetImageBase();\n            lVar4 = lVar4 + *(int *)(param_1 + 8);\n          }\n          lVar5 = _GetThrowImageBase();\n          pcVar6 = (char *)(lVar4 + 0x10);\n          lVar4 = ((longlong)*(int *)(param_2 + 4) + 0x10 + lVar5) - (longlong)pcVar6;\n          do {\n            cVar1 = *pcVar6;\n            cVar2 = pcVar6[lVar4];\n            if (cVar1 != cVar2) break;\n            pcVar6 = pcVar6 + 1;\n          } while (cVar2 != '\\0');\n          if (cVar1 != cVar2) {\n            return 0;\n          }\n        }\n        if (((((((byte)*param_2 & 2) == 0) || (((byte)param_1[4] & 8) != 0)) &&\n             (((*(byte *)&param_3->attributes & 1) == 0 || (((byte)param_1[4] & 1) != 0)))) &&\n            (((*(byte *)&param_3->attributes & 4) == 0 || (((byte)param_1[4] & 4) != 0)))) &&\n           (((*(byte *)&param_3->attributes & 2) == 0 || (lVar8 = 0, ((byte)param_1[4] & 2) != 0))))\n        {\n          lVar8 = 1;\n        }\n        return (int)lVar8;\n      }\n    }\n  }\n  return 1;\n}\n\n",
  "ReadEntry": "\n/* Library Function - Single Match\n    private: void __cdecl FH4::UWMap4::ReadEntry(unsigned char * __ptr64 * __ptr64) __ptr64\n   \n   Library: Visual Studio 2019 Release */\n\nvoid __thiscall FH4::UWMap4::ReadEntry(UWMap4 *this,uchar **param_1)\n\n{\n  byte bVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  byte *pbVar5;\n  \n  uVar3 = **param_1 & 0xf;\n  pbVar5 = *param_1 + -(longlong)(char)(&DAT_140024780)[uVar3];\n  uVar3 = *(uint *)(pbVar5 + -4) >> ((&DAT_140024790)[uVar3] & 0x1f);\n  *param_1 = pbVar5;\n  uVar4 = uVar3 & 3;\n  *(uint *)(this + 0x14) = uVar4;\n  *(uint *)(this + 0x10) = uVar3 >> 2;\n  if ((uVar4 == 1) || (uVar4 == 2)) {\n    uVar2 = *(undefined4 *)*param_1;\n    *param_1 = *param_1 + 4;\n    *(undefined4 *)(this + 0x18) = uVar2;\n    uVar3 = **param_1 & 0xf;\n    bVar1 = (&DAT_140024790)[uVar3];\n    pbVar5 = *param_1 + -(longlong)(char)(&DAT_140024780)[uVar3];\n    uVar3 = *(uint *)(pbVar5 + -4);\n    *param_1 = pbVar5;\n    *(uint *)(this + 0x1c) = uVar3 >> (bVar1 & 0x1f);\n  }\n  else if (uVar4 == 3) {\n    uVar2 = *(undefined4 *)*param_1;\n    *param_1 = *param_1 + 4;\n    *(undefined4 *)(this + 0x18) = uVar2;\n    return;\n  }\n  return;\n}\n\n",
  "__acrt_stdio_allocate_buffer_nolock": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n/* Library Function - Single Match\n    __acrt_stdio_allocate_buffer_nolock\n   \n   Libraries: Visual Studio 2017 Release, Visual Studio 2019 Release */\n\nvoid __acrt_stdio_allocate_buffer_nolock(undefined8 *param_1)\n\n{\n  LPVOID pvVar1;\n  undefined4 uVar2;\n  \n  _DAT_1400370e8 = _DAT_1400370e8 + 1;\n  uVar2 = 0x1000;\n  pvVar1 = _malloc_base(0x1000);\n  param_1[1] = pvVar1;\n  _free_base((LPVOID)0x0);\n  if (param_1[1] == 0) {\n    LOCK();\n    *(uint *)((longlong)param_1 + 0x14) = *(uint *)((longlong)param_1 + 0x14) | 0x400;\n    UNLOCK();\n    uVar2 = 2;\n    param_1[1] = (longlong)param_1 + 0x1c;\n  }\n  else {\n    LOCK();\n    *(uint *)((longlong)param_1 + 0x14) = *(uint *)((longlong)param_1 + 0x14) | 0x40;\n    UNLOCK();\n  }\n  *(undefined4 *)(param_1 + 4) = uVar2;\n  *(undefined4 *)(param_1 + 2) = 0;\n  *param_1 = param_1[1];\n  return;\n}\n\n"
}