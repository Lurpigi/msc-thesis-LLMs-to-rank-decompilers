{
  "sh_unset_nodelay_mode": "\nuint sh_unset_nodelay_mode(int param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar1 = fcntl(param_1,3,0);\n  if ((int)uVar1 < 0) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    uVar2 = uVar1 & 0x800;\n    if (uVar2 != 0) {\n      uVar1 = fcntl(param_1,4,(ulong)(uVar1 & 0xfffff7ff));\n      return uVar1;\n    }\n  }\n  return uVar2;\n}\n\n",
  "phash_remove": "\nint phash_remove(undefined8 param_1)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  long lVar3;\n  \n  iVar2 = hashing_enabled;\n  if (hashing_enabled != 0) {\n    iVar2 = 0;\n    if (hashed_filenames != 0) {\n      lVar3 = hash_remove(param_1,hashed_filenames,0);\n      iVar2 = 1;\n      if (lVar3 != 0) {\n        puVar1 = *(undefined8 **)(lVar3 + 0x10);\n        if (puVar1 != (undefined8 *)0x0) {\n          sh_xfree(*puVar1,\"hashcmd.c\",0x35);\n          sh_xfree(puVar1,\"hashcmd.c\",0x36);\n        }\n        sh_xfree(*(undefined8 *)(lVar3 + 8),\"hashcmd.c\",0x4f);\n        sh_xfree(lVar3,\"hashcmd.c\",0x50);\n        iVar2 = 0;\n      }\n      return iVar2;\n    }\n  }\n  return iVar2;\n}\n\n",
  "FUN_00192980": "\nchar * FUN_00192980(char *param_1,int param_2)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  uint uVar3;\n  char cVar4;\n  size_t sVar5;\n  char *__dest;\n  char *pcVar6;\n  long lVar7;\n  long lVar8;\n  bool bVar9;\n  \n  if (param_2 == 0) {\n    if (DAT_002487c8 != (char *)0x0) {\n      sh_xfree(DAT_002487c8,\"bashline.c\",0x9bf);\n    }\n    cVar4 = *param_1;\n    DAT_002487c0 = (int)cVar4;\n    bVar9 = DAT_002487c0 == 0x24;\n    pcVar6 = param_1;\n    if (bVar9) {\n      cVar4 = param_1[1];\n      pcVar6 = param_1 + 1;\n    }\n    DAT_002487c4 = (uint)bVar9;\n    if (cVar4 == '{') {\n      DAT_002487c4 = bVar9 + 1;\n      pcVar6 = param_1 + (int)DAT_002487c4;\n    }\n    sVar5 = strlen(pcVar6);\n    __dest = (char *)sh_xmalloc(sVar5 + 1,\"bashline.c\",0x9ca);\n    DAT_002487c8 = strcpy(__dest,pcVar6);\n    if (DAT_002487b8 != (char *)0x0) {\n      strvec_dispose(DAT_002487b8);\n    }\n    DAT_002487b8 = (char *)all_variables_matching_prefix(DAT_002487c8);\n    DAT_002487b0 = 0;\n  }\n  pcVar6 = DAT_002487b8;\n  if ((DAT_002487b8 != (char *)0x0) &&\n     (pcVar6 = *(char **)(DAT_002487b8 + (long)DAT_002487b0 * 8), pcVar6 != (char *)0x0)) {\n    sVar5 = strlen(pcVar6);\n    pcVar6 = (char *)sh_xmalloc(sVar5 + 4,\"bashline.c\",0x9db);\n    uVar3 = DAT_002487c4;\n    iVar2 = DAT_002487b0;\n    if (DAT_002487c4 == 0) {\n      strcpy(pcVar6,*(char **)(DAT_002487b8 + (long)DAT_002487b0 * 8));\n    }\n    else {\n      lVar7 = (long)DAT_002487b0;\n      lVar8 = (long)(int)DAT_002487c4;\n      *pcVar6 = (char)DAT_002487c0;\n      ppcVar1 = (char **)(DAT_002487b8 + lVar7 * 8);\n      if (uVar3 != 2) {\n        strcpy(pcVar6 + lVar8,*ppcVar1);\n        DAT_002487b0 = iVar2 + 1;\n        return pcVar6;\n      }\n      pcVar6[1] = '{';\n      strcpy(pcVar6 + lVar8,*ppcVar1);\n      sVar5 = strlen(pcVar6);\n      *(undefined2 *)(pcVar6 + sVar5) = 0x7d;\n    }\n    DAT_002487b0 = iVar2 + 1;\n    return pcVar6;\n  }\n  return pcVar6;\n}\n\n",
  "print_unix_command_map": "\nundefined8 print_unix_command_map(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = rl_get_keymap();\n  uVar2 = FUN_001944d0(uVar1);\n  rl_set_keymap(uVar2);\n  rl_macro_dumper(1);\n  rl_set_keymap(uVar1);\n  return 0;\n}\n\n",
  "hash_bucket": "\nuint hash_bucket(char *param_1,long param_2)\n\n{\n  char cVar1;\n  uint uVar2;\n  \n  uVar2 = 0x811c9dc5;\n  cVar1 = *param_1;\n  while (cVar1 != '\\0') {\n    param_1 = param_1 + 1;\n    uVar2 = (int)cVar1 ^ uVar2 * 0x1000193;\n    cVar1 = *param_1;\n  }\n  return uVar2 & *(int *)(param_2 + 8) - 1U;\n}\n\n",
  "wcscmp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcscmp(wchar_t *__s1,wchar_t *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wcscmp_00237838)();\n  return iVar1;\n}\n\n",
  "append_history": "\nvoid append_history(undefined4 param_1,undefined8 param_2)\n\n{\n  FUN_001f5220(param_2,param_1,0);\n  return;\n}\n\n",
  "internal_debug": "\nvoid internal_debug(void)\n\n{\n  return;\n}\n\n",
  "_rl_region_color_off": "\nvoid _rl_region_color_off(void)\n\n{\n  if ((_rl_active_region_start_color != 0) && (_rl_active_region_end_color != 0)) {\n    tputs(_rl_active_region_end_color,1,_rl_output_character_function);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001e74c0": "\nvoid FUN_001e74c0(undefined4 param_1)\n\n{\n  _rl_caught_signal = param_1;\n  if ((code *)0x1 < DAT_0024aba0) {\n    rl_readline_state = rl_readline_state | 0x8000;\n    (*DAT_0024aba0)();\n    rl_readline_state = rl_readline_state & 0xffffffffffff7fff;\n    return;\n  }\n  rl_readline_state =\n       CONCAT62((int6)(rl_readline_state >> 0x10),\n                CONCAT11((char)((rl_readline_state | 0x8000) >> 8),(char)rl_readline_state)) &\n       0xffffffffffff7fff;\n  return;\n}\n\n",
  "rl_message": "\nundefined8\nrl_message(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n          undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n          undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n          undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  int iVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  undefined4 local_e8;\n  undefined4 local_e4;\n  undefined *local_e0;\n  undefined *local_d8;\n  long local_d0;\n  undefined local_c8 [8];\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  \n  if (in_AL != '\\0') {\n    local_98 = param_1;\n    local_88 = param_2;\n    local_78 = param_3;\n    local_68 = param_4;\n    local_58 = param_5;\n    local_48 = param_6;\n    local_38 = param_7;\n    local_28 = param_8;\n  }\n  local_d0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e0 = &stack0x00000008;\n  local_e8 = 8;\n  local_d8 = local_c8;\n  local_e4 = 0x30;\n  local_c0 = param_10;\n  local_b8 = param_11;\n  local_b0 = param_12;\n  local_a8 = param_13;\n  local_a0 = param_14;\n  if (DAT_0024a8b8 == 0) {\n    DAT_0024a8b4 = 0x80;\n    DAT_0024a8b8 = xmalloc(0x80);\n  }\n  iVar1 = __vsnprintf_chk(DAT_0024a8b8,(long)DAT_0024a8b4,1,0xffffffffffffffff,param_9,&local_e8);\n  if (DAT_0024a8b4 + -1 <= iVar1) {\n    DAT_0024a8b4 = iVar1 + 1;\n    DAT_0024a8b8 = xrealloc(DAT_0024a8b8,(long)DAT_0024a8b4);\n    local_e0 = &stack0x00000008;\n    local_d8 = local_c8;\n    local_e8 = 8;\n    local_e4 = 0x30;\n    __vsnprintf_chk(DAT_0024a8b8,(long)(DAT_0024a8b4 + -1),1,0xffffffffffffffff,param_9,&local_e8);\n  }\n  if (DAT_0024a858 == (void *)0x0) {\n    rl_save_prompt();\n    DAT_0024a82c = 1;\n  }\n  else if ((char *)DAT_0024a858 != DAT_0024a8a0) {\n    if (DAT_0024a8a0 != (char *)0x0) {\n      free(DAT_0024a8a0);\n    }\n    if (DAT_0024a898 != (void *)0x0) {\n      free(DAT_0024a898);\n    }\n    DAT_0024a8a0 = (char *)0x0;\n  }\n  rl_display_prompt = DAT_0024a8b8;\n  DAT_0024a8a0 = (char *)FUN_001e0bd0(DAT_0024a8b8,0,&DAT_0024a88c,&DAT_0024a880,&DAT_0024a878,\n                                      &DAT_0024a870);\n  DAT_0024a898 = (void *)0x0;\n  uVar2 = 0;\n  if (DAT_0024a8a0 != (char *)0x0) {\n    sVar3 = strlen(DAT_0024a8a0);\n    uVar2 = (undefined4)sVar3;\n  }\n  DAT_0024a894 = uVar2;\n  (*(code *)rl_redisplay_function)();\n  if (local_d0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "strncmp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strncmp_00237888)();\n  return iVar1;\n}\n\n",
  "make_function_def": "\nvoid make_function_def(undefined8 *param_1,long param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 *puVar1;\n  long lVar2;\n  size_t sVar3;\n  char *__dest;\n  char *pcVar4;\n  undefined8 *puVar5;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x20,\"make_cmd.c\",0x312);\n  *(long *)(puVar1 + 4) = param_2;\n  *(undefined8 **)(puVar1 + 2) = param_1;\n  puVar1[1] = param_3;\n  *puVar1 = 0;\n  *(undefined4 *)(param_2 + 8) = param_4;\n  *(undefined8 *)(puVar1 + 6) = 0;\n  lVar2 = find_variable(\"BASH_SOURCE\");\n  if ((((lVar2 == 0) || ((*(byte *)(lVar2 + 0x28) & 4) == 0)) ||\n      (lVar2 = *(long *)(lVar2 + 8), lVar2 == 0)) || (*(long *)(lVar2 + 8) < 1)) {\n    lVar2 = *(long *)(puVar1 + 6);\n  }\n  else {\n    lVar2 = array_reference(lVar2,0);\n    *(long *)(puVar1 + 6) = lVar2;\n  }\n  if (lVar2 == 0) {\n    pcVar4 = \"main\";\n    if (shell_initialized == 0) {\n      pcVar4 = \"environment\";\n    }\n    *(char **)(puVar1 + 6) = pcVar4;\n  }\n  bind_function_def(*param_1,puVar1,0);\n  pcVar4 = *(char **)(puVar1 + 6);\n  if (pcVar4 != (char *)0x0) {\n    sVar3 = strlen(pcVar4);\n    __dest = (char *)sh_xmalloc(sVar3 + 1,\"make_cmd.c\",0x32a);\n    pcVar4 = strcpy(__dest,pcVar4);\n  }\n  *(char **)(puVar1 + 6) = pcVar4;\n  puVar5 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar5[3] = puVar1;\n  *puVar5 = 7;\n  *puVar1 = 0;\n  puVar5[2] = 0;\n  return;\n}\n\n",
  "FUN_00152050": "\nvoid FUN_00152050(long *param_1,code *param_2,long *param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  char **ppcVar3;\n  char *__s1;\n  char *__s2;\n  int iVar4;\n  long lVar5;\n  long **pplVar6;\n  ulong uVar7;\n  bool bVar8;\n  int local_4c;\n  long local_48;\n  \n  if ((((param_1 != (long *)0x0) && (*(int *)((long)param_1 + 0xc) != 0)) &&\n      (((ulong)param_3 | (ulong)param_2) != 0)) && (0 < *(int *)(param_1 + 1))) {\n    local_48 = 0;\n    do {\n      pplVar6 = *(long ***)(*param_1 + local_48 * 8);\n      while (pplVar6 != (long **)0x0) {\nLAB_001520c8:\n        ppcVar3 = (char **)pplVar6[2];\n        bVar8 = true;\n        if (param_2 != (code *)0x0) {\n          iVar4 = (*param_2)();\n          bVar8 = iVar4 != 0;\n        }\n        if ((param_3 == (long *)0x0) || (!bVar8)) {\nLAB_00152148:\n          pplVar6 = (long **)*pplVar6;\n          if (pplVar6 == (long **)0x0) break;\n          goto LAB_001520c8;\n        }\n        local_4c = *(int *)((long)param_3 + 0xc);\n        lVar5 = *param_3;\n        if (0 < local_4c) {\n          uVar7 = 1;\n          __s1 = *ppcVar3;\n          cVar1 = *__s1;\n          while ((__s2 = **(char ***)(lVar5 + -8 + uVar7 * 8), cVar1 != *__s2 ||\n                 (iVar4 = strcmp(__s1,__s2), iVar4 != 0))) {\n            iVar4 = (int)uVar7;\n            uVar7 = uVar7 + 1;\n            if (uVar7 == local_4c + 1) goto LAB_00152180;\n          }\n          goto LAB_00152148;\n        }\n        iVar4 = 0;\nLAB_00152180:\n        iVar2 = *(int *)(param_3 + 1);\n        if (iVar2 <= iVar4) {\n          *(int *)(param_3 + 1) = iVar2 + 0x10;\n          lVar5 = sh_xrealloc(lVar5,(long)(iVar2 + 0x11) << 3,\"variables.c\",0x105e);\n          *param_3 = lVar5;\n          local_4c = *(int *)((long)param_3 + 0xc);\n        }\n        pplVar6 = (long **)*pplVar6;\n        *(int *)((long)param_3 + 0xc) = local_4c + 1;\n        *(undefined8 *)(lVar5 + 8 + (long)local_4c * 8) = 0;\n        *(char ***)(lVar5 + (long)local_4c * 8) = ppcVar3;\n      }\n      local_48 = local_48 + 1;\n    } while (*(int *)(param_1 + 1) != (int)local_48 && (int)local_48 <= *(int *)(param_1 + 1));\n  }\n  return;\n}\n\n",
  "FUN_0015c720": "\nulong FUN_0015c720(void)\n\n{\n  int iVar1;\n  ulong uVar2;\n  ulong uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  ulong uVar6;\n  bool bVar7;\n  \n  uVar2 = FUN_0015c4c0();\n  iVar1 = DAT_00242448;\n  while (DAT_00242448 = iVar1, iVar1 - 1U < 2) {\n    FUN_0015d330();\n    uVar3 = FUN_0015c4c0();\n    if (iVar1 == 1) {\n      bVar7 = uVar3 == uVar2;\n    }\n    else {\n      bVar7 = uVar3 != uVar2;\n    }\n    uVar2 = (ulong)bVar7;\n    DAT_00242444 = 6;\n    iVar1 = DAT_00242448;\n  }\n  while (DAT_00242448 == 0x26) {\n    FUN_0015d330();\n    uVar3 = FUN_0015c4c0();\n    iVar1 = DAT_00242448;\n    while (DAT_00242448 = iVar1, iVar1 - 1U < 2) {\n      FUN_0015d330();\n      uVar4 = FUN_0015c4c0();\n      if (iVar1 == 1) {\n        bVar7 = uVar4 == uVar3;\n      }\n      else {\n        bVar7 = uVar4 != uVar3;\n      }\n      uVar3 = (ulong)bVar7;\n      DAT_00242444 = 6;\n      iVar1 = DAT_00242448;\n    }\n    DAT_00242444 = 6;\n    uVar2 = uVar2 & uVar3;\n  }\n  while (DAT_00242448 == 0x5e) {\n    FUN_0015d330();\n    uVar3 = FUN_0015c4c0();\n    iVar1 = DAT_00242448;\n    while (DAT_00242448 = iVar1, iVar1 - 1U < 2) {\n      FUN_0015d330();\n      uVar4 = FUN_0015c4c0();\n      if (iVar1 == 1) {\n        bVar7 = uVar4 == uVar3;\n      }\n      else {\n        bVar7 = uVar4 != uVar3;\n      }\n      uVar3 = (ulong)bVar7;\n      DAT_00242444 = 6;\n      iVar1 = DAT_00242448;\n    }\n    while (DAT_00242448 == 0x26) {\n      FUN_0015d330();\n      uVar4 = FUN_0015c4c0();\n      iVar1 = DAT_00242448;\n      while (DAT_00242448 = iVar1, iVar1 - 1U < 2) {\n        FUN_0015d330();\n        uVar5 = FUN_0015c4c0();\n        if (iVar1 == 1) {\n          bVar7 = uVar5 == uVar4;\n        }\n        else {\n          bVar7 = uVar5 != uVar4;\n        }\n        uVar4 = (ulong)bVar7;\n        DAT_00242444 = 6;\n        iVar1 = DAT_00242448;\n      }\n      DAT_00242444 = 6;\n      uVar3 = uVar3 & uVar4;\n    }\n    DAT_00242444 = 6;\n    uVar2 = uVar2 ^ uVar3;\n  }\n  while (DAT_00242448 == 0x7c) {\n    FUN_0015d330();\n    uVar3 = FUN_0015c4c0();\n    iVar1 = DAT_00242448;\n    while (DAT_00242448 = iVar1, iVar1 - 1U < 2) {\n      FUN_0015d330();\n      uVar4 = FUN_0015c4c0();\n      if (iVar1 == 1) {\n        bVar7 = uVar4 == uVar3;\n      }\n      else {\n        bVar7 = uVar4 != uVar3;\n      }\n      uVar3 = (ulong)bVar7;\n      DAT_00242444 = 6;\n      iVar1 = DAT_00242448;\n    }\n    while (DAT_00242448 == 0x26) {\n      FUN_0015d330();\n      uVar4 = FUN_0015c4c0();\n      iVar1 = DAT_00242448;\n      while (DAT_00242448 = iVar1, iVar1 - 1U < 2) {\n        FUN_0015d330();\n        uVar5 = FUN_0015c4c0();\n        if (iVar1 == 1) {\n          bVar7 = uVar5 == uVar4;\n        }\n        else {\n          bVar7 = uVar5 != uVar4;\n        }\n        uVar4 = (ulong)bVar7;\n        DAT_00242444 = 6;\n        iVar1 = DAT_00242448;\n      }\n      DAT_00242444 = 6;\n      uVar3 = uVar3 & uVar4;\n    }\n    while (DAT_00242448 == 0x5e) {\n      FUN_0015d330();\n      uVar4 = FUN_0015c4c0();\n      iVar1 = DAT_00242448;\n      while (DAT_00242448 = iVar1, iVar1 - 1U < 2) {\n        FUN_0015d330();\n        uVar5 = FUN_0015c4c0();\n        if (iVar1 == 1) {\n          bVar7 = uVar5 == uVar4;\n        }\n        else {\n          bVar7 = uVar5 != uVar4;\n        }\n        uVar4 = (ulong)bVar7;\n        DAT_00242444 = 6;\n        iVar1 = DAT_00242448;\n      }\n      while (DAT_00242448 == 0x26) {\n        FUN_0015d330();\n        uVar5 = FUN_0015c4c0();\n        iVar1 = DAT_00242448;\n        while (DAT_00242448 = iVar1, iVar1 - 1U < 2) {\n          FUN_0015d330();\n          uVar6 = FUN_0015c4c0();\n          if (iVar1 == 1) {\n            bVar7 = uVar6 == uVar5;\n          }\n          else {\n            bVar7 = uVar6 != uVar5;\n          }\n          uVar5 = (ulong)bVar7;\n          DAT_00242444 = 6;\n          iVar1 = DAT_00242448;\n        }\n        DAT_00242444 = 6;\n        uVar4 = uVar4 & uVar5;\n      }\n      DAT_00242444 = 6;\n      uVar3 = uVar3 ^ uVar4;\n    }\n    DAT_00242444 = 6;\n    uVar2 = uVar2 | uVar3;\n  }\n  return uVar2;\n}\n\n",
  "sh_restricted": "\nvoid sh_restricted(long param_1)\n\n{\n  if (param_1 != 0) {\n    builtin_error(\"%s: restricted\",param_1);\n    return;\n  }\n  builtin_error(\"restricted\",0);\n  return;\n}\n\n",
  "rl_get_keymap_name": "\nlong rl_get_keymap_name(long param_1)\n\n{\n  long *plVar1;\n  int iVar2;\n  long lVar3;\n  \n  lVar3 = *(long *)PTR_PTR_s_emacs_00240468;\n  if (lVar3 != 0) {\n    iVar2 = 0;\n    plVar1 = (long *)PTR_PTR_s_emacs_00240468;\n    do {\n      if (param_1 == plVar1[1]) {\n        return *(long *)(PTR_PTR_s_emacs_00240468 + (long)iVar2 * 0x10);\n      }\n      lVar3 = plVar1[2];\n      iVar2 = iVar2 + 1;\n      plVar1 = plVar1 + 2;\n    } while (lVar3 != 0);\n  }\n  return lVar3;\n}\n\n",
  "rl_digit_argument": "\nundefined8 rl_digit_argument(undefined8 param_1,undefined4 param_2)\n\n{\n  undefined8 uVar1;\n  \n  rl_save_prompt();\n  _rl_argcxt = 0;\n  if ((rl_readline_state & 0x80000) == 0) {\n    rl_readline_state = rl_readline_state | 0x400;\n    rl_execute_next(param_2);\n    uVar1 = FUN_001f0a70();\n    return uVar1;\n  }\n  rl_readline_state = rl_readline_state | 0x400;\n  _rl_arg_dispatch(0,param_2);\n  rl_message(\"(arg: %d) \",rl_arg_sign * rl_numeric_arg);\n  return 0;\n}\n\n",
  "get_new_window_size": "\nvoid get_new_window_size(undefined8 param_1,uint *param_2,uint *param_3)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  ushort local_28;\n  ushort local_26;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = shell_tty;\n  if (shell_tty == -1) {\n    iVar1 = fileno(stderr);\n  }\n  if ((((-1 < iVar1) && (iVar1 = ioctl(iVar1,0x5413,&local_28), iVar1 == 0)) && (local_28 != 0)) &&\n     (local_26 != 0)) {\n    sh_set_lines_and_columns();\n    if (((interactive_shell != 0) && (no_line_editing == 0)) || (bash_readline_initialized != 0)) {\n      rl_set_screen_size(local_28,local_26);\n    }\n    if (param_2 != (uint *)0x0) {\n      *param_2 = (uint)local_28;\n    }\n    if (param_3 != (uint *)0x0) {\n      *param_3 = (uint)local_26;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "FUN_00148aa0": "\nint FUN_00148aa0(char *param_1)\n\n{\n  int iVar1;\n  size_t sVar2;\n  wchar_t *__s;\n  long lVar3;\n  long lVar4;\n  \n  sVar2 = mbstowcs((wchar_t *)0x0,param_1,0);\n  if (sVar2 == 0xffffffffffffffff) {\n    lVar3 = 4;\n    lVar4 = 1;\n    sVar2 = 0;\n  }\n  else {\n    lVar4 = sVar2 + 1;\n    lVar3 = lVar4 * 4;\n  }\n  __s = (wchar_t *)sh_xmalloc(lVar3,\"execute_cmd.c\",0xc8f);\n  __mbstowcs_chk(__s,param_1,lVar4,0x3fffffffffffffff);\n  iVar1 = wcswidth(__s,sVar2);\n  sh_xfree(__s,\"execute_cmd.c\",0xc92);\n  if ((((iVar1 < 0) && (iVar1 = 0, param_1 != (char *)0x0)) && (*param_1 != '\\0')) &&\n     ((iVar1 = 1, param_1[1] != '\\0' && (iVar1 = 2, param_1[2] != '\\0')))) {\n    sVar2 = strlen(param_1);\n    iVar1 = (int)sVar2;\n  }\n  return iVar1;\n}\n\n",
  "set_job_control": "\nint set_job_control(int param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = job_control;\n  job_control = param_1;\n  if ((terminal_pgrp == -1) && (-1 < shell_tty)) {\n    terminal_pgrp = tcgetpgrp(shell_tty);\n  }\n  if ((iVar1 == job_control) || (job_control == 0)) {\n    running_in_background = (uint)(terminal_pgrp != shell_pgrp);\n  }\n  else {\n    shell_pgrp = getpgrp();\n    running_in_background = (uint)(terminal_pgrp != shell_pgrp);\n    if ((iVar1 != job_control) && (job_control != 0)) {\n      pipeline_pgrp = 0;\n      return iVar1;\n    }\n  }\n  return iVar1;\n}\n\n",
  "file_iswdir": "\nbool file_iswdir(char *param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  bool bVar2;\n  stat sStack_a8;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = stat(param_1,&sStack_a8);\n  if ((iVar1 == 0) && ((sStack_a8.st_mode & 0xf000) == 0x4000)) {\n    iVar1 = sh_eaccess(param_1,2);\n    bVar2 = iVar1 == 0;\n  }\n  else {\n    bVar2 = false;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "unary_test": "\nbool unary_test(long param_1,char *param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  uint uVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  bool bVar5;\n  undefined2 local_d8;\n  short sStack_d6;\n  int iStack_d4;\n  undefined local_b8 [88];\n  long local_60;\n  int local_58;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  switch(*(undefined *)(param_1 + 1)) {\n  case 0x47:\n    iVar1 = sh_stat(param_2,local_b8);\n    if ((iVar1 == 0) && (DAT_0023804c == local_b8._32_4_)) {\nLAB_001869c8:\n      bVar5 = true;\n      goto LAB_00186932;\n    }\n    break;\n  case 0x4c:\n  case 0x68:\n    if ((*param_2 != '\\0') && (iVar1 = lstat(param_2,(stat *)local_b8), iVar1 == 0)) {\n      bVar5 = (local_b8._24_4_ & 0xf000) == 0xa000;\n      goto LAB_00186932;\n    }\n    break;\n  case 0x4e:\n    iVar1 = sh_stat(param_2,local_b8);\n    if ((-1 < iVar1) && ((long)local_b8._72_8_ <= local_60)) {\n      bVar5 = true;\n      if (local_b8._72_8_ == local_60) {\n        bVar5 = 0 < local_58 - local_b8._80_4_;\n      }\n      goto LAB_00186932;\n    }\n    break;\n  case 0x4f:\n    iVar1 = sh_stat(param_2,local_b8);\n    if ((iVar1 == 0) && (DAT_00238044 == local_b8._28_4_)) goto LAB_001869c8;\n    break;\n  case 0x52:\n    lVar2 = find_variable_noref(param_2);\n    if ((lVar2 != 0) && (((*(uint *)(lVar2 + 0x28) & 0x1000) == 0 && (*(long *)(lVar2 + 8) != 0))))\n    {\n      local_b8._24_4_ = *(uint *)(lVar2 + 0x28) & 0x800;\njoined_r0x00186b7a:\n      if (local_b8._24_4_ != 0) goto LAB_001869c8;\n    }\n    break;\n  case 0x53:\n    iVar1 = sh_stat(param_2,local_b8);\n    if ((iVar1 == 0) && ((local_b8._24_4_ & 0xf000) == 0xc000)) goto LAB_001869c8;\n    break;\n  case 0x61:\n  case 0x65:\n    iVar1 = sh_stat(param_2,local_b8);\n    bVar5 = iVar1 == 0;\n    goto LAB_00186932;\n  case 0x62:\n    iVar1 = sh_stat(param_2,local_b8);\n    if ((iVar1 == 0) && ((local_b8._24_4_ & 0xf000) == 0x6000)) goto LAB_001869c8;\n    break;\n  case 99:\n    iVar1 = sh_stat(param_2,local_b8);\n    if ((iVar1 == 0) && ((local_b8._24_4_ & 0xf000) == 0x2000)) goto LAB_001869c8;\n    break;\n  case 100:\n    iVar1 = sh_stat(param_2,local_b8);\n    if ((iVar1 == 0) && ((local_b8._24_4_ & 0xf000) == 0x4000)) goto LAB_001869c8;\n    break;\n  case 0x66:\n    iVar1 = sh_stat(param_2,local_b8);\n    if (-1 < iVar1) {\n      bVar5 = (local_b8._24_4_ & 0x7000) == 0;\n      goto LAB_00186932;\n    }\n    break;\n  case 0x67:\n    iVar1 = sh_stat(param_2,local_b8);\n    if (iVar1 == 0) {\n      local_b8._24_4_ = local_b8._24_4_ & 0x400;\n      goto joined_r0x00186b7a;\n    }\n    break;\n  case 0x6b:\n    iVar1 = sh_stat(param_2,local_b8);\n    if (iVar1 == 0) {\n      local_b8._24_4_ = local_b8._24_4_ & 0x200;\n      goto joined_r0x00186b7a;\n    }\n    break;\n  case 0x6e:\n    bVar5 = *param_2 != '\\0';\n    goto LAB_00186932;\n  case 0x6f:\n    iVar1 = minus_o_option_value(param_2);\n    bVar5 = iVar1 == 1;\n    goto LAB_00186932;\n  case 0x70:\n    iVar1 = sh_stat(param_2,local_b8);\n    if ((iVar1 == 0) && ((local_b8._24_4_ & 0xf000) == 0x1000)) goto LAB_001869c8;\n    break;\n  case 0x72:\n    uVar4 = 4;\n    goto LAB_00186aa5;\n  case 0x73:\n    iVar1 = sh_stat(param_2,local_b8);\n    if ((iVar1 == 0) && (0 < (long)local_b8._48_8_)) goto LAB_001869c8;\n    break;\n  case 0x74:\n    iVar1 = legal_number(param_2,&local_d8);\n    if ((iVar1 != 0) &&\n       (iVar1 = CONCAT22(sStack_d6,local_d8), CONCAT44(iStack_d4,iVar1) == (long)iVar1)) {\n      iVar1 = isatty(iVar1);\n      bVar5 = iVar1 != 0;\n      goto LAB_00186932;\n    }\n    break;\n  case 0x75:\n    iVar1 = sh_stat(param_2,local_b8);\n    if (iVar1 == 0) {\n      local_b8._24_4_ = local_b8._24_4_ & 0x800;\n      goto joined_r0x00186b7a;\n    }\n    break;\n  case 0x76:\n    uVar3 = (uint)(assoc_expand_once != 0) << 5;\n    iVar1 = valid_array_reference(param_2,(ulong)(assoc_expand_once != 0) << 5);\n    if (iVar1 != 0) {\n      if (0x33 < shell_compatibility_level) {\n        uVar3 = uVar3 | 0x80;\n      }\n      init_eltstate(&local_d8);\n      lVar2 = get_array_value(param_2,uVar3 | 1,&local_d8);\n      bVar5 = lVar2 != 0;\n      if (0 < sStack_d6) {\n        sh_xfree(lVar2,\"test.c\",0x28b);\n      }\n      flush_eltstate(&local_d8);\n      goto LAB_00186932;\n    }\n    iVar1 = legal_number(param_2,&local_d8);\n    if (iVar1 == 0) {\n      lVar2 = find_variable(param_2);\n      if (lVar2 != 0) {\n        uVar3 = *(uint *)(lVar2 + 0x28);\n        if ((uVar3 & 0x1004) == 4) {\n          lVar2 = array_reference(*(undefined8 *)(lVar2 + 8),0);\n          bVar5 = lVar2 != 0;\n          goto LAB_00186932;\n        }\n        if ((uVar3 & 0x1040) == 0x40) {\n          lVar2 = assoc_reference(*(undefined8 *)(lVar2 + 8),&DAT_00210deb);\n          bVar5 = lVar2 != 0;\n          goto LAB_00186932;\n        }\n        if (((uVar3 & 0x1000) == 0) && (*(long *)(lVar2 + 8) != 0)) goto LAB_001869c8;\n      }\n    }\n    else if (-1 < iStack_d4) {\n      iVar1 = number_of_args();\n      bVar5 = CONCAT44(iStack_d4,CONCAT22(sStack_d6,local_d8)) <= (long)iVar1;\n      goto LAB_00186932;\n    }\n    break;\n  case 0x77:\n    uVar4 = 2;\n    goto LAB_00186aa5;\n  case 0x78:\n    uVar4 = 1;\nLAB_00186aa5:\n    iVar1 = sh_eaccess(param_2,uVar4);\n    bVar5 = iVar1 == 0;\n    goto LAB_00186932;\n  case 0x7a:\n    bVar5 = *param_2 == '\\0';\n    goto LAB_00186932;\n  }\n  bVar5 = false;\nLAB_00186932:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_ITM_registerTMCloneTable": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_registerTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n",
  "maybe_set_debug_trap": "\nvoid maybe_set_debug_trap(undefined8 param_1)\n\n{\n  if (((byte)DAT_00247f44 & 1) != 0) {\n    return;\n  }\n  set_signal(0x41,param_1);\n  return;\n}\n\n",
  "FUN_00133f20": "\nulong FUN_00133f20(char *param_1)\n\n{\n  int iVar1;\n  ulong uVar2;\n  size_t sVar3;\n  char *pcVar4;\n  \n  iVar1 = __sigsetjmp(top_level,0);\n  if (iVar1 != 0) {\n    uVar2 = unlink_fifo_list();\n    if (iVar1 == 2) {\n      last_command_exit_value = 1;\n      return uVar2;\n    }\n    if (iVar1 < 3) {\n      if (iVar1 == 1) {\n        last_command_exit_value = 0x7f;\n        return uVar2;\n      }\n    }\n    else if ((iVar1 < 5) || (iVar1 == 6)) {\n      return (ulong)last_command_exit_value;\n    }\n    command_error(\"run_one_command\",3,iVar1,0);\n  }\n  sVar3 = strlen(param_1);\n  pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"shell.c\",0x5c1);\n  pcVar4 = strcpy(pcVar4,param_1);\n  uVar2 = parse_and_execute(pcVar4,&DAT_001fa0a7,0x14);\n  return uVar2;\n}\n\n",
  "FUN_00187140": "\nulong FUN_00187140(void)\n\n{\n  char *pcVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  pcVar1 = *(char **)(DAT_00248560 + (long)DAT_0024856c * 8);\n  if (*pcVar1 == '!') {\n    if (pcVar1[1] == '\\0') {\n      return (ulong)(**(char **)(DAT_00248560 + 8 + (long)DAT_0024856c * 8) == '\\0');\n    }\n  }\n  else if (((*pcVar1 == '-') && (pcVar1[1] != '\\0')) && (pcVar1[2] == '\\0')) {\n    iVar2 = test_unop(pcVar1);\n    if (iVar2 != 0) {\n      uVar3 = FUN_00186e30();\n      return uVar3;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00186410(\"%s: unary operator expected\");\n}\n\n",
  "assoc_modcase": "\nundefined8 assoc_modcase(long param_1,undefined8 param_2,undefined4 param_3,uint param_4)\n\n{\n  long *plVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  if (((param_1 == 0) || (*(int *)(param_1 + 0xc) == 0)) ||\n     (plVar1 = (long *)FUN_0018d590(param_1,0), plVar5 = plVar1, plVar1 == (long *)0x0)) {\n    uVar3 = 0;\n  }\n  else {\n    do {\n      lVar2 = sh_modcase(*(undefined8 *)plVar5[1],param_2,param_3);\n      plVar4 = (long *)plVar5[1];\n      if (*plVar4 != 0) {\n        sh_xfree(*plVar4,\"assoc.c\",0x165);\n        plVar4 = (long *)plVar5[1];\n      }\n      plVar5 = (long *)*plVar5;\n      *plVar4 = lVar2;\n    } while (plVar5 != (long *)0x0);\n    uVar3 = string_list_pos_params\n                      ((-((param_4 & 0x80) == 0) & 0x16U) + 0x2a,plVar1,(int)param_4 >> 5 & 1,\n                       (int)param_4 >> 3 & 8);\n    dispose_words(plVar1);\n  }\n  return uVar3;\n}\n\n",
  "shtimer_select": "\nint shtimer_select(long *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  fd_set *pfVar3;\n  int iVar4;\n  long in_FS_OFFSET;\n  byte bVar5;\n  timeval local_158;\n  timespec local_148;\n  sigset_t local_138;\n  fd_set local_b8;\n  long local_30;\n  \n  bVar5 = 0;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_138);\n  sigaddset(&local_138,0x11);\n  iVar1 = gettimeofday(&local_158,(__timezone_ptr_t)0x0);\n  if (iVar1 < 0) {\n    if ((*(byte *)((long)param_1 + 0x14) & 4) != 0) goto LAB_001cd72c;\n    iVar1 = -1;\n  }\n  else {\n    lVar2 = *param_1;\n    if ((local_158.tv_sec <= lVar2) &&\n       ((local_158.tv_sec != lVar2 || (local_158.tv_usec < param_1[1])))) {\n      local_148.tv_sec = lVar2 - local_158.tv_sec;\n      local_158.tv_usec = param_1[1] - local_158.tv_usec;\n      if (local_158.tv_usec < 0) {\n        local_148.tv_sec = local_148.tv_sec + -1;\n        local_158.tv_usec = local_158.tv_usec + 1000000;\n      }\n      lVar2 = 0x10;\n      local_148.tv_nsec = local_158.tv_usec * 1000;\n      iVar1 = *(int *)(param_1 + 2);\n      pfVar3 = &local_b8;\n      iVar4 = -1;\n      if (-1 < iVar1) {\n        iVar4 = iVar1;\n      }\n      for (; lVar2 != 0; lVar2 = lVar2 + -1) {\n        pfVar3->fds_bits[0] = 0;\n        pfVar3 = (fd_set *)((long)pfVar3 + ((ulong)bVar5 * -2 + 1) * 8);\n      }\n      if (-1 < iVar1) {\n        lVar2 = __fdelt_chk((long)iVar1);\n        local_b8.fds_bits[lVar2] =\n             local_b8.fds_bits[lVar2] | 1L << ((byte)*(undefined4 *)(param_1 + 2) & 0x3f);\n      }\n      iVar1 = pselect(iVar4 + 1,&local_b8,(fd_set *)0x0,(fd_set *)0x0,&local_148,&local_138);\n      if (iVar1 != 0) goto LAB_001cd61f;\n    }\n    if ((*(byte *)((long)param_1 + 0x14) & 4) != 0) {\nLAB_001cd72c:\n                    /* WARNING: Subroutine does not return */\n      __longjmp_chk(param_1 + 6,1);\n    }\n    if ((code *)param_1[0x1f] == (code *)0x0) {\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = (*(code *)param_1[0x1f])(param_1);\n    }\n  }\nLAB_001cd61f:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
  "rl_kill_word": "\nundefined8 rl_kill_word(int param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = rl_point;\n  if (param_1 < 0) {\n    uVar2 = rl_backward_kill_word(-param_1);\n    return uVar2;\n  }\n  rl_forward_word();\n  if (rl_point != iVar1) {\n    rl_kill_text(iVar1);\n  }\n  if (rl_editing_mode == 1) {\n    rl_mark = iVar1;\n    rl_point = rl_mark;\n    return 0;\n  }\n  rl_point = iVar1;\n  return 0;\n}\n\n",
  "executable_or_directory": "\nbool executable_or_directory(void)\n\n{\n  ulong uVar1;\n  \n  uVar1 = file_status();\n  return (uVar1 & 0x12) != 0;\n}\n\n",
  "connect_async_list": "\nulong * connect_async_list(ulong *param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  ulong uVar1;\n  ulong *puVar2;\n  ulong *puVar3;\n  undefined4 *puVar4;\n  undefined8 *puVar5;\n  ulong *puVar6;\n  \n  puVar6 = *(ulong **)(param_1[3] + 0x10);\n  if (((puVar6 != (ulong *)0x0) && ((*(byte *)((long)param_1 + 4) & 1) == 0)) &&\n     (*(int *)(param_1[3] + 0x18) == 0x3b)) {\n    uVar1 = *puVar6;\n    puVar3 = param_1;\n    while ((puVar2 = puVar6, (uVar1 & 0x1ffffffff) == 6 && (*(int *)(puVar2[3] + 0x18) == 0x3b))) {\n      puVar6 = *(ulong **)(puVar2[3] + 0x10);\n      uVar1 = *puVar6;\n      puVar3 = puVar2;\n    }\n    puVar4 = (undefined4 *)sh_xmalloc(0x20,\"make_cmd.c\",0xc0);\n    puVar4[6] = param_3;\n    *(ulong **)(puVar4 + 2) = puVar2;\n    *(undefined8 *)(puVar4 + 4) = param_2;\n    puVar5 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n    puVar5[3] = puVar4;\n    *puVar5 = 6;\n    uVar1 = puVar3[3];\n    *puVar4 = 0;\n    puVar5[2] = 0;\n    *(undefined8 **)(uVar1 + 0x10) = puVar5;\n    return param_1;\n  }\n  puVar4 = (undefined4 *)sh_xmalloc(0x20,\"make_cmd.c\",0xc0);\n  puVar4[6] = param_3;\n  *(ulong **)(puVar4 + 2) = param_1;\n  *(undefined8 *)(puVar4 + 4) = param_2;\n  puVar6 = (ulong *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar6[3] = (ulong)puVar4;\n  *puVar6 = 6;\n  *puVar4 = 0;\n  puVar6[2] = 0;\n  return puVar6;\n}\n\n",
  "hash_walk": "\nvoid hash_walk(long *param_1,code *param_2)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  long lVar3;\n  \n  if (param_1 == (long *)0x0) {\n    return;\n  }\n  if ((*(int *)((long)param_1 + 0xc) != 0) && (0 < *(int *)(param_1 + 1))) {\n    lVar3 = 0;\n    do {\n      for (puVar1 = *(undefined8 **)(*param_1 + lVar3 * 8); puVar1 != (undefined8 *)0x0;\n          puVar1 = (undefined8 *)*puVar1) {\n        iVar2 = (*param_2)(puVar1);\n        if (iVar2 < 0) {\n          return;\n        }\n      }\n      lVar3 = lVar3 + 1;\n    } while (*(int *)(param_1 + 1) != (int)lVar3 && (int)lVar3 <= *(int *)(param_1 + 1));\n  }\n  return;\n}\n\n",
  "FUN_00186290": "\nulong FUN_00186290(undefined8 param_1,undefined8 param_2,int param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  undefined local_168 [88];\n  long local_110;\n  int local_108;\n  undefined local_d8 [88];\n  long local_80;\n  int local_78;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = sh_stat(param_1,local_168);\n  if (iVar1 < 0) {\n    if (param_3 != 2) {\n      iVar2 = sh_stat(param_2,local_d8);\n      if (iVar2 < 0) {\n        if (param_3 == 1) {\n          if (iVar1 < iVar2) goto LAB_00186389;\n        }\n        else if (iVar2 < iVar1) {\nLAB_00186389:\n          uVar3 = 1;\n          goto LAB_00186323;\n        }\n      }\n      else if (param_3 == 1) goto LAB_00186389;\n    }\n  }\n  else {\n    iVar1 = sh_stat(param_2,local_d8);\n    if (iVar1 < 0) {\n      if ((param_3 != 2) && (param_3 != 1)) {\n        uVar3 = 1;\n        goto LAB_00186323;\n      }\n    }\n    else if (param_3 == 1) {\n      if (local_110 < local_80) goto LAB_00186389;\n      if (local_110 == local_80) {\n        uVar3 = (ulong)((uint)(local_108 - local_78) >> 0x1f);\n        goto LAB_00186323;\n      }\n    }\n    else {\n      if (param_3 == 2) {\n        uVar3 = same_file(param_1,param_2,local_168,local_d8);\n        goto LAB_00186323;\n      }\n      if ((param_3 == 0) && (local_80 <= local_110)) {\n        if (local_110 == local_80) {\n          uVar3 = (ulong)(0 < local_108 - local_78);\n          goto LAB_00186323;\n        }\n        goto LAB_00186389;\n      }\n    }\n  }\n  uVar3 = 0;\nLAB_00186323:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
  "FUN_001e74b0": "\nvoid FUN_001e74b0(undefined4 param_1)\n\n{\n  _rl_caught_signal = param_1;\n  return;\n}\n\n",
  "clear_unwind_protect_list": "\nvoid clear_unwind_protect_list(int param_1)\n\n{\n  if (DAT_00248390 == 0) {\n    return;\n  }\n  if (param_1 == 0) {\n    DAT_00248390 = 0;\n    return;\n  }\n  do {\n    FUN_00184010();\n  } while (DAT_00248390 != 0);\n  DAT_00248390 = 0;\n  return;\n}\n\n",
  "rl_pending_signal": "\nundefined4 rl_pending_signal(void)\n\n{\n  return _rl_caught_signal;\n}\n\n",
  "FUN_0019e8a0": "\nundefined8 FUN_0019e8a0(long param_1,int param_2)\n\n{\n  long lVar1;\n  int iVar2;\n  long lVar3;\n  long *plVar4;\n  size_t sVar5;\n  char *pcVar6;\n  char *pcVar7;\n  uint uVar8;\n  long lVar9;\n  int iVar10;\n  \n  iVar10 = 1;\n  if (param_2 != 0) {\n    iVar10 = (uint)(param_2 == 1) * 3 + -1;\n  }\n  plVar4 = (long *)strlist_create(DAT_0023877c);\n  uVar8 = DAT_0023877c - 1;\n  if (-1 < (int)uVar8) {\n    lVar9 = (long)(int)uVar8 << 3;\n    lVar1 = ((long)DAT_0023877c - (ulong)uVar8) * 8 + -0x10;\n    do {\n      while ((lVar3 = *(long *)(jobs + lVar9), lVar3 != 0 &&\n             ((param_2 == -1 || (*(int *)(lVar3 + 0x14) == iVar10))))) {\n        pcVar7 = *(char **)(*(long *)(lVar3 + 8) + 0x18);\n        sVar5 = strlen(pcVar7);\n        pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"pcomplete.c\",0x247);\n        pcVar7 = strcpy(pcVar6,pcVar7);\n        pcVar6 = strpbrk(pcVar7,\" \\t\\n\");\n        if (pcVar6 != (char *)0x0) {\n          *pcVar6 = '\\0';\n        }\n        iVar2 = *(int *)((long)plVar4 + 0xc);\n        lVar9 = lVar9 + -8;\n        *(int *)((long)plVar4 + 0xc) = iVar2 + 1;\n        *(char **)(*plVar4 + (long)iVar2 * 8) = pcVar7;\n        if (lVar1 == lVar9) goto LAB_0019e995;\n      }\n      lVar9 = lVar9 + -8;\n    } while (lVar1 != lVar9);\n  }\nLAB_0019e995:\n  *(long **)(param_1 + 0x10) = plVar4;\n  return 0;\n}\n\n",
  "_rl_copy_undo_entry": "\nundefined8 * _rl_copy_undo_entry(long param_1)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  size_t sVar4;\n  char *__dest;\n  char *__s;\n  \n  uVar2 = *(undefined8 *)(param_1 + 8);\n  uVar1 = *(undefined4 *)(param_1 + 0x18);\n  puVar3 = (undefined8 *)xmalloc(0x20);\n  puVar3[1] = uVar2;\n  puVar3[2] = 0;\n  __s = *(char **)(param_1 + 0x10);\n  *(undefined4 *)(puVar3 + 3) = uVar1;\n  *puVar3 = 0;\n  if (__s != (char *)0x0) {\n    sVar4 = strlen(__s);\n    __dest = (char *)xmalloc(sVar4 + 1);\n    __s = strcpy(__dest,__s);\n  }\n  puVar3[2] = __s;\n  return puVar3;\n}\n\n",
  "FUN_001d6fc0": "\nundefined8 FUN_001d6fc0(int param_1)\n\n{\n  uint uVar1;\n  \n  do {\n    rl_readline_state = rl_readline_state | 0x40;\n    uVar1 = rl_read_key();\n    rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n    if (((uVar1 & 0xffffffdf) == 0x59) || (uVar1 == 0x20)) {\n      return 1;\n    }\n    if (uVar1 - 0x4e < 0x32) {\n      if ((0x2000100000001U >> ((ulong)(uVar1 - 0x4e) & 0x3f) & 1) != 0) {\n        return 0;\n      }\n    }\n    else if ((uVar1 == 7) || ((int)uVar1 < 0)) {\n                    /* WARNING: Subroutine does not return */\n      _rl_abort_internal();\n    }\n    if (param_1 != 0) {\n      if ((uVar1 == 10) || (uVar1 == 0xd)) {\n        return 2;\n      }\n      if ((uVar1 & 0xffffffdf) == 0x51) {\n        return 0;\n      }\n    }\n    rl_ding();\n  } while( true );\n}\n\n",
  "fileno": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fileno_00237ba0)();\n  return iVar1;\n}\n\n",
  "towlower": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nwint_t towlower(wint_t __wc)\n\n{\n  wint_t wVar1;\n  \n  wVar1 = (*(code *)PTR_towlower_00237d88)();\n  return wVar1;\n}\n\n",
  "get_directory_stack": "\nundefined8 get_directory_stack(uint param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  char *pcVar4;\n  long lVar5;\n  \n  if (DAT_00248b48 < 1) {\n    uVar1 = 0;\n  }\n  else {\n    lVar5 = 0;\n    uVar1 = 0;\n    do {\n      uVar2 = *(undefined8 *)(DAT_00248b50 + lVar5 * 8);\n      if ((param_1 & 1) != 0) {\n        uVar2 = polite_directory_format(uVar2);\n      }\n      uVar2 = make_word(uVar2);\n      lVar5 = lVar5 + 1;\n      uVar1 = make_word_list(uVar2,uVar1);\n    } while ((int)lVar5 < DAT_00248b48);\n  }\n  pcVar3 = (char *)get_working_directory(\"dirstack\");\n  if (pcVar3 != (char *)0x0) {\n    if ((param_1 & 1) != 0) {\n      pcVar4 = (char *)polite_directory_format(pcVar3);\n      if (pcVar3 != pcVar4) {\n        sh_xfree(pcVar3,\"./pushd.def\",0x2af);\n        goto LAB_001af5c4;\n      }\n    }\n    uVar2 = make_word(pcVar3);\n    uVar1 = make_word_list(uVar2,uVar1);\n    sh_xfree(pcVar3,\"./pushd.def\",0x2b7);\n    return uVar1;\n  }\n  pcVar4 = \".\";\nLAB_001af5c4:\n  uVar2 = make_word(pcVar4);\n  uVar1 = make_word_list(uVar2,uVar1);\n  return uVar1;\n}\n\n",
  "strvec_posixcmp": "\nvoid strvec_posixcmp(char **param_1,char **param_2)\n\n{\n  char *__s2;\n  char *__s1;\n  int iVar1;\n  \n  __s2 = *param_2;\n  __s1 = *param_1;\n  iVar1 = strcoll(__s1,__s2);\n  if ((iVar1 == 0) && (*__s1 == *__s2)) {\n    strcmp(__s1,__s2);\n    return;\n  }\n  return;\n}\n\n",
  "sigemptyset": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigemptyset(sigset_t *__set)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigemptyset_00237b38)();\n  return iVar1;\n}\n\n",
  "unbind_variable": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid unbind_variable(undefined8 param_1)\n\n{\n  long *plVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  \n  lVar5 = shell_variables;\n  if (shell_variables != 0) {\n    do {\n      uVar2 = *(undefined8 *)(lVar5 + 0x20);\n      lVar3 = hash_search(param_1,uVar2,0);\n      if ((lVar3 != 0) && (_DAT_002422f8 = uVar2, *(long *)(lVar3 + 0x10) != 0)) {\n        if (((*(byte *)(*(long *)(lVar3 + 0x10) + 0x29) & 8) != 0) &&\n           (puVar4 = (undefined8 *)find_variable_nameref(), puVar4 != (undefined8 *)0x0)) {\n          makunbound(*puVar4,shell_variables);\n          return;\n        }\n        break;\n      }\n      plVar1 = (long *)(lVar5 + 0x18);\n      lVar5 = *plVar1;\n    } while (*plVar1 != 0);\n  }\n  makunbound(param_1,shell_variables);\n  return;\n}\n\n",
  "strvec_mresize": "\nvoid strvec_mresize(void *param_1,int param_2)\n\n{\n  realloc(param_1,(long)param_2 << 3);\n  return;\n}\n\n",
  "tgetnum": "\nvoid tgetnum(void)\n\n{\n  (*(code *)PTR_tgetnum_00237c08)();\n  return;\n}\n\n",
  "array_from_argv": "\nlong array_from_argv(long param_1,char **param_2,int param_3)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  char *pcVar3;\n  long lVar4;\n  long lVar5;\n  long lVar6;\n  long lVar7;\n  \n  lVar7 = (long)param_3;\n  if ((param_1 == 0) || (lVar5 = *(long *)(param_1 + 8), lVar5 == 0)) {\n    lVar5 = 0;\n    if (0 < lVar7) {\n      do {\n        lVar6 = lVar5 + 1;\n        array_insert(param_1,lVar5,0);\n        lVar5 = lVar6;\n      } while (lVar7 != lVar6);\n    }\n  }\n  else {\n    if (lVar5 == lVar7) {\n      if (param_3 == 1) {\n        pcVar3 = *param_2;\n        lVar7 = *(long *)(*(long *)(param_1 + 0x10) + 0x10);\n        if (pcVar3 != (char *)0x0) {\n          sVar1 = strlen(pcVar3);\n          pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"array.c\",0x36e);\n          pcVar3 = strcpy(pcVar2,pcVar3);\n        }\n        sh_xfree(*(undefined8 *)(lVar7 + 8),\"array.c\",0x36f);\n        *(char **)(lVar7 + 8) = pcVar3;\n        return param_1;\n      }\n    }\n    else if (lVar5 != lVar7 && lVar7 <= lVar5) {\n      array_flush();\n      if (lVar7 < 1) {\n        return param_1;\n      }\n      lVar5 = 0;\n      do {\n        lVar6 = lVar5 + 1;\n        array_insert(param_1,lVar5,param_2[lVar5]);\n        lVar5 = lVar6;\n      } while (lVar7 != lVar6);\n      return param_1;\n    }\n    lVar6 = *(long *)(param_1 + 0x10);\n    lVar4 = 0;\n    if (0 < lVar5) {\n      do {\n        pcVar3 = *param_2;\n        lVar6 = *(long *)(lVar6 + 0x10);\n        if (pcVar3 != (char *)0x0) {\n          sVar1 = strlen(pcVar3);\n          pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"array.c\",0x378);\n          pcVar3 = strcpy(pcVar2,pcVar3);\n        }\n        lVar4 = lVar4 + 1;\n        sh_xfree(*(undefined8 *)(lVar6 + 8),\"array.c\",0x379);\n        *(char **)(lVar6 + 8) = pcVar3;\n      } while (*(long *)(param_1 + 8) != lVar4 && lVar4 <= *(long *)(param_1 + 8));\n    }\n    if (lVar4 < lVar7) {\n      do {\n        lVar5 = lVar4 + 1;\n        array_insert(param_1,lVar4,param_2[lVar4]);\n        lVar4 = lVar5;\n      } while (lVar7 != lVar5);\n    }\n  }\n  return param_1;\n}\n\n",
  "fatal_error": "\nvoid fatal_error(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined8 local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  FUN_0015b0b0(0);\n  local_d0 = &stack0x00000008;\n  local_d8 = 8;\n  local_c8 = local_b8;\n  local_d4 = 0x30;\n  __vfprintf_chk(stderr,1,param_9,&local_d8);\n  fputc(10,stderr);\n                    /* WARNING: Subroutine does not return */\n  sh_exit(2);\n}\n\n",
  "assoc_remove_quoted_nulls": "\nlong * assoc_remove_quoted_nulls(long *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long lVar3;\n  \n  if (param_1 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  if (*(int *)((long)param_1 + 0xc) == 0) {\n    return (long *)0x0;\n  }\n  lVar3 = 0;\n  if (0 < *(int *)(param_1 + 1)) {\n    do {\n      for (puVar1 = *(undefined8 **)(*param_1 + lVar3 * 8); puVar1 != (undefined8 *)0x0;\n          puVar1 = (undefined8 *)*puVar1) {\n        uVar2 = remove_quoted_nulls(puVar1[2]);\n        puVar1[2] = uVar2;\n      }\n      lVar3 = lVar3 + 1;\n    } while (*(int *)(param_1 + 1) != (int)lVar3 && (int)lVar3 <= *(int *)(param_1 + 1));\n  }\n  return param_1;\n}\n\n",
  "sh_needarg": "\nvoid sh_needarg(undefined8 param_1)\n\n{\n  builtin_error(\"%s: option requires an argument\",param_1);\n  return;\n}\n\n",
  "assoc_to_kvpair_list": "\nlong * assoc_to_kvpair_list(long *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  long *plVar4;\n  long lVar5;\n  \n  if (((param_1 != (long *)0x0) && (*(int *)((long)param_1 + 0xc) != 0)) &&\n     (0 < *(int *)(param_1 + 1))) {\n    lVar5 = 0;\n    plVar4 = (long *)0x0;\n    do {\n      for (puVar1 = *(undefined8 **)(*param_1 + lVar5 * 8); puVar1 != (undefined8 *)0x0;\n          puVar1 = (undefined8 *)*puVar1) {\n        uVar3 = puVar1[2];\n        uVar2 = make_bare_word(puVar1[1]);\n        uVar2 = make_word_list(uVar2,plVar4);\n        uVar3 = make_bare_word(uVar3);\n        plVar4 = (long *)make_word_list(uVar3,uVar2);\n      }\n      lVar5 = lVar5 + 1;\n    } while (*(int *)(param_1 + 1) != (int)lVar5 && (int)lVar5 <= *(int *)(param_1 + 1));\n    if (plVar4 != (long *)0x0) {\n      if (*plVar4 == 0) {\n        return plVar4;\n      }\n      plVar4 = (long *)list_reverse(plVar4);\n      return plVar4;\n    }\n  }\n  return (long *)0x0;\n}\n\n",
  "set_builtin": "\nulong set_builtin(long **param_1)\n\n{\n  char cVar1;\n  byte bVar2;\n  char cVar3;\n  char *pcVar4;\n  long **pplVar5;\n  long *plVar6;\n  bool bVar7;\n  uint uVar8;\n  int iVar9;\n  ulong uVar10;\n  long lVar11;\n  int iVar12;\n  long in_FS_OFFSET;\n  bool bVar13;\n  uint local_50;\n  char local_43;\n  ushort local_42;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (long **)0x0) {\n    lVar11 = all_shell_variables();\n    if (lVar11 != 0) {\n      print_var_list(lVar11);\n      sh_xfree(lVar11,\"./set.def\",0x20e);\n    }\n    if ((posixly_correct == 0) && (lVar11 = all_shell_functions(), lVar11 != 0)) {\n      print_func_list(lVar11);\n      sh_xfree(lVar11,\"./set.def\",0x219);\n    }\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar10 = sh_chkwrite(0);\n      return uVar10;\n    }\n    goto LAB_001b2727;\n  }\n  reset_internal_getopt();\n  do {\n    iVar9 = internal_getopt(param_1,optflags);\n    if (iVar9 == -1) {\n      local_50 = 0;\n      bVar7 = false;\n      goto LAB_001b257b;\n    }\n    if (iVar9 == 0x3f) {\n      builtin_usage();\n      uVar10 = 0;\n      if (list_optopt != 0x3f) {\n        uVar10 = 0x102;\n      }\n      goto LAB_001b2467;\n    }\n    if (iVar9 == 0x69) {\n      local_43 = (char)list_opttype;\n      local_42 = 0x69;\n      sh_invalidopt(&local_43);\n      builtin_usage();\n      uVar10 = 0x102;\n      goto LAB_001b2467;\n    }\n  } while (iVar9 != -99);\n  builtin_help();\n  uVar10 = 0x102;\n  goto LAB_001b2467;\n  while( true ) {\n    while (local_50 = uVar8, bVar2 != 0) {\n      iVar12 = (int)(char)bVar2;\n      if (iVar12 == 0x3f) {\n        builtin_usage();\n        uVar10 = 0;\n        goto LAB_001b2467;\n      }\n      if (iVar12 == 0x6f) {\n        pplVar5 = (long **)*param_1;\n        if (pplVar5 == (long **)0x0) {\n          list_minus_o_opts(0xffffffff,bVar13);\n          local_50 = sh_chkwrite(uVar8);\n        }\n        else if ((((char *)*pplVar5[1] == (char *)0x0) ||\n                 (cVar3 = *(char *)*pplVar5[1], (cVar3 - 0x2bU & 0xfd) == 0)) || (cVar3 == '\\0')) {\n          list_minus_o_opts(0xffffffff,bVar13);\n        }\n        else {\n          local_50 = set_minus_o_option(iVar9);\n          if (local_50 != 0) goto LAB_001b269a;\n          bVar7 = true;\n          param_1 = pplVar5;\n          local_50 = uVar8;\n        }\n      }\n      else {\n        iVar12 = change_flag(iVar12,iVar9);\n        if (iVar12 == -1) {\n          local_42 = (ushort)bVar2;\n          local_43 = cVar1;\n          sh_invalidopt(&local_43);\n          builtin_usage();\n          set_shellopts();\n          uVar10 = 1;\n          goto LAB_001b2467;\n        }\n        bVar7 = true;\n      }\n      bVar2 = pcVar4[2];\n      pcVar4 = pcVar4 + 1;\n      uVar8 = local_50;\n    }\n    param_1 = (long **)*param_1;\n    if (param_1 == (long **)0x0) break;\nLAB_001b257b:\n    pcVar4 = (char *)*param_1[1];\n    cVar1 = *pcVar4;\n    uVar8 = local_50;\n    if (cVar1 == '-') {\n      bVar2 = pcVar4[1];\n      if (bVar2 == 0) {\n        plVar6 = *param_1;\n        change_flag(0x78,0x2b);\n        change_flag(0x76,0x2b);\n        if (plVar6 != (long *)0x0) {\n          remember_args(plVar6,1);\n        }\n        goto LAB_001b269a;\n      }\n      iVar9 = 0x2d;\n      bVar13 = false;\n      if ((bVar2 == 0x2d) && (pcVar4[2] == '\\0')) {\n        param_1 = (long **)*param_1;\n        goto LAB_001b26e7;\n      }\n    }\n    else {\n      iVar9 = (int)cVar1;\n      if ((cVar1 == '\\0') || (bVar13 = iVar9 == 0x2b, (iVar9 - 0x2bU & 0xfffffffd) != 0)) {\nLAB_001b26e7:\n        remember_args(param_1,1);\n        break;\n      }\n      bVar2 = pcVar4[1];\n    }\n  }\n  uVar10 = (ulong)local_50;\n  if (bVar7) {\nLAB_001b269a:\n    set_shellopts();\n    uVar10 = (ulong)local_50;\n  }\nLAB_001b2467:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar10;\n  }\nLAB_001b2727:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_DT_INIT": "\nvoid _DT_INIT(void)\n\n{\n  if (PTR___gmon_start___00237f88 != (undefined *)0x0) {\n    (*(code *)PTR___gmon_start___00237f88)();\n  }\n  return;\n}\n\n",
  "iswupper": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswupper(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswupper_00237bb0)();\n  return iVar1;\n}\n\n",
  "strlist_remove": "\nulong strlist_remove(long *param_1)\n\n{\n  ulong uVar1;\n  \n  if (param_1 == (long *)0x0) {\n    return 0;\n  }\n  if (*param_1 != 0) {\n    uVar1 = (ulong)*(uint *)((long)param_1 + 0xc);\n    if (*(uint *)((long)param_1 + 0xc) != 0) {\n      uVar1 = strvec_remove();\n      if ((int)uVar1 != 0) {\n        *(int *)((long)param_1 + 0xc) = *(int *)((long)param_1 + 0xc) + -1;\n        return uVar1;\n      }\n    }\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "rl_vi_append_eol": "\nundefined8 rl_vi_append_eol(undefined8 param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  \n  rl_end_of_line(1);\n  if (rl_point < rl_end) {\n    sVar2 = __ctype_get_mb_cur_max();\n    iVar1 = rl_point;\n    if ((sVar2 == 1) || (rl_byte_oriented != 0)) {\n      rl_point = rl_point + 1;\n    }\n    else {\n      rl_point = _rl_forward_char_internal(1);\n      if ((rl_point == iVar1) || (rl_end < rl_point)) {\n        rl_point = rl_end;\n      }\n    }\n  }\n  DAT_0023b36c = 1;\n  DAT_0023b368 = rl_arg_sign;\n  _rl_vi_last_command = param_2;\n  rl_begin_undo_group();\n  DAT_0024a3c8 = param_2;\n  _rl_keymap = &vi_insertion_keymap;\n  if (_rl_show_mode_in_prompt == 0) {\n    return 0;\n  }\n  _rl_reset_prompt();\n  return 0;\n}\n\n",
  "__libc_start_main": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n",
  "array_walk": "\nvoid array_walk(long param_1,code *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  if (param_1 == 0) {\n    return;\n  }\n  if ((*(long *)(param_1 + 8) != 0) &&\n     (lVar2 = *(long *)(*(long *)(param_1 + 0x10) + 0x10), *(long *)(param_1 + 0x10) != lVar2)) {\n    do {\n      iVar1 = (*param_2)(lVar2,param_3);\n      if (iVar1 < 0) {\n        return;\n      }\n      lVar2 = *(long *)(lVar2 + 0x10);\n    } while (*(long *)(param_1 + 0x10) != lVar2);\n  }\n  return;\n}\n\n",
  "FUN_001e9370": "\nvoid FUN_001e9370(char *param_1,int param_2)\n\n{\n  char *__s;\n  size_t sVar1;\n  size_t sVar2;\n  char *__dest;\n  char *pcVar3;\n  long lVar4;\n  char **ppcVar5;\n  int iVar6;\n  \n  iVar6 = DAT_0024b154;\n  if (_rl_last_command_was_kill == 0) {\n    if (DAT_0024b160 != (char **)0x0) {\n      if (DAT_0024b154 == 10) {\n        iVar6 = 9;\n        xfree(*DAT_0024b160);\n        ppcVar5 = (char **)memmove(DAT_0024b160,DAT_0024b160 + 1,0x50);\n        lVar4 = 0x48;\n      }\n      else {\n        lVar4 = (long)(DAT_0024b154 + 2) * 8;\n        DAT_0024b154 = DAT_0024b154 + 1;\n        ppcVar5 = (char **)xrealloc(DAT_0024b160,lVar4);\n        lVar4 = lVar4 + -0x10;\n        DAT_0024b160 = ppcVar5;\n      }\n      ppcVar5 = (char **)(lVar4 + (long)ppcVar5);\n      *ppcVar5 = (char *)0x0;\n      goto LAB_001e947b;\n    }\n  }\n  else if (DAT_0024b160 != (char **)0x0) {\n    iVar6 = DAT_0024b154 + -1;\n    ppcVar5 = DAT_0024b160 + iVar6;\n    __s = *ppcVar5;\n    if ((__s != (char *)0x0) && (rl_editing_mode != 0)) {\n      sVar1 = strlen(__s);\n      sVar2 = strlen(param_1);\n      __dest = (char *)xmalloc(sVar1 + 1 + sVar2);\n      if (param_2 == 0) {\n        pcVar3 = stpcpy(__dest,param_1);\n        strcpy(pcVar3,__s);\n      }\n      else {\n        pcVar3 = stpcpy(__dest,__s);\n        strcpy(pcVar3,param_1);\n      }\n      xfree(__s);\n      xfree(param_1);\n      DAT_0024b160[iVar6] = __dest;\n      DAT_0024b158 = iVar6;\n      return;\n    }\n    goto LAB_001e947b;\n  }\n  iVar6 = 0;\n  DAT_0024b154 = 1;\n  ppcVar5 = (char **)xmalloc(0x10);\n  DAT_0024b160 = ppcVar5;\n  *ppcVar5 = (char *)0x0;\nLAB_001e947b:\n  *ppcVar5 = param_1;\n  DAT_0024b158 = iVar6;\n  return;\n}\n\n",
  "false_builtin": "\nundefined8 false_builtin(void)\n\n{\n  return 1;\n}\n\n",
  "run_interrupt_trap": "\nvoid run_interrupt_trap(int param_1)\n\n{\n  if ((param_1 != 0) && (0 < running_trap)) {\n    (&DAT_00247e40)[running_trap + -1] = (&DAT_00247e40)[running_trap + -1] & 0xffffffcf;\n  }\n  pending_traps._8_4_ = 0;\n  DAT_00247e28 = 0;\n  FUN_001811f0(2,\"interrupt trap\");\n  return;\n}\n\n",
  "rl_bracketed_paste_begin": "\nbool rl_bracketed_paste_begin(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  long local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar2 = _rl_bracketed_text(&local_28);\n  rl_mark = rl_point;\n  iVar1 = rl_insert_text(uVar2);\n  if (_rl_enable_active_region != 0) {\n    rl_activate_mark();\n  }\n  xfree(uVar2);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_28 != iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "reset_internal_getopt": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid reset_internal_getopt(void)\n\n{\n  loptend = 0;\n  lcurrent = 0;\n  _DAT_00248e10 = 0;\n  DAT_00248e18 = 1;\n  return;\n}\n\n",
  "sh_getopt_save_istate": "\nvoid sh_getopt_save_istate(void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  \n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"getopt.c\",0xe7);\n  uVar1 = sh_optarg;\n  *(undefined4 *)((long)puVar2 + 0x1c) = 0;\n  *puVar2 = uVar1;\n  *(undefined4 *)(puVar2 + 1) = sh_optind;\n  *(undefined4 *)((long)puVar2 + 0xc) = DAT_00248de0;\n  puVar2[2] = DAT_00248dd8;\n  *(undefined4 *)(puVar2 + 3) = DAT_00248dd0;\n  return;\n}\n\n",
  "connect": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint connect(int __fd,sockaddr *__addr,socklen_t __len)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_connect_00237e00)();\n  return iVar1;\n}\n\n",
  "sh_mbsnlen": "\nint sh_mbsnlen(long param_1,long param_2,int param_3)\n\n{\n  byte *__s;\n  byte bVar1;\n  mbstate_t mVar2;\n  size_t sVar3;\n  int iVar4;\n  int iVar5;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  iVar5 = 0;\n  iVar4 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  do {\n    mVar2 = local_48;\n    __s = (byte *)(param_1 + iVar4);\n    bVar1 = *__s;\n    if (bVar1 == 0) break;\n    iVar5 = iVar5 + 1;\n    if (locale_mb_cur_max < 2) {\nLAB_001cc7f5:\n      iVar4 = iVar4 + 1;\n    }\n    else {\n      if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n        if ((locale_utf8locale == 0) || (sVar3 = 1, (char)bVar1 < '\\0')) {\n          sVar3 = mbrtowc((wchar_t *)0x0,(char *)__s,param_2 - iVar4,&local_48);\n          if (0xfffffffffffffffd < sVar3) {\n            iVar4 = iVar4 + 1;\n            local_48 = mVar2;\n            goto LAB_001cc793;\n          }\n          if (sVar3 == 0) goto LAB_001cc7f5;\n        }\n      }\n      else {\n        sVar3 = 1;\n      }\n      iVar4 = iVar4 + (int)sVar3;\n    }\nLAB_001cc793:\n  } while (iVar4 <= param_3);\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001bfab0": "\nbyte * FUN_001bfab0(byte *param_1,byte *param_2,int param_3)\n\n{\n  bool bVar1;\n  byte bVar2;\n  uint uVar3;\n  byte *pbVar4;\n  uint uVar5;\n  byte bVar6;\n  byte *pbVar7;\n  \n  bVar2 = *param_1;\n  if (bVar2 == 0) {\n    return (byte *)0x0;\n  }\n  if (param_2 <= param_1) {\n    return param_1;\n  }\n  uVar5 = 0;\n  pbVar7 = (byte *)0x0;\n  bVar6 = 0;\n  uVar3 = 0;\n  bVar1 = false;\n  do {\n    pbVar4 = param_1 + 1;\n    if (bVar1) {\n      bVar2 = *pbVar4;\n      bVar1 = false;\njoined_r0x001bfb61:\n      if (bVar2 == 0) {\n        return (byte *)0x0;\n      }\n    }\n    else {\n      if (bVar2 == 0x5c) {\n        bVar2 = *pbVar4;\n        bVar1 = true;\n        goto joined_r0x001bfb61;\n      }\n      if (0x5c < bVar2) {\n        if (bVar2 == 0x5d) {\n          bVar2 = *pbVar4;\n          if (uVar3 != 0) {\n            if ((bVar6 == 0) || (param_1[-1] != bVar6)) {\n              if (pbVar7 != param_1) {\n                uVar3 = 0;\n                pbVar7 = (byte *)0x0;\n              }\n            }\n            else {\n              bVar6 = 0;\n            }\n          }\n        }\n        else {\n          if ((bVar2 != 0x7c) || ((uVar3 | uVar5) != 0)) goto LAB_001bfba0;\n          if (param_3 == 0x7c) {\n            return pbVar4;\n          }\n          bVar2 = *pbVar4;\n          uVar3 = 0;\n          uVar5 = 0;\n        }\n        goto joined_r0x001bfb61;\n      }\n      if (bVar2 == 0x29) {\n        if (uVar3 == 0) {\n          if ((int)uVar5 < 1) {\n            return pbVar4;\n          }\n          bVar2 = *pbVar4;\n          uVar5 = uVar5 - 1;\n        }\n        else {\nLAB_001bfba0:\n          bVar2 = *pbVar4;\n        }\n        goto joined_r0x001bfb61;\n      }\n      if (bVar2 != 0x5b) {\n        if (bVar2 != 0x28) goto LAB_001bfba0;\n        bVar2 = *pbVar4;\n        uVar5 = uVar5 + (uVar3 == 0);\n        goto joined_r0x001bfb61;\n      }\n      bVar2 = *pbVar4;\n      if (uVar3 == 0) {\n        if ((bVar2 == 0x21) || (uVar3 = 1, pbVar7 = pbVar4, bVar2 == 0x5e)) {\n          bVar1 = false;\n          uVar3 = 1;\n          pbVar7 = param_1 + 2;\n        }\n        goto joined_r0x001bfb61;\n      }\n      if (bVar2 < 0x3e) {\n        if ((-0x2400400000000001 >> (bVar2 & 0x3f) & 1U) == 0) {\n          bVar6 = bVar2;\n        }\n        goto joined_r0x001bfb61;\n      }\n    }\n    param_1 = pbVar4;\n    if (param_2 == pbVar4) {\n      return param_2;\n    }\n  } while( true );\n}\n\n",
  "fchmod": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fchmod(int __fd,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fchmod_00237cd8)();\n  return iVar1;\n}\n\n",
  "FUN_00165350": "\nvoid FUN_00165350(int param_1)\n\n{\n  long **pplVar1;\n  long lVar2;\n  long *plVar3;\n  long **pplVar4;\n  long *plVar5;\n  int iVar6;\n  int iVar7;\n  long *plVar8;\n  long *plVar9;\n  int iVar10;\n  long lVar11;\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_0023877c == 0) goto LAB_00165378;\n  sigemptyset(&sStack_128);\n  sigaddset(&sStack_128,0x11);\n  sigemptyset(&local_a8);\n  sigprocmask(0,&sStack_128,&local_a8);\n  iVar10 = interactive_shell;\n  if (param_1 == 0) {\n    if (DAT_0023877c < 1) {\n      if (-1 < js) goto LAB_00165510;\n      iVar10 = 0;\n      lVar11 = 0;\nLAB_001655d8:\n      set_maxchild(0);\n    }\n    else {\n      iVar10 = 0;\n      plVar9 = jobs + 1;\n      plVar5 = jobs;\n      while( true ) {\n        plVar3 = plVar9;\n        lVar11 = *plVar5;\n        if ((lVar11 != 0) && (*(int *)(lVar11 + 0x14) == 4)) {\n          iVar6 = 0;\n          plVar9 = *(long **)(lVar11 + 8);\n          do {\n            plVar9 = (long *)*plVar9;\n            iVar6 = iVar6 + 1;\n          } while (*(long **)(lVar11 + 8) != plVar9);\n          iVar10 = iVar10 + iVar6;\n        }\n        if (plVar3 == jobs + 1 + (DAT_0023877c - 1)) break;\n        plVar9 = plVar3 + 1;\n        plVar5 = plVar3;\n      }\n      lVar11 = (long)iVar10;\n      if (js < 0) goto LAB_001655d8;\n    }\n    iVar6 = interactive_shell;\n    lVar2 = js;\n    if ((js < lVar11) && (0 < DAT_0023877c)) {\n      plVar9 = jobs + (ulong)(DAT_0023877c - 1) + 1;\n      plVar5 = jobs;\n      do {\n        while ((lVar11 = *plVar5, lVar11 == 0 || (*(int *)(lVar11 + 0x14) != 4))) {\nLAB_00165490:\n          plVar5 = plVar5 + 1;\n          if (plVar5 == plVar9) goto LAB_00165510;\n        }\n        pplVar1 = *(long ***)(lVar11 + 8);\n        pplVar4 = pplVar1;\n        if (iVar6 == 0) {\n          do {\n            plVar3 = (long *)pplVar4;\n            if (plVar3 == (long *)0x0) {\n              do {\n                invalidInstructionException();\n              } while( true );\n            }\n            pplVar4 = (long **)(long *)*plVar3;\n          } while (pplVar1 != (long **)(long *)*plVar3);\n          if (last_asynchronous_pid != *(int *)(plVar3 + 1)) {\n            pplVar4 = (long **)*pplVar1;\n            iVar7 = 1;\n            goto joined_r0x001654e5;\n          }\n          goto LAB_00165490;\n        }\n        iVar7 = 0;\n        do {\n          pplVar4 = (long **)*pplVar4;\n          iVar7 = iVar7 + 1;\njoined_r0x001654e5:\n        } while (pplVar4 != pplVar1);\n        iVar10 = iVar10 - iVar7;\n        if (iVar10 <= lVar2) break;\n        plVar5 = plVar5 + 1;\n        *(uint *)(lVar11 + 0x18) = *(uint *)(lVar11 + 0x18) | 2;\n      } while (plVar5 != plVar9);\n    }\n  }\n  else if (0 < DAT_0023877c) {\n    plVar9 = jobs + (ulong)(DAT_0023877c - 1) + 1;\n    plVar5 = jobs;\n    do {\n      lVar11 = *plVar5;\n      if ((lVar11 != 0) && (*(int *)(lVar11 + 0x14) == 4)) {\n        if (iVar10 == 0) {\n          plVar3 = *(long **)(lVar11 + 8);\n          do {\n            plVar8 = plVar3;\n            if (plVar8 == (long *)0x0) {\n              do {\n                invalidInstructionException();\n              } while( true );\n            }\n            plVar3 = (long *)*plVar8;\n          } while (*(long **)(lVar11 + 8) != (long *)*plVar8);\n          if (last_asynchronous_pid == *(int *)(plVar8 + 1)) goto LAB_00165568;\n        }\n        *(uint *)(lVar11 + 0x18) = *(uint *)(lVar11 + 0x18) | 2;\n      }\nLAB_00165568:\n      plVar5 = plVar5 + 1;\n    } while (plVar9 != plVar5);\n  }\nLAB_00165510:\n  sigprocmask(2,&local_a8,(sigset_t *)0x0);\nLAB_00165378:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "find_variable_no_invisible": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid find_variable_no_invisible(undefined8 param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  \n  iVar2 = 2;\n  _DAT_002422f8 = 0;\n  if (expanding_redir == 0) {\n    iVar2 = 3 - (uint)((assigning_in_environment | executing_builtin) == 0);\n  }\n  lVar1 = FUN_00152c60(param_1,iVar2);\n  if ((lVar1 != 0) && ((*(byte *)(lVar1 + 0x29) & 8) != 0)) {\n    find_variable_nameref(lVar1);\n    return;\n  }\n  return;\n}\n\n",
  "rl_backward_menu_complete": "\nvoid rl_backward_menu_complete(int param_1)\n\n{\n  rl_menu_complete(-param_1);\n  return;\n}\n\n",
  "unwind_protect_tag_on_stack": "\nundefined8 unwind_protect_tag_on_stack(char *param_1)\n\n{\n  int iVar1;\n  long *plVar2;\n  \n  plVar2 = DAT_00248390;\n  if (DAT_00248390 != (long *)0x0) {\n    do {\n      if (((plVar2[1] == 0) && (*(char *)plVar2[2] == *param_1)) &&\n         (iVar1 = strcmp((char *)plVar2[2],param_1), iVar1 == 0)) {\n        return 1;\n      }\n      plVar2 = (long *)*plVar2;\n    } while (plVar2 != (long *)0x0);\n  }\n  return 0;\n}\n\n",
  "sv_optind": "\nvoid sv_optind(void)\n\n{\n  long lVar1;\n  char *__nptr;\n  ulong uVar2;\n  ulong uVar3;\n  \n  lVar1 = find_variable(\"OPTIND\");\n  if (((lVar1 != 0) && (__nptr = (char *)get_variable_value(lVar1), __nptr != (char *)0x0)) &&\n     (*__nptr != '\\0')) {\n    uVar2 = strtol(__nptr,(char **)0x0,10);\n    uVar3 = uVar2 & 0xffffffff;\n    if ((-1 < (int)uVar2) && ((int)uVar2 != 1)) goto LAB_00153e6d;\n  }\n  uVar3 = 0;\nLAB_00153e6d:\n  getopts_reset(uVar3);\n  return;\n}\n\n",
  "rl_history_substr_search_backward": "\nundefined8 rl_history_substr_search_backward(int param_1,undefined4 param_2)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  if ((rl_last_func != rl_history_substr_search_forward) &&\n     (rl_last_func != rl_history_substr_search_backward)) {\n    FUN_001d4840(0);\n  }\n  if (DAT_0024a46c != 0) {\n    iVar2 = -param_1;\n    if (0 < param_1) {\n      iVar2 = param_1;\n    }\n    uVar1 = FUN_001d4900(iVar2,((param_1 < 1) - 1) + (uint)(param_1 < 1));\n    return uVar1;\n  }\n  uVar1 = rl_get_previous_history(param_1,param_2);\n  return uVar1;\n}\n\n",
  "test_unop": "\nuint test_unop(char *param_1)\n\n{\n  uint uVar1;\n  byte bVar2;\n  \n  uVar1 = 0;\n  if ((((*param_1 == '-') && (param_1[1] != '\\0')) && (param_1[2] == '\\0')) &&\n     (bVar2 = param_1[1] + 0xb9, uVar1 = 0, bVar2 < 0x34)) {\n    uVar1 = (uint)(0xbfb93fc0019a1 >> (bVar2 & 0x3f)) & 1;\n  }\n  return uVar1;\n}\n\n",
  "execute_command": "\nundefined4 execute_command(undefined8 param_1)\n\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  undefined (*pauVar3) [16];\n  \n  current_fds_to_close = 0;\n  puVar2 = (undefined4 *)sh_xmalloc(0x10,\"execute_cmd.c\",0x147);\n  *puVar2 = 0x20;\n  pauVar3 = (undefined (*) [16])sh_xmalloc(0x20,\"execute_cmd.c\",0x14d);\n  *(undefined (**) [16])(puVar2 + 2) = pauVar3;\n  *pauVar3 = (undefined  [16])0x0;\n  pauVar3[1] = (undefined  [16])0x0;\n  begin_unwind_frame(\"execute-command\");\n  add_unwind_protect(dispose_fd_bitmap,puVar2);\n  uVar1 = execute_command_internal(param_1,0,0xffffffff,0xffffffff,puVar2);\n  if (*(long *)(puVar2 + 2) != 0) {\n    sh_xfree(*(long *)(puVar2 + 2),\"execute_cmd.c\",0x159);\n  }\n  sh_xfree(puVar2,\"execute_cmd.c\",0x15a);\n  discard_unwind_frame(\"execute-command\");\n  if ((variable_context | executing_list) == 0) {\n    unlink_fifo_list();\n  }\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n    return uVar1;\n  }\n  return uVar1;\n}\n\n",
  "set_directory_hook": "\nvoid set_directory_hook(void)\n\n{\n  if (dircomplete_expand != 0) {\n    rl_directory_completion_hook = FUN_00195b80;\n    rl_directory_rewrite_hook = (code *)0x0;\n    return;\n  }\n  rl_directory_rewrite_hook = FUN_00195b80;\n  rl_directory_completion_hook = (code *)0x0;\n  return;\n}\n\n",
  "FUN_001950b0": "\nvoid FUN_001950b0(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  uVar3 = rl_completion_entry_function;\n  uVar2 = rl_attempted_completion_function;\n  uVar1 = rl_ignore_some_completions_function;\n  rl_completion_entry_function = FUN_00192780;\n  rl_attempted_completion_function = 0;\n  rl_complete_internal(0x3f);\n  rl_completion_entry_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar2;\n  rl_ignore_some_completions_function = uVar1;\n  return;\n}\n\n",
  "memcpy": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memcpy_00237b70)();\n  return pvVar1;\n}\n\n",
  "printable_filename": "\nundefined8 printable_filename(undefined8 param_1,int param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = ansic_shouldquote();\n  if (iVar1 != 0) {\n    uVar2 = ansic_quote(param_1,0,0);\n    return uVar2;\n  }\n  if (param_2 != 0) {\n    iVar1 = sh_contains_shell_metas(param_1);\n    if (iVar1 != 0) {\n      uVar2 = sh_single_quote(param_1);\n      return uVar2;\n    }\n  }\n  return param_1;\n}\n\n",
  "rl_vi_bWord": "\nundefined8 rl_vi_bWord(int param_1)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  char cVar3;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  do {\n    if (rl_point < 1) {\n      return 0;\n    }\n    cVar3 = *(char *)(rl_line_buffer + rl_point);\n    if (cVar3 == ' ') goto LAB_001d0b5e;\n    if (cVar3 == '\\t') {\nLAB_001d0b50:\n      while( true ) {\n        if ((cVar3 != ' ') && (cVar3 != '\\t')) goto LAB_001d0b20;\nLAB_001d0b5e:\n        sVar2 = __ctype_get_mb_cur_max();\n        if ((sVar2 == 1) || (rl_byte_oriented != 0)) {\n          rl_point = rl_point + -1;\n        }\n        else {\n          rl_point = _rl_backward_char_internal(1);\n          if (rl_point < 0) goto LAB_001d0b87;\n        }\n        if (rl_point < 1) break;\n        cVar3 = *(char *)(rl_line_buffer + rl_point);\n      }\n    }\n    else {\n      pcVar1 = (char *)(rl_line_buffer + -1 + (long)rl_point);\n      cVar3 = *pcVar1;\n      if ((cVar3 == ' ') || (cVar3 == '\\t')) {\n        rl_point = rl_point + -1;\n        if (rl_point != 0) {\n          cVar3 = *pcVar1;\n          goto LAB_001d0b50;\n        }\n      }\n      else {\nLAB_001d0b20:\n        do {\n          if (rl_point < 1) {\nLAB_001d0b24:\n            if (rl_point != 0) {\nLAB_001d0b87:\n              rl_point = 0;\n            }\n            goto LAB_001d0b91;\n          }\n          sVar2 = __ctype_get_mb_cur_max();\n          if ((sVar2 == 1) || (rl_byte_oriented != 0)) {\n            rl_point = rl_point + -1;\n          }\n          else {\n            rl_point = _rl_backward_char_internal(1);\n            if (rl_point < 0) goto LAB_001d0b87;\n          }\n          if (rl_point < 1) goto LAB_001d0b24;\n        } while ((*(char *)(rl_line_buffer + rl_point) != ' ') &&\n                (*(char *)(rl_line_buffer + rl_point) != '\\t'));\n        rl_point = rl_point + 1;\n      }\n    }\nLAB_001d0b91:\n    param_1 = param_1 + -1;\n    if (param_1 == 0) {\n      return 0;\n    }\n  } while( true );\n}\n\n",
  "bash_dequote_text": "\nvoid bash_dequote_text(char *param_1)\n\n{\n  char cVar1;\n  \n  cVar1 = *param_1;\n  if ((cVar1 != '\\\"') && (cVar1 != '\\'')) {\n    cVar1 = cVar1 == '\\\"';\n  }\n  FUN_00191560(param_1,(int)cVar1);\n  return;\n}\n\n",
  "FUN_00160ba0": "\nlong ** FUN_00160ba0(int param_1,int param_2,int *param_3)\n\n{\n  long **pplVar1;\n  long **pplVar2;\n  int iVar3;\n  long **pplVar4;\n  long in_FS_OFFSET;\n  long **local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = (long **)0x0;\n  if (param_3 != (int *)0x0) {\n    *param_3 = -1;\n  }\n  pplVar4 = the_pipeline;\n  pplVar2 = DAT_00247668;\n  if (the_pipeline != (long **)0x0) {\n    do {\n      if ((param_1 == *(int *)(pplVar4 + 1)) &&\n         (((param_2 == 0 || (*(int *)(pplVar4 + 2) == 1)) ||\n          (*(char *)((long)pplVar4 + 0xc) == '\\x7f')))) goto LAB_00160c10;\n      pplVar4 = (long **)*pplVar4;\n    } while (the_pipeline != pplVar4);\n  }\n  for (; pplVar2 != (long **)0x0; pplVar2 = (long **)pplVar2[1]) {\n    pplVar1 = (long **)*pplVar2;\n    pplVar4 = pplVar1;\n    if (pplVar1 != (long **)0x0) {\n      do {\n        while (param_1 == *(int *)(pplVar4 + 1)) {\n          if (((param_2 == 0) || (*(int *)(pplVar4 + 2) == 1)) ||\n             (*(char *)((long)pplVar4 + 0xc) == '\\x7f')) goto LAB_00160c10;\n          pplVar4 = (long **)*pplVar4;\n          if (pplVar1 == pplVar4) goto LAB_00160c80;\n        }\n        pplVar4 = (long **)*pplVar4;\n      } while (pplVar1 != pplVar4);\n    }\nLAB_00160c80:\n  }\n  if (((DAT_00242520 < 1) ||\n      (pplVar4 = (long **)procsub_search(param_1), local_28 = pplVar4, pplVar4 == (long **)0x0)) ||\n     ((param_2 != 0 && ((*(int *)(pplVar4 + 2) != 1 && (*(char *)((long)pplVar4 + 0xc) != '\\x7f'))))\n     )) {\n    iVar3 = FUN_0015e6b0(param_1,param_2,&local_28);\n    if (param_3 != (int *)0x0) {\n      *param_3 = iVar3;\n    }\n    if (iVar3 == -1) {\n      pplVar4 = (long **)0x0;\n    }\n    else {\n      pplVar4 = *(long ***)(*(long *)(jobs + (long)iVar3 * 8) + 8);\n    }\n  }\nLAB_00160c10:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pplVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "builtin_builtin": "\nundefined8 builtin_builtin(void)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  uVar2 = no_options();\n  puVar1 = loptend;\n  if ((int)uVar2 == 0) {\n    if (loptend != (undefined8 *)0x0) {\n      uVar2 = *(undefined8 *)loptend[1];\n      UNRECOVERED_JUMPTABLE = (code *)find_shell_builtin(uVar2);\n      if (UNRECOVERED_JUMPTABLE != (code *)0x0) {\n        this_command_name = uVar2;\n        this_shell_builtin = UNRECOVERED_JUMPTABLE;\n                    /* WARNING: Could not recover jumptable at 0x001a298a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        uVar2 = (*UNRECOVERED_JUMPTABLE)(*puVar1);\n        return uVar2;\n      }\n      sh_notbuiltin(uVar2);\n      uVar2 = 1;\n    }\n  }\n  else {\n    uVar2 = 0x102;\n  }\n  return uVar2;\n}\n\n",
  "FUN_00168430": "\nulong FUN_00168430(undefined8 param_1,undefined8 param_2,int param_3,undefined8 *param_4,\n                  undefined8 *param_5)\n\n{\n  undefined4 uVar1;\n  wchar_t *pwVar2;\n  undefined8 *puVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  wchar_t wVar7;\n  uint uVar8;\n  int iVar9;\n  wchar_t __wc;\n  size_t sVar10;\n  long lVar11;\n  ulong uVar12;\n  wchar_t *pwVar13;\n  wchar_t *pwVar14;\n  wchar_t *pwVar15;\n  wchar_t *pwVar16;\n  ulong uVar17;\n  undefined4 *puVar18;\n  ulong uVar19;\n  long lVar20;\n  ulong uVar21;\n  long in_FS_OFFSET;\n  bool bVar22;\n  uint local_90;\n  long local_58;\n  wchar_t *local_50;\n  undefined8 *local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar10 = __ctype_get_mb_cur_max();\n  if ((sVar10 < 2) ||\n     ((lVar11 = mbsmbchar(param_1), lVar11 == 0 && (lVar11 = mbsmbchar(param_2), lVar11 == 0)))) {\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar12 = FUN_00166b00(param_1,param_2,param_3,param_4,param_5);\n      return uVar12;\n    }\n    goto LAB_00168b8f;\n  }\n  lVar11 = xdupmbstowcs(&local_50,0,param_2);\n  if (lVar11 == -1) {\nLAB_001687a6:\n    uVar8 = FUN_00166b00(param_1,param_2,param_3,param_4,param_5);\n    uVar21 = (ulong)uVar8;\n  }\n  else {\n    uVar12 = xdupmbstowcs(&local_58,&local_48,param_1);\n    puVar3 = local_48;\n    pwVar2 = local_50;\n    lVar11 = local_58;\n    iVar4 = extended_glob;\n    if (uVar12 == 0xffffffffffffffff) {\n      sh_xfree(local_50,\"subst.c\",0x1630);\n      goto LAB_001687a6;\n    }\n    local_90 = 1;\n    wVar7 = *local_50;\n    if ((uint)(wVar7 + L'\\xffffffd6') < 0x33) {\n      local_90 = (uint)(-0x6000000200002 >> ((byte)(wVar7 + L'\\xffffffd6') & 0x3f)) & 1;\n    }\n    sVar10 = wcslen(local_50);\n    uVar8 = local_90;\n    if ((iVar4 == 0) || (pwVar2[1] != L'(')) {\n      if ((wVar7 != L'*') || (pwVar2[sVar10 - 1] != L'*')) goto LAB_00168550;\n      iVar4 = wcsmatch(pwVar2,lVar11,(uint)(match_ignore_case != 0) << 4 | (uint)(iVar4 != 0) << 5);\n    }\n    else {\n      if ((wVar7 == L'*') || (wVar7 == L'?')) {\n        local_90 = 0;\n        uVar8 = local_90;\n      }\n      else if (((uint)(wVar7 + L'\\xffffffdf') < 0x20) &&\n              (uVar8 = 0, (0x80000401UL >> ((byte)(wVar7 + L'\\xffffffdf') & 0x3f) & 1) == 0)) {\n        uVar8 = local_90;\n      }\nLAB_00168550:\n      local_90 = uVar8;\n      pwVar13 = (wchar_t *)sh_xmalloc(sVar10 * 4 + 0xc,\"subst.c\",0x15a3);\n      pwVar14 = pwVar2;\n      pwVar16 = pwVar13;\n      if ((*pwVar2 != L'*') || ((wVar7 = L'*', pwVar2[1] == L'(' && (extended_glob != 0)))) {\n        *pwVar13 = L'*';\n        wVar7 = *pwVar2;\n        goto joined_r0x00168589;\n      }\n      do {\n        pwVar14 = pwVar14 + 1;\n        *pwVar16 = wVar7;\n        wVar7 = *pwVar14;\njoined_r0x00168589:\n        pwVar16 = pwVar16 + 1;\n      } while (wVar7 != L'\\0');\n      if (pwVar14[-1] == L'*') {\n        if (pwVar14[-2] == L'\\\\') {\n          iVar4 = 1;\n          pwVar15 = pwVar14 + -3;\n          if (pwVar2 <= pwVar14 + -3) {\n            do {\n              pwVar14 = pwVar15 + -1;\n              if (*pwVar15 != L'\\\\') break;\n              iVar4 = 1 - iVar4;\n              pwVar15 = pwVar14;\n            } while (pwVar2 <= pwVar14);\n            if (iVar4 == 0) goto LAB_001685bc;\n          }\n          goto LAB_001685b2;\n        }\n      }\n      else {\nLAB_001685b2:\n        *pwVar16 = L'*';\n        pwVar16 = pwVar16 + 1;\n      }\nLAB_001685bc:\n      *pwVar16 = L'\\0';\n      iVar4 = wcsmatch(pwVar13,lVar11,\n                       (uint)(extended_glob != 0) << 5 | (uint)(match_ignore_case != 0) << 4);\n      if (pwVar2 != pwVar13) {\n        sh_xfree(pwVar13,\"subst.c\",0x15bf);\n      }\n    }\n    if (iVar4 == 1) {\nLAB_00168730:\n      uVar21 = 0;\n    }\n    else {\n      iVar5 = wmatchlen(pwVar2,uVar12);\n      iVar4 = (int)uVar12;\n      if (iVar4 < iVar5) goto LAB_00168730;\n      if (param_3 == 1) {\n        iVar6 = match_pattern_wchar(pwVar2,lVar11,(ulong)(match_ignore_case != 0) << 4);\n        if (iVar6 != 0) {\n          if (iVar5 != -1) {\n            iVar4 = iVar5;\n          }\n          lVar20 = (long)iVar4;\n          puVar18 = (undefined4 *)(lVar11 + lVar20 * 4);\n          if (-1 < iVar4) {\n            do {\n              uVar1 = *puVar18;\n              *puVar18 = 0;\n              iVar4 = wcsmatch(pwVar2,lVar11,\n                               (uint)(match_ignore_case != 0) << 4 | (uint)(extended_glob != 0) << 5\n                              );\n              if (iVar4 == 0) {\n                *puVar18 = uVar1;\n                uVar21 = 1;\n                *param_4 = *puVar3;\n                *param_5 = puVar3[lVar20];\n                goto LAB_00168733;\n              }\n              *puVar18 = uVar1;\n              if (iVar5 != -1) break;\n              lVar20 = lVar20 + -1;\n              puVar18 = puVar18 + -1;\n            } while ((int)lVar20 != -1);\n          }\n        }\n        goto LAB_00168730;\n      }\n      if (param_3 == 2) {\n        if (iVar5 == -1) {\n          uVar17 = 0;\n        }\n        else {\n          uVar17 = (long)(iVar4 - iVar5);\n          if (uVar12 < (ulong)(long)(iVar4 - iVar5)) goto LAB_00168730;\n        }\n        do {\n          uVar21 = uVar17 + 1;\n          iVar4 = wcsmatch(pwVar2,lVar11 + uVar17 * 4,\n                           (uint)(extended_glob != 0) << 5 | (uint)(match_ignore_case != 0) << 4);\n          if (iVar4 == 0) {\n            uVar21 = 1;\n            *param_4 = puVar3[uVar17];\n            *param_5 = puVar3[uVar12];\n            goto LAB_00168733;\n          }\n        } while ((iVar5 == -1) && (uVar17 = uVar21, uVar21 <= uVar12));\n        goto LAB_00168730;\n      }\n      uVar21 = 0;\n      if (param_3 == 0) {\n        uVar17 = 0;\n        do {\n          lVar20 = lVar11 + uVar17 * 4;\n          if (local_90 == 0) {\n            iVar6 = match_pattern_wchar(pwVar2,lVar20,(ulong)(match_ignore_case != 0) << 4);\n            if (iVar6 != 0) goto LAB_0016883d;\n          }\n          else {\n            wVar7 = *pwVar2;\n            if (match_ignore_case == 0) {\n              __wc = *(wchar_t *)(lVar11 + uVar17 * 4);\n            }\n            else {\n              iVar6 = iswupper(wVar7);\n              if (iVar6 != 0) {\n                wVar7 = towlower(wVar7);\n              }\n              __wc = *(wchar_t *)(lVar11 + uVar17 * 4);\n              iVar6 = iswupper(__wc);\n              if (iVar6 != 0) {\n                __wc = towlower(__wc);\n              }\n            }\n            if (__wc == wVar7) {\nLAB_0016883d:\n              iVar6 = (int)uVar17;\n              iVar9 = iVar5 + iVar6;\n              if (iVar5 == -1) {\n                iVar9 = iVar4;\n              }\n              uVar19 = (ulong)iVar9;\n              if (uVar12 < uVar19) break;\n              if (iVar6 <= iVar9) {\n                puVar18 = (undefined4 *)(lVar11 + uVar19 * 4);\n                do {\n                  uVar1 = *puVar18;\n                  *puVar18 = 0;\n                  iVar9 = wcsmatch(pwVar2,lVar20,\n                                   (uint)(extended_glob != 0) << 5 |\n                                   (uint)(match_ignore_case != 0) << 4);\n                  if (iVar9 == 0) {\n                    *puVar18 = uVar1;\n                    uVar21 = 1;\n                    *param_4 = puVar3[uVar17];\n                    *param_5 = puVar3[uVar19];\n                    goto LAB_00168733;\n                  }\n                  *puVar18 = uVar1;\n                  if (iVar5 != -1) break;\n                  uVar19 = uVar19 - 1;\n                  puVar18 = puVar18 + -1;\n                } while (iVar6 <= (int)uVar19);\n              }\n            }\n          }\n          bVar22 = uVar12 != uVar17;\n          uVar17 = uVar17 + 1;\n        } while (bVar22);\n        goto LAB_00168730;\n      }\n    }\nLAB_00168733:\n    sh_xfree(local_50,\"subst.c\",0x1635);\n    sh_xfree(local_58,\"subst.c\",0x1636);\n    sh_xfree(local_48,\"subst.c\",0x1637);\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar21;\n  }\nLAB_00168b8f:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_arrow_keys": "\nundefined4 rl_arrow_keys(undefined4 param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  ushort **ppuVar4;\n  size_t sVar5;\n  __int32_t **pp_Var6;\n  bool bVar7;\n  \n  rl_readline_state = rl_readline_state | 0x40;\n  iVar2 = rl_read_key();\n  rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n  if (iVar2 < 0) {\n    return 1;\n  }\n  ppuVar4 = __ctype_b_loc();\n  if ((*(byte *)((long)*ppuVar4 + (ulong)(byte)iVar2 * 2 + 1) & 2) == 0) {\n    iVar1 = iVar2 + -0x43;\n    bVar7 = iVar2 == 0x43;\n    iVar3 = iVar2;\n    if (bVar7) {\nLAB_001ef4a5:\n      sVar5 = __ctype_get_mb_cur_max();\n      if ((1 < sVar5) && (rl_byte_oriented == 0)) {\n        rl_forward_char(param_1,iVar2);\n        return 0;\n      }\n      rl_forward_byte();\n      return 0;\n    }\n  }\n  else {\n    pp_Var6 = __ctype_toupper_loc();\n    iVar3 = (*pp_Var6)[(byte)iVar2];\n    iVar1 = iVar3 + -0x43;\n    bVar7 = iVar1 == 0;\n    if (bVar7) goto LAB_001ef4a5;\n  }\n  if (bVar7 || SBORROW4(iVar3,0x43) != iVar1 < 0) {\n    if (iVar3 == 0x41) {\n      rl_get_previous_history(param_1,iVar2);\n      return 0;\n    }\n    if (iVar3 != 0x42) {\nLAB_001ef4f0:\n      rl_ding();\n      return 0;\n    }\n    rl_get_next_history(param_1,iVar2);\n  }\n  else {\n    if (iVar3 != 0x44) goto LAB_001ef4f0;\n    sVar5 = __ctype_get_mb_cur_max();\n    if ((sVar5 < 2) || (rl_byte_oriented != 0)) {\n      rl_backward_byte();\n      return 0;\n    }\n    rl_backward_char(param_1,iVar2);\n  }\n  return 0;\n}\n\n",
  "set_ppid": "\nvoid set_ppid(void)\n\n{\n  __pid_t _Var1;\n  undefined8 uVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  undefined local_2c [12];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  _Var1 = getppid();\n  uVar2 = inttostr((long)_Var1,local_2c,0xc);\n  lVar3 = find_variable(&DAT_001fcedd);\n  if (lVar3 != 0) {\n    *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) & 0xfffffffc;\n  }\n  lVar3 = bind_variable(&DAT_001fcedd,uVar2,0);\n  *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | 0x12;\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001dcb10": "\nundefined8 FUN_001dcb10(char *param_1)\n\n{\n  bool bVar1;\n  uint uVar2;\n  int iVar3;\n  size_t sVar4;\n  char *pcVar5;\n  int iVar6;\n  char cVar7;\n  long lVar8;\n  char *pcVar9;\n  ulong uVar10;\n  undefined **ppuVar11;\n  int iVar12;\n  char *pcVar13;\n  long lVar14;\n  char *pcVar15;\n  int unaff_R12D;\n  char *pcVar16;\n  ulong unaff_R13;\n  long in_FS_OFFSET;\n  bool bVar17;\n  bool bVar18;\n  char cVar19;\n  int local_50;\n  char local_4c;\n  int local_44;\n  long local_40;\n  \n  lVar8 = (long)DAT_0024a794;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar12 = DAT_0024a794 + 1;\n  if (DAT_0024a790 <= iVar12) {\n    if (DAT_0024a798 == 0) {\n      DAT_0024a790 = 0x14;\n      DAT_0024a798 = xmalloc(0x14);\n      lVar8 = (long)DAT_0024a794;\n      iVar12 = DAT_0024a794 + 1;\n    }\n    else {\n      DAT_0024a790 = DAT_0024a790 + 0x14;\n      DAT_0024a798 = xrealloc(DAT_0024a798,(long)DAT_0024a790);\n      lVar8 = (long)DAT_0024a794;\n      iVar12 = DAT_0024a794 + 1;\n    }\n  }\n  DAT_0024a794 = iVar12;\n  *(char *)(DAT_0024a798 + lVar8) = _rl_parsing_conditionalized_out;\n  cVar19 = _rl_parsing_conditionalized_out;\n  if (_rl_parsing_conditionalized_out == '\\0') {\n    sVar4 = strlen(param_1);\n    local_44 = 0;\n    cVar7 = *param_1;\n    pcVar9 = param_1;\n    while (pcVar15 = rl_terminal_name, cVar7 != '\\0') {\n      local_44 = (1 - (int)param_1) + (int)pcVar9;\n      if ((cVar7 == ' ') || (cVar7 == '\\t')) {\n        *pcVar9 = '\\0';\n        pcVar15 = rl_terminal_name;\n        break;\n      }\n      pcVar15 = pcVar9 + 1;\n      pcVar9 = pcVar9 + 1;\n      cVar7 = *pcVar15;\n    }\n    rl_terminal_name = pcVar15;\n    if ((pcVar15 == (char *)0x0) || (iVar12 = strncasecmp(param_1,\"term=\",5), iVar12 != 0)) {\n      iVar12 = strncasecmp(param_1,\"mode=\",5);\n      if (iVar12 == 0) {\n        iVar12 = strcasecmp(param_1 + 5,\"emacs\");\n        if (iVar12 == 0) {\n          _rl_parsing_conditionalized_out = rl_editing_mode != 1;\n        }\n        else {\n          iVar12 = strcasecmp(param_1 + 5,\"vi\");\n          _rl_parsing_conditionalized_out = rl_editing_mode + (uint)(iVar12 != 0) != 0;\n        }\n      }\n      else {\n        uVar2 = strncasecmp(param_1,\"version\",7);\n        uVar10 = (ulong)uVar2;\n        iVar12 = (int)sVar4;\n        if (uVar2 == 0) {\n          _rl_parsing_conditionalized_out = '\\x01';\n          if (((0 < local_44) && (local_44 <= iVar12)) && (param_1[(long)local_44 + -1] == '\\0')) {\n            param_1[(long)local_44 + -1] = ' ';\n          }\n          local_44 = 7;\n          param_1[iVar12] = '\\0';\n          cVar19 = param_1[7];\n          if ((cVar19 == '\\t') || (pcVar9 = param_1 + 7, cVar19 == ' ')) {\n            pcVar15 = param_1 + 8;\n            do {\n              do {\n                pcVar9 = pcVar15;\n                cVar19 = *pcVar9;\n                local_44 = (int)pcVar9 - (int)param_1;\n                pcVar15 = pcVar9 + 1;\n              } while (cVar19 == ' ');\n            } while (cVar19 == '\\t');\n          }\n          if (((byte)(cVar19 - 0x3cU) < 3) || (cVar19 == '!')) {\n            iVar12 = FUN_001da280(param_1,&local_44);\n            uVar2 = (uint)uVar10;\n            if (iVar12 < 1) {\n              FUN_001da6e0(\"comparison operator expected, found `%s\\'\",pcVar9);\n            }\n            else {\n              pcVar9 = param_1 + local_44;\n              cVar19 = *pcVar9;\n              if (cVar19 != '\\0') {\n                pcVar15 = param_1 + (long)local_44 + 1;\n                iVar6 = (int)pcVar9;\n                lVar8 = (long)pcVar15 - (long)pcVar9;\n                bVar17 = false;\nLAB_001dcd87:\n                bVar1 = cVar19 == ' ' || cVar19 == '\\t';\n                if (bVar1) goto LAB_001dcd70;\n                if (bVar17) {\n                  local_44 = unaff_R12D;\n                }\n                if (9 < (byte)(cVar19 - 0x30U)) goto LAB_001dd2de;\n                iVar6 = 0;\n                cVar19 = param_1[local_44];\n                lVar8 = (long)local_44;\n                lVar14 = (long)(local_44 + 1);\n                iVar3 = local_44;\n                while ((byte)(cVar19 - 0x30U) < 10) {\n                  iVar3 = (int)lVar14;\n                  iVar6 = (int)(char)(cVar19 + -0x30) + iVar6 * 10;\n                  cVar19 = param_1[lVar14];\n                  lVar8 = lVar14;\n                  lVar14 = lVar14 + 1;\n                }\n                local_44 = iVar3;\n                if (cVar19 == '.') {\n                  if (((byte)(param_1[lVar8 + 1] - 0x30U) < 10) || (param_1[lVar8 + 1] == '\\0')) {\n                    local_44 = iVar3 + 1;\n                    pcVar9 = param_1 + local_44;\n                    cVar19 = *pcVar9;\n                    if ((byte)(cVar19 - 0x30U) < 10) {\n                      lVar8 = (long)(iVar3 + 2);\n                      do {\n                        pcVar9 = param_1 + lVar8;\n                        uVar2 = (int)(char)(cVar19 + -0x30) + (int)uVar10 * 10;\n                        uVar10 = (ulong)uVar2;\n                        cVar19 = param_1[lVar8];\n                        local_44 = (int)lVar8;\n                        lVar8 = lVar8 + 1;\n                      } while ((byte)(cVar19 - 0x30U) < 10);\n                    }\n                    goto LAB_001dce13;\n                  }\n                  goto LAB_001dd2de;\n                }\n                pcVar9 = param_1 + iVar3;\n                cVar19 = *pcVar9;\nLAB_001dce13:\n                if (cVar19 != '\\0') {\n                  uVar10 = (long)(local_44 + 1);\n                  do {\n                    bVar17 = cVar19 == ' ';\n                    bVar18 = cVar19 == '\\t';\n                    if (!bVar17 && !bVar18) {\n                      if (bVar1) {\n                        local_44 = (int)unaff_R13;\n                      }\n                      if (cVar19 != '#') {\n                        FUN_001da6e0(\"trailing garbage on line: `%s\\'\",pcVar9);\n                        goto LAB_001dcc60;\n                      }\n                      break;\n                    }\n                    unaff_R13 = uVar10 & 0xffffffff;\n                    cVar19 = param_1[uVar10];\n                    uVar10 = uVar10 + 1;\n                    bVar1 = bVar17 || bVar18;\n                  } while (cVar19 != '\\0');\n                }\n                iVar6 = uVar2 + iVar6 * 10;\n                switch(iVar12) {\n                case 1:\n                  local_4c = iVar6 == 0x52;\n                  break;\n                case 2:\n                  local_4c = iVar6 != 0x52;\n                  break;\n                case 3:\n                  local_4c = iVar6 < 0x52;\n                  break;\n                case 4:\n                  local_4c = iVar6 < 0x53;\n                  break;\n                case 5:\n                  local_4c = 0x52 < iVar6;\n                  break;\n                case 6:\n                  local_4c = 0x51 < iVar6;\n                }\n                _rl_parsing_conditionalized_out = '\\x01' - local_4c;\n                goto LAB_001dcc60;\n              }\nLAB_001dd2de:\n              FUN_001da6e0(\"numeric argument expected, found `%s\\'\",pcVar9);\n            }\n          }\n          else {\n            if (cVar19 == '\\0') {\n              pcVar9 = \"end-of-line\";\n            }\n            FUN_001da6e0(\"comparison operator expected, found `%s\\'\",pcVar9);\n          }\n        }\n        else {\n          iVar6 = strcasecmp(param_1,rl_readline_name);\n          if (iVar6 != 0) {\n            ppuVar11 = &PTR_s_blink_matching_paren_002372b8;\n            iVar6 = 0;\n            pcVar9 = \"bind-tty-special-chars\";\n            do {\n              iVar3 = strcasecmp(param_1,pcVar9);\n              if (iVar3 == 0) {\n                pcVar9 = (&PTR_s_bind_tty_special_chars_002372a0)[(long)iVar6 * 3];\n                goto LAB_001dcfe2;\n              }\n              pcVar9 = *ppuVar11;\n              ppuVar11 = ppuVar11 + 3;\n              iVar6 = iVar6 + 1;\n            } while (pcVar9 != (char *)0x0);\n            ppuVar11 = &PTR_s_active_region_start_color_00235858;\n            iVar6 = 0;\n            pcVar9 = \"active-region-end-color\";\n            while (iVar3 = strcasecmp(param_1,pcVar9), iVar3 != 0) {\n              pcVar9 = *ppuVar11;\n              ppuVar11 = ppuVar11 + 3;\n              iVar6 = iVar6 + 1;\n              if (pcVar9 == (char *)0x0) goto LAB_001dd336;\n            }\n            pcVar9 = (&PTR_s_active_region_end_color_00235840)[(long)iVar6 * 3];\nLAB_001dcfe2:\n            _rl_parsing_conditionalized_out = '\\x01';\n            sVar4 = strlen(pcVar9);\n            if (((0 < local_44) && (local_44 <= iVar12)) && (param_1[(long)local_44 + -1] == '\\0'))\n            {\n              param_1[(long)local_44 + -1] = ' ';\n            }\n            local_44 = (int)sVar4;\n            pcVar15 = param_1 + local_44;\n            param_1[iVar12] = '\\0';\n            cVar19 = *pcVar15;\n            if ((cVar19 == ' ') || (cVar19 == '\\t')) {\n              lVar8 = (long)local_44;\n              iVar12 = local_44 + 1;\n              pcVar16 = param_1 + lVar8 + 1;\n              do {\n                do {\n                  pcVar15 = pcVar16;\n                  cVar19 = *pcVar15;\n                  local_44 = (iVar12 - (int)(param_1 + lVar8 + 1)) + (int)pcVar15;\n                  pcVar16 = pcVar15 + 1;\n                } while (cVar19 == ' ');\n              } while (cVar19 == '\\t');\n            }\n            if ((cVar19 != '=') && (cVar19 != '!')) {\n              if (cVar19 == '\\0') {\n                pcVar15 = \"end-of-line\";\n              }\n              FUN_001da6e0(\"equality comparison operator expected, found `%s\\'\",pcVar15);\n              goto LAB_001dcc60;\n            }\n            iVar12 = FUN_001da280(param_1,&local_44);\n            if (1 < iVar12 - 1U) {\n              FUN_001da6e0(\"equality comparison operator expected, found `%s\\'\",pcVar15);\n              goto LAB_001dcc60;\n            }\n            lVar8 = (long)local_44;\n            pcVar15 = param_1 + lVar8;\n            cVar19 = *pcVar15;\n            pcVar16 = pcVar15;\n            if (cVar19 != '\\0') {\n              pcVar13 = param_1 + lVar8 + 1;\n              lVar14 = (long)pcVar13 - (long)pcVar15;\n              cVar7 = cVar19;\n              bVar17 = false;\n              do {\n                bVar1 = cVar7 == ' ';\n                bVar18 = cVar7 == '\\t';\n                if (!bVar1 && !bVar18) {\n                  if (bVar17) {\n                    lVar8 = (long)local_50;\n                    pcVar15 = param_1 + lVar8;\n                    local_44 = local_50;\n                    cVar19 = *pcVar15;\n                    if (cVar19 != '\\0') goto LAB_001dd281;\n                    goto LAB_001dd2a8;\n                  }\nLAB_001dd281:\n                  pcVar13 = param_1 + lVar8 + 1;\n                  goto LAB_001dd290;\n                }\n                cVar7 = *pcVar13;\n                local_50 = ((local_44 + 1) - (int)pcVar15) + (int)pcVar16;\n                pcVar13 = pcVar13 + 1;\n                pcVar16 = pcVar16 + lVar14;\n                bVar17 = bVar1 || bVar18;\n              } while (cVar7 != '\\0');\n            }\n            FUN_001da6e0(\"argument expected, found `%s\\'\",pcVar16);\n            goto LAB_001dcc60;\n          }\n          _rl_parsing_conditionalized_out = '\\0';\n        }\n      }\n    }\n    else {\n      sVar4 = strlen(pcVar15);\n      pcVar9 = (char *)xmalloc(sVar4 + 1);\n      pcVar9 = strcpy(pcVar9,pcVar15);\n      pcVar15 = strchr(pcVar9,0x2d);\n      if (pcVar15 != (char *)0x0) {\n        *pcVar15 = '\\0';\n      }\n      iVar12 = strcasecmp(param_1 + 5,pcVar9);\n      if (iVar12 != 0) {\n        iVar12 = strcasecmp(param_1 + 5,rl_terminal_name);\n        cVar19 = iVar12 != 0;\n      }\n      _rl_parsing_conditionalized_out = cVar19;\n      xfree(pcVar9);\n    }\n  }\nLAB_001dcc60:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\nLAB_001dd336:\n  _rl_parsing_conditionalized_out = '\\x01';\n  goto LAB_001dcc60;\n  while( true ) {\n    cVar19 = *pcVar5;\n    pcVar13 = pcVar5 + 1;\n    pcVar15 = pcVar5;\n    if (cVar19 == '\\0') break;\nLAB_001dd290:\n    pcVar5 = pcVar13;\n    if ((cVar19 == ' ') || (cVar19 == '\\t')) break;\n  }\nLAB_001dd2a8:\n  *pcVar15 = '\\0';\n  pcVar9 = (char *)rl_variable_value(pcVar9);\n  if (iVar12 == 1) {\n    iVar12 = strcasecmp(pcVar9,pcVar16);\n    _rl_parsing_conditionalized_out = iVar12 != 0;\n  }\n  else {\n    iVar12 = strcasecmp(pcVar9,pcVar16);\n    _rl_parsing_conditionalized_out = iVar12 == 0;\n  }\n  *pcVar15 = cVar19;\n  goto LAB_001dcc60;\nLAB_001dcd70:\n  cVar19 = *pcVar15;\n  unaff_R12D = ((local_44 + 1) - iVar6) + (int)pcVar9;\n  pcVar15 = pcVar15 + 1;\n  pcVar9 = pcVar9 + lVar8;\n  bVar17 = bVar1;\n  if (cVar19 == '\\0') goto LAB_001dd2de;\n  goto LAB_001dcd87;\n}\n\n",
  "gai_strerror": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * gai_strerror(int __ecode)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_gai_strerror_00237a28)();\n  return pcVar1;\n}\n\n",
  "check_binary_file": "\nbool check_binary_file(char *param_1,int param_2)\n\n{\n  void *pvVar1;\n  long lVar2;\n  char cVar3;\n  \n  cVar3 = *param_1;\n  if (param_2 < 4) {\n    if ((cVar3 == '#') && (param_1[1] == '!')) {\nLAB_00141e3e:\n      pvVar1 = memchr(param_1,0,(long)param_2);\n      return pvVar1 != (void *)0x0;\n    }\n    lVar2 = 0;\n    if (param_2 < 1) {\n      return false;\n    }\n  }\n  else {\n    lVar2 = 0;\n    if (cVar3 == '\\x7f') {\n      if (((param_1[1] == 'E') && (lVar2 = 0, param_1[2] == 'L')) && (param_1[3] == 'F')) {\n        return true;\n      }\n    }\n    else if ((cVar3 == '#') && (param_1[1] == '!')) goto LAB_00141e3e;\n  }\n  while( true ) {\n    if (cVar3 == '\\n') {\n      return false;\n    }\n    if (cVar3 == '\\0') break;\n    lVar2 = lVar2 + 1;\n    if (param_2 <= (int)lVar2) {\n      return false;\n    }\n    cVar3 = param_1[lVar2];\n  }\n  return true;\n}\n\n",
  "dlsym": "\nvoid dlsym(void)\n\n{\n  (*(code *)PTR_dlsym_00237da8)();\n  return;\n}\n\n",
  "sh_wrerror": "\nvoid sh_wrerror(void)\n\n{\n  int *piVar1;\n  char *pcVar2;\n  \n  piVar1 = __errno_location();\n  pcVar2 = strerror(*piVar1);\n  builtin_error(\"write error: %s\",pcVar2);\n  return;\n}\n\n",
  "strlen": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strlen_002379b8)();\n  return sVar1;\n}\n\n",
  "pretty_print_loop": "\nundefined8 pretty_print_loop(void)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  int iVar3;\n  char *__s;\n  int local_10;\n  \n  uVar1 = posixly_correct;\n  local_10 = EOF_Reached;\n  if (EOF_Reached == 0) {\n    do {\n      iVar3 = __sigsetjmp(top_level,0);\n      if ((iVar3 != 0) || (iVar3 = read_command(), lVar2 = global_command, iVar3 != 0)) {\n        return 1;\n      }\n      posixly_correct = 1;\n      global_command = 0;\n      if ((lVar2 == 0) || (__s = (char *)make_command_string(lVar2), __s == (char *)0x0)) {\n        if (local_10 == 0) {\n          putchar(10);\n          local_10 = 1;\n        }\n      }\n      else {\n        puts(__s);\n        local_10 = 0;\n      }\n      posixly_correct = uVar1;\n      dispose_command(lVar2);\n    } while (EOF_Reached == 0);\n  }\n  return 0;\n}\n\n",
  "rl_character_len": "\nint rl_character_len(uint param_1,uint param_2)\n\n{\n  ushort **ppuVar1;\n  \n  if ((char)param_1 < '\\0') {\n    return (-(uint)(_rl_output_meta_chars == 0) & 3) + 1;\n  }\n  if ((char)param_1 != '\\t') {\n    if ((int)param_1 < 0x20) {\n      if ((param_1 & 0x80) == 0) {\n        return 2;\n      }\n    }\n    else if (param_1 == 0x7f) {\n      return 2;\n    }\n    ppuVar1 = __ctype_b_loc();\n    return ((*(byte *)((long)*ppuVar1 + (ulong)(param_1 & 0xff) * 2 + 1) & 0x40) == 0) + 1;\n  }\n  return ((param_2 | 7) + 1) - param_2;\n}\n\n",
  "memcmp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_memcmp_00237ad0)();\n  return iVar1;\n}\n\n",
  "FUN_001bd0d0": "\nchar ** FUN_001bd0d0(char *param_1,char **param_2,uint param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  size_t sVar4;\n  ulong uVar5;\n  char *pcVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char **ppcVar9;\n  char **ppcVar10;\n  long lVar11;\n  long in_FS_OFFSET;\n  char **local_110;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar4 = strlen(param_1);\n  uVar5 = sVar4 & 0xffffffff;\n  if ((int)sVar4 == 0) {\n    local_110 = param_2;\n    if (((param_3 & 1) != 0) && (pcVar6 = *param_2, pcVar6 != (char *)0x0)) {\n      ppcVar10 = param_2;\n      do {\n        iVar2 = stat(pcVar6,&local_d8);\n        if ((iVar2 == 0) && ((local_d8.st_mode & 0xf000) == 0x4000)) {\n          pcVar6 = *ppcVar10;\n          sVar4 = strlen(pcVar6);\n          pcVar6 = (char *)realloc(pcVar6,(ulong)((int)sVar4 + 2));\n          if (pcVar6 == (char *)0x0) goto LAB_001bd3ab;\n          pcVar6[sVar4 & 0xffffffff] = '/';\n          pcVar6[(int)sVar4 + 1] = '\\0';\n          *ppcVar10 = pcVar6;\n        }\n        uVar5 = (ulong)((int)uVar5 + 1);\n        ppcVar10 = param_2 + uVar5;\n        pcVar6 = *ppcVar10;\n      } while (pcVar6 != (char *)0x0);\n    }\n    goto LAB_001bd335;\n  }\n  cVar1 = param_1[(int)sVar4 - 1];\n  if (*param_2 == (char *)0x0) {\n    lVar11 = 8;\n  }\n  else {\n    uVar7 = 0;\n    do {\n      iVar2 = (int)uVar7;\n      uVar7 = (ulong)(iVar2 + 1);\n    } while (param_2[uVar7] != (char *)0x0);\n    lVar11 = (ulong)(iVar2 + 2) << 3;\n  }\n  local_110 = (char **)sh_malloc(lVar11,\"glob.c\",0x449);\n  if (local_110 == (char **)0x0) {\nLAB_001bd3ab:\n    local_110 = (char **)0x0;\n    goto LAB_001bd335;\n  }\n  pcVar6 = *param_2;\n  ppcVar10 = local_110;\n  if (pcVar6 != (char *)0x0) {\n    uVar7 = sVar4 & 0xffffffff;\n    uVar8 = 0;\n    lVar11 = 0;\n    ppcVar10 = param_2;\nLAB_001bd27e:\n    sVar4 = strlen(pcVar6);\n    ppcVar9 = (char **)(lVar11 + (long)local_110);\n    pcVar6 = (char *)sh_malloc(sVar4 + uVar7 + 3,\"glob.c\",0x450);\n    *ppcVar9 = pcVar6;\n    iVar2 = (int)uVar8;\n    if (pcVar6 != (char *)0x0) goto code_r0x001bd2ad;\n    if (iVar2 != 0) {\n      ppcVar10 = local_110;\n      do {\n        pcVar6 = *ppcVar10;\n        ppcVar10 = ppcVar10 + 1;\n        sh_xfree(pcVar6,\"glob.c\",0x456);\n      } while (local_110 + (ulong)(iVar2 - 1) + 1 != ppcVar10);\n    }\n    sh_xfree(local_110,\"glob.c\",0x457);\n    goto LAB_001bd3ab;\n  }\n  goto LAB_001bd3c5;\ncode_r0x001bd2ad:\n  strcpy(pcVar6,param_1);\n  if (cVar1 != '/') {\n    (*ppcVar9)[uVar7] = '/';\n  }\n  if (**ppcVar10 == '\\0') {\n    (*ppcVar9)[(uint)(cVar1 != '/') + (int)uVar5] = '\\0';\n  }\n  else {\n    strcpy(*ppcVar9 + (cVar1 != '/') + uVar7,*ppcVar10);\n    if ((((param_3 & 1) != 0) && (iVar3 = stat(*ppcVar9,&local_d8), iVar3 == 0)) &&\n       ((local_d8.st_mode & 0xf000) == 0x4000)) {\n      pcVar6 = *ppcVar9;\n      sVar4 = strlen(pcVar6);\n      pcVar6[sVar4] = '/';\n      (*ppcVar9)[sVar4 + 1] = '\\0';\n    }\n  }\n  uVar8 = (ulong)(iVar2 + 1);\n  lVar11 = uVar8 * 8;\n  ppcVar10 = param_2 + uVar8;\n  pcVar6 = *ppcVar10;\n  if (pcVar6 == (char *)0x0) goto LAB_001bd3c0;\n  goto LAB_001bd27e;\nLAB_001bd3c0:\n  ppcVar10 = local_110 + uVar8;\nLAB_001bd3c5:\n  *ppcVar10 = (char *)0x0;\n  uVar5 = 0;\n  pcVar6 = *param_2;\n  while (pcVar6 != (char *)0x0) {\n    sh_xfree(pcVar6,\"glob.c\",0x473);\n    uVar5 = (ulong)((int)uVar5 + 1);\n    pcVar6 = param_2[uVar5];\n  }\n  sh_xfree(param_2,\"glob.c\",0x474);\nLAB_001bd335:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_110;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0015e940": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0015e940(void)\n\n{\n  long lVar1;\n  int iVar2;\n  \n  if ((DAT_0023877c != 0) && (DAT_00238790 != -1)) {\n    lVar1 = *(long *)(jobs + (long)DAT_00238790 * 8);\n    if ((lVar1 != 0) && (*(int *)(lVar1 + 0x14) == 2)) goto LAB_0015e9e0;\n  }\n  if (DAT_00238794 != -1) {\n    lVar1 = *(long *)(jobs + (long)DAT_00238794 * 8);\n    if ((lVar1 != 0) && (*(int *)(lVar1 + 0x14) == 2)) {\nLAB_0015e9e0:\n      FUN_0015e860();\n      return;\n    }\n  }\n  iVar2 = FUN_0015e790(DAT_0023877c,2);\n  if (iVar2 == -1) {\n    iVar2 = FUN_0015e790(DAT_0023877c,1);\n    if (iVar2 == -1) {\n      _DAT_00238790 = 0xffffffffffffffff;\n      return;\n    }\n  }\n  FUN_0015e860(iVar2);\n  return;\n}\n\n",
  "rl_maybe_replace_line": "\nundefined8 rl_maybe_replace_line(void)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  undefined4 uVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  \n  lVar4 = current_history();\n  lVar2 = rl_undo_list;\n  uVar1 = rl_line_buffer;\n  if ((lVar4 != 0) && (*(long *)(lVar4 + 0x10) != rl_undo_list)) {\n    uVar3 = where_history();\n    puVar5 = (undefined8 *)replace_history_entry(uVar3,uVar1,lVar2);\n    xfree(*puVar5);\n    if ((void *)puVar5[1] != (void *)0x0) {\n      free((void *)puVar5[1]);\n    }\n    xfree(puVar5);\n  }\n  return 0;\n}\n\n",
  "dequote_escapes": "\nbyte * dequote_escapes(byte *param_1)\n\n{\n  mbstate_t mVar1;\n  byte bVar2;\n  size_t sVar3;\n  byte *__dest;\n  char *pcVar4;\n  size_t sVar5;\n  size_t sVar6;\n  byte *pbVar7;\n  byte *__s;\n  long in_FS_OFFSET;\n  bool bVar8;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  if (param_1 == (byte *)0x0) {\n    __dest = (byte *)0x0;\n  }\n  else {\n    sVar3 = strlen((char *)param_1);\n    __dest = (byte *)sh_xmalloc(sVar3 + 1,\"subst.c\",0x129b);\n    pcVar4 = strchr((char *)param_1,1);\n    if (pcVar4 == (char *)0x0) {\n      strcpy((char *)__dest,(char *)param_1);\n    }\n    else {\n      bVar8 = false;\n      if (ifs_value != (char *)0x0) {\n        bVar8 = *ifs_value == '\\0';\n      }\n      bVar2 = *param_1;\n      pbVar7 = __dest;\n      __s = param_1;\n      while (bVar2 != 0) {\n        while( true ) {\n          mVar1 = local_48;\n          if ((bVar2 == 1) &&\n             (((bVar2 = __s[1], bVar2 == 1 || (bVar2 == 0x7f)) || ((bVar2 == 0x20 && (bVar8)))))) {\n            __s = __s + 1;\n          }\n          else {\n            bVar2 = *__s;\n          }\n          if (locale_mb_cur_max < 2) break;\n          if (((*(uint *)(is_basic_table + (ulong)(bVar2 >> 5) * 4) >> (bVar2 & 0x1f) & 1) == 0) &&\n             ((locale_utf8locale == 0 || ((char)bVar2 < '\\0')))) {\n            sVar5 = mbrtowc((wchar_t *)0x0,(char *)__s,(size_t)(param_1 + (sVar3 - (long)__s)),\n                            &local_48);\n            if (0xfffffffffffffffd < sVar5) {\n              *pbVar7 = *__s;\n              goto LAB_0016f8c8;\n            }\n            sVar6 = 1;\n            if (sVar5 != 0) {\n              sVar6 = sVar5;\n            }\n            sVar5 = 0;\n            bVar2 = *__s;\n            while( true ) {\n              pbVar7[sVar5] = bVar2;\n              sVar5 = sVar5 + 1;\n              if (sVar6 == sVar5) break;\n              bVar2 = __s[sVar5];\n            }\n          }\n          else {\n            *pbVar7 = bVar2;\n            sVar5 = 1;\n          }\n          __s = __s + sVar5;\n          pbVar7 = pbVar7 + sVar5;\n          bVar2 = *__s;\n          if (bVar2 == 0) goto LAB_0016f928;\n        }\n        *pbVar7 = bVar2;\nLAB_0016f8c8:\n        bVar2 = __s[1];\n        pbVar7 = pbVar7 + 1;\n        __s = __s + 1;\n        local_48 = mVar1;\n      }\nLAB_0016f928:\n      *pbVar7 = 0;\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return __dest;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "wcschr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nwchar_t * wcschr(wchar_t *__wcs,wchar_t __wc)\n\n{\n  wchar_t *pwVar1;\n  \n  pwVar1 = (wchar_t *)(*(code *)PTR_wcschr_00237d60)();\n  return pwVar1;\n}\n\n",
  "FUN_00148830": "\nbool FUN_00148830(long param_1)\n\n{\n  int iVar1;\n  char *__src;\n  int iVar2;\n  uint uVar3;\n  size_t sVar4;\n  char *__dest;\n  long lVar5;\n  undefined *puVar6;\n  undefined8 uVar7;\n  undefined *puVar8;\n  long in_FS_OFFSET;\n  bool bVar9;\n  int local_34;\n  long local_30;\n  \n  iVar1 = line_number;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  line_number = *(int *)(param_1 + 4);\n  this_command_name = &DAT_001fc775;\n  iVar2 = signal_in_progress(0x42);\n  if ((iVar2 == 0) && (running_trap != 0x43)) {\n    line_number_for_err_trap = line_number;\n  }\n  if ((((variable_context != 0) && (interactive_shell != 0)) && (sourcelevel == 0)) &&\n     (line_number = line_number - (DAT_00242170 + -1), line_number < 1)) {\n    line_number = 1;\n  }\n  command_string_index = 0;\n  print_arith_command(*(undefined8 *)(param_1 + 8));\n  uVar3 = signal_in_progress(0x41);\n  if ((uVar3 | running_trap) == 0) {\n    if (the_printed_command_except_trap != (char *)0x0) {\n      sh_xfree(the_printed_command_except_trap,\"execute_cmd.c\",0xedf);\n    }\n    __src = the_printed_command;\n    sVar4 = strlen(the_printed_command);\n    __dest = (char *)sh_xmalloc(sVar4 + 1,\"execute_cmd.c\",0xee0);\n    the_printed_command_except_trap = strcpy(__dest,__src);\n  }\n  iVar2 = run_debug_trap();\n  if ((debugging_mode == 0) || (iVar2 == 0)) {\n    this_command_name = &DAT_001fc775;\n    if (**(long **)(param_1 + 8) == 0) {\n      puVar6 = (undefined *)expand_arith_string(*(undefined8 *)(*(long **)(param_1 + 8))[1],0x101);\n    }\n    else {\n      lVar5 = string_list();\n      puVar6 = (undefined *)expand_arith_string(lVar5,0x101);\n      if (lVar5 != 0) {\n        sh_xfree(lVar5,\"execute_cmd.c\",0xef7);\n      }\n    }\n    if (echo_command_at_execute != 0) {\n      puVar8 = &DAT_00213d70;\n      if (puVar6 != (undefined *)0x0) {\n        puVar8 = puVar6;\n      }\n      uVar7 = make_word(puVar8);\n      uVar7 = make_word_list(uVar7,0);\n      xtrace_print_arith_cmd(uVar7);\n      dispose_words(uVar7);\n    }\n    bVar9 = true;\n    if (puVar6 != (undefined *)0x0) {\n      lVar5 = evalexp(puVar6,shell_compatibility_level < 0x34,&local_34);\n      line_number = iVar1;\n      sh_xfree(puVar6,\"execute_cmd.c\",0xf08);\n      if (local_34 != 0) {\n        bVar9 = lVar5 == 0;\n      }\n    }\n  }\n  else {\n    bVar9 = false;\n    line_number = iVar1;\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return bVar9;\n}\n\n",
  "rl_initialize": "\nundefined8 rl_initialize(void)\n\n{\n  undefined *puVar1;\n  long lVar2;\n  undefined *puVar3;\n  \n  _rl_timeout_init();\n  if (DAT_0024a328 == 0) {\n    rl_readline_state = rl_readline_state | 1;\n    lVar2 = stdin;\n    if (rl_instream != 0) {\n      lVar2 = rl_instream;\n    }\n    rl_instream = lVar2;\n    if (rl_outstream == 0) {\n      rl_outstream = stdout;\n    }\n    _rl_out_stream = rl_outstream;\n    _rl_in_stream = rl_instream;\n    if (rl_line_buffer == (undefined *)0x0) {\n      rl_line_buffer_len = 0x100;\n      rl_line_buffer = (undefined *)xmalloc(0x100);\n    }\n    if (rl_terminal_name == 0) {\n      rl_terminal_name = sh_get_env_value(\"TERM\");\n    }\n    _rl_init_terminal_io(rl_terminal_name);\n    if (_rl_bind_stty_chars != 0) {\n      rl_tty_set_default_bindings(_rl_keymap);\n    }\n    rl_initialize_funmap();\n    _rl_init_eightbit();\n    rl_read_init_file(0);\n    if ((_rl_horizontal_scroll_mode != 0) && (_rl_term_autowrap != 0)) {\n      _rl_screenwidth = _rl_screenwidth + -1;\n      _rl_screenchars = _rl_screenchars - _rl_screenheight;\n    }\n    rl_set_keymap_from_edit_mode();\n    FUN_001cdb30(emacs_standard_keymap);\n    FUN_001cdb30(vi_movement_keymap);\n    if (vi_movement_keymap[432] == '\\x01') {\n      rl_bind_keyseq_in_map(&DAT_002129fc,0,vi_movement_keymap);\n    }\n    FUN_001cdb30(&vi_insertion_keymap);\n    puVar1 = _rl_keymap;\n    _rl_keymap = emacs_standard_keymap;\n    rl_bind_keyseq_if_unbound(&DAT_002129fe,rl_bracketed_paste_begin);\n    _rl_keymap = &vi_insertion_keymap;\n    rl_bind_keyseq_if_unbound(&DAT_002129fe,rl_bracketed_paste_begin);\n    puVar3 = rl_basic_word_break_characters;\n    if (rl_completer_word_break_characters != (undefined *)0x0) {\n      puVar3 = rl_completer_word_break_characters;\n    }\n    rl_completer_word_break_characters = puVar3;\n    _rl_keymap = puVar1;\n    if ((_rl_colored_stats | _rl_colored_completion_prefix) != 0) {\n      _rl_parse_colors();\n    }\n    _rl_executing_keyseq_size = 0x10;\n    rl_executing_keyseq = (undefined *)malloc(0x10);\n    if (rl_executing_keyseq != (undefined *)0x0) {\n      rl_key_sequence_length = 0;\n      *rl_executing_keyseq = 0;\n    }\n    DAT_0024a328 = DAT_0024a328 + 1;\n    rl_readline_state = rl_readline_state & 0xfffffffffffffffe | 2;\n  }\n  else {\n    _rl_reset_locale();\n  }\n  DAT_0024a320 = rl_line_buffer;\n  rl_mark = 0;\n  rl_end = 0;\n  rl_point = 0;\n  *rl_line_buffer = 0;\n  rl_readline_state = rl_readline_state & 0xfffffffff1ffffff;\n  rl_done = 0;\n  _rl_start_using_history();\n  rl_reset_line_state();\n  rl_last_func = 0;\n  _rl_parsing_conditionalized_out = 0;\n  if (rl_editing_mode == 0) {\n    _rl_vi_initialize_line();\n  }\n  _rl_set_insert_mode(1,1);\n  return 0;\n}\n\n",
  "FUN_00134e10": "\nulong FUN_00134e10(void)\n\n{\n  char *pcVar1;\n  int iVar2;\n  long lVar3;\n  size_t sVar4;\n  code *pcVar5;\n  undefined *puVar6;\n  bool bVar7;\n  \n  if (current_readline_line == (char *)0x0) goto LAB_00134e62;\n  while( true ) {\n    lVar3 = (long)current_readline_line_index;\n    if (*(byte *)(lVar3 + (long)current_readline_line) != 0) {\n      current_readline_line_index = current_readline_line_index + 1;\n      return (ulong)*(byte *)(lVar3 + (long)current_readline_line);\n    }\n    sh_xfree(current_readline_line,\"/usr/local/src/chet/src/bash/src/parse.y\",0x614);\n    current_readline_line = (char *)0x0;\nLAB_00134e62:\n    if (bash_readline_initialized == 0) {\n      initialize_readline();\n    }\n    if (job_control != 0) {\n      give_terminal_to(shell_pgrp,0);\n    }\n    iVar2 = signal_is_ignored(2);\n    if (iVar2 == 0) {\n      pcVar5 = (code *)set_signal_handler(2,sigint_sighandler);\n      bVar7 = pcVar5 != (code *)PTR_initialize_traps_00237fc0;\n    }\n    else {\n      pcVar5 = initialize_traps;\n      bVar7 = false;\n    }\n    iVar2 = fileno(rl_instream);\n    sh_unset_nodelay_mode(iVar2);\n    puVar6 = current_readline_prompt;\n    if (current_readline_prompt == (undefined *)0x0) {\n      puVar6 = &DAT_00213d70;\n    }\n    current_readline_line = (char *)readline(puVar6);\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    iVar2 = signal_is_ignored(2);\n    if ((iVar2 == 0) && (bVar7)) {\n      set_signal_handler(2,pcVar5);\n    }\n    pcVar1 = current_readline_line;\n    if (current_readline_line == (char *)0x0) break;\n    current_readline_line_index = 0;\n    sVar4 = strlen(current_readline_line);\n    iVar2 = (int)sVar4;\n    current_readline_line =\n         (char *)sh_xrealloc(pcVar1,(long)(iVar2 + 2),\"/usr/local/src/chet/src/bash/src/parse.y\",\n                             0x60d);\n    *(undefined *)((long)current_readline_line + (long)iVar2) = 10;\n    *(undefined *)((long)current_readline_line + (long)(iVar2 + 1)) = 0;\n  }\n  return 0xffffffff;\n}\n\n",
  "break_builtin": "\nundefined4 break_builtin(long param_1)\n\n{\n  char *__s1;\n  long lVar1;\n  int iVar2;\n  undefined4 uVar3;\n  long in_FS_OFFSET;\n  long local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((((param_1 == 0) || (*(char ***)(param_1 + 8) == (char **)0x0)) ||\n      (__s1 = **(char ***)(param_1 + 8), *__s1 != '-')) ||\n     (iVar2 = strcmp(__s1,\"--help\"), iVar2 != 0)) {\n    if ((loop_level != 0) ||\n       ((uVar3 = 0, posixly_correct == 0 &&\n        (builtin_error(\"only meaningful in a `for\\', `while\\', or `until\\' loop\"), loop_level != 0))\n       )) {\n      get_numeric_arg(param_1,1,&local_28);\n      if (local_28 < 1) {\n        uVar3 = 1;\n        sh_erange(**(undefined8 **)(param_1 + 8),\"loop count\");\n        breaking = loop_level;\n      }\n      else {\n        lVar1 = (long)loop_level;\n        if (local_28 <= loop_level) {\n          lVar1 = local_28;\n        }\n        breaking = (int)lVar1;\n        uVar3 = 0;\n      }\n    }\n  }\n  else {\n    builtin_help();\n    uVar3 = 0x102;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
  "rl_clear_message": "\nundefined8 rl_clear_message(void)\n\n{\n  rl_display_prompt = rl_prompt;\n  if (DAT_0024a82c == 0) {\n    (*(code *)rl_redisplay_function)();\n    return 0;\n  }\n  rl_restore_prompt();\n  DAT_0024a82c = 0;\n  (*(code *)rl_redisplay_function)();\n  return 0;\n}\n\n",
  "tilde_expand_word": "\nchar * tilde_expand_word(char *param_1)\n\n{\n  ulong uVar1;\n  size_t sVar2;\n  char *pcVar3;\n  ulong uVar4;\n  long lVar5;\n  passwd *ppVar6;\n  char *pcVar7;\n  char cVar8;\n  ulong uVar9;\n  \n  if (param_1 == (char *)0x0) {\n    return (char *)0x0;\n  }\n  if (*param_1 != '~') {\n    sVar2 = strlen(param_1);\n    pcVar3 = (char *)xmalloc(sVar2 + 1);\n    pcVar3 = strcpy(pcVar3,param_1);\n    return pcVar3;\n  }\n  if ((param_1[1] == '\\0') || (param_1[1] == '/')) {\n    lVar5 = sh_get_env_value(&DAT_001faa94);\n    if (lVar5 == 0) {\n      lVar5 = sh_get_home_dir(0);\n    }\n    pcVar3 = (char *)FUN_001f6f50(lVar5,param_1,1);\n    return pcVar3;\n  }\n  sVar2 = strlen(param_1);\n  pcVar3 = (char *)xmalloc(sVar2);\n  cVar8 = param_1[1];\n  if ((cVar8 == '\\0') || (cVar8 == '/')) {\n    uVar9 = 1;\n    pcVar7 = pcVar3;\n  }\n  else {\n    uVar1 = 2;\n    do {\n      uVar4 = uVar1;\n      pcVar3[uVar4 - 2] = cVar8;\n      cVar8 = param_1[uVar4];\n      uVar9 = uVar4 & 0xffffffff;\n      if (cVar8 == '\\0') break;\n      uVar1 = uVar4 + 1;\n    } while (cVar8 != '/');\n    pcVar7 = pcVar3 + (uVar4 - 1);\n  }\n  *pcVar7 = '\\0';\n  if ((tilde_expansion_preexpansion_hook != (code *)0x0) &&\n     (lVar5 = (*tilde_expansion_preexpansion_hook)(pcVar3), lVar5 != 0)) {\n    pcVar7 = (char *)FUN_001f6f50(lVar5,param_1,uVar9);\n    xfree(pcVar3);\n    xfree(lVar5);\n    return pcVar7;\n  }\n  ppVar6 = getpwnam(pcVar3);\n  if (ppVar6 == (passwd *)0x0) {\n    if ((tilde_expansion_failure_hook != (code *)0x0) &&\n       (lVar5 = (*tilde_expansion_failure_hook)(pcVar3), lVar5 != 0)) {\n      pcVar7 = (char *)FUN_001f6f50(lVar5,param_1,uVar9);\n      xfree(lVar5);\n      if (pcVar7 != (char *)0x0) goto LAB_001f70ad;\n    }\n    sVar2 = strlen(param_1);\n    pcVar7 = (char *)xmalloc(sVar2 + 1);\n    pcVar7 = strcpy(pcVar7,param_1);\n  }\n  else {\n    pcVar7 = (char *)FUN_001f6f50(ppVar6->pw_dir,param_1,uVar9);\n  }\nLAB_001f70ad:\n  xfree(pcVar3);\n  endpwent();\n  return pcVar7;\n}\n\n",
  "_DT_FINI": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
  "delete_all_variables": "\nvoid delete_all_variables(undefined8 param_1)\n\n{\n  hash_flush(param_1,dispose_variable);\n  return;\n}\n\n",
  "expand_word_leave_quoted": "\nvoid expand_word_leave_quoted(undefined8 *param_1,undefined8 param_2)\n\n{\n  uint uVar1;\n  undefined *puVar2;\n  undefined8 uVar3;\n  \n  DAT_00247848 = 1;\n  uVar1 = *(uint *)(param_1 + 1);\n  if (ifs_is_null != 0) {\n    uVar1 = uVar1 | 0x10;\n  }\n  *(uint *)(param_1 + 1) = uVar1 | 0x40;\n  puVar2 = (undefined *)FUN_00177e80(param_1,param_2,0,0,0);\n  if (puVar2 == &DAT_00247880) {\n    *param_1 = 0;\n    uVar3 = 2;\n  }\n  else {\n    if (puVar2 != &DAT_00247870) {\n      DAT_00247848 = 0;\n      return;\n    }\n    *param_1 = 0;\n    uVar3 = 1;\n  }\n  last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n  FUN_001667f0(uVar3);\n}\n\n",
  "FUN_00138cc0": "\n/* WARNING: Removing unreachable block (ram,0x00139602) */\n/* WARNING: Removing unreachable block (ram,0x0013931b) */\n/* WARNING: Removing unreachable block (ram,0x00139329) */\n/* WARNING: Removing unreachable block (ram,0x0013933a) */\n/* WARNING: Removing unreachable block (ram,0x0013934c) */\n/* WARNING: Removing unreachable block (ram,0x00139440) */\n/* WARNING: Removing unreachable block (ram,0x001390a7) */\n\nundefined * FUN_00138cc0(int param_1,uint param_2,uint param_3,int *param_4,uint param_5)\n\n{\n  bool bVar1;\n  undefined4 uVar2;\n  bool bVar3;\n  bool bVar4;\n  uint __c;\n  uint uVar5;\n  undefined *puVar6;\n  char *pcVar7;\n  char *pcVar8;\n  size_t sVar9;\n  ulong uVar10;\n  undefined8 uVar11;\n  byte bVar12;\n  ulong uVar13;\n  uint uVar14;\n  int iVar15;\n  long lVar16;\n  ulong uVar17;\n  int iVar18;\n  int iVar19;\n  int iVar20;\n  long in_FS_OFFSET;\n  bool bVar21;\n  bool bVar22;\n  bool bVar23;\n  int local_84;\n  int local_80;\n  uint local_7c;\n  int local_48;\n  int local_44;\n  long local_40;\n  \n  local_80 = (int)param_5 >> 6;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((param_5 & 8) == 0) ||\n     ((param_1 - 0x22U < 0x3f &&\n      ((0xbfffffffffffffdeU >> ((ulong)(param_1 - 0x22U) & 0x3f) & 1) == 0)))) {\n    if (param_1 == 0x22) {\n      local_7c = 4;\n      uVar14 = 0;\n    }\n    else {\n      uVar14 = 0;\n      local_7c = param_5 & 4;\n    }\n  }\n  else {\n    local_7c = param_5 & 4;\n    uVar14 = (uint)((param_5 & 4) == 0) * 2;\n  }\n  bVar1 = false;\n  puVar6 = (undefined *)sh_xmalloc(0x40,\"/usr/local/src/chet/src/bash/src/parse.y\",0xe5f);\n  uVar2 = line_number;\n  local_84 = 1;\n  iVar20 = 0x40;\n  iVar18 = 0;\nLAB_00138d80:\n  do {\n    while( true ) {\n      bVar21 = false;\n      if (param_1 != 0x27) {\n        bVar21 = (uVar14 & 8) == 0;\n      }\n      __c = FUN_00137960(bVar21);\n      uVar13 = (ulong)__c;\n      if (__c == 0xffffffff) {\n        sh_xfree(puVar6,\"/usr/local/src/chet/src/bash/src/parse.y\",0xe6b);\n        puVar6 = &DAT_00240b10;\n        parser_error(uVar2,\"unexpected EOF while looking for matching `%c\\'\",param_3);\n        EOF_Reached = 1;\n        goto LAB_001392b3;\n      }\n      bVar12 = (byte)__c;\n      iVar19 = local_80;\n      if (__c == 10) break;\n      if ((uVar14 & 4) == 0) {\n        bVar21 = __c == 0x23;\n        bVar3 = (uVar14 & 6) == 2 && bVar21;\n        if (bVar3) {\n          if ((((iVar18 == 0) || (puVar6[(long)iVar18 + -1] == 10)) ||\n              ((*(byte *)((long)&sh_syntaxtab + (ulong)(byte)puVar6[(long)iVar18 + -1] * 4 + 1) &\n               0x20) != 0)) &&\n             ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')))) {\n            uVar14 = uVar14 | 4;\n          }\n          bVar21 = (bool)((byte)(parser_state >> 0x12) & param_2 == 0x27);\n          bVar4 = bVar21;\n          if (bVar21 == false) {\n            bVar21 = bVar3;\n            bVar4 = param_2 == 0x27;\n          }\n          goto LAB_00138fb0;\n        }\n        if ((uVar14 & 8) == 0) goto LAB_00138de1;\n        uVar14 = uVar14 & 0xfffffff7;\n        if (iVar20 <= iVar18 + 2) {\n          uVar5 = (iVar18 + 2) - iVar20 & 0xffffffc0;\n          if (iVar18 + 2 < iVar20) {\n            uVar5 = 0;\n          }\n          iVar20 = iVar20 + 0x40 + uVar5;\n          puVar6 = (undefined *)\n                   sh_xrealloc(puVar6,(long)iVar20,\"/usr/local/src/chet/src/bash/src/parse.y\",0xe94)\n          ;\n        }\n        lVar16 = (long)iVar18;\n        if ((__c == 1) &&\n           ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')))) {\n          iVar18 = iVar18 + 1;\n          puVar6[lVar16] = 1;\n          lVar16 = (long)iVar18;\n        }\n        puVar6[lVar16] = bVar12;\n        iVar18 = iVar18 + 1;\n      }\n      else {\nLAB_00139370:\n        iVar19 = iVar18 + 1;\n        if (iVar20 <= iVar19) {\n          iVar20 = (iVar19 - iVar20 & 0xffffffc0U) + 0x40 + iVar20;\n          puVar6 = (undefined *)\n                   sh_xrealloc(puVar6,(long)iVar20,\"/usr/local/src/chet/src/bash/src/parse.y\",0xe7a)\n          ;\n        }\n        puVar6[iVar18] = bVar12;\n        iVar18 = iVar19;\n        if ((__c == 10) &&\n           ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')))) {\n          uVar14 = uVar14 & 0xfffffffb;\n        }\n      }\n    }\n    if ((((interactive != 0) && (bash_input - 1U < 2)) &&\n        ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')))) &&\n       ((pushed_string_list == 0 || (*(long *)(pushed_string_list + 0x18) == 0)))) {\n      FUN_001373e0();\n    }\n    if ((uVar14 & 4) != 0) goto LAB_00139370;\n    bVar21 = false;\nLAB_00138de1:\n    bVar3 = param_2 == 0x27;\n    bVar22 = __c == 0x7f;\n    bVar23 = __c == 1;\n    bVar4 = (bool)((byte)(parser_state >> 0x12) & bVar3);\n    if (bVar4 == false) {\n      bVar4 = bVar3;\n      if (bVar22 || bVar23) {\n        if (1 < DAT_00240da0) goto LAB_00138e2f;\nLAB_00139480:\n        iVar19 = iVar18 + 2;\n        if (iVar20 <= iVar19) {\n          iVar20 = (iVar19 - iVar20 & 0xffffffc0U) + 0x40 + iVar20;\n          puVar6 = (undefined *)\n                   sh_xrealloc(puVar6,(long)iVar20,\"/usr/local/src/chet/src/bash/src/parse.y\",0xea6)\n          ;\n        }\n        puVar6[iVar18] = 1;\n        puVar6[iVar18 + 1] = bVar12;\n        iVar18 = iVar19;\n      }\n      else {\nLAB_00138fb0:\n        if ((__c != param_3) ||\n           ((1 < DAT_00240da0 && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))))\n        goto LAB_00138e3a;\n        local_84 = local_84 + -1;\nLAB_00138fd0:\n        if (iVar20 <= iVar18 + 1) {\nLAB_00138fda:\n          uVar5 = (iVar18 + 1) - iVar20 & 0xffffffc0;\n          if (iVar18 + 1 < iVar20) {\n            uVar5 = 0;\n          }\n          iVar20 = iVar20 + 0x40 + uVar5;\n          puVar6 = (undefined *)\n                   sh_xrealloc(puVar6,(long)iVar20,\"/usr/local/src/chet/src/bash/src/parse.y\",0xeb4)\n          ;\n        }\n        iVar15 = iVar18 + 1;\n        puVar6[iVar18] = bVar12;\n        if (local_84 == 0) goto LAB_001392a2;\njoined_r0x00139410:\n        if (bVar4 == false) {\n          if (__c == 0x5c) goto LAB_00138eb8;\nLAB_0013905b:\n          if ((param_5 & 0x40) == 0) goto LAB_001390e8;\n          bVar3 = local_80 == 1;\n          if (__c != 0x25) {\n            if ((!bVar3) || (bVar21 == false)) goto LAB_001398fd;\n            goto LAB_00138ef6;\n          }\n          if (bVar3) {\n            if ((iVar18 + 1 < 2) ||\n               ((1 < DAT_00240da0 && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))))\n            goto LAB_00138f28;\n            goto LAB_001390e0;\n          }\nLAB_001398fd:\n          if ((__c != 0x2f) || (!bVar3)) {\n            if ((__c != 0x5e) || (!bVar3)) goto LAB_00139d40;\n            goto LAB_001390c1;\n          }\n          if (iVar18 + 1 < 2) goto LAB_00138f28;\n          if ((DAT_00240da0 < 2) ||\n             (lVar16 = DAT_00240e48, uVar10 = DAT_00240da0, uVar17 = uVar13,\n             *(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n            local_80 = 0x80;\n            iVar19 = local_80;\n            goto LAB_001390e8;\n          }\nLAB_0013993e:\n          bVar12 = (byte)uVar17;\n          iVar19 = 2;\n          if (*(char *)(lVar16 + -1 + uVar10) == '\\0') {\n            iVar19 = local_80;\n          }\n          goto LAB_001390e8;\n        }\n        if ((((param_5 >> 1 & 1) != 0) && (__c == 0x5c)) &&\n           ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')))) {\n          uVar14 = uVar14 | 8;\n        }\nLAB_00139430:\n        iVar18 = iVar18 + 1;\n      }\n      goto LAB_00138d80;\n    }\n    if (!bVar22 && !bVar23) goto LAB_00138fb0;\n    if ((DAT_00240da0 < 2) ||\n       (bVar4 = bVar22 || bVar23, *(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n      iVar19 = iVar18 + 1;\n      if (iVar20 <= iVar19) {\n        iVar20 = iVar20 + 0x40 + (iVar19 - iVar20 & 0xffffffc0U);\n        puVar6 = (undefined *)\n                 sh_xrealloc(puVar6,(long)iVar20,\"/usr/local/src/chet/src/bash/src/parse.y\",0xea0);\n      }\n      puVar6[iVar18] = bVar12;\n      iVar18 = iVar19;\n    }\n    else {\nLAB_00138e2f:\n      if (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0') goto LAB_00139480;\nLAB_00138e3a:\n      if ((((param_2 == param_3) || (!bVar1)) || (param_2 != 0x7b)) || (__c != param_2)) {\n        if ((((param_5 & 1) != 0) || (__c != param_2)) ||\n           ((1 < DAT_00240da0 && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))))\n        goto LAB_00138fd0;\n        local_84 = local_84 + 1;\n        if (iVar20 <= iVar18 + 1) goto LAB_00138fda;\n        puVar6[iVar18] = bVar12;\n        goto joined_r0x00139410;\n      }\n      if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))\n      goto LAB_00138fd0;\n      local_84 = local_84 + 1;\n      if (iVar20 <= iVar18 + 1) goto LAB_00138fda;\n      puVar6[iVar18] = bVar12;\n      if (__c != 0x5c) goto LAB_0013905b;\nLAB_00138eb8:\n      if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n        uVar14 = uVar14 | 8;\n      }\n      if ((param_5 & 0x40) != 0) {\n        if ((local_80 == 1) && (bVar21 != false)) {\nLAB_00138ef6:\n          if (iVar18 + 1 < 2) goto LAB_00138f28;\n          if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0')) {\n            if (__c != 0x2c) goto LAB_00138f28;\nLAB_001390d2:\n            lVar16 = DAT_00240e48;\n            uVar10 = DAT_00240da0;\n            if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0')) {\n              pcVar7 = strchr(\"#%^,~:-=?+/\",__c);\n              uVar17 = (ulong)bVar12;\n              if (pcVar7 != (char *)0x0) goto LAB_0013993e;\n              goto LAB_001390e8;\n            }\n          }\nLAB_001390e0:\n          local_80 = 0x40;\n          iVar19 = local_80;\n        }\n        else {\nLAB_00139d40:\n          if (__c == 0x2c) {\n            if (local_80 != 1) {\nLAB_00139d51:\n              if ((local_80 == 2) && (pcVar7 = strchr(\"#%^,~:-=?+/\",__c), pcVar7 == (char *)0x0)) {\n                if (DAT_00240da0 < 2) {\n                  local_80 = 4;\n                  iVar19 = local_80;\n                }\n                else {\n                  iVar19 = 4;\n                  if (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0') {\n                    iVar19 = local_80;\n                  }\n                }\n              }\n              goto LAB_001390e8;\n            }\nLAB_001390c1:\n            if (1 < iVar18 + 1) goto LAB_001390d2;\n          }\n          else if (local_80 != 1) goto LAB_00139d51;\nLAB_00138f28:\n          pcVar7 = strchr(\"#%^,~:-=?+/\",__c);\n          uVar17 = (ulong)bVar12;\n          if (pcVar7 != (char *)0x0) {\n            lVar16 = DAT_00240e48;\n            uVar10 = DAT_00240da0;\n            if (1 < DAT_00240da0) goto LAB_0013993e;\n            local_80 = 2;\n            iVar19 = local_80;\n          }\n        }\n      }\nLAB_001390e8:\n      local_80 = iVar19;\n      iVar15 = iVar18 + 1;\n      if ((((posixly_correct == 0) || (shell_compatibility_level < 0x2a)) ||\n          ((local_80 - 0x40U & 0xffffffbf) == 0)) || (((param_5 & 0x44) != 0x44 || (__c != 0x27))))\n      {\n        if (param_2 != param_3) {\n          if ((*(byte *)(&sh_syntaxtab + (uVar13 & 0xff)) & 8) == 0) goto LAB_001394f0;\n          if (1 < DAT_00240da0) goto LAB_00139156;\nLAB_00139161:\n          if (DAT_00240a1c <= DAT_00240a18 + 1) {\n            DAT_00240a1c = DAT_00240a1c + 10;\n            dstack = sh_xrealloc(dstack,(long)DAT_00240a1c,\n                                 \"/usr/local/src/chet/src/bash/src/parse.y\",0xef2);\n          }\n          *(byte *)(dstack + DAT_00240a18) = bVar12;\n          DAT_00240a18 = DAT_00240a18 + 1;\n          if ((__c == 0x27) && (bVar1)) {\n            if ((DAT_00240da0 < 2) ||\n               (uVar5 = local_7c, *(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n              uVar5 = local_7c | 2;\n            }\n            pcVar8 = (char *)FUN_00138cc0(0x27,0x27,0x27,&local_48,uVar5);\n            DAT_00240a18 = DAT_00240a18 + -1;\n            if (pcVar8 == &DAT_00240b10) {\nLAB_00139fad:\n              sh_xfree(puVar6,\"/usr/local/src/chet/src/bash/src/parse.y\",0xef8);\n              puVar6 = &DAT_00240b10;\n              goto LAB_001392b3;\n            }\n            pcVar7 = pcVar8;\n            if ((((extended_quote != 0) || (local_7c == 0)) ||\n                ((local_80 - 0x40U & 0xffffffbf) == 0)) &&\n               ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')))) {\n              pcVar7 = (char *)ansiexpand(pcVar8,0,local_48 + -1,&local_44);\n              sh_xfree(pcVar8,\"/usr/local/src/chet/src/bash/src/parse.y\",0xeff);\n              iVar19 = local_44;\n              if (shell_compatibility_level < 0x2b) {\n                if (local_7c == 0) goto LAB_00139f78;\n              }\n              else {\n                if (local_7c == 0) {\nLAB_00139f78:\n                  pcVar8 = (char *)sh_single_quote(pcVar7);\n                  uVar11 = 0xf19;\n                }\n                else {\n                  if (((local_80 - 0x40U & 0xffffffbf) != 0) || ((param_5 & 0x40) == 0))\n                  goto LAB_00139bde;\n                  pcVar8 = (char *)sh_single_quote(pcVar7);\n                  uVar11 = 0xf09;\n                }\n                sh_xfree(pcVar7,\"/usr/local/src/chet/src/bash/src/parse.y\",uVar11);\n                sVar9 = strlen(pcVar8);\n                pcVar7 = pcVar8;\n                iVar19 = (int)sVar9;\n              }\nLAB_00139bde:\n              iVar15 = iVar18 + -1;\n              local_48 = iVar19;\n            }\nLAB_001391fb:\n            if (local_48 == 0) {\n              if (pcVar7 == (char *)0x0) goto LAB_00139250;\n            }\n            else {\nLAB_00139203:\n              if (iVar20 <= local_48 + iVar15) {\n                iVar20 = ((local_48 + iVar15) - iVar20 & 0xffffffc0U) + 0x40 + iVar20;\n                puVar6 = (undefined *)\n                         sh_xrealloc(puVar6,(long)iVar20,\"/usr/local/src/chet/src/bash/src/parse.y\",\n                                     0xf42);\n              }\n              strcpy(puVar6 + iVar15,pcVar7);\n              iVar15 = iVar15 + local_48;\n            }\n          }\n          else {\n            pcVar7 = (char *)FUN_00138cc0(uVar13,uVar13,uVar13,&local_48,local_7c);\n            DAT_00240a18 = DAT_00240a18 + -1;\n            if (pcVar7 == &DAT_00240b10) goto LAB_00139fad;\n            if ((((!bVar1) || (__c != 0x22)) || ((extended_quote == 0 && (local_7c != 0)))) ||\n               ((1 < DAT_00240da0 && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))))\n            goto LAB_001391fb;\n            pcVar8 = (char *)locale_expand(pcVar7,0,local_48 + -1,uVar2,&local_44);\n            sh_xfree(pcVar7,\"/usr/local/src/chet/src/bash/src/parse.y\",0xf2a);\n            iVar19 = local_44;\n            if ((singlequote_translations == 0) ||\n               ((local_48 + -1 == local_44 &&\n                ((local_44 == 0 ||\n                 ((*pcVar7 == *pcVar8 &&\n                  (iVar15 = strncmp(pcVar7,pcVar8,(long)local_44), iVar15 == 0)))))))) {\n              pcVar7 = (char *)sh_mkdoublequoted(pcVar8,iVar19,0);\n            }\n            else if ((local_7c == 0) || ((local_80 == 0x80 && ((param_5 & 0x40) != 0)))) {\n              pcVar7 = (char *)sh_single_quote(pcVar8);\n            }\n            else {\n              pcVar7 = (char *)sh_backslash_quote_for_double_quotes(pcVar8,0);\n            }\n            sh_xfree(pcVar8,\"/usr/local/src/chet/src/bash/src/parse.y\",0xf3c);\n            sVar9 = strlen(pcVar7);\n            iVar15 = iVar18 + -1;\n            local_48 = (int)sVar9;\n            if (local_48 != 0) goto LAB_00139203;\n          }\n          sh_xfree(pcVar7,\"/usr/local/src/chet/src/bash/src/parse.y\",0xf43);\n          goto LAB_00139250;\n        }\n        if ((param_2 != 0x22) || (__c != 0x60)) {\n          if (param_2 != 0x60) goto LAB_001398ab;\n          goto LAB_00139250;\n        }\n        if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0')) {\n          if (bVar1) goto LAB_001398b5;\n          goto LAB_00139280;\n        }\n        pcVar7 = (char *)FUN_00138cc0(0,0x60,0x60,&local_48,local_7c);\n        if (pcVar7 == &DAT_00240b10) {\n          sh_xfree(puVar6,\"/usr/local/src/chet/src/bash/src/parse.y\",0xf55);\n          puVar6 = &DAT_00240b10;\n          goto LAB_001392b3;\n        }\n        if (local_48 == 0) {\n          if (pcVar7 == (char *)0x0) goto LAB_00139280;\n        }\n        else {\n          if (iVar20 <= local_48 + iVar15) {\n            iVar20 = ((local_48 + iVar15) - iVar20 & 0xffffffc0U) + 0x40 + iVar20;\n            puVar6 = (undefined *)\n                     sh_xrealloc(puVar6,(long)iVar20,\"/usr/local/src/chet/src/bash/src/parse.y\",\n                                 0xf56);\n          }\n          strcpy(puVar6 + iVar15,pcVar7);\n          iVar15 = iVar15 + local_48;\n        }\n        sh_xfree(pcVar7,\"/usr/local/src/chet/src/bash/src/parse.y\",0xf58);\n        uVar14 = 0;\nLAB_0013928e:\n        bVar1 = false;\n      }\n      else {\n        if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0'))\n        goto LAB_00139430;\n        if (param_2 == param_3) {\n          if (param_2 == 0x60) goto LAB_00139280;\nLAB_001398ab:\n          if (bVar1) {\nLAB_001398b5:\n            if ((((__c & 0xffffffdf) == 0x5b) || (__c == 0x28)) &&\n               ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')))) {\nLAB_0013951d:\n              if (__c == param_2) {\nLAB_00139e67:\n                local_84 = local_84 + -1;\n              }\n              if (__c == 0x28) {\nLAB_0013997f:\n                pcVar7 = (char *)FUN_00138940(0,&local_48);\n              }\n              else if (__c == 0x7b) {\n                pcVar7 = (char *)FUN_00138cc0(0,0x7b,0x7d,&local_48,local_7c | 0x41);\n              }\n              else {\n                pcVar7 = (char *)FUN_00138cc0(0,0x5b,0x5d,&local_48,local_7c);\n              }\n              if (pcVar7 == &DAT_00240b10) {\n                sh_xfree(puVar6,\"/usr/local/src/chet/src/bash/src/parse.y\",0xf67);\n                puVar6 = &DAT_00240b10;\n                goto LAB_001392b3;\n              }\n              if (local_48 == 0) {\n                if (pcVar7 == (char *)0x0) goto LAB_00139250;\n              }\n              else {\n                if (iVar20 <= local_48 + iVar15) {\n                  iVar20 = ((local_48 + iVar15) - iVar20 & 0xffffffc0U) + 0x40 + iVar20;\n                  puVar6 = (undefined *)\n                           sh_xrealloc(puVar6,(long)iVar20,\n                                       \"/usr/local/src/chet/src/bash/src/parse.y\",0xf68);\n                }\n                strcpy(puVar6 + iVar15,pcVar7);\n                iVar15 = iVar15 + local_48;\n              }\n              sh_xfree(pcVar7,\"/usr/local/src/chet/src/bash/src/parse.y\",0xf6a);\n            }\n          }\n        }\n        else {\n          if ((DAT_002394bc & 8) != 0) {\nLAB_00139156:\n            if (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0') goto LAB_00139161;\n          }\nLAB_001394f0:\n          if ((param_5 & 0x60) != 0) {\n            if (bVar1) {\n              if (((__c & 0xffffffdf) == 0x5b) || (__c == 0x28)) goto LAB_0013951d;\n            }\n            else if (((uVar14 & 0x1000) != 0) && (__c == 0x28)) {\n              if (param_2 == 0x28) goto LAB_00139e67;\n              goto LAB_0013997f;\n            }\n          }\n        }\nLAB_00139250:\n        if ((((__c & 0xfffffffd) == 0x3c) && ((uVar14 & 0x1000) == 0)) &&\n           ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')))) {\n          uVar14 = 0x1000;\n          goto LAB_0013928e;\n        }\nLAB_00139280:\n        uVar14 = 0;\n        if (((__c != 0x24) || (uVar14 = 0, bVar1)) ||\n           ((1 < DAT_00240da0 && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))))\n        goto LAB_0013928e;\n        uVar14 = 0;\n        bVar1 = true;\n      }\n      iVar18 = iVar15;\n      if (local_84 == 0) {\nLAB_001392a2:\n        puVar6[iVar15] = 0;\n        *param_4 = iVar15;\nLAB_001392b3:\n        if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n          __stack_chk_fail();\n        }\n        return puVar6;\n      }\n    }\n  } while( true );\n}\n\n",
  "job_exit_status": "\nuint job_exit_status(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar1 = FUN_0015e730();\n  if ((char)(((byte)uVar1 & 0x7f) + 1) < '\\x02') {\n    uVar2 = 0;\n    if ((byte)uVar1 != 0x7f) {\n      uVar2 = uVar1 >> 8 & 0xff;\n    }\n    return uVar2;\n  }\n  return (uVar1 & 0x7f) + 0x80;\n}\n\n",
  "bind_global_variable": "\nvoid bind_global_variable(undefined8 param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  if (shell_variables == 0) {\n    FUN_00152b20();\n  }\n  FUN_00154e30(param_1,param_2,*(undefined8 *)(global_variables + 0x20),0,param_3);\n  return;\n}\n\n",
  "strerror": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strerror_00237e50)();\n  return pcVar1;\n}\n\n",
  "coproc_alloc": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 * coproc_alloc(char *param_1,undefined4 param_2)\n\n{\n  size_t sVar1;\n  char *__dest;\n  \n  _DAT_00238438 = 0xffffffff;\n  sh_coproc = (char *)0x0;\n  DAT_0023842c = 0xffffffff;\n  _DAT_00238430 = 0xffffffffffffffff;\n  _DAT_00238440 = 0x200000000;\n  DAT_00238428 = param_2;\n  sVar1 = strlen(param_1);\n  __dest = (char *)sh_xmalloc(sVar1 + 1,\"execute_cmd.c\",0x802);\n  sh_coproc = strcpy(__dest,param_1);\n  _DAT_00238440 = _DAT_00238440 & 0xffffffff;\n  return &sh_coproc;\n}\n\n",
  "rl_completion_matches": "\nundefined8 * rl_completion_matches(undefined8 param_1,code *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  long lVar6;\n  int iVar7;\n  long *plVar8;\n  int iVar9;\n  \n  iVar9 = 0;\n  iVar7 = 10;\n  puVar3 = (undefined8 *)xmalloc(0x58);\n  puVar3[1] = 0;\n  do {\n    lVar4 = (*param_2)(param_1,iVar9);\n    if (lVar4 == 0) {\n      if (iVar9 == 0) {\n        puVar5 = (undefined8 *)0x0;\n        xfree(puVar3);\n      }\n      else {\n        puVar5 = puVar3;\n        if (iVar9 == 1) {\n          uVar2 = puVar3[1];\n          puVar3[1] = 0;\n          *puVar3 = uVar2;\n        }\n        else {\n          FUN_001d7060(puVar3,iVar9,param_1);\n        }\n      }\n      return puVar5;\n    }\n    if (_rl_caught_signal == 0) {\n      iVar9 = iVar9 + 1;\n      if (iVar7 <= iVar9) {\n        iVar1 = iVar7 + 0xb;\n        iVar7 = iVar7 + 10;\n        lVar6 = (long)iVar1 << 3;\n        goto LAB_001d8cd9;\n      }\n    }\n    else {\n      if ((param_2 == rl_filename_completion_function) && (puVar3[1] != 0)) {\n        plVar8 = puVar3 + 2;\n        do {\n          xfree();\n          lVar6 = *plVar8;\n          plVar8 = plVar8 + 1;\n        } while (lVar6 != 0);\n      }\n      xfree(puVar3);\n      if (_rl_caught_signal == 0) {\n        iVar7 = 10;\n        lVar6 = 0x58;\n        puVar3 = (undefined8 *)0x0;\n        iVar9 = 1;\n      }\n      else {\n        iVar7 = 10;\n        puVar3 = (undefined8 *)0x0;\n        iVar9 = 1;\n        _rl_signal_handler(_rl_caught_signal);\n        lVar6 = 0x58;\n      }\nLAB_001d8cd9:\n      puVar3 = (undefined8 *)xrealloc(puVar3,lVar6);\n      if (puVar3 == (undefined8 *)0x0) {\n        return (undefined8 *)0x0;\n      }\n    }\n    puVar3[iVar9] = lVar4;\n    puVar3[(long)iVar9 + 1] = 0;\n  } while( true );\n}\n\n",
  "save_pgrp_pipe": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid save_pgrp_pipe(undefined4 *param_1,int param_2)\n\n{\n  *param_1 = pgrp_pipe;\n  param_1[1] = DAT_0023873c;\n  if (param_2 != 0) {\n    _pgrp_pipe = 0xffffffffffffffff;\n  }\n  return;\n}\n\n",
  "dispose_saved_dollar_vars": "\nvoid dispose_saved_dollar_vars(void)\n\n{\n  undefined8 *puVar1;\n  long lVar2;\n  long *plVar3;\n  \n  if ((DAT_002422d8 != 0) && (DAT_002422cc != 0)) {\n    DAT_002422cc = DAT_002422cc + -1;\n    dispose_words(*(undefined8 *)(DAT_002422d8 + 8 + (long)DAT_002422cc * 0x18));\n    lVar2 = *(long *)(DAT_002422d8 + (long)DAT_002422cc * 0x18);\n    plVar3 = (long *)(lVar2 + 8);\n    do {\n      if (*plVar3 != 0) {\n        sh_xfree(*plVar3,\"variables.c\",0x15ee);\n      }\n      plVar3 = plVar3 + 1;\n    } while ((long *)(lVar2 + 0x50) != plVar3);\n    sh_xfree(*(undefined8 *)(DAT_002422d8 + (long)DAT_002422cc * 0x18),\"variables.c\",0x1649);\n    puVar1 = (undefined8 *)(DAT_002422d8 + (long)DAT_002422cc * 0x18);\n    *puVar1 = 0;\n    puVar1[1] = 0;\n    *(undefined4 *)(puVar1 + 2) = 0;\n    return;\n  }\n  return;\n}\n\n",
  "optimize_shell_function": "\nvoid optimize_shell_function(int *param_1)\n\n{\n  uint *puVar1;\n  long lVar2;\n  int iVar3;\n  \n  iVar3 = *param_1;\n  if (iVar3 == 9) {\n    param_1 = *(int **)(*(long *)(param_1 + 6) + 8);\n    iVar3 = *param_1;\n  }\n  if (iVar3 == 4) {\n    iVar3 = should_suppress_fork(param_1);\n    if (iVar3 != 0) {\n      param_1[1] = param_1[1] | 0x40;\n      **(uint **)(param_1 + 6) = **(uint **)(param_1 + 6) | 0x40;\n      return;\n    }\n    iVar3 = *param_1;\n  }\n  if (iVar3 == 6) {\n    iVar3 = can_optimize_connection(param_1);\n    if (iVar3 != 0) {\n      iVar3 = should_suppress_fork(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10));\n      if (iVar3 != 0) {\n        lVar2 = *(long *)(*(long *)(param_1 + 6) + 0x10);\n        puVar1 = (uint *)(lVar2 + 4);\n        *puVar1 = *puVar1 | 0x40;\n        puVar1 = *(uint **)(lVar2 + 0x18);\n        *puVar1 = *puVar1 | 0x40;\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
  "rl_activate_mark": "\nvoid rl_activate_mark(void)\n\n{\n  _rl_keep_mark_active = _rl_keep_mark_active + 1;\n  DAT_0024b688 = 1;\n  return;\n}\n\n",
  "FUN_00140fd0": "\nchar * FUN_00140fd0(char *param_1)\n\n{\n  char cVar1;\n  char *pcVar2;\n  size_t sVar3;\n  char *__dest;\n  \n  cVar1 = *param_1;\n  if (cVar1 == '+') {\n    cVar1 = param_1[1];\n    if (cVar1 == '\\0') {\n      pcVar2 = (char *)get_string_value(&DAT_001fc3d5);\n      goto LAB_00140fef;\n    }\n  }\n  else if ((cVar1 == '-') && (cVar1 = param_1[1], cVar1 == '\\0')) {\n    pcVar2 = (char *)get_string_value(&DAT_001fc3d2);\n    goto LAB_00140fef;\n  }\n  if (9 < (byte)(cVar1 - 0x30U)) {\n    return (char *)0x0;\n  }\n  pcVar2 = (char *)get_dirstack_from_string();\nLAB_00140fef:\n  if (pcVar2 == (char *)0x0) {\n    return (char *)0x0;\n  }\n  sVar3 = strlen(pcVar2);\n  __dest = (char *)sh_xmalloc(sVar3 + 1,\"general.c\",0x444);\n  pcVar2 = strcpy(__dest,pcVar2);\n  return pcVar2;\n}\n\n",
  "zmapfd": "\nulong zmapfd(undefined4 param_1,long *param_2)\n\n{\n  long lVar1;\n  size_t __n;\n  ulong uVar2;\n  ulong uVar3;\n  ulong uVar4;\n  long in_FS_OFFSET;\n  undefined local_1048 [4104];\n  long local_40;\n  \n  uVar2 = 0x1000;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar1 = sh_xmalloc(0x1000,\"zmapfd.c\",0x3c);\n  uVar4 = 0;\n  do {\n    __n = zread(param_1,local_1048,0x1000);\n    if (__n == 0) {\n      uVar3 = uVar4 & 0xffffffff;\n      if (uVar2 <= uVar4 + 1) {\n        do {\n          uVar2 = uVar2 + 0x80;\n        } while (uVar2 <= uVar4 + 1);\n        lVar1 = sh_xrealloc(lVar1,uVar2,\"zmapfd.c\",0x54);\n      }\n      *(undefined *)(lVar1 + uVar4) = 0;\n      if (param_2 == (long *)0x0) {\n        sh_xfree(lVar1,\"zmapfd.c\",0x5a);\n      }\n      else {\n        *param_2 = lVar1;\n      }\nLAB_001caf95:\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return uVar3;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if ((long)__n < 0) {\n      uVar3 = 0xffffffff;\n      sh_xfree(lVar1,\"zmapfd.c\",0x49);\n      if (param_2 != (long *)0x0) {\n        *param_2 = 0;\n      }\n      goto LAB_001caf95;\n    }\n    uVar3 = __n + uVar4;\n    if (uVar2 <= uVar3) {\n      do {\n        uVar2 = uVar2 + 0x1000;\n      } while (uVar2 <= uVar3);\n      lVar1 = sh_xrealloc(lVar1,uVar2,\"zmapfd.c\",0x4f);\n    }\n    memcpy((void *)(lVar1 + uVar4),local_1048,__n);\n    uVar4 = uVar3;\n  } while( true );\n}\n\n",
  "initialize_shell_builtins": "\nvoid initialize_shell_builtins(void)\n\n{\n  qsort(shell_builtins,(long)num_shell_builtins,0x30,FUN_001a3a10);\n  return;\n}\n\n",
  "reset_shopt_options": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid reset_shopt_options(void)\n\n{\n  cdspelling = 0;\n  cdable_vars = 0;\n  autocd = 0;\n  check_hashed_filenames = 0;\n  check_window_size = 1;\n  glob_dot_filenames = 0;\n  allow_null_glob_expansion = 0;\n  no_exit_on_failed_exec = 0;\n  expand_aliases = 0;\n  extended_quote = 1;\n  fail_glob_expansion = 0;\n  glob_asciirange = 1;\n  glob_star = 0;\n  gnu_error_format = 0;\n  hup_on_exit = 0;\n  inherit_errexit = 0;\n  interactive_comments = 1;\n  lastpipe_opt = 0;\n  localvar_unset = 0;\n  localvar_inherit = 0;\n  mail_warning = 0;\n  match_ignore_case = 0;\n  glob_ignore_case = 0;\n  print_shift_error = 0;\n  promptvars = 1;\n  source_uses_path = 1;\n  varassign_redir_autoclose = 0;\n  singlequote_translations = 0;\n  patsub_replacement = 1;\n  check_jobs_at_exit = 0;\n  extended_glob = 0;\n  assoc_expand_once = 0;\n  expand_once_flag = 0;\n  literal_history = 0;\n  force_append_history = 0;\n  command_oriented_history = 1;\n  complete_fullquote = 1;\n  force_fignore = 1;\n  history_reediting = 0;\n  hist_verify = 0;\n  perform_hostname_completion = 1;\n  dircomplete_expand = 0;\n  dircomplete_spelling = 0;\n  no_empty_command_completion = 0;\n  prog_completion_enabled = 1;\n  progcomp_alias = 0;\n  xpg_echo = 0;\n  _DAT_00248d68 = login_shell;\n  return;\n}\n\n",
  "rl_vi_eof_maybe": "\nvoid rl_vi_eof_maybe(void)\n\n{\n  rl_newline(1,10);\n  return;\n}\n\n",
  "_rl_arg_overflow": "\nundefined8 _rl_arg_overflow(void)\n\n{\n  if (rl_numeric_arg < 0xf4241) {\n    return 0;\n  }\n  _rl_argcxt = 0;\n  rl_numeric_arg = 0;\n  rl_explicit_arg = 0;\n  rl_ding();\n  rl_restore_prompt();\n  rl_clear_message();\n  rl_readline_state = rl_readline_state & 0xfffffffffffffbff;\n  return 1;\n}\n\n",
  "array_to_assign": "\nundefined * array_to_assign(long param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined *puVar4;\n  char *__s;\n  char *__s_00;\n  size_t sVar5;\n  undefined *puVar6;\n  int iVar7;\n  int iVar8;\n  long lVar9;\n  undefined8 *puVar10;\n  long lVar11;\n  long in_FS_OFFSET;\n  undefined local_58 [24];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    puVar6 = (undefined *)0x0;\n  }\n  else {\n    puVar6 = (undefined *)0x0;\n    if (*(long *)(param_1 + 8) != 0) {\n      puVar4 = (undefined *)sh_xmalloc(0x80,\"array.c\",0x3fa);\n      *puVar4 = 0x28;\n      puVar10 = (undefined8 *)(*(undefined8 **)(param_1 + 0x10))[2];\n      if (*(undefined8 **)(param_1 + 0x10) == puVar10) {\n        lVar11 = 2;\n        lVar9 = 1;\n      }\n      else {\n        iVar3 = 1;\n        iVar8 = 0x80;\n        do {\n          __s = (char *)inttostr(*puVar10,local_58,0x16);\n          if (puVar10[1] == 0) {\n            iVar2 = 9;\n            __s_00 = (char *)0x0;\n            if (__s != (char *)0x0) {\n              if (*__s == '\\0') {\n                iVar7 = 8;\n              }\n              else {\n                if (__s[1] != '\\0') goto LAB_0018a2cf;\n                iVar7 = 9;\n              }\n              goto LAB_0018a305;\n            }\n          }\n          else {\n            iVar2 = ansic_shouldquote(puVar10[1]);\n            if (iVar2 == 0) {\n              __s_00 = (char *)sh_double_quote(puVar10[1]);\n            }\n            else {\n              __s_00 = (char *)ansic_quote(puVar10[1],0,0);\n            }\n            iVar7 = 8;\n            if (((__s != (char *)0x0) && (*__s != '\\0')) && (iVar7 = 9, __s[1] != '\\0')) {\nLAB_0018a2cf:\n              iVar7 = 10;\n              if (__s[2] != '\\0') {\n                sVar5 = strlen(__s);\n                iVar7 = (int)sVar5 + 8;\n              }\n            }\n            if (__s_00 == (char *)0x0) {\nLAB_0018a305:\n              iVar2 = iVar7 + 1;\n              __s_00 = (char *)0x0;\n            }\n            else {\n              iVar2 = iVar7 + 1;\n              if (((*__s_00 != '\\0') && (iVar2 = iVar7 + 2, __s_00[1] != '\\0')) &&\n                 (iVar2 = iVar7 + 3, __s_00[2] != '\\0')) {\n                sVar5 = strlen(__s_00);\n                iVar2 = iVar7 + 1 + (int)sVar5;\n              }\n            }\n          }\n          iVar2 = iVar2 + iVar3;\n          iVar7 = iVar8;\n          if (iVar8 <= iVar2) {\n            do {\n              iVar8 = iVar7 * 2;\n              iVar1 = iVar7 * -2;\n              iVar7 = iVar8;\n            } while (SBORROW4(iVar2,iVar8) == iVar2 + iVar1 < 0);\n            puVar4 = (undefined *)sh_xrealloc(puVar4,(long)iVar8,\"array.c\",0x406);\n          }\n          puVar4[iVar3] = 0x5b;\n          strcpy(puVar4 + (iVar3 + 1),__s);\n          iVar2 = 0;\n          if (((*__s != '\\0') && (iVar2 = 1, __s[1] != '\\0')) && (iVar2 = 2, __s[2] != '\\0')) {\n            sVar5 = strlen(__s);\n            iVar2 = (int)sVar5;\n          }\n          iVar2 = iVar2 + iVar3 + 1;\n          iVar3 = iVar2 + 2;\n          puVar4[iVar2] = 0x5d;\n          lVar9 = (long)iVar3;\n          puVar4[iVar2 + 1] = 0x3d;\n          if (__s_00 == (char *)0x0) {\n            if (puVar10[2] == *(long *)(param_1 + 0x10)) goto LAB_0018a1f8;\n            puVar4[lVar9] = 0x20;\n            iVar3 = iVar2 + 3;\n          }\n          else {\n            strcpy(puVar4 + lVar9,__s_00);\n            iVar2 = 0;\n            if (((*__s_00 != '\\0') && (iVar2 = 1, __s_00[1] != '\\0')) &&\n               (iVar2 = 2, __s_00[2] != '\\0')) {\n              sVar5 = strlen(__s_00);\n              iVar2 = (int)sVar5;\n            }\n            iVar3 = iVar2 + iVar3;\n            if (puVar10[2] != *(long *)(param_1 + 0x10)) {\n              puVar4[iVar3] = 0x20;\n              iVar3 = iVar3 + 1;\n            }\n            sh_xfree(__s_00,\"array.c\",0x415);\n          }\n          puVar10 = (undefined8 *)puVar10[2];\n        } while (*(undefined8 **)(param_1 + 0x10) != puVar10);\n        lVar9 = (long)iVar3;\nLAB_0018a1f8:\n        iVar3 = iVar3 + 1;\n        lVar11 = (long)iVar3;\n        if (iVar8 <= iVar3) {\n          puVar4 = (undefined *)\n                   sh_xrealloc(puVar4,(long)(int)(iVar8 + 8 + (iVar3 - iVar8 & 0xfffffff8U)),\n                               \"array.c\",0x417);\n        }\n      }\n      puVar4[lVar9] = 0x29;\n      puVar4[lVar11] = 0;\n      puVar6 = puVar4;\n      if (param_2 != 0) {\n        puVar6 = (undefined *)sh_single_quote(puVar4);\n        sh_xfree(puVar4,\"array.c\",0x41d);\n      }\n    }\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar6;\n}\n\n",
  "FUN_001580f0": "\nundefined8 FUN_001580f0(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if ((DAT_002422c8 | variable_context | debugging_mode) == 0) {\n    DAT_002422c8 = 1;\n    if (bash_argv_initialized == 0) {\n      uVar1 = list_rest_of_args();\n      push_args(uVar1);\n      dispose_words(uVar1);\n      bash_argv_initialized = 1;\n    }\n    DAT_002422c8 = 0;\n  }\n  return param_1;\n}\n\n",
  "clean_simple_command": "\nint * clean_simple_command(int *param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  \n  if (*param_1 == 4) {\n    lVar2 = *(long *)(param_1 + 6);\n    plVar1 = *(long **)(lVar2 + 8);\n    if ((plVar1 != (long *)0x0) && (*plVar1 != 0)) {\n      plVar1 = (long *)list_reverse();\n      lVar2 = *(long *)(param_1 + 6);\n    }\n    *(long **)(lVar2 + 8) = plVar1;\n    plVar1 = *(long **)(lVar2 + 0x10);\n    if ((plVar1 != (long *)0x0) && (*plVar1 != 0)) {\n      plVar1 = (long *)list_reverse();\n      lVar2 = *(long *)(param_1 + 6);\n    }\n    *(long **)(lVar2 + 0x10) = plVar1;\n    parser_state = parser_state & 0xfff7ffff;\n    return param_1;\n  }\n  command_error(\"clean_simple_command\",1,*param_1,0);\n  parser_state = parser_state & 0xfff7ffff;\n  return param_1;\n}\n\n",
  "getgrent": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ngroup * getgrent(void)\n\n{\n  group *pgVar1;\n  \n  pgVar1 = (group *)(*(code *)PTR_getgrent_002378a0)();\n  return pgVar1;\n}\n\n",
  "FUN_00156420": "\nvoid FUN_00156420(char **param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char *pcVar6;\n  long lVar7;\n  undefined **ppuVar8;\n  \n  lVar3 = shell_variables;\n  lVar7 = *(long *)(shell_variables + 0x20);\n  if (lVar7 == 0) {\n    if (shell_variables == global_variables) {\n      lVar7 = hash_create(0x400);\n      *(long *)(lVar3 + 0x20) = lVar7;\n      *(long *)(shell_variables + 0x20) = lVar7;\n    }\n    else {\n      lVar7 = hash_create(4);\n      *(long *)(lVar3 + 0x20) = lVar7;\n    }\n  }\n  lVar3 = FUN_00154e30(*param_1,param_1[1],lVar7,0,0x220);\n  if (lVar3 != 0) {\n    *(undefined4 *)(lVar3 + 0x2c) = *(undefined4 *)(shell_variables + 8);\n  }\n  if (*(long *)(global_variables + 0x20) == lVar7) {\n    *(uint *)(param_1 + 5) = *(uint *)(param_1 + 5) & 0xffcfffff;\n  }\n  else {\n    *(uint *)(param_1 + 5) = *(uint *)(param_1 + 5) | 0x200000;\n    if (*(long *)(shell_variables + 0x20) == lVar7) {\n      *(uint *)(shell_variables + 0xc) = *(uint *)(shell_variables + 0xc) | 2;\n    }\n  }\n  if (lVar3 != 0) {\n    *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | *(uint *)(param_1 + 5);\n  }\n  pcVar6 = *param_1;\n  if (PTR_s_BASH_COMPAT_00238460 != (undefined *)0x0) {\n    cVar1 = *pcVar6;\n    ppuVar8 = &PTR_s_BASH_XTRACEFD_00238470;\n    pcVar5 = PTR_s_BASH_COMPAT_00238460;\n    do {\n      iVar2 = (int)*pcVar5 - (int)cVar1;\n      if (iVar2 == 0) {\n        iVar2 = strcmp(pcVar5,pcVar6);\n        if (iVar2 == 0) {\n          sVar4 = strlen(pcVar6);\n          pcVar5 = (char *)sh_xmalloc(sVar4 + 1,\"variables.c\",0x1224);\n          lVar7 = tempvar_list;\n          lVar3 = (long)tvlist_ind;\n          tvlist_ind = tvlist_ind + 1;\n          pcVar6 = strcpy(pcVar5,pcVar6);\n          *(char **)(lVar7 + lVar3 * 8) = pcVar6;\n          break;\n        }\n      }\n      if (0 < iVar2) break;\n      pcVar5 = *ppuVar8;\n      ppuVar8 = ppuVar8 + 2;\n    } while (pcVar5 != (char *)0x0);\n  }\n  dispose_variable(param_1);\n  return;\n}\n\n",
  "FUN_00192960": "\nvoid FUN_00192960(void)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = rl_completion_mode(FUN_00192960);\n  FUN_00192690(uVar1);\n  return;\n}\n\n",
  "declare_builtin": "\nvoid declare_builtin(undefined8 param_1)\n\n{\n  FUN_001a51a0(param_1,0);\n  return;\n}\n\n",
  "bash_delete_histent": "\nbool bash_delete_histent(void)\n\n{\n  long lVar1;\n  \n  lVar1 = remove_history();\n  if (lVar1 != 0) {\n    free_history_entry(lVar1);\n    history_lines_this_session = history_lines_this_session + -1;\n  }\n  return lVar1 != 0;\n}\n\n",
  "FUN_001cfcf0": "\nvoid FUN_001cfcf0(void)\n\n{\n  int iVar1;\n  \n  iVar1 = rl_end;\n  rl_vi_unix_word_rubout();\n  DAT_0024a410 = DAT_0024a410 - (iVar1 - rl_end);\n  return;\n}\n\n",
  "reset_signal_handlers": "\nvoid reset_signal_handlers(void)\n\n{\n  FUN_00181650(FUN_00180f90);\n  return;\n}\n\n",
  "rl_free_line_state": "\nvoid rl_free_line_state(void)\n\n{\n  long lVar1;\n  \n  rl_free_undo_list();\n  lVar1 = current_history();\n  if (lVar1 != 0) {\n    *(undefined8 *)(lVar1 + 0x10) = 0;\n  }\n  _rl_kill_kbd_macro();\n  rl_clear_message();\n  _rl_reset_argument();\n  return;\n}\n\n",
  "termsig_sighandler": "\nvoid termsig_sighandler(uint param_1)\n\n{\n  undefined *puVar1;\n  \n  if ((((param_1 < 0x1b) && ((0xfffffffff8ff0bf9U >> ((ulong)param_1 & 0x3f) & 1) == 0)) ||\n      (terminating_signal != param_1)) && (terminating_signal = param_1, terminate_immediately == 0)\n     ) {\nLAB_001860aa:\n    if ((CONCAT71(rl_readline_state._1_7_,(byte)rl_readline_state) & 0x8004) != 0) {\n      bashline_set_event_hook();\n      return;\n    }\n    return;\n  }\n  terminating_signal = param_1;\n  if (interactive_shell != 0) goto LAB_00186118;\n  do {\n    history_lines_this_session = 0;\n    puVar1 = (undefined *)register0x00000020;\n    do {\n      terminate_immediately = 0;\n      if (DAT_00248538 != 0) goto LAB_001860aa;\n      register0x00000020 = (BADSPACEBASE *)(puVar1 + -8);\n      *(undefined8 *)(puVar1 + -0x10) = 0x186111;\n      FUN_00185df0();\nLAB_00186118:\n    } while (((interactive != 0) && ((param_1 == 1 || (param_1 == 0xf)))) &&\n            ((no_line_editing == 0 &&\n             (puVar1 = (undefined *)register0x00000020, ((byte)rl_readline_state & 8) != 0))));\n  } while( true );\n}\n\n",
  "FUN_001745e0": "\nchar ** FUN_001745e0(char *param_1,int *param_2,uint param_3,undefined4 *param_4,int *param_5,\n                    int *param_6,undefined4 *param_7,uint param_8)\n\n{\n  mbstate_t mVar1;\n  byte bVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  ushort **ppuVar6;\n  char *pcVar7;\n  long lVar8;\n  char *pcVar9;\n  undefined2 *puVar10;\n  undefined8 uVar11;\n  long *plVar12;\n  long *plVar13;\n  char **ppcVar14;\n  undefined2 *puVar15;\n  ulong uVar16;\n  undefined *puVar17;\n  undefined8 *puVar18;\n  undefined8 *puVar19;\n  size_t sVar20;\n  undefined8 uVar21;\n  byte *pbVar22;\n  ulong uVar23;\n  char cVar24;\n  bool bVar25;\n  undefined4 uVar26;\n  int iVar27;\n  uint uVar28;\n  undefined8 uVar29;\n  bool bVar30;\n  undefined8 in_R11;\n  int iVar31;\n  int iVar32;\n  byte bVar33;\n  int iVar34;\n  uint uVar35;\n  int iVar36;\n  long in_FS_OFFSET;\n  bool bVar37;\n  bool bVar38;\n  bool bVar39;\n  bool bVar40;\n  char *local_e8;\n  uint local_e0;\n  uint local_d0;\n  uint local_cc;\n  long *local_c0;\n  int local_b0;\n  uint local_ac;\n  undefined8 *local_a8;\n  int local_90;\n  int local_8c;\n  long local_88;\n  undefined8 local_80;\n  int local_78 [2];\n  undefined8 local_70;\n  mbstate_t local_54;\n  mbstate_t local_4c;\n  undefined2 local_43;\n  undefined local_41;\n  long local_40;\n  \n  iVar34 = *param_2;\n  iVar31 = iVar34 + 1;\n  pbVar22 = (byte *)(param_1 + iVar31);\n  bVar33 = *pbVar22;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  switch(bVar33) {\n  case 0x21:\n    if (last_asynchronous_pid == -1) {\n      if (param_4 == (undefined4 *)0x0) {\n        param_4 = (undefined4 *)(ulong)unbound_vars_is_error;\n        puVar10 = (undefined2 *)0x0;\n        if (unbound_vars_is_error == 0) goto LAB_00174d94;\n      }\n      else {\n        *param_4 = 0;\n        param_4 = (undefined4 *)(ulong)unbound_vars_is_error;\n        if (unbound_vars_is_error == 0) {\n          bVar33 = *pbVar22;\n          puVar10 = (undefined2 *)0x0;\n          break;\n        }\n      }\n      if ((param_8 & 2) == 0) {\n        local_43 = 0x2124;\nLAB_00174799:\n        local_41 = 0;\n        set_exit_status(1);\n        err_unboundvar(&local_43);\nLAB_001747b8:\n        if (interactive_shell != 0) goto LAB_001748d0;\nLAB_001747c6:\n        ppcVar14 = (char **)&DAT_00247850;\n        goto LAB_00174da9;\n      }\n      bVar33 = *pbVar22;\n      param_4 = (undefined4 *)0x0;\n      puVar10 = (undefined2 *)0x0;\n    }\n    else {\n      param_4 = (undefined4 *)0x0;\n      puVar10 = (undefined2 *)itos((long)last_asynchronous_pid);\n      bVar33 = *pbVar22;\n    }\n    break;\n  default:\n    local_80 = (char *)CONCAT44(local_80._4_4_,iVar31);\n    iVar34 = iVar31;\n    if (bVar33 == 0) {\nLAB_00175134:\n      puVar10 = (undefined2 *)sh_xmalloc(2,\"subst.c\",0x29a7);\n      *puVar10 = 0x24;\n      if (param_4 == (undefined4 *)0x0) goto LAB_00174758;\n      *param_4 = 0;\n      uVar26 = 0;\n      *param_2 = iVar34;\n    }\n    else {\n      ppuVar6 = __ctype_b_loc();\n      do {\n        if (((*(byte *)(*ppuVar6 + bVar33) & 8) == 0) && (bVar33 != 0x5f)) break;\n        bVar33 = pbVar22[1];\n        iVar34 = iVar34 + 1;\n        pbVar22 = pbVar22 + 1;\n      } while (bVar33 != 0);\n      if ((iVar34 <= iVar31) ||\n         (pcVar7 = (char *)substring(param_1,iVar31,iVar34), pcVar7 == (char *)0x0))\n      goto LAB_00175134;\n      if (*pcVar7 == '\\0') {\n        sh_xfree(pcVar7,\"subst.c\",0x29a6);\n        goto LAB_00175134;\n      }\n      lVar8 = find_variable(pcVar7);\n      if (lVar8 == 0) {\n        lVar8 = find_variable_last_nameref(pcVar7,0);\n        if ((((lVar8 == 0) || (puVar10 = *(undefined2 **)(lVar8 + 8), puVar10 == (undefined2 *)0x0))\n            || ((*(uint *)(lVar8 + 0x28) & 0x1000) != 0)) || (*(char *)puVar10 == '\\0'))\n        goto LAB_001759a0;\n        iVar31 = valid_array_reference(puVar10,0);\n        if (iVar31 == 0) {\n          if ((*(char *)puVar10 == '\\0') || (iVar31 = legal_identifier(puVar10), iVar31 != 0))\n          goto LAB_001759a0;\n          set_exit_status(1);\n          report_error(\"%s: invalid variable name for name reference\",puVar10);\n          goto LAB_001748d0;\n        }\n        FUN_00168d30(puVar10,param_3,param_6,param_5);\n        if (*(char *)puVar10 == '\\0') {\nLAB_00177985:\n          uVar28 = 0;\n        }\n        else if ((byte)(*(char *)puVar10 - 0x30U) < 10) {\n          iVar31 = all_digits(puVar10);\n          uVar28 = 1;\n          if (iVar31 == 0) goto LAB_001778f8;\n        }\n        else {\nLAB_001778f8:\n          if (*(char *)((long)puVar10 + 1) != '\\0') goto LAB_00177985;\n          uVar28 = (uint)(&sh_syntaxtab)[*(byte *)puVar10] >> 0xb & 1;\n        }\n        ppcVar14 = (char **)FUN_0017bfe0(puVar10,uVar28,param_3,param_8,0);\n        if (ppcVar14 == (char **)&DAT_00247860) goto LAB_001748d0;\n        if (ppcVar14 != (char **)&DAT_00247850) {\n          *param_2 = iVar34;\n          if (ppcVar14 != (char **)0x0) goto LAB_00174da9;\n          uVar26 = 0;\n          goto LAB_00174d9b;\n        }\n        goto LAB_001747c6;\n      }\n      uVar28 = *(uint *)(lVar8 + 0x28);\n      param_4 = (undefined4 *)(ulong)(uVar28 & 0x1000);\n      if (((uVar28 & 0x1000) != 0) || (pcVar9 = *(char **)(lVar8 + 8), pcVar9 == (char *)0x0)) {\nLAB_001759a0:\n        if (unbound_vars_is_error == 0) {\n          puVar10 = (undefined2 *)0x0;\n          sh_xfree(pcVar7,\"subst.c\",0x29f5);\n          *param_2 = iVar34;\n          uVar26 = 0;\n          goto LAB_00174d9b;\n        }\nLAB_001759ae:\n        set_exit_status(1);\n        err_unboundvar(pcVar7);\n        sh_xfree(pcVar7,\"subst.c\",0x29f9);\n        set_exit_status(1);\n        if (unbound_vars_is_error == 0) goto LAB_001748d0;\n        goto LAB_001747b8;\n      }\n      if ((uVar28 & 0x44) == 0) {\n        if ((*pcVar9 == '\\0') || ((param_3 & 3) == 0)) {\n          if ((param_8 & 8) == 0) {\n            puVar10 = (undefined2 *)FUN_00167220(pcVar9,0);\n          }\n          else {\n            puVar10 = (undefined2 *)FUN_00167220(pcVar9,4);\n          }\n        }\n        else {\n          puVar10 = (undefined2 *)quote_string();\n        }\n      }\n      else {\n        if ((uVar28 & 4) == 0) {\n          pcVar9 = (char *)assoc_reference(pcVar9,&DAT_00210deb);\n        }\n        else {\n          pcVar9 = (char *)array_reference(pcVar9,0);\n        }\n        if (pcVar9 == (char *)0x0) {\n          puVar10 = (undefined2 *)0x0;\n          if (unbound_vars_is_error != 0) goto LAB_001759ae;\n        }\n        else if ((*pcVar9 == '\\0') || ((param_3 & 3) == 0)) {\n          puVar10 = (undefined2 *)FUN_00167220(pcVar9,0);\n        }\n        else {\n          puVar10 = (undefined2 *)quote_string(pcVar9);\n        }\n      }\n      sh_xfree(pcVar7,\"subst.c\",0x29cb);\nLAB_00174758:\n      uVar26 = SUB84(param_4,0);\n      *param_2 = iVar34;\n    }\n    goto LAB_00174d9b;\n  case 0x23:\n    iVar34 = number_of_args();\n    param_4 = (undefined4 *)0x0;\n    puVar10 = (undefined2 *)itos((long)iVar34);\n    bVar33 = *pbVar22;\n    break;\n  case 0x24:\n    param_4 = (undefined4 *)0x0;\n    puVar10 = (undefined2 *)itos((long)dollar_dollar_pid);\n    bVar33 = *pbVar22;\n    break;\n  case 0x28:\n    local_80 = (char *)CONCAT44(local_80._4_4_,iVar34 + 2);\n    pcVar7 = (char *)extract_command_subst(param_1,&local_80,(param_8 & 0x10) << 6);\n    iVar31 = (int)local_80;\n    if ((pcVar7 != (char *)0x0) && (*pcVar7 == '(')) {\n      sVar20 = strlen(pcVar7 + 1);\n      pcVar9 = (char *)sh_xmalloc(sVar20 + 1,\"subst.c\",0x2947);\n      pcVar9 = strcpy(pcVar9,pcVar7 + 1);\n      sVar20 = strlen(pcVar9);\n      iVar34 = (int)sVar20 + -1;\n      local_80 = (char *)CONCAT44(local_80._4_4_,iVar34);\n      if (pcVar9[iVar34] == ')') {\n        pcVar9[iVar34] = '\\0';\n        local_54.__count = 0;\n        local_54.__value = (_union_27)0x0;\n        if (0 < iVar34) {\n          iVar32 = 0;\n          iVar36 = 0;\n          do {\n            mVar1 = local_54;\n            bVar33 = pcVar9[iVar36];\n            if (bVar33 == 0x28) {\n              iVar32 = iVar32 + 1;\nLAB_001760c7:\n              if (locale_mb_cur_max < 2) {\nLAB_00176108:\n                iVar3 = iVar36 + 1;\n              }\n              else {\n                if ((*(uint *)(is_basic_table + (ulong)(bVar33 >> 5) * 4) >> (bVar33 & 0x1f) & 1) ==\n                    0) {\n                  if ((locale_utf8locale != 0) && (-1 < (char)bVar33)) {\n                    if (bVar33 == 0) goto LAB_00176108;\n                    goto LAB_00176288;\n                  }\n                  sVar20 = mbrtowc((wchar_t *)0x0,pcVar9 + iVar36,(long)(iVar34 - iVar36),&local_54)\n                  ;\n                  if (0xfffffffffffffffd < sVar20) {\n                    local_54 = mVar1;\n                    iVar3 = iVar36 + 1;\n                    goto LAB_00176090;\n                  }\n                  if (sVar20 == 0) goto LAB_00176108;\n                }\n                else {\nLAB_00176288:\n                  sVar20 = 1;\n                }\n                iVar3 = iVar36 + (int)sVar20;\n              }\n            }\n            else {\n              if (bVar33 == 0x29) {\n                bVar39 = iVar32 != 0;\n                iVar32 = iVar32 + -1;\n                if (bVar39) goto LAB_001760c7;\n                goto LAB_00176261;\n              }\n              if (bVar33 == 0x27) {\n                iVar36 = iVar36 + 1;\n                local_4c.__count = 0;\n                local_4c.__value = (_union_27)0x0;\n                lVar8 = (long)iVar36;\n                pbVar22 = (byte *)(pcVar9 + lVar8);\n                bVar33 = *pbVar22;\n                if ((bVar33 != 0x27) && (bVar33 != 0)) {\n                  do {\n                    mVar1 = local_4c;\n                    if (locale_mb_cur_max < 2) {\nLAB_001761d7:\n                      iVar36 = iVar36 + 1;\n                    }\n                    else {\n                      if ((*(uint *)(is_basic_table + (ulong)(bVar33 >> 5) * 4) >> (bVar33 & 0x1f) &\n                          1) == 0) {\n                        if ((locale_utf8locale == 0) || (iVar3 = 1, (char)bVar33 < '\\0')) {\n                          sVar20 = mbrtowc((wchar_t *)0x0,(char *)pbVar22,iVar34 - lVar8,&local_4c);\n                          if (0xfffffffffffffffd < sVar20) {\n                            iVar36 = iVar36 + 1;\n                            local_4c = mVar1;\n                            goto LAB_001761bb;\n                          }\n                          iVar3 = (int)sVar20;\n                          if (sVar20 == 0) goto LAB_001761d7;\n                        }\n                      }\n                      else {\n                        iVar3 = 1;\n                      }\n                      iVar36 = iVar36 + iVar3;\n                    }\nLAB_001761bb:\n                    lVar8 = (long)iVar36;\n                    pbVar22 = (byte *)(pcVar9 + lVar8);\n                    bVar33 = *pbVar22;\n                  } while ((bVar33 != 0) && (bVar33 != 0x27));\n                }\n                iVar3 = (iVar36 + 1) - (uint)(bVar33 == 0);\n              }\n              else if (bVar33 == 0x5c) {\n                iVar27 = iVar36 + 1;\n                bVar33 = pcVar9[iVar27];\n                local_54 = mVar1;\n                iVar3 = iVar27;\n                if (bVar33 != 0) {\n                  if (locale_mb_cur_max < 2) {\n                    iVar3 = iVar36 + 2;\n                  }\n                  else {\n                    if ((*(uint *)(is_basic_table + (ulong)(bVar33 >> 5) * 4) >> (bVar33 & 0x1f) & 1\n                        ) == 0) {\n                      if ((locale_utf8locale == 0) || (sVar20 = 1, (char)bVar33 < '\\0')) {\n                        sVar20 = mbrtowc((wchar_t *)0x0,pcVar9 + iVar27,(long)(iVar34 - iVar27),\n                                         &local_54);\n                        if (sVar20 < 0xfffffffffffffffe) {\n                          iVar3 = iVar36 + 2;\n                          if (sVar20 != 0) goto LAB_00176083;\n                        }\n                        else {\n                          local_54 = mVar1;\n                          iVar3 = iVar36 + 2;\n                        }\n                        goto LAB_00176090;\n                      }\n                    }\n                    else {\n                      sVar20 = 1;\n                    }\nLAB_00176083:\n                    iVar3 = iVar27 + (int)sVar20;\n                  }\n                }\n              }\n              else {\n                if (bVar33 != 0x22) goto LAB_001760c7;\n                iVar3 = FUN_0016a7c0(pcVar9,(long)iVar34,iVar36 + 1,0);\n              }\n            }\nLAB_00176090:\n            iVar36 = iVar3;\n          } while (iVar3 < iVar34);\n          if (iVar32 != 0) {\nLAB_00176261:\n            sh_xfree(pcVar9,\"subst.c\",0x2955);\n            goto LAB_00174e73;\n          }\n        }\n        uVar21 = expand_arith_string(pcVar9,0x101);\n        sh_xfree(pcVar9,\"subst.c\",0x295e);\n        goto LAB_0017483a;\n      }\n      sh_xfree(pcVar9,\"subst.c\",0x294c);\n    }\nLAB_00174e73:\n    if ((param_8 & 1) == 0) {\n      puVar10 = (undefined2 *)0x0;\n      puVar19 = (undefined8 *)command_substitute(pcVar7,param_3,param_8 & 8);\n      if (puVar19 != (undefined8 *)0x0) {\n        puVar10 = (undefined2 *)*puVar19;\n        dispose_word_desc(puVar19);\n      }\n    }\n    else {\n      puVar10 = (undefined2 *)substring(param_1,*param_2,iVar31 + 1);\n    }\n    if (pcVar7 != (char *)0x0) {\n      sh_xfree(pcVar7,\"subst.c\",0x2983);\n    }\n    bVar33 = param_1[iVar31];\n    param_4 = (undefined4 *)0x0;\n    break;\n  case 0x2a:\n    plVar12 = (long *)list_rest_of_args();\n    if (((param_3 & 3) == 0) || (plVar12 != (long *)0x0)) {\n      param_4 = (undefined4 *)(ulong)(param_3 & 0xb);\n      if ((param_3 & 0xb) == 0) {\n        if (DAT_00247848 == 0) {\n          puVar15 = (undefined2 *)string_list_dollar_at(plVar12,param_3,0);\n          puVar10 = puVar15;\n          if (param_3 == 0) {\nLAB_00174f2f:\n            puVar10 = puVar15;\n            if (ifs_is_null == 0) {\n              if (puVar15 == (undefined2 *)0x0) {\nLAB_00176b23:\n                puVar10 = (undefined2 *)0x0;\n              }\n              else {\n                param_4 = (undefined4 *)(ulong)ifs_is_set;\n                if ((ifs_is_set != 0) &&\n                   (param_4 = (undefined4 *)(ulong)(param_8 & 8), (param_8 & 8) != 0)) {\n                  param_4 = (undefined4 *)0x0;\n                  puVar10 = (undefined2 *)quote_string(puVar15);\n                  sh_xfree(puVar15,\"subst.c\",0x28b4);\n                }\n              }\n            }\n            else {\n              param_4 = (undefined4 *)&DAT_00000008;\n            }\n          }\n        }\n        else if (param_3 == 0) {\n          if (ifs_is_set == 0) {\n            if ((param_8 & 8) == 0) {\n              if (ifs_is_null != 0) goto LAB_00176552;\nLAB_001758f7:\n              if (ifs_firstc != '\\0') {\n                puVar15 = (undefined2 *)string_list_dollar_at(plVar12,0,0);\n                goto LAB_00174f2f;\n              }\n              goto LAB_00175db8;\n            }\n            pcVar7 = (char *)FUN_0016e2d0(plVar12);\n            if (pcVar7 == (char *)0x0) goto LAB_00176b23;\n            puVar10 = (undefined2 *)quote_string(pcVar7);\n            uVar28 = 0;\n            if ((*pcVar7 == '\\0') && (*(char *)puVar10 == '\\x7f')) {\n              uVar28 = (uint)(*(char *)((long)puVar10 + 1) == '\\0') << 0x15;\n            }\n            sh_xfree(pcVar7,\"subst.c\",0x2887);\n            param_4 = (undefined4 *)(ulong)uVar28;\n          }\n          else if (ifs_is_null == 0) {\n            if ((param_8 & 8) == 0) goto LAB_001758f7;\n            pcVar7 = (char *)FUN_0016e2d0(plVar12);\n            if (pcVar7 == (char *)0x0) goto LAB_00176b23;\n            puVar10 = (undefined2 *)quote_string(pcVar7);\n            uVar28 = 0;\n            if ((*pcVar7 == '\\0') && (*(char *)puVar10 == '\\x7f')) {\n              uVar28 = (uint)(*(char *)((long)puVar10 + 1) == '\\0') << 0x15;\n            }\n            sh_xfree(pcVar7,\"subst.c\",0x2899);\n            param_4 = (undefined4 *)(ulong)uVar28;\n          }\n          else {\nLAB_00176552:\n            if ((param_8 & 8) == 0) goto LAB_001758f7;\n            lVar8 = FUN_0016e2d0(plVar12);\n            if (lVar8 == 0) goto LAB_00176b23;\n            param_4 = (undefined4 *)0x0;\n            puVar10 = (undefined2 *)FUN_00167220(lVar8,0);\n            sh_xfree(lVar8,\"subst.c\",0x288e);\n          }\n        }\n        else if (ifs_firstc == '\\0') {\nLAB_00175db8:\n          puVar10 = (undefined2 *)FUN_0016e2d0(plVar12);\n        }\n        else {\n          puVar10 = (undefined2 *)string_list_dollar_at(plVar12,param_3,0);\n        }\n        if ((DAT_00247848 == 0) && (param_5 != (int *)0x0)) {\n          *param_5 = 1;\n        }\n      }\n      else {\n        if ((param_3 & 9) == 0) {\n          puVar10 = (undefined2 *)string_list_internal(plVar12,&DAT_001fdb1c);\n        }\n        else {\n          puVar10 = (undefined2 *)FUN_0016e2d0(plVar12);\n        }\n        if (puVar10 == (undefined2 *)0x0) goto LAB_00174eeb;\n        if ((param_3 & 1) == 0) {\n          param_4 = (undefined4 *)((ulong)(*(char *)puVar10 == '\\0') << 0x12);\n        }\n        else {\n          puVar15 = (undefined2 *)quote_string(puVar10);\n          param_4 = (undefined4 *)((ulong)(*(char *)puVar10 == '\\0') << 0x12);\n          if (puVar10 != puVar15) {\n            sh_xfree(puVar10,\"subst.c\",0x2873);\n            puVar10 = puVar15;\n          }\n        }\n      }\n    }\n    else {\nLAB_00174eeb:\n      param_4 = (undefined4 *)0x0;\n      puVar10 = (undefined2 *)0x0;\n    }\n    goto LAB_0017503a;\n  case 0x2d:\n    puVar10 = (undefined2 *)which_set_flags();\n    param_4 = (undefined4 *)0x0;\n    bVar33 = *pbVar22;\n    break;\n  case 0x30:\n  case 0x31:\n  case 0x32:\n  case 0x33:\n  case 0x34:\n  case 0x35:\n  case 0x36:\n  case 0x37:\n  case 0x38:\n  case 0x39:\n    param_4 = (undefined4 *)(ulong)unbound_vars_is_error;\n    puVar10 = (undefined2 *)(&dollar_vars)[(int)(bVar33 - 0x30)];\n    if (unbound_vars_is_error != 0) {\n      if (puVar10 == (undefined2 *)0x0) {\n        local_43 = CONCAT11(bVar33,0x24);\n        goto LAB_00174799;\n      }\nLAB_00175059:\n      if ((*(char *)puVar10 == '\\0') || ((param_3 & 3) == 0)) {\n        param_4 = (undefined4 *)0x0;\n        puVar10 = (undefined2 *)FUN_00167220(puVar10,0);\n        bVar33 = *pbVar22;\n      }\n      else {\n        param_4 = (undefined4 *)0x0;\n        puVar10 = (undefined2 *)quote_string(puVar10);\n        bVar33 = *pbVar22;\n      }\n      break;\n    }\n    if (puVar10 != (undefined2 *)0x0) goto LAB_00175059;\n    goto LAB_00174d94;\n  case 0x3f:\n    param_4 = (undefined4 *)0x0;\n    puVar10 = (undefined2 *)itos((long)last_command_exit_value);\n    bVar33 = *pbVar22;\n    break;\n  case 0x40:\n    plVar12 = (long *)list_rest_of_args();\n    if (plVar12 == (long *)0x0) {\n      iVar34 = 0;\n    }\n    else {\n      iVar34 = 0;\n      plVar13 = plVar12;\n      do {\n        if ((char **)plVar13[1] != (char **)0x0) {\n          pcVar7 = *(char **)plVar13[1];\n          if (pcVar7 == (char *)0x0) {\n            iVar34 = 1;\n          }\n          else if (*pcVar7 == '\\0') {\n            iVar34 = 1;\n          }\n        }\n        plVar13 = (long *)*plVar13;\n      } while (plVar13 != (long *)0x0);\n    }\n    if ((param_6 != (int *)0x0) && ((param_3 & 3) != 0)) {\n      *param_6 = 1;\n    }\n    if (param_5 != (int *)0x0) {\n      *param_5 = 1;\n    }\n    if ((param_8 & 8) == 0) {\n      if ((((param_8 & 4) == 0) || (ifs_is_set == 0)) ||\n         (((param_3 | ifs_is_null) != 0 || (ifs_firstc == ' ')))) {\n        param_4 = (undefined4 *)0x100;\n        puVar10 = (undefined2 *)string_list_dollar_at(plVar12,param_3,param_8);\n      }\n      else {\n        param_4 = (undefined4 *)0x100;\n        puVar10 = (undefined2 *)string_list_dollar_at(plVar12,1,param_8);\n      }\n    }\n    else {\n      param_4 = (undefined4 *)((ulong)(uint)(iVar34 << 0x12) | 0x100);\n      puVar10 = (undefined2 *)string_list_dollar_at(plVar12,param_3 | 1,param_8);\n    }\nLAB_0017503a:\n    dispose_words(plVar12);\n    bVar33 = *pbVar22;\n    break;\n  case 0x5b:\n    local_80 = (char *)CONCAT44(local_80._4_4_,iVar34 + 2);\n    pcVar7 = (char *)FUN_0016b780(param_1,&local_80,&DAT_001fe093,&DAT_0021404a,\"]\",0);\n    iVar31 = (int)local_80;\n    if (pcVar7 != (char *)0x0) {\n      uVar21 = expand_arith_string(pcVar7,0x101);\nLAB_0017483a:\n      uVar29 = this_command_name;\n      this_command_name = (undefined2 *)0x0;\n      uVar11 = evalexp(uVar21,shell_compatibility_level < 0x34,local_78);\n      this_command_name = (undefined2 *)uVar29;\n      sh_xfree(pcVar7,\"subst.c\",0x2968);\n      sh_xfree(uVar21,\"subst.c\",0x2969);\n      if (local_78[0] != 0) {\n        param_4 = (undefined4 *)0x0;\n        puVar10 = (undefined2 *)itos(uVar11);\n        bVar33 = param_1[iVar31];\n        break;\n      }\n      if ((interactive_shell == 0) && (posixly_correct != 0)) {\n        ppcVar14 = (char **)&DAT_00247850;\n        set_exit_status(1);\n        goto LAB_00174da9;\n      }\n      goto LAB_001748d0;\n    }\n    sVar20 = strlen(param_1);\n    pcVar7 = (char *)sh_xmalloc(sVar20 + 1,\"subst.c\",0x2990);\n    puVar10 = (undefined2 *)strcpy(pcVar7,param_1);\n    if (param_4 != (undefined4 *)0x0) {\n      *param_4 = 0;\n      uVar26 = 0;\n      *param_2 = iVar31;\n      goto LAB_00174d9b;\n    }\n    goto LAB_00174d98;\n  case 0x7b:\n    iVar34 = iVar34 + 2;\n    local_90 = iVar34;\n    local_8c = iVar34;\n    if (param_1[iVar34] == '#') {\n      ppuVar6 = __ctype_b_loc();\n      if (((*(byte *)((long)*ppuVar6 + (ulong)(byte)param_1[(long)iVar34 + 1] * 2 + 1) & 4) == 0) &&\n         (param_1[(long)iVar34 + 1] != 0x5f)) goto LAB_00174940;\n      puVar10 = (undefined2 *)FUN_0016b540(param_1,&local_90,&DAT_0020ef45,2);\n    }\n    else {\nLAB_00174940:\n      puVar10 = (undefined2 *)FUN_0016b540(param_1,&local_90,\"#%^,~:-=?+/@}\",2);\n    }\n    if (*(char *)puVar10 == '\\0') {\n      if ((local_8c == local_90) && (param_1[local_8c] == '@')) {\n        puVar10 = (undefined2 *)sh_xrealloc(puVar10,2,\"subst.c\",0x255b);\n        *puVar10 = 0x40;\n        local_90 = local_90 + 1;\n      }\n    }\n    else if ((((*(char *)puVar10 == '!') && (local_8c < local_90)) && (param_1[local_90] == '@')) &&\n            (param_1[(long)local_90 + 1] == '}')) {\n      puVar10 = (undefined2 *)\n                sh_xrealloc(puVar10,(long)((local_90 - local_8c) + 2),\"subst.c\",0x2562);\n      *(undefined *)((long)puVar10 + (long)(local_90 - local_8c)) = 0x40;\n      *(undefined *)((long)puVar10 + (long)(local_90 - local_8c) + 1) = 0;\n      local_90 = local_90 + 1;\n    }\n    init_eltstate(local_78);\n    local_70 = 0x8000000000000000;\n    if (local_8c == local_90) {\n      lVar8 = (long)local_90;\n      bVar33 = param_1[lVar8];\n      if (0x1d < (byte)(bVar33 - 0x23)) {\n        if (bVar33 == 0x23) {\nLAB_00175859:\n          if (((byte)((byte)param_1[lVar8 + 1] - 0x23) < 0x1e) &&\n             ((0xffffffffcffffbfeU >> ((ulong)((byte)param_1[lVar8 + 1] - 0x23) & 0x3f) & 1) == 0))\n          goto LAB_0017543e;\n        }\n        goto LAB_001749f1;\n      }\n      if ((0xffffffffcffffbfeU >> ((ulong)(bVar33 - 0x23) & 0x3f) & 1) == 0) goto LAB_0017543e;\n      if (param_1[lVar8] == '#') goto LAB_00175859;\n      uVar28 = (uint)(char)bVar33;\nLAB_001749fe:\n      local_8c = local_90 + 1;\n      if (uVar28 == 0x3a) {\n        bVar33 = param_1[local_8c];\n        uVar4 = (&sh_syntaxtab)[bVar33] & 0x1000;\n        if (((&sh_syntaxtab)[bVar33] & 0x1000) == 0) {\n          local_cc = 0;\n          uVar5 = 0;\n          local_d0 = (uint)(bVar33 != 0x7d);\n          bVar39 = false;\n        }\n        else {\n          uVar28 = (uint)(char)bVar33;\n          if (bVar33 != 0) {\n            local_8c = local_90 + 2;\n          }\n          uVar4 = 0;\n          local_cc = 0;\n          uVar5 = 0;\n          local_d0 = 0;\n          bVar39 = true;\n        }\n      }\n      else if (uVar28 == 0x2f) {\n        uVar4 = 0;\n        local_cc = 0;\n        uVar5 = 1;\n        local_d0 = 0;\n        bVar39 = false;\n      }\n      else {\n        uVar4 = uVar28;\n        if ((uVar28 != 0x5e) && (uVar28 != 0x2c)) {\n          if (uVar28 != 0x7e) {\n            if ((uVar28 != 0x40) || ((param_1[local_8c] & 0xdfU) != 0x41)) goto LAB_0017525f;\n            local_cc = 0;\n            uVar5 = 0;\n            uVar4 = (uint)(param_1[(long)local_8c + 1] == '}') << 6;\n            local_d0 = 0;\n            bVar39 = false;\n            goto LAB_00174a70;\n          }\n          local_ac = 0x7e;\n          uVar4 = local_ac;\n        }\n        local_ac = uVar4;\n        uVar4 = 0;\n        local_cc = 1;\n        uVar5 = 0;\n        local_d0 = 0;\n        bVar39 = false;\n      }\n    }\n    else {\n      bVar33 = param_1[local_90];\n      if (((local_8c == local_90 + -1) && (param_1[local_8c] == '!')) &&\n         ((((posixly_correct == 0 && ((bVar33 == 0x23 || (bVar33 == 0x3f)))) || (bVar33 == 0x40)) ||\n          (bVar33 == 0x2a)))) {\nLAB_0017543e:\n        local_90 = local_90 + 1;\n        pcVar7 = (char *)FUN_0016b540(param_1,&local_90,\"#%:-=?+/@}\",0);\n        sVar20 = strlen(pcVar7);\n        puVar10 = (undefined2 *)sh_xrealloc(puVar10,sVar20 + 3,\"subst.c\",0x257b);\n        *(char *)puVar10 = param_1[local_8c];\n        if (param_1[local_8c] == '!') {\n          *(char *)((long)puVar10 + 1) = param_1[(long)local_8c + 1];\n          strcpy((char *)(puVar10 + 1),pcVar7);\n        }\n        else {\n          strcpy((char *)((long)puVar10 + 1),pcVar7);\n        }\n        sh_xfree(pcVar7,\"subst.c\",0x2585);\n        bVar33 = param_1[local_90];\n      }\nLAB_001749f1:\n      uVar28 = (uint)(char)bVar33;\n      local_8c = local_90;\n      if (bVar33 != 0) goto LAB_001749fe;\nLAB_0017525f:\n      uVar4 = 0;\n      local_cc = 0;\n      uVar5 = 0;\n      local_d0 = 0;\n      bVar39 = false;\n    }\nLAB_00174a70:\n    cVar24 = *(char *)puVar10;\n    if (cVar24 == '#') {\n      if ((*(char *)((long)puVar10 + 1) != '\\0') || (bVar39 != false)) {\nLAB_0017533b:\n        cVar24 = *(char *)puVar10;\nLAB_0017533f:\n        if ((9 < (byte)(cVar24 - 0x30U)) || (iVar34 = all_digits(puVar10), iVar34 == 0)) {\nLAB_00175531:\n          bVar33 = *(byte *)puVar10;\n          if (*(char *)((long)puVar10 + 1) != '\\0') {\n            bVar25 = false;\n            goto LAB_00175366;\n          }\n          if (((&sh_syntaxtab)[bVar33] & 0x800) == 0) {\n            bVar25 = false;\n            goto LAB_00175366;\n          }\n          if (bVar33 != 0x23) {\n            bVar38 = false;\n            goto LAB_00175737;\n          }\n          bVar25 = true;\n          uVar35 = 0;\n          goto LAB_00174a93;\n        }\n        bVar33 = *(byte *)puVar10;\n        bVar25 = true;\nLAB_00175366:\n        bVar38 = false;\n        if (bVar33 != 0x23) {\nLAB_0017573c:\n          if (bVar33 != 0x40) goto LAB_001755a4;\n          uVar35 = 0;\n          if (*(char *)((long)puVar10 + 1) == '\\0') {\n            if (((param_3 & 3) != 0) && (param_6 != (int *)0x0)) {\n              *param_6 = 1;\n            }\n            uVar35 = 0x100;\n            if (param_5 != (int *)0x0) {\n              *param_5 = 1;\n            }\n          }\n          goto LAB_001755b0;\n        }\n        bVar33 = *(byte *)((long)puVar10 + 1);\n        if (bVar33 == 0) goto LAB_00174a90;\n        if ((param_1[(long)local_8c + -1] != '}') ||\n           (((((*(byte *)((long)&sh_syntaxtab + (ulong)bVar33 * 4 + 1) & 8) == 0 ||\n              (*(char *)(puVar10 + 1) != '\\0')) &&\n             ((lVar8 = (long)puVar10 + 1, 9 < (byte)(bVar33 - 0x30) ||\n              (iVar34 = all_digits(lVar8), iVar34 == 0)))) &&\n            ((iVar34 = valid_array_reference(lVar8,0), iVar34 == 0 &&\n             (iVar34 = legal_identifier(lVar8), iVar34 == 0)))))) goto LAB_001752a0;\n        lVar8 = FUN_0017b800(puVar10);\n        if (lVar8 != -0x8000000000000000) {\n          sh_xfree(puVar10,\"subst.c\",0x25e2);\n          local_b0 = local_8c;\n          if (-1 < lVar8) {\n            ppcVar14 = (char **)alloc_word_desc();\n            pcVar7 = (char *)itos(lVar8);\n            *ppcVar14 = pcVar7;\n            goto LAB_00174ce0;\n          }\n          goto LAB_001748d0;\n        }\n        if (unbound_vars_is_error == 0) {\n          sh_xfree(puVar10,\"subst.c\",0x25e2);\n          goto LAB_001748d0;\n        }\n        set_exit_status(1);\n        err_unboundvar((long)puVar10 + 1);\n        uVar21 = 0x25df;\nLAB_00175e35:\n        sh_xfree(puVar10,\"subst.c\",uVar21);\n        goto LAB_001747b8;\n      }\n      if ((uVar28 - 0x23 < 0x1e) && ((0x30000401UL >> ((ulong)(uVar28 - 0x23) & 0x3f) & 1) != 0)) {\n        if (param_1[local_8c] == '}') {\n          puVar10 = (undefined2 *)sh_xrealloc(puVar10,3,\"subst.c\");\n          *(char *)((long)puVar10 + 1) = (char)uVar28;\n          *(undefined *)(puVar10 + 1) = 0;\n          lVar8 = (long)local_8c;\n          local_8c = local_8c + 1;\n          uVar28 = (uint)param_1[lVar8];\n          cVar24 = *(char *)puVar10;\n          if (cVar24 != '#') goto LAB_00174a7d;\n          goto LAB_00175d74;\n        }\n      }\n      else {\nLAB_00175d74:\n        if ((*(char *)((long)puVar10 + 1) != '\\0') || (uVar28 == 0)) goto LAB_0017533b;\n      }\n      lVar8 = mbschr(&DAT_001fe10a,uVar28);\n      if ((lVar8 == 0) || (param_1[local_8c] != '}')) {\n        cVar24 = *(char *)puVar10;\n        goto LAB_00174a7d;\n      }\nLAB_001752a0:\n      set_exit_status(1);\n      if (param_1 == (char *)0x0) {\n        report_error(\"%s: bad substitution\",&DAT_001fa094);\n      }\n      else {\n        report_error(\"%s: bad substitution\",param_1);\n      }\nLAB_001752c4:\n      sh_xfree(puVar10,\"subst.c\",0x272b);\n      flush_eltstate(local_78);\n      if ((0x2b < shell_compatibility_level) && (posixly_correct != 0)) goto LAB_001747b8;\n    }\n    else {\nLAB_00174a7d:\n      if (cVar24 == '!') {\n        ppuVar6 = __ctype_b_loc();\n        bVar2 = *(byte *)((long)puVar10 + 1);\n        bVar33 = 0x21;\n        if (((((((*(byte *)((long)*ppuVar6 + (ulong)bVar2 * 2 + 1) & 4) == 0) && (bVar2 != 0x5f)) &&\n              (9 < (byte)(bVar2 - 0x30))) &&\n             ((posixly_correct != 0 || ((bVar2 != 0x23 && (bVar2 != 0x3f)))))) && (bVar2 != 0x2a))\n           && (bVar2 != 0x40)) goto LAB_00175531;\n        if (bVar2 == 0) {\n          if ((DAT_002394a4 & 0x800) == 0) {\n            bVar2 = *(byte *)(puVar10 + 1);\n            bVar38 = true;\n            bVar25 = false;\n            if (bVar2 == 0) goto LAB_00175e50;\n            goto LAB_001755a4;\n          }\n          bVar38 = true;\nLAB_00175737:\n          bVar25 = true;\n          goto LAB_0017573c;\n        }\n        if (*(char *)(puVar10 + 1) == '\\0') {\nLAB_00175e50:\n          if ((posixly_correct == 0) && ((bVar2 == 0x23 || (bVar2 == 0x3f)))) {\n            bVar38 = true;\n            bVar25 = true;\n          }\n          else {\n            bVar38 = true;\n            bVar25 = bVar2 == 0x40 || bVar2 == 0x2a;\n          }\n        }\n        else {\n          bVar38 = true;\n          bVar25 = false;\n        }\nLAB_001755a4:\n        uVar35 = 0;\nLAB_001755b0:\n        if (!bVar38) goto LAB_00174a93;\n        pcVar7 = (char *)((long)puVar10 + 1);\n        if (param_1[(long)local_8c + -1] == '}') {\n          cVar24 = param_1[(long)local_8c + -2];\n          if ((cVar24 != '*') && (cVar24 != '@')) {\nLAB_00175a47:\n            if ((cVar24 == ']') && (iVar34 = valid_array_reference(pcVar7,0), iVar34 != 0)) {\n              sVar20 = strlen(pcVar7);\n              pcVar9 = (char *)sh_xmalloc(sVar20 + 1,\"subst.c\",0x2628);\n              pcVar9 = strcpy(pcVar9,pcVar7);\n              lVar8 = array_variable_name(pcVar9,0,&local_80,0);\n              if (lVar8 != 0) {\n                sh_xfree(lVar8,\"subst.c\",0x262a);\n              }\n              if (((*local_80 == '@') || (*local_80 == '*')) && (local_80[1] == ']')) {\n                pcVar7 = (char *)array_keys(pcVar9,param_3,param_8);\n                if (*local_80 == '@') {\n                  if (((param_3 & 3) != 0) && (param_6 != (int *)0x0)) {\n                    *param_6 = 1;\n                  }\n                  if (param_5 == (int *)0x0) {\n                    uVar35 = 0x100;\n                  }\n                  else {\n                    *param_5 = 1;\n                    uVar35 = 0x100;\n                  }\n                }\n                sh_xfree(puVar10,\"subst.c\",0x2638);\n                sh_xfree(pcVar9,\"subst.c\",0x2639);\n                local_b0 = local_8c;\n                ppcVar14 = (char **)alloc_word_desc();\n                *(uint *)(ppcVar14 + 1) = uVar35;\n                *ppcVar14 = pcVar7;\n                goto LAB_00174ce0;\n              }\n              sh_xfree(pcVar9,\"subst.c\",0x2642);\n            }\n            goto LAB_001755cf;\n          }\n          ppuVar6 = __ctype_b_loc();\n          if (((*(byte *)((long)*ppuVar6 + (ulong)*(byte *)((long)puVar10 + 1) * 2 + 1) & 4) == 0)\n             && (*(byte *)((long)puVar10 + 1) != 0x5f)) goto LAB_00175a47;\n          sVar20 = strlen(pcVar7);\n          pcVar9 = (char *)sh_xmalloc(sVar20 + 1,\"subst.c\",0x2603);\n          pcVar7 = strcpy(pcVar9,pcVar7);\n          sVar20 = strlen(pcVar7);\n          pcVar7[sVar20 - 1] = '\\0';\n          uVar21 = all_variables_matching_prefix(pcVar7);\n          uVar29 = strvec_to_word_list(uVar21,0,0);\n          if (param_1[(long)local_8c + -2] == '*') {\n            pcVar9 = (char *)FUN_0016e2d0(uVar29);\n          }\n          else {\n            pcVar9 = (char *)string_list_dollar_at(uVar29,param_3,0);\n            if (((param_3 & 3) != 0) && (param_6 != (int *)0x0)) {\n              *param_6 = 1;\n            }\n            uVar35 = 0x100;\n            if (param_5 != (int *)0x0) {\n              *param_5 = 1;\n            }\n          }\n          sh_xfree(uVar21,\"subst.c\",0x2614);\n          dispose_words(uVar29);\n          sh_xfree(pcVar7,\"subst.c\",0x2616);\n          local_b0 = local_8c;\n          sh_xfree(puVar10,\"subst.c\",0x2619);\n          ppcVar14 = (char **)alloc_word_desc();\n          *(uint *)(ppcVar14 + 1) = uVar35;\n          *ppcVar14 = pcVar9;\n          goto LAB_00174ce0;\n        }\nLAB_001755cf:\n        iVar34 = FUN_001683d0(pcVar7,bVar25);\n        if (((iVar34 == 0) ||\n            (ppcVar14 = (char **)FUN_0017ef50(pcVar7,bVar25,param_3,uVar4 | param_8,param_6,param_5)\n            , ppcVar14 == (char **)&DAT_00247850)) || (ppcVar14 == (char **)&DAT_00247860))\n        goto LAB_001752a0;\n        if ((ppcVar14 != (char **)0x0) && (*(uint *)(ppcVar14 + 1) != 0)) {\n          *(uint *)(ppcVar14 + 1) = *(uint *)(ppcVar14 + 1) & 0xfeffffff;\n        }\n        bVar38 = false;\n        if (param_5 != (int *)0x0) {\n          bVar38 = *param_5 != 0;\n        }\nLAB_0017566a:\n        if (ppcVar14 == (char **)0x0) goto LAB_00174afb;\n        local_e8 = *ppcVar14;\n        uVar35 = *(uint *)(ppcVar14 + 1);\n        dispose_word_desc();\n        if (local_e8 != &DAT_0024784f) {\n          if (local_e8 == &DAT_0024784e) {\n            sh_xfree(puVar10,\"subst.c\",0x2678);\n            goto LAB_001747c6;\n          }\n          bVar40 = local_e8 != (char *)0x0;\n          goto LAB_00174b09;\n        }\n        sh_xfree(puVar10,\"subst.c\",0x2678);\n        goto LAB_001748d0;\n      }\n      if (cVar24 != '\\0') goto LAB_0017533f;\n      bVar25 = false;\nLAB_00174a90:\n      uVar35 = 0;\nLAB_00174a93:\n      iVar34 = FUN_001683d0(puVar10,bVar25);\n      if (iVar34 == 0) goto LAB_001752a0;\n      ppcVar14 = (char **)FUN_0017bfe0(puVar10,bVar25,param_3,param_8 & 0xc | uVar4 | 2);\n      if (ppcVar14 == (char **)&DAT_00247860) {\n        bVar38 = false;\n        uVar35 = 0;\n      }\n      else {\n        bVar38 = false;\n        if (ppcVar14 != (char **)&DAT_00247850) goto LAB_0017566a;\n        uVar35 = 0;\n      }\nLAB_00174afb:\n      bVar40 = false;\n      local_e8 = (char *)0x0;\nLAB_00174b09:\n      iVar34 = valid_array_reference(puVar10,0);\n      if (iVar34 != 0) {\n        uVar4 = param_3 | 1;\n        if ((param_8 & 8) == 0) {\n          uVar4 = param_3;\n        }\n        lVar8 = mbschr(puVar10,0x5b);\n        if ((lVar8 != 0) &&\n           (((cVar24 = *(char *)(lVar8 + 1), cVar24 == '@' || (cVar24 == '*')) &&\n            (*(char *)(lVar8 + 2) == ']')))) {\n          if ((DAT_00247848 == 0) || (cVar24 != '*')) {\n            bVar38 = true;\n          }\n          else {\n            bVar38 = true;\n            uVar4 = uVar4 | 1;\n          }\n        }\n        FUN_00168d30(puVar10,uVar4,param_6,param_5);\n      }\n      bVar30 = false;\n      if ((bVar39 != false) && (bVar30 = bVar39, local_e8 != (char *)0x0)) {\n        bVar37 = *local_e8 == '\\0';\n        if ((bVar25 == false) || (!bVar40)) {\nLAB_00174bb6:\n          bVar30 = bVar37;\n          if ((param_3 & 3) != 0) {\nLAB_00174bbc:\n            if (((*local_e8 == '\\x7f') && (local_e8[1] == '\\0')) &&\n               (iVar34 = valid_array_reference(puVar10,0), iVar34 != 0)) {\n              iVar34 = FUN_00168d30(puVar10,0,0,0);\n              bVar30 = (bool)(bVar30 | iVar34 != 0);\n            }\n          }\n        }\n        else {\n          bVar30 = bVar37;\n          if ((param_3 & 3) != 0) {\n            if ((*local_e8 != '\\x7f') || (bVar30 = bVar39, local_e8[1] != '\\0')) goto LAB_00174bb6;\n            goto LAB_00174bbc;\n          }\n        }\n      }\n      if ((uVar28 != 0) && (uVar28 != 0x7d)) {\n        if (uVar28 - 0x23 < 0x3c) {\n          iVar34 = (-(uint)((0x800000000801205U >> ((byte)(uVar28 - 0x23) & 0x3f) & 1) == 0) &\n                   0xffffff00) + 0x300;\n        }\n        else {\n          iVar34 = 0x200;\n        }\n        local_c0 = (long *)FUN_001691b0(param_1,&local_8c,param_3,iVar34);\n        if (param_1[local_8c] == '}') {\n          local_8c = local_8c + 1;\n          goto LAB_00174c53;\n        }\n        goto LAB_00175bd8;\n      }\n      local_c0 = (long *)0x0;\nLAB_00174c53:\n      local_b0 = local_8c;\n      uVar21 = this_command_name;\n      uVar4 = (int)uVar35 >> 0x16;\n      if ((local_d0 | uVar5 | local_cc) == 0) {\n        if (((((uVar28 - 0x23 & 0xfffffffd) == 0) || (uVar28 == 0x40)) || (uVar28 == 0x7d)) &&\n           ((local_e8 == (char *)0x0 && (unbound_vars_is_error != 0)))) goto LAB_00175de2;\nLAB_00174c87:\n        if (uVar28 == 0x3f) {\n          if ((bVar30 == false) && (bVar40)) {\nLAB_00176f06:\n            if (local_c0 != (long *)0x0) {\n              sh_xfree(local_c0,\"subst.c\",0x2793);\n            }\nLAB_00174cab:\n            sh_xfree(puVar10,\"subst.c\",0x27d0);\n            flush_eltstate(local_78);\nLAB_00174cc7:\n            ppcVar14 = (char **)alloc_word_desc();\n            *(uint *)(ppcVar14 + 1) = uVar35;\n            *ppcVar14 = local_e8;\n            goto LAB_00174ce0;\n          }\nLAB_0017766f:\n          if (local_e8 != (char *)0x0) {\nLAB_0017717d:\n            sh_xfree(local_e8,\"subst.c\",0x27a1);\n          }\n          if ((uVar28 == 0x3d) && (bVar25 != false)) {\n            set_exit_status(1);\n            report_error(\"$%s: cannot assign in this way\",puVar10);\n            sh_xfree(puVar10,\"subst.c\",0x27a7);\n            sh_xfree(local_c0,\"subst.c\",0x27a8);\n            flush_eltstate(local_78);\n            goto LAB_001748d0;\n          }\n          if (uVar28 != 0x3f) {\n            if (uVar28 == 0x2b) {\n              ppcVar14 = (char **)0x0;\n            }\n            else {\n              uVar4 = param_3 & 3;\n              if ((param_6 == (int *)0x0) || ((param_3 & 3) == 0)) {\n                if (param_5 != (int *)0x0) goto LAB_001771e1;\nLAB_001771ec:\n                if ((param_3 & 3) != 0) goto LAB_00177960;\n              }\n              else {\n                *param_6 = 0;\n                if (param_5 != (int *)0x0) {\nLAB_001771e1:\n                  *param_5 = 0;\n                  goto LAB_001771ec;\n                }\nLAB_00177960:\n                param_3 = param_3 | 0x80;\n              }\n              ppcVar14 = (char **)FUN_0017e5e0(puVar10,local_c0,uVar28,param_3,param_8,param_6,\n                                               param_5,uVar4);\n            }\n            sh_xfree(local_c0,\"subst.c\",0x27cb);\n            local_e8 = (char *)0x0;\nLAB_0017723c:\n            sh_xfree(puVar10,\"subst.c\",0x27d0);\n            flush_eltstate(local_78);\n            if (ppcVar14 != (char **)0x0) goto LAB_00174ce0;\n            goto LAB_00174cc7;\n          }\n          set_exit_status(1);\n          if ((local_c0 == (long *)0x0) || (*(byte *)local_c0 == 0)) {\n            if (bVar39 == false) {\n              report_error(\"%s: parameter not set\",puVar10);\n            }\n            else {\n              report_error(\"%s: parameter null or not set\",puVar10);\n            }\n            sh_xfree(puVar10,\"subst.c\",0x1f0d);\n            if (local_c0 != (long *)0x0) goto LAB_00177df1;\n          }\n          else {\n            uVar21 = FUN_0017af90(local_c0,0);\n            lVar8 = string_list_internal(uVar21,&DAT_001fdb1c);\n            if (lVar8 == 0) {\n              report_error(\"%s: %s\",puVar10,&DAT_00213d70);\n            }\n            else {\n              report_error(\"%s: %s\",puVar10,lVar8);\n              sh_xfree(lVar8,\"subst.c\",0x1f03);\n            }\n            dispose_words(uVar21);\n            sh_xfree(puVar10,\"subst.c\",0x1f0d);\nLAB_00177df1:\n            sh_xfree(local_c0,\"subst.c\",0x1f0e);\n          }\n          flush_eltstate(local_78);\n          goto LAB_001747b8;\n        }\n        if ((int)uVar28 < 0x40) {\n          if (uVar28 - 0x23 < 0x1b) {\n            uVar23 = (ulong)uVar28;\n            uVar16 = 1L << ((byte)uVar28 & 0x3f);\n            if ((uVar16 & 0x2000280000000000) != 0) {\n              if ((bVar30 != false) || (!bVar40)) {\n                if ((uVar28 != 0x2b) || (!bVar40)) goto LAB_0017766f;\n                if (((*local_e8 == '\\x7f') && (local_e8[1] == '\\0')) && ((param_3 & 3) != 0)) {\n                  uVar35 = uVar35 | 0x40000;\n                }\n                goto LAB_0017717d;\n              }\n              if (uVar28 != 0x2b) goto LAB_00176f06;\n              if (((param_3 & 3) != 0) && (param_6 != (int *)0x0)) {\n                *param_6 = 0;\n              }\n              if (param_5 != (int *)0x0) {\n                *param_5 = 0;\n              }\n              sh_xfree(local_e8,\"subst.c\",0x277d);\n              if (local_c0 == (long *)0x0) {\n                local_e8 = (char *)0x0;\n                goto LAB_00174cab;\n              }\n              if ((param_3 & 3) != 0) {\n                param_3 = param_3 | 0x80;\n              }\n              ppcVar14 = (char **)FUN_0017e5e0(puVar10,local_c0,0x2b,param_3,param_8,param_6,param_5\n                                               ,uVar23);\n              sh_xfree(local_c0,\"subst.c\",0x278c);\n              goto LAB_0017723c;\n            }\n            if ((uVar16 & 0x2800000000) != 0) {\n              if (local_c0 != (long *)0x0) {\n                if (((*(byte *)local_c0 != 0) && (local_e8 != (char *)0x0)) && (*local_e8 != '\\0'))\n                {\n                  pcVar7 = (char *)FUN_0017e240(puVar10,local_e8,local_78,local_c0,uVar28,param_3,\n                                                uVar4 & 4,bVar30);\n                  sh_xfree(local_e8,\"subst.c\",0x275a);\n                  sh_xfree(local_c0,\"subst.c\",0x275b);\n                  flush_eltstate(local_78);\n                  ppcVar14 = (char **)alloc_word_desc();\n                  *ppcVar14 = pcVar7;\n                  if (pcVar7 != (char *)0x0) {\n                    if (((*pcVar7 == '\\x7f') && (pcVar7[1] == '\\0')) && ((param_3 & 3) != 0)) {\n                      *(uint *)(ppcVar14 + 1) = *(uint *)(ppcVar14 + 1) | 0x40002;\n                    }\n                    else if (((*(char *)puVar10 == '*') && (*(char *)((long)puVar10 + 1) == '\\0'))\n                            && ((param_3 == 0 && (ifs_is_null != 0)))) {\n                      *(uint *)(ppcVar14 + 1) = *(uint *)(ppcVar14 + 1) | 8;\n                    }\n                  }\n                  sh_xfree(puVar10,\"subst.c\",0x2768);\n                  goto LAB_00174ce0;\n                }\n                sh_xfree(local_c0,\"subst.c\",0x2756);\n              }\n              goto LAB_00174cab;\n            }\n          }\nLAB_00175bd8:\n          set_exit_status(1);\n          if (param_1 == (char *)0x0) {\n            param_1 = \"??\";\n          }\n          report_error(\"%s: bad substitution\",param_1);\n          if (local_c0 != (long *)0x0) {\n            sh_xfree(local_c0,\"subst.c\",0x2729);\n          }\n          if (local_e8 != (char *)0x0) {\n            sh_xfree(local_e8,\"subst.c\",0x272a);\n          }\n          goto LAB_001752c4;\n        }\n        if (uVar28 != 0x40) {\n          if (uVar28 == 0x7d) goto LAB_00174cab;\n          goto LAB_00175bd8;\n        }\n        iVar34 = (int)(char)*(byte *)local_c0;\n        bVar33 = *(byte *)local_c0 & 0xdf;\n        if ((local_e8 == (char *)0x0) && (bVar33 != 0x41)) {\n          puVar19 = (undefined8 *)0x0;\n          this_command_name = (undefined2 *)uVar21;\nLAB_0017777c:\n          sh_xfree(local_e8,\"subst.c\",0x2739);\n          sh_xfree(local_c0,\"subst.c\",0x273a);\n          flush_eltstate(local_78);\nLAB_00177415:\n          if (puVar19 == (undefined8 *)&DAT_0024784e) {\n            sh_xfree(puVar10,\"subst.c\",0x2741);\n            set_exit_status(1);\n            if (param_1 == (char *)0x0) {\n              report_error(\"%s: bad substitution\",&DAT_001fa094);\n            }\n            else {\n              report_error(\"%s: bad substitution\",param_1);\n            }\n            goto LAB_001747c6;\n          }\n          ppcVar14 = (char **)alloc_word_desc();\n          *ppcVar14 = (char *)puVar19;\n          if (puVar19 != (undefined8 *)0x0) {\n            if (((*(char *)puVar19 == '\\x7f') && (*(char *)((long)puVar19 + 1) == '\\0')) &&\n               ((param_3 & 3) != 0)) {\n              *(uint *)(ppcVar14 + 1) = *(uint *)(ppcVar14 + 1) | 0x40002;\n            }\n            else if (((*(char *)puVar10 == '*') && (*(char *)((long)puVar10 + 1) == '\\0')) &&\n                    ((param_3 == 0 && (ifs_is_null != 0)))) {\n              *(uint *)(ppcVar14 + 1) = *(uint *)(ppcVar14 + 1) | 8;\n            }\n          }\n        }\n        else {\n          this_command_name = puVar10;\n          uVar28 = FUN_0017c800(puVar10,local_e8,local_78,param_3,uVar4 & 4,&local_80,&local_88,\n                                in_R11);\n          if (uVar28 == 0xffffffff) {\n            puVar19 = (undefined8 *)0x0;\n            this_command_name = (undefined2 *)uVar21;\n            goto LAB_0017777c;\n          }\n          if ((((*(byte *)local_c0 == 0) || (*(byte *)((long)local_c0 + 1) != 0)) ||\n              (bVar2 = *(byte *)local_c0 + 0xbf, 0x34 < bVar2)) ||\n             ((0x10040100118c11U >> (bVar2 & 0x3f) & 1) == 0)) {\n            this_command_name = (undefined2 *)uVar21;\n            if ((uVar28 == 0) && (local_88 != 0)) {\n              sh_xfree(local_88,\"subst.c\",0x21db);\n            }\n            if (interactive_shell != 0) {\n              sh_xfree(local_e8,\"subst.c\",0x2739);\n              sh_xfree(local_c0,\"subst.c\",0x273a);\n              flush_eltstate(local_78);\nLAB_00176de5:\n              sh_xfree(puVar10,\"subst.c\",0x2741);\n              set_exit_status(1);\n              if (param_1 == (char *)0x0) {\n                report_error(\"%s: bad substitution\",&DAT_001fa094);\n              }\n              else {\n                report_error(\"%s: bad substitution\",param_1);\n              }\n              goto LAB_001748d0;\n            }\n            puVar19 = (undefined8 *)&DAT_0024784e;\n            goto LAB_0017777c;\n          }\n          uVar4 = uVar28 & 0xffffff7f;\n          if ((bVar33 == 0x41) && (uVar4 == 0)) {\n            if (local_80 == (char *)0x0) {\n              local_80 = (char *)find_variable(puVar10);\n            }\nLAB_00177364:\n            lVar8 = FUN_0016fa40(iVar34,local_80,local_88);\n            if (local_88 != 0) {\n              sh_xfree(local_88,\"subst.c\",0x21ee);\n            }\nLAB_00177394:\n            if (lVar8 == 0) goto LAB_001775fc;\n            if ((param_3 & 3) == 0) {\n              puVar19 = (undefined8 *)FUN_00167220(lVar8,0);\n            }\n            else {\n              puVar19 = (undefined8 *)quote_string(lVar8);\n            }\n            sh_xfree(lVar8,\"subst.c\",0x21f4);\nLAB_001773c4:\n            this_command_name = (undefined2 *)uVar21;\n            sh_xfree(local_e8,\"subst.c\",0x2739);\n            sh_xfree(local_c0,\"subst.c\",0x273a);\n            flush_eltstate(local_78);\n            if (puVar19 == (undefined8 *)&DAT_0024784f) goto LAB_00176de5;\n            goto LAB_00177415;\n          }\n          if (uVar4 == 2) {\n            puVar18 = (undefined8 *)FUN_00171ef0(iVar34,local_80,uVar28 & 0x80,param_3);\n            if (puVar18 != (undefined8 *)0x0) {\n              uVar28 = ifs_is_null;\n              if (param_3 != 0) {\n                if (puVar18 == (undefined8 *)0x0) goto LAB_001775fc;\n                uVar28 = param_3 & 3;\n              }\n              puVar19 = puVar18;\n              if (uVar28 == 0) {\n                puVar19 = (undefined8 *)FUN_00167220(puVar18,0);\n                sh_xfree(puVar18,\"subst.c\",0x2202);\n              }\n              goto LAB_001773c4;\n            }\n          }\n          else if ((int)uVar4 < 3) {\n            if (uVar4 == 0) goto LAB_00177364;\n            if (uVar4 == 1) {\n              cVar24 = *(char *)puVar10;\n              lVar8 = list_rest_of_args();\n              if (lVar8 != 0) {\n                if (iVar34 == 0x41) {\n                  pcVar7 = (char *)FUN_00171de0(0x51,0,lVar8,(int)cVar24,param_3);\n                  sVar20 = strlen(pcVar7);\n                  puVar19 = (undefined8 *)sh_xmalloc(sVar20 + 8,\"subst.c\",0x20f0);\n                  *puVar19 = 0x202d2d20746573;\n                  strcpy((char *)((long)puVar19 + 7),pcVar7);\n                  sh_xfree(pcVar7,\"subst.c\",0x20f3);\n                  dispose_words(lVar8);\n                  uVar28 = ifs_is_null;\n                  if (param_3 != 0) {\nLAB_00177c6e:\n                    uVar28 = param_3 & 3;\n                  }\njoined_r0x0017759c:\n                  if (uVar28 == 0) {\n                    puVar18 = (undefined8 *)FUN_00167220(puVar19,0);\n                    sh_xfree(puVar19,\"subst.c\",0x2210);\n                    puVar19 = puVar18;\n                  }\n                  goto LAB_001773c4;\n                }\n                puVar19 = (undefined8 *)FUN_00171de0(iVar34,0,lVar8,(int)cVar24,param_3);\n                dispose_words(lVar8);\n                if (puVar19 != (undefined8 *)0x0) {\n                  uVar28 = ifs_is_null;\n                  if (param_3 == 0) goto joined_r0x0017759c;\n                  if (puVar19 != (undefined8 *)0x0) goto LAB_00177c6e;\n                }\n              }\n            }\n          }\n          else if (uVar4 == 3) {\n            lVar8 = FUN_0016fa40(iVar34,local_80,local_88);\n            goto LAB_00177394;\n          }\nLAB_001775fc:\n          this_command_name = (undefined2 *)uVar21;\n          sh_xfree(local_e8,\"subst.c\",0x2739);\n          sh_xfree(local_c0,\"subst.c\",0x273a);\n          flush_eltstate(local_78);\n          ppcVar14 = (char **)alloc_word_desc();\n          *ppcVar14 = (char *)0x0;\n        }\n        sh_xfree(puVar10,\"subst.c\",0x274f);\n      }\n      else {\n        if ((local_e8 == (char *)0x0) && (unbound_vars_is_error != 0)) {\nLAB_00175de2:\n          if ((((*(char *)puVar10 != '@') && (*(char *)puVar10 != '*')) ||\n              (*(char *)((long)puVar10 + 1) != '\\0')) && (!bVar38)) {\n            set_exit_status(1);\n            err_unboundvar(puVar10);\n            if (local_c0 != (long *)0x0) {\n              sh_xfree(local_c0,\"subst.c\",0x26bb);\n            }\n            uVar21 = 0x26bd;\n            goto LAB_00175e35;\n          }\n        }\n        if (local_d0 == 0) {\n          if (uVar5 != 0) {\n            pcVar7 = (char *)FUN_0017d6c0(puVar10,local_e8,local_78,local_c0,param_3,param_8,\n                                          uVar4 & 4);\n            if (local_c0 != (long *)0x0) {\n              sh_xfree(local_c0,\"subst.c\",0x26e9);\n            }\n            if (local_e8 != (char *)0x0) {\n              sh_xfree(local_e8,\"subst.c\",0x26ea);\n            }\n            flush_eltstate(local_78);\n            if (pcVar7 == &DAT_0024784f) {\n              sh_xfree(puVar10,\"subst.c\",0x26f1);\n              goto LAB_001748d0;\n            }\n            if (pcVar7 != &DAT_0024784e) {\n              ppcVar14 = (char **)alloc_word_desc();\n              *ppcVar14 = pcVar7;\n              if (pcVar7 != (char *)0x0) {\n                if (((param_6 == (int *)0x0) || (*param_6 == 0)) &&\n                   ((*pcVar7 == '\\x7f' && ((pcVar7[1] == '\\0' && ((param_3 & 3) != 0)))))) {\n                  *(uint *)(ppcVar14 + 1) = *(uint *)(ppcVar14 + 1) | 0x40002;\n                }\n                else if ((*(char *)puVar10 == '*') &&\n                        (((*(char *)((long)puVar10 + 1) == '\\0' && (param_3 == 0)) &&\n                         (ifs_is_null != 0)))) {\n                  *(uint *)(ppcVar14 + 1) = *(uint *)(ppcVar14 + 1) | 8;\n                }\n              }\n              sh_xfree(puVar10,\"subst.c\",0x26ff);\n              goto LAB_00174ce0;\n            }\n            sh_xfree(puVar10,\"subst.c\",0x26f1);\n            goto LAB_001747c6;\n          }\n          if (local_cc == 0) goto LAB_00174c87;\n          if (local_e8 == (char *)0x0) {\n            if (local_c0 != (long *)0x0) {\n              sh_xfree(local_c0,\"subst.c\",0x2706);\n              local_a8 = (undefined8 *)0x0;\n              goto LAB_00176add;\n            }\n            flush_eltstate(local_78);\n            ppcVar14 = (char **)alloc_word_desc();\n            *ppcVar14 = (char *)0x0;\n          }\n          else {\n            plVar12 = &local_88;\n            this_command_name = puVar10;\n            local_e0 = FUN_0017c800(puVar10,local_e8,local_78,param_3,uVar4 & 4,&local_80);\n            if (local_e0 == 0xffffffff) {\n              local_a8 = (undefined8 *)0x0;\n            }\n            else {\n              uVar28 = local_e0 & 0xffffff7f;\n              bVar39 = (param_3 & 3) != 0;\n              uVar16 = (ulong)bVar39 << 5;\n              if ((local_e0 & 0x80) != 0) {\n                uVar16 = (ulong)bVar39 << 5 | 0x80;\n              }\n              if ((param_8 & 8) != 0) {\n                uVar16 = (ulong)((uint)uVar16 | 0x40);\n              }\n              uVar4 = 0;\n              if (local_ac == 0x5e) {\n                if (local_c0 == (long *)0x0) {\n                  uVar5 = 0x40;\n                }\n                else {\n                  uVar4 = 0;\n                  if (*(byte *)local_c0 == 0x5e) {\n                    uVar4 = local_cc;\n                  }\n                  uVar5 = 0x40;\n                  if (*(byte *)local_c0 == 0x5e) {\n                    uVar5 = 2;\n                  }\n                }\nLAB_00176f7c:\n                plVar13 = (long *)((long)local_c0 + (long)(int)uVar4);\n                plVar12 = local_c0;\n              }\n              else {\n                if (local_ac == 0x2c) {\n                  if (local_c0 == (long *)0x0) {\n                    uVar5 = 0x80;\n                  }\n                  else {\n                    uVar4 = 0;\n                    if (*(byte *)local_c0 == 0x2c) {\n                      uVar4 = local_cc;\n                    }\n                    uVar5 = 0x80;\n                    if (*(byte *)local_c0 == 0x2c) {\n                      uVar5 = local_cc;\n                    }\n                  }\n                  goto LAB_00176f7c;\n                }\n                uVar5 = 0;\n                plVar13 = local_c0;\n                if (local_ac == 0x7e) {\n                  if (local_c0 == (long *)0x0) {\n                    uVar5 = 0x10;\n                  }\n                  else {\n                    uVar4 = 0;\n                    if (*(byte *)local_c0 == 0x7e) {\n                      uVar4 = local_cc;\n                    }\n                    uVar5 = 0x10;\n                    if (*(byte *)local_c0 == 0x7e) {\n                      uVar5 = 0x20;\n                    }\n                  }\n                  goto LAB_00176f7c;\n                }\n              }\n              uVar4 = (uint)uVar16;\n              if (plVar13 == (long *)0x0) {\n                pcVar7 = (char *)0x0;\n                pcVar9 = pcVar7;\n                if (uVar28 == 2) {\n                  lVar8 = 0;\n                  goto LAB_00176fe2;\n                }\n                if ((int)uVar28 < 3) {\n                  if (uVar28 == 0) {\n                    lVar8 = 0;\n                    goto LAB_001777da;\n                  }\n                  if ((uVar28 == 1) &&\n                     (puVar19 = (undefined8 *)list_rest_of_args(plVar12), local_a8 = puVar19,\n                     puVar19 != (undefined8 *)0x0)) {\n                    lVar8 = 0;\n                    goto LAB_00176906;\n                  }\n                }\n                else {\n                  pcVar9 = (char *)0x0;\n                  lVar8 = 0;\n                  if (uVar28 == 3) goto LAB_00176a1e;\n                }\n              }\n              else {\n                local_e0 = local_e0 & 0xffffff7f;\n                sVar20 = strlen((char *)plVar13);\n                pcVar7 = (char *)sh_xmalloc(sVar20 + 1,\"subst.c\",0x24b2);\n                pcVar9 = strcpy(pcVar7,(char *)plVar13);\n                lVar8 = FUN_0017b240(pcVar9,param_3);\n                if (local_e0 == 2) {\nLAB_00176fe2:\n                  if (((uVar4 & 0xc0) == 0xc0) && (ifs_is_null != 0)) {\n                    uVar16 = 0xe0;\n                  }\n                  if ((local_80[0x28] & 0x40U) == 0) {\n                    local_a8 = (undefined8 *)\n                               array_modcase(*(undefined8 *)(local_80 + 8),lVar8,uVar5,uVar16);\n                  }\n                  else {\n                    local_a8 = (undefined8 *)assoc_modcase();\n                  }\n                  if (local_a8 != (undefined8 *)0x0) {\n                    if (param_3 == 0) {\n                      if (ifs_is_null == 0) {\nLAB_0017704b:\n                        if ((uVar16 & 0x20) == 0) {\n                          puVar19 = (undefined8 *)FUN_00167220(local_a8,0);\n                          sh_xfree(local_a8,\"subst.c\",0x24e7);\n                          local_a8 = puVar19;\n                        }\n                      }\n                    }\n                    else if (local_a8 != (undefined8 *)0x0) goto LAB_0017704b;\n                  }\n                }\n                else {\n                  if ((int)local_e0 < 3) {\n                    if (local_e0 != 0) {\n                      if ((local_e0 == 1) &&\n                         (puVar19 = (undefined8 *)list_rest_of_args(), local_a8 = puVar19,\n                         puVar19 != (undefined8 *)0x0)) {\nLAB_00176906:\n                        do {\n                          puVar17 = (undefined *)sh_modcase(*(undefined8 *)puVar19[1],lVar8,uVar5);\n                          puVar18 = (undefined8 *)alloc_word_desc();\n                          if (puVar17 == (undefined *)0x0) {\n                            puVar17 = (undefined *)sh_xmalloc(1,\"subst.c\",0x2461);\n                            *puVar17 = 0;\n                          }\n                          *puVar18 = puVar17;\n                          dispose_word(puVar19[1]);\n                          puVar19[1] = puVar18;\n                          puVar19 = (undefined8 *)*puVar19;\n                        } while (puVar19 != (undefined8 *)0x0);\n                        uVar29 = 0x40;\n                        uVar28 = (int)uVar4 >> 5 & 1;\n                        if ((uVar16 & 0x80) != 0) {\n                          if (((uVar16 & 0x40) != 0) && (ifs_is_null != 0)) {\n                            uVar28 = local_cc;\n                          }\n                          uVar29 = 0x2a;\n                        }\n                        puVar19 = (undefined8 *)\n                                  string_list_pos_params(uVar29,local_a8,uVar28,(int)uVar4 >> 3 & 8)\n                        ;\n                        dispose_words(local_a8);\n                        local_a8 = puVar19;\n                        if (puVar19 != (undefined8 *)0x0) {\n                          if (param_3 == 0) {\n                            if (ifs_is_null == 0) {\nLAB_001772e0:\n                              if ((uVar16 & 0x20) == 0) {\n                                local_a8 = (undefined8 *)FUN_00167220(puVar19,0);\n                                sh_xfree(puVar19,\"subst.c\",0x24d0);\n                              }\n                            }\n                          }\n                          else if (puVar19 != (undefined8 *)0x0) goto LAB_001772e0;\n                        }\n                      }\n                      goto LAB_00176a78;\n                    }\nLAB_001777da:\n                    local_a8 = (undefined8 *)sh_modcase(local_88,lVar8,uVar5);\n                    if (local_88 != 0) {\n                      sh_xfree(local_88,\"subst.c\",0x24be);\n                    }\n                  }\n                  else {\n                    if (local_e0 != 3) goto LAB_00176a78;\nLAB_00176a1e:\n                    local_a8 = (undefined8 *)sh_modcase(local_88,lVar8,uVar5);\n                  }\n                  if (local_a8 != (undefined8 *)0x0) {\n                    if ((uVar16 & 0x20) == 0) {\n                      puVar19 = (undefined8 *)FUN_00167220(local_a8,0);\n                    }\n                    else {\n                      puVar19 = (undefined8 *)quote_string();\n                    }\n                    sh_xfree(local_a8,\"subst.c\",0x24c2);\n                    local_a8 = puVar19;\n                  }\n                }\nLAB_00176a78:\n                pcVar7 = pcVar9;\n                if (lVar8 != 0) {\n                  sh_xfree(lVar8,\"subst.c\",0x24ef);\n                }\n              }\n              sh_xfree(pcVar7,\"subst.c\",0x24f0);\n            }\n            this_command_name = (undefined2 *)uVar21;\n            if (local_c0 != (long *)0x0) {\n              sh_xfree(local_c0,\"subst.c\",0x2706);\n            }\n            sh_xfree(local_e8,\"subst.c\",0x2707);\nLAB_00176add:\n            flush_eltstate(local_78);\n            if (local_a8 == (undefined8 *)&DAT_0024784f) {\n              sh_xfree(puVar10,\"subst.c\",0x270e);\n              goto LAB_001748d0;\n            }\n            if (local_a8 == (undefined8 *)&DAT_0024784e) {\n              sh_xfree(puVar10,\"subst.c\",0x270e);\n              goto LAB_001747c6;\n            }\n            ppcVar14 = (char **)alloc_word_desc();\n            *ppcVar14 = (char *)local_a8;\n            if (local_a8 != (undefined8 *)0x0) {\n              if ((((param_6 == (int *)0x0) || (*param_6 == 0)) && (*(char *)local_a8 == '\\x7f')) &&\n                 ((*(char *)((long)local_a8 + 1) == '\\0' && ((param_3 & 3) != 0)))) {\n                *(uint *)(ppcVar14 + 1) = *(uint *)(ppcVar14 + 1) | 0x40002;\n              }\n              else if (((*(char *)puVar10 == '*') &&\n                       ((*(char *)((long)puVar10 + 1) == '\\0' && (param_3 == 0)))) &&\n                      (ifs_is_null != 0)) {\n                *(uint *)(ppcVar14 + 1) = *(uint *)(ppcVar14 + 1) | 8;\n              }\n            }\n          }\n          sh_xfree(puVar10,\"subst.c\",0x271c);\n        }\n        else {\n          pcVar7 = (char *)FUN_0017cc10(puVar10,local_e8,local_78,local_c0,param_3,param_8,uVar4 & 4\n                                       );\n          if (local_c0 != (long *)0x0) {\n            sh_xfree(local_c0,\"subst.c\",0x26c6);\n          }\n          if (local_e8 != (char *)0x0) {\n            sh_xfree(local_e8,\"subst.c\",0x26c7);\n          }\n          flush_eltstate(local_78);\n          if (pcVar7 == &DAT_0024784f) {\n            sh_xfree(puVar10,\"subst.c\",0x26ce);\n            goto LAB_001748d0;\n          }\n          if (pcVar7 == &DAT_0024784e) {\n            sh_xfree(puVar10,\"subst.c\",0x26ce);\n            goto LAB_001747c6;\n          }\n          ppcVar14 = (char **)alloc_word_desc();\n          *ppcVar14 = pcVar7;\n          if (pcVar7 != (char *)0x0) {\n            if (((param_6 == (int *)0x0) || (*param_6 == 0)) &&\n               ((*pcVar7 == '\\x7f' && ((pcVar7[1] == '\\0' && ((param_3 & 3) != 0)))))) {\n              *(uint *)(ppcVar14 + 1) = *(uint *)(ppcVar14 + 1) | 0x40002;\n            }\n            else if ((*(char *)puVar10 == '*') &&\n                    ((((*(char *)((long)puVar10 + 1) == '\\0' && (param_3 == 0)) &&\n                      ((param_8 & 8) != 0)) ||\n                     (((*(char *)((long)puVar10 + 1) == '\\0' && (param_3 == 0)) &&\n                      (ifs_is_null != 0)))))) {\n              *(uint *)(ppcVar14 + 1) = *(uint *)(ppcVar14 + 1) | 8;\n            }\n          }\n          sh_xfree(puVar10,\"subst.c\",0x26e3);\n        }\n      }\nLAB_00174ce0:\n      if (ppcVar14 != (char **)&DAT_00247860) {\n        if (ppcVar14 != (char **)&DAT_00247850) {\n          pcVar7 = *ppcVar14;\n          if ((((pcVar7 != (char *)0x0) && ((*(byte *)((long)ppcVar14 + 10) & 4) != 0)) &&\n              (*pcVar7 == '\\x7f')) && (pcVar7[1] == '\\0')) {\n            if (param_7 != (undefined4 *)0x0) {\n              *param_7 = 1;\n            }\n            if (*param_6 == 0) {\n              sh_xfree(pcVar7,\"subst.c\",0x292f);\n              *ppcVar14 = (char *)0x0;\n            }\n          }\n          *param_2 = local_b0;\n          goto LAB_00174da9;\n        }\n        goto LAB_001747c6;\n      }\n    }\nLAB_001748d0:\n    ppcVar14 = (char **)&DAT_00247860;\n    goto LAB_00174da9;\n  }\n  if (bVar33 != 0) {\nLAB_00174d94:\n    iVar31 = iVar31 + 1;\n  }\nLAB_00174d98:\n  uVar26 = SUB84(param_4,0);\n  *param_2 = iVar31;\nLAB_00174d9b:\n  ppcVar14 = (char **)alloc_word_desc();\n  *(undefined4 *)(ppcVar14 + 1) = uVar26;\n  *ppcVar14 = (char *)puVar10;\nLAB_00174da9:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return ppcVar14;\n}\n\n",
  "FUN_001d23d0": "\nundefined8 FUN_001d23d0(long param_1)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  undefined8 uVar3;\n  \n  uVar1 = *(undefined4 *)(param_1 + 0x20);\n  DAT_0024a400 = uVar1;\n  rl_extend_line_buffer(rl_end + 1);\n  lVar2 = (long)rl_end;\n  rl_end = rl_end + 1;\n  *(undefined *)(rl_line_buffer + lVar2) = 0x20;\n  *(undefined *)(rl_line_buffer + rl_end) = 0;\n  _rl_dispatch(uVar1,_rl_keymap);\n  if (((rl_readline_state & 0x80000) != 0) && ((rl_readline_state & 0x800000) != 0)) {\n    return 0;\n  }\n  uVar3 = _rl_vi_domove_motion_cleanup(uVar1,param_1);\n  return uVar3;\n}\n\n",
  "set_dollar_vars_unchanged": "\nvoid set_dollar_vars_unchanged(void)\n\n{\n  DAT_00248a98 = 0;\n  return;\n}\n\n",
  "get_job_by_name": "\nint get_job_by_name(char *param_1,uint param_2)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  long lVar3;\n  int iVar4;\n  size_t sVar5;\n  size_t sVar6;\n  char *pcVar7;\n  undefined8 *puVar8;\n  bool bVar9;\n  int local_64;\n  long local_60;\n  \n  sVar5 = strlen(param_1);\n  lVar3 = jobs;\n  if (DAT_0023877c + -1 < 0) {\n    local_64 = -1;\n  }\n  else {\n    local_60 = (long)(DAT_0023877c + -1);\n    local_64 = -1;\n    do {\n      lVar1 = *(long *)(lVar3 + local_60 * 8);\n      if ((lVar1 != 0) && (((param_2 & 8) == 0 || (*(int *)(lVar1 + 0x14) == 2)))) {\n        puVar2 = *(undefined8 **)(lVar1 + 8);\n        puVar8 = puVar2;\n        do {\n          if ((param_2 & 4) == 0) {\n            if ((param_2 & 2) == 0) {\n              if ((int)sVar5 != 0) {\n                if (*(char *)puVar8[3] != *param_1) goto LAB_001a4934;\n                iVar4 = strncmp((char *)puVar8[3],param_1,(long)(int)sVar5);\n                if (iVar4 != 0) {\n                  puVar8 = (undefined8 *)*puVar8;\n                  goto LAB_001a4911;\n                }\n              }\n            }\n            else {\n              pcVar7 = strcasestr((char *)puVar8[3],param_1);\n              if (pcVar7 == (char *)0x0) goto LAB_001a4934;\n            }\nLAB_001a4900:\n            if ((param_2 & 0x10) != 0) {\n              return (int)local_60;\n            }\n            bVar9 = local_64 != -1;\n            local_64 = (int)local_60;\n            if (bVar9) {\n              if (this_shell_builtin != 0) {\n                builtin_error();\n                return -2;\n              }\n              internal_error(\"%s: ambiguous job spec\",param_1);\n              return -2;\n            }\n          }\n          else {\n            pcVar7 = (char *)puVar8[3];\n            sVar6 = strlen(pcVar7);\n            if (((int)sVar6 == 0) ||\n               ((*pcVar7 == *param_1 &&\n                (iVar4 = strncmp(pcVar7,param_1,(long)(int)sVar6), iVar4 == 0)))) goto LAB_001a4900;\nLAB_001a4934:\n            puVar8 = (undefined8 *)*puVar8;\n          }\nLAB_001a4911:\n        } while (puVar8 != puVar2);\n      }\n      local_60 = local_60 + -1;\n    } while (-1 < (int)local_60);\n  }\n  return local_64;\n}\n\n",
  "sh_mktmpdir": "\nchar * sh_mktmpdir(char *param_1,uint param_2)\n\n{\n  uint uVar1;\n  undefined8 *__template;\n  undefined8 uVar2;\n  size_t sVar3;\n  char *pcVar4;\n  ulong uVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined8 *puVar8;\n  byte bVar9;\n  \n  bVar9 = 0;\n  __template = (undefined8 *)sh_xmalloc(0x1001,\"tmpfile.c\",0x112);\n  uVar2 = FUN_001c6e70(param_2);\n  if ((undefined8 *)param_1 == (undefined8 *)0x0) {\n    param_1 = \"shtmp\";\nLAB_001c731c:\n    __sprintf_chk(__template,1,0xffffffffffffffff,\"%s/%s.XXXXXX\",uVar2,param_1);\n  }\n  else {\n    if (((param_2 & 8) == 0) || (sVar3 = strlen(param_1), 0x1000 < sVar3)) goto LAB_001c731c;\n    uVar5 = sVar3 + 1;\n    uVar1 = (uint)uVar5;\n    if (7 < uVar1) {\n      *__template = *(undefined8 *)param_1;\n      *(undefined8 *)((long)__template + ((uVar5 & 0xffffffff) - 8)) =\n           *(undefined8 *)((long)param_1 + ((uVar5 & 0xffffffff) - 8));\n      lVar6 = (long)__template - (long)(undefined8 *)((ulong)(__template + 1) & 0xfffffffffffffff8);\n      puVar7 = (undefined8 *)((long)param_1 - lVar6);\n      puVar8 = (undefined8 *)((ulong)(__template + 1) & 0xfffffffffffffff8);\n      for (uVar5 = (ulong)(uVar1 + (int)lVar6 >> 3); uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar8 = *puVar7;\n        puVar7 = puVar7 + (ulong)bVar9 * -2 + 1;\n        puVar8 = puVar8 + (ulong)bVar9 * -2 + 1;\n      }\n      pcVar4 = mkdtemp((char *)__template);\n      goto joined_r0x001c73cf;\n    }\n    if ((uVar5 & 4) == 0) {\n      if ((uVar1 != 0) && (*(char *)__template = *param_1, (uVar5 & 2) != 0)) {\n        *(undefined2 *)((long)__template + ((uVar5 & 0xffffffff) - 2)) =\n             *(undefined2 *)((long)param_1 + ((uVar5 & 0xffffffff) - 2));\n      }\n    }\n    else {\n      *(undefined4 *)__template = *(undefined4 *)param_1;\n      *(undefined4 *)((long)__template + ((uVar5 & 0xffffffff) - 4)) =\n           *(undefined4 *)((long)param_1 + ((uVar5 & 0xffffffff) - 4));\n    }\n  }\n  pcVar4 = mkdtemp((char *)__template);\njoined_r0x001c73cf:\n  if (pcVar4 != (char *)0x0) {\n    return pcVar4;\n  }\n  sh_xfree(__template,\"tmpfile.c\",0x124);\n  return (char *)0x0;\n}\n\n",
  "job_exit_signal": "\nbyte job_exit_signal(void)\n\n{\n  byte bVar1;\n  byte bVar2;\n  \n  bVar1 = FUN_0015e730();\n  bVar2 = bVar1 & 0x7f;\n  if ((char)((bVar1 & 0x7f) + 1) < '\\x02') {\n    bVar2 = 0;\n  }\n  return bVar2;\n}\n\n",
  "assoc_to_kvpair": "\nundefined * assoc_to_kvpair(long *param_1,int param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  undefined *puVar4;\n  char *__s;\n  size_t sVar5;\n  undefined *puVar6;\n  char *__s_00;\n  int iVar7;\n  undefined8 *puVar8;\n  int iVar9;\n  undefined2 *__dest;\n  int iVar10;\n  long lVar11;\n  long local_50;\n  \n  if (param_1 == (long *)0x0) {\n    puVar4 = (undefined *)0x0;\n  }\n  else {\n    puVar4 = (undefined *)0x0;\n    if (*(int *)((long)param_1 + 0xc) != 0) {\n      puVar4 = (undefined *)sh_xmalloc(0x80,\"assoc.c\",0x180);\n      *puVar4 = 0;\n      puVar6 = puVar4;\n      if (0 < *(int *)(param_1 + 1)) {\n        local_50 = 0;\n        iVar10 = 0;\n        iVar9 = 0x80;\n        do {\n          for (puVar8 = *(undefined8 **)(*param_1 + local_50 * 8); puVar8 != (undefined8 *)0x0;\n              puVar8 = (undefined8 *)*puVar8) {\nLAB_0018e068:\n            iVar3 = ansic_shouldquote(puVar8[1]);\n            if (iVar3 == 0) {\n              iVar3 = sh_contains_shell_metas();\n              if (iVar3 != 0) {\n                __s_00 = (char *)sh_double_quote(puVar8[1]);\n                goto LAB_0018defc;\n              }\n              __s_00 = (char *)puVar8[1];\n              cVar1 = *__s_00;\n              if (((cVar1 == '@') || (cVar1 == '*')) && (__s_00[1] == '\\0')) {\n                __s_00 = (char *)sh_double_quote(__s_00);\n                goto LAB_0018defc;\n              }\n              lVar11 = puVar8[2];\n              if (lVar11 != 0) goto LAB_0018df09;\n              iVar3 = 5;\n              __s = (char *)0x0;\n              if (cVar1 == '\\0') goto LAB_0018df80;\n              if (__s_00[1] == '\\0') goto LAB_0018e280;\n              iVar7 = 6;\n              if (__s_00[2] == '\\0') goto LAB_0018e275;\nLAB_0018e0e0:\n              sVar5 = strlen(__s_00);\n              iVar7 = (int)sVar5 + 4;\nLAB_0018df3d:\n              if (__s == (char *)0x0) {\nLAB_0018e275:\n                iVar3 = iVar7 + 1;\n                __s = (char *)0x0;\n              }\n              else {\n                iVar3 = iVar7 + 1;\n                if (((*__s != '\\0') && (iVar3 = iVar7 + 2, __s[1] != '\\0')) &&\n                   (iVar3 = iVar7 + 3, __s[2] != '\\0')) {\n                  sVar5 = strlen(__s);\n                  iVar3 = iVar7 + 1 + (int)sVar5;\n                }\n              }\n            }\n            else {\n              __s_00 = (char *)ansic_quote(puVar8[1],0,0);\nLAB_0018defc:\n              lVar11 = puVar8[2];\n              if (lVar11 != 0) {\nLAB_0018df09:\n                iVar3 = ansic_shouldquote(lVar11);\n                if (iVar3 == 0) {\n                  __s = (char *)sh_double_quote(puVar8[2]);\n                }\n                else {\n                  __s = (char *)ansic_quote(puVar8[2],0,0);\n                }\n                iVar7 = 4;\n                if ((__s_00 != (char *)0x0) && (*__s_00 != '\\0')) {\n                  if (__s_00[1] == '\\0') {\n                    iVar7 = 5;\n                  }\n                  else {\nLAB_0018e13b:\n                    iVar7 = 6;\n                    if (__s_00[2] != '\\0') goto LAB_0018e0e0;\n                  }\n                }\n                goto LAB_0018df3d;\n              }\n              iVar3 = 5;\n              __s = (char *)0x0;\n              if (__s_00 != (char *)0x0) {\n                if (*__s_00 != '\\0') {\n                  if (__s_00[1] != '\\0') goto LAB_0018e13b;\nLAB_0018e280:\n                  __s = (char *)0x0;\n                  iVar3 = 6;\n                  goto LAB_0018df80;\n                }\n                iVar7 = 4;\n                goto LAB_0018e275;\n              }\n            }\nLAB_0018df80:\n            iVar3 = iVar3 + iVar10;\n            iVar7 = iVar9;\n            if (iVar9 <= iVar3) {\n              do {\n                iVar9 = iVar7 * 2;\n                iVar2 = iVar7 * -2;\n                iVar7 = iVar9;\n              } while (SBORROW4(iVar3,iVar9) == iVar3 + iVar2 < 0);\n              puVar6 = (undefined *)sh_xrealloc(puVar6,(long)iVar9,\"assoc.c\",0x195);\n            }\n            strcpy(puVar6 + iVar10,__s_00);\n            iVar3 = 0;\n            if (((*__s_00 != '\\0') && (iVar3 = 1, __s_00[1] != '\\0')) &&\n               (iVar3 = 2, __s_00[2] != '\\0')) {\n              sVar5 = strlen(__s_00);\n              iVar3 = (int)sVar5;\n            }\n            iVar3 = iVar3 + iVar10;\n            puVar6[iVar3] = 0x20;\n            __dest = (undefined2 *)(puVar6 + (iVar3 + 1));\n            if (__s == (char *)0x0) {\n              iVar10 = iVar3 + 4;\n              *(undefined *)(__dest + 1) = 0;\n              *__dest = 0x2222;\n              puVar6[iVar3 + 3] = 0x20;\n              if (__s_00 == (char *)puVar8[1]) goto LAB_0018e05c;\n              sh_xfree(__s_00,\"assoc.c\",0x1a7);\n              puVar8 = (undefined8 *)*puVar8;\n              if (puVar8 == (undefined8 *)0x0) break;\n              goto LAB_0018e068;\n            }\n            strcpy((char *)__dest,__s);\n            iVar7 = 0;\n            if (((*__s != '\\0') && (iVar7 = 1, __s[1] != '\\0')) && (iVar7 = 2, __s[2] != '\\0')) {\n              sVar5 = strlen(__s);\n              iVar7 = (int)sVar5;\n            }\n            iVar7 = iVar7 + iVar3 + 1;\n            iVar10 = iVar7 + 1;\n            puVar6[iVar7] = 0x20;\n            if (__s_00 != (char *)puVar8[1]) {\n              sh_xfree(__s_00,\"assoc.c\",0x1a7);\n            }\n            sh_xfree(__s,\"assoc.c\",0x1a9);\nLAB_0018e05c:\n          }\n          local_50 = local_50 + 1;\n        } while (*(int *)(param_1 + 1) != (int)local_50 && (int)local_50 <= *(int *)(param_1 + 1));\n        if (iVar9 <= iVar10 + 1) {\n          puVar6 = (undefined *)\n                   sh_xrealloc(puVar6,(long)(int)(iVar9 + 8 + ((iVar10 + 1) - iVar9 & 0xfffffff8U)),\n                               \"assoc.c\",0x1ac);\n        }\n        puVar4 = puVar6 + iVar10;\n      }\n      *puVar4 = 0;\n      puVar4 = puVar6;\n      if (param_2 != 0) {\n        puVar4 = (undefined *)sh_single_quote(puVar6);\n        sh_xfree(puVar6,\"assoc.c\",0x1b2);\n      }\n    }\n  }\n  return puVar4;\n}\n\n",
  "FUN_00191640": "\nundefined8 FUN_00191640(void)\n\n{\n  int iVar1;\n  char *pcVar2;\n  size_t sVar3;\n  char *__dest;\n  long in_FS_OFFSET;\n  undefined local_13;\n  undefined local_12;\n  undefined local_11;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = rl_read_key();\n  if (0 < iVar1) {\n    local_13 = 0x5f;\n    local_12 = (undefined)iVar1;\n    local_11 = 0;\n    pcVar2 = (char *)get_alias_value(&local_13);\n    if ((pcVar2 != (char *)0x0) && (*pcVar2 != '\\0')) {\n      sVar3 = strlen(pcVar2);\n      __dest = (char *)sh_xmalloc(sVar3 + 1,\"bashline.c\",0x41f);\n      pcVar2 = strcpy(__dest,pcVar2);\n      rl_push_macro_input(pcVar2);\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001c6e70": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nchar * FUN_001c6e70(uint param_1)\n\n{\n  int iVar1;\n  char *__s;\n  size_t sVar2;\n  long lVar3;\n  \n  if ((((((param_1 & 1) == 0) || (__s = (char *)get_string_value(\"TMPDIR\"), __s == (char *)0x0)) ||\n       (iVar1 = file_iswdir(__s), iVar1 == 0)) || (sVar2 = strlen(__s), 0x1000 < sVar2)) &&\n     (__s = DAT_00249f88, DAT_00249f88 == (char *)0x0)) {\n    DAT_00249f88 = \"/tmp\";\n    iVar1 = file_iswdir(&DAT_0021258e);\n    __s = DAT_00249f88;\n    if (iVar1 == 0) {\n      DAT_00249f88 = \"/tmp\";\n      iVar1 = file_iswdir(&DAT_0021258e);\n      __s = DAT_00249f88;\n      if (iVar1 == 0) {\n        DAT_00249f88 = \"/var/tmp\";\n        iVar1 = file_iswdir();\n        __s = DAT_00249f88;\n        if (iVar1 == 0) {\n          DAT_00249f88 = \"/usr/tmp\";\n          iVar1 = file_iswdir();\n          __s = DAT_00249f88;\n          if (iVar1 == 0) {\n            DAT_00249f88 = \".\";\n            __s = \".\";\n          }\n        }\n      }\n    }\n  }\n  if (_DAT_0023b30c == -1) {\n    lVar3 = pathconf(__s,3);\n    _DAT_0023b30c = (int)lVar3;\n    return __s;\n  }\n  return __s;\n}\n\n",
  "FUN_0015ebc0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0015ebc0(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long *plVar5;\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_128);\n  sigaddset(&sStack_128,0x11);\n  sigemptyset(&local_a8);\n  sigprocmask(0,&sStack_128,&local_a8);\n  if (0 < DAT_0023877c) {\n    uVar1 = DAT_0023877c - 1;\n    plVar2 = jobs + 1;\n    plVar3 = plVar2;\n    plVar5 = jobs;\n    while( true ) {\n      plVar4 = plVar3;\n      if (*plVar5 != 0) {\n        *(undefined4 *)(*plVar5 + 0x14) = 4;\n        _DAT_0023878c = _DAT_0023878c + 1;\n      }\n      if (plVar4 == plVar2 + uVar1) break;\n      plVar3 = plVar4 + 1;\n      plVar5 = plVar4;\n    }\n  }\n  sigprocmask(2,&local_a8,(sigset_t *)0x0);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00170720": "\nundefined2 * FUN_00170720(char **param_1,uint param_2,int param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined2 *puVar3;\n  size_t sVar4;\n  undefined2 *__s;\n  size_t sVar5;\n  long in_FS_OFFSET;\n  undefined auStack_58 [24];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (char **)0x0) {\nLAB_001709c0:\n    puVar3 = (undefined2 *)0x0;\n    goto LAB_0017084a;\n  }\n  if (param_3 == 2) {\n    if ((*(uint *)(param_1 + 5) & 4) == 0) {\n      lVar2 = assoc_to_kvpair(param_1[1],0);\n    }\n    else {\n      lVar2 = array_to_kvpair();\n    }\nLAB_00170775:\n    if (lVar2 != 0) goto LAB_0017077e;\nLAB_00170881:\n    if (((*(byte *)((long)param_1 + 0x29) & 0x10) != 0) || (param_1[1] == (char *)0x0)) {\n      if (param_3 == 2) goto LAB_001709c0;\n      iVar1 = var_attribute_string(param_1,0,auStack_58);\n      lVar2 = (long)iVar1;\n      goto LAB_001708af;\n    }\n    puVar3 = (undefined2 *)sh_xmalloc(3,\"subst.c\",0x20cc);\n    *puVar3 = 0x2928;\n    *(undefined *)(puVar3 + 1) = 0;\n    if (param_3 == 2) goto LAB_0017084a;\n    iVar1 = var_attribute_string(param_1,0,auStack_58);\n    lVar2 = (long)iVar1;\n    __s = puVar3;\nLAB_001707d0:\n    sVar5 = 0;\n    if (((*(char *)__s != '\\0') && (sVar5 = 1, *(char *)((long)__s + 1) != '\\0')) &&\n       (sVar5 = 2, *(char *)(__s + 1) != '\\0')) {\n      sVar5 = strlen((char *)__s);\n    }\n    sVar4 = strlen(*param_1);\n    puVar3 = (undefined2 *)sh_xmalloc(lVar2 + 0x10 + sVar5 + sVar4,\"subst.c\",0x20dc);\n    __sprintf_chk(puVar3,1,0xffffffffffffffff,\"declare -%s %s=%s\",auStack_58,*param_1,__s);\n  }\n  else {\n    if ((*(uint *)(param_1 + 5) & 4) == 0) {\n      lVar2 = assoc_to_assign();\n      goto LAB_00170775;\n    }\n    lVar2 = array_to_assign();\n    if (lVar2 == 0) goto LAB_00170881;\nLAB_0017077e:\n    if ((param_2 & 3) == 0) {\n      puVar3 = (undefined2 *)FUN_00167220(lVar2,0);\n    }\n    else {\n      puVar3 = (undefined2 *)quote_string(lVar2);\n    }\n    sh_xfree(lVar2,\"subst.c\",0x20d4);\n    if (param_3 == 2) goto LAB_0017084a;\n    iVar1 = var_attribute_string(param_1,0,auStack_58);\n    lVar2 = (long)iVar1;\n    __s = puVar3;\n    if (puVar3 != (undefined2 *)0x0) goto LAB_001707d0;\nLAB_001708af:\n    sVar5 = strlen(*param_1);\n    puVar3 = (undefined2 *)sh_xmalloc(lVar2 + 0x10 + sVar5,\"subst.c\",0x20dc);\n    __sprintf_chk(puVar3,1,0xffffffffffffffff,\"declare -%s %s\",auStack_58,*param_1);\n    __s = (undefined2 *)0x0;\n  }\n  sh_xfree(__s,\"subst.c\",0x20e1);\nLAB_0017084a:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0016af90": "\nulong FUN_0016af90(long param_1,uint param_2,uint param_3)\n\n{\n  char cVar1;\n  bool bVar2;\n  undefined4 uVar3;\n  mbstate_t mVar4;\n  int iVar5;\n  size_t sVar6;\n  ulong uVar7;\n  ulong uVar8;\n  byte bVar9;\n  ulong uVar10;\n  byte *pbVar11;\n  uint uVar12;\n  int iVar13;\n  long in_FS_OFFSET;\n  bool bVar14;\n  uint local_54;\n  mbstate_t local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  uVar8 = (ulong)param_2;\n  uVar10 = (ulong)(int)param_2;\n  pbVar11 = (byte *)(param_1 + uVar10);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50.__count = 0;\n  local_50.__value = (_union_27)0x0;\n  sVar6 = strlen((char *)pbVar11);\n  uVar3 = no_longjmp_on_fatal_error;\n  uVar7 = sVar6 + uVar10;\n  no_longjmp_on_fatal_error = 1;\n  if ((param_3 & 2) == 0) {\n    uVar8 = (ulong)(param_2 + 1);\n    uVar10 = (ulong)(int)(param_2 + 1);\n    pbVar11 = (byte *)(param_1 + uVar10);\n  }\n  bVar9 = *pbVar11;\n  iVar13 = 1;\n  bVar14 = false;\n  if (bVar9 != 0) {\n    bVar2 = false;\n    do {\n      mVar4 = local_50;\n      uVar12 = (uint)uVar8;\n      if (bVar2) {\n        if (locale_mb_cur_max < 2) {\nLAB_0016b1b5:\n          uVar8 = (ulong)(uVar12 + 1);\n        }\n        else {\n          if ((*(uint *)(is_basic_table + (ulong)(bVar9 >> 5) * 4) >> (bVar9 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale == 0) || (sVar6 = 1, (char)bVar9 < '\\0')) {\n              sVar6 = mbrtowc((wchar_t *)0x0,(char *)pbVar11,uVar7 - uVar10,&local_50);\n              if (0xfffffffffffffffd < sVar6) {\n                uVar8 = (ulong)(uVar12 + 1);\n                local_50 = mVar4;\n                goto LAB_0016b14c;\n              }\n              if (sVar6 == 0) goto LAB_0016b1b5;\n            }\n          }\n          else {\n            sVar6 = 1;\n          }\n          uVar8 = (ulong)(uVar12 + (int)sVar6);\n        }\nLAB_0016b14c:\n        bVar2 = false;\n        uVar10 = (ulong)(int)uVar8;\n      }\n      else if ((param_3 & 1) == 0) {\n        if (bVar9 == 0x5c) {\n          uVar8 = (ulong)(uVar12 + 1);\n          bVar2 = true;\n          uVar10 = (ulong)(int)(uVar12 + 1);\n          local_50 = mVar4;\n        }\n        else {\n          if (bVar14) goto LAB_0016b1c0;\n          if (bVar9 == 0x60) {\n            uVar8 = (ulong)(uVar12 + 1);\n            bVar14 = true;\n            uVar10 = (ulong)(int)(uVar12 + 1);\n            local_50 = mVar4;\n          }\n          else {\n            if (bVar9 == 0x5b) {\n              iVar13 = iVar13 + 1;\n              goto LAB_0016b25c;\n            }\n            if (bVar9 == 0x5d) goto LAB_0016b0ce;\n            if ((bVar9 != 0x27) && (bVar9 != 0x22)) {\n              if ((bVar9 != 0x24) ||\n                 ((cVar1 = *(char *)(param_1 + 1 + uVar10), cVar1 != '(' && (cVar1 != '{'))))\n              goto LAB_0016b089;\n              local_54 = uVar12 + 2;\n              uVar8 = (ulong)local_54;\n              if (*(char *)(param_1 + (int)local_54) == '\\0') goto LAB_0016b0de;\n              if (cVar1 == '(') {\n                FUN_0016b780(param_1,&local_54,&DAT_001fe090,&DAT_001fe091,&DAT_001fc61f,9);\n              }\n              else {\n                FUN_001691b0(param_1,&local_54,0,1);\n              }\n              uVar8 = (ulong)(int)local_54;\n              if (uVar7 <= uVar8) {\n                uVar8 = uVar7 & 0xffffffff;\n                goto LAB_0016b0de;\n              }\n              uVar12 = local_54;\n              if (*(char *)(param_1 + uVar8) != '\\0') goto LAB_0016b1b5;\n              break;\n            }\n            uVar12 = uVar12 + 1;\n            uVar8 = (ulong)uVar12;\n            if (bVar9 == 0x27) {\n              uVar10 = (ulong)(int)uVar12;\n              local_48.__count = 0;\n              local_48.__value = (_union_27)0x0;\n              pbVar11 = (byte *)(param_1 + uVar10);\n              bVar9 = *pbVar11;\n              if (bVar9 != 0) {\n                if (bVar9 != 0x27) {\n                  uVar8 = (ulong)uVar12;\n                  do {\n                    mVar4 = local_48;\n                    iVar5 = (int)uVar8;\n                    if (locale_mb_cur_max < 2) {\nLAB_0016b462:\n                      uVar8 = (ulong)(iVar5 + 1);\n                    }\n                    else {\n                      if ((*(uint *)(is_basic_table + (ulong)(bVar9 >> 5) * 4) >> (bVar9 & 0x1f) & 1\n                          ) == 0) {\n                        if ((locale_utf8locale == 0) || (sVar6 = 1, (char)bVar9 < '\\0')) {\n                          sVar6 = mbrtowc((wchar_t *)0x0,(char *)pbVar11,uVar7 - uVar10,&local_48);\n                          if (0xfffffffffffffffd < sVar6) {\n                            uVar8 = (ulong)(iVar5 + 1);\n                            local_48 = mVar4;\n                            goto LAB_0016b441;\n                          }\n                          if (sVar6 == 0) goto LAB_0016b462;\n                        }\n                      }\n                      else {\n                        sVar6 = 1;\n                      }\n                      uVar8 = (ulong)(uint)(iVar5 + (int)sVar6);\n                    }\nLAB_0016b441:\n                    uVar10 = (ulong)(int)uVar8;\n                    pbVar11 = (byte *)(param_1 + uVar10);\n                    bVar9 = *pbVar11;\n                    if (bVar9 == 0) goto LAB_0016b334;\n                  } while (bVar9 != 0x27);\n                  bVar9 = 0x27;\n                }\n                if (bVar9 != 0) {\n                  uVar12 = (int)uVar8 + 1;\n                  uVar8 = (ulong)uVar12;\n                  uVar10 = (ulong)(int)uVar12;\n                }\n              }\n            }\n            else {\n              iVar5 = FUN_0016a7c0(param_1,uVar7,uVar8,0);\n              uVar10 = (ulong)iVar5;\n              uVar8 = uVar10;\n            }\nLAB_0016b334:\n            bVar2 = false;\n          }\n        }\n      }\n      else if (bVar14) {\nLAB_0016b1c0:\n        bVar14 = bVar9 != 0x60;\n        if (locale_mb_cur_max < 2) {\nLAB_0016b25c:\n          uVar8 = (ulong)(uVar12 + 1);\n          uVar10 = (ulong)(int)(uVar12 + 1);\n          local_50 = mVar4;\n        }\n        else {\n          if ((*(uint *)(is_basic_table + (ulong)(bVar9 >> 5) * 4) >> (bVar9 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale == 0) || (sVar6 = 1, (char)bVar9 < '\\0')) {\n              sVar6 = mbrtowc((wchar_t *)0x0,(char *)pbVar11,uVar7 - uVar10,&local_50);\n              if (sVar6 < 0xfffffffffffffffe) {\n                if (sVar6 != 0) goto LAB_0016b2fd;\n                uVar8 = (ulong)(uVar12 + 1);\n                uVar10 = (ulong)(int)(uVar12 + 1);\n              }\n              else {\n                uVar8 = (ulong)(uVar12 + 1);\n                uVar10 = (ulong)(int)(uVar12 + 1);\n                local_50 = mVar4;\n              }\n              goto LAB_0016b152;\n            }\n          }\n          else {\n            sVar6 = 1;\n          }\nLAB_0016b2fd:\n          uVar12 = uVar12 + (int)sVar6;\n          uVar8 = (ulong)uVar12;\n          uVar10 = (ulong)(int)uVar12;\n        }\n      }\n      else {\n        if (bVar9 == 0x5d) {\nLAB_0016b0ce:\n          iVar13 = iVar13 + -1;\n          if (iVar13 == 0) break;\nLAB_0016b2c0:\n          uVar8 = (ulong)(uVar12 + 1);\n        }\n        else {\nLAB_0016b089:\n          if (locale_mb_cur_max < 2) goto LAB_0016b2c0;\n          if ((*(uint *)(is_basic_table + (ulong)(bVar9 >> 5) * 4) >> (bVar9 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale != 0) && (sVar6 = 1, -1 < (char)bVar9)) goto LAB_0016b0b2;\n            sVar6 = mbrtowc((wchar_t *)0x0,(char *)pbVar11,uVar7 - uVar10,&local_50);\n            if (sVar6 < 0xfffffffffffffffe) {\n              if (sVar6 == 0) goto LAB_0016b2c0;\n              goto LAB_0016b0b2;\n            }\n            uVar8 = (ulong)(uVar12 + 1);\n            local_50 = mVar4;\n          }\n          else {\n            sVar6 = 1;\nLAB_0016b0b2:\n            uVar8 = (ulong)(uVar12 + (int)sVar6);\n          }\n        }\n        bVar14 = false;\n        uVar10 = (ulong)(int)uVar8;\n      }\nLAB_0016b152:\n      pbVar11 = (byte *)(param_1 + uVar10);\n      bVar9 = *pbVar11;\n    } while (bVar9 != 0);\n    uVar8 = uVar8 & 0xffffffff;\n  }\nLAB_0016b0de:\n  no_longjmp_on_fatal_error = uVar3;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar8;\n}\n\n",
  "FUN_0018cd60": "\nlong * FUN_0018cd60(undefined8 param_1,uint param_2,uint param_3,ushort *param_4)\n\n{\n  char cVar1;\n  ushort uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  size_t sVar5;\n  long *plVar6;\n  char *__dest;\n  char *pcVar7;\n  uint uVar8;\n  undefined8 uVar9;\n  long unaff_R15;\n  long in_FS_OFFSET;\n  int local_4c;\n  char *local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar3 = array_variable_name(param_1,param_3,&local_48);\n  if (lVar3 == 0) {\n    if (local_4c == 0) goto LAB_0018d060;\nLAB_0018cf55:\n    if (param_4 == (ushort *)0x0) {\n      cVar1 = *local_48;\n      uVar2 = (ushort)(cVar1 == '*');\n      if ((cVar1 != '@') && (cVar1 != '*')) {\nLAB_0018d049:\n        lVar3 = array_expand_index(0,local_48,(long)local_4c,param_3);\n        if (-1 < lVar3) goto LAB_0018d060;\nLAB_0018d2c8:\n        local_48[-1] = '\\0';\n        err_badarraysub(param_1);\n        local_48[-1] = '[';\n        plVar6 = (long *)0x0;\n        goto LAB_0018cf20;\n      }\n      puVar4 = (undefined8 *)0x0;\nLAB_0018cf80:\n      if (local_48[1] != ']') goto LAB_0018ce8f;\n      if (param_4 != (ushort *)0x0) goto LAB_0018cf8f;\nLAB_0018cf9d:\n      if ((param_3 & 1) == 0) {\n        err_badarraysub(param_1);\n        plVar6 = (long *)0x0;\n        goto LAB_0018cf20;\n      }\n      if (((puVar4 != (undefined8 *)0x0) && (puVar4[1] != 0)) &&\n         (uVar8 = *(uint *)(puVar4 + 5), (uVar8 & 0x1000) == 0)) {\n        if ((uVar8 & 0x44) == 0) {\n          if (param_4 != (ushort *)0x0) {\n            *param_4 = 0;\n          }\n          uVar9 = make_word();\n          lVar3 = make_word_list(uVar9,0);\n        }\n        else if ((uVar8 & 0x40) == 0) {\n          if (param_4 != (ushort *)0x0) {\n            *param_4 = 1;\n          }\n          lVar3 = array_to_word_list();\n          if (lVar3 == 0) {\n            plVar6 = (long *)0x0;\n            goto LAB_0018cf20;\n          }\n        }\n        else {\n          if (param_4 != (ushort *)0x0) {\n            *param_4 = 2;\n          }\n          lVar3 = assoc_to_word_list();\n          if (lVar3 == 0) goto LAB_0018d060;\n        }\n        if ((*local_48 == '*') && ((param_2 & 3) != 0)) {\n          uVar9 = string_list_dollar_star(lVar3,param_2,(int)param_3 >> 1 & 8);\n          plVar6 = (long *)quote_string(uVar9);\n          sh_xfree(uVar9,\"arrayfunc.c\",0x611);\n        }\n        else {\n          plVar6 = (long *)string_list_dollar_at();\n        }\n        dispose_words(lVar3);\n        goto LAB_0018cf20;\n      }\n    }\n    else {\n      *(undefined8 *)(param_4 + 0xc) = 0;\n      cVar1 = *local_48;\n      uVar2 = (ushort)(cVar1 == '*');\n      if ((cVar1 == '@') || (cVar1 == '*')) {\n        puVar4 = (undefined8 *)0x0;\n        if (local_48[1] != ']') goto LAB_0018ce8f;\nLAB_0018cf8f:\n        param_4[1] = 2 - uVar2;\n        goto LAB_0018cf9d;\n      }\n      puVar4 = (undefined8 *)0x0;\n      param_4[1] = 0;\nLAB_0018ceb4:\n      if (((param_3 & 4) == 0) || (param_4 == (ushort *)0x0)) {\n        unaff_R15 = array_expand_index(puVar4,local_48,(long)local_4c,param_3);\n        if (unaff_R15 < 0) {\n          if (puVar4 == (undefined8 *)0x0) goto LAB_0018d2c8;\n          goto LAB_0018d1f9;\n        }\n        if (param_4 == (ushort *)0x0) goto LAB_0018d119;\nLAB_0018d161:\n        *(long *)(param_4 + 4) = unaff_R15;\n      }\n      else {\n        unaff_R15 = *(long *)(param_4 + 4);\n      }\n      if (param_4 == (ushort *)0x0) {\nLAB_0018d119:\n        if (puVar4 != (undefined8 *)0x0) goto LAB_0018d122;\n      }\n      else if (puVar4 != (undefined8 *)0x0) {\n        *param_4 = (ushort)(*(int *)(puVar4 + 5) >> 2) & 1;\n        plVar6 = (long *)puVar4[1];\n        if (plVar6 != (long *)0x0) goto LAB_0018cef6;\n      }\n    }\nLAB_0018d060:\n    plVar6 = (long *)0x0;\n    goto LAB_0018cf20;\n  }\n  puVar4 = (undefined8 *)find_variable(lVar3);\n  sh_xfree(lVar3,\"arrayfunc.c\",0x5ad);\n  if (local_4c == 0) goto LAB_0018d060;\n  if (puVar4 == (undefined8 *)0x0) goto LAB_0018cf55;\n  uVar8 = *(uint *)(puVar4 + 5);\n  if (param_4 != (ushort *)0x0) {\n    *(undefined8 *)(param_4 + 0xc) = 0;\n  }\n  if (((uVar8 & 0x40) == 0) || ((param_3 & 0x80) == 0)) {\n    cVar1 = *local_48;\n    uVar2 = (ushort)(cVar1 == '*');\n    if ((cVar1 == '@') || (cVar1 == '*')) goto LAB_0018cf80;\nLAB_0018ce8f:\n    if (param_4 != (ushort *)0x0) {\n      param_4[1] = 0;\n      if (puVar4 == (undefined8 *)0x0) goto LAB_0018ceb4;\n      uVar8 = *(uint *)(puVar4 + 5);\n      goto joined_r0x0018ceae;\n    }\n    if (puVar4 == (undefined8 *)0x0) goto LAB_0018d049;\nLAB_0018d0f0:\n    if ((*(uint *)(puVar4 + 5) & 0x44) != 0x40) {\n      unaff_R15 = array_expand_index(puVar4,local_48,(long)local_4c,param_3);\n      if (-1 < unaff_R15) goto LAB_0018d119;\nLAB_0018d1f9:\n      if ((*(byte *)(puVar4 + 5) & 4) != 0) {\n        plVar6 = (long *)puVar4[1];\n        unaff_R15 = unaff_R15 + 1 + *plVar6;\n        if (-1 < unaff_R15) {\n          if (param_4 != (ushort *)0x0) goto LAB_0018d161;\n          goto LAB_0018cef6;\n        }\n      }\nLAB_0018d250:\n      err_badarraysub(*puVar4);\n      plVar6 = (long *)0x0;\n      goto LAB_0018cf20;\n    }\n    if ((*(uint *)(puVar4 + 5) & 0x40) == 0) goto LAB_0018d122;\n    local_48[(long)local_4c + -1] = '\\0';\nLAB_0018d17e:\n    pcVar7 = local_48;\n    if ((param_3 & 0x20) == 0) {\n      pcVar7 = (char *)expand_subscript_string(local_48,0);\n      local_48[(long)local_4c + -1] = ']';\n      if (pcVar7 == (char *)0x0) goto LAB_0018d250;\n    }\n    else {\n      sVar5 = strlen(local_48);\n      uVar9 = 0x63b;\nLAB_0018d271:\n      __dest = (char *)sh_xmalloc(sVar5 + 1,\"arrayfunc.c\",uVar9);\n      pcVar7 = strcpy(__dest,pcVar7);\n      local_48[(long)local_4c + -1] = ']';\n    }\n    if (*pcVar7 == '\\0') {\n      sh_xfree(pcVar7,\"arrayfunc.c\",0x63f);\n      goto LAB_0018d250;\n    }\n    plVar6 = (long *)puVar4[1];\n    if (plVar6 == (long *)0x0) {\n      sh_xfree(pcVar7,\"arrayfunc.c\",0x646);\n      goto LAB_0018cf20;\n    }\n    uVar8 = *(uint *)(puVar4 + 5);\n    if ((uVar8 & 0x1000) != 0) {\n      sh_xfree(pcVar7,\"arrayfunc.c\",0x64b);\n      plVar6 = (long *)0x0;\n      goto LAB_0018cf20;\n    }\n  }\n  else {\n    if (param_4 == (ushort *)0x0) goto LAB_0018d0f0;\n    uVar8 = *(uint *)(puVar4 + 5);\n    param_4[1] = 0;\njoined_r0x0018ceae:\n    if ((uVar8 & 0x44) != 0x40) goto LAB_0018ceb4;\n    if ((uVar8 & 0x40) != 0) {\n      local_48[(long)local_4c + -1] = '\\0';\n      if (((param_4 == (ushort *)0x0) || (*param_4 = 2, (param_3 & 4) == 0)) ||\n         (pcVar7 = *(char **)(param_4 + 8), pcVar7 == (char *)0x0)) goto LAB_0018d17e;\n      sVar5 = strlen(pcVar7);\n      uVar9 = 0x637;\n      goto LAB_0018d271;\n    }\nLAB_0018d122:\n    plVar6 = (long *)puVar4[1];\n    if (plVar6 == (long *)0x0) {\n      plVar6 = (long *)0x0;\n      goto LAB_0018cf20;\n    }\nLAB_0018cef6:\n    uVar8 = *(uint *)(puVar4 + 5);\n    if ((uVar8 & 0x1000) != 0) goto LAB_0018d060;\n    pcVar7 = (char *)0x0;\n  }\n  if ((uVar8 & 0x44) == 0) {\n    if (unaff_R15 != 0) {\n      plVar6 = (long *)0x0;\n    }\nLAB_0018cf17:\n    if (param_4 == (ushort *)0x0) goto LAB_0018cf20;\n  }\n  else {\n    if ((uVar8 & 0x40) == 0) {\n      plVar6 = (long *)array_reference(plVar6,unaff_R15);\n      goto LAB_0018cf17;\n    }\n    plVar6 = (long *)assoc_reference(plVar6,pcVar7);\n    if (param_4 == (ushort *)0x0) {\n      sh_xfree(pcVar7,\"arrayfunc.c\",0x658);\n      goto LAB_0018cf20;\n    }\n    if ((*(long *)(param_4 + 8) == 0) || ((param_3 & 4) == 0)) {\n      *(char **)(param_4 + 8) = pcVar7;\n    }\n    else {\n      sh_xfree(pcVar7,\"arrayfunc.c\",0x654);\n    }\n  }\n  *(long **)(param_4 + 0xc) = plVar6;\nLAB_0018cf20:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return plVar6;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_cleanup_after_signal": "\nvoid rl_cleanup_after_signal(void)\n\n{\n  _rl_clean_up_for_exit();\n  if (rl_deprep_term_function != (undefined *)0x0) {\n    (*(code *)rl_deprep_term_function)();\n  }\n  rl_clear_pending_input();\n  rl_clear_signals();\n  return;\n}\n\n",
  "parse_string": "\n/* WARNING: Removing unreachable block (ram,0x001a8f63) */\n\nulong parse_string(undefined8 param_1,undefined8 param_2,uint param_3,undefined8 *param_4,\n                  char **param_5)\n\n{\n  bool bVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  int iVar4;\n  int iVar5;\n  ulong uVar6;\n  long in_FS_OFFSET;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  FUN_001a8750(param_1,param_3,\"parse_string top\");\n  sigemptyset(&local_a8);\n  sigprocmask(0,(sigset_t *)0x0,&local_a8);\n  push_stream(0);\n  iVar4 = parser_expanding_alias();\n  if (iVar4 != 0) {\n    parser_save_alias();\n  }\n  uVar2 = global_command;\n  iVar4 = 0;\n  with_input_from_string(param_1,param_2);\n  pcVar3 = DAT_00240a70;\n  do {\n    bVar1 = false;\n    if (*DAT_00240a70 == '\\0') goto LAB_001a8e01;\n    iVar4 = __sigsetjmp(top_level,0);\n    if (iVar4 != 0) {\n      if (iVar4 < 5) {\n        if (0 < iVar4) {\nLAB_001a8f6d:\n          bVar1 = true;\n          goto LAB_001a8e01;\n        }\n      }\n      else if (iVar4 == 6) goto LAB_001a8f6d;\n      sigprocmask(2,&local_a8,(sigset_t *)0x0);\n      command_error(\"parse_string\",3,iVar4,0);\n    }\n    bVar1 = false;\n    iVar5 = parse_command();\n    if (iVar5 != 0) {\n      if ((param_3 & 0x40) == 0) {\n        bVar1 = true;\n        iVar4 = 2;\n      }\n      else {\n        reset_parser();\n      }\n      goto LAB_001a8e01;\n    }\n    if (param_4 == (undefined8 *)0x0) {\n      dispose_command();\n    }\n    else {\n      *param_4 = global_command;\n    }\n    bVar1 = false;\n    global_command = 0;\n    if (current_token == 0x131) {\n      if (shell_eof_token != 0x131) goto LAB_001a8e01;\n      goto LAB_001a9000;\n    }\n    if (current_token == shell_eof_token) {\nLAB_001a9000:\n      rewind_input_string();\nLAB_001a8e01:\n      uVar6 = (long)DAT_00240a70 - (long)pcVar3;\n      global_command = uVar2;\n      if (param_5 != (char **)0x0) {\n        *param_5 = DAT_00240a70;\n      }\n      run_unwind_frame(\"parse_string top\");\n      if (bVar1) {\n        if (parse_and_execute_level == 0) {\n          top_level_cleanup();\n        }\n        if (iVar4 != 2) {\n                    /* WARNING: Subroutine does not return */\n          jump_to_top_level(iVar4);\n        }\n        uVar6 = 0xfffffffe;\n      }\n      else {\n        uVar6 = uVar6 & 0xffffffff;\n      }\n      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return uVar6;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n  } while( true );\n}\n\n",
  "ttfd_eightbit": "\nvoid ttfd_eightbit(int param_1,termios *param_2)\n\n{\n  param_2->c_iflag = param_2->c_iflag & 0xffffffdf;\n  param_2->c_cflag = param_2->c_cflag & 0xfffffeff | 0x30;\n  tcsetattr(param_1,1,param_2);\n  return;\n}\n\n",
  "_rl_reset_argument": "\nvoid _rl_reset_argument(void)\n\n{\n  rl_arg_sign = 1;\n  rl_numeric_arg = 1;\n  rl_explicit_arg = 0;\n  _rl_argcxt = 0;\n  return;\n}\n\n",
  "FUN_0019ed40": "\nlong * FUN_0019ed40(long *param_1,char *param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  char cVar2;\n  long lVar3;\n  int iVar4;\n  char *pcVar5;\n  long *plVar6;\n  bool bVar7;\n  long lVar8;\n  char *local_40;\n  \n  pcVar5 = param_2;\n  if (param_2 == (char *)0x0) {\n    plVar6 = (long *)FUN_00131c76();\n    return plVar6;\n  }\n  for (; cVar2 = *pcVar5, local_40 = param_2, cVar2 != '\\0'; pcVar5 = pcVar5 + 1) {\n    if (cVar2 == '\\\\') {\n      pcVar5 = pcVar5 + 1;\n    }\n    else if (cVar2 == '&') {\n      local_40 = (char *)strcreplace(param_2,0x26,param_3,1);\n      break;\n    }\n  }\n  pcVar5 = local_40;\n  bVar7 = false;\n  if (*local_40 == '!') {\n    if (extended_glob == 0) {\n      pcVar5 = local_40 + 1;\n      bVar7 = true;\n    }\n    else {\n      bVar7 = false;\n      if (local_40[1] != '(') {\n        bVar7 = true;\n        pcVar5 = local_40 + 1;\n      }\n    }\n  }\n  lVar8 = 0;\n  plVar6 = (long *)strlist_create(*(undefined4 *)(param_1 + 1));\n  if (0 < *(int *)((long)param_1 + 0xc)) {\n    do {\n      while( true ) {\n        lVar1 = lVar8 * 8;\n        iVar4 = strmatch(pcVar5,*(undefined8 *)(*param_1 + lVar8 * 8),\n                         (uint)(match_ignore_case != 0) << 4 | (uint)(extended_glob != 0) << 5);\n        if ((iVar4 != 1) != bVar7) break;\n        iVar4 = *(int *)((long)plVar6 + 0xc);\n        lVar3 = *param_1;\n        lVar8 = lVar8 + 1;\n        *(int *)((long)plVar6 + 0xc) = iVar4 + 1;\n        *(undefined8 *)(*plVar6 + (long)iVar4 * 8) = *(undefined8 *)(lVar1 + lVar3);\n        if (*(int *)((long)param_1 + 0xc) == (int)lVar8 ||\n            *(int *)((long)param_1 + 0xc) < (int)lVar8) goto LAB_0019ee5b;\n      }\n      lVar1 = lVar8 * 8;\n      lVar8 = lVar8 + 1;\n      sh_xfree(*(undefined8 *)(*param_1 + lVar1),\"pcomplete.c\",0x13f);\n    } while (*(int *)((long)param_1 + 0xc) != (int)lVar8 &&\n             (int)lVar8 <= *(int *)((long)param_1 + 0xc));\n  }\nLAB_0019ee5b:\n  *(undefined8 *)(*plVar6 + (long)*(int *)((long)plVar6 + 0xc) * 8) = 0;\n  if (param_2 != local_40) {\n    sh_xfree(local_40,\"pcomplete.c\",0x146);\n  }\n  return plVar6;\n}\n\n",
  "compgen_builtin": "\nint compgen_builtin(long param_1)\n\n{\n  undefined4 uVar1;\n  ulong uVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  size_t sVar5;\n  char *pcVar6;\n  char *pcVar7;\n  long *plVar8;\n  undefined8 uVar9;\n  undefined *puVar10;\n  long in_FS_OFFSET;\n  undefined8 local_50;\n  ulong local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\nLAB_001bcbb0:\n    iVar3 = 0;\n    goto LAB_001bcb8d;\n  }\n  local_48 = 0;\n  local_50 = 0;\n  DAT_00248e20 = (char *)0x0;\n  DAT_00248e28 = (char *)0x0;\n  DAT_00248e30 = (char *)0x0;\n  DAT_00248e38 = (char *)0x0;\n  DAT_00248e40 = (char *)0x0;\n  DAT_00248e48 = (char *)0x0;\n  DAT_00248e50 = (char *)0x0;\n  iVar3 = FUN_001bb8a0(param_1,0,&local_50,&local_48);\n  if (iVar3 == 0x102) goto LAB_001bcb8d;\n  if (iVar3 == 1) goto LAB_001bcbb0;\n  puVar10 = &DAT_00213d70;\n  if ((loptend != 0) && (*(undefined8 **)(loptend + 8) != (undefined8 *)0x0)) {\n    puVar10 = (undefined *)**(undefined8 **)(loptend + 8);\n  }\n  if (DAT_00248e28 != (char *)0x0) {\n    builtin_error(\"warning: -F option may not work as you expect\");\n  }\n  if (DAT_00248e20 != (char *)0x0) {\n    builtin_error(\"warning: -C option may not work as you expect\");\n  }\n  puVar4 = (undefined4 *)compspec_create();\n  uVar2 = local_48;\n  pcVar7 = DAT_00248e50;\n  *(ulong *)(puVar4 + 4) = local_48;\n  *(undefined8 *)(puVar4 + 2) = local_50;\n  *puVar4 = 1;\n  if (pcVar7 != (char *)0x0) {\n    sVar5 = strlen(pcVar7);\n    pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"./complete.def\",0x2c2);\n    pcVar7 = strcpy(pcVar6,pcVar7);\n  }\n  *(char **)(puVar4 + 6) = pcVar7;\n  pcVar7 = DAT_00248e48;\n  if (DAT_00248e48 != (char *)0x0) {\n    sVar5 = strlen(DAT_00248e48);\n    pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"./complete.def\",0x2c3);\n    pcVar7 = strcpy(pcVar6,pcVar7);\n  }\n  *(char **)(puVar4 + 8) = pcVar7;\n  pcVar7 = DAT_00248e40;\n  if (DAT_00248e40 != (char *)0x0) {\n    sVar5 = strlen(DAT_00248e40);\n    pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"./complete.def\",0x2c4);\n    pcVar7 = strcpy(pcVar6,pcVar7);\n  }\n  *(char **)(puVar4 + 10) = pcVar7;\n  pcVar7 = DAT_00248e38;\n  if (DAT_00248e38 != (char *)0x0) {\n    sVar5 = strlen(DAT_00248e38);\n    pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"./complete.def\",0x2c5);\n    pcVar7 = strcpy(pcVar6,pcVar7);\n  }\n  *(char **)(puVar4 + 0xc) = pcVar7;\n  pcVar7 = DAT_00248e28;\n  if (DAT_00248e28 != (char *)0x0) {\n    sVar5 = strlen(DAT_00248e28);\n    pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"./complete.def\",0x2c6);\n    pcVar7 = strcpy(pcVar6,pcVar7);\n  }\n  *(char **)(puVar4 + 0xe) = pcVar7;\n  pcVar7 = DAT_00248e20;\n  if (DAT_00248e20 != (char *)0x0) {\n    sVar5 = strlen(DAT_00248e20);\n    pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"./complete.def\",0x2c7);\n    pcVar7 = strcpy(pcVar6,pcVar7);\n  }\n  *(char **)(puVar4 + 0x10) = pcVar7;\n  pcVar7 = DAT_00248e30;\n  if (DAT_00248e30 != (char *)0x0) {\n    sVar5 = strlen(DAT_00248e30);\n    pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"./complete.def\",0x2c8);\n    pcVar7 = strcpy(pcVar6,pcVar7);\n  }\n  *(char **)(puVar4 + 0x14) = pcVar7;\n  uVar9 = pcomp_line;\n  uVar1 = pcomp_ind;\n  pcomp_line = 0;\n  pcomp_ind = 0;\n  plVar8 = (long *)gen_compspec_completions(puVar4,\"compgen\",puVar10,0,0,0);\n  pcomp_ind = uVar1;\n  pcomp_line = uVar9;\n  if (plVar8 == (long *)0x0) {\n    if ((uVar2 & 0x40) != 0) {\nLAB_001bcb30:\n      uVar9 = bash_default_completion(puVar10,0,0,0,0);\n      plVar8 = (long *)completions_to_stringlist(uVar9);\n      strvec_dispose(uVar9);\n      if (plVar8 != (long *)0x0) {\n        if (*(int *)((long)plVar8 + 0xc) != 0) goto LAB_001bcb70;\n        goto LAB_001bcac5;\n      }\n    }\n    if ((uVar2 & 2) != 0) {\n      plVar8 = (long *)0x0;\nLAB_001bcacf:\n      uVar9 = rl_completion_matches(puVar10,rl_filename_completion_function);\n      strlist_dispose(plVar8);\n      plVar8 = (long *)completions_to_stringlist(uVar9);\n      strvec_dispose(uVar9);\n      if (plVar8 != (long *)0x0) {\n        if ((*plVar8 != 0) && (*(int *)((long)plVar8 + 0xc) != 0)) goto LAB_001bcb18;\n        goto LAB_001bcb77;\n      }\n    }\n    iVar3 = 1;\n  }\n  else {\n    if (*(int *)((long)plVar8 + 0xc) == 0) {\n      if ((uVar2 & 0x40) != 0) goto LAB_001bcb30;\nLAB_001bcac5:\n      if ((uVar2 & 2) != 0) goto LAB_001bcacf;\nLAB_001bcb77:\n      iVar3 = 1;\n    }\n    else {\nLAB_001bcb70:\n      if (*plVar8 == 0) goto LAB_001bcb77;\nLAB_001bcb18:\n      iVar3 = 0;\n      strlist_print(plVar8,0);\n    }\n    strlist_dispose(plVar8);\n  }\n  compspec_dispose(puVar4);\nLAB_001bcb8d:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar3;\n}\n\n",
  "rl_backward": "\nvoid rl_backward(void)\n\n{\n  rl_backward_char();\n  return;\n}\n\n",
  "FUN_00191e10": "\nbool FUN_00191e10(char *param_1,int param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  size_t sVar4;\n  char *pcVar5;\n  long in_FS_OFFSET;\n  stat sStack_b8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 0) {\n    sVar4 = strlen(param_1);\n    pcVar3 = (char *)sh_xmalloc(sVar4 + 1,\"bashline.c\",0xd1f);\n    pcVar3 = strcpy(pcVar3,param_1);\n  }\n  else {\n    pcVar3 = (char *)FUN_00191560(param_1,rl_completion_quote_character);\n    if (pcVar3 == (char *)0x0) {\n      pcVar5 = &DAT_ffffffffffffffff;\n      cVar1 = DAT_ffffffffffffffff;\n      goto LAB_00191eab;\n    }\n  }\n  if (*pcVar3 == '\\0') {\n    pcVar5 = pcVar3 + -1;\n    cVar1 = pcVar3[-1];\n  }\n  else {\n    pcVar5 = pcVar3;\n    cVar1 = *pcVar3;\n    if (pcVar3[1] != '\\0') {\n      if (pcVar3[2] == '\\0') {\n        pcVar5 = pcVar3 + 1;\n        cVar1 = pcVar3[1];\n      }\n      else {\n        sVar4 = strlen(pcVar3);\n        pcVar5 = pcVar3 + (long)(int)sVar4 + -1;\n        cVar1 = *pcVar5;\n      }\n    }\n  }\nLAB_00191eab:\n  if (cVar1 == '/') {\n    *pcVar5 = '\\0';\n  }\n  iVar2 = lstat(pcVar3,&sStack_b8);\n  sh_xfree(pcVar3,\"bashline.c\",0xd28);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2 == 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "list_all_jobs": "\nvoid list_all_jobs(undefined4 param_1)\n\n{\n  if (DAT_0023877c == 0) {\n    return;\n  }\n  if (DAT_00247660 == 0) {\n    FUN_001626a0();\n    if (DAT_0023877c == 0) {\n      return;\n    }\n  }\n  FUN_0015f750(param_1,0xffffffff);\n  return;\n}\n\n",
  "set_compatibility_opts": "\nvoid set_compatibility_opts(void)\n\n{\n  DAT_00248d60 = 0;\n  DAT_00248d64 = 0;\n  DAT_00248d50 = 0;\n  DAT_00248d54 = 0;\n  DAT_00248d58 = 0;\n  DAT_00248d5c = 0;\n  DAT_00248d4c = 0;\n  switch(shell_compatibility_level) {\n  case 0x1f:\n    DAT_00248d64 = 1;\n    break;\n  case 0x20:\n    DAT_00248d60 = 1;\n    return;\n  case 0x28:\n    DAT_00248d5c = 1;\n    return;\n  case 0x29:\n    DAT_00248d58 = 1;\n    return;\n  case 0x2a:\n    DAT_00248d54 = 1;\n    return;\n  case 0x2b:\n    DAT_00248d50 = 1;\n    return;\n  case 0x2c:\n    DAT_00248d4c = 1;\n    return;\n  }\n  return;\n}\n\n",
  "input_avail": "\nundefined8 input_avail(int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (-1 < param_1) {\n    uVar1 = FUN_001cbc80();\n    return uVar1;\n  }\n  return 0xffffffff;\n}\n\n",
  "rl_get_keymap_by_name": "\nchar * rl_get_keymap_by_name(char *param_1)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  char **ppcVar3;\n  int iVar4;\n  char *__s2;\n  \n  puVar1 = PTR_PTR_s_emacs_00240468;\n  __s2 = *(char **)PTR_PTR_s_emacs_00240468;\n  if (__s2 != (char *)0x0) {\n    iVar4 = 0;\n    ppcVar3 = (char **)PTR_PTR_s_emacs_00240468;\n    do {\n      ppcVar3 = ppcVar3 + 2;\n      iVar2 = strcasecmp(param_1,__s2);\n      if (iVar2 == 0) {\n        return *(char **)(puVar1 + (long)iVar4 * 0x10 + 8);\n      }\n      __s2 = *ppcVar3;\n      iVar4 = iVar4 + 1;\n    } while (__s2 != (char *)0x0);\n  }\n  return __s2;\n}\n\n",
  "ttnocanon": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint ttnocanon(void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  termios local_58;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00249ee0 == 0) {\n    iVar1 = -1;\n  }\n  else {\n    local_58._48_8_ = DAT_00249f70;\n    local_58.c_iflag = _DAT_00249f40;\n    local_58.c_oflag = tRam0000000000249f44;\n    local_58.c_cflag = tRam0000000000249f48;\n    local_58._16_4_ = _DAT_00249f50;\n    local_58.c_cc._3_4_ = uRam0000000000249f54;\n    local_58.c_cc._7_4_ = uRam0000000000249f58;\n    local_58.c_cc._11_4_ = uRam0000000000249f5c;\n    local_58.c_lflag = uRam0000000000249f4c & 0xfffffffd;\n    local_58.c_ospeed = DAT_00249f78;\n    local_58.c_cc._15_4_ = _DAT_00249f60;\n    local_58.c_cc._19_4_ = uRam0000000000249f64;\n    local_58.c_cc._23_4_ = uRam0000000000249f68;\n    local_58.c_cc._27_4_ = uRam0000000000249f6c;\n    iVar1 = tcsetattr(0,1,&local_58);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_named_function": "\nchar * rl_named_function(char *param_1)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  undefined8 *puVar3;\n  \n  rl_initialize_funmap();\n  ppcVar1 = (char **)*funmap;\n  puVar3 = funmap;\n  while( true ) {\n    if (ppcVar1 == (char **)0x0) {\n      return (char *)0x0;\n    }\n    puVar3 = puVar3 + 1;\n    iVar2 = strcasecmp(*ppcVar1,param_1);\n    if (iVar2 == 0) break;\n    ppcVar1 = (char **)*puVar3;\n  }\n  return ppcVar1[1];\n}\n\n",
  "FUN_001af600": "\nvoid FUN_001af600(void)\n\n{\n  if (read_timeout != 0) {\n    *(undefined4 *)(read_timeout + 0x18) = 1;\n  }\n  return;\n}\n\n",
  "FUN_0015a140": "\nvoid FUN_0015a140(char **param_1,byte param_2)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  long lVar3;\n  undefined8 uVar4;\n  long lVar5;\n  \n  lVar3 = shell_variables;\n  uVar2 = *(uint *)(param_1 + 5);\n  if ((((uVar2 & 0x20) != 0) && (**param_1 == '-')) && ((*param_1)[1] == '\\0')) {\n    set_current_options(param_1[1]);\n    set_shellopts();\n    goto LAB_0015a239;\n  }\n  if (((uVar2 & 0x100000) == 0) || ((posixly_correct != 0 & param_2) == 0)) {\n    if ((uVar2 & 0x300000) != 0x300000) {\n      stupidly_hack_special_variables(*param_1);\n      goto LAB_0015a239;\n    }\n    lVar5 = *(long *)(shell_variables + 0x20);\n    if ((((*(uint *)(shell_variables + 0xc) & 4) != 0) ||\n        ((*(uint *)(shell_variables + 0xc) & 0x1c) == 0x10)) && (lVar5 == 0)) {\n      uVar4 = hash_create(0x400);\n      *(undefined8 *)(lVar3 + 0x20) = uVar4;\n      lVar5 = *(long *)(shell_variables + 0x20);\n    }\n    lVar3 = FUN_00154e30(*param_1,param_1[1],lVar5,0,0);\n    lVar5 = shell_variables;\n    if (lVar3 != 0) {\n      *(undefined4 *)(lVar3 + 0x2c) = *(undefined4 *)(shell_variables + 8);\n    }\n    if (global_variables == lVar5) {\n      *(uint *)(param_1 + 5) = *(uint *)(param_1 + 5) & 0xffcfffff;\n    }\n    else {\n      puVar1 = (uint *)(lVar5 + 0xc);\n      *puVar1 = *puVar1 | 2;\n    }\n    if (lVar3 == 0) goto LAB_0015a239;\n    *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | *(uint *)(param_1 + 5);\n  }\n  else {\n    lVar3 = bind_variable(*param_1,param_1[1],0x220);\n    if (lVar3 == 0) goto LAB_0015a239;\n    uVar2 = *(uint *)(lVar3 + 0x28) | *(uint *)(param_1 + 5);\n    *(uint *)(lVar3 + 0x28) = uVar2;\n    if (*(int *)(lVar3 + 0x2c) == 0) {\n      *(uint *)(lVar3 + 0x28) = uVar2 & 0xffcfffff;\n    }\n  }\n  uVar2 = *(uint *)(param_1 + 5);\n  if ((uVar2 & 0x44) != 0) {\n    if (*(long *)(lVar3 + 8) != 0) {\n      sh_xfree(*(long *)(lVar3 + 8),\"variables.c\",0x14ff);\n      uVar2 = *(uint *)(param_1 + 5);\n    }\n    if ((uVar2 & 4) == 0) {\n      uVar4 = hash_copy(param_1[1],0);\n      *(undefined8 *)(lVar3 + 8) = uVar4;\n    }\n    else {\n      uVar4 = array_copy();\n      *(undefined8 *)(lVar3 + 8) = uVar4;\n    }\n  }\nLAB_0015a239:\n  dispose_variable(param_1);\n  return;\n}\n\n",
  "cond_expand_word": "\nundefined8 cond_expand_word(char **param_1,int param_2)\n\n{\n  long *plVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 *puVar6;\n  undefined8 *puVar7;\n  \n  if ((*param_1 == (char *)0x0) || (**param_1 == '\\0')) {\n    return 0;\n  }\n  *(uint *)(param_1 + 1) = *(uint *)(param_1 + 1) | 0x40;\n  DAT_00247848 = 1;\n  puVar3 = (undefined8 *)FUN_00177e80(param_1,(ulong)(param_2 == 3) << 8,0,0,0);\n  if (puVar3 == (undefined8 *)&DAT_00247880) {\n    *param_1 = (char *)0x0;\n    uVar4 = 2;\nLAB_0017b667:\n    last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n    FUN_001667f0(uVar4);\n  }\n  if (puVar3 == (undefined8 *)&DAT_00247870) {\n    *param_1 = (char *)0x0;\n    uVar4 = 1;\n    goto LAB_0017b667;\n  }\n  DAT_00247848 = 0;\n  if (puVar3 == (undefined8 *)0x0) {\n    DAT_00247848 = 0;\n    return 0;\n  }\n  puVar6 = (undefined8 *)puVar3[1];\n  if (param_2 == 0) {\n    puVar7 = puVar3;\n    if (puVar6 != (undefined8 *)0x0) {\n      while( true ) {\n        remove_quoted_nulls(*puVar6);\n        puVar2 = (undefined8 *)*puVar7;\n        *(uint *)(puVar7[1] + 8) = *(uint *)(puVar7[1] + 8) & 0xfffbffff;\n        if (puVar2 == (undefined8 *)0x0) break;\n        puVar6 = (undefined8 *)puVar2[1];\n        puVar7 = puVar2;\n      }\n    }\n  }\n  else {\n    if (param_2 != 3) {\n      puVar6 = puVar3;\n      do {\n        remove_quoted_nulls(*(undefined8 *)puVar6[1]);\n        plVar1 = puVar6 + 1;\n        puVar6 = (undefined8 *)*puVar6;\n        *(uint *)(*plVar1 + 8) = *(uint *)(*plVar1 + 8) & 0xfffbffff;\n      } while (puVar6 != (undefined8 *)0x0);\n      uVar4 = string_list_internal(puVar3,&DAT_001fdb1c);\n      uVar5 = quote_string_for_globbing(uVar4,(param_2 == 2) * '\\x04' + '\\t');\n      sh_xfree(uVar4,\"subst.c\",0x1034);\n      goto LAB_0017b59b;\n    }\n    puVar7 = puVar3;\n    if (puVar6 != (undefined8 *)0x0) {\n      while( true ) {\n        remove_quoted_nulls(*puVar6);\n        puVar2 = (undefined8 *)*puVar7;\n        *(uint *)(puVar7[1] + 8) = *(uint *)(puVar7[1] + 8) & 0xfffbffff;\n        if (puVar2 == (undefined8 *)0x0) break;\n        puVar6 = (undefined8 *)puVar2[1];\n        puVar7 = puVar2;\n      }\n    }\n  }\n  dequote_list(puVar3);\n  uVar5 = string_list_internal(puVar3,&DAT_001fdb1c);\nLAB_0017b59b:\n  dispose_words(puVar3);\n  return uVar5;\n}\n\n",
  "FUN_00194f30": "\nvoid FUN_00194f30(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  uVar3 = rl_completion_entry_function;\n  uVar2 = rl_attempted_completion_function;\n  uVar1 = rl_ignore_some_completions_function;\n  rl_completion_entry_function = FUN_00192f60;\n  rl_attempted_completion_function = 0;\n  rl_complete_internal(0x3f);\n  rl_completion_entry_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar2;\n  rl_ignore_some_completions_function = uVar1;\n  return;\n}\n\n",
  "quote_string_for_globbing": "\nvoid quote_string_for_globbing(char *param_1,uint param_2)\n\n{\n  byte bVar1;\n  char cVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  size_t sVar6;\n  char *pcVar7;\n  long lVar8;\n  char *pcVar9;\n  int iVar10;\n  char cVar11;\n  uint uVar12;\n  ulong uVar13;\n  uint uVar14;\n  char *pcVar15;\n  byte *pbVar16;\n  uint uVar17;\n  ulong uVar18;\n  ulong uVar19;\n  int iVar20;\n  int iVar21;\n  int iVar22;\n  ulong uVar23;\n  ulong uVar24;\n  \n  sVar6 = strlen(param_1);\n  pcVar7 = (char *)sh_xmalloc(sVar6 * 2 + 1,\"pathexp.c\",0xd7);\n  cVar11 = *param_1;\n  if (((param_2 & 1) == 0) || (cVar11 != '\\x7f')) {\n    pcVar9 = pcVar7;\n    if (cVar11 == '\\0') goto LAB_00184ad4;\n  }\n  else if (param_1[1] == '\\0') {\n    *pcVar7 = '\\0';\n    return;\n  }\n  bVar3 = false;\n  bVar5 = false;\n  bVar4 = false;\n  uVar19 = 0;\n  uVar23 = 0;\n  uVar18 = 0;\n  uVar13 = 0;\n  do {\n    while( true ) {\n      pcVar9 = pcVar7 + uVar18;\n      iVar22 = (int)uVar19;\n      iVar20 = (int)uVar23;\n      if (cVar11 == '\\x01') break;\n      uVar17 = iVar20 + 1;\n      iVar10 = iVar22 + 1;\n      uVar24 = (ulong)(int)uVar17;\n      pcVar15 = param_1 + uVar24;\n      if ((param_2 & 4) == 0) {\n        if (cVar11 != '\\\\') goto LAB_00184a0e;\n        *pcVar9 = '\\\\';\n        cVar11 = *pcVar15;\n        if (cVar11 == '\\0') {\nLAB_00184e5c:\n          lVar8 = (long)iVar10;\nLAB_00184e5f:\n          pcVar9 = pcVar7 + lVar8;\n          goto LAB_00184ad4;\n        }\n        uVar17 = iVar20 + 2;\n        if (((param_2 & 8) == 0) || (cVar11 != '\\x01')) goto LAB_00184a18;\n        pbVar16 = (byte *)(param_1 + uVar24 + 1);\n        bVar1 = *pbVar16;\n        uVar13 = (ulong)bVar1;\n        if ((bVar1 != 1) && (bVar1 != 0x7f)) {\n          uVar23 = (ulong)uVar17;\n          uVar19 = (ulong)iVar10;\n          uVar18 = uVar19;\n          if ((param_2 & 2) != 0) goto LAB_00184a74;\n          goto LAB_00184b58;\n        }\n        uVar17 = iVar20 + 2;\nLAB_00184b69:\n        lVar8 = (long)(int)uVar17;\n        uVar17 = uVar17 + 1;\n        cVar11 = param_1[lVar8];\nLAB_00184a18:\n        uVar19 = (ulong)(iVar10 + 1U);\n        uVar23 = (ulong)(int)uVar17;\n        pcVar7[iVar10] = cVar11;\n        pcVar15 = param_1 + uVar23;\n        uVar18 = (long)(int)(iVar10 + 1U);\n        uVar24 = uVar23;\n      }\n      else {\n        if (((iVar20 != 0) && (param_1[uVar13 - 1] == '\\x01')) || (cVar11 != '[')) {\nLAB_00184a0e:\n          cVar11 = param_1[iVar20];\n          iVar10 = iVar22;\n          goto LAB_00184a18;\n        }\n        *pcVar9 = '[';\n        cVar11 = *pcVar15;\n        uVar12 = iVar20 + 2;\n        iVar21 = iVar10;\n        if (cVar11 == '^') {\n          pcVar7[iVar10] = '^';\n          cVar11 = param_1[(int)uVar12];\n          uVar12 = iVar20 + 3;\n          iVar21 = iVar22 + 2;\n        }\n        if (cVar11 == ']') {\n          lVar8 = (long)iVar21;\n          iVar21 = iVar21 + 1;\n          pcVar7[lVar8] = ']';\n          lVar8 = (long)(int)uVar12;\n          uVar12 = uVar12 + 1;\n          cVar11 = param_1[lVar8];\n        }\n        do {\n          lVar8 = (long)iVar21;\n          if (cVar11 == '\\0') goto LAB_00184e5f;\n          if (cVar11 == '\\x01') {\n            pcVar9 = pcVar7 + lVar8;\n            if (param_1[(int)uVar12] == '\\0') goto LAB_00184ad4;\n            iVar22 = uVar12 + 1;\n            *pcVar9 = param_1[(int)uVar12];\n            iVar21 = iVar21 + 1;\n            uVar12 = uVar12 + 2;\n            cVar11 = param_1[iVar22];\n          }\n          else {\n            iVar22 = iVar21 + 1;\n            uVar14 = uVar12 + 1;\n            pcVar9 = param_1 + (int)uVar12;\n            if (cVar11 == '[') {\n              cVar2 = *pcVar9;\n              if (cVar2 == ':') {\n                pcVar7[lVar8] = '[';\n                lVar8 = (long)iVar22;\n                iVar22 = iVar21 + 2;\n                bVar5 = true;\n                pcVar7[lVar8] = *pcVar9;\n                cVar11 = param_1[(int)uVar14];\n              }\n              else if (cVar2 == '=') {\n                pcVar7[lVar8] = '[';\n                lVar8 = (long)iVar22;\n                iVar22 = iVar21 + 2;\n                pcVar7[lVar8] = *pcVar9;\n                cVar11 = param_1[(int)uVar14];\n                if (cVar11 == ']') {\n                  uVar14 = uVar12 + 2;\n                  lVar8 = (long)iVar22;\n                  iVar22 = iVar21 + 3;\n                  bVar3 = true;\n                  pcVar7[lVar8] = ']';\n                  cVar11 = param_1[(int)uVar14];\n                }\n                else {\n                  bVar3 = true;\n                }\n              }\n              else {\n                if (cVar2 != '.') goto LAB_00184c3f;\n                pcVar7[lVar8] = '[';\n                lVar8 = (long)iVar22;\n                iVar22 = iVar21 + 2;\n                pcVar7[lVar8] = *pcVar9;\n                cVar11 = param_1[(int)uVar14];\n                if (cVar11 == ']') {\n                  uVar14 = uVar12 + 2;\n                  lVar8 = (long)iVar22;\n                  bVar4 = true;\n                  iVar22 = iVar21 + 3;\n                  pcVar7[lVar8] = ']';\n                  cVar11 = param_1[(int)uVar14];\n                }\n                else {\n                  bVar4 = true;\n                }\n              }\n            }\n            else if ((cVar11 == ':') && (bVar5)) {\n              if (*pcVar9 != ']') goto LAB_00184c3f;\n              pcVar7[lVar8] = ':';\n              lVar8 = (long)iVar22;\n              iVar22 = iVar21 + 2;\n              bVar5 = false;\n              pcVar7[lVar8] = *pcVar9;\n              cVar11 = param_1[(int)uVar14];\n            }\n            else if ((cVar11 == '=') && (bVar3)) {\n              if (*pcVar9 == ']') {\n                pcVar7[lVar8] = '=';\n                lVar8 = (long)iVar22;\n                iVar22 = iVar21 + 2;\n                bVar3 = false;\n                pcVar7[lVar8] = *pcVar9;\n                cVar11 = param_1[(int)uVar14];\n              }\n              else {\nLAB_00184c3f:\n                pcVar7[lVar8] = cVar11;\n                cVar11 = *pcVar9;\n                uVar14 = uVar12;\n              }\n            }\n            else {\n              if (((cVar11 != '.') || (!bVar4)) || (*pcVar9 != ']')) goto LAB_00184c3f;\n              pcVar7[lVar8] = '.';\n              lVar8 = (long)iVar22;\n              iVar22 = iVar21 + 2;\n              bVar4 = false;\n              pcVar7[lVar8] = *pcVar9;\n              cVar11 = param_1[(int)uVar14];\n            }\n            uVar12 = uVar14 + 1;\n            iVar21 = iVar22;\n          }\n          if (cVar11 == ']') {\n            uVar19 = (ulong)(iVar21 + 1U);\n            pcVar7[iVar21] = ']';\n            uVar24 = (ulong)(int)uVar12;\n            uVar23 = (ulong)uVar12;\n            pcVar15 = param_1 + uVar24;\n            uVar18 = (long)(int)(iVar21 + 1U);\n            goto LAB_00184a2f;\n          }\n        } while (cVar11 != '\\0');\n        uVar23 = (ulong)uVar17;\n        uVar19 = (ulong)iVar10;\n        uVar18 = uVar19;\n      }\nLAB_00184a2f:\n      cVar11 = *pcVar15;\n      uVar13 = uVar24;\n      if (cVar11 == '\\0') goto LAB_00184ad0;\n    }\n    cVar11 = param_1[uVar13 + 1];\n    if (cVar11 == '\\0') {\n      *pcVar9 = '\\x01';\n      pcVar9 = pcVar7 + (iVar22 + 1);\n      goto LAB_00184ad4;\n    }\n    if (((param_2 & 0xc) != 0) && ((cVar11 == '\\x01' || (cVar11 == '\\x7f')))) {\n      uVar23 = (ulong)(iVar20 + 2U);\n      uVar19 = (ulong)(iVar22 + 1U);\n      *pcVar9 = cVar11;\n      uVar24 = (ulong)(int)(iVar20 + 2U);\n      pcVar15 = param_1 + uVar24;\n      uVar18 = (long)(int)(iVar22 + 1U);\n      goto LAB_00184a2f;\n    }\n    uVar23 = (ulong)(iVar20 + 1);\n    pbVar16 = (byte *)(param_1 + (long)iVar20 + 1);\n    uVar13 = (ulong)*pbVar16;\n    if ((param_2 & 2) != 0) {\nLAB_00184a74:\n      if ((char)uVar13 != '/') goto LAB_00184a7a;\n      goto LAB_00184ab4;\n    }\nLAB_00184a7a:\n    uVar17 = (uint)uVar23;\n    iVar10 = (int)uVar19;\n    cVar11 = (char)uVar13;\n    if ((cVar11 == '\\x01') || ((param_2 & 4) == 0)) {\nLAB_00184b58:\n      pcVar7[uVar18] = '\\\\';\n      iVar10 = iVar10 + 1;\n      if (*pbVar16 == 0) goto LAB_00184e5c;\n      goto LAB_00184b69;\n    }\n    if (cVar11 < '/') {\n      if ((cVar11 < '$') || ((0x4f1000000000U >> (uVar13 & 0x3f) & 1) == 0)) goto LAB_00184ab4;\n      goto LAB_00184b58;\n    }\n    uVar12 = (int)uVar13 - 0x3f;\n    if (((byte)uVar12 < 0x3e) && ((0x30000000b0000001U >> ((ulong)uVar12 & 0x3f) & 1) != 0))\n    goto LAB_00184b58;\nLAB_00184ab4:\n    cVar11 = param_1[(int)uVar23];\n    uVar13 = (long)(int)uVar23;\n  } while (cVar11 != '\\0');\nLAB_00184ad0:\n  pcVar9 = pcVar7 + uVar18;\nLAB_00184ad4:\n  *pcVar9 = '\\0';\n  return;\n}\n\n",
  "FUN_0017c6a0": "\nchar * FUN_0017c6a0(undefined8 param_1,int param_2,uint param_3,uint param_4)\n\n{\n  undefined4 uVar1;\n  long *plVar2;\n  char *pcVar3;\n  long lVar4;\n  size_t sVar5;\n  char *__dest;\n  \n  uVar1 = DAT_00247848;\n  if (param_2 == 0) {\n    if (((((param_4 & 1) != 0) && (lVar4 = find_variable_last_nameref(param_1,0), lVar4 != 0)) &&\n        ((*(byte *)(lVar4 + 0x29) & 8) != 0)) &&\n       ((pcVar3 = *(char **)(lVar4 + 8), pcVar3 != (char *)0x0 && (*pcVar3 != '\\0')))) {\n      sVar5 = strlen(pcVar3);\n      __dest = (char *)sh_xmalloc(sVar5 + 1,\"subst.c\",0x1d99);\n      pcVar3 = strcpy(__dest,pcVar3);\n      return pcVar3;\n    }\n    plVar2 = (long *)FUN_0017bfe0(param_1,0,param_3,2,0);\n    lVar4 = *plVar2;\n    if (lVar4 == 0) {\nLAB_0017c7f0:\n      pcVar3 = (char *)0x0;\n      goto LAB_0017c711;\n    }\n    if ((param_3 & 3) != 0) goto LAB_0017c7d6;\n    pcVar3 = (char *)dequote_escapes(lVar4);\n  }\n  else {\n    DAT_00247848 = 1;\n    plVar2 = (long *)FUN_0017bfe0(param_1,1,param_3,10,0);\n    lVar4 = *plVar2;\n    DAT_00247848 = uVar1;\n    if (lVar4 == 0) goto LAB_0017c7f0;\nLAB_0017c7d6:\n    pcVar3 = (char *)dequote_string(lVar4);\n  }\n  sh_xfree(lVar4,\"subst.c\",0x1db1);\nLAB_0017c711:\n  dispose_word_desc(plVar2);\n  return pcVar3;\n}\n\n",
  "wait_for_single_pid": "\nint wait_for_single_pid(uint param_1,uint param_2)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long *plVar3;\n  int iVar4;\n  long lVar5;\n  int *piVar6;\n  long *plVar7;\n  long in_FS_OFFSET;\n  sigset_t sStack_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_148);\n  sigaddset(&sStack_148,0x11);\n  sigemptyset(&local_c8);\n  sigprocmask(0,&sStack_148,&local_c8);\n  lVar5 = FUN_00160ba0(param_1,0,0);\n  sigprocmask(2,&local_c8,(sigset_t *)0x0);\n  if (lVar5 == 0) {\n    if (((bgpids != 0) && (DAT_0024253c != 0)) && (DAT_00242540 != 0)) {\n      iVar4 = *(int *)(pidstat_table + (ulong)(param_1 & 0xfff) * 4);\n      do {\n        if (iVar4 == -1) goto LAB_0016402d;\n        piVar6 = (int *)((long)iVar4 * 0x10 + bgpids);\n        if (param_1 == piVar6[2]) {\n          iVar4 = (int)*(short *)(piVar6 + 3);\n          if (iVar4 < 0) goto LAB_0016402d;\n          goto LAB_00163f40;\n        }\n        iVar4 = *piVar6;\n      } while (*(int *)(pidstat_table + (ulong)(param_1 & 0xfff) * 4) != iVar4);\n      internal_warning(\"bgp_search: LOOP: psi (%d) == storage[psi].bucket_next\");\n    }\nLAB_0016402d:\n    if ((param_2 & 1) == 0) {\n      iVar4 = 0x101;\n    }\n    else {\n      iVar4 = 0x101;\n      internal_error(\"wait: pid %ld is not a child of this shell\",(long)(int)param_1);\n    }\n  }\n  else {\n    while (iVar4 = wait_for(param_1,0), (param_2 & 2) != 0) {\n      sigemptyset(&sStack_148);\n      sigaddset(&sStack_148,0x11);\n      sigemptyset(&local_c8);\n      sigprocmask(0,&sStack_148,&local_c8);\n      if ((*(int *)(lVar5 + 0x10) != 1) && (*(char *)(lVar5 + 0xc) != '\\x7f')) {\n        sigprocmask(2,&local_c8,(sigset_t *)0x0);\n        break;\n      }\n      sigprocmask(2,&local_c8,(sigset_t *)0x0);\n    }\n    sigemptyset(&sStack_148);\n    sigaddset(&sStack_148,0x11);\n    sigemptyset(&local_c8);\n    sigprocmask(0,&sStack_148,&local_c8);\n    if (0 < DAT_0023877c) {\n      plVar7 = jobs;\n      do {\n        lVar5 = *plVar7;\n        if (lVar5 != 0) {\n          plVar2 = *(long **)(lVar5 + 8);\n          uVar1 = *(uint *)(plVar2 + 1);\n          plVar3 = plVar2;\n          while( true ) {\n            if (param_1 == uVar1) {\n              if (*(int *)(lVar5 + 0x14) == 4) {\n                *(uint *)(lVar5 + 0x18) = *(uint *)(lVar5 + 0x18) | 2;\n              }\n              goto LAB_00163ef0;\n            }\n            plVar3 = (long *)*plVar3;\n            if (plVar2 == plVar3) break;\n            uVar1 = *(uint *)(plVar3 + 1);\n          }\n        }\n        plVar7 = plVar7 + 1;\n      } while (plVar7 != jobs + (ulong)(DAT_0023877c - 1) + 1);\n    }\nLAB_00163ef0:\n    sigprocmask(2,&local_c8,(sigset_t *)0x0);\n    if (posixly_correct != 0) {\n      if ((DAT_0023877c != 0) && (DAT_00247660 == 0)) {\n        FUN_001626a0();\n      }\n      FUN_0015ec90(param_1);\n    }\n    if ((((wait_intr_flag != 0) && (wait_signal_received != 0)) &&\n        (this_shell_builtin == PTR_wait_builtin_00237f70)) &&\n       (this_shell_builtin != (undefined *)0x0)) {\n                    /* WARNING: Subroutine does not return */\n      __longjmp_chk(wait_intr_buf,1);\n    }\n  }\nLAB_00163f40:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "seedrand": "\nvoid seedrand(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  long in_FS_OFFSET;\n  uint local_38;\n  uint local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  gettimeofday((timeval *)&local_38,(__timezone_ptr_t)0x0);\n  uVar1 = getpid();\n  uVar2 = getppid();\n  last_random_value = 0;\n  DAT_0023b318 = local_30 ^ local_38 ^ current_user ^ 0x1cce30 ^ uVar1 ^ uVar2;\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "write": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = (*(code *)PTR_write_00237940)();\n  return sVar1;\n}\n\n",
  "__cxa_finalize": "\nvoid __cxa_finalize(void)\n\n{\n  (*(code *)PTR___cxa_finalize_00237ff0)();\n  return;\n}\n\n",
  "array_reference": "\nlong array_reference(long *param_1,long param_2)\n\n{\n  long *plVar1;\n  long lVar2;\n  int iVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  if (((param_1 == (long *)0x0) || (param_1[1] == 0)) || (*param_1 < param_2)) {\n    return 0;\n  }\n  plVar1 = (long *)((long *)param_1[2])[2];\n  if (param_2 < *plVar1) {\n    return 0;\n  }\n  plVar5 = (long *)param_1[3];\n  if (plVar5 == (long *)0x0) {\n    iVar3 = 1;\n    lVar2 = *plVar1 / 2;\n    plVar5 = plVar1;\n  }\n  else {\n    lVar2 = *plVar5;\n    iVar3 = 1;\n    plVar4 = plVar1;\n    if (param_2 < lVar2 / 2) goto joined_r0x001892bf;\n    iVar3 = -1;\n  }\n  plVar1 = plVar5;\n  plVar4 = plVar5;\n  if (lVar2 <= param_2) {\n    iVar3 = 1;\n  }\njoined_r0x001892bf:\n  do {\n    while( true ) {\n      plVar5 = plVar4;\n      if ((long *)param_1[2] == plVar1) goto LAB_001892f9;\n      if (*plVar1 == param_2) {\n        param_1[3] = (long)plVar1;\n        return plVar1[1];\n      }\n      if (iVar3 != 1) break;\n      plVar5 = (long *)plVar1[2];\n      plVar1 = plVar5;\n      if (*plVar5 != param_2 && param_2 <= *plVar5) goto LAB_001892f9;\n    }\n    plVar5 = (long *)plVar1[3];\n    plVar1 = plVar5;\n  } while ((iVar3 != -1) || (param_2 <= *plVar5));\nLAB_001892f9:\n  param_1[3] = (long)plVar5;\n  return 0;\n}\n\n",
  "FUN_00193440": "\nundefined8 FUN_00193440(void)\n\n{\n  rl_crlf();\n  show_shell_version(0);\n  putc(0xd,rl_outstream);\n  fflush(rl_outstream);\n  rl_on_new_line();\n  rl_redisplay();\n  return 0;\n}\n\n",
  "FUN_00195620": "\nvoid FUN_00195620(int param_1,int param_2,int param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  byte *pbVar3;\n  long lVar4;\n  char *pcVar5;\n  undefined8 *puVar6;\n  int iVar7;\n  byte bVar8;\n  \n  bVar8 = 0;\n  if ((rl_filename_quote_characters != (byte *)0x0) && (*rl_filename_quote_characters != '\\0')) {\n    pbVar3 = (byte *)sh_xrealloc(DAT_00248980,0x1a,\"bashline.c\",0x1086);\n    pcVar5 = \"\\t\\n\\\\\\\"\\'@<>=;|&()#$`?*[!:{~\";\n    iVar2 = 0x20;\n    iVar7 = 0;\n    DAT_00248980 = pbVar3;\n    do {\n      if ((param_1 != iVar2 && param_2 != iVar2) && (param_3 != iVar2)) {\n        lVar4 = (long)iVar7;\n        iVar7 = iVar7 + 1;\n        pbVar3[lVar4] = (byte)iVar2;\n      }\n      cVar1 = *pcVar5;\n      iVar2 = (int)cVar1;\n      pcVar5 = pcVar5 + 1;\n    } while (cVar1 != '\\0');\n    pbVar3[iVar7] = 0;\n    puVar6 = &DAT_00248880;\n    for (lVar4 = 0x20; lVar4 != 0; lVar4 = lVar4 + -1) {\n      *puVar6 = 0;\n      puVar6 = puVar6 + (ulong)bVar8 * -2 + 1;\n    }\n    rl_filename_quote_characters = pbVar3;\n    if (pbVar3 != (byte *)0x0) {\n      for (; *pbVar3 != 0; pbVar3 = pbVar3 + 1) {\n        *(undefined *)((long)&DAT_00248880 + (ulong)*pbVar3) = 1;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
  "with_input_from_string": "\nvoid with_input_from_string(undefined8 param_1,undefined8 param_2)\n\n{\n  init_yy_io(FUN_00134b10,FUN_00134b40,3,param_2,param_1);\n  return;\n}\n\n",
  "print_var_list": "\nvoid print_var_list(long *param_1)\n\n{\n  if (param_1 == (long *)0x0) {\n    return;\n  }\n  for (; *param_1 != 0; param_1 = param_1 + 1) {\n    if ((*(byte *)(*param_1 + 0x29) & 0x10) == 0) {\n      print_assignment();\n    }\n  }\n  return;\n}\n\n",
  "no_args": "\nundefined8 no_args(long param_1)\n\n{\n  int iVar1;\n  undefined8 in_RAX;\n  undefined8 uVar2;\n  \n  if (param_1 == 0) {\n    return in_RAX;\n  }\n  FUN_001a3b30();\n  reset_internal_getopt();\n  iVar1 = internal_getopt(param_1,&DAT_00213d70);\n  uVar2 = 0;\n  if (iVar1 != -1) {\n    if (iVar1 == -99) {\n      builtin_help();\n      return 2;\n    }\n    builtin_usage();\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
  "find_function": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong find_function(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  \n  uVar1 = shell_functions;\n  lVar2 = hash_search(param_1,shell_functions,0);\n  if (lVar2 != 0) {\n    _DAT_002422f8 = uVar1;\n    lVar2 = *(long *)(lVar2 + 0x10);\n  }\n  return lVar2;\n}\n\n",
  "maybe_set_sigchld_trap": "\nvoid maybe_set_sigchld_trap(undefined8 param_1)\n\n{\n  if ((((byte)DAT_00247e84 & 1) == 0) && (DAT_00247a88 == initialize_traps)) {\n    set_signal(0x11,param_1);\n    return;\n  }\n  return;\n}\n\n",
  "get_dirstack_from_string": "\nundefined8 get_dirstack_from_string(char *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  int iVar4;\n  long in_FS_OFFSET;\n  int local_1c;\n  undefined8 local_18;\n  long local_10;\n  \n  iVar4 = 1;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar1 = *param_1;\n  if ((cVar1 - 0x2bU & 0xfd) == 0) {\n    param_1 = param_1 + 1;\n    iVar4 = ((cVar1 != '-') - 1) + (uint)(cVar1 != '-');\n  }\n  iVar2 = legal_number(param_1,&local_18);\n  if (iVar2 == 0) {\nLAB_001af3e8:\n    uVar3 = 0;\n  }\n  else {\n    local_1c = 0;\n    iVar4 = FUN_001ae530(local_18,iVar4,&local_1c);\n    if (local_1c != 0) {\n      if ((iVar4 < 0) || (DAT_00248b48 < iVar4)) goto LAB_001af3e8;\n      if ((local_1c != 1) || (iVar4 != 0)) {\n        uVar3 = *(undefined8 *)(DAT_00248b50 + (long)iVar4 * 8);\n        goto LAB_001af3cc;\n      }\n    }\n    uVar3 = get_string_value(&DAT_001fc3d5);\n  }\nLAB_001af3cc:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001e08f0": "\nint FUN_001e08f0(void *param_1,int param_2,int param_3,int param_4)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  uint uVar4;\n  size_t sVar5;\n  int iVar6;\n  int iVar7;\n  long in_FS_OFFSET;\n  wchar_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  iVar3 = DAT_0024a894;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  iVar7 = param_3;\n  if ((param_4 == 0) || (param_2 != 0)) {\n    iVar6 = 0;\n    if (0 < param_2) {\n      do {\n        if ((_rl_utf8locale == 0) || (*(char *)((long)iVar6 + (long)param_1) < '\\0')) {\n          sVar5 = mbrtowc((wchar_t *)0x0,(char *)((long)iVar6 + (long)param_1),(long)iVar7,&local_48\n                         );\n          uVar4 = (uint)sVar5;\n          if (uVar4 < 0xfffffffe) {\n            if (uVar4 != 0) goto LAB_001e0a4c;\n            break;\n          }\n          local_48.__count = 0;\n          local_48.__value = (_union_27)0x0;\n          iVar6 = iVar6 + 1;\n          iVar7 = iVar7 + -1;\n        }\n        else {\n          local_48.__count = 0;\n          local_48.__value = (_union_27)0x0;\n          uVar4 = 1;\nLAB_001e0a4c:\n          iVar6 = iVar6 + uVar4;\n          iVar7 = iVar7 - uVar4;\n        }\n      } while (iVar6 < param_2);\n    }\n  }\n  else if (DAT_0024a894 == param_3) {\n    iVar6 = 0;\n    iVar2 = memcmp(param_1,DAT_0024a8a0,(long)DAT_0024a894);\n    iVar7 = iVar3;\n    if (iVar2 == 0) {\n      param_2 = DAT_0024a884 + DAT_0024a870;\nLAB_001e0b07:\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return param_2;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n  }\n  else if (((DAT_0024a894 < 1) || (param_3 <= DAT_0024a894)) || (DAT_0024a8a0 == (void *)0x0)) {\n    iVar6 = 0;\n  }\n  else {\n    iVar6 = 0;\n    iVar2 = memcmp(param_1,DAT_0024a8a0,(long)DAT_0024a894);\n    if (iVar2 == 0) {\n      param_2 = DAT_0024a884 + DAT_0024a870;\n      sVar5 = __ctype_get_mb_cur_max();\n      if ((sVar5 == 1) || (rl_byte_oriented != 0)) {\n        param_3 = param_3 - iVar3;\n      }\n      else {\n        param_3 = FUN_001e08f0(param_1,iVar3,param_3,param_4);\n      }\n      param_2 = param_2 + param_3;\n      goto LAB_001e0b07;\n    }\n  }\n  param_2 = iVar6 - param_2;\njoined_r0x001e0989:\n  if (iVar6 < param_3) {\n    do {\n      if ((_rl_utf8locale == 0) || (cVar1 = *(char *)((long)iVar6 + (long)param_1), cVar1 < '\\0')) {\n        sVar5 = mbrtowc(&local_4c,(char *)((long)iVar6 + (long)param_1),(long)iVar7,&local_48);\n        uVar4 = (uint)sVar5;\n        if (0xfffffffd < uVar4) goto LAB_001e0ae0;\n        if (uVar4 == 0) break;\n      }\n      else {\n        uVar4 = 1;\n        local_4c = (int)cVar1;\n      }\n      iVar6 = iVar6 + uVar4;\n      iVar7 = iVar7 - uVar4;\n      if (local_4c < L'`') {\n        if (local_4c < L'A') {\n          if (local_4c < L'$') {\n            iVar3 = 1;\n            if (L'\\x1f' < local_4c) goto LAB_001e09b8;\n          }\n          else if ((uint)(local_4c + L'\\xffffffdb') < 0x1b) goto LAB_001e0a0d;\nLAB_001e09aa:\n          iVar3 = wcwidth(local_4c);\n          if (iVar3 < 0) {\n            iVar3 = 1;\n          }\n        }\n        else {\nLAB_001e0a0d:\n          iVar3 = 1;\n        }\n      }\n      else {\n        iVar3 = 1;\n        if (0x1d < (uint)(local_4c + L'\\xffffff9f')) goto LAB_001e09aa;\n      }\nLAB_001e09b8:\n      param_2 = param_2 + iVar3;\n      if (param_3 <= iVar6) break;\n    } while( true );\n  }\n  param_2 = (iVar6 - param_3) + param_2;\n  goto LAB_001e0b07;\nLAB_001e0ae0:\n  iVar6 = iVar6 + 1;\n  iVar7 = iVar7 + -1;\n  param_2 = param_2 + 1;\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  goto joined_r0x001e0989;\n}\n\n",
  "FUN_001af620": "\nvoid FUN_001af620(void)\n\n{\n  long lVar1;\n  undefined *puVar2;\n  \n  lVar1 = rl_get_keymap();\n  *(char *)(lVar1 + 0xd0) = (char)DAT_00248b78;\n  *(undefined8 *)(lVar1 + 0xd8) = DAT_00248b70;\n  puVar2 = (undefined *)(lVar1 + (ulong)DAT_00248b68 * 0x10);\n  *puVar2 = (char)DAT_00248b88;\n  *(undefined8 *)(puVar2 + 8) = DAT_00248b80;\n  return;\n}\n\n",
  "bind_function": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong bind_function(char *param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int iVar3;\n  uint uVar4;\n  long lVar5;\n  size_t sVar6;\n  char *pcVar7;\n  long lVar8;\n  \n  uVar1 = shell_functions;\n  lVar5 = hash_search(param_1,shell_functions,0);\n  uVar2 = shell_functions;\n  if (lVar5 != 0) {\n    _DAT_002422f8 = uVar1;\n    lVar5 = *(long *)(lVar5 + 0x10);\n    if (lVar5 != 0) {\n      if (*(long *)(lVar5 + 0x10) != 0) {\n        sh_xfree(*(long *)(lVar5 + 0x10),\"variables.c\",0xdc4);\n        *(undefined8 *)(lVar5 + 0x10) = 0;\n      }\n      goto LAB_001561d6;\n    }\n  }\n  sVar6 = strlen(param_1);\n  pcVar7 = (char *)sh_xmalloc(sVar6 + 1,\"variables.c\",0xdbf);\n  pcVar7 = strcpy(pcVar7,param_1);\n  lVar8 = hash_insert(pcVar7,uVar2,1);\n  lVar5 = FUN_00151400(param_1);\n  *(long *)(lVar8 + 0x10) = lVar5;\nLAB_001561d6:\n  if (*(long *)(lVar5 + 8) != 0) {\n    dispose_command();\n  }\n  if (param_2 != 0) {\n    param_2 = copy_command(param_2);\n  }\n  iVar3 = mark_modified_vars;\n  *(long *)(lVar5 + 8) = param_2;\n  uVar4 = *(uint *)(lVar5 + 0x28) | 8;\n  if (iVar3 != 0) {\n    uVar4 = *(uint *)(lVar5 + 0x28) | 9;\n  }\n  *(uint *)(lVar5 + 0x28) = uVar4 & 0xffffefff;\n  if ((uVar4 & 1) != 0) {\n    array_needs_making = 1;\n  }\n  set_itemlist_dirty(it_functions);\n  return lVar5;\n}\n\n",
  "wcslen": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t wcslen(wchar_t *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_wcslen_00237a18)();\n  return sVar1;\n}\n\n",
  "pat_subst": "\nchar * pat_subst(byte *param_1,char *param_2,char *param_3,ulong param_4)\n\n{\n  byte *pbVar1;\n  byte *__s;\n  mbstate_t mVar2;\n  uint uVar3;\n  int iVar4;\n  size_t sVar5;\n  byte *pbVar6;\n  ulong uVar7;\n  char *pcVar8;\n  byte bVar9;\n  size_t sVar10;\n  byte *pbVar11;\n  byte *pbVar12;\n  size_t sVar13;\n  int iVar14;\n  long lVar15;\n  long in_FS_OFFSET;\n  bool bVar16;\n  size_t local_b0;\n  char *local_a8;\n  byte *local_58;\n  byte *local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  if (param_1 == (byte *)0x0) {\n    local_a8 = (char *)sh_xmalloc(1,\"subst.c\",0x22d9);\n    *local_a8 = '\\0';\n    goto LAB_00172f30;\n  }\n  uVar3 = (uint)param_4 & 3;\n  if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\n    if (uVar3 - 1 < 2) {\n      pcVar8 = param_3;\n      if ((param_4 & 0x100) != 0) {\n        pcVar8 = (char *)strcreplace(param_3,0x26,&DAT_00213d70,2);\n      }\n      if ((pcVar8 == (char *)0x0) || (*pcVar8 == '\\0')) {\n        if (*param_1 == 0) {\n          local_a8 = (char *)sh_xmalloc(2,\"subst.c\",0x22ee);\n        }\n        else {\n          if (param_1[1] != 0) {\n            sVar5 = 0;\nLAB_001732c0:\n            if (param_1[2] == 0) {\n              sVar10 = 2;\n              sVar13 = sVar5 + 2;\n            }\n            else {\n              sVar10 = strlen((char *)param_1);\n              sVar13 = sVar5 + sVar10;\n            }\n            goto LAB_001732d5;\n          }\n          local_a8 = (char *)sh_xmalloc(3,\"subst.c\",0x22ee);\n        }\nLAB_00173440:\n        strcpy(local_a8,(char *)param_1);\n      }\n      else {\n        if (pcVar8[1] == '\\0') {\n          sVar5 = 1;\nLAB_00173472:\n          if (*param_1 == 0) {\n            sVar10 = 0;\n            local_a8 = (char *)sh_xmalloc(sVar5 + 2,\"subst.c\",0x22ee);\n          }\n          else {\n            if (param_1[1] != 0) goto LAB_001732c0;\n            sVar10 = 1;\n            local_a8 = (char *)sh_xmalloc(sVar5 + 3,\"subst.c\",0x22ee);\n          }\n        }\n        else {\n          if (pcVar8[2] == '\\0') {\n            sVar5 = 2;\n            goto LAB_00173472;\n          }\n          sVar5 = strlen(pcVar8);\n          if (*param_1 == 0) {\n            sVar10 = 0;\n            sVar13 = sVar5;\n          }\n          else {\n            if (param_1[1] != 0) goto LAB_001732c0;\n            sVar10 = 1;\n            sVar13 = sVar5 + 1;\n          }\nLAB_001732d5:\n          local_a8 = (char *)sh_xmalloc(sVar13 + 2,\"subst.c\",0x22ee);\n          if (sVar5 == 0) goto LAB_00173440;\n        }\n        if (uVar3 == 1) {\n          strcpy(local_a8,pcVar8);\n          strcpy(local_a8 + sVar5,(char *)param_1);\n        }\n        else {\n          strcpy(local_a8,(char *)param_1);\n          strcpy(local_a8 + sVar10,pcVar8);\n        }\n      }\n      if (pcVar8 != param_3) {\n        sh_xfree(pcVar8,\"subst.c\",0x22fc);\n      }\n      goto LAB_00172f30;\n    }\n    if (((*param_1 != 0) || (param_2 == (char *)0x0)) || (*param_2 == '\\0')) goto LAB_00172d80;\n  }\n  else if (*param_1 != 0) goto LAB_00172d80;\n  iVar14 = FUN_00168430(param_1,param_2,uVar3,&local_58,&local_50);\n  if (iVar14 == 0) {\nLAB_00172d80:\n    local_a8 = (char *)sh_xmalloc(0x40,\"subst.c\",0x2302);\n    *local_a8 = '\\0';\n    sVar5 = strlen((char *)param_1);\n    local_b0 = 0;\n    if (((param_3 != (char *)0x0) && (*param_3 != '\\0')) &&\n       ((local_b0 = 1, param_3[1] != '\\0' && (local_b0 = 2, param_3[2] != '\\0')))) {\n      local_b0 = strlen(param_3);\n    }\n    pbVar11 = (byte *)0x40;\n    iVar14 = 0;\n    pbVar12 = param_1;\n    do {\n      do {\n        if (*pbVar12 == 0) {\n          lVar15 = (long)iVar14;\nLAB_00173214:\n          local_a8[lVar15] = '\\0';\n          goto LAB_00172f30;\n        }\n        if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\n          lVar15 = (long)iVar14;\nLAB_00172f09:\n          if (pbVar11 <= param_1 + lVar15 + (sVar5 - (long)pbVar12) + 1) {\n            do {\n              pbVar11 = pbVar11 + 0x40;\n            } while (pbVar11 <= param_1 + lVar15 + (sVar5 - (long)pbVar12) + 1);\n            local_a8 = (char *)sh_xrealloc(local_a8,pbVar11,\"subst.c\",0x234f);\n          }\n          strcpy(local_a8 + lVar15,(char *)pbVar12);\n          goto LAB_00172f30;\n        }\n        iVar4 = FUN_00168430(pbVar12,param_2,uVar3,&local_58,&local_50);\n        __s = local_50;\n        pbVar1 = local_58;\n        if (iVar4 == 0) {\nLAB_0017356b:\n          lVar15 = (long)iVar14;\n          if (*pbVar12 == 0) goto LAB_00173214;\n          goto LAB_00172f09;\n        }\n        sVar13 = (long)local_58 - (long)pbVar12;\n        pcVar8 = param_3;\n        sVar10 = local_b0;\n        if ((param_3 != (char *)0x0) && ((param_4 & 0x100) != 0)) {\n          iVar4 = (int)local_50 - (int)local_58;\n          lVar15 = sh_xmalloc((long)(iVar4 + 1),\"subst.c\",0x2310);\n          uVar7 = 0;\n          if (0 < iVar4) {\n            do {\n              *(byte *)(lVar15 + uVar7) = pbVar1[uVar7];\n              bVar16 = iVar4 - 1 != uVar7;\n              uVar7 = uVar7 + 1;\n            } while (bVar16);\n          }\n          *(undefined *)(lVar15 + iVar4) = 0;\n          pcVar8 = (char *)strcreplace(param_3,0x26,lVar15,2);\n          sh_xfree(lVar15,\"subst.c\",0x2315);\n          sVar10 = strlen(pcVar8);\n        }\n        lVar15 = (long)iVar14;\n        pbVar6 = (byte *)(lVar15 + sVar13 + sVar10);\n        if (pbVar11 <= pbVar6) {\n          do {\n            pbVar11 = pbVar11 + 0x40;\n          } while (pbVar11 <= pbVar6);\n          local_a8 = (char *)sh_xrealloc(local_a8,pbVar11,\"subst.c\",0x231e);\n        }\n        if (sVar13 != 0) {\n          iVar14 = iVar14 + (int)sVar13;\n          strncpy(local_a8 + lVar15,(char *)pbVar12,sVar13);\n          lVar15 = (long)iVar14;\n        }\n        if (local_b0 != 0) {\n          strncpy(local_a8 + lVar15,pcVar8,sVar10);\n          iVar14 = iVar14 + (int)sVar10;\n          lVar15 = (long)iVar14;\n        }\n        if (pcVar8 != param_3) {\n          sh_xfree(pcVar8,\"subst.c\",0x2331);\n        }\n        pbVar12 = __s;\n        if (((((byte)((param_4 & 0xffffffff) >> 4) ^ 1) & 1) != 0) || ((param_4 & 3) != 0)) {\n          if (__s == (byte *)0x0) goto LAB_00173214;\n          goto LAB_0017356b;\n        }\n      } while (pbVar1 != __s);\n      if (pbVar11 <= (byte *)(long)(locale_mb_cur_max + iVar14)) {\n        do {\n          pbVar11 = pbVar11 + 0x40;\n        } while (pbVar11 <= (byte *)(long)(locale_mb_cur_max + iVar14));\n        local_a8 = (char *)sh_xrealloc(local_a8,pbVar11,\"subst.c\",0x233d);\n      }\n      mVar2 = local_48;\n      pbVar1 = (byte *)(local_a8 + lVar15);\n      bVar9 = *__s;\n      pbVar12 = __s + 1;\n      if (locale_mb_cur_max < 2) {\n        *pbVar1 = bVar9;\n        sVar10 = 1;\n        local_48 = mVar2;\n      }\n      else {\n        if (((*(uint *)(is_basic_table + (ulong)(bVar9 >> 5) * 4) >> (bVar9 & 0x1f) & 1) == 0) &&\n           ((locale_utf8locale == 0 || ((char)bVar9 < '\\0')))) {\n          sVar10 = mbrtowc((wchar_t *)0x0,(char *)__s,(size_t)(param_1 + (sVar5 - (long)__s)),\n                           &local_48);\n          if (0xfffffffffffffffd < sVar10) {\n            sVar10 = 1;\n            *pbVar1 = *__s;\n            local_48 = mVar2;\n            goto LAB_00173261;\n          }\n          if (sVar10 == 0) {\n            sVar10 = 1;\n          }\n          sVar13 = 0;\n          bVar9 = *__s;\n          while( true ) {\n            pbVar1[sVar13] = bVar9;\n            sVar13 = sVar13 + 1;\n            if (sVar13 == sVar10) break;\n            bVar9 = __s[sVar13];\n          }\n        }\n        else {\n          *pbVar1 = bVar9;\n          sVar10 = 1;\n        }\n        pbVar12 = __s + sVar10;\n      }\nLAB_00173261:\n      iVar14 = iVar14 + (int)sVar10;\n      local_50 = pbVar12;\n    } while( true );\n  }\n  if ((param_4 & 0x100) == 0) {\n    sVar5 = strlen(param_3);\n    pcVar8 = (char *)sh_xmalloc(sVar5 + 1,\"subst.c\",0x2300);\n    local_a8 = strcpy(pcVar8,param_3);\n  }\n  else {\n    local_a8 = (char *)strcreplace(param_3,0x26,&DAT_00213d70,2);\n  }\nLAB_00172f30:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_a8;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001f06f0": "\nvoid FUN_001f06f0(void)\n\n{\n  rl_point = rl_end;\n  if (((_rl_history_preserve_point != 0) && (_rl_history_saved_point != -1)) &&\n     (rl_point = _rl_history_saved_point, rl_end < _rl_history_saved_point)) {\n    rl_point = rl_end;\n  }\n  if (rl_editing_mode == 0) {\n    if (_rl_keymap != &vi_insertion_keymap) {\n      rl_point = 0;\n      return;\n    }\n  }\n  else if ((rl_editing_mode == 1) && (rl_mark = rl_end, rl_point == rl_end)) {\n    rl_mark = 0;\n  }\n  return;\n}\n\n",
  "make_bare_simple_command": "\nundefined8 * make_bare_simple_command(void)\n\n{\n  undefined4 uVar1;\n  undefined8 *puVar2;\n  undefined4 *puVar3;\n  \n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0x1f5);\n  puVar3 = (undefined4 *)sh_xmalloc(0x18,\"make_cmd.c\",0x1f6);\n  uVar1 = line_number;\n  puVar2[3] = puVar3;\n  *puVar3 = 0;\n  puVar3[1] = uVar1;\n  *(undefined8 *)(puVar3 + 2) = 0;\n  *(undefined8 *)(puVar3 + 4) = 0;\n  puVar2[2] = 0;\n  *puVar2 = 4;\n  return puVar2;\n}\n\n",
  "reset_mail_timer": "\nvoid reset_mail_timer(void)\n\n{\n  DAT_002478a8 = time((time_t *)0x0);\n  return;\n}\n\n",
  "array_to_string": "\nundefined * array_to_string(long param_1,char *param_2,int param_3)\n\n{\n  long lVar1;\n  long lVar2;\n  int iVar3;\n  size_t sVar4;\n  undefined *puVar5;\n  char *__s;\n  int iVar6;\n  long lVar7;\n  int iVar8;\n  ulong uVar9;\n  int iVar10;\n  \n  if (param_1 != 0) {\n    if (*(long *)(param_1 + 8) == 0) {\n      puVar5 = (undefined *)sh_xmalloc(1,\"array.c\",0x42c);\n      *puVar5 = 0;\n      return puVar5;\n    }\n    lVar1 = *(long *)(param_1 + 0x10);\n    lVar7 = *(long *)(lVar1 + 0x10);\n    if (lVar1 != lVar7) {\n      puVar5 = (undefined *)0x0;\n      iVar8 = 0;\n      iVar10 = 0;\n      sVar4 = strlen(param_2);\n      iVar3 = (int)sVar4;\n      do {\n        if (iVar10 == 0) {\n          iVar10 = 0x40;\n          puVar5 = (undefined *)sh_xmalloc(0x40,\"array.c\",0x39f);\n        }\n        __s = *(char **)(lVar7 + 8);\n        if (__s != (char *)0x0) {\n          if (param_3 == 0) {\n            sVar4 = strlen(__s);\n            uVar9 = sVar4 & 0xffffffff;\n            iVar6 = iVar3 + 2 + (int)sVar4 + iVar8;\n            if (iVar6 < iVar10) {\n              iVar6 = iVar8 + (int)sVar4;\n              memcpy(puVar5 + iVar8,__s,sVar4 + 1);\n            }\n            else {\nLAB_0018a4a0:\n              do {\n                iVar10 = iVar10 * 2;\n              } while (iVar10 <= iVar6);\n              puVar5 = (undefined *)sh_xrealloc(puVar5,(long)iVar10,\"array.c\",0x3a3);\n              strcpy(puVar5 + iVar8,__s);\n              iVar6 = iVar8 + (int)uVar9;\n              if (param_3 != 0) goto LAB_0018a4ea;\n            }\n            lVar2 = *(long *)(lVar7 + 0x10);\n            iVar8 = iVar6;\n          }\n          else {\n            __s = (char *)quote_string();\n            sVar4 = strlen(__s);\n            uVar9 = sVar4 & 0xffffffff;\n            iVar6 = iVar3 + 2 + (int)sVar4 + iVar8;\n            if (iVar10 <= iVar6) goto LAB_0018a4a0;\n            memcpy(puVar5 + iVar8,__s,sVar4 + 1);\n            iVar6 = iVar8 + (int)sVar4;\nLAB_0018a4ea:\n            sh_xfree(__s,\"array.c\",0x3a8);\n            lVar2 = *(long *)(lVar7 + 0x10);\n            iVar8 = iVar6;\n          }\n          if (lVar1 == lVar2) break;\n          strcpy(puVar5 + iVar8,param_2);\n          iVar8 = iVar8 + iVar3;\n        }\n        lVar7 = *(long *)(lVar7 + 0x10);\n      } while (lVar1 != lVar7);\n      if (puVar5 == (undefined *)0x0) {\n        return (undefined *)0x0;\n      }\n      puVar5[iVar8] = 0;\n      return puVar5;\n    }\n  }\n  return (undefined *)0x0;\n}\n\n",
  "line_isblank": "\nundefined8 line_isblank(byte *param_1)\n\n{\n  byte bVar1;\n  ushort **ppuVar2;\n  \n  if (param_1 == (byte *)0x0) {\n    return 0;\n  }\n  bVar1 = *param_1;\n  if (bVar1 != 0) {\n    ppuVar2 = __ctype_b_loc();\n    param_1 = param_1 + 1;\n    do {\n      if ((*(byte *)(*ppuVar2 + bVar1) & 1) == 0) {\n        return 0;\n      }\n      bVar1 = *param_1;\n      param_1 = param_1 + 1;\n    } while (bVar1 != 0);\n  }\n  return 1;\n}\n\n",
  "unfreeze_jobs_list": "\nvoid unfreeze_jobs_list(void)\n\n{\n  DAT_00247660 = 0;\n  return;\n}\n\n",
  "tgoto": "\nvoid tgoto(void)\n\n{\n  (*(code *)PTR_tgoto_00237990)();\n  return;\n}\n\n",
  "copy_redirects": "\nlong * copy_redirects(long *param_1)\n\n{\n  long *plVar1;\n  long *plVar2;\n  \n  if (param_1 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  plVar2 = (long *)0x0;\n  do {\n    plVar1 = plVar2;\n    plVar2 = (long *)copy_redirect(param_1);\n    *plVar2 = (long)plVar1;\n    param_1 = (long *)*param_1;\n  } while (param_1 != (long *)0x0);\n  if (plVar1 != (long *)0x0) {\n    plVar2 = (long *)list_reverse(plVar2);\n    return plVar2;\n  }\n  return plVar2;\n}\n\n",
  "_rl_prep_non_filename_text": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid _rl_prep_non_filename_text(void)\n\n{\n  if (_DAT_00240608 != (void *)0x0) {\n    fwrite(_DAT_00240608,_DAT_00240600,1,rl_outstream);\n    return;\n  }\n  fwrite(PTR_DAT_002405e8,_rl_color_indicator,1,rl_outstream);\n  fwrite(PTR_DAT_00240618,DAT_00240610,1,rl_outstream);\n  fwrite(PTR_DAT_002405f8,DAT_002405f0,1,rl_outstream);\n  return;\n}\n\n",
  "FUN_0015bc10": "\nvoid FUN_0015bc10(void)\n\n{\n  long lVar1;\n  \n  for (DAT_00242344 = DAT_00242344 + -1; 0 < DAT_00242344; DAT_00242344 = DAT_00242344 + -1) {\n    if (*(long *)(DAT_00242348[DAT_00242344] + 0x28) != 0) {\n      sh_xfree(*(long *)(DAT_00242348[DAT_00242344] + 0x28),\"expr.c\",0x134);\n    }\n    lVar1 = DAT_00242348[DAT_00242344];\n    if (*(long *)(lVar1 + 8) != 0) {\n      sh_xfree(*(long *)(lVar1 + 8),\"expr.c\",0x137);\n      lVar1 = DAT_00242348[DAT_00242344];\n    }\n    sh_xfree(lVar1,\"expr.c\",0x139);\n  }\n  if (DAT_00242344 != 0) {\n    DAT_00242428 = 0;\n    DAT_00242344 = DAT_00242344;\n    return;\n  }\n  sh_xfree(*DAT_00242348,\"expr.c\",0x13c);\n  DAT_00242428 = 0;\n  return;\n}\n\n",
  "assign_array_element": "\nlong assign_array_element(undefined8 param_1,undefined8 param_2,uint param_3,undefined2 *param_4)\n\n{\n  char cVar1;\n  long lVar2;\n  long lVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char *pcVar6;\n  long lVar7;\n  long lVar8;\n  undefined8 uVar9;\n  uint uVar10;\n  long in_FS_OFFSET;\n  char *local_70;\n  int local_4c;\n  char *local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar10 = (uint)((param_3 & 0x80) != 0) << 5;\n  if ((param_3 & 0x1000) != 0) {\n    uVar10 = uVar10 | 0x40;\n  }\n  lVar2 = array_variable_name(param_1,uVar10,&local_48,&local_4c);\n  if (lVar2 == 0) {\n    lVar3 = 0;\n    goto LAB_0018cb97;\n  }\n  lVar3 = find_variable(lVar2);\n  if ((lVar3 == 0) || ((*(byte *)(lVar3 + 0x28) & 0x40) == 0)) {\n    cVar1 = *local_48;\njoined_r0x0018cb5f:\n    if (((cVar1 != '@') && (cVar1 != '*')) || (local_48[1] != ']')) goto LAB_0018c9fd;\n  }\n  else {\n    if ((param_3 & 0x880) == 0) {\n      cVar1 = *local_48;\n      goto joined_r0x0018cb5f;\n    }\nLAB_0018c9fd:\n    if ((1 < local_4c) && (local_48[local_4c] == '\\0')) {\n      if (lVar3 == 0) {\n        lVar7 = array_expand_index(0,local_48,local_4c,0);\nLAB_0018cbef:\n        if (lVar7 < 0) {\nLAB_0018cc90:\n          lVar3 = 0;\n          err_badarraysub(param_1);\n        }\n        else {\nLAB_0018cbf8:\n          lVar3 = bind_array_variable(lVar2,lVar7,param_2,param_3);\n          if (param_4 != (undefined2 *)0x0) {\n            uVar9 = 0;\n            *param_4 = 1;\n            *(long *)(param_4 + 4) = lVar7;\n            if (lVar3 != 0) {\n              uVar9 = array_reference(*(undefined8 *)(lVar3 + 8));\n            }\n            *(undefined8 *)(param_4 + 0xc) = uVar9;\n            sh_xfree(lVar2,\"arrayfunc.c\",0x186);\n            goto LAB_0018cb97;\n          }\n        }\n      }\n      else {\n        if ((*(byte *)(lVar3 + 0x28) & 0x40) == 0) {\n          lVar7 = array_expand_index(lVar3,local_48,local_4c,0);\n          if (lVar7 < 0) {\n            lVar8 = 1;\n            if ((*(byte *)(lVar3 + 0x28) & 4) != 0) {\n              lVar8 = **(long **)(lVar3 + 8) + 1;\n            }\n            lVar7 = lVar7 + lVar8;\n            goto LAB_0018cbef;\n          }\n          goto LAB_0018cbf8;\n        }\n        pcVar6 = local_48 + (long)local_4c + -1;\n        *pcVar6 = '\\0';\n        if ((param_3 & 0x80) == 0) {\n          pcVar5 = (char *)expand_subscript_string(local_48,0);\n          *pcVar6 = ']';\n          if (pcVar5 == (char *)0x0) goto LAB_0018cc90;\n        }\n        else {\n          sVar4 = strlen(local_48);\n          pcVar5 = (char *)sh_xmalloc(sVar4 + 1,\"arrayfunc.c\",0x1a1);\n          pcVar5 = strcpy(pcVar5,local_48);\n          *pcVar6 = ']';\n        }\n        if (*pcVar5 == '\\0') {\n          lVar3 = 0;\n          err_badarraysub(param_1);\n          sh_xfree(pcVar5,\"arrayfunc.c\",0x1a6);\n          goto LAB_0018cb31;\n        }\n        if (param_4 != (undefined2 *)0x0) {\n          sVar4 = strlen(pcVar5);\n          pcVar6 = (char *)sh_xmalloc(sVar4 + 1,\"arrayfunc.c\",0x1aa);\n          local_70 = strcpy(pcVar6,pcVar5);\n        }\n        uVar10 = *(uint *)(lVar3 + 0x28);\n        if ((uVar10 & 2) == 0) {\n          if ((uVar10 & 0x4000) != 0) goto LAB_0018cce1;\nLAB_0018caef:\n          lVar3 = FUN_0018a950(lVar3,*(undefined8 *)(lVar3 + 8),pcVar5,param_2,param_3);\n          if (param_4 == (undefined2 *)0x0) goto LAB_0018cb31;\n          *param_4 = 2;\n          *(char **)(param_4 + 8) = local_70;\n          if (lVar3 != 0) goto LAB_0018ccfb;\n          lVar3 = 0;\n          uVar9 = 0;\n        }\n        else {\n          if (((param_3 & 0x20) != 0) && ((uVar10 & 0x4000) == 0)) goto LAB_0018caef;\n          err_readonly(lVar2);\nLAB_0018cce1:\n          if (param_4 == (undefined2 *)0x0) goto LAB_0018cb31;\n          *param_4 = 2;\n          *(char **)(param_4 + 8) = local_70;\nLAB_0018ccfb:\n          uVar9 = assoc_reference(*(undefined8 *)(lVar3 + 8),local_70);\n        }\n        *(undefined8 *)(param_4 + 0xc) = uVar9;\n      }\nLAB_0018cb31:\n      sh_xfree(lVar2,\"arrayfunc.c\",0x186);\n      goto LAB_0018cb97;\n    }\n  }\n  lVar3 = 0;\n  sh_xfree(lVar2,\"arrayfunc.c\",0x177);\n  err_badarraysub(param_1);\nLAB_0018cb97:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_erase_entire_line": "\nvoid _rl_erase_entire_line(void)\n\n{\n  _rl_cr();\n  _rl_last_c_pos = 0;\n  if (_rl_term_clreol != 0) {\n    tputs(_rl_term_clreol,1,_rl_output_character_function);\n  }\n  _rl_cr();\n  _rl_last_c_pos = 0;\n  fflush(rl_outstream);\n  return;\n}\n\n",
  "fd_is_bash_input": "\nbool fd_is_bash_input(int param_1)\n\n{\n  if ((bash_input == 4) && ((int)DAT_00240a70 == param_1)) {\n    return true;\n  }\n  return interactive_shell == 0 && default_buffered_input == param_1;\n}\n\n",
  "unbind_variable_noref": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 unbind_variable_noref(undefined8 param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long lVar4;\n  \n  lVar4 = shell_variables;\n  if (shell_variables != 0) {\n    do {\n      uVar3 = *(undefined8 *)(lVar4 + 0x20);\n      lVar2 = hash_search(param_1,uVar3,0);\n      if ((lVar2 != 0) && (_DAT_002422f8 = uVar3, *(long *)(lVar2 + 0x10) != 0)) {\n        uVar3 = makunbound(param_1,shell_variables);\n        return uVar3;\n      }\n      plVar1 = (long *)(lVar4 + 0x18);\n      lVar4 = *plVar1;\n    } while (*plVar1 != 0);\n  }\n  return 0;\n}\n\n",
  "pathconf": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nlong pathconf(char *__path,int __name)\n\n{\n  long lVar1;\n  \n  lVar1 = (*(code *)PTR_pathconf_00237960)();\n  return lVar1;\n}\n\n",
  "bash_clear_history": "\nvoid bash_clear_history(void)\n\n{\n  clear_history();\n  history_lines_this_session = 0;\n  return;\n}\n\n",
  "shtimer_clear": "\nvoid shtimer_clear(undefined8 *param_1)\n\n{\n  long lVar1;\n  \n  *param_1 = 0;\n  param_1[1] = 0;\n  if ((*(uint *)((long)param_1 + 0x14) & 1) != 0) {\n    *(undefined4 *)(param_1 + 3) = 0;\n    if ((*(uint *)((long)param_1 + 0x14) & 0x200) == 0) {\n      lVar1 = param_1[5];\n    }\n    else {\n      falarm(0,0);\n      lVar1 = param_1[5];\n    }\n    if ((lVar1 != 0) && ((*(byte *)((long)param_1 + 0x15) & 1) != 0)) {\n      set_signal_handler(0xe);\n      *(uint *)((long)param_1 + 0x14) = *(uint *)((long)param_1 + 0x14) & 0xfffffeff;\n      param_1[5] = 0;\n    }\n  }\n  sh_xfree(param_1,\"timers.c\",0x5e);\n  return;\n}\n\n",
  "rl_delete_horizontal_space": "\nundefined8 rl_delete_horizontal_space(void)\n\n{\n  char cVar1;\n  ulong uVar2;\n  long lVar3;\n  ulong uVar4;\n  int iVar5;\n  \n  if (rl_point == 0) {\n    if (rl_end < 1) {\n      return 0;\n    }\n    uVar4 = 0;\n  }\n  else {\n    uVar2 = (ulong)rl_point;\n    do {\n      cVar1 = *(char *)(rl_line_buffer + -1 + uVar2);\n      uVar4 = uVar2 & 0xffffffff;\n      if ((cVar1 != ' ') && (cVar1 != '\\t')) {\n        iVar5 = rl_point;\n        if (rl_point < rl_end) goto LAB_001efd66;\n        goto LAB_001efd94;\n      }\n      rl_point = (int)uVar2 + -1;\n      uVar2 = uVar2 - 1;\n    } while ((int)uVar2 != 0);\n    if (rl_end <= rl_point) goto LAB_001efd9e;\n    uVar4 = 0;\n  }\nLAB_001efd66:\n  lVar3 = (long)rl_point;\n  do {\n    if ((*(char *)(rl_line_buffer + lVar3) != ' ') &&\n       (iVar5 = (int)lVar3, *(char *)(rl_line_buffer + lVar3) != '\\t')) break;\n    rl_point = (int)lVar3 + 1;\n    lVar3 = lVar3 + 1;\n    iVar5 = rl_point;\n  } while ((int)lVar3 < rl_end);\nLAB_001efd94:\n  if (iVar5 != (int)uVar4) {\n    rl_delete_text(uVar4);\n    rl_point = (int)uVar4;\n  }\nLAB_001efd9e:\n  if (rl_point < 0) {\n    rl_point = 0;\n  }\n  return 0;\n}\n\n",
  "FUN_001b54b0": "\nundefined8 FUN_001b54b0(int param_1,rlim_t *param_2,rlim_t *param_3)\n\n{\n  __rlimit_resource_t __resource;\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  rlimit local_38;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  __resource = (&DAT_002351c4)[(long)param_1 * 8];\n  if ((int)__resource < 0x100) {\n    iVar1 = getrlimit(__resource,&local_38);\n    if (iVar1 < 0) {\n      uVar3 = 0xffffffff;\n    }\n    else {\n      *param_2 = local_38.rlim_cur;\n      *param_3 = local_38.rlim_max;\n      uVar3 = 0;\n    }\n  }\n  else if (__resource == 0x101) {\n    *param_3 = 0x1000;\n    uVar3 = 0;\n    *param_2 = 0x1000;\n  }\n  else {\n    piVar2 = __errno_location();\n    *piVar2 = 0x16;\n    uVar3 = 0xffffffff;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "make_word_from_token": "\nvoid make_word_from_token(undefined param_1)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  undefined local_12;\n  undefined local_11;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_11 = 0;\n  local_12 = param_1;\n  uVar1 = make_bare_word(&local_12);\n  make_word_flags(uVar1,&local_12);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001f4f60": "\nchar * FUN_001f4f60(char *param_1)\n\n{\n  char cVar1;\n  __pid_t _Var2;\n  ssize_t sVar3;\n  size_t sVar4;\n  char *__dest;\n  long in_FS_OFFSET;\n  char acStack_1028 [4104];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar3 = readlink(param_1,acStack_1028,0x1000);\n  if (0 < sVar3) {\n    acStack_1028[sVar3] = '\\0';\n    param_1 = acStack_1028;\n  }\n  sVar4 = strlen(param_1);\n  __dest = (char *)xmalloc(sVar4 + 0xb);\n  strcpy(__dest,param_1);\n  _Var2 = getpid();\n  __dest[sVar4] = '-';\n  __dest[sVar4 + 1] = (char)(_Var2 / 10000) + (char)((_Var2 / 10000) / 10) * -10 + '0';\n  __dest[sVar4 + 2] = (char)(_Var2 / 1000) + (char)((_Var2 / 1000) / 10) * -10 + '0';\n  __dest[sVar4 + 3] = (char)(_Var2 / 100) + (char)((_Var2 / 100) / 10) * -10 + '0';\n  cVar1 = (char)(_Var2 / 10);\n  __dest[sVar4 + 4] = cVar1 + (char)((_Var2 / 10) / 10) * -10 + '0';\n  __dest[sVar4 + 5] = (char)_Var2 + cVar1 * -10 + '0';\n  *(undefined4 *)(__dest + sVar4 + 6) = 0x706d742e;\n  *(undefined *)((long)(__dest + sVar4 + 6) + 4) = 0;\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return __dest;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "u32toutf8": "\nundefined8 u32toutf8(uint param_1,byte *param_2)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  byte bVar3;\n  undefined8 uVar4;\n  \n  bVar3 = (byte)param_1;\n  if (param_1 < 0x80) {\n    *param_2 = bVar3;\n    uVar4 = 1;\n    pbVar2 = param_2 + 1;\n  }\n  else {\n    if (param_1 < 0x800) {\n      param_2[1] = bVar3 & 0x3f | 0x80;\n      *param_2 = (byte)(param_1 >> 6) | 0xc0;\n      param_2[2] = 0;\n      return 2;\n    }\n    if (param_1 < 0x10000) {\n      param_2[2] = bVar3 & 0x3f | 0x80;\n      *param_2 = (byte)(param_1 >> 0xc) | 0xe0;\n      param_2[1] = (byte)(param_1 >> 6) & 0x3f | 0x80;\n      param_2[3] = 0;\n      return 3;\n    }\n    if (param_1 < 0x200000) {\n      pbVar2 = param_2 + 4;\n      uVar4 = 4;\n      param_2[3] = bVar3 & 0x3f | 0x80;\n      *param_2 = (byte)(param_1 >> 0x12) | 0xf0;\n      param_2[1] = (byte)(param_1 >> 0xc) & 0x3f | 0x80;\n      param_2[2] = (byte)(param_1 >> 6) & 0x3f | 0x80;\n    }\n    else {\n      bVar1 = (byte)(param_1 >> 0x18);\n      if (param_1 < 0x4000000) {\n        pbVar2 = param_2 + 5;\n        uVar4 = 5;\n        param_2[4] = bVar3 & 0x3f | 0x80;\n        *param_2 = bVar1 | 0xf8;\n        param_2[1] = (byte)(param_1 >> 0x12) & 0x3f | 0x80;\n        param_2[2] = (byte)(param_1 >> 0xc) & 0x3f | 0x80;\n        param_2[3] = (byte)(param_1 >> 6) & 0x3f | 0x80;\n      }\n      else {\n        uVar4 = 0;\n        pbVar2 = param_2;\n        if (-1 < (int)param_1) {\n          pbVar2 = param_2 + 6;\n          uVar4 = 6;\n          param_2[5] = bVar3 & 0x3f | 0x80;\n          *param_2 = bVar1 >> 6 | 0xfc;\n          param_2[1] = bVar1 & 0x3f | 0x80;\n          param_2[2] = (byte)(param_1 >> 0x12) & 0x3f | 0x80;\n          param_2[3] = (byte)(param_1 >> 0xc) & 0x3f | 0x80;\n          param_2[4] = (byte)(param_1 >> 6) & 0x3f | 0x80;\n        }\n      }\n    }\n  }\n  *pbVar2 = 0;\n  return uVar4;\n}\n\n",
  "coproc_fdchk": "\nvoid coproc_fdchk(int param_1)\n\n{\n  if (DAT_0023842c < 0) {\n    if (DAT_00238430 < 0) {\n      return;\n    }\nLAB_0014a35c:\n    if (param_1 != DAT_00238430) {\n      return;\n    }\n  }\n  else {\n    if (param_1 != DAT_0023842c) {\n      if (DAT_00238430 < 0) {\n        return;\n      }\n      goto LAB_0014a35c;\n    }\n    DAT_0023842c = -1;\n    if ((DAT_00238430 < 0) || (param_1 != DAT_00238430)) goto LAB_0014a384;\n  }\n  DAT_00238430 = -1;\nLAB_0014a384:\n  coproc_setvars(&sh_coproc);\n  return;\n}\n\n",
  "malloc": "\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)FUN_001f85f0(__size,0,0);\n  return pvVar1;\n}\n\n",
  "rl_callback_sigcleanup": "\nvoid rl_callback_sigcleanup(void)\n\n{\n  if ((rl_readline_state & 0x80000) != 0) {\n    if ((rl_readline_state & 0x80) == 0) {\n      if ((rl_readline_state & 0x100) == 0) {\n        if ((rl_readline_state & 0x100000) == 0) {\n          if ((rl_readline_state & 0x400) == 0) {\n            if ((rl_readline_state & 0x200000) != 0) {\n              rl_readline_state = rl_readline_state & 0xffffffffffdfffff;\n            }\n          }\n          else {\n            _rl_argcxt = 0;\n            rl_readline_state = rl_readline_state & 0xfffffffffffffbff;\n          }\n        }\n        else {\n          rl_readline_state = rl_readline_state & 0xffffffffffefffff;\n        }\n      }\n      else {\n        _rl_nsearch_cleanup(_rl_nscxt,0);\n      }\n    }\n    else {\n      _rl_isearch_cleanup(_rl_iscxt,0);\n    }\n    if ((rl_readline_state & 0x800000) != 0) {\n      rl_readline_state = rl_readline_state & 0xffffffffff7fffff;\n    }\n    _rl_callback_func = 0;\n    return;\n  }\n  return;\n}\n\n",
  "make_subshell_command": "\nvoid make_subshell_command(undefined8 param_1)\n\n{\n  undefined4 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x10,\"make_cmd.c\",0x335);\n  *(undefined8 *)(puVar1 + 2) = param_1;\n  *puVar1 = 1;\n  puVar1[1] = line_number;\n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar2[3] = puVar1;\n  *puVar2 = 0xd;\n  *puVar1 = 0;\n  puVar2[2] = 0;\n  return;\n}\n\n",
  "FUN_00192130": "\nchar * FUN_00192130(char *param_1,int param_2)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  char *__dest;\n  \n  pcVar1 = (char *)fnx_fromfs(param_1,(long)param_2);\n  if (param_1 != pcVar1) {\n    sVar2 = strlen(pcVar1);\n    __dest = (char *)sh_xmalloc(sVar2 + 1,\"bashline.c\",0xce0);\n    pcVar1 = strcpy(__dest,pcVar1);\n    return pcVar1;\n  }\n  return param_1;\n}\n\n",
  "_rl_unget_char": "\nundefined4 _rl_unget_char(undefined param_1)\n\n{\n  int iVar1;\n  \n  if (DAT_0024b3e0 < DAT_0024b3e4) {\n    iVar1 = (DAT_0024b3e4 - DAT_0024b3e0) + -1;\n  }\n  else {\n    iVar1 = (DAT_0024b3e4 - DAT_0024b3e0) + 0x1ff;\n  }\n  if (iVar1 != 0) {\n    DAT_0024b3e4 = DAT_0024b3e4 + -1;\n    if (DAT_0024b3e4 < 0) {\n      DAT_0024b3e4 = 0x1ff;\n    }\n    (&DAT_0024b1e0)[DAT_0024b3e4] = param_1;\n    return 1;\n  }\n  return 0;\n}\n\n",
  "valid_array_reference": "\nvoid valid_array_reference(undefined8 param_1,undefined8 param_2)\n\n{\n  tokenize_array_reference(param_1,param_2,0);\n  return;\n}\n\n",
  "show_func_attributes": "\nbool show_func_attributes(undefined8 param_1,undefined4 param_2)\n\n{\n  long lVar1;\n  \n  lVar1 = find_function();\n  if (lVar1 != 0) {\n    show_var_attributes(lVar1,this_shell_builtin == export_builtin ||\n                              this_shell_builtin == readonly_builtin,param_2);\n  }\n  return lVar1 == 0;\n}\n\n",
  "rl_restore_prompt": "\nvoid rl_restore_prompt(void)\n\n{\n  if (DAT_0024a8a0 != (void *)0x0) {\n    free(DAT_0024a8a0);\n  }\n  if (DAT_0024a898 != (void *)0x0) {\n    free(DAT_0024a898);\n  }\n  if (DAT_0024a868 != (void *)0x0) {\n    free(DAT_0024a868);\n  }\n  DAT_0024a8a0 = (void *)DAT_0024a858;\n  DAT_0024a898 = (void *)DAT_0024a850;\n  DAT_0024a868 = (void *)DAT_0024a848;\n  DAT_0024a880 = DAT_0024a844;\n  DAT_0024a88c = DAT_0024a840;\n  DAT_0024a890 = DAT_0024a83c;\n  DAT_0024a894 = DAT_0024a838;\n  DAT_0024a878 = DAT_0024a834;\n  DAT_0024a870 = DAT_0024a830;\n  DAT_0024a858 = 0;\n  DAT_0024a850 = 0;\n  DAT_0024a838 = 0;\n  DAT_0024a848 = 0;\n  DAT_0024a83c = 0;\n  DAT_0024a844 = 0;\n  DAT_0024a840 = 0;\n  DAT_0024a834 = 0;\n  DAT_0024a830 = 0;\n  return;\n}\n\n",
  "FUN_001874a0": "\nuint FUN_001874a0(void)\n\n{\n  char *pcVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  \n  uVar2 = FUN_00187300();\n  if (DAT_0024856c < DAT_00248568) {\n    pcVar1 = *(char **)(DAT_00248560 + (long)DAT_0024856c * 8);\n    if (((*pcVar1 == '-') && (pcVar1[1] == 'a')) && (pcVar1[2] == '\\0')) {\n      DAT_0024856c = DAT_0024856c + 1;\n      uVar3 = FUN_001874a0();\n      uVar2 = (uint)((int)uVar3 != 0) & (uint)CONCAT71((int7)((ulong)uVar3 >> 8),uVar2 != 0);\n    }\n  }\n  return uVar2;\n}\n\n",
  "make_child": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\n__pid_t make_child(long *param_1,uint param_2)\n\n{\n  long **pplVar1;\n  long lVar2;\n  long *plVar3;\n  long *plVar4;\n  uint uVar5;\n  __pid_t __pid;\n  __pid_t __pid_00;\n  int iVar6;\n  int *piVar7;\n  ssize_t sVar8;\n  long **pplVar9;\n  ulong uVar10;\n  long **pplVar11;\n  uint __seconds;\n  long in_FS_OFFSET;\n  undefined8 local_1e0;\n  undefined local_1c9;\n  sigset_t local_1c8;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_c8);\n  sigprocmask(0,(sigset_t *)0x0,&local_c8);\n  sigaddset(&local_c8,0xf);\n  sigemptyset(&local_1c8);\n  sigaddset(&local_1c8,0x11);\n  sigaddset(&local_1c8,2);\n  sigaddset(&local_1c8,0xf);\n  sigemptyset(&local_148);\n  sigprocmask(0,&local_1c8,&local_148);\n  if (interactive_shell != 0) {\n    local_1e0 = set_signal_handler(0xf,0);\n  }\n  if (already_making_children == 0) {\n    already_making_children = 1;\n    start_pipeline();\n  }\n  if ((default_buffered_input != -1) && ((0 < default_buffered_input || ((param_2 & 1) == 0)))) {\n    sync_buffered_stream();\n  }\n  __seconds = 1;\n  while( true ) {\n    __pid = fork();\n    if (-1 < __pid) break;\n    piVar7 = __errno_location();\n    if ((*piVar7 != 0xb) || (0xf < (int)__seconds)) {\nLAB_00162e00:\n      if (interactive_shell != 0) {\n        set_signal_handler(0xf,local_1e0);\n      }\n      sys_error(&DAT_001fdc11);\n      if ((pipeline_pgrp != 0) && (pipeline_pgrp != shell_pgrp)) {\n        killpg(pipeline_pgrp,0xf);\n        killpg(pipeline_pgrp,0x12);\n      }\n      if (the_pipeline != (long **)0x0) {\n        already_making_children = 0;\n        start_pipeline();\n      }\n      set_exit_status(0x7e);\n      throw_to_top_level();\n      goto LAB_00162e70;\n    }\n    sigprocmask(2,&local_c8,(sigset_t *)0x0);\n    FUN_00161c20(0);\n    *piVar7 = 0xb;\n    sys_error(\"fork: retry\");\n    uVar5 = sleep(__seconds);\n    if ((uVar5 != 0) || (__seconds = __seconds * 2, interrupt_state != 0)) goto LAB_00162e00;\n    sigprocmask(2,&local_1c8,(sigset_t *)0x0);\n  }\n  if (__pid == 0) {\n    subshell_environment = subshell_environment | 0x100;\n    __pid_00 = getpid();\n    unset_bash_input(0);\n    interrupt_state = 0;\n    restore_sigmask();\n    if (job_control == 0) {\n      if (pipeline_pgrp == 0) {\n        pipeline_pgrp = shell_pgrp;\n      }\n      default_tty_job_signals();\n    }\n    else {\n      if (pipeline_pgrp == 0) {\n        pipeline_pgrp = __pid_00;\n      }\n      if (shell_pgrp == pipeline_pgrp) {\n        set_signal_handler(0x14,1);\n        set_signal_handler(0x15,1);\n        set_signal_handler(0x16,1);\n      }\n      else {\n        default_tty_job_signals();\n      }\n      iVar6 = setpgid(__pid_00,pipeline_pgrp);\n      if (iVar6 < 0) {\n        sys_error(\"child setpgid (%ld to %ld)\",(long)__pid_00,(long)pipeline_pgrp);\n      }\n      if ((shell_pgrp != pipeline_pgrp) &&\n         ((subshell_environment & 0x11 | running_in_background | param_2 & 5) == 0)) {\n        give_terminal_to(pipeline_pgrp,0);\n      }\n      if (__pid_00 == pipeline_pgrp) {\n        if (-1 < DAT_0023873c) {\n          close(DAT_0023873c);\n          DAT_0023873c = -1;\n        }\n        if (-1 < pgrp_pipe) {\n          do {\n            sVar8 = read(pgrp_pipe,&local_1c9,1);\n            if (sVar8 != -1) break;\n            piVar7 = __errno_location();\n          } while (*piVar7 == 4);\n        }\n      }\n    }\n    sh_closepipe(&pgrp_pipe);\n  }\n  else {\n    if (interactive_shell != 0) {\n      set_signal_handler(0xf,local_1e0);\n    }\nLAB_00162e70:\n    if (job_control == 0) {\n      if (pipeline_pgrp == 0) {\n        pipeline_pgrp = shell_pgrp;\n      }\n    }\n    else {\n      if (pipeline_pgrp == 0) {\n        pipeline_pgrp = __pid;\n      }\n      setpgid(__pid,pipeline_pgrp);\n    }\n    pplVar9 = (long **)sh_xmalloc(0x20,\"jobs.c\",0x5e3);\n    *(__pid_t *)(pplVar9 + 1) = __pid;\n    *pplVar9 = (long *)the_pipeline;\n    pplVar9[3] = param_1;\n    *(undefined8 *)((long)pplVar9 + 0xc) = 0x100000000;\n    pplVar1 = the_pipeline;\n    if (the_pipeline == (long **)0x0) {\n      the_pipeline = pplVar9;\n      *pplVar9 = (long *)pplVar9;\n    }\n    else {\n      do {\n        pplVar11 = pplVar1;\n        pplVar1 = (long **)*pplVar11;\n      } while (the_pipeline != pplVar1);\n      the_pipeline = pplVar9;\n      *pplVar11 = (long *)pplVar9;\n    }\n    if ((param_2 & 1) != 0) {\n      last_asynchronous_pid = __pid;\n    }\n    if (0 < DAT_0023877c) {\n      uVar10 = 0;\n      do {\n        lVar2 = *(long *)(jobs + uVar10 * 8);\n        if (lVar2 != 0) {\n          plVar3 = *(long **)(lVar2 + 8);\n          iVar6 = *(int *)(plVar3 + 1);\n          plVar4 = plVar3;\n          while( true ) {\n            if (__pid == iVar6) {\n              if (*(int *)(lVar2 + 0x14) == 4) {\n                if (DAT_00247660 == 0) {\n                  FUN_0015f990(uVar10 & 0xffffffff,2);\n                }\n              }\n              else {\n                internal_debug(\"forked pid %d appears in running job %d\",__pid,\n                               (int)(uVar10 & 0xffffffff) + 1);\n                *(undefined4 *)(plVar4 + 1) = 0;\n              }\n              goto LAB_00162f30;\n            }\n            plVar4 = (long *)*plVar4;\n            if (plVar3 == plVar4) break;\n            iVar6 = *(int *)(plVar4 + 1);\n          }\n        }\n        uVar10 = uVar10 + 1;\n      } while ((long)DAT_0023877c != uVar10);\n    }\nLAB_00162f30:\n    FUN_0015ec90(__pid);\n    _DAT_00238774 = _DAT_00238774 + 1;\n    _DAT_00238768 = _DAT_00238768 + 1;\n    last_made_pid = __pid;\n    sigprocmask(2,&local_148,(sigset_t *)0x0);\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return __pid;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "list_append": "\nlong ** list_append(long **param_1,long *param_2)\n\n{\n  long **pplVar1;\n  long **pplVar2;\n  \n  pplVar1 = param_1;\n  if (param_1 == (long **)0x0) {\n    return (long **)param_2;\n  }\n  do {\n    pplVar2 = pplVar1;\n    pplVar1 = (long **)*pplVar2;\n  } while (pplVar1 != (long **)0x0);\n  *pplVar2 = param_2;\n  return param_1;\n}\n\n",
  "rl_history_search_forward": "\nundefined8 rl_history_search_forward(int param_1,undefined4 param_2)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  if ((rl_last_func != rl_history_search_forward) && (rl_last_func != rl_history_search_backward)) {\n    FUN_001d4840(1);\n  }\n  if (DAT_0024a46c != 0) {\n    iVar2 = -param_1;\n    if (0 < param_1) {\n      iVar2 = param_1;\n    }\n    uVar1 = FUN_001d4900(iVar2,((0 < param_1) - 1) + (uint)(0 < param_1));\n    return uVar1;\n  }\n  uVar1 = rl_get_next_history(param_1,param_2);\n  return uVar1;\n}\n\n",
  "FUN_00144c70": "\nvoid FUN_00144c70(long **param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  long *plVar3;\n  undefined8 *puVar4;\n  ulong uVar5;\n  ulong extraout_RDX;\n  ulong extraout_RDX_00;\n  ulong extraout_RDX_01;\n  ulong extraout_RDX_02;\n  ulong extraout_RDX_03;\n  ulong extraout_RDX_04;\n  ulong extraout_RDX_05;\n  ulong extraout_RDX_06;\n  ulong extraout_RDX_07;\n  ulong extraout_RDX_08;\n  ulong extraout_RDX_09;\n  ulong extraout_RDX_10;\n  undefined8 *puVar6;\n  undefined8 *puVar7;\n  long *plVar8;\n  \n  DAT_00241f28 = 0;\n  if (param_1 == (long **)0x0) {\n    return;\n  }\n  puVar7 = (undefined8 *)0x0;\n  puVar6 = (undefined8 *)0x0;\n  iVar1 = *(int *)(param_1 + 3);\n  puVar4 = puVar6;\n  if ((iVar1 - 4U & 0xfffffffb) != 0) goto LAB_00144d00;\n  while( true ) {\n    puVar4 = (undefined8 *)copy_redirect(param_1);\n    *puVar4 = 0;\n    FUN_00144b90(puVar4);\n    if (puVar7 == (undefined8 *)0x0) break;\n    *puVar6 = puVar4;\n    while( true ) {\n      param_1 = (long **)*param_1;\n      if (param_1 == (long **)0x0) goto LAB_00144d30;\nLAB_00144ce6:\n      FUN_001446d0(&DAT_001fdb1c);\n      iVar1 = *(int *)(param_1 + 3);\n      puVar6 = puVar4;\n      if ((iVar1 - 4U & 0xfffffffb) == 0) break;\nLAB_00144d00:\n      plVar8 = param_1[4];\n      uVar5 = (ulong)*(uint *)(param_1 + 4);\n      plVar3 = param_1[1];\n      iVar2 = *(int *)(param_1 + 1);\n      switch(iVar1) {\n      case 0:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          if (iVar2 != 1) {\n            FUN_001446d0(\"%d\",iVar2,uVar5);\n            uVar5 = extraout_RDX;\n          }\n        }\n        else {\n          FUN_001446d0(&DAT_001fc62b,*plVar3,uVar5);\n          uVar5 = extraout_RDX_08;\n        }\n        FUN_001446d0(&DAT_001fc6e1,*plVar8,uVar5);\n        break;\n      case 1:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          if (iVar2 != 0) {\n            FUN_001446d0(\"%d\",iVar2,uVar5);\n            uVar5 = extraout_RDX_09;\n          }\n        }\n        else {\n          FUN_001446d0(&DAT_001fc62b,*plVar3,uVar5);\n          uVar5 = extraout_RDX_03;\n        }\n        FUN_001446d0(&DAT_001fc645,*plVar8,uVar5);\n        break;\n      case 2:\n        FUN_001446d0(&DAT_001fdb61,iVar2,uVar5);\n        break;\n      case 3:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          if (iVar2 != 1) {\n            FUN_001446d0(\"%d\",iVar2,uVar5);\n            uVar5 = extraout_RDX_00;\n          }\n        }\n        else {\n          FUN_001446d0(&DAT_001fc62b,*plVar3,uVar5);\n          uVar5 = extraout_RDX_06;\n        }\n        FUN_001446d0(\">> %s\",*plVar8,uVar5);\n        break;\n      case 5:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          if (iVar2 != 0) {\n            FUN_001446d0(\"%d\",iVar2,uVar5);\n            plVar8 = param_1[4];\n            uVar5 = extraout_RDX_10;\n          }\n        }\n        else {\n          FUN_001446d0(&DAT_001fc62b,*plVar3,uVar5);\n          plVar8 = param_1[4];\n          uVar5 = extraout_RDX_07;\n        }\n        FUN_001446d0(&DAT_001fc643,*plVar8,uVar5);\n        break;\n      case 6:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          FUN_001446d0(\"%d<&%d\",iVar2,uVar5);\n        }\n        else {\n          FUN_001446d0(\"{%s}<&%d\",*plVar3,uVar5);\n        }\n        break;\n      case 7:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          FUN_001446d0(\"%d>&%d\",iVar2,uVar5);\n        }\n        else {\n          FUN_001446d0(\"{%s}>&%d\",*plVar3,uVar5);\n        }\n        break;\n      case 8:\n        FUN_00144b90(param_1);\n        FUN_001446d0(&DAT_001ff6d2);\n        FUN_001446d0(&DAT_001fc632,*param_1[4],param_1[5]);\n        break;\n      case 9:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          FUN_001446d0(\"%d>&-\",iVar2,uVar5);\n        }\n        else {\n          FUN_001446d0(\"{%s}>&-\",*plVar3,uVar5);\n        }\n        break;\n      case 10:\n        FUN_001446d0(&DAT_001fc6e0,*plVar8,uVar5);\n        break;\n      case 0xb:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          if (iVar2 != 1) {\n            FUN_001446d0(\"%d\",iVar2,uVar5);\n            uVar5 = extraout_RDX_02;\n          }\n        }\n        else {\n          FUN_001446d0(&DAT_001fc62b,*plVar3,uVar5);\n          uVar5 = extraout_RDX_04;\n        }\n        FUN_001446d0(\"<> %s\",*plVar8,uVar5);\n        break;\n      case 0xc:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          if (iVar2 != 1) {\n            FUN_001446d0(\"%d\",iVar2,uVar5);\n            uVar5 = extraout_RDX_01;\n          }\n        }\n        else {\n          FUN_001446d0(&DAT_001fc62b,*plVar3,uVar5);\n          uVar5 = extraout_RDX_05;\n        }\n        FUN_001446d0(\">| %s\",*plVar8,uVar5);\n        break;\n      case 0xd:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          if (iVar2 == 0) {\n            FUN_001446d0(&DAT_001fc675,*plVar8);\n          }\n          else {\n            FUN_001446d0(&DAT_001fc673);\n          }\n        }\n        else {\n          FUN_001446d0(\"{%s}<&%s\",*plVar3);\n        }\n        break;\n      case 0xe:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          if (iVar2 == 1) {\n            FUN_001446d0(&DAT_001fc685,*plVar8);\n          }\n          else {\n            FUN_001446d0(&DAT_001fc683);\n          }\n        }\n        else {\n          FUN_001446d0(\"{%s}>&%s\",*plVar3);\n        }\n        break;\n      case 0xf:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          FUN_001446d0(\"%d<&%d-\",iVar2,uVar5);\n        }\n        else {\n          FUN_001446d0(\"{%s}<&%d-\",*plVar3,uVar5);\n        }\n        break;\n      case 0x10:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          FUN_001446d0(\"%d>&%d-\",iVar2,uVar5);\n        }\n        else {\n          FUN_001446d0(\"{%s}>&%d-\",*plVar3,uVar5);\n        }\n        break;\n      case 0x11:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          FUN_001446d0(\"%d<&%s-\",iVar2,*plVar8);\n        }\n        else {\n          FUN_001446d0(\"{%s}<&%s-\",*plVar3,*plVar8);\n        }\n        break;\n      case 0x12:\n        if ((*(byte *)(param_1 + 2) & 1) == 0) {\n          FUN_001446d0(\"%d>&%s-\",iVar2,*plVar8);\n        }\n        else {\n          FUN_001446d0(\"{%s}>&%s-\",*plVar3,*plVar8);\n        }\n        break;\n      case 0x13:\n        FUN_001446d0(&DAT_001fc6e6,*plVar8,uVar5);\n      }\n    }\n  }\n  param_1 = (long **)*param_1;\n  puVar7 = puVar4;\n  if (param_1 != (long **)0x0) goto LAB_00144ce6;\nLAB_00144d30:\n  puVar6 = DAT_00241f18;\n  if ((puVar7 != (undefined8 *)0x0) && (puVar6 = puVar7, DAT_00241f24 == 0)) {\n    FUN_001446d0(&DAT_001ff6d2);\n    do {\n      FUN_001446d0(&DAT_001fc632,*(undefined8 *)puVar6[4],puVar6[5]);\n      FUN_001446d0(&DAT_001ff6d2);\n      puVar6 = (undefined8 *)*puVar6;\n    } while (puVar6 != (undefined8 *)0x0);\n    DAT_00241f28 = 1;\n    dispose_redirects(puVar7);\n    return;\n  }\n  DAT_00241f18 = puVar6;\n  return;\n}\n\n",
  "validate_inherited_value": "\nbool validate_inherited_value(long param_1,int param_2)\n\n{\n  bool bVar1;\n  \n  if (param_2 != 4) {\n    bVar1 = true;\n    if (param_2 == 0x40) {\n      bVar1 = (*(byte *)(param_1 + 0x28) & 4) == 0;\n    }\n    return bVar1;\n  }\n  return (*(byte *)(param_1 + 0x28) & 0x40) == 0;\n}\n\n",
  "unbind_array_element": "\nuint unbind_array_element(undefined8 *param_1,char *param_2,uint param_3)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  long lVar4;\n  char *pcVar5;\n  uint uVar6;\n  \n  uVar2 = this_command_name;\n  cVar1 = *param_2;\n  uVar6 = *(uint *)(param_1 + 5);\n  if ((cVar1 != '@' && cVar1 != '*') || (param_2[1] != '\\0')) {\nLAB_0018c636:\n    if ((uVar6 & 0x40) == 0) {\n      if ((uVar6 & 4) == 0) {\n        sVar3 = strlen(param_2);\n        lVar4 = array_expand_index(param_1,param_2,(int)sVar3 + 1,0);\n        if (lVar4 == 0) {\n          this_command_name = uVar2;\n          unbind_variable(*param_1);\n          return 0;\n        }\n        goto LAB_0018c81a;\n      }\n      if ((cVar1 == '@' || cVar1 == '*') && (param_2[1] == '\\0')) {\n        if (0x33 < shell_compatibility_level) {\n          array_flush(param_1[1]);\n          return 0;\n        }\nLAB_0018c720:\n        unbind_variable(*param_1);\n        return 0;\n      }\n      sVar3 = strlen(param_2);\n      lVar4 = array_expand_index(param_1,param_2,(int)sVar3 + 1,0);\n      if ((lVar4 < 0) && (lVar4 + 1 + *(long *)param_1[1] < 0)) goto LAB_0018c6fd;\n      lVar4 = array_remove();\n      if (lVar4 != 0) {\n        array_dispose_element(lVar4);\n        return 0;\n      }\n    }\n    else if ((param_3 & 1) == 0) {\n      pcVar5 = (char *)expand_subscript_string(param_2,0);\n      if (pcVar5 == (char *)0x0) {\nLAB_0018c6fd:\n        builtin_error(\"[%s]: %s\",param_2,\"bad array subscript\");\n        return 0xffffffff;\n      }\n      if (*pcVar5 == '\\0') goto LAB_0018c7e3;\n      assoc_remove(param_1[1],pcVar5);\n      if (param_2 != pcVar5) {\n        sh_xfree(pcVar5,\"arrayfunc.c\",0x482);\n        return param_3 & 1;\n      }\n    }\n    else {\n      pcVar5 = param_2;\n      if (cVar1 == '\\0') {\nLAB_0018c7e3:\n        builtin_error(\"[%s]: %s\",param_2,\"bad array subscript\");\n        sh_xfree(pcVar5,\"arrayfunc.c\",0x47d);\n        return 0xffffffff;\n      }\n      assoc_remove(param_1[1],param_2);\n    }\n    uVar6 = 0;\n  }\n  else {\n    if ((uVar6 & 0x44) != 0) {\n      if ((param_3 & 4) != 0) goto LAB_0018c720;\n      goto LAB_0018c636;\n    }\nLAB_0018c81a:\n    uVar6 = 0xfffffffe;\n    this_command_name = uVar2;\n  }\n  return uVar6;\n}\n\n",
  "FUN_001523c0": "\nlong FUN_001523c0(long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = executing_line_number();\n  uVar2 = itos((long)iVar1);\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x527);\n  }\n  *(undefined8 *)(param_1 + 8) = uVar2;\n  return param_1;\n}\n\n",
  "memchr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memchr_00237ab8)();\n  return pvVar1;\n}\n\n",
  "read_tty_modified": "\nundefined4 read_tty_modified(void)\n\n{\n  return DAT_00248c04;\n}\n\n",
  "rl_tty_unset_default_bindings": "\nvoid rl_tty_unset_default_bindings(long param_1)\n\n{\n  char *pcVar1;\n  \n  if ((rl_readline_state._2_1_ & 4) != 0) {\n    if ((DAT_0024a583 != 0) &&\n       (pcVar1 = (char *)((ulong)DAT_0024a583 * 0x10 + param_1), *pcVar1 == '\\0')) {\n      *(code **)(pcVar1 + 8) = rl_insert;\n    }\n    if ((DAT_0024a585 != 0) &&\n       (pcVar1 = (char *)((ulong)DAT_0024a585 * 0x10 + param_1), *pcVar1 == '\\0')) {\n      *(code **)(pcVar1 + 8) = rl_insert;\n    }\n    if ((DAT_0024a58d != 0) &&\n       (pcVar1 = (char *)((ulong)DAT_0024a58d * 0x10 + param_1), *pcVar1 == '\\0')) {\n      *(code **)(pcVar1 + 8) = rl_insert;\n    }\n    if ((DAT_0024a584 != 0) &&\n       (pcVar1 = (char *)(param_1 + (ulong)DAT_0024a584 * 0x10), *pcVar1 == '\\0')) {\n      *(code **)(pcVar1 + 8) = rl_insert;\n    }\n  }\n  return;\n}\n\n",
  "FUN_00133b40": "\nvoid FUN_00133b40(char *param_1)\n\n{\n  char *pcVar1;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    pcVar1 = (char *)expand_string_unsplit_to_string(param_1,1);\n    if (pcVar1 != (char *)0x0) {\n      if (*pcVar1 != '\\0') {\n        maybe_execute_file(pcVar1,1);\n      }\n      sh_xfree(pcVar1,\"shell.c\",0x45f);\n      return;\n    }\n    return;\n  }\n  return;\n}\n\n",
  "_rl_isearch_dispatch": "\nundefined8 _rl_isearch_dispatch(long param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (-1 < param_2) {\n    uVar1 = FUN_001df160();\n    return uVar1;\n  }\n  *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 4;\n  *(undefined4 *)(param_1 + 0x60) = *(undefined4 *)(param_1 + 0x3c);\n  return 0xffffffff;\n}\n\n",
  "clear_dollar_vars": "\nvoid clear_dollar_vars(void)\n\n{\n  long *plVar1;\n  \n  plVar1 = &DAT_00242228;\n  do {\n    if (*plVar1 != 0) {\n      sh_xfree(*plVar1,\"variables.c\",0x15e2);\n    }\n    *plVar1 = 0;\n    plVar1 = plVar1 + 1;\n  } while (plVar1 != (long *)&tempenv_assign_error);\n  dispose_words(rest_of_args);\n  rest_of_args = 0;\n  posparam_count = 0;\n  return;\n}\n\n",
  "builtin_address": "\nundefined8 builtin_address(undefined8 param_1)\n\n{\n  current_builtin = builtin_address_internal(param_1,1);\n  if (current_builtin != 0) {\n    return *(undefined8 *)(current_builtin + 8);\n  }\n  return 0;\n}\n\n",
  "alias_expand_word": "\nchar * alias_expand_word(undefined8 param_1)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *__dest;\n  char *pcVar3;\n  \n  if (aliases == 0) {\n    return (char *)0x0;\n  }\n  lVar1 = hash_search(param_1,aliases,0);\n  if ((lVar1 != 0) && (*(long *)(lVar1 + 0x10) != 0)) {\n    pcVar3 = *(char **)(*(long *)(lVar1 + 0x10) + 8);\n    sVar2 = strlen(pcVar3);\n    __dest = (char *)sh_xmalloc(sVar2 + 1,\"alias.c\",0x122);\n    pcVar3 = strcpy(__dest,pcVar3);\n    return pcVar3;\n  }\n  return (char *)0x0;\n}\n\n",
  "mremap": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * mremap(void *__addr,size_t __old_len,size_t __new_len,int __flags,...)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_mremap_00237c60)();\n  return pvVar1;\n}\n\n",
  "__fpurge": "\nvoid __fpurge(void)\n\n{\n  (*(code *)PTR___fpurge_00237948)();\n  return;\n}\n\n",
  "end_job_control": "\nvoid end_job_control(void)\n\n{\n  int iVar1;\n  \n  if (job_control != 0) {\n    terminate_stopped_jobs();\n  }\n  if (-1 < original_pgrp) {\n    iVar1 = terminal_pgrp;\n    if (original_pgrp != terminal_pgrp) {\n      give_terminal_to(original_pgrp,1);\n      iVar1 = original_pgrp;\n      if (original_pgrp < 0) {\n        return;\n      }\n    }\n    iVar1 = setpgid(0,iVar1);\n    if (iVar1 == 0) {\n      shell_pgrp = original_pgrp;\n    }\n  }\n  return;\n}\n\n",
  "dlclose": "\nvoid dlclose(void)\n\n{\n  (*(code *)PTR_dlclose_00237e78)();\n  return;\n}\n\n",
  "FUN_0014ab30": "\nundefined8\nFUN_0014ab30(long param_1,long param_2,char *param_3,uint param_4,uint param_5,int param_6,\n            int *param_7,uint param_8)\n\n{\n  int iVar1;\n  long lVar2;\n  size_t sVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  byte bVar6;\n  undefined4 uVar7;\n  long lVar8;\n  \n  uVar5 = **(undefined8 **)(param_1 + 8);\n  bVar6 = (param_4 & param_5) == 0xffffffff & (byte)(param_8 >> 6);\n  if ((restricted != 0) && (lVar2 = mbschr(uVar5,0x2f), lVar2 != 0)) {\n    internal_error(\"%s: restricted: cannot specify `/\\' in command names\",uVar5);\n    last_command_exit_value = 1;\n    if (bVar6 != 0) {\n                    /* WARNING: Subroutine does not return */\n      exit(1);\n    }\n    uVar5 = 1;\n    lVar2 = 0;\njoined_r0x0014adc9:\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      throw_to_top_level();\n    }\n    if (-1 < (int)param_4) {\n      close(param_4);\n    }\n    if (-1 < (int)param_5) {\n      close(param_5);\n    }\n    if (lVar2 != 0) {\n      sh_xfree(lVar2,\"execute_cmd.c\",0x1684);\n    }\n    return uVar5;\n  }\n  lVar2 = search_for_command(uVar5,(-(uint)((param_8 & 0x4000) == 0) & 0xfffffffe) + 3);\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n  }\n  if (lVar2 != 0) {\n    if ((bVar6 != 0) && ((subshell_environment & 0x10) == 0)) {\n      adjust_shell_level(0xffffffff);\n    }\n    maybe_make_export_env();\n    put_command_name_into_env(lVar2);\n  }\n  if (bVar6 == 0) {\n    sVar3 = strlen(param_3);\n    pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"execute_cmd.c\",0x1614);\n    pcVar4 = strcpy(pcVar4,param_3);\n    iVar1 = make_child(pcVar4,param_6 != 0);\n    if (iVar1 != 0) {\n      uVar5 = 0;\n      goto joined_r0x0014adc9;\n    }\n    reset_terminating_signals();\n    restore_original_signals();\n    subshell_environment = subshell_environment & 0xfffffeff;\n    sh_xfree(pcVar4,\"execute_cmd.c\",0x1621);\n  }\n  else {\n    reset_terminating_signals();\n    restore_original_signals();\n    subshell_environment = subshell_environment & 0xfffffeff;\n  }\n  if (param_6 == 0) {\n    if ((param_7 != (int *)0x0) && (0 < *param_7)) goto LAB_0014acae;\n    FUN_001497c0(param_4,param_5);\nLAB_0014ae20:\n    subshell_environment = subshell_environment | 8;\n    uVar7 = interactive;\n    if (param_2 == 0) goto LAB_0014ae54;\nLAB_0014ae2f:\n    iVar1 = do_redirections(param_2,1);\n    if (iVar1 != 0) {\n      unlink_all_fifos();\n                    /* WARNING: Subroutine does not return */\n      exit(1);\n    }\n    if (param_6 == 0) goto LAB_0014ae54;\n  }\n  else {\n    if ((((param_8 & 0x400) != 0) && (param_4 == 0xffffffff)) &&\n       (iVar1 = stdin_redirects(param_2), iVar1 == 0)) {\n      async_redirect_stdin();\n    }\n    if (job_control == 0) {\n      get_original_signal(2);\n      set_signal_handler(2,1);\n      get_original_signal(3);\n      set_signal_handler(3,1);\n    }\n    if ((param_7 == (int *)0x0) || (*param_7 < 1)) {\n      FUN_001497c0(param_4,param_5);\n      uVar7 = interactive;\n    }\n    else {\nLAB_0014acae:\n      lVar8 = 0;\n      do {\n        while (*(char *)(*(long *)(param_7 + 2) + lVar8) == '\\0') {\n          lVar8 = lVar8 + 1;\n          if (*param_7 == (int)lVar8 || *param_7 < (int)lVar8) goto LAB_0014ace6;\n        }\n        close((int)lVar8);\n        *(undefined *)(*(long *)(param_7 + 2) + lVar8) = 0;\n        lVar8 = lVar8 + 1;\n      } while (*param_7 != (int)lVar8 && (int)lVar8 <= *param_7);\nLAB_0014ace6:\n      FUN_001497c0(param_4,param_5);\n      uVar7 = interactive;\n      if (param_6 == 0) goto LAB_0014ae20;\n    }\n    subshell_environment = subshell_environment | 8;\n    interactive = 0;\n    if (param_2 != 0) goto LAB_0014ae2f;\n  }\n  interactive = uVar7;\nLAB_0014ae54:\n  if (lVar2 != 0) {\n    uVar5 = strvec_from_word_list(param_1,0,0,0);\n    iVar1 = shell_execve(lVar2,uVar5,export_env);\n                    /* WARNING: Subroutine does not return */\n    exit(iVar1);\n  }\n  lVar2 = find_function(\"command_not_found_handle\");\n  if (lVar2 == 0) {\n    uVar5 = printable_filename(uVar5,0);\n    internal_error(\"%s: command not found\",uVar5);\n                    /* WARNING: Subroutine does not return */\n    exit(0x7f);\n  }\n  without_job_control();\n  set_sigchld_handler();\n  uVar5 = make_word(\"command_not_found_handle\");\n  uVar5 = make_word_list(uVar5,param_1);\n  iVar1 = execute_shell_function(lVar2,uVar5);\n                    /* WARNING: Subroutine does not return */\n  exit(iVar1);\n}\n\n",
  "FUN_001ec8e0": "\nvoid FUN_001ec8e0(undefined *param_1)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = _rl_keymap;\n  _rl_keymap = param_1;\n  rl_bind_keyseq_if_unbound(DAT_0024b630,rl_get_previous_history);\n  rl_bind_keyseq_if_unbound(DAT_0024b628,rl_get_next_history);\n  rl_bind_keyseq_if_unbound(DAT_0024b620,rl_forward_char);\n  rl_bind_keyseq_if_unbound(DAT_0024b618,rl_backward_char);\n  rl_bind_keyseq_if_unbound(DAT_0024b600,rl_beg_of_line);\n  rl_bind_keyseq_if_unbound(DAT_0024b5f0,rl_end_of_line);\n  rl_bind_keyseq_if_unbound(DAT_0024b5e8,rl_delete);\n  rl_bind_keyseq_if_unbound(DAT_0024b5e0,rl_overwrite_mode);\n  rl_bind_keyseq_if_unbound(DAT_0024b5d0,rl_history_search_forward);\n  rl_bind_keyseq_if_unbound(DAT_0024b5d8,rl_history_search_backward);\n  _rl_keymap = puVar1;\n  return;\n}\n\n",
  "coproc_unsetvars": "\nvoid coproc_unsetvars(char **param_1)\n\n{\n  size_t sVar1;\n  undefined8 uVar2;\n  \n  if (*param_1 != (char *)0x0) {\n    sVar1 = strlen(*param_1);\n    uVar2 = sh_xmalloc((long)((int)sVar1 + 0x10),\"execute_cmd.c\",0x937);\n    __sprintf_chk(uVar2,1,0xffffffffffffffff,\"%s_PID\",*param_1);\n    unbind_variable_noref(uVar2);\n    check_unbind_variable(*param_1);\n    sh_xfree(uVar2,\"execute_cmd.c\",0x945);\n    return;\n  }\n  return;\n}\n\n",
  "rl_discard_argument": "\nundefined8 rl_discard_argument(void)\n\n{\n  rl_ding();\n  rl_clear_message();\n  rl_arg_sign = 1;\n  rl_numeric_arg = 1;\n  rl_explicit_arg = 0;\n  _rl_argcxt = 0;\n  return 0;\n}\n\n",
  "indirection_level_string": "\nchar * indirection_level_string(void)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  char *pcVar5;\n  size_t sVar6;\n  size_t sVar7;\n  char *pcVar8;\n  char *pcVar9;\n  int iVar10;\n  long in_FS_OFFSET;\n  char local_58;\n  undefined local_57;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar4 = (char *)get_string_value(&DAT_001fc70b);\n  if (DAT_00241f08 == (char *)0x0) {\n    DAT_00241f00 = 100;\n    DAT_00241f08 = (char *)sh_xmalloc(100,\"print_cmd.c\",0x1c9);\n  }\n  pcVar5 = DAT_00241f08;\n  *DAT_00241f08 = '\\0';\n  if ((pcVar4 != (char *)0x0) && (*pcVar4 != '\\0')) {\n    iVar2 = change_flag(0x78,0x2b);\n    pcVar4 = (char *)decode_prompt_string(pcVar4);\n    if (iVar2 != 0) {\n      change_flag(0x78,0x2d);\n    }\n    pcVar5 = DAT_00241f08;\n    if (pcVar4 != (char *)0x0) {\n      if (*pcVar4 == '\\0') {\n        sh_xfree(pcVar4,\"print_cmd.c\",0x1d6);\n        pcVar5 = DAT_00241f08;\n      }\n      else {\n        sVar6 = __ctype_get_mb_cur_max();\n        sVar6 = strnlen(pcVar4,sVar6);\n        sVar7 = __ctype_get_mb_cur_max();\n        if ((sVar7 < 2) || (iVar2 = mblen(pcVar4,(long)(int)sVar6), iVar2 < 2)) {\n          local_58 = *pcVar4;\n          local_57 = 0;\n          iVar2 = 1;\n        }\n        else {\n          __memcpy_chk(&local_58,pcVar4,(long)iVar2,0x11);\n        }\n        cVar1 = local_58;\n        sVar6 = strlen(pcVar4);\n        iVar3 = indirection_level * iVar2 + (int)sVar6;\n        if (DAT_00241f00 <= iVar3) {\n          DAT_00241f00 = iVar3 + 1;\n          DAT_00241f08 = (char *)sh_xrealloc(DAT_00241f08,(long)DAT_00241f00,\"print_cmd.c\",0x1ef);\n        }\n        pcVar5 = DAT_00241f08;\n        pcVar8 = DAT_00241f08;\n        if (cVar1 == '\\0') {\n          iVar3 = 0;\n        }\n        else {\n          iVar10 = 0;\n          for (iVar3 = 0; (iVar10 < indirection_level && (iVar3 < DAT_00241f00 + -1));\n              iVar3 = iVar3 + iVar2) {\n            if (iVar2 == 1) {\n              *pcVar8 = cVar1;\n            }\n            else {\n              pcVar8 = (char *)memcpy(pcVar8,&local_58,(long)iVar2);\n            }\n            iVar10 = iVar10 + 1;\n            pcVar8 = pcVar8 + iVar2;\n          }\n        }\n        if (*pcVar4 != '\\0') {\n          pcVar9 = pcVar4 + iVar2;\n          iVar2 = DAT_00241f00 + -1;\n          pcVar8 = pcVar5 + iVar3;\n          do {\n            if ((*pcVar9 == '\\0') || (iVar2 <= iVar3)) goto LAB_001457b3;\n            *pcVar8 = *pcVar9;\n            iVar3 = iVar3 + 1;\n            pcVar8 = pcVar8 + 1;\n            pcVar9 = pcVar9 + 1;\n          } while (*pcVar4 != '\\0');\n          pcVar8 = pcVar5 + iVar3;\n        }\nLAB_001457b3:\n        *pcVar8 = '\\0';\n        sh_xfree(pcVar4,\"print_cmd.c\",0x1fe);\n        pcVar5 = DAT_00241f08;\n      }\n    }\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar5;\n}\n\n",
  "pipe": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint pipe(int *__pipedes)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_pipe_00237a90)();\n  return iVar1;\n}\n\n",
  "strsignal": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strsignal(int __sig)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strsignal_00237c80)();\n  return pcVar1;\n}\n\n",
  "FUN_001336b0": "\nvoid FUN_001336b0(FILE *param_1,int param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  undefined **ppuVar7;\n  undefined *puVar8;\n  \n  if (param_2 != 0) {\n    uVar5 = shell_version_string();\n    __fprintf_chk(param_1,1,\"GNU bash, version %s-(%s)\\n\",uVar5,\"x86_64-pc-linux-gnu\");\n  }\n  ppuVar7 = &PTR_s_debugger_00235d80;\n  __fprintf_chk(param_1,1,\n                \"Usage:\\t%s [GNU long option] [option] ...\\n\\t%s [GNU long option] [option] script-file ...\\n\"\n                ,shell_name,shell_name);\n  fwrite(\"GNU long options:\\n\",1,0x12,param_1);\n  pcVar6 = \"debug\";\n  do {\n    __fprintf_chk(param_1,1,\"\\t--%s\\n\",pcVar6);\n    pcVar6 = *ppuVar7;\n    ppuVar7 = ppuVar7 + 4;\n  } while (pcVar6 != (char *)0x0);\n  fwrite(\"Shell options:\\n\",1,0xf,param_1);\n  fwrite(\"\\t-ilrsD or -c command or -O shopt_option\\t\\t(invocation only)\\n\",1,0x3c,param_1);\n  pcVar6 = *(char **)shell_builtins;\n  puVar8 = shell_builtins;\n  while( true ) {\n    if (pcVar6 == (char *)0x0) goto LAB_00133849;\n    if ((*pcVar6 == 's') && (iVar1 = strcmp(pcVar6,\"set\"), iVar1 == 0)) break;\n    pcVar6 = *(char **)(puVar8 + 0x30);\n    puVar8 = puVar8 + 0x30;\n  }\n  pcVar6 = *(char **)(puVar8 + 0x20);\n  sVar2 = strlen(pcVar6);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"shell.c\",0x821);\n  pcVar3 = strcpy(pcVar3,pcVar6);\n  pcVar6 = strchr(pcVar3,0x5b);\n  if (pcVar6 == (char *)0x0) {\n    pcVar6 = pcVar3;\n  }\n  do {\n    pcVar6 = pcVar6 + 1;\n  } while (*pcVar6 == '-');\n  pcVar4 = strchr(pcVar6,0x5d);\n  if (pcVar4 != (char *)0x0) {\n    *pcVar4 = '\\0';\n  }\n  __fprintf_chk(param_1,1,\"\\t-%s or -o option\\n\",pcVar6);\n  sh_xfree(pcVar3,\"shell.c\",0x830);\nLAB_00133849:\n  if (param_2 == 0) {\n    return;\n  }\n  __fprintf_chk(param_1,1,\"Type `%s -c \\\"help set\\\"\\' for more information about shell options.\\n\",\n                shell_name);\n  __fprintf_chk(param_1,1,\"Type `%s -c help\\' for more information about shell builtin commands.\\n\",\n                shell_name);\n  fwrite(\"Use the `bashbug\\' command to report bugs.\\n\",1,0x2a,param_1);\n  fputc(10,param_1);\n  fwrite(\"bash home page: <http://www.gnu.org/software/bash>\\n\",1,0x33,param_1);\n  fwrite(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\",1,0x3f,param_1);\n  return;\n}\n\n",
  "next_pending_trap": "\nulong next_pending_trap(int param_1)\n\n{\n  ulong uVar1;\n  \n  if (param_1 < 0x41) {\n    uVar1 = (ulong)param_1;\n    do {\n      if (*(int *)(pending_traps + uVar1 * 4) != 0) {\n        return uVar1 & 0xffffffff;\n      }\n      uVar1 = uVar1 + 1;\n    } while ((int)uVar1 < 0x41);\n  }\n  return 0xffffffff;\n}\n\n",
  "run_return_trap": "\nvoid run_return_trap(void)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = last_command_exit_value;\n  if ((DAT_00247f4c & 0x51) != 1) {\n    return;\n  }\n  FUN_001811f0(0x43,\"return trap\");\n  last_command_exit_value = uVar1;\n  return;\n}\n\n",
  "check_bash_input": "\nint check_bash_input(undefined8 param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar1 = (int)param_1;\n  if ((bash_input != 4) || (iVar1 != (int)DAT_00240a70)) {\n    if (interactive_shell != 0) {\n      return 0;\n    }\n    if (iVar1 != default_buffered_input) {\n      return interactive_shell;\n    }\n  }\n  if (iVar1 < 1) {\n    iVar2 = 0;\n    if (iVar1 == 0) {\n      iVar1 = sync_buffered_stream(0);\n      iVar2 = -(uint)(iVar1 == -1);\n    }\n    return iVar2;\n  }\n  iVar1 = save_bash_input(param_1,0xffffffff);\n  return -(uint)(iVar1 == -1);\n}\n\n",
  "FUN_001bf860": "\nbyte * FUN_001bf860(long param_1,uint *param_2)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte *pbVar3;\n  int iVar4;\n  size_t __n;\n  byte *pbVar5;\n  undefined **ppuVar6;\n  uint uVar7;\n  \n  bVar1 = *(byte *)(param_1 + 1);\n  pbVar5 = (byte *)(param_1 + 1);\n  if (bVar1 != 0) {\n    uVar7 = (uint)bVar1;\n    __n = 0;\n    pbVar3 = (byte *)(param_1 + 2);\n    bVar2 = bVar1;\n    do {\n      pbVar5 = pbVar3;\n      if ((bVar2 == 0x2e) && (*pbVar5 == 0x5d)) {\n        ppuVar6 = &PTR_DAT_0023ad00;\n        pbVar5 = PTR_DAT_0023ad00;\n        if (PTR_DAT_0023ad00 == (undefined *)0x0) goto LAB_001bf908;\n        goto LAB_001bf8dd;\n      }\n      bVar2 = *pbVar5;\n      __n = __n + 1;\n      pbVar3 = pbVar5 + 1;\n    } while (bVar2 != 0);\n  }\n  uVar7 = 0xffffffff;\n  goto LAB_001bf91a;\n  while( true ) {\n    pbVar5 = ppuVar6[2];\n    ppuVar6 = ppuVar6 + 2;\n    if (pbVar5 == (byte *)0x0) break;\nLAB_001bf8dd:\n    if (((*pbVar5 == bVar1) &&\n        (iVar4 = strncmp((char *)pbVar5,(char *)(byte *)(param_1 + 1),__n), iVar4 == 0)) &&\n       (pbVar5[__n] == 0)) {\n      uVar7 = (uint)*(byte *)(ppuVar6 + 1);\n      goto LAB_001bf915;\n    }\n  }\nLAB_001bf908:\n  if ((int)__n != 1) {\n    uVar7 = 0xffffffff;\n  }\nLAB_001bf915:\n  pbVar5 = (byte *)(param_1 + 3 + __n);\nLAB_001bf91a:\n  *param_2 = uVar7;\n  return pbVar5;\n}\n\n",
  "_rl_to_lower": "\nuint _rl_to_lower(uint param_1)\n\n{\n  ushort **ppuVar1;\n  __int32_t **pp_Var2;\n  \n  ppuVar1 = __ctype_b_loc();\n  if ((*(byte *)((long)*ppuVar1 + (ulong)(param_1 & 0xff) * 2 + 1) & 1) != 0) {\n    pp_Var2 = __ctype_tolower_loc();\n    param_1 = (*pp_Var2)[param_1 & 0xff];\n  }\n  return param_1;\n}\n\n",
  "FUN_00146230": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00146230(undefined4 *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long **pplVar4;\n  uint uVar5;\n  int iVar6;\n  int *piVar7;\n  undefined *puVar8;\n  long lVar9;\n  long *plVar10;\n  long in_FS_OFFSET;\n  ushort local_43;\n  undefined local_41;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (undefined4 *)0x0) {\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      FUN_001446d0(&DAT_00213d70);\n      return;\n    }\n    goto LAB_00147098;\n  }\n  if (DAT_00241f2c == 0) {\n    FUN_001449a0(DAT_00241f34);\n  }\n  else {\n    DAT_00241f2c = DAT_00241f2c + -1;\n  }\n  uVar5 = param_1[1];\n  if ((uVar5 & 0x80) != 0) {\n    FUN_001446d0(\"time \");\n    uVar5 = param_1[1];\n    if ((uVar5 & 0x100) != 0) {\n      FUN_001446d0(&DAT_001fc76d);\n      uVar5 = param_1[1];\n    }\n  }\n  if ((uVar5 & 4) != 0) {\n    FUN_001446d0(&DAT_001fc61b);\n  }\n  switch(*param_1) {\n  case 0:\n    lVar9 = *(long *)(param_1 + 6);\n    FUN_001446d0(\"for %s in \",**(undefined8 **)(lVar9 + 8));\n    for (pplVar4 = *(long ***)(lVar9 + 0x10); pplVar4 != (long **)0x0; pplVar4 = (long **)*pplVar4)\n    {\n      puVar8 = &DAT_00213d70;\n      if (*pplVar4 != (long *)0x0) {\n        puVar8 = &DAT_001fdb1c;\n      }\n      FUN_001446d0(&DAT_001fc632,*pplVar4[1],puVar8);\n    }\n    goto LAB_001463c7;\n  case 1:\n    lVar9 = *(long *)(param_1 + 6);\n    FUN_001446d0(\"case %s in \",**(undefined8 **)(lVar9 + 8));\n    plVar10 = *(long **)(lVar9 + 0x10);\n    if (plVar10 != (long *)0x0) {\n      DAT_00241f34 = DAT_00241f34 + DAT_00238404;\n      do {\n        FUN_001446d0(&DAT_001ff6d2);\n        FUN_001449a0(DAT_00241f34);\n        for (pplVar4 = (long **)plVar10[1]; pplVar4 != (long **)0x0; pplVar4 = (long **)*pplVar4) {\n          puVar8 = &DAT_001fc763;\n          if (*pplVar4 == (long *)0x0) {\n            puVar8 = &DAT_00213d70;\n          }\n          FUN_001446d0(&DAT_001fc632,*pplVar4[1],puVar8);\n        }\n        FUN_001446d0(&DAT_00213e3e);\n        DAT_00241f34 = DAT_00241f34 + DAT_00238404;\n        FUN_00146230(plVar10[2]);\n        DAT_00241f34 = DAT_00241f34 - DAT_00238404;\n        if (DAT_00241f18 != 0) {\n          FUN_001452c0(&DAT_00213d70);\n        }\n        if ((*(uint *)(plVar10 + 3) & 1) == 0) {\n          if ((*(uint *)(plVar10 + 3) & 2) == 0) {\n            FUN_001446d0(&DAT_001ff6d2);\n            FUN_001449a0(DAT_00241f34);\n            FUN_001446d0(&DAT_002102da,&DAT_001fab1d);\n          }\n          else {\n            FUN_001446d0(&DAT_001ff6d2);\n            FUN_001449a0(DAT_00241f34);\n            FUN_001446d0(&DAT_002102da,&DAT_001fab20);\n          }\n        }\n        else {\n          FUN_001446d0(&DAT_001ff6d2);\n          FUN_001449a0(DAT_00241f34);\n          FUN_001446d0(&DAT_002102da,&DAT_001fab21);\n        }\n        plVar10 = (long *)*plVar10;\n      } while (plVar10 != (long *)0x0);\n      DAT_00241f34 = DAT_00241f34 - DAT_00238404;\n    }\n    FUN_001446d0(&DAT_001ff6d2);\n    FUN_001449a0(DAT_00241f34);\n    FUN_001446d0(&DAT_002102da,&DAT_001faac7);\n    break;\n  case 2:\n    FUN_00147180(*(undefined8 *)(param_1 + 6),\"while\");\n    break;\n  case 3:\n    lVar9 = *(long *)(param_1 + 6);\n    FUN_001446d0(&DAT_001fc778);\n    DAT_00241f2c = DAT_00241f2c + 1;\n    FUN_00146230(*(undefined8 *)(lVar9 + 8));\n    if ((command_string_index < 1) ||\n       ((cVar1 = *(char *)(the_printed_command + -1 + (long)command_string_index), cVar1 != '&' &&\n        (cVar1 != '\\n')))) {\n      FUN_001446d0(&DAT_001fab1e);\n    }\n    FUN_001446d0(\" then\\n\");\n    DAT_00241f34 = DAT_00241f34 + DAT_00238404;\n    FUN_00146230(*(undefined8 *)(lVar9 + 0x10));\n    if (DAT_00241f18 != 0) {\n      FUN_001452c0(&DAT_00213d70);\n    }\n    DAT_00241f34 = DAT_00241f34 - DAT_00238404;\n    if (*(long *)(lVar9 + 0x18) != 0) {\n      if ((command_string_index < 1) ||\n         ((cVar1 = *(char *)(the_printed_command + -1 + (long)command_string_index), cVar1 != '&' &&\n          (cVar1 != '\\n')))) {\n        FUN_001446d0(&DAT_001fab1e);\n      }\n      FUN_001446d0(&DAT_001ff6d2);\n      FUN_001449a0(DAT_00241f34);\n      FUN_001446d0(&DAT_002102da,\"else\\n\");\n      DAT_00241f34 = DAT_00241f34 + DAT_00238404;\n      FUN_00146230(*(undefined8 *)(lVar9 + 0x18));\n      if (DAT_00241f18 != 0) {\n        FUN_001452c0(&DAT_00213d70);\n      }\n      DAT_00241f34 = DAT_00241f34 - DAT_00238404;\n    }\n    if ((command_string_index < 1) ||\n       ((cVar1 = *(char *)(the_printed_command + -1 + (long)command_string_index), cVar1 != '&' &&\n        (cVar1 != '\\n')))) {\n      FUN_001446d0(&DAT_001fab1e);\n    }\n    FUN_001446d0(&DAT_001ff6d2);\n    FUN_001449a0(DAT_00241f34);\n    FUN_001446d0(&DAT_002102da,&DAT_001fab45);\n    break;\n  case 4:\n    print_simple_command(*(undefined8 *)(param_1 + 6));\n    break;\n  case 5:\n    lVar9 = *(long *)(param_1 + 6);\n    FUN_001446d0(\"select %s in \",**(undefined8 **)(lVar9 + 8));\n    for (pplVar4 = *(long ***)(lVar9 + 0x10); pplVar4 != (long **)0x0; pplVar4 = (long **)*pplVar4)\n    {\n      puVar8 = &DAT_00213d70;\n      if (*pplVar4 != (long *)0x0) {\n        puVar8 = &DAT_001fdb1c;\n      }\n      FUN_001446d0(&DAT_001fc632,*pplVar4[1],puVar8);\n    }\nLAB_001463c7:\n    FUN_001446d0(&DAT_001fab1e);\n    FUN_001446d0(&DAT_001ff6d2);\n    FUN_001449a0(DAT_00241f34);\n    FUN_001446d0(&DAT_002102da,&DAT_001fc7be);\n    DAT_00241f34 = DAT_00241f34 + DAT_00238404;\n    FUN_00146230(*(undefined8 *)(lVar9 + 0x18));\n    if (DAT_00241f18 != 0) {\n      FUN_001452c0(&DAT_00213d70);\n    }\n    if ((command_string_index < 1) ||\n       ((cVar1 = *(char *)(the_printed_command + -1 + (long)command_string_index), cVar1 != '&' &&\n        (cVar1 != '\\n')))) {\n      FUN_001446d0(&DAT_001fab1e);\n    }\nLAB_00146465:\n    DAT_00241f34 = DAT_00241f34 - DAT_00238404;\n    FUN_001446d0(&DAT_001ff6d2);\n    FUN_001449a0(DAT_00241f34);\n    FUN_001446d0(&DAT_002102da,&DAT_001fab5f);\n    break;\n  case 6:\n    DAT_00241f2c = DAT_00241f2c + 1;\n    DAT_00241f24 = DAT_00241f24 + 1;\n    FUN_00146230(*(undefined8 *)(*(long *)(param_1 + 6) + 8));\n    iVar2 = *(int *)(*(long *)(param_1 + 6) + 0x18);\n    if (iVar2 == 0x120) {\n      puVar8 = &DAT_001fc621;\nLAB_00146dd3:\n      FUN_001452c0(puVar8);\n      lVar9 = *(long *)(*(long *)(param_1 + 6) + 0x10);\n      if (lVar9 != 0) {\nLAB_00146de9:\n        DAT_00241f2c = DAT_00241f2c + 1;\n      }\n    }\n    else {\n      if (0x120 < iVar2) {\n        puVar8 = &DAT_001fc626;\n        if (iVar2 != 0x121) goto LAB_00146ed8;\n        goto LAB_00146dd3;\n      }\n      if (iVar2 == 0x3b) {\nLAB_00146e58:\n        iVar6 = 0x3b;\n        if (DAT_00241f20 != 0) {\n          iVar6 = iVar2;\n        }\n        local_43 = (ushort)(byte)iVar6;\n        if (DAT_00241f18 == 0) {\n          if (DAT_00241f28 == 0) {\n            FUN_001446d0(&DAT_002102da,&local_43);\n          }\n          else {\n            DAT_00241f28 = 0;\n          }\n        }\n        else {\n          puVar8 = &DAT_00213d70;\n          if (DAT_00241f30 == 0) {\n            puVar8 = &DAT_001fab1e;\n          }\n          FUN_001452c0(puVar8);\n        }\n        if (DAT_00241f30 != 0) {\n          FUN_001446d0(&DAT_001ff6d2);\n          lVar9 = *(long *)(*(long *)(param_1 + 6) + 0x10);\n          goto LAB_00146bd8;\n        }\n        if (iVar2 == 0x3b) {\n          FUN_001446d0(&DAT_001fdb1c);\n        }\n        lVar9 = *(long *)(*(long *)(param_1 + 6) + 0x10);\n        if (lVar9 == 0) goto LAB_00146bd8;\n        goto LAB_00146de9;\n      }\n      if (iVar2 < 0x3c) {\n        if (iVar2 == 10) goto LAB_00146e58;\n        if (iVar2 != 0x26) goto LAB_00146ed8;\n        local_41 = 0;\n        local_43 = 0x2620;\n        FUN_001452c0(&local_43);\n        if (*(long *)(*(long *)(param_1 + 6) + 0x10) != 0) goto LAB_00146bb5;\n        lVar9 = 0;\n      }\n      else if (iVar2 == 0x7c) {\n        local_41 = 0;\n        local_43 = 0x7c20;\n        FUN_001452c0(&local_43);\nLAB_00146bb5:\n        FUN_001446d0(&DAT_001fdb1c);\n        DAT_00241f2c = DAT_00241f2c + 1;\n        lVar9 = *(long *)(*(long *)(param_1 + 6) + 0x10);\n      }\n      else {\nLAB_00146ed8:\n        FUN_001446d0(\"print_command: bad connector `%d\\'\",iVar2);\n        lVar9 = *(long *)(*(long *)(param_1 + 6) + 0x10);\n      }\n    }\nLAB_00146bd8:\n    FUN_00146230(lVar9);\n    if (DAT_00241f18 != 0) {\n      FUN_001452c0(&DAT_00213d70);\n    }\n    DAT_00241f24 = DAT_00241f24 + -1;\n    break;\n  case 7:\n    lVar9 = *(long *)(param_1 + 6);\n    uVar3 = **(undefined8 **)(lVar9 + 8);\n    if (posixly_correct == 0) {\n      FUN_001446d0(\"function %s () \\n\",uVar3);\n    }\n    else {\n      FUN_001446d0(\"%s () \\n\",uVar3);\n    }\n    add_unwind_protect(FUN_00144520,0);\n    FUN_001449a0(DAT_00241f34);\n    FUN_001446d0(&DAT_001fc79a);\n    DAT_00241f30 = DAT_00241f30 + 1;\n    DAT_00241f34 = DAT_00241f34 + DAT_00238404;\n    piVar7 = (int *)copy_command(*(undefined8 *)(lVar9 + 0x10));\n    if (*piVar7 == 9) {\n      lVar9 = *(long *)(piVar7 + 4);\n      *(undefined8 *)(piVar7 + 4) = 0;\n      FUN_00146230(*(undefined8 *)(*(long *)(piVar7 + 6) + 8));\n      if (DAT_00241f18 != 0) goto LAB_00146d01;\nLAB_00146d0d:\n      remove_unwind_protect();\n      DAT_00241f30 = DAT_00241f30 + -1;\n      DAT_00241f34 = DAT_00241f34 - DAT_00238404;\n      if (lVar9 == 0) goto LAB_00147004;\n      FUN_001446d0(&DAT_001ff6d2);\n      FUN_001449a0(DAT_00241f34);\n      FUN_001446d0(&DAT_002102da,&DAT_001fc79e);\n      FUN_00144c70(lVar9);\n      *(long *)(piVar7 + 4) = lVar9;\n    }\n    else {\n      lVar9 = 0;\n      FUN_00146230(piVar7);\n      if (DAT_00241f18 != 0) {\nLAB_00146d01:\n        FUN_001452c0(&DAT_00213d70);\n        goto LAB_00146d0d;\n      }\n      remove_unwind_protect();\n      DAT_00241f30 = DAT_00241f30 + -1;\n      DAT_00241f34 = DAT_00241f34 - DAT_00238404;\nLAB_00147004:\n      FUN_001446d0(&DAT_001ff6d2);\n      FUN_001449a0(DAT_00241f34);\n      FUN_001446d0(&DAT_002102da,&DAT_0020ef45);\n    }\n    dispose_command(piVar7);\n    break;\n  case 8:\n    FUN_00147180(*(undefined8 *)(param_1 + 6),\"until\");\n    break;\n  case 9:\n    _DAT_00241f10 = _DAT_00241f10 + 1;\n    lVar9 = *(long *)(param_1 + 6);\n    FUN_001446d0(&DAT_001fc7a1);\n    if (DAT_00241f30 == 0) {\n      DAT_00241f2c = DAT_00241f2c + 1;\n    }\n    else {\n      FUN_001446d0(&DAT_001ff6d2);\n      DAT_00241f34 = DAT_00241f34 + DAT_00238404;\n    }\n    FUN_00146230(*(undefined8 *)(lVar9 + 8));\n    if (DAT_00241f18 != 0) {\n      FUN_001452c0(&DAT_00213d70);\n    }\n    if (DAT_00241f30 == 0) {\n      if ((command_string_index < 1) ||\n         ((cVar1 = *(char *)(the_printed_command + -1 + (long)command_string_index), cVar1 != '&' &&\n          (cVar1 != '\\n')))) {\n        FUN_001446d0(&DAT_001fab1e);\n      }\n      FUN_001446d0(&DAT_001fdb1c);\n    }\n    else {\n      FUN_001446d0(&DAT_001ff6d2);\n      DAT_00241f34 = DAT_00241f34 - DAT_00238404;\n      FUN_001449a0();\n    }\n    FUN_001446d0(&DAT_0020ef45);\n    _DAT_00241f10 = _DAT_00241f10 + -1;\n    break;\n  case 10:\n    pplVar4 = *(long ***)(*(long *)(param_1 + 6) + 8);\n    FUN_001446d0(&DAT_001fc775);\n    for (; pplVar4 != (long **)0x0; pplVar4 = (long **)*pplVar4) {\n      puVar8 = &DAT_00213d70;\n      if (*pplVar4 != (long *)0x0) {\n        puVar8 = &DAT_001fdb1c;\n      }\n      FUN_001446d0(&DAT_001fc632,*pplVar4[1],puVar8);\n    }\n    FUN_001446d0(&DAT_0020ef6c);\n    break;\n  case 0xb:\n    uVar3 = *(undefined8 *)(param_1 + 6);\n    FUN_001446d0(&DAT_001fc74e);\n    FUN_00144a20(uVar3);\n    FUN_001446d0(&DAT_0020ef86);\n    break;\n  case 0xc:\n    lVar9 = *(long *)(param_1 + 6);\n    FUN_001446d0(&DAT_001fc771);\n    for (pplVar4 = *(long ***)(lVar9 + 8); pplVar4 != (long **)0x0; pplVar4 = (long **)*pplVar4) {\n      puVar8 = &DAT_00213d70;\n      if (*pplVar4 != (long *)0x0) {\n        puVar8 = &DAT_001fdb1c;\n      }\n      FUN_001446d0(&DAT_001fc632,*pplVar4[1],puVar8);\n    }\n    FUN_001446d0(&DAT_001faa24);\n    for (pplVar4 = *(long ***)(lVar9 + 0x10); pplVar4 != (long **)0x0; pplVar4 = (long **)*pplVar4)\n    {\n      puVar8 = &DAT_00213d70;\n      if (*pplVar4 != (long *)0x0) {\n        puVar8 = &DAT_001fdb1c;\n      }\n      FUN_001446d0(&DAT_001fc632,*pplVar4[1],puVar8);\n    }\n    FUN_001446d0(&DAT_001faa24);\n    for (pplVar4 = *(long ***)(lVar9 + 0x18); pplVar4 != (long **)0x0; pplVar4 = (long **)*pplVar4)\n    {\n      puVar8 = &DAT_00213d70;\n      if (*pplVar4 != (long *)0x0) {\n        puVar8 = &DAT_001fdb1c;\n      }\n      FUN_001446d0(&DAT_001fc632,*pplVar4[1],puVar8);\n    }\n    FUN_001446d0(&DAT_0020ef6c);\n    FUN_001446d0(&DAT_001ff6d2);\n    FUN_001449a0(DAT_00241f34);\n    FUN_001446d0(&DAT_002102da,&DAT_001fc7be);\n    DAT_00241f34 = DAT_00241f34 + DAT_00238404;\n    FUN_00146230(*(undefined8 *)(lVar9 + 0x20));\n    if (DAT_00241f18 != 0) {\n      FUN_001452c0(&DAT_00213d70);\n    }\n    if ((command_string_index < 1) ||\n       ((cVar1 = *(char *)(the_printed_command + -1 + (long)command_string_index), cVar1 != '&' &&\n        (cVar1 != '\\n')))) {\n      FUN_001446d0(&DAT_001fab1e);\n    }\n    goto LAB_00146465;\n  case 0xd:\n    FUN_001446d0(&DAT_001fc75b);\n    DAT_00241f2c = DAT_00241f2c + 1;\n    FUN_00146230(*(undefined8 *)(*(long *)(param_1 + 6) + 8));\n    if (DAT_00241f18 != 0) {\n      FUN_001452c0(&DAT_00213d70);\n    }\n    FUN_001446d0(&DAT_001fc61e);\n    break;\n  case 0xe:\n    FUN_001446d0(\"coproc %s \",*(undefined8 *)(*(long *)(param_1 + 6) + 8));\n    DAT_00241f2c = DAT_00241f2c + 1;\n    FUN_00146230(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10));\n    break;\n  default:\n    command_error(\"print_command\",1,*param_1,0);\n  }\n  if (*(long *)(param_1 + 4) != 0) {\n    FUN_001446d0(&DAT_001fdb1c);\n    FUN_00144c70(*(undefined8 *)(param_1 + 4));\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\nLAB_00147098:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "sh_set_lines_and_columns": "\nvoid sh_set_lines_and_columns(int param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  undefined local_2c [12];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = inttostr((long)param_1,local_2c,0xc);\n  bind_variable(\"LINES\",uVar1,0);\n  uVar1 = inttostr((long)param_2,local_2c,0xc);\n  bind_variable(\"COLUMNS\",uVar1,0);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "search_for_command": "\nchar * search_for_command(char *param_1,uint param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  char *pcVar3;\n  size_t sVar4;\n  bool bVar5;\n  uint uVar6;\n  long in_FS_OFFSET;\n  uint local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = find_variable_tempenv(\"PATH\");\n  if ((lVar2 == 0) || ((*(byte *)(lVar2 + 0x2a) & 0x10) == 0)) {\n    uVar6 = param_2 & 2;\n    if ((param_2 & 2) == 0) {\n      iVar1 = absolute_program(param_1);\n      if ((iVar1 == 0) && (pcVar3 = (char *)phash_search(param_1), pcVar3 != (char *)0x0)) {\n        if (((posixly_correct | check_hashed_filenames) == 0) ||\n           (local_34 = file_status(pcVar3), (local_34 & 3) == 3)) goto LAB_0019bb90;\n        phash_remove(param_1);\n        sh_xfree(pcVar3,\"findcmd.c\",0x16f);\n      }\n      iVar1 = absolute_program(param_1);\n      if (iVar1 == 0) {\n        bVar5 = false;\n        if (lVar2 != 0) goto LAB_0019baf1;\n        goto LAB_0019baf5;\n      }\n    }\n    else {\n      iVar1 = absolute_program(param_1);\n      if (iVar1 == 0) {\n        lVar2 = conf_standard_path();\n        pcVar3 = (char *)FUN_0019b620(param_1,lVar2,0x24,&local_34);\n        if (((pcVar3 == (char *)0x0) || (hashing_enabled == 0)) || ((param_2 & 1) == 0))\n        goto LAB_0019ba60;\n        goto LAB_0019bb2a;\n      }\n    }\n  }\n  else {\n    iVar1 = absolute_program(param_1);\n    if (iVar1 == 0) {\n      bVar5 = true;\n      if ((param_2 & 2) == 0) {\nLAB_0019baf1:\n        lVar2 = *(long *)(lVar2 + 8);\nLAB_0019baf5:\n        pcVar3 = (char *)FUN_0019b620(param_1,lVar2,0x24,&local_34);\n        if (((pcVar3 == (char *)0x0) || (hashing_enabled == 0)) || ((bVar5 || ((param_2 & 1) == 0)))\n           ) goto LAB_0019bb90;\n        uVar6 = 0;\nLAB_0019bb2a:\n        if ((((*pcVar3 != *param_1) || (iVar1 = strcmp(pcVar3,param_1), iVar1 != 0)) &&\n            ((posixly_correct | check_hashed_filenames) == 0)) || ((local_34 & 2) != 0)) {\n          phash_insert(param_1,pcVar3,dot_found_in_search,1);\n        }\n        if (uVar6 == 0) goto LAB_0019bb90;\n      }\n      else {\n        lVar2 = conf_standard_path();\n        pcVar3 = (char *)FUN_0019b620(param_1,lVar2,0x24,&local_34);\n      }\nLAB_0019ba60:\n      sh_xfree(lVar2,\"findcmd.c\",0x19b);\n      goto LAB_0019bb90;\n    }\n  }\n  sVar4 = strlen(param_1);\n  pcVar3 = (char *)sh_xmalloc(sVar4 + 1,\"findcmd.c\",0x179);\n  pcVar3 = strcpy(pcVar3,param_1);\nLAB_0019bb90:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar3;\n}\n\n",
  "faccessat": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint faccessat(int __fd,char *__file,int __type,int __flag)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_faccessat_00237920)();\n  return iVar1;\n}\n\n",
  "rl_vi_goto_mark": "\nundefined8 rl_vi_goto_mark(void)\n\n{\n  undefined8 uVar1;\n  \n  if ((rl_readline_state._2_1_ & 8) != 0) {\n    _rl_callback_data = 0;\n    _rl_callback_func = FUN_001cfa00;\n    return 0;\n  }\n  uVar1 = FUN_001cf980();\n  return uVar1;\n}\n\n",
  "FUN_001edc60": "\nundefined8 FUN_001edc60(int param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  size_t sVar3;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  do {\n    iVar2 = rl_end;\n    if ((rl_point != rl_end && rl_end <= rl_point) || (iVar2 = rl_point, rl_point == rl_end)) {\n      rl_point = iVar2;\n      return 0;\n    }\n    uVar1 = _rl_char_value(rl_line_buffer);\n    iVar2 = _rl_walphabetic(uVar1);\n    while (iVar2 == 0) {\n      sVar3 = __ctype_get_mb_cur_max();\n      if ((sVar3 < 2) || (rl_byte_oriented != 0)) {\n        rl_point = rl_point + 1;\n      }\n      else {\n        rl_point = _rl_find_next_mbchar(rl_line_buffer,rl_point,1,1);\n      }\n      if (rl_end <= rl_point) break;\n      uVar1 = _rl_char_value(rl_line_buffer);\n      iVar2 = _rl_walphabetic(uVar1);\n    }\n    if (rl_end < rl_point) {\n      rl_point = rl_end;\n      return 0;\n    }\n    if (rl_end == rl_point) {\n      return 0;\n    }\n    do {\n      sVar3 = __ctype_get_mb_cur_max();\n      if ((sVar3 < 2) || (rl_byte_oriented != 0)) {\n        rl_point = rl_point + 1;\n        if (rl_end <= rl_point) break;\n      }\n      else {\n        rl_point = _rl_find_next_mbchar(rl_line_buffer,rl_point,1,1);\n        if (rl_end <= rl_point) break;\n      }\n      uVar1 = _rl_char_value(rl_line_buffer);\n      iVar2 = _rl_walphabetic(uVar1);\n    } while (iVar2 != 0);\n    param_1 = param_1 + -1;\n    if (param_1 == 0) {\n      return 0;\n    }\n  } while( true );\n}\n\n",
  "print_arith_command": "\nvoid print_arith_command(long *param_1)\n\n{\n  undefined *puVar1;\n  \n  FUN_001446d0(&DAT_001fc775);\n  if (param_1 != (long *)0x0) {\n    do {\n      puVar1 = &DAT_00213d70;\n      if (*param_1 != 0) {\n        puVar1 = &DAT_001fdb1c;\n      }\n      FUN_001446d0(&DAT_001fc632,*(undefined8 *)param_1[1],puVar1);\n      param_1 = (long *)*param_1;\n    } while (param_1 != (long *)0x0);\n  }\n  FUN_001446d0(&DAT_0020ef6c);\n  return;\n}\n\n",
  "force_execute_file": "\nundefined4 force_execute_file(undefined8 param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  \n  uVar2 = bash_tilde_expand(param_1,0);\n  uVar1 = FUN_001a7e10(uVar2,(ulong)(param_2 != 0) << 3);\n  sh_xfree(uVar2,\"evalfile.c\",0x15c);\n  return uVar1;\n}\n\n",
  "shtimer_alloc": "\nundefined8 * shtimer_alloc(void)\n\n{\n  undefined8 *puVar1;\n  ulong uVar2;\n  undefined8 *puVar3;\n  byte bVar4;\n  \n  bVar4 = 0;\n  puVar1 = (undefined8 *)sh_xmalloc(0x108,\"timers.c\",0x4c);\n  *puVar1 = 0;\n  puVar1[1] = 0;\n  puVar1[2] = 0xffffffff;\n  *(undefined4 *)(puVar1 + 3) = 0;\n  puVar1[5] = 0;\n  puVar1[4] = 0;\n  puVar1[6] = 0;\n  puVar1[0x1e] = 0;\n  puVar3 = (undefined8 *)((ulong)(puVar1 + 7) & 0xfffffffffffffff8);\n  for (uVar2 = (ulong)(((int)puVar1 - (int)(undefined8 *)((ulong)(puVar1 + 7) & 0xfffffffffffffff8))\n                       + 0xf8U >> 3); uVar2 != 0; uVar2 = uVar2 - 1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;\n  }\n  puVar1[0x1f] = 0;\n  puVar1[0x20] = 0;\n  return puVar1;\n}\n\n",
  "delete_all_contexts": "\nvoid delete_all_contexts(long param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 != global_variables) {\n    do {\n      lVar1 = *(long *)(param_1 + 0x18);\n      dispose_var_context(param_1);\n      param_1 = lVar1;\n    } while (lVar1 != global_variables);\n  }\n  hash_flush(*(undefined8 *)(global_variables + 0x20),dispose_variable);\n  shell_variables = global_variables;\n  return;\n}\n\n",
  "get_original_signal": "\nvoid get_original_signal(ulong param_1)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  \n  if ((int)param_1 - 1U < 0x40) {\n    lVar2 = (long)(int)param_1;\n    if (*(code **)(original_signals + lVar2 * 8) == initialize_traps) {\n      uVar1 = set_signal_handler(param_1,0);\n      *(undefined8 *)(original_signals + lVar2 * 8) = uVar1;\n      set_signal_handler(param_1 & 0xffffffff,uVar1);\n      if (*(long *)(original_signals + lVar2 * 8) == 1) {\n        (&DAT_00247e40)[lVar2] = (&DAT_00247e40)[lVar2] | 2;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00152bf0": "\nundefined8 FUN_00152bf0(char *param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  size_t sVar2;\n  char *pcVar3;\n  long lVar4;\n  \n  uVar1 = FUN_00151400();\n  if (shell_variables == 0) {\n    FUN_00152b20();\n  }\n  sVar2 = strlen(param_1);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"variables.c\",0xaf3);\n  pcVar3 = strcpy(pcVar3,param_1);\n  lVar4 = hash_insert(pcVar3,param_2,1);\n  *(undefined8 *)(lVar4 + 0x10) = uVar1;\n  return uVar1;\n}\n\n",
  "ttsetattr": "\nvoid ttsetattr(int param_1,termios *param_2)\n\n{\n  tcsetattr(param_1,1,param_2);\n  return;\n}\n\n",
  "unlink_all_fifos": "\nvoid unlink_all_fifos(void)\n\n{\n  if (DAT_00247834 != 0) {\n    FUN_00168fd0();\n    return;\n  }\n  return;\n}\n\n",
  "exit_builtin": "\nundefined8 exit_builtin(long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  if (((param_1 != 0) && (*(char ***)(param_1 + 8) != (char **)0x0)) &&\n     (pcVar3 = **(char ***)(param_1 + 8), *pcVar3 == '-')) {\n    iVar1 = strcmp(pcVar3,\"--help\");\n    if (iVar1 == 0) {\n      builtin_help();\n      return 0x102;\n    }\n  }\n  if (interactive != 0) {\n    pcVar3 = \"logout\\n\";\n    if (login_shell == 0) {\n      pcVar3 = \"exit\\n\";\n    }\n    __fprintf_chk(stderr,1,pcVar3);\n    fflush(stderr);\n  }\n  uVar2 = FUN_001a9d90(param_1);\n  return uVar2;\n}\n\n",
  "ttnoecho": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint ttnoecho(void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  termios local_58;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00249ee0 == 0) {\n    iVar1 = -1;\n  }\n  else {\n    local_58._48_8_ = DAT_00249f70;\n    local_58.c_iflag = _DAT_00249f40;\n    local_58.c_oflag = tRam0000000000249f44;\n    local_58.c_cflag = tRam0000000000249f48;\n    local_58._16_4_ = _DAT_00249f50;\n    local_58.c_cc._3_4_ = uRam0000000000249f54;\n    local_58.c_cc._7_4_ = uRam0000000000249f58;\n    local_58.c_cc._11_4_ = uRam0000000000249f5c;\n    local_58.c_lflag = uRam0000000000249f4c & 0xffffff97;\n    local_58.c_ospeed = DAT_00249f78;\n    local_58.c_cc._15_4_ = _DAT_00249f60;\n    local_58.c_cc._19_4_ = uRam0000000000249f64;\n    local_58.c_cc._23_4_ = uRam0000000000249f68;\n    local_58.c_cc._27_4_ = uRam0000000000249f6c;\n    iVar1 = tcsetattr(0,1,&local_58);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "parser_remaining_input": "\nundefined * parser_remaining_input(void)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = DAT_00240da8;\n  if (DAT_00240da8 != (undefined *)0x0) {\n    if ((-1 < (int)DAT_00240da0) && (DAT_00240da0 < DAT_00240d90)) {\n      return DAT_00240da8 + DAT_00240da0;\n    }\n    puVar1 = &DAT_00213d70;\n  }\n  return puVar1;\n}\n\n",
  "make_bare_word": "\nchar ** make_bare_word(char *param_1)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  char **ppcVar3;\n  \n  if (DAT_00241ecc < 1) {\n    ppcVar3 = (char **)sh_xmalloc(0x10,\"make_cmd.c\",0x4c);\n  }\n  else {\n    DAT_00241ecc = DAT_00241ecc + -1;\n    ppcVar3 = *(char ***)(wdcache + (long)DAT_00241ecc * 8);\n  }\n  *(undefined4 *)(ppcVar3 + 1) = 0;\n  *ppcVar3 = (char *)0x0;\n  if (*param_1 != '\\0') {\n    sVar1 = strlen(param_1);\n    pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"make_cmd.c\",0x5b);\n    pcVar2 = strcpy(pcVar2,param_1);\n    *ppcVar3 = pcVar2;\n    return ppcVar3;\n  }\n  pcVar2 = (char *)sh_xmalloc(1,\"make_cmd.c\",0x5e);\n  *ppcVar3 = pcVar2;\n  *pcVar2 = '\\0';\n  return ppcVar3;\n}\n\n",
  "mbstrlen": "\nlong mbstrlen(byte *param_1)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  byte bVar3;\n  long lVar4;\n  mbstate_t mVar5;\n  long in_FS_OFFSET;\n  mbstate_t local_38;\n  long local_30;\n  \n  mVar5.__count = 0;\n  mVar5.__value = (_union_27)0x0;\n  lVar4 = 0;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38.__count = 0;\n  local_38.__value = (_union_27)0x0;\n  sVar1 = __ctype_get_mb_cur_max();\n  bVar3 = *param_1;\n  while (bVar3 != 0) {\n    while ((*(uint *)(is_basic_table + (ulong)(bVar3 >> 5) * 4) >> (bVar3 & 0x1f) & 1) != 0) {\n      param_1 = param_1 + 1;\n      lVar4 = lVar4 + 1;\n      bVar3 = *param_1;\n      if (bVar3 == 0) goto LAB_001cc5e0;\n    }\n    sVar2 = mbrtowc((wchar_t *)0x0,(char *)param_1,(long)(int)sVar1,&local_38);\n    if (sVar2 == 0) break;\n    if (0xfffffffffffffffd < sVar2) {\n      sVar2 = 1;\n      local_38 = mVar5;\n    }\n    param_1 = param_1 + sVar2;\n    lVar4 = lVar4 + 1;\n    mVar5 = local_38;\n    bVar3 = *param_1;\n  }\nLAB_001cc5e0:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "sh_mktmpfd": "\nint sh_mktmpfd(char *param_1,uint param_2,undefined8 *param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 *__template;\n  undefined8 uVar3;\n  size_t sVar4;\n  ulong uVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined8 *puVar8;\n  byte bVar9;\n  \n  bVar9 = 0;\n  __template = (undefined8 *)sh_xmalloc(0x1001,\"tmpfile.c\",0xc6);\n  uVar3 = FUN_001c6e70(param_2);\n  if ((undefined8 *)param_1 == (undefined8 *)0x0) {\n    param_1 = \"shtmp\";\nLAB_001c7141:\n    __sprintf_chk(__template,1,0xffffffffffffffff,\"%s/%s.XXXXXX\",uVar3,param_1);\n  }\n  else {\n    if (((param_2 & 8) == 0) || (sVar4 = strlen(param_1), 0x1000 < sVar4)) goto LAB_001c7141;\n    uVar5 = sVar4 + 1;\n    uVar2 = (uint)uVar5;\n    if (7 < uVar2) {\n      *__template = *(undefined8 *)param_1;\n      *(undefined8 *)((long)__template + ((uVar5 & 0xffffffff) - 8)) =\n           *(undefined8 *)((long)param_1 + ((uVar5 & 0xffffffff) - 8));\n      lVar6 = (long)__template - (long)(undefined8 *)((ulong)(__template + 1) & 0xfffffffffffffff8);\n      puVar7 = (undefined8 *)((long)param_1 - lVar6);\n      puVar8 = (undefined8 *)((ulong)(__template + 1) & 0xfffffffffffffff8);\n      for (uVar5 = (ulong)(uVar2 + (int)lVar6 >> 3); uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar8 = *puVar7;\n        puVar7 = puVar7 + (ulong)bVar9 * -2 + 1;\n        puVar8 = puVar8 + (ulong)bVar9 * -2 + 1;\n      }\n      iVar1 = mkstemp((char *)__template);\n      goto joined_r0x001c716e;\n    }\n    if ((uVar5 & 4) == 0) {\n      if ((uVar2 != 0) && (*(char *)__template = *param_1, (uVar5 & 2) != 0)) {\n        *(undefined2 *)((long)__template + ((uVar5 & 0xffffffff) - 2)) =\n             *(undefined2 *)((long)param_1 + ((uVar5 & 0xffffffff) - 2));\n      }\n    }\n    else {\n      *(undefined4 *)__template = *(undefined4 *)param_1;\n      *(undefined4 *)((long)__template + ((uVar5 & 0xffffffff) - 4)) =\n           *(undefined4 *)((long)param_1 + ((uVar5 & 0xffffffff) - 4));\n    }\n  }\n  iVar1 = mkstemp((char *)__template);\njoined_r0x001c716e:\n  if ((iVar1 < 0) || (param_3 == (undefined8 *)0x0)) {\n    sh_xfree(__template,\"tmpfile.c\",0xd9);\n    if (param_3 == (undefined8 *)0x0) {\n      return iVar1;\n    }\n    __template = (undefined8 *)0x0;\n  }\n  *param_3 = __template;\n  return iVar1;\n}\n\n",
  "xtrace_print_case_command_head": "\nvoid xtrace_print_case_command_head(long param_1)\n\n{\n  char *__s;\n  \n  if (xtrace_fp == (FILE *)0x0) {\n    xtrace_fp = stderr;\n  }\n  __s = (char *)indirection_level_string();\n  fputs(__s,xtrace_fp);\n  __fprintf_chk(xtrace_fp,1,\"case %s in\\n\",**(undefined8 **)(param_1 + 8));\n  return;\n}\n\n",
  "_rl_del_executing_keyseq": "\nvoid _rl_del_executing_keyseq(void)\n\n{\n  if (0 < rl_key_sequence_length) {\n    rl_key_sequence_length = rl_key_sequence_length + -1;\n  }\n  return;\n}\n\n",
  "FUN_0017bfe0": "\nchar ** FUN_0017bfe0(char *param_1,int param_2,uint param_3,uint param_4,undefined8 *param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  size_t sVar3;\n  char **ppcVar4;\n  long lVar5;\n  char *pcVar6;\n  uint uVar7;\n  long in_FS_OFFSET;\n  undefined4 local_6c;\n  char *local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 uStack_50;\n  undefined4 local_48;\n  undefined4 uStack_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_5 == (undefined8 *)0x0) {\n    init_eltstate(&local_58);\n    uStack_50 = 0x8000000000000000;\n  }\n  else {\n    local_58 = *param_5;\n    uStack_50 = param_5[1];\n    local_48 = *(undefined4 *)(param_5 + 2);\n    uStack_44 = *(undefined4 *)((long)param_5 + 0x14);\n    uStack_40 = *(undefined4 *)(param_5 + 3);\n    uStack_3c = *(undefined4 *)((long)param_5 + 0x1c);\n  }\n  iVar2 = legal_number(param_1,&local_60);\n  if (iVar2 == 0) {\n    if (param_2 == 0) {\n      iVar2 = valid_array_reference(param_1,0);\n      if (iVar2 != 0) {\nLAB_0017c112:\n        lVar5 = array_variable_part(param_1,0,&local_68,0);\n        cVar1 = *local_68;\n        if ((param_4 & 8) == 0) {\n          if ((param_4 & 4) == 0) {\n            if (cVar1 == '*') {\n              cVar1 = local_68[1];\njoined_r0x0017c426:\n              if (((cVar1 == ']') && (DAT_00247848 != 0)) && (ifs_is_null != 0)) {\n                pcVar6 = (char *)array_value(param_1,3,0,&local_58);\n                goto LAB_0017c161;\n              }\n            }\n          }\n          else if (cVar1 == '@') {\n            if ((((local_68[1] == ']') && (lVar5 != 0)) && (ifs_is_set != 0)) &&\n               (((param_3 | ifs_is_null) == 0 && (ifs_firstc != ' ')))) {\n              pcVar6 = (char *)array_value(param_1,1,0x10,&local_58);\n              goto LAB_0017c161;\n            }\n          }\n          else if (cVar1 == '*') {\n            cVar1 = local_68[1];\n            goto joined_r0x0017c426;\n          }\nLAB_0017c153:\n          pcVar6 = (char *)array_value(param_1,param_3,0,&local_58);\n        }\n        else {\n          if ((((cVar1 != '@') && (cVar1 != '*')) || (local_68[1] != ']')) ||\n             ((lVar5 == 0 || ((*(byte *)(lVar5 + 0x28) & 0x44) == 0)))) goto LAB_0017c153;\n          pcVar6 = (char *)array_value(param_1,param_3 | 1,0x10,&local_58);\n        }\nLAB_0017c161:\n        uVar7 = 0;\n        if (local_58._2_2_ == 0) {\n          if (pcVar6 == (char *)0x0) goto LAB_0017c2e9;\n          if ((*pcVar6 == '\\0') || ((param_3 & 3) == 0)) {\n            pcVar6 = (char *)FUN_00167220(pcVar6,0);\n          }\n          else {\n            pcVar6 = (char *)quote_string(pcVar6);\n          }\n          if (param_5 != (undefined8 *)0x0) {\n            uVar7 = 0x1000000;\n            *(undefined4 *)param_5 = (undefined4)local_58;\n            *(undefined4 *)((long)param_5 + 4) = local_58._4_4_;\n            *(undefined4 *)(param_5 + 1) = (undefined4)uStack_50;\n            *(undefined4 *)((long)param_5 + 0xc) = uStack_50._4_4_;\n            *(undefined4 *)(param_5 + 2) = local_48;\n            *(undefined4 *)((long)param_5 + 0x14) = uStack_44;\n            *(undefined4 *)(param_5 + 3) = uStack_40;\n            *(undefined4 *)((long)param_5 + 0x1c) = uStack_3c;\n            goto LAB_0017c242;\n          }\n          uVar7 = 0x1000000;\n        }\n        else {\n          if (((local_58._2_2_ == 1) || (local_58._2_2_ == 2)) &&\n             ((pcVar6 != (char *)0x0 && ((*pcVar6 == '\\x7f' && (pcVar6[1] == '\\0')))))) {\n            uVar7 = (uint)((param_3 & 3) != 0) << 0x12;\n          }\nLAB_0017c2e9:\n          if (param_5 != (undefined8 *)0x0) goto LAB_0017c242;\n        }\n        flush_eltstate(&local_58);\n        goto LAB_0017c242;\n      }\n      lVar5 = find_variable(param_1);\n      if (lVar5 == 0) {\n        lVar5 = find_variable_last_nameref(param_1,0);\n        if (((lVar5 != 0) && (param_1 = *(char **)(lVar5 + 8), param_1 != (char *)0x0)) &&\n           (*param_1 != '\\0')) {\n          iVar2 = valid_array_reference(param_1,0);\n          if (iVar2 != 0) goto LAB_0017c112;\n          if ((*param_1 != '\\0') && (iVar2 = legal_identifier(param_1), iVar2 == 0)) {\n            set_exit_status(1);\n            report_error(\"%s: invalid variable name for name reference\",param_1);\n            pcVar6 = &DAT_0024784f;\n            uVar7 = 0;\n            goto LAB_0017c242;\n          }\n        }\n      }\n      else {\n        pcVar6 = *(char **)(lVar5 + 8);\n        if ((pcVar6 != (char *)0x0) && (uVar7 = *(uint *)(lVar5 + 0x28), (uVar7 & 0x1000) == 0)) {\n          local_68 = (char *)0x0;\n          if ((param_4 & 0x40) == 0) {\n            if ((uVar7 & 0x40) == 0) {\n              if ((uVar7 & 4) == 0) goto LAB_0017c3a6;\n              pcVar6 = (char *)array_reference(pcVar6,0);\n            }\n            else {\n              pcVar6 = (char *)assoc_reference(pcVar6,&DAT_00210deb);\n            }\nLAB_0017c3a1:\n            if (pcVar6 != (char *)0x0) {\nLAB_0017c3a6:\n              if ((*pcVar6 == '\\0') || ((param_3 & 3) == 0)) {\n                if ((param_4 & 8) == 0) {\n                  pcVar6 = (char *)FUN_00167220(pcVar6,0);\n                }\n                else {\n                  pcVar6 = (char *)FUN_00167220(pcVar6,4);\n                }\n              }\n              else {\n                pcVar6 = (char *)quote_string(pcVar6);\n              }\n            }\n            uVar7 = 0;\n            if (local_68 != (char *)0x0) {\n              sh_xfree(local_68,\"subst.c\",0x1d66);\n            }\n            goto LAB_0017c242;\n          }\n          if ((uVar7 & 0x40) == 0) {\n            if ((uVar7 & 4) == 0) goto LAB_0017c3a6;\n            if (*(long *)(pcVar6 + 8) != 0) {\n              pcVar6 = (char *)array_to_string(pcVar6,&DAT_001fdb1c,param_3);\n              local_68 = pcVar6;\n              goto LAB_0017c3a1;\n            }\n          }\n          else if (*(int *)(pcVar6 + 0xc) != 0) {\n            pcVar6 = (char *)assoc_to_string(pcVar6,&DAT_001fdb1c,param_3);\n            local_68 = pcVar6;\n            goto LAB_0017c3a1;\n          }\n        }\n      }\n    }\n    else {\n      sVar3 = strlen(param_1);\n      local_68 = (char *)sh_xmalloc(sVar3 + 2,\"subst.c\",0x1cfd);\n      local_6c = 0;\n      *local_68 = '$';\n      strcpy(local_68 + 1,param_1);\n      ppcVar4 = (char **)FUN_001745e0(local_68,&local_6c,param_3,0,0,0,0,param_4);\n      if (((param_3 & 3) == 0) || (((*param_1 != '@' && (*param_1 != '*')) || (param_1[1] != '\\0')))\n         ) {\n        sh_xfree(local_68,\"subst.c\",0x1d0a);\n        if (ppcVar4 != (char **)0x0) goto LAB_0017c0d2;\n      }\n      else {\n        if (ppcVar4 != (char **)0x0) {\n          pcVar6 = *ppcVar4;\n          if (((pcVar6 != (char *)0x0) && (*pcVar6 == '\\x7f')) && (pcVar6[1] == '\\0')) {\n            *(uint *)(ppcVar4 + 1) = *(uint *)(ppcVar4 + 1) | 0x40000;\n          }\n          sh_xfree(local_68,\"subst.c\",0x1d0a);\n          goto LAB_0017c0d2;\n        }\n        sh_xfree(local_68,\"subst.c\",0x1d0a);\n      }\n    }\nLAB_0017c23d:\n    uVar7 = 0;\n    pcVar6 = (char *)0x0;\n  }\n  else {\n    local_68 = (char *)get_dollar_var_value(local_60);\n    if (local_68 == (char *)0x0) goto LAB_0017c23d;\n    if ((*local_68 == '\\0') || ((param_3 & 3) == 0)) {\n      pcVar6 = (char *)FUN_00167220(local_68,0);\n    }\n    else {\n      pcVar6 = (char *)quote_string(local_68);\n    }\n    uVar7 = 0;\n    if (local_68 != (char *)0x0) {\n      sh_xfree(local_68,\"subst.c\",0x1cf8);\n    }\n  }\nLAB_0017c242:\n  ppcVar4 = (char **)alloc_word_desc();\n  *(uint *)(ppcVar4 + 1) = *(uint *)(ppcVar4 + 1) | uVar7;\n  *ppcVar4 = pcVar6;\nLAB_0017c0d2:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return ppcVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "find_global_variable_last_nameref": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong find_global_variable_last_nameref(undefined8 param_1,int param_2)\n\n{\n  long *plVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  long lVar5;\n  long lVar6;\n  long lVar7;\n  int iVar8;\n  \n  lVar7 = global_variables;\n  if (global_variables != 0) {\n    do {\n      uVar3 = *(undefined8 *)(lVar7 + 0x20);\n      lVar6 = hash_search(param_1,uVar3,0);\n      if ((lVar6 != 0) && (lVar6 = *(long *)(lVar6 + 0x10), _DAT_002422f8 = uVar3, lVar6 != 0)) {\n        if ((*(code **)(lVar6 + 0x18) != (code *)0x0) &&\n           (lVar6 = (**(code **)(lVar6 + 0x18))(lVar6), lVar6 == 0)) {\n          return 0;\n        }\n        iVar8 = 9;\n        uVar2 = *(uint *)(lVar6 + 0x28);\n        lVar7 = lVar6;\n        while( true ) {\n          lVar5 = lVar6;\n          if ((uVar2 & 0x800) == 0) {\n            return lVar7;\n          }\n          iVar8 = iVar8 + -1;\n          if (iVar8 == 0) {\n            return 0;\n          }\n          pcVar4 = *(char **)(lVar5 + 8);\n          if ((pcVar4 == (char *)0x0) || (lVar7 = global_variables, *pcVar4 == '\\0')) break;\n          while( true ) {\n            if (lVar7 == 0) {\n              return lVar5;\n            }\n            uVar3 = *(undefined8 *)(lVar7 + 0x20);\n            lVar6 = hash_search(pcVar4,uVar3,0);\n            if ((lVar6 != 0) && (lVar6 = *(long *)(lVar6 + 0x10), _DAT_002422f8 = uVar3, lVar6 != 0)\n               ) break;\n            lVar7 = *(long *)(lVar7 + 0x18);\n          }\n          if ((*(code **)(lVar6 + 0x18) != (code *)0x0) &&\n             (lVar6 = (**(code **)(lVar6 + 0x18))(), lVar6 == 0)) {\n            return lVar5;\n          }\n          uVar2 = *(uint *)(lVar6 + 0x28);\n          lVar7 = lVar5;\n        }\n        if (param_2 == 0) {\n          return 0;\n        }\n        if ((uVar2 & 0x1000) == 0) {\n          return 0;\n        }\n        return lVar5;\n      }\n      plVar1 = (long *)(lVar7 + 0x18);\n      lVar7 = *plVar1;\n    } while (*plVar1 != 0);\n  }\n  return 0;\n}\n\n",
  "substring": "\nvoid substring(long param_1,int param_2,int param_3)\n\n{\n  void *pvVar1;\n  \n  param_3 = param_3 - param_2;\n  pvVar1 = (void *)sh_xmalloc((long)(param_3 + 1),\"stringlib.c\",0x87);\n  pvVar1 = memcpy(pvVar1,(void *)(param_1 + param_2),(long)param_3);\n  *(undefined *)((long)pvVar1 + (long)param_3) = 0;\n  return;\n}\n\n",
  "expand_prompt_string": "\nundefined * expand_prompt_string(char *param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  size_t sVar1;\n  char *__dest;\n  undefined *puVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  char *local_38;\n  undefined4 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_1 == (char *)0x0) || (*param_1 == '\\0')) {\nLAB_0017a428:\n    puVar2 = (undefined *)0x0;\n  }\n  else {\n    local_30 = param_3;\n    sVar1 = strlen(param_1);\n    __dest = (char *)sh_xmalloc(sVar1 + 1,\"subst.c\",0x115d);\n    local_38 = strcpy(__dest,param_1);\n    no_longjmp_on_fatal_error = 1;\n    puVar2 = (undefined *)FUN_00177e80(&local_38,param_2,0,0,0);\n    no_longjmp_on_fatal_error = 0;\n    if ((puVar2 == &DAT_00247870) || (puVar2 == &DAT_00247880)) {\n      uVar3 = make_bare_word(param_1);\n      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n        puVar2 = (undefined *)make_word_list(uVar3,0);\n        return puVar2;\n      }\n      goto LAB_0017a45b;\n    }\n    if (local_38 != (char *)0x0) {\n      sh_xfree(local_38,\"subst.c\",0x1168);\n    }\n    if (puVar2 == (undefined *)0x0) goto LAB_0017a428;\n    if (*(undefined8 **)(puVar2 + 8) != (undefined8 *)0x0) {\n      remove_quoted_nulls(**(undefined8 **)(puVar2 + 8));\n      *(uint *)(*(long *)(puVar2 + 8) + 8) = *(uint *)(*(long *)(puVar2 + 8) + 8) & 0xfffbffff;\n    }\n    dequote_list(puVar2);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar2;\n  }\nLAB_0017a45b:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_call_last_kbd_macro": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 rl_call_last_kbd_macro(int param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  size_t sVar3;\n  char *__dest;\n  char *pcVar4;\n  \n  if (DAT_0024b198 == (char *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    _rl_abort_internal();\n  }\n  if ((rl_readline_state & 0x1000) != 0) {\n    rl_ding();\n    DAT_0024b190 = DAT_0024b190 + -1;\n    DAT_0024b198[DAT_0024b190] = '\\0';\n    return 0;\n  }\n  if (param_1 != 0) {\n    do {\n      pcVar4 = DAT_0024b198;\n      sVar3 = strlen(DAT_0024b198);\n      __dest = (char *)xmalloc(sVar3 + 1);\n      pcVar4 = strcpy(__dest,pcVar4);\n      if (0x10 < _DAT_0024b180) {\n        _rl_errmsg(\"maximum macro execution nesting level exceeded\");\n                    /* WARNING: Subroutine does not return */\n        _rl_abort_internal();\n      }\n      puVar2 = (undefined8 *)xmalloc(0x18);\n      _DAT_0024b180 = _DAT_0024b180 + 1;\n      puVar1 = puVar2;\n      *puVar2 = DAT_0024b188;\n      DAT_0024b188 = puVar1;\n      rl_readline_state = rl_readline_state | 0x800;\n      *(undefined4 *)(puVar2 + 2) = DAT_0024b1a0;\n      DAT_0024b1a0 = 0;\n      puVar2[1] = rl_executing_macro;\n      param_1 = param_1 + -1;\n      rl_executing_macro = pcVar4;\n    } while (param_1 != 0);\n  }\n  return 0;\n}\n\n",
  "rl_copy_forward_word": "\nvoid rl_copy_forward_word(ulong param_1)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  \n  uVar2 = rl_point;\n  uVar1 = rl_mark;\n  if (-1 < (int)param_1) {\n    rl_forward_word(param_1,0);\n    rl_mark = rl_point;\n    rl_backward_word(param_1 & 0xffffffff,0);\n    FUN_001e9520(0);\n    rl_mark = uVar1;\n    rl_point = uVar2;\n    return;\n  }\n  rl_copy_backward_word(-(int)param_1);\n  return;\n}\n\n",
  "sh_mktmpfp": "\nFILE * sh_mktmpfp(undefined8 param_1,ulong param_2)\n\n{\n  int __fd;\n  FILE *pFVar1;\n  char *__modes;\n  \n  __fd = sh_mktmpfd();\n  if (-1 < __fd) {\n    __modes = \"w+\";\n    if ((param_2 & 2) == 0) {\n      __modes = \"w\";\n    }\n    pFVar1 = fdopen(__fd,__modes);\n    if (pFVar1 == (FILE *)0x0) {\n      close(__fd);\n    }\n    return pFVar1;\n  }\n  return (FILE *)0x0;\n}\n\n",
  "FUN_00133b90": "\nbool FUN_00133b90(void)\n\n{\n  char cVar1;\n  int iVar2;\n  char *__s1;\n  bool bVar3;\n  \n  __s1 = (char *)base_pathname();\n  cVar1 = *__s1;\n  if (cVar1 == '-') {\n    cVar1 = __s1[1];\n    __s1 = __s1 + 1;\n  }\n  bVar3 = false;\n  if (cVar1 == 'r') {\n    iVar2 = strcmp(__s1,\"rbash\");\n    bVar3 = iVar2 == 0;\n  }\n  return bVar3;\n}\n\n",
  "FUN_001a1aa0": "\nvoid FUN_001a1aa0(char **param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  undefined *puVar2;\n  \n  uVar1 = sh_single_quote(param_1[1]);\n  if (param_2 != 0) {\n    puVar2 = &DAT_00213d70;\n    if ((*param_1 != (char *)0x0) && (**param_1 == '-')) {\n      puVar2 = &DAT_0020f01b;\n    }\n    __printf_chk(1,\"alias %s\",puVar2);\n  }\n  __printf_chk(1,\"%s=%s\\n\",*param_1,uVar1);\n  sh_xfree(uVar1,\"./alias.def\",0xed);\n  fflush(stdout);\n  return;\n}\n\n",
  "_rl_free_match_list": "\nvoid _rl_free_match_list(long *param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  \n  if (param_1 != (long *)0x0) {\n    if (*param_1 != 0) {\n      plVar2 = param_1 + 1;\n      do {\n        xfree();\n        lVar1 = *plVar2;\n        plVar2 = plVar2 + 1;\n      } while (lVar1 != 0);\n    }\n    xfree(param_1);\n    return;\n  }\n  return;\n}\n\n",
  "_rl_reset_region_color": "\nundefined8 _rl_reset_region_color(int param_1,char *param_2)\n\n{\n  size_t sVar1;\n  long in_FS_OFFSET;\n  int local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    xfree(_rl_active_region_start_color);\n    if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\n      _rl_active_region_start_color = 0;\n    }\n    else {\n      sVar1 = strlen(param_2);\n      _rl_active_region_start_color = xmalloc(sVar1 * 2 + 1);\n      rl_translate_keyseq(param_2,_rl_active_region_start_color,&local_14);\n      *(undefined *)(_rl_active_region_start_color + local_14) = 0;\n    }\n  }\n  else {\n    xfree(_rl_active_region_end_color);\n    if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\n      _rl_active_region_end_color = 0;\n    }\n    else {\n      sVar1 = strlen(param_2);\n      _rl_active_region_end_color = xmalloc(sVar1 * 2 + 1);\n      rl_translate_keyseq(param_2,_rl_active_region_end_color,&local_14);\n      *(undefined *)(_rl_active_region_end_color + local_14) = 0;\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001cfe00": "\nuint FUN_001cfe00(void)\n\n{\n  undefined uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  long lVar4;\n  undefined *puVar5;\n  uint uVar6;\n  long in_FS_OFFSET;\n  long local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar4 = _rl_bracketed_text(&local_38);\n  if (local_38 != 0) {\n    iVar2 = (int)local_38;\n    uVar6 = iVar2 - 1;\n    if (-1 < (int)uVar6) {\n      puVar5 = (undefined *)((int)uVar6 + lVar4);\n      do {\n        uVar1 = *puVar5;\n        puVar5 = puVar5 + -1;\n        _rl_unget_char(uVar1);\n      } while (puVar5 != (undefined *)((((long)iVar2 + -2) - (ulong)uVar6) + lVar4));\n      uVar6 = uVar6 - iVar2;\n    }\n    xfree(lVar4);\n    do {\n      iVar2 = _rl_pushed_input_available();\n      while( true ) {\n        if (iVar2 == 0) goto LAB_001cfebf;\n        uVar3 = rl_read_key();\n        if (DAT_0024a420 == 0) {\n          DAT_0024a420 = 1;\n          rl_begin_undo_group();\n        }\n        uVar6 = 1;\n        iVar2 = _rl_overwrite_char(1,uVar3);\n        if (iVar2 != 0) break;\n        DAT_0024a410 = DAT_0024a410 + 1;\n        uVar6 = 0;\n        iVar2 = _rl_pushed_input_available();\n      }\n    } while( true );\n  }\n  uVar6 = 0;\n  xfree(lVar4);\nLAB_001cfebf:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar6;\n}\n\n",
  "history_set_pos": "\nundefined8 history_set_pos(int param_1)\n\n{\n  if (((param_1 <= history_length) && (-1 < param_1)) && (DAT_0024b6e8 != 0)) {\n    history_offset = param_1;\n    return 1;\n  }\n  return 0;\n}\n\n",
  "_rl_move_vert": "\nvoid _rl_move_vert(int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  \n  if (_rl_last_v_pos == param_1) {\n    return;\n  }\n  iVar2 = _rl_last_v_pos;\n  if (param_1 <= _rl_screenheight) {\n    iVar2 = param_1 - _rl_last_v_pos;\n    if (iVar2 < 1) {\n      iVar2 = param_1;\n      if (((_rl_term_up != (char *)0x0) && (iVar2 = param_1, *_rl_term_up != '\\0')) &&\n         (iVar1 = _rl_last_v_pos - param_1, iVar2 = param_1, 0 < iVar1)) {\n        iVar3 = 0;\n        do {\n          iVar3 = iVar3 + 1;\n          tputs(_rl_term_up,1,_rl_output_character_function);\n          iVar2 = param_1;\n        } while (iVar1 != iVar3);\n      }\n    }\n    else {\n      iVar1 = 0;\n      do {\n        iVar1 = iVar1 + 1;\n        putc(10,rl_outstream);\n      } while (iVar2 != iVar1);\n      _rl_cr();\n      _rl_last_c_pos = 0;\n      iVar2 = param_1;\n    }\n  }\n  _rl_last_v_pos = iVar2;\n  return;\n}\n\n",
  "run_pending_traps": "\nvoid run_pending_traps(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  int iVar5;\n  uint uVar6;\n  undefined4 uVar7;\n  __pid_t __pid;\n  size_t sVar8;\n  char *__dest;\n  char *pcVar9;\n  long lVar10;\n  uint uVar11;\n  long in_FS_OFFSET;\n  uint local_234;\n  int local_20c;\n  undefined local_208 [208];\n  undefined local_138 [264];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00247e28 != 0) {\n    if (0 < (int)running_trap) {\n      internal_debug(\"run_pending_traps: recursive invocation while running trap for signal %d\",\n                     running_trap + -1);\n      if ((running_trap == 0x1d) && (pending_traps._112_4_ != 0)) goto LAB_00181d28;\n      if ((0 < evalnest_max) && (evalnest_max < evalnest)) {\n        internal_error(\"trap handler: maximum trap handler level exceeded (%d)\");\n        evalnest = 0;\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level(2);\n      }\n    }\n    uVar1 = last_command_exit_value;\n    trapped_signal_received = 0;\n    DAT_00247e28 = 0;\n    trap_saved_exit_value = last_command_exit_value;\n    save_pipestatus_array();\n    iVar5 = running_trap;\n    if (pending_traps._4_4_ != 0) {\n      running_trap = 2;\n      local_234 = 1;\n      goto LAB_00181d6d;\n    }\n    local_234 = 2;\n    uVar6 = 1;\n    running_trap = iVar5;\n    uVar11 = local_234;\nLAB_00181d10:\n    local_234 = uVar11;\n    if ((int)uVar6 < 0x40) {\n      lVar10 = (long)(int)local_234;\n      uVar11 = local_234 + 1;\n      uVar6 = local_234;\n      if (*(int *)(pending_traps + lVar10 * 4) != 0) {\n        running_trap = uVar11;\n        if (local_234 == 2) {\n          *(undefined4 *)(pending_traps + lVar10 * 4) = 0;\n          pending_traps._8_4_ = 0;\n          DAT_00247e28 = 0;\n          FUN_001811f0(2,\"interrupt trap\");\n          interrupt_state = 0;\n        }\n        else {\n          if (local_234 == 0x11) {\n            if (DAT_00247a88 == initialize_traps) {\n              if ((DAT_00247e84 & 0x10) == 0) goto LAB_00181d6d;\n            }\n            else if ((DAT_00247e84 & 0x10) == 0) {\n              *(undefined4 *)(pending_traps + lVar10 * 4) = 0;\n              DAT_00247e84 = DAT_00247e84 | 0x10;\n              evalnest = evalnest + 1;\n              run_sigchld_trap();\n              evalnest = evalnest + -1;\n              DAT_00247e84 = DAT_00247e84 & 0xffffffef;\n              running_trap = 0;\n              goto LAB_00181d10;\n            }\n            running_trap = 0;\n            goto LAB_00181d10;\n          }\nLAB_00181d6d:\n          uVar11 = running_trap;\n          if (((code *)(&trap_list)[(int)local_234] < (code *)0x2) ||\n             ((code *)(&trap_list)[(int)local_234] == initialize_traps)) {\n            internal_warning(\"run_pending_traps: bad value in trap_list[%d]: %p\",local_234);\n            if ((&trap_list)[(int)local_234] == 0) {\n              pcVar9 = \"invalid signal number\";\n              if ((local_234 < 0x44) &&\n                 (pcVar9 = (&signal_names)[(int)local_234], pcVar9 == (char *)0x0)) {\n                pcVar9 = \"invalid signal number\";\n              }\n              internal_warning(\"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself\"\n                               ,local_234,pcVar9);\n              __pid = getpid();\n              kill(__pid,local_234);\n            }\n          }\n          else {\n            save_parser_state(local_138);\n            uVar4 = subst_assign_varlist;\n            uVar3 = temporary_env;\n            subst_assign_varlist = 0;\n            temporary_env = 0;\n            save_pipeline(1);\n            local_20c = 0;\n            *(undefined4 *)(pending_traps + (long)(int)local_234 * 4) = 0;\n            iVar2 = return_catch_flag;\n            evalnest = evalnest + 1;\n            if (return_catch_flag != 0) {\n              xbcopy(return_catch,local_208,200);\n              local_20c = __sigsetjmp(return_catch,0);\n            }\n            if (local_20c == 0) {\n              pcVar9 = (char *)(&trap_list)[(int)local_234];\n              sVar8 = strlen(pcVar9);\n              __dest = (char *)sh_xmalloc(sVar8 + 1,\"trap.c\",0x1bc);\n              pcVar9 = strcpy(__dest,pcVar9);\n              uVar7 = parse_and_execute(pcVar9,\"trap\",0x15);\n            }\n            else {\n              parse_and_execute_cleanup(local_234 + 1);\n              uVar7 = return_catch_value;\n            }\n            evalnest = evalnest + -1;\n            restore_pipeline(1);\n            subst_assign_varlist = uVar4;\n            restore_parser_state(local_138);\n            temporary_env = uVar3;\n            if ((iVar2 != 0) &&\n               (return_catch_value = uVar7, return_catch_flag = iVar2,\n               xbcopy(local_208,return_catch,200), local_20c != 0)) {\n              running_trap = iVar5;\n                    /* WARNING: Subroutine does not return */\n              __longjmp_chk(return_catch,1);\n            }\n            uVar11 = local_234 + 1;\n          }\n        }\n        *(undefined4 *)(pending_traps + (long)(int)local_234 * 4) = 0;\n        uVar6 = local_234;\n        running_trap = iVar5;\n      }\n      goto LAB_00181d10;\n    }\n    restore_pipestatus_array();\n    last_command_exit_value = uVar1;\n  }\nLAB_00181d28:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "is_directory": "\nuint is_directory(void)\n\n{\n  uint uVar1;\n  \n  uVar1 = file_status();\n  return uVar1 & 0x10;\n}\n\n",
  "FUN_00193420": "\nvoid FUN_00193420(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_001931e0(param_1,param_2,1,\"fc -e \\\"${VISUAL:-${EDITOR:-emacs}}\\\"\");\n  return;\n}\n\n",
  "FUN_001f50f0": "\nvoid FUN_001f50f0(char *param_1,char *param_2)\n\n{\n  ssize_t sVar1;\n  long in_FS_OFFSET;\n  char acStack_1028 [4104];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar1 = readlink(param_2,acStack_1028,0x1000);\n  if (sVar1 < 1) {\n    rename(param_1,param_2);\n  }\n  else {\n    acStack_1028[sVar1] = '\\0';\n    rename(param_1,acStack_1028);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "dispose_words": "\nvoid dispose_words(undefined8 *param_1)\n\n{\n  undefined8 *puVar1;\n  long lVar2;\n  long lVar3;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    return;\n  }\n  do {\n    while( true ) {\n      puVar1 = (undefined8 *)*param_1;\n      dispose_word(param_1[1]);\n      if (DAT_00241ebc < DAT_00241eb8) break;\n      sh_xfree(param_1,\"dispose_cmd.c\",0x115);\n      param_1 = puVar1;\n      if (puVar1 == (undefined8 *)0x0) {\n        return;\n      }\n    }\n    *param_1 = 0xdfdfdfdfdfdfdfdf;\n    lVar2 = wlcache;\n    param_1[1] = 0xdfdfdfdfdfdfdfdf;\n    lVar3 = (long)DAT_00241ebc;\n    DAT_00241ebc = DAT_00241ebc + 1;\n    *(undefined8 **)(lVar2 + lVar3 * 8) = param_1;\n    param_1 = puVar1;\n  } while (puVar1 != (undefined8 *)0x0);\n  return;\n}\n\n",
  "FUN_00168020": "\nundefined * FUN_00168020(int param_1,uint param_2,uint param_3,undefined4 *param_4)\n\n{\n  long lVar1;\n  char cVar2;\n  bool bVar3;\n  char cVar4;\n  char cVar5;\n  size_t sVar6;\n  ulong uVar7;\n  size_t sVar8;\n  undefined *puVar9;\n  long lVar10;\n  undefined *puVar12;\n  long lVar13;\n  ulong uVar14;\n  size_t __n;\n  char *unaff_R14;\n  char *__s;\n  long in_FS_OFFSET;\n  wchar_t local_1054;\n  mbstate_t local_1050;\n  char local_1048 [4104];\n  long local_40;\n  long lVar11;\n  \n  cVar5 = DAT_0024779f;\n  cVar4 = ifs_cmap._1_1_;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar6 = __ctype_get_mb_cur_max();\n  if (-1 < param_1) {\n    __n = 0;\n    uVar14 = 0;\n    bVar3 = false;\n    lVar13 = 0;\n    puVar9 = (undefined *)0x0;\nLAB_00168103:\n    __n = __n - 1;\n    __s = unaff_R14;\n    if ((0 < (long)__n) || (__n = zread(param_1,local_1048,0x1000), __s = local_1048, 0 < (long)__n)\n       ) {\n      cVar2 = *__s;\n      unaff_R14 = __s + 1;\n      if (cVar2 != '\\0') {\n        uVar7 = ((int)sVar6 + 1) + lVar13;\n        if (uVar14 <= uVar7) {\n          do {\n            uVar14 = uVar14 + 0x200;\n          } while (uVar14 <= uVar7);\n          puVar9 = (undefined *)sh_xrealloc(puVar9,uVar14,\"subst.c\",0x1aaa);\n        }\n        if ((param_2 & 3) != 0) goto LAB_00168145;\n        if ((param_3 & 8) == 0) {\nLAB_001682e0:\n          if (cVar4 == '\\0') {\nLAB_001682e8:\n            if (cVar2 == '\\x01') goto LAB_001680de;\n          }\n          if ((cVar5 == '\\0') && (cVar2 == '\\x7f')) {\nLAB_00168145:\n            puVar9[lVar13] = 1;\n            lVar13 = lVar13 + 1;\n          }\n          else if (cVar2 == ' ') {\n            if ((ifs_value == (char *)0x0) || (*ifs_value != '\\0')) goto LAB_001680e1;\n            goto LAB_00168145;\n          }\n          lVar1 = lVar13;\n          if (locale_utf8locale == 0) goto LAB_001680eb;\njoined_r0x001680f5:\n          lVar13 = lVar1;\n          if (cVar2 < '\\0') {\n            local_1050.__count = 0;\n            local_1050.__value = (_union_27)0x0;\n            sVar8 = mbrtowc(&local_1054,__s,__n,&local_1050);\n            puVar9[lVar1] = cVar2;\n            lVar13 = lVar1 + 1;\n            if (sVar8 - 2 < 0xfffffffffffffffc) {\n              lVar11 = lVar13;\n              do {\n                lVar10 = lVar11 + 1;\n                puVar9[lVar11] = __s[lVar10 + (-1 - lVar1)];\n                lVar11 = lVar10;\n              } while (lVar1 + sVar8 != lVar10);\n              unaff_R14 = __s + sVar8;\n              lVar13 = lVar13 + (sVar8 - 1);\n              __n = (__n + 1) - sVar8;\n            }\n            goto LAB_00168103;\n          }\n        }\n        else {\n          if (cVar4 == '\\0') goto LAB_001682e8;\n          if (cVar2 != '\\x01') goto LAB_001682e0;\nLAB_001680de:\n          puVar9[lVar13] = 1;\n          lVar13 = lVar13 + 1;\nLAB_001680e1:\n          if (locale_utf8locale == 0) {\nLAB_001680eb:\n            lVar1 = lVar13;\n            if (1 < (int)sVar6) goto joined_r0x001680f5;\n          }\n        }\n        puVar9[lVar13] = cVar2;\n        lVar13 = lVar13 + 1;\n        goto LAB_00168103;\n      }\n      if (!bVar3) {\n        internal_warning(&DAT_002102da,\"command substitution: ignored null byte in input\");\n        bVar3 = true;\n      }\n      goto LAB_00168103;\n    }\n    if (puVar9 == (undefined *)0x0) {\n      if (lVar13 != 0) goto LAB_0016826a;\n    }\n    else {\n      puVar9[lVar13] = 0;\n      if (lVar13 != 0) {\nLAB_0016826a:\n        if ((param_2 & 3) == 0) {\n          strip_trailing(puVar9,(int)lVar13 + -1,1);\n        }\n        else {\n          while (puVar12 = puVar9, lVar13 != 0) {\n            lVar1 = lVar13 + -1;\n            if (puVar9[lVar13 + -1] != '\\n') {\n              puVar12 = puVar9 + lVar13;\n              break;\n            }\n            lVar11 = lVar13 + -2;\n            lVar13 = lVar13 + -2;\n            if (puVar9[lVar11] != '\\x01') {\n              lVar13 = lVar1;\n            }\n          }\n          *puVar12 = 0;\n        }\n        goto LAB_001682a9;\n      }\n      sh_xfree(puVar9,\"subst.c\",0x1ad8);\n    }\n  }\n  puVar9 = (undefined *)0x0;\nLAB_001682a9:\n  *param_4 = 0;\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar9;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "assoc_to_string": "\nundefined * assoc_to_string(long *param_1,undefined8 param_2,int param_3)\n\n{\n  long *__s;\n  size_t sVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  long *plVar4;\n  undefined *puVar5;\n  long lVar6;\n  long **pplVar7;\n  \n  if (param_1 == (long *)0x0) {\n    return (undefined *)0x0;\n  }\n  if (*(int *)((long)param_1 + 0xc) == 0) {\n    puVar5 = (undefined *)sh_xmalloc(1,\"assoc.c\",0x249);\n    *puVar5 = 0;\n    return puVar5;\n  }\n  lVar6 = 0;\n  plVar4 = (long *)0x0;\n  if (0 < *(int *)(param_1 + 1)) {\n    do {\n      for (pplVar7 = *(long ***)(*param_1 + lVar6 * 8); pplVar7 != (long **)0x0;\n          pplVar7 = (long **)*pplVar7) {\nLAB_0018e8a3:\n        __s = pplVar7[2];\n        if (__s == (long *)0x0) {\nLAB_0018e89b:\n          pplVar7 = (long **)*pplVar7;\n          if (pplVar7 == (long **)0x0) break;\n          goto LAB_0018e8a3;\n        }\n        if (param_3 != 0) {\n          pcVar2 = (char *)quote_string();\n          uVar3 = make_bare_word(pcVar2);\n          plVar4 = (long *)make_word_list(uVar3,plVar4);\n          if (pcVar2 != (char *)0x0) goto LAB_0018e8ed;\n          goto LAB_0018e89b;\n        }\n        sVar1 = strlen((char *)__s);\n        pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"assoc.c\",0x256);\n        pcVar2 = strcpy(pcVar2,(char *)__s);\n        uVar3 = make_bare_word(pcVar2);\n        plVar4 = (long *)make_word_list(uVar3,plVar4);\nLAB_0018e8ed:\n        sh_xfree(pcVar2,\"assoc.c\",600);\n      }\n      lVar6 = lVar6 + 1;\n    } while (*(int *)(param_1 + 1) != (int)lVar6 && (int)lVar6 <= *(int *)(param_1 + 1));\n    if ((plVar4 != (long *)0x0) &&\n       ((*plVar4 == 0 || (plVar4 = (long *)list_reverse(plVar4), plVar4 != (long *)0x0)))) {\n      puVar5 = (undefined *)string_list_internal(plVar4,param_2);\n      goto LAB_0018e945;\n    }\n  }\n  plVar4 = (long *)0x0;\n  puVar5 = (undefined *)sh_xmalloc(1,\"assoc.c\",0x25d);\n  *puVar5 = 0;\nLAB_0018e945:\n  dispose_words(plVar4);\n  return puVar5;\n}\n\n",
  "xstrmatch": "\nulong xstrmatch(char *param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  char *pcVar1;\n  char cVar2;\n  char cVar3;\n  uint uVar4;\n  int iVar5;\n  size_t sVar6;\n  long lVar7;\n  ulong uVar8;\n  char *pcVar9;\n  undefined **ppuVar10;\n  char *pcVar11;\n  long in_FS_OFFSET;\n  undefined8 local_68;\n  undefined8 local_60;\n  char local_58 [24];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar6 = __ctype_get_mb_cur_max();\n  if (sVar6 != 1) {\n    lVar7 = mbsmbchar(param_2);\n    if ((lVar7 != 0) || (lVar7 = mbsmbchar(param_1), lVar7 != 0)) {\nLAB_001c33cb:\n      uVar8 = xdupmbstowcs(&local_68,0,param_1);\n      if (uVar8 < 0xfffffffffffffffe) {\n        uVar8 = xdupmbstowcs(&local_60,0,param_2);\n        if (0xfffffffffffffffd < uVar8) {\n          sh_xfree(local_68,\"smatch.c\",0x271);\n          goto LAB_001c3476;\n        }\n        uVar4 = internal_wstrmatch(local_68,local_60,param_3);\n        sh_xfree(local_68,\"smatch.c\",0x277);\n        sh_xfree(local_60,\"smatch.c\",0x278);\n      }\n      else {\nLAB_001c3476:\n        uVar4 = internal_strmatch(param_1,param_2,param_3);\n      }\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return (ulong)uVar4;\n      }\n      goto LAB_001c35bc;\n    }\n    pcVar11 = param_1;\n    while (pcVar9 = strchr(pcVar11,0x5b), pcVar9 != (char *)0x0) {\n      pcVar11 = pcVar9 + 1;\n      if (pcVar9[1] == ':') {\n        pcVar1 = pcVar9 + 2;\n        pcVar11 = pcVar1;\n        cVar3 = pcVar9[2];\n        while( true ) {\n          if (cVar3 == '\\0') goto LAB_001c3590;\n          pcVar9 = pcVar11 + 1;\n          if ((cVar3 == ':') && (*pcVar9 == ']')) break;\n          pcVar11 = pcVar11 + 1;\n          cVar3 = *pcVar9;\n        }\n        uVar8 = (long)pcVar11 - (long)pcVar1;\n        if (0xf < uVar8) goto LAB_001c33cb;\n        __memmove_chk(local_58,pcVar1,uVar8,0x10);\n        cVar3 = 'a';\n        pcVar9 = \"ascii\";\n        local_58[uVar8] = '\\0';\n        cVar2 = local_58[0];\n        ppuVar10 = &PTR_s_alnum_00235710;\n        while ((cVar2 != cVar3 || (iVar5 = strcmp(local_58,pcVar9), iVar5 != 0))) {\n          if (ppuVar10 == (undefined **)&DAT_00235778) goto LAB_001c33cb;\n          pcVar9 = *ppuVar10;\n          ppuVar10 = ppuVar10 + 1;\n          cVar3 = *pcVar9;\n        }\n        pcVar11 = pcVar11 + 2;\n      }\n    }\n  }\nLAB_001c3590:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    uVar8 = internal_strmatch(param_1,param_2,param_3);\n    return uVar8;\n  }\nLAB_001c35bc:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001d5cb0": "\nundefined * FUN_001d5cb0(char *param_1,undefined8 param_2,undefined *param_3)\n\n{\n  size_t sVar1;\n  undefined *puVar2;\n  \n  sVar1 = strlen(param_1);\n  puVar2 = (undefined *)xmalloc(sVar1 + 2);\n  *puVar2 = *rl_completer_quote_characters;\n  strcpy(puVar2 + 1,param_1);\n  if (param_3 != (undefined *)0x0) {\n    *param_3 = *rl_completer_quote_characters;\n  }\n  return puVar2;\n}\n\n",
  "executable_file": "\nbool executable_file(void)\n\n{\n  uint uVar1;\n  int *piVar2;\n  \n  uVar1 = file_status();\n  if ((uVar1 & 0x10) != 0) {\n    piVar2 = __errno_location();\n    *piVar2 = 0x15;\n  }\n  return (uVar1 & 0x12) == 2;\n}\n\n",
  "set_current_prompt_level": "\nvoid set_current_prompt_level(int param_1)\n\n{\n  prompt_string_pointer = &ps2_prompt;\n  if (param_1 != 2) {\n    prompt_string_pointer = &ps1_prompt;\n  }\n  current_prompt_string = *prompt_string_pointer;\n  return;\n}\n\n",
  "FUN_0015c330": "\nlong FUN_0015c330(void)\n\n{\n  char cVar1;\n  byte bVar2;\n  long __numer;\n  ulong uVar3;\n  long __denom;\n  bool bVar4;\n  char *pcVar5;\n  int iVar6;\n  ulong uVar7;\n  imaxdiv_t iVar8;\n  bool local_41;\n  char *local_40;\n  \n  __numer = FUN_0015c2b0();\n  uVar7 = (ulong)DAT_00242448;\n  if (DAT_00242448 < 0x30) {\n    uVar3 = -0x842000000001 >> ((byte)DAT_00242448 & 0x3f);\n    bVar2 = (byte)uVar3;\n    pcVar5 = DAT_00242458;\n    while (DAT_00242458 = pcVar5, (uVar3 & 1) == 0) {\n      bVar4 = DAT_00242448 == 0x2f;\n      FUN_0015d330();\n      __denom = FUN_0015c2b0();\n      iVar6 = (int)uVar7;\n      if ((iVar6 == 0x25) || (bVar4)) {\n        if (__denom == 0) {\n          if (DAT_00242428 == 0) {\n            DAT_00242450 = pcVar5;\n            local_41 = (bool)(bVar2 & 1);\n            if (pcVar5 != (char *)0x0) {\n              while ((cVar1 = *pcVar5, cVar1 != '\\0' && (cVar1 == ' ' || cVar1 == '\\t'))) {\n                pcVar5 = pcVar5 + 1;\n                local_41 = cVar1 == ' ' || cVar1 == '\\t';\n                local_40 = pcVar5;\n              }\n              if (local_41 != false) {\n                DAT_00242450 = local_40;\n              }\n            }\n                    /* WARNING: Subroutine does not return */\n            FUN_0015bcf0(\"division by 0\");\n          }\n          __denom = 1;\n          if (iVar6 == 0x2a) goto LAB_0015c3ab;\nLAB_0015c3fa:\n          iVar8 = imaxdiv(__numer,__denom);\n          __numer = iVar8.rem;\n          if (iVar6 == 0x2f) {\n            __numer = iVar8.quot;\n          }\n          goto LAB_0015c3ab;\n        }\n        if (iVar6 != 0x25) {\n          if ((__numer == -0x8000000000000000) && (bVar4)) {\n            if (__denom == -1) {\n              __denom = 1;\n            }\n            goto LAB_0015c3fa;\n          }\nLAB_0015c4ad:\n          if (iVar6 == 0x2a) goto LAB_0015c3a7;\n          goto LAB_0015c3fa;\n        }\n        if (__numer != -0x8000000000000000) goto LAB_0015c4ad;\n        if (__denom != -1) {\n          iVar8 = imaxdiv(-0x8000000000000000,__denom);\n          __numer = iVar8.rem;\n          goto LAB_0015c3ab;\n        }\n        __numer = 0;\n      }\n      else {\n        if (iVar6 == 0x2a) {\nLAB_0015c3a7:\n          __numer = __numer * __denom;\n        }\nLAB_0015c3ab:\n        DAT_00242444 = 6;\n      }\n      uVar7 = (ulong)DAT_00242448;\n      if (0x2f < DAT_00242448) {\n        return __numer;\n      }\n      pcVar5 = DAT_00242458;\n      uVar3 = 0xffff7bdfffffffff >> (uVar7 & 0x3f);\n    }\n  }\n  return __numer;\n}\n\n",
  "FUN_0015f840": "\nvoid FUN_0015f840(void)\n\n{\n  __pid_t _Var1;\n  int iVar2;\n  undefined *puVar3;\n  \n  if ((this_shell_builtin != (code *)0x0) && (this_shell_builtin == wait_builtin)) {\n    set_exit_status(0x82);\n    if ((code *)PTR_wait_for_background_pids_002387a8 != wait_for_background_pids) {\n      set_signal_handler(2);\n      PTR_wait_for_background_pids_002387a8 = wait_for_background_pids;\n      waiting_for_child = 0;\n    }\n    if (((this_shell_builtin == wait_builtin) && (iVar2 = signal_is_trapped(2), iVar2 != 0)) &&\n       (puVar3 = (undefined *)trap_to_sighandler(2), puVar3 == PTR_trap_handler_00237fd8)) {\n      trap_handler(2);\n      wait_signal_received = 2;\n      if (wait_intr_flag == 0) {\n        wait_signal_received = 2;\n        return;\n      }\n                    /* WARNING: Subroutine does not return */\n      __longjmp_chk(wait_intr_buf,1);\n    }\n    _Var1 = getpid();\n    kill(_Var1,2);\n  }\n  if (waiting_for_child != 0) {\n    DAT_002475c4 = 1;\n    return;\n  }\n  set_exit_status(0x82);\n  if ((code *)PTR_wait_for_background_pids_002387a8 != wait_for_background_pids) {\n    set_signal_handler(2);\n    PTR_wait_for_background_pids_002387a8 = wait_for_background_pids;\n    waiting_for_child = 0;\n  }\n  _Var1 = getpid();\n  kill(_Var1,2);\n  return;\n}\n\n",
  "sv_ifs": "\nvoid sv_ifs(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = find_variable(&DAT_001fce6e);\n  setifs(uVar1);\n  return;\n}\n\n",
  "FUN_0016fe00": "\nvoid FUN_0016fe00(char *param_1)\n\n{\n  char *__src;\n  \n  __src = (char *)dequote_escapes();\n  strcpy(param_1,__src);\n  sh_xfree(__src,\"subst.c\",0x1377);\n  return;\n}\n\n",
  "mmap": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * mmap(void *__addr,size_t __len,int __prot,int __flags,int __fd,__off_t __offset)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_mmap_002379e0)();\n  return pvVar1;\n}\n\n",
  "FUN_001f85f0": "\nchar * FUN_001f85f0(size_t param_1,char *param_2,undefined4 param_3)\n\n{\n  char cVar1;\n  uint uVar2;\n  bool bVar3;\n  int iVar4;\n  int iVar5;\n  long lVar6;\n  ulong uVar7;\n  undefined *puVar8;\n  void *pvVar9;\n  undefined2 *puVar10;\n  char *__s;\n  char *pcVar12;\n  char *pcVar13;\n  undefined *puVar14;\n  undefined8 uVar15;\n  uint uVar16;\n  ulong uVar17;\n  undefined2 *puVar18;\n  undefined uVar19;\n  size_t __len;\n  int iVar20;\n  int iVar21;\n  long lVar22;\n  long in_FS_OFFSET;\n  undefined *local_168;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  undefined2 *puVar11;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_0024b7a0 == 0) {\n    iVar5 = getpagesize();\n    if (0xfff < iVar5) {\n      uVar17 = (ulong)iVar5;\n      DAT_0024b7a0 = iVar5;\n      pvVar9 = sbrk(0);\n      lVar6 = uVar17 - ((long)(iVar5 + -1) & (ulong)pvVar9);\n      if (lVar6 < 0) {\n        lVar6 = lVar6 + uVar17;\n      }\n      DAT_0024b790 = pvVar9;\n      if (lVar6 != 0) goto LAB_001f8972;\nLAB_001f8a4a:\n      lVar6 = 7;\n      uVar7 = 0x1000;\n      while (DAT_0024b79c = (int)lVar6, uVar7 < uVar17) {\n        lVar6 = lVar6 + 1;\n        if (lVar6 == 0x1c) {\n          DAT_0024b79c = 0x1c;\n          break;\n        }\n        uVar7 = (&DAT_00214400)[lVar6];\n      }\n      goto LAB_001f862d;\n    }\n    DAT_0024b7a0 = 0x1000;\n    iVar5 = 0x1000;\n    pvVar9 = sbrk(0);\n    lVar6 = 0x1000 - (ulong)((uint)pvVar9 & 0xfff);\nLAB_001f8972:\n    DAT_0024b790 = pvVar9;\n    puVar8 = (undefined *)sbrk(lVar6);\n    if (puVar8 != &DAT_ffffffffffffffff) {\n      DAT_0024b790 = (void *)((long)pvVar9 + lVar6);\n      uVar17 = (ulong)iVar5;\n      if (0 < lVar6 >> 6) {\n        puVar18 = (undefined2 *)(puVar8 + ((uint)lVar6 & 0x3f));\n        DAT_0024b7e8 = puVar18;\n        *puVar18 = 0x154;\n        iVar4 = (int)(lVar6 >> 6);\n        if (iVar4 != 1) {\n          puVar10 = puVar18;\n          do {\n            puVar11 = puVar10 + 0x20;\n            *(undefined *)puVar11 = 0x54;\n            *(undefined2 **)(puVar10 + 4) = puVar11;\n            *(undefined *)((long)puVar10 + 0x41) = 1;\n            puVar10 = puVar11;\n          } while (puVar18 + ((ulong)(iVar4 - 2) + 1) * 0x20 != puVar11);\n          puVar18 = puVar18 + (long)(iVar4 + -1) * 0x20;\n        }\n        *(undefined8 *)(puVar18 + 4) = 0;\n        uVar17 = (ulong)iVar5;\n      }\n      goto LAB_001f8a4a;\n    }\n  }\n  else {\nLAB_001f862d:\n    iVar5 = DAT_0024b798;\n    if (param_1 + 0x23 >> 0x20 == 0) {\n      uVar2 = (uint)param_1;\n      uVar16 = uVar2 + 0x23 & 0xfffffff0;\n      if ((uint)(DAT_0024b7a0 >> 1) < uVar16) {\n        lVar6 = (long)DAT_0024b79c;\n        if (0x1b < DAT_0024b79c) goto LAB_001f88e0;\n        uVar17 = (&DAT_00214400)[lVar6];\n      }\n      else {\n        uVar17 = 0x20;\n        lVar6 = 0;\n      }\n      while (iVar4 = (int)lVar6, uVar17 < uVar16) {\n        lVar6 = lVar6 + 1;\n        if (0x1b < (int)lVar6) goto LAB_001f88e0;\n        uVar17 = (&DAT_00214400)[lVar6];\n      }\n      lVar22 = (long)iVar4;\n      lVar6 = (long)(iVar4 + 1);\n      if ((&DAT_0024b7b0)[lVar22] != '\\0') {\n        do {\n          iVar4 = (int)lVar6;\n          pcVar13 = &DAT_0024b7b0 + lVar6;\n          lVar6 = lVar6 + 1;\n        } while (*pcVar13 != '\\0');\n        lVar22 = (long)iVar4;\n      }\n      (&DAT_0024b7b0)[lVar22] = 1;\n      if (iVar5 < iVar4) {\n        DAT_0024b798 = iVar4;\n      }\n      pcVar13 = (char *)(&DAT_0024b7e0)[lVar22];\n      if (pcVar13 == (char *)0x0) {\n        if (((running_trap != 0) || (iVar5 = signal_is_trapped(2), iVar5 != 0)) ||\n           (iVar5 = signal_is_trapped(0x11), iVar5 != 0)) {\n          sigfillset(&local_148);\n          sigemptyset(&local_c8);\n          sigprocmask(0,&local_148,&local_c8);\n          uVar17 = (&DAT_00214400)[lVar22];\n          if (-1 < (long)uVar17) {\n            bVar3 = true;\n            goto LAB_001f883c;\n          }\n          goto LAB_001f8c88;\n        }\n        uVar17 = (&DAT_00214400)[lVar22];\n        bVar3 = false;\n        if (-1 < (long)uVar17) {\nLAB_001f883c:\n          iVar5 = malloc_mmap_threshold;\n          uVar19 = (undefined)iVar4;\n          if ((0 < iVar4) && (iVar4 <= malloc_mmap_threshold)) {\n            iVar21 = DAT_0024b798;\n            if (DAT_0024b798 < 0xc) {\n              iVar21 = 0xc;\n            }\n            if (iVar4 < 9) {\n              lVar6 = (long)(iVar4 + 1);\n              do {\n                iVar20 = (int)lVar6;\n                if (((&DAT_0024b7b0)[lVar6] == '\\0') && ((&DAT_0024b7e0)[lVar6] != 0))\n                goto LAB_001f8b0d;\n                lVar6 = lVar6 + 1;\n              } while ((int)lVar6 <= iVar21);\n            }\n            else if (iVar4 < iVar21) {\n              lVar6 = (long)iVar21;\n              do {\n                iVar20 = (int)lVar6;\n                if (((&DAT_0024b7b0)[lVar6] == '\\0') && ((&DAT_0024b7e0)[lVar6] != 0))\n                goto LAB_001f8b0d;\n                lVar6 = lVar6 + -1;\n              } while (iVar4 < (int)lVar6);\n            }\n            goto LAB_001f8d73;\n          }\n          goto LAB_001f884a;\n        }\n        goto LAB_001f88cc;\n      }\n      goto LAB_001f86d6;\n    }\n  }\nLAB_001f88e0:\n  __s = (char *)0x0;\n  goto LAB_001f88e3;\nLAB_001f8b0d:\n  if ((iVar21 < iVar20) || (iVar20 <= iVar4)) {\nLAB_001f8d73:\n    if ((&DAT_0024b7e0)[lVar22] == 0) {\n      if (((iVar4 < DAT_0024b79c + -1) && (iVar21 = iVar4 + -1, (&DAT_0024b7b0)[iVar21] == '\\0')) &&\n         (puVar8 = (undefined *)(&DAT_0024b7e0)[iVar21], puVar8 != (undefined *)0x0)) {\n        (&DAT_0024b7b0)[iVar21] = 1;\n        puVar14 = *(undefined **)(puVar8 + 8);\n        if (puVar14 != (undefined *)0x0) {\n          if (puVar14 == puVar8 + (&DAT_00214400)[iVar21]) {\n            uVar15 = *(undefined8 *)(puVar14 + 8);\nLAB_001f8ec6:\n            (&DAT_0024b7e0)[iVar21] = uVar15;\n          }\n          else {\n            do {\n              local_168 = puVar8;\n              puVar8 = puVar14;\n              puVar14 = *(undefined **)(puVar8 + 8);\n              if (puVar14 == (undefined *)0x0) goto LAB_001f8df7;\n            } while (puVar14 != puVar8 + (&DAT_00214400)[iVar21]);\n            if ((local_168 != puVar8) && (puVar8 != *(undefined **)(local_168 + 8))) {\n              (&DAT_0024b7b0)[iVar21] = 0;\n              __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",\"unknown\",0);\n              fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n              programming_error(\"bcoalesce: CHAIN(mp2) != mp1\",0,0);\n            }\n            uVar15 = *(undefined8 *)(puVar8 + (&DAT_00214400)[iVar21] + 8);\n            if ((undefined *)(&DAT_0024b7e0)[iVar21] == puVar8) goto LAB_001f8ec6;\n            *(undefined8 *)(local_168 + 8) = uVar15;\n          }\n          uVar15 = (&DAT_0024b7e0)[lVar22];\n          (&DAT_0024b7b0)[iVar21] = 0;\n          *puVar8 = 0x54;\n          puVar8[1] = uVar19;\n          *(undefined8 *)(puVar8 + 8) = uVar15;\n          (&DAT_0024b7e0)[lVar22] = puVar8;\n          goto LAB_001f88b8;\n        }\nLAB_001f8df7:\n        (&DAT_0024b7b0)[iVar21] = 0;\n      }\nLAB_001f884a:\n      __len = (size_t)DAT_0024b7a0;\n      if ((long)__len < (long)uVar17) {\n        uVar7 = (long)(DAT_0024b7a0 + -1) & uVar17;\n        if (uVar7 == 0) {\n          iVar21 = 1;\n          __len = uVar17;\n        }\n        else {\n          iVar21 = 1;\n          __len = (__len + uVar17) - uVar7;\n        }\n      }\n      else {\n        iVar21 = (int)((long)__len / (long)uVar17);\n      }\n      if (iVar5 < iVar4) {\n        puVar8 = (undefined *)mmap((void *)0x0,__len,3,0x22,-1,0);\n        if (puVar8 != &DAT_ffffffffffffffff) {\n          (&DAT_0024b7e0)[lVar22] = puVar8;\n          *puVar8 = 0x54;\n          puVar8[1] = uVar19;\n          *(undefined8 *)(puVar8 + 8) = 0;\n        }\n      }\n      else {\n        puVar8 = (undefined *)sbrk(__len);\n        if (puVar8 != &DAT_ffffffffffffffff) {\n          DAT_0024b790 = (void *)((long)DAT_0024b790 + __len);\n          if (((ulong)puVar8 & 0xf) != 0) {\n            iVar21 = iVar21 + -1;\n            puVar8 = (undefined *)((ulong)(puVar8 + 0xf) & 0xfffffffffffffff0);\n          }\n          iVar5 = iVar21 + -1;\n          (&DAT_0024b7e0)[lVar22] = puVar8;\n          *puVar8 = 0x54;\n          puVar8[1] = uVar19;\n          if (0 < iVar5) {\n            puVar14 = puVar8;\n            do {\n              puVar14 = puVar14 + uVar17;\n              *(undefined **)(puVar14 + (8 - uVar17)) = puVar14;\n              *puVar14 = 0x54;\n              puVar14[1] = uVar19;\n              iVar5 = iVar5 + -1;\n            } while (iVar5 != 0);\n            puVar8 = puVar8 + ((ulong)(iVar21 - 2) + 1) * uVar17;\n          }\n          goto LAB_001f8b7a;\n        }\n      }\n    }\n  }\n  else {\n    puVar8 = (undefined *)(&DAT_0024b7e0)[iVar20];\n    uVar7 = (&DAT_00214400)[iVar20];\n    uVar15 = *(undefined8 *)(puVar8 + 8);\n    (&DAT_0024b7b0)[iVar20] = 0;\n    (&DAT_0024b7e0)[iVar20] = uVar15;\n    (&DAT_0024b7e0)[lVar22] = puVar8;\n    *puVar8 = 0x54;\n    puVar8[1] = uVar19;\n    iVar5 = (int)(uVar7 / uVar17);\n    iVar21 = iVar5 + -1;\n    if (0 < iVar21) {\n      puVar14 = puVar8;\n      do {\n        puVar14 = puVar14 + uVar17;\n        *(undefined **)(puVar14 + (8 - uVar17)) = puVar14;\n        *puVar14 = 0x54;\n        puVar14[1] = uVar19;\n        iVar21 = iVar21 + -1;\n      } while (iVar21 != 0);\n      puVar8 = puVar8 + ((ulong)(iVar5 - 2) + 1) * uVar17;\n    }\nLAB_001f8b7a:\n    *(undefined8 *)(puVar8 + 8) = 0;\n  }\nLAB_001f88b8:\n  if (bVar3) {\nLAB_001f8c88:\n    sigprocmask(2,&local_c8,(sigset_t *)0x0);\n  }\nLAB_001f88cc:\n  pcVar13 = (char *)(&DAT_0024b7e0)[lVar22];\n  if (pcVar13 == (char *)0x0) {\n    (&DAT_0024b7b0)[lVar22] = 0;\n    goto LAB_001f88e0;\n  }\nLAB_001f86d6:\n  uVar15 = *(undefined8 *)(pcVar13 + 8);\n  (&DAT_0024b7b0)[lVar22] = 0;\n  cVar1 = *pcVar13;\n  (&DAT_0024b7e0)[lVar22] = uVar15;\n  if ((cVar1 != 'T') || (pcVar13[1] != iVar4)) {\n    pcVar13 = \"unknown\";\n    if (param_2 != (char *)0x0) {\n      pcVar13 = param_2;\n    }\n    __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar13,param_3);\n    fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"malloc: block on free list clobbered\",param_2,param_3);\n  }\n  *pcVar13 = -9;\n  __s = pcVar13 + 0x10;\n  *(undefined2 *)(pcVar13 + 2) = 0x5555;\n  *(undefined8 *)(pcVar13 + 8) = 0x5555555555555555;\n  pcVar12 = pcVar13 + param_1 + 0x10;\n  *(uint *)(pcVar13 + 4) = uVar2;\n  pcVar12[2] = (char)(param_1 >> 0x10);\n  *pcVar12 = (char)param_1;\n  pcVar12[1] = (char)(param_1 >> 8);\n  pcVar12[3] = (char)(param_1 >> 0x18);\n  if (param_1 == 0) goto LAB_001f88e3;\n  pcVar12 = __s;\n  switch(param_1) {\n  case 0:\n  case 1:\n    pcVar13[0x10] = -0x21;\n    break;\n  case 2:\n    *(undefined2 *)(pcVar13 + 0x10) = 0xdfdf;\n    break;\n  case 3:\n    pcVar13[0x12] = -0x21;\n    *(undefined2 *)(pcVar13 + 0x10) = 0xdfdf;\n    break;\n  case 4:\n    uVar17 = 0;\n    goto LAB_001f8bdd;\n  case 5:\n    uVar17 = 0;\n    goto LAB_001f8bd6;\n  case 6:\n    uVar17 = 0;\nLAB_001f8bcf:\n    *__s = -0x21;\n    pcVar12 = pcVar13 + 0x11;\n    goto LAB_001f8bd6;\n  case 7:\n    uVar17 = 0;\n    goto LAB_001f8c0d;\n  case 0xbad1abe1:\n    uVar17 = param_1 - 1 >> 3;\n    switch(uVar2 & 7) {\n    case 0:\n      pcVar13 = __s;\n      goto LAB_001f8c06;\n    case 1:\n      pcVar13 = __s;\n      goto LAB_001f8bf2;\n    case 2:\n      pcVar13 = __s;\n      goto LAB_001f8beb;\n    case 3:\n      pcVar13 = __s;\n      goto LAB_001f8be4;\n    case 4:\n      break;\n    case 5:\n      goto LAB_001f8bd6;\n    case 6:\n      goto LAB_001f8bcf;\n    case 7:\n      goto LAB_001f8c0d;\n    }\nLAB_001f8bdd:\n    while( true ) {\n      *pcVar12 = -0x21;\n      pcVar13 = pcVar12 + 1;\nLAB_001f8be4:\n      *pcVar13 = -0x21;\n      pcVar13 = pcVar13 + 1;\nLAB_001f8beb:\n      *pcVar13 = -0x21;\n      pcVar13 = pcVar13 + 1;\nLAB_001f8bf2:\n      *pcVar13 = -0x21;\n      if (uVar17 == 0) break;\n      uVar17 = uVar17 - 1;\n      pcVar13 = pcVar13 + 1;\nLAB_001f8c06:\n      *pcVar13 = -0x21;\n      pcVar12 = pcVar13 + 1;\nLAB_001f8c0d:\n      *pcVar12 = -0x21;\n      pcVar12[1] = -0x21;\n      pcVar12 = pcVar12 + 2;\nLAB_001f8bd6:\n      *pcVar12 = -0x21;\n      pcVar12 = pcVar12 + 1;\n    }\n    break;\n  default:\n    __s = (char *)memset(__s,0xdf,param_1);\n  }\nLAB_001f88e3:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return __s;\n}\n\n",
  "rl_do_undo": "\nundefined8 rl_do_undo(void)\n\n{\n  uint uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined4 uVar4;\n  long lVar5;\n  undefined8 *puVar6;\n  undefined8 *puVar7;\n  int iVar8;\n  undefined8 *puVar9;\n  int iVar10;\n  int iVar11;\n  \n  iVar8 = 0;\n  do {\n    while( true ) {\n      if (rl_undo_list == (undefined8 *)0x0) {\n        return 0;\n      }\n      uVar1 = *(uint *)(rl_undo_list + 3);\n      _rl_doing_an_undo = 1;\n      rl_readline_state = rl_readline_state | 0x10000;\n      if (uVar1 < 2) {\n        iVar2 = *(int *)(rl_undo_list + 1);\n        iVar11 = rl_point;\n        if ((iVar2 != -1) && (iVar11 = iVar2, iVar2 == -2)) {\n          iVar11 = rl_end;\n        }\n        iVar2 = *(int *)((long)rl_undo_list + 0xc);\n        iVar10 = rl_point;\n        if ((iVar2 != -1) && (iVar10 = iVar2, iVar2 == -2)) {\n          iVar10 = rl_end;\n        }\n        if (uVar1 == 0) {\n          rl_point = iVar11;\n          _rl_fix_point(1,iVar10);\n          rl_insert_text(rl_undo_list[2]);\n          xfree(rl_undo_list[2]);\n          puVar9 = rl_undo_list;\n        }\n        else {\n          rl_delete_text(iVar11);\n          rl_point = iVar11;\n          _rl_fix_point(1);\n          puVar9 = rl_undo_list;\n        }\n      }\n      else {\n        puVar9 = rl_undo_list;\n        if (uVar1 == 2) {\n          if (iVar8 == 0) {\n            rl_ding();\n            puVar9 = rl_undo_list;\n          }\n          else {\n            iVar8 = iVar8 + -1;\n          }\n        }\n        else {\n          iVar8 = iVar8 + (uint)(uVar1 == 3);\n        }\n      }\n      _rl_doing_an_undo = 0;\n      rl_readline_state = rl_readline_state & 0xfffffffffffeffff;\n      rl_undo_list = (undefined8 *)*puVar9;\n      *puVar9 = 0;\n      lVar5 = current_history();\n      puVar7 = rl_undo_list;\n      uVar3 = rl_line_buffer;\n      if (((lVar5 != 0) && (*(undefined8 **)(lVar5 + 0x10) == puVar9)) &&\n         (*(undefined8 **)(lVar5 + 0x10) != (undefined8 *)0x0)) {\n        uVar4 = where_history();\n        puVar7 = (undefined8 *)replace_history_entry(uVar4,uVar3,puVar7);\n        xfree(*puVar7);\n        if ((void *)puVar7[1] != (void *)0x0) {\n          free((void *)puVar7[1]);\n        }\n        xfree(puVar7);\n      }\n      _hs_replace_history_data(0xffffffff,puVar9,rl_undo_list);\n      if ((_rl_saved_line_for_history != 0) &&\n         (puVar7 = *(undefined8 **)(_rl_saved_line_for_history + 0x10), puVar7 != (undefined8 *)0x0)\n         ) break;\nLAB_001ea52f:\n      xfree(puVar9);\n      if (iVar8 == 0) {\n        return 1;\n      }\n    }\n    if (puVar7 == puVar9) {\n      *(undefined8 **)(_rl_saved_line_for_history + 0x10) = rl_undo_list;\n      goto LAB_001ea52f;\n    }\n    do {\n      puVar6 = puVar7;\n      puVar7 = (undefined8 *)*puVar6;\n      if (puVar7 == (undefined8 *)0x0) goto LAB_001ea52f;\n    } while (puVar7 != puVar9);\n    *puVar6 = rl_undo_list;\n    xfree(puVar9);\n    if (iVar8 == 0) {\n      return 1;\n    }\n  } while( true );\n}\n\n",
  "_FINI_0": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_002407e8 == '\\0') {\n    if (PTR___cxa_finalize_00237ff0 != (undefined *)0x0) {\n      __cxa_finalize(PTR_LOOP_00238008);\n    }\n    FUN_00133580();\n    DAT_002407e8 = 1;\n    return;\n  }\n  return;\n}\n\n",
  "setup_ignore_patterns": "\nvoid setup_ignore_patterns(undefined8 *param_1)\n\n{\n  char **ppcVar1;\n  code *pcVar2;\n  int iVar3;\n  char *__s1;\n  size_t sVar4;\n  char *pcVar5;\n  long lVar6;\n  int iVar7;\n  long *plVar8;\n  int iVar9;\n  long lVar10;\n  int local_44;\n  \n  __s1 = (char *)get_string_value(*param_1);\n  if (__s1 == (char *)0x0) {\n    if (param_1[3] == 0) {\n      return;\n    }\nLAB_00185422:\n    plVar8 = (long *)param_1[1];\n    *(undefined4 *)(param_1 + 2) = 0;\n    if (plVar8 != (long *)0x0) goto LAB_00185436;\n    lVar6 = param_1[3];\nLAB_0018562b:\n    sh_xfree(lVar6,\"pathexp.c\",0x25e);\n    param_1[3] = 0;\n  }\n  else {\n    pcVar5 = (char *)param_1[3];\n    if (pcVar5 != (char *)0x0) {\n      if ((*__s1 == *pcVar5) && (iVar9 = strcmp(__s1,pcVar5), iVar9 == 0)) {\n        return;\n      }\n      goto LAB_00185422;\n    }\n    plVar8 = (long *)param_1[1];\n    *(undefined4 *)(param_1 + 2) = 0;\n    if (plVar8 == (long *)0x0) goto LAB_0018549c;\nLAB_00185436:\n    lVar6 = *plVar8;\n    if (lVar6 != 0) {\n      do {\n        plVar8 = plVar8 + 2;\n        sh_xfree(lVar6,\"pathexp.c\",599);\n        lVar6 = *plVar8;\n      } while (lVar6 != 0);\n      plVar8 = (long *)param_1[1];\n    }\n    sh_xfree(plVar8,\"pathexp.c\",600);\n    lVar6 = param_1[3];\n    param_1[1] = 0;\n    if (lVar6 != 0) goto LAB_0018562b;\n  }\n  if (__s1 == (char *)0x0) {\n    return;\n  }\nLAB_0018549c:\n  if (*__s1 != '\\0') {\n    sVar4 = strlen(__s1);\n    pcVar5 = (char *)sh_xmalloc(sVar4 + 1,\"pathexp.c\",0x265);\n    pcVar5 = strcpy(pcVar5,__s1);\n    param_1[3] = pcVar5;\n    if (*__s1 == '\\0') {\n      lVar6 = param_1[1];\n      lVar10 = 0;\n      iVar9 = 0;\n    }\n    else {\n      local_44 = 0;\n      lVar10 = 0;\n      iVar7 = 0;\n      iVar9 = 0;\n      do {\n        iVar3 = skip_to_delim(__s1,iVar7,\":\",0x51);\n        pcVar5 = (char *)substring(__s1,iVar7,iVar3);\n        iVar7 = (uint)(__s1[iVar3] == ':') + iVar3;\n        lVar6 = param_1[1];\n        if (pcVar5 == (char *)0x0) {\n          lVar10 = (long)iVar9 << 4;\n          goto LAB_001855fe;\n        }\n        iVar9 = iVar9 + 1;\n        if (local_44 <= iVar9) {\n          local_44 = local_44 + 10;\n          lVar6 = sh_xrealloc(lVar6,(long)local_44 << 4,\"pathexp.c\",0x272);\n          param_1[1] = lVar6;\n        }\n        ppcVar1 = (char **)(lVar6 + lVar10);\n        *ppcVar1 = pcVar5;\n        sVar4 = strlen(pcVar5);\n        *(int *)(ppcVar1 + 1) = (int)sVar4;\n        pcVar2 = (code *)param_1[4];\n        *(undefined4 *)((long)ppcVar1 + 0xc) = 0;\n        if (pcVar2 != (code *)0x0) {\n          (*pcVar2)(ppcVar1);\n        }\n        lVar10 = lVar10 + 0x10;\n      } while (__s1[iVar7] != '\\0');\n      lVar10 = (long)iVar9 << 4;\n      lVar6 = param_1[1];\n    }\nLAB_001855fe:\n    *(undefined8 *)(lVar6 + lVar10) = 0;\n    *(int *)(param_1 + 2) = iVar9;\n  }\n  return;\n}\n\n",
  "rl_kill_text": "\nundefined8 rl_kill_text(int param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (param_1 != param_2) {\n    uVar1 = rl_copy_text();\n    rl_delete_text(param_1,param_2);\n    FUN_001e9370(uVar1,param_1 < param_2);\n    _rl_last_command_was_kill = _rl_last_command_was_kill + 1;\n    return 0;\n  }\n  _rl_last_command_was_kill = _rl_last_command_was_kill + 1;\n  return 0;\n}\n\n",
  "FUN_00151990": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong FUN_00151990(long param_1,undefined8 param_2)\n\n{\n  uint uVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  int local_2c;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((*(byte *)(param_1 + 0x28) & 0x10) == 0) {\n    local_2c = legal_number(param_2,&local_28);\n  }\n  else {\n    local_28 = evalexp(param_2,0,&local_2c);\n  }\n  if (local_2c != 0) {\n    sbrand(local_28);\n    if (subshell_environment != 0) {\n      _DAT_002422e8 = getpid();\n    }\n    uVar1 = *(uint *)(param_1 + 0x28);\n    uVar2 = itos(local_28);\n    if (*(long *)(param_1 + 8) != 0) {\n      sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x527);\n    }\n    *(undefined8 *)(param_1 + 8) = uVar2;\n    if ((uVar1 & 0x10) != 0) {\n      *(uint *)(param_1 + 0x28) = *(uint *)(param_1 + 0x28) | 0x10;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return param_1;\n}\n\n",
  "save_token_state": "\nvoid save_token_state(void)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x10,\"/usr/local/src/chet/src/bash/src/parse.y\",0x72d);\n  *puVar1 = DAT_00240d70;\n  puVar1[1] = DAT_00240d6c;\n  puVar1[2] = DAT_00240d68;\n  puVar1[3] = current_token;\n  return;\n}\n\n",
  "strchr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strchr_00237a08)();\n  return pcVar1;\n}\n\n",
  "should_ignore_glob_matches": "\nundefined4 should_ignore_glob_matches(void)\n\n{\n  return DAT_00238b30;\n}\n\n",
  "FUN_00135030": "\nulong FUN_00135030(long param_1)\n\n{\n  int iVar1;\n  ulong uVar2;\n  \n  uVar2 = history_number();\n  iVar1 = (int)uVar2;\n  if ((iVar1 != 1) && (ps1_prompt != param_1)) {\n    if (ps2_prompt == param_1) {\n      if (command_oriented_history != 0) {\n        uVar2 = (ulong)(iVar1 - 1);\n      }\n    }\n    else {\n      uVar2 = (ulong)(iVar1 - 1);\n    }\n  }\n  return uVar2;\n}\n\n",
  "copy_command": "\nundefined8 * copy_command(undefined8 *param_1)\n\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  undefined8 *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  long **pplVar7;\n  undefined8 *puVar8;\n  long *plVar9;\n  long *plVar10;\n  long **pplVar11;\n  long **pplVar12;\n  undefined8 uVar13;\n  undefined4 *puVar14;\n  size_t sVar15;\n  char *__dest;\n  char *pcVar16;\n  undefined8 uVar17;\n  long lVar18;\n  long lVar19;\n  long *plVar20;\n  long **pplVar21;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    puVar8 = (undefined8 *)0x0;\n  }\n  else {\n    puVar8 = (undefined8 *)sh_xmalloc(0x20,\"copy_cmd.c\",0x176);\n    uVar17 = param_1[1];\n    *puVar8 = *param_1;\n    puVar8[1] = uVar17;\n    uVar4 = *(uint *)((long)param_1 + 0x14);\n    uVar5 = *(uint *)(param_1 + 3);\n    uVar6 = *(uint *)((long)param_1 + 0x1c);\n    *(uint *)(puVar8 + 2) = *(uint *)(param_1 + 2);\n    *(uint *)((long)puVar8 + 0x14) = uVar4;\n    *(uint *)(puVar8 + 3) = uVar5;\n    *(uint *)((long)puVar8 + 0x1c) = uVar6;\n    plVar20 = (long *)param_1[2];\n    *(uint *)((long)puVar8 + 4) = *(uint *)((long)param_1 + 4);\n    *(uint *)(puVar8 + 1) = *(uint *)(param_1 + 1);\n    if (plVar20 != (long *)0x0) {\n      plVar10 = (long *)0x0;\n      do {\n        plVar9 = plVar10;\n        plVar10 = (long *)copy_redirect(plVar20);\n        *plVar10 = (long)plVar9;\n        plVar20 = (long *)*plVar20;\n      } while (plVar20 != (long *)0x0);\n      if (plVar9 != (long *)0x0) {\n        plVar10 = (long *)list_reverse(plVar10);\n      }\n      puVar8[2] = plVar10;\n    }\n    if (*(uint *)param_1 < 0xf) {\n      switch(*(uint *)param_1) {\n      default:\n        uVar17 = FUN_0015afb0(param_1[3]);\n        puVar8[3] = uVar17;\n        break;\n      case 1:\n        puVar2 = (undefined4 *)param_1[3];\n        puVar14 = (undefined4 *)sh_xmalloc(0x18,\"copy_cmd.c\",0xff);\n        puVar3 = *(undefined8 **)(puVar2 + 2);\n        *puVar14 = *puVar2;\n        uVar17 = *puVar3;\n        puVar14[1] = puVar2[1];\n        lVar19 = make_bare_word(uVar17);\n        plVar20 = *(long **)(puVar2 + 4);\n        plVar10 = (long *)0x0;\n        *(undefined4 *)(lVar19 + 8) = *(undefined4 *)(puVar3 + 1);\n        *(long *)(puVar14 + 2) = lVar19;\n        if (plVar20 != (long *)0x0) {\n          do {\n            plVar9 = plVar10;\n            plVar10 = (long *)sh_xmalloc(0x20,\"copy_cmd.c\",0x5e);\n            lVar18 = copy_word_list(plVar20[1]);\n            lVar19 = plVar20[2];\n            plVar10[1] = lVar18;\n            lVar19 = copy_command(lVar19);\n            plVar10[2] = lVar19;\n            uVar1 = *(undefined4 *)(plVar20 + 3);\n            *plVar10 = (long)plVar9;\n            plVar20 = (long *)*plVar20;\n            *(undefined4 *)(plVar10 + 3) = uVar1;\n          } while (plVar20 != (long *)0x0);\n          if (plVar9 != (long *)0x0) {\n            plVar10 = (long *)list_reverse(plVar10);\n          }\n        }\n        *(long **)(puVar14 + 4) = plVar10;\n        puVar8[3] = puVar14;\n        break;\n      case 2:\n      case 8:\n        puVar2 = (undefined4 *)param_1[3];\n        puVar14 = (undefined4 *)sh_xmalloc(0x18,\"copy_cmd.c\",0x10d);\n        uVar17 = *(undefined8 *)(puVar2 + 2);\n        *puVar14 = *puVar2;\n        uVar13 = copy_command(uVar17);\n        uVar17 = *(undefined8 *)(puVar2 + 4);\n        *(undefined8 *)(puVar14 + 2) = uVar13;\n        uVar17 = copy_command(uVar17);\n        *(undefined8 *)(puVar14 + 4) = uVar17;\n        puVar8[3] = puVar14;\n        break;\n      case 3:\n        puVar2 = (undefined4 *)param_1[3];\n        puVar14 = (undefined4 *)sh_xmalloc(0x20,\"copy_cmd.c\",0x11a);\n        uVar17 = *(undefined8 *)(puVar2 + 2);\n        *puVar14 = *puVar2;\n        uVar13 = copy_command(uVar17);\n        uVar17 = *(undefined8 *)(puVar2 + 4);\n        *(undefined8 *)(puVar14 + 2) = uVar13;\n        uVar17 = copy_command(uVar17);\n        lVar19 = *(long *)(puVar2 + 6);\n        *(undefined8 *)(puVar14 + 4) = uVar17;\n        if (lVar19 != 0) {\n          lVar19 = copy_command();\n        }\n        *(long *)(puVar14 + 6) = lVar19;\n        puVar8[3] = puVar14;\n        break;\n      case 4:\n        puVar2 = (undefined4 *)param_1[3];\n        puVar14 = (undefined4 *)sh_xmalloc(0x18,\"copy_cmd.c\",0x14b);\n        uVar17 = *(undefined8 *)(puVar2 + 2);\n        *puVar14 = *puVar2;\n        uVar17 = copy_word_list(uVar17);\n        pplVar12 = *(long ***)(puVar2 + 4);\n        *(undefined8 *)(puVar14 + 2) = uVar17;\n        if (pplVar12 != (long **)0x0) {\n          pplVar7 = (long **)0x0;\n          pplVar21 = pplVar12;\n          do {\n            pplVar11 = pplVar7;\n            pplVar12 = (long **)copy_redirect(pplVar21);\n            *pplVar12 = (long *)pplVar11;\n            pplVar21 = (long **)*pplVar21;\n            pplVar7 = pplVar12;\n          } while (pplVar21 != (long **)0x0);\n          if (pplVar11 != (long **)0x0) {\n            pplVar12 = (long **)list_reverse(pplVar12);\n          }\n        }\n        uVar1 = puVar2[1];\n        *(long ***)(puVar14 + 4) = pplVar12;\n        puVar14[1] = uVar1;\n        puVar8[3] = puVar14;\n        break;\n      case 6:\n        lVar19 = sh_xmalloc(0x20,\"copy_cmd.c\",0x1be);\n        uVar17 = *(undefined8 *)(param_1[3] + 8);\n        *(undefined4 *)(lVar19 + 0x18) = *(undefined4 *)(param_1[3] + 0x18);\n        uVar17 = copy_command(uVar17);\n        *(undefined8 *)(lVar19 + 8) = uVar17;\n        uVar17 = copy_command(*(undefined8 *)(param_1[3] + 0x10));\n        *(undefined8 *)(lVar19 + 0x10) = uVar17;\n        puVar8[3] = lVar19;\n        break;\n      case 7:\n        uVar17 = param_1[3];\n        uVar13 = sh_xmalloc(0x20,\"copy_cmd.c\",0x165);\n        uVar17 = copy_function_def_contents(uVar17,uVar13);\n        puVar8[3] = uVar17;\n        break;\n      case 9:\n        lVar19 = param_1[3];\n        lVar18 = sh_xmalloc(0x10,\"copy_cmd.c\",0xda);\n        uVar17 = copy_command(*(undefined8 *)(lVar19 + 8));\n        *(undefined8 *)(lVar18 + 8) = uVar17;\n        puVar8[3] = lVar18;\n        break;\n      case 10:\n        puVar2 = (undefined4 *)param_1[3];\n        puVar14 = (undefined4 *)sh_xmalloc(0x10,\"copy_cmd.c\",0x129);\n        uVar17 = *(undefined8 *)(puVar2 + 2);\n        *puVar14 = *puVar2;\n        uVar17 = copy_word_list(uVar17);\n        *(undefined8 *)(puVar14 + 2) = uVar17;\n        puVar14[1] = puVar2[1];\n        puVar8[3] = puVar14;\n        break;\n      case 0xb:\n        uVar17 = FUN_0015a750(param_1[3]);\n        puVar8[3] = uVar17;\n        break;\n      case 0xc:\n        puVar2 = (undefined4 *)param_1[3];\n        puVar14 = (undefined4 *)sh_xmalloc(0x28,\"copy_cmd.c\",0xc9);\n        uVar17 = *(undefined8 *)(puVar2 + 2);\n        *puVar14 = *puVar2;\n        puVar14[1] = puVar2[1];\n        uVar13 = copy_word_list(uVar17);\n        uVar17 = *(undefined8 *)(puVar2 + 4);\n        *(undefined8 *)(puVar14 + 2) = uVar13;\n        uVar13 = copy_word_list(uVar17);\n        uVar17 = *(undefined8 *)(puVar2 + 6);\n        *(undefined8 *)(puVar14 + 4) = uVar13;\n        uVar13 = copy_word_list(uVar17);\n        uVar17 = *(undefined8 *)(puVar2 + 8);\n        *(undefined8 *)(puVar14 + 6) = uVar13;\n        uVar17 = copy_command(uVar17);\n        *(undefined8 *)(puVar14 + 8) = uVar17;\n        puVar8[3] = puVar14;\n        break;\n      case 0xd:\n        puVar2 = (undefined4 *)param_1[3];\n        puVar14 = (undefined4 *)sh_xmalloc(0x10,\"copy_cmd.c\",0xe5);\n        uVar17 = copy_command(*(undefined8 *)(puVar2 + 2));\n        *(undefined8 *)(puVar14 + 2) = uVar17;\n        *puVar14 = *puVar2;\n        puVar14[1] = puVar2[1];\n        puVar8[3] = puVar14;\n        break;\n      case 0xe:\n        puVar2 = (undefined4 *)param_1[3];\n        puVar14 = (undefined4 *)sh_xmalloc(0x18,\"copy_cmd.c\",0xf2);\n        pcVar16 = *(char **)(puVar2 + 2);\n        sVar15 = strlen(pcVar16);\n        __dest = (char *)sh_xmalloc(sVar15 + 1,\"copy_cmd.c\",0xf3);\n        pcVar16 = strcpy(__dest,pcVar16);\n        uVar17 = *(undefined8 *)(puVar2 + 4);\n        *(char **)(puVar14 + 2) = pcVar16;\n        uVar17 = copy_command(uVar17);\n        *(undefined8 *)(puVar14 + 4) = uVar17;\n        *puVar14 = *puVar2;\n        puVar8[3] = puVar14;\n      }\n    }\n  }\n  return puVar8;\n}\n\n",
  "FUN_001b19a0": "\nint FUN_001b19a0(int param_1)\n\n{\n  if (param_1 == 0x2d) {\n    enable_history_list = 1;\n    bash_history_enable();\n    if (history_lines_this_session == 0) {\n      load_history();\n      return 1 - enable_history_list;\n    }\n  }\n  else {\n    enable_history_list = 0;\n    bash_history_disable();\n  }\n  return 1 - enable_history_list;\n}\n\n",
  "rl_set_keyboard_input_timeout": "\nint rl_set_keyboard_input_timeout(int param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = DAT_00240538;\n  if (-1 < param_1) {\n    DAT_00240538 = param_1;\n  }\n  return iVar1;\n}\n\n",
  "rl_forward_search_history": "\nvoid rl_forward_search_history(void)\n\n{\n  FUN_001e0330();\n  return;\n}\n\n",
  "string_to_rlimtype": "\nlong string_to_rlimtype(char *param_1)\n\n{\n  char cVar1;\n  long lVar2;\n  bool bVar3;\n  bool bVar4;\n  \n  if (param_1 != (char *)0x0) {\n    for (; cVar1 = *param_1, cVar1 != '\\0'; param_1 = param_1 + 1) {\n      if ((cVar1 != ' ') && (cVar1 != '\\t')) {\n        bVar3 = cVar1 == '-';\n        bVar4 = (cVar1 - 0x2bU & 0xfd) == 0;\n        if (bVar4) {\n          cVar1 = param_1[1];\n          param_1 = param_1 + 1;\n        }\n        lVar2 = 0;\n        while ((byte)(cVar1 - 0x30U) < 10) {\n          param_1 = param_1 + 1;\n          lVar2 = (long)(char)(cVar1 - 0x30U) + lVar2 * 10;\n          cVar1 = *param_1;\n        }\n        if (bVar4 && bVar3) {\n          lVar2 = -lVar2;\n        }\n        return lVar2;\n      }\n    }\n  }\n  return 0;\n}\n\n",
  "rl_free_keymap": "\nvoid rl_free_keymap(long param_1)\n\n{\n  if (param_1 != 0) {\n    FUN_001d42a0();\n  }\n  xfree(param_1);\n  return;\n}\n\n",
  "FUN_00195580": "\nvoid FUN_00195580(void)\n\n{\n  undefined *puVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined4 uVar5;\n  \n  puVar1 = rl_filename_quoting_function;\n  if (rl_editing_mode == 1) {\n    rl_explicit_arg = 1;\n  }\n  rl_filename_quoting_function = FUN_00195af0;\n  uVar5 = rl_completion_mode(FUN_00195580);\n  uVar4 = rl_completion_entry_function;\n  uVar3 = rl_attempted_completion_function;\n  uVar2 = rl_ignore_some_completions_function;\n  rl_attempted_completion_function = 0;\n  rl_completion_entry_function = FUN_00192780;\n  rl_complete_internal(uVar5);\n  rl_completion_entry_function = (code *)uVar4;\n  rl_attempted_completion_function = uVar3;\n  rl_ignore_some_completions_function = uVar2;\n  rl_filename_quoting_function = puVar1;\n  return;\n}\n\n",
  "wmatchlen": "\nint wmatchlen(int *param_1)\n\n{\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  int iVar4;\n  int *piVar5;\n  int *piVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  \n  iVar7 = *param_1;\n  if (iVar7 == 0) {\n    return iVar7;\n  }\n  bVar3 = false;\n  bVar1 = false;\n  iVar10 = 0;\n  bVar2 = false;\n  piVar5 = param_1 + 1;\nLAB_001c4460:\n  if (iVar7 < 0x41) {\n    if (0x20 < iVar7) {\n      switch(iVar7) {\n      case 0x21:\n      case 0x2b:\n      case 0x3f:\n      case 0x40:\n        if (param_1[1] == 0x28) {\n          return -1;\n        }\n        break;\n      case 0x2a:\n        return -1;\n      }\n    }\nswitchD_001c4479_caseD_22:\n    iVar7 = *piVar5;\n    iVar10 = iVar10 + 1;\n    piVar6 = piVar5 + 1;\n    param_1 = piVar5;\n  }\n  else {\n    if (iVar7 == 0x5b) {\n      piVar5 = param_1 + 2;\n      iVar7 = param_1[1];\n      iVar4 = 1;\nLAB_001c4511:\n      iVar9 = iVar4;\n      piVar6 = piVar5;\n      if (iVar7 == 0) {\n        iVar7 = piVar6[-1];\n        param_1 = piVar6 + -1;\n        iVar10 = iVar10 + iVar9;\n        goto LAB_001c4497;\n      }\n      piVar5 = piVar6 + 1;\n      iVar8 = *piVar6;\n      iVar4 = iVar9 + 1;\n      if (iVar7 == 0x5c) {\n        if ((iVar8 == 0) || (iVar8 = piVar6[1], piVar6 = piVar5, iVar8 == 0)) {\n          return iVar4 + iVar10;\n        }\n      }\n      else {\n        if (iVar7 == 0x5b) {\n          if (iVar8 == 0x3a) {\n            iVar8 = piVar6[1];\n            bVar1 = true;\n            piVar6 = piVar5;\n            goto LAB_001c4505;\n          }\n          if (iVar8 == 0x2e) {\n            iVar7 = piVar6[1];\n            bVar2 = true;\n            piVar5 = piVar6 + 2;\n            if (iVar7 != 0x5d) goto LAB_001c4511;\n            iVar8 = piVar6[2];\n          }\n          else {\n            if (iVar8 != 0x3d) goto LAB_001c4505;\n            iVar7 = piVar6[1];\n            bVar3 = true;\n            piVar5 = piVar6 + 2;\n            if (iVar7 != 0x5d) goto LAB_001c4511;\n            iVar8 = piVar6[2];\n          }\n          iVar4 = iVar9 + 2;\n          param_1 = piVar6 + 3;\n          piVar6 = piVar6 + 2;\n          goto joined_r0x001c457f;\n        }\n        if ((iVar7 == 0x3a) && (bVar1)) {\n          if (iVar8 == 0x5d) {\n            iVar8 = piVar6[1];\n            bVar1 = false;\n            piVar6 = piVar5;\n          }\n          goto LAB_001c4505;\n        }\n        if ((iVar7 == 0x2e) && (bVar2)) {\n          iVar7 = iVar8;\n          if (iVar8 != 0x5d) goto LAB_001c4511;\n          iVar8 = piVar6[1];\n          bVar2 = false;\n          piVar6 = piVar5;\n        }\n        else if ((iVar7 == 0x3d) && (bVar3)) {\n          iVar7 = iVar8;\n          if (iVar8 != 0x5d) goto LAB_001c4511;\n          iVar8 = piVar6[1];\n          bVar3 = false;\n          piVar6 = piVar5;\n        }\n      }\nLAB_001c4505:\n      param_1 = piVar6 + 1;\njoined_r0x001c457f:\n      piVar5 = param_1;\n      iVar7 = iVar8;\n      if (iVar8 == 0x5d) goto LAB_001c4588;\n      goto LAB_001c4511;\n    }\n    if (iVar7 != 0x5c) goto switchD_001c4479_caseD_22;\n    iVar10 = iVar10 + 1;\n    if (param_1[1] == 0) {\n      return iVar10;\n    }\n    iVar7 = param_1[2];\n    piVar6 = param_1 + 3;\n    param_1 = param_1 + 2;\n  }\n  goto LAB_001c4497;\nLAB_001c4588:\n  iVar7 = piVar6[1];\n  iVar10 = iVar10 + 1;\n  piVar6 = piVar6 + 2;\nLAB_001c4497:\n  piVar5 = piVar6;\n  if (iVar7 == 0) {\n    return iVar10;\n  }\n  goto LAB_001c4460;\n}\n\n",
  "gettimeofday": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint gettimeofday(timeval *__tv,__timezone_ptr_t __tz)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_gettimeofday_00237a48)();\n  return iVar1;\n}\n\n",
  "FUN_00147c70": "\nvoid FUN_00147c70(undefined8 param_1)\n\n{\n  do_redirections(param_1,1);\n  dispose_redirects(param_1);\n  return;\n}\n\n",
  "array_copy": "\nundefined8 * array_copy(undefined8 *param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  undefined8 *puVar6;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    return (undefined8 *)0x0;\n  }\n  puVar4 = (undefined8 *)array_create();\n  *puVar4 = *param_1;\n  puVar4[1] = param_1[1];\n  puVar6 = (undefined8 *)((undefined8 *)param_1[2])[2];\n  if ((undefined8 *)param_1[2] != puVar6) {\n    do {\n      while( true ) {\n        lVar5 = array_create_element(*puVar6,puVar6[1]);\n        lVar1 = puVar4[2];\n        lVar2 = *(long *)(lVar1 + 0x18);\n        *(long *)(lVar2 + 0x10) = lVar5;\n        *(long *)(lVar5 + 0x18) = lVar2;\n        puVar3 = (undefined8 *)param_1[2];\n        *(long *)(lVar1 + 0x18) = lVar5;\n        *(long *)(lVar5 + 0x10) = lVar1;\n        if ((undefined8 *)param_1[3] == (undefined8 *)0x0) break;\n        if ((undefined8 *)param_1[3] != puVar6) goto LAB_00188ca5;\nLAB_00188ce9:\n        puVar6 = (undefined8 *)puVar6[2];\n        puVar4[3] = lVar5;\n        if (puVar3 == puVar6) {\n          return puVar4;\n        }\n      }\n      if ((undefined8 *)puVar3[2] == puVar6) goto LAB_00188ce9;\nLAB_00188ca5:\n      puVar6 = (undefined8 *)puVar6[2];\n    } while (puVar3 != puVar6);\n  }\n  return puVar4;\n}\n\n",
  "strlist_from_word_list": "\nundefined8 * strlist_from_word_list(long param_1,undefined4 param_2,int param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined4 local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    puVar2 = (undefined8 *)0x0;\n    if (param_4 != (undefined4 *)0x0) {\n      *param_4 = 0;\n    }\n  }\n  else {\n    iVar1 = list_length();\n    puVar2 = (undefined8 *)sh_xmalloc(0x10,\"stringlist.c\",0x114);\n    uVar3 = strvec_from_word_list(param_1,param_2,param_3,&local_44);\n    *puVar2 = uVar3;\n    *(int *)(puVar2 + 1) = iVar1 + param_3;\n    *(undefined4 *)((long)puVar2 + 0xc) = local_44;\n    if (param_4 != (undefined4 *)0x0) {\n      *param_4 = local_44;\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "user_command_matches": "\nvoid user_command_matches(undefined8 param_1,undefined4 param_2,int param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  long lVar3;\n  long lVar4;\n  long lVar5;\n  undefined8 uVar6;\n  long in_FS_OFFSET;\n  int local_ec;\n  int local_dc;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_3 == 0) {\n    if (DAT_002489e0 == (undefined8 *)0x0) {\n      DAT_002489dc = 5;\n      DAT_002489e0 = (undefined8 *)strvec_create(5);\n    }\n    if (0 < DAT_002489dc) {\n      memset(DAT_002489e0,0,(long)DAT_002489dc << 3);\n    }\n    DAT_002489d8 = 0;\n    iVar2 = absolute_program(param_1);\n    puVar1 = DAT_002489e0;\n    if (iVar2 == 0) {\n      DAT_002489e8 = 0;\n      dot_found_in_search = 0;\n      iVar2 = stat(\".\",&local_d8);\n      if (iVar2 < 0) {\n        local_d8.st_ino = 0;\n        local_d8.st_dev = 0;\n      }\n      lVar3 = get_string_value(\"PATH\");\n      local_dc = 0;\n    }\n    else {\n      uVar6 = FUN_0019b300(param_1,param_2);\n      *puVar1 = uVar6;\n      lVar3 = 0;\n      DAT_002489e0[1] = 0;\n    }\n    while (lVar3 != 0) {\n      while( true ) {\n        if ((*(char *)(lVar3 + local_dc) == '\\0') ||\n           (lVar4 = FUN_0019b1b0(lVar3,&local_dc), lVar4 == 0)) goto LAB_0019be31;\n        lVar5 = FUN_0019b360(param_1,lVar4,param_2,&local_d8,0);\n        sh_xfree(lVar4,\"findcmd.c\",0x1d7);\n        if (lVar5 == 0) break;\n        iVar2 = DAT_002489d8 + 1;\n        if (iVar2 == DAT_002489dc) {\n          DAT_002489dc = DAT_002489d8 + 0xb;\n          DAT_002489e0 = (undefined8 *)strvec_resize(DAT_002489e0,DAT_002489d8 + 0xc);\n          iVar2 = DAT_002489d8 + 1;\n        }\n        puVar1 = DAT_002489e0;\n        lVar4 = (long)DAT_002489d8;\n        DAT_002489d8 = iVar2;\n        DAT_002489e0[lVar4] = lVar5;\n        puVar1[iVar2] = 0;\n        if (DAT_002489e8 != 0) {\n          sh_xfree(DAT_002489e8,\"findcmd.c\",0x1e4);\n        }\n        DAT_002489e8 = 0;\n        if (lVar3 == 0) goto LAB_0019be31;\n      }\n    }\nLAB_0019be31:\n    lVar3 = 0;\n    local_ec = 0;\n  }\n  else {\n    local_ec = DAT_002489d8;\n    lVar3 = (long)DAT_002489d8 << 3;\n  }\n  DAT_002489d8 = local_ec;\n  if (*(long *)((long)DAT_002489e0 + lVar3) != 0) {\n    DAT_002489d8 = local_ec + 1;\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "builtin_arrayref_flags": "\nuint builtin_arrayref_flags(long param_1,uint param_2)\n\n{\n  if ((*(byte *)(param_1 + 9) & 2) != 0) {\n    param_2 = param_2 | 3;\n  }\n  return param_2;\n}\n\n",
  "add_or_supercede_exported_var": "\nchar ** add_or_supercede_exported_var(char *param_1,int param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  char **ppcVar5;\n  size_t sVar6;\n  char *pcVar7;\n  long lVar8;\n  long lVar9;\n  \n  iVar3 = assignment(param_1,0);\n  iVar2 = DAT_00242334;\n  ppcVar5 = export_env;\n  if (iVar3 == 0) {\n    return export_env;\n  }\n  if ((((param_1[(long)iVar3 + 1] == '(') && (pcVar7 = param_1 + (long)iVar3 + 2, *pcVar7 == ')'))\n      && (pcVar7[1] == ' ')) && (pcVar7[2] == '{')) {\n    iVar3 = iVar3 + 4;\n  }\n  lVar8 = (long)DAT_00242334;\n  if (0 < DAT_00242334) {\n    pcVar7 = *export_env;\n    if (iVar3 == -1) {\n      lVar9 = 0;\nLAB_0015753a:\n      sh_xfree(pcVar7,\"variables.c\",0x13ab);\n      if (param_2 != 0) {\n        sVar6 = strlen(param_1);\n        pcVar7 = (char *)sh_xmalloc(sVar6 + 1,\"variables.c\",0x13ac);\n        param_1 = strcpy(pcVar7,param_1);\n      }\n      ppcVar5 = export_env;\n      *(char **)((long)export_env + lVar9) = param_1;\n      return ppcVar5;\n    }\n    cVar1 = *param_1;\n    lVar9 = 0;\n    do {\n      pcVar7 = *(char **)((long)ppcVar5 + lVar9);\n      if ((cVar1 == *pcVar7) && (iVar4 = strncmp(param_1,pcVar7,(long)(iVar3 + 1)), iVar4 == 0))\n      goto LAB_0015753a;\n      lVar9 = lVar9 + 8;\n    } while (lVar8 * 8 - lVar9 != 0);\n  }\n  if (DAT_00242330 + -1 <= iVar2) {\n    DAT_00242330 = DAT_00242330 + 0x10;\n    environ = (char **)strvec_resize(export_env);\n    export_env = environ;\n  }\n  if (param_2 != 0) {\n    sVar6 = strlen(param_1);\n    pcVar7 = (char *)sh_xmalloc(sVar6 + 1,\"variables.c\",0x13b0);\n    param_1 = strcpy(pcVar7,param_1);\n  }\n  ppcVar5 = export_env;\n  export_env[DAT_00242334] = param_1;\n  ppcVar5[(long)DAT_00242334 + 1] = (char *)0x0;\n  DAT_00242334 = DAT_00242334 + 1;\n  return ppcVar5;\n}\n\n",
  "iswctype": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswctype(wint_t __wc,wctype_t __desc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswctype_00237970)();\n  return iVar1;\n}\n\n",
  "FUN_001db960": "\nundefined8 FUN_001db960(char *param_1)\n\n{\n  size_t sVar1;\n  \n  if (param_1 == (char *)0x0) {\n    if (_rl_vi_ins_mode_str != (undefined *)0x0) {\n      free(_rl_vi_ins_mode_str);\n    }\n    _rl_vi_ins_mode_str = (undefined *)0x0;\n    _rl_vi_ins_modestr_len = 0;\n    return 0;\n  }\n  if (*param_1 == '\\0') {\n    if (_rl_vi_ins_mode_str != (undefined *)0x0) {\n      free(_rl_vi_ins_mode_str);\n    }\n    _rl_vi_ins_mode_str = (undefined *)xmalloc(1);\n    _rl_vi_ins_modestr_len = 0;\n    *_rl_vi_ins_mode_str = 0;\n    return 0;\n  }\n  if (_rl_vi_ins_mode_str != (undefined *)0x0) {\n    free(_rl_vi_ins_mode_str);\n  }\n  sVar1 = strlen(param_1);\n  _rl_vi_ins_mode_str = (undefined *)xmalloc(sVar1 * 2 + 1);\n  rl_translate_keyseq(param_1,_rl_vi_ins_mode_str,&_rl_vi_ins_modestr_len);\n  *(undefined *)((long)_rl_vi_ins_mode_str + (long)_rl_vi_ins_modestr_len) = 0;\n  return 0;\n}\n\n",
  "FUN_001d7840": "\nint FUN_001d7840(byte *param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  size_t sVar3;\n  size_t sVar4;\n  int iVar5;\n  byte *__s;\n  int iVar6;\n  long in_FS_OFFSET;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar3 = strlen((char *)param_1);\n  local_38.__count = 0;\n  local_38.__value = (_union_27)0x0;\n  bVar1 = *param_1;\n  if (bVar1 == 0) {\n    iVar6 = 0;\n  }\n  else {\n    iVar5 = 0;\n    iVar6 = 0;\n    __s = param_1;\n    do {\n      while ((0x1f < bVar1 && (bVar1 != 0x7f))) {\n        sVar4 = mbrtowc(&local_3c,(char *)__s,(long)(((int)sVar3 + 1) - iVar5),&local_38);\n        if (sVar4 < 0xfffffffffffffffe) {\n          if (sVar4 == 0) goto LAB_001d7910;\n          iVar5 = iVar5 + (int)sVar4;\n          if (local_3c < L'`') {\n            if (local_3c < L'A') {\n              if (local_3c < L'$') {\n                iVar2 = 1;\n                if (L'\\x1f' < local_3c) goto LAB_001d78e8;\n              }\n              else if ((uint)(local_3c + L'\\xffffffdb') < 0x1b) goto LAB_001d7938;\nLAB_001d78d6:\n              iVar2 = wcwidth(local_3c);\n              if (iVar2 < 0) {\n                iVar2 = 1;\n              }\n            }\n            else {\nLAB_001d7938:\n              iVar2 = 1;\n            }\n          }\n          else {\n            iVar2 = 1;\n            if (0x1d < (uint)(local_3c + L'\\xffffff9f')) goto LAB_001d78d6;\n          }\nLAB_001d78e8:\n          iVar6 = iVar6 + iVar2;\n        }\n        else {\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          iVar6 = iVar6 + 1;\n          iVar5 = iVar5 + 1;\n        }\n        __s = param_1 + iVar5;\n        bVar1 = *__s;\n        if (bVar1 == 0) goto LAB_001d7910;\n      }\n      iVar5 = iVar5 + 1;\n      iVar6 = iVar6 + 2;\n      __s = param_1 + iVar5;\n      bVar1 = *__s;\n    } while (bVar1 != 0);\n  }\nLAB_001d7910:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar6;\n}\n\n",
  "FUN_001bfc60": "\nuint * FUN_001bfc60(uint *param_1,uint *param_2,int param_3)\n\n{\n  bool bVar1;\n  uint *puVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint *puVar7;\n  \n  uVar3 = *param_1;\n  if (uVar3 == 0) {\n    return (uint *)0x0;\n  }\n  if (param_2 <= param_1) {\n    return param_1;\n  }\n  uVar5 = 0;\n  puVar7 = (uint *)0x0;\n  uVar6 = 0;\n  uVar4 = 0;\n  bVar1 = false;\n  do {\n    puVar2 = param_1 + 1;\n    if (bVar1) {\n      uVar3 = *puVar2;\n      bVar1 = false;\n    }\n    else if (uVar3 == 0x5c) {\n      uVar3 = *puVar2;\n      bVar1 = true;\n    }\n    else if ((int)uVar3 < 0x5d) {\n      if (uVar3 == 0x29) {\n        if (uVar4 == 0) {\n          if ((int)uVar5 < 1) {\n            return puVar2;\n          }\n          uVar3 = *puVar2;\n          uVar5 = uVar5 - 1;\n        }\n        else {\nLAB_001bfd40:\n          uVar3 = *puVar2;\n        }\n      }\n      else if (uVar3 == 0x5b) {\n        uVar3 = *puVar2;\n        if (uVar4 == 0) {\n          if ((uVar3 == 0x21) || (uVar4 = 1, puVar7 = puVar2, uVar3 == 0x5e)) {\n            bVar1 = false;\n            uVar4 = 1;\n            puVar7 = param_1 + 2;\n          }\n        }\n        else if ((uVar3 < 0x3e) && ((-0x2400400000000001 >> ((byte)uVar3 & 0x3f) & 1U) == 0)) {\n          uVar6 = uVar3;\n        }\n      }\n      else {\n        if (uVar3 != 0x28) goto LAB_001bfd40;\n        uVar3 = *puVar2;\n        uVar5 = uVar5 + (uVar4 == 0);\n      }\n    }\n    else if (uVar3 == 0x5d) {\n      uVar3 = *puVar2;\n      if (uVar4 != 0) {\n        if ((uVar6 == 0) || (param_1[-1] != uVar6)) {\n          if (puVar7 != param_1) {\n            uVar4 = 0;\n            puVar7 = (uint *)0x0;\n          }\n        }\n        else {\n          uVar6 = 0;\n        }\n      }\n    }\n    else {\n      if ((uVar3 != 0x7c) || ((uVar4 | uVar5) != 0)) goto LAB_001bfd40;\n      if (param_3 == 0x7c) {\n        return puVar2;\n      }\n      uVar3 = *puVar2;\n      uVar4 = 0;\n      uVar5 = 0;\n    }\n    if (uVar3 == 0) {\n      return (uint *)0x0;\n    }\n    param_1 = puVar2;\n    if (param_2 <= puVar2) {\n      return puVar2;\n    }\n  } while( true );\n}\n\n",
  "getmaxgroups": "\nulong getmaxgroups(void)\n\n{\n  ulong uVar1;\n  \n  if (0 < (int)DAT_0023b308) {\n    return (ulong)DAT_0023b308;\n  }\n  uVar1 = sysconf(3);\n  if (0 < (int)uVar1) {\n    DAT_0023b308 = (int)uVar1;\n    return uVar1;\n  }\n  DAT_0023b308 = 0x40;\n  return 0x40;\n}\n\n",
  "dequote_word": "\nchar ** dequote_word(char **param_1)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  pcVar2 = (char *)dequote_string(*param_1);\n  pcVar1 = *param_1;\n  if ((*pcVar1 == '\\x7f') && (pcVar1[1] == '\\0')) {\n    *(uint *)(param_1 + 1) = *(uint *)(param_1 + 1) & 0xfffbffff;\n  }\n  sh_xfree(pcVar1,\"subst.c\",0x1352);\n  *param_1 = pcVar2;\n  return param_1;\n}\n\n",
  "rl_vi_fWord": "\nundefined8 rl_vi_fWord(int param_1)\n\n{\n  char cVar1;\n  size_t sVar2;\n  ulong uVar3;\n  uint uVar4;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\nLAB_001d0968:\n  uVar3 = (ulong)rl_point;\n  if ((int)(rl_end - 1) <= (int)rl_point) {\n    return 0;\n  }\n  uVar4 = rl_point;\n  if (*(char *)(rl_line_buffer + (int)rl_point) == ' ') goto LAB_001d0a20;\n  if (*(char *)(rl_line_buffer + (int)rl_point) == '\\t') {\n    cVar1 = '\\t';\n  }\n  else {\n    do {\n      if ((int)rl_end <= (int)uVar3) {\n        uVar3 = (ulong)(int)rl_point;\n        cVar1 = *(char *)(rl_line_buffer + uVar3);\n        break;\n      }\n      sVar2 = __ctype_get_mb_cur_max();\n      uVar4 = rl_point;\n      if ((sVar2 == 1) || (rl_byte_oriented != 0)) {\n        rl_point = rl_point + 1;\n        uVar3 = (ulong)rl_point;\n      }\n      else {\n        rl_point = _rl_forward_char_internal(1);\n        uVar3 = (ulong)rl_end;\n        if ((rl_point == uVar4) || ((int)rl_end < (int)rl_point)) {\n          rl_point = rl_end;\n        }\n        else {\n          uVar3 = (ulong)rl_point;\n        }\n      }\n      uVar4 = (uint)uVar3;\n      cVar1 = *(char *)(rl_line_buffer + (int)uVar4);\n      if (cVar1 == ' ') goto LAB_001d0a20;\n    } while (cVar1 != '\\t');\n  }\n  do {\n    uVar4 = (uint)uVar3;\n    if ((cVar1 != ' ') && (cVar1 != '\\t')) break;\nLAB_001d0a20:\n    if ((int)rl_end <= (int)uVar4) break;\n    sVar2 = __ctype_get_mb_cur_max();\n    uVar4 = rl_point;\n    if ((sVar2 == 1) || (rl_byte_oriented != 0)) {\n      rl_point = rl_point + 1;\n      uVar3 = (ulong)rl_point;\n    }\n    else {\n      rl_point = _rl_forward_char_internal(1);\n      uVar3 = (ulong)rl_end;\n      if ((rl_point == uVar4) || ((int)rl_end < (int)rl_point)) {\n        rl_point = rl_end;\n      }\n      else {\n        uVar3 = (ulong)rl_point;\n      }\n    }\n    cVar1 = *(char *)(rl_line_buffer + (int)uVar3);\n  } while( true );\n  param_1 = param_1 + -1;\n  if (param_1 == 0) {\n    return 0;\n  }\n  goto LAB_001d0968;\n}\n\n",
  "copy_fifo_list": "\nvoid * copy_fifo_list(int *param_1)\n\n{\n  int iVar1;\n  void *pvVar2;\n  \n  iVar1 = DAT_00247830;\n  if ((DAT_00247834 != 0) && (DAT_00247830 != 0)) {\n    if (param_1 != (int *)0x0) {\n      *param_1 = DAT_00247830;\n    }\n    pvVar2 = (void *)sh_xmalloc((long)iVar1 << 2,\"subst.c\",0x1875);\n    pvVar2 = memcpy(pvVar2,DAT_00247838,(long)DAT_00247830 << 2);\n    return pvVar2;\n  }\n  if (param_1 != (int *)0x0) {\n    *param_1 = 0;\n  }\n  return (void *)0x0;\n}\n\n",
  "FUN_00187930": "\nvoid FUN_00187930(undefined8 *param_1)\n\n{\n  if ((*(byte *)(param_1 + 2) & 2) != 0) {\n    clear_string_list_expander();\n  }\n  sh_xfree(param_1[1],\"alias.c\",0xab);\n  sh_xfree(*param_1,\"alias.c\",0xac);\n  sh_xfree(param_1,\"alias.c\",0xad);\n  return;\n}\n\n",
  "sv_history_control": "\nvoid sv_history_control(void)\n\n{\n  int iVar1;\n  long lVar2;\n  char *pcVar3;\n  char *__s1;\n  long in_FS_OFFSET;\n  undefined4 local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  history_control = 0;\n  lVar2 = find_variable();\n  if (lVar2 != 0) {\n    pcVar3 = (char *)get_variable_value(lVar2);\n    if ((pcVar3 != (char *)0x0) && (*pcVar3 != '\\0')) {\n      local_44 = 0;\n      while( true ) {\n        __s1 = (char *)extract_colon_unit(pcVar3,&local_44);\n        if (__s1 == (char *)0x0) break;\n        if (*__s1 == 'i') {\n          iVar1 = strcmp(__s1,\"ignorespace\");\n          if (iVar1 == 0) {\n            history_control = history_control | 1;\n          }\n          else {\n            iVar1 = strcmp(__s1,\"ignoredups\");\n            if (iVar1 == 0) {\n              history_control = history_control | 2;\n            }\n            else {\n              iVar1 = strcmp(__s1,\"ignoreboth\");\n              if (iVar1 == 0) {\n                history_control = history_control | 3;\n              }\n            }\n          }\n        }\n        else if (*__s1 == 'e') {\n          iVar1 = strcmp(__s1,\"erasedups\");\n          if (iVar1 == 0) {\n            history_control = history_control | 4;\n          }\n        }\n        sh_xfree(__s1,\"variables.c\",0x182e);\n      }\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "umask": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__mode_t umask(__mode_t __mask)\n\n{\n  __mode_t _Var1;\n  \n  _Var1 = (*(code *)PTR_umask_00237b40)();\n  return _Var1;\n}\n\n",
  "FUN_00195110": "\nvoid FUN_00195110(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  uVar3 = rl_completion_entry_function;\n  uVar2 = rl_attempted_completion_function;\n  uVar1 = rl_ignore_some_completions_function;\n  rl_completion_entry_function = FUN_00192980;\n  rl_attempted_completion_function = 0;\n  rl_complete_internal(0x3f);\n  rl_completion_entry_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar2;\n  rl_ignore_some_completions_function = uVar1;\n  return;\n}\n\n",
  "rl_trim_arg_from_keyseq": "\nint rl_trim_arg_from_keyseq(long param_1,ulong param_2,undefined *param_3)\n\n{\n  byte bVar1;\n  code *pcVar2;\n  int iVar3;\n  int iVar4;\n  char *pcVar5;\n  int iVar6;\n  ulong uVar7;\n  int iVar8;\n  undefined *puVar9;\n  \n  if (param_3 == (undefined *)0x0) {\n    param_3 = _rl_keymap;\n  }\n  if ((param_1 != 0) && (param_2 != 0)) {\n    iVar3 = 0;\n    iVar8 = 0;\n    iVar6 = 0;\n    uVar7 = 0;\n    puVar9 = param_3;\n    do {\n      bVar1 = *(byte *)(param_1 + uVar7);\n      if ((iVar3 == 0) || (9 < (byte)(bVar1 - 0x30))) {\n        pcVar5 = puVar9 + (ulong)bVar1 * 0x10;\n        if (*pcVar5 == '\\x01') {\n          uVar7 = (ulong)(iVar6 + 1);\n          if (uVar7 == param_2) {\n            return -1;\n          }\n          puVar9 = *(undefined **)(pcVar5 + 8);\n          iVar6 = iVar6 + 1;\n          iVar3 = 0;\n        }\n        else if (*pcVar5 == '\\0') {\n          pcVar2 = *(code **)(pcVar5 + 8);\n          if ((pcVar2 != rl_digit_argument && pcVar2 != rl_universal_argument) &&\n             (pcVar2 != (code *)PTR_rl_vi_arg_digit_00237f68)) {\n            return iVar8;\n          }\n          iVar8 = iVar6 + 1;\n          uVar7 = (ulong)iVar8;\n          if (uVar7 == param_2) {\n            return -1;\n          }\n          if ((pcVar2 == rl_universal_argument) && (iVar6 == 0x2c)) {\n            uVar7 = 0x2e;\n            iVar8 = 0x2e;\n            iVar4 = 2;\n            iVar3 = 2;\n          }\n          else {\n            iVar4 = 1;\n            iVar3 = 1;\n          }\n          puVar9 = param_3;\n          iVar6 = iVar8;\n          if ((bVar1 == 0x2d) && (iVar3 = iVar4, pcVar2 == rl_digit_argument)) {\n            iVar3 = 2;\n          }\n        }\n        else {\n          uVar7 = (ulong)(iVar6 + 1);\n          iVar6 = iVar6 + 1;\n          iVar3 = 0;\n        }\n      }\n      else {\n        iVar8 = iVar6 + 1;\n        uVar7 = (ulong)iVar8;\n        iVar6 = iVar8;\n      }\n      if (param_2 <= uVar7) {\n        return -1;\n      }\n    } while( true );\n  }\n  return -1;\n}\n\n",
  "sh_openpipe": "\nint sh_openpipe(int *param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = pipe(param_1);\n  if (-1 < iVar1) {\n    iVar1 = move_to_high_fd(*param_1,1,0x40);\n    *param_1 = iVar1;\n    iVar1 = move_to_high_fd(param_1[1],1,0x40);\n    param_1[1] = iVar1;\n    iVar1 = 0;\n  }\n  return iVar1;\n}\n\n",
  "FUN_001b5cf0": "\nvoid FUN_001b5cf0(ulong param_1)\n\n{\n  uint uVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  bool bVar3;\n  undefined local_1c [4];\n  undefined local_18 [4];\n  undefined local_14 [4];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  bVar3 = (param_1 & 0x100) == 0;\n  if (bVar3) {\n    local_1c[0] = 0x72;\n  }\n  uVar1 = (uint)bVar3;\n  if ((param_1 & 0x80) == 0) {\n    lVar2 = (long)(int)uVar1;\n    uVar1 = uVar1 + 1;\n    local_1c[lVar2] = 0x77;\n  }\n  if ((param_1 & 0x40) == 0) {\n    lVar2 = (long)(int)uVar1;\n    uVar1 = uVar1 + 1;\n    local_1c[lVar2] = 0x78;\n  }\n  local_1c[(int)uVar1] = 0;\n  bVar3 = (param_1 & 0x20) == 0;\n  if (bVar3) {\n    local_18[0] = 0x72;\n  }\n  uVar1 = (uint)bVar3;\n  if ((param_1 & 0x10) == 0) {\n    lVar2 = (long)(int)uVar1;\n    uVar1 = uVar1 + 1;\n    local_18[lVar2] = 0x77;\n  }\n  if ((param_1 & 8) == 0) {\n    lVar2 = (long)(int)uVar1;\n    uVar1 = uVar1 + 1;\n    local_18[lVar2] = 0x78;\n  }\n  local_18[(int)uVar1] = 0;\n  bVar3 = (param_1 & 4) == 0;\n  if (bVar3) {\n    local_14[0] = 0x72;\n  }\n  uVar1 = (uint)bVar3;\n  if ((param_1 & 2) == 0) {\n    lVar2 = (long)(int)uVar1;\n    uVar1 = uVar1 + 1;\n    local_14[lVar2] = 0x77;\n  }\n  if ((param_1 & 1) == 0) {\n    lVar2 = (long)(int)uVar1;\n    uVar1 = uVar1 + 1;\n    local_14[lVar2] = 0x78;\n  }\n  local_14[(int)uVar1] = 0;\n  __printf_chk(1,\"u=%s,g=%s,o=%s\\n\",local_1c,local_18,local_14);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "assign_in_env": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 assign_in_env(char **param_1,int param_2)\n\n{\n  undefined *puVar1;\n  undefined4 uVar2;\n  int iVar3;\n  uint uVar4;\n  size_t sVar5;\n  char *pcVar6;\n  char *pcVar7;\n  long lVar8;\n  void *pvVar9;\n  char **ppcVar10;\n  char *pcVar11;\n  long lVar12;\n  size_t sVar13;\n  char *pcVar14;\n  bool bVar15;\n  \n  pcVar14 = *param_1;\n  iVar3 = assignment(pcVar14,0);\n  lVar12 = (long)iVar3;\n  sVar5 = strlen(pcVar14);\n  pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"variables.c\",0xe15);\n  pcVar7 = strcpy(pcVar6,pcVar14);\n  pcVar6 = (char *)0x0;\n  pcVar14 = pcVar7;\n  if (pcVar7[lVar12] != '=') goto LAB_001583a6;\n  pcVar7[lVar12] = '\\0';\n  bVar15 = pcVar7[lVar12 + -1] == '+';\n  if (bVar15) {\n    pcVar7[lVar12 + -1] = '\\0';\n  }\n  iVar3 = legal_identifier(pcVar7);\n  if (iVar3 == 0) {\n    sh_invalidid(pcVar7);\n    sh_xfree(pcVar7,\"variables.c\",0xe26);\n    return 0;\n  }\n  ppcVar10 = (char **)find_variable(pcVar7);\n  if (ppcVar10 == (char **)0x0) {\n    ppcVar10 = (char **)find_variable_last_nameref(pcVar7,1);\n    if (ppcVar10 == (char **)0x0) {\n      pcVar6 = (char *)expand_assignment_string_to_string(pcVar7 + lVar12 + 1,0);\n      goto LAB_001583a6;\n    }\n    uVar4 = *(uint *)(ppcVar10 + 5);\n    if ((uVar4 & 0x800) != 0) {\n      iVar3 = valid_nameref_value(ppcVar10[1],2);\n      if (iVar3 != 0) {\n        pcVar14 = ppcVar10[1];\n        pcVar6 = (char *)expand_assignment_string_to_string(pcVar7 + lVar12 + 1,0);\n        goto LAB_001583a6;\n      }\n      goto LAB_00158598;\n    }\n  }\n  else {\n    pcVar14 = *ppcVar10;\nLAB_00158598:\n    uVar4 = *(uint *)(ppcVar10 + 5);\n  }\n  if ((uVar4 & 0x4002) != 0) {\n    if ((uVar4 & 2) != 0) {\n      err_readonly(pcVar7);\n    }\n    sh_xfree(pcVar7,\"variables.c\",0xe43);\n    return 0;\n  }\n  pcVar11 = (char *)expand_assignment_string_to_string(pcVar7 + lVar12 + 1,0);\n  pcVar6 = pcVar11;\n  if (bVar15) {\n    if (pcVar11 == (char *)0x0) {\n      pcVar11 = (char *)sh_xmalloc(1,\"variables.c\",0xe4e);\n      *pcVar11 = '\\0';\n    }\n    pcVar6 = (char *)make_variable_value(ppcVar10,pcVar11,1);\n    sh_xfree(pcVar11,\"variables.c\",0xe52);\n  }\nLAB_001583a6:\n  if (temporary_env == 0) {\n    temporary_env = hash_create(4);\n  }\n  lVar12 = temporary_env;\n  lVar8 = hash_search(pcVar14,temporary_env,0);\n  if ((lVar8 == 0) || (lVar8 = *(long *)(lVar8 + 0x10), _DAT_002422f8 = lVar12, lVar8 == 0)) {\n    lVar8 = FUN_00152bf0(pcVar14,temporary_env);\n  }\n  else if (*(long *)(lVar8 + 8) != 0) {\n    sh_xfree(*(long *)(lVar8 + 8),\"variables.c\",0xe5e);\n  }\n  if (pcVar6 == (char *)0x0) {\n    pcVar6 = (char *)sh_xmalloc(1,\"variables.c\",0xe62);\n    *pcVar6 = '\\0';\n  }\n  uVar2 = variable_context;\n  *(char **)(lVar8 + 8) = pcVar6;\n  *(uint *)(lVar8 + 0x28) = *(uint *)(lVar8 + 0x28) | 0x100001;\n  *(undefined4 *)(lVar8 + 0x2c) = uVar2;\n  if (*(long *)(lVar8 + 0x10) != 0) {\n    sh_xfree(*(long *)(lVar8 + 0x10),\"variables.c\",0xe6a);\n    *(undefined8 *)(lVar8 + 0x10) = 0;\n  }\n  sVar5 = strlen(pcVar14);\n  sVar13 = 0;\n  if (((*pcVar6 != '\\0') && (sVar13 = 1, pcVar6[1] != '\\0')) && (sVar13 = 2, pcVar6[2] != '\\0')) {\n    sVar13 = strlen(pcVar6);\n  }\n  pvVar9 = (void *)sh_xmalloc(sVar13 + 2 + sVar5,\"variables.c\",0x12d2);\n  pvVar9 = memcpy(pvVar9,pcVar14,sVar5);\n  puVar1 = (undefined *)((long)pvVar9 + sVar5);\n  *puVar1 = 0x3d;\n  if (*pcVar6 == '\\0') {\n    puVar1[1] = 0;\n  }\n  else {\n    memcpy(puVar1 + 1,pcVar6,sVar13 + 1);\n  }\n  *(void **)(lVar8 + 0x10) = pvVar9;\n  array_needs_making = 1;\n  if (param_2 != 0) {\n    if ((*pcVar14 == 'P') &&\n       ((iVar3 = strcmp(pcVar14,\"POSIXLY_CORRECT\"), iVar3 == 0 ||\n        (iVar3 = strcmp(pcVar14,\"POSIX_PEDANDTIC\"), iVar3 == 0)))) {\n      save_posix_options();\n    }\n    stupidly_hack_special_variables(pcVar14);\n  }\n  if (echo_command_at_execute != 0) {\n    xtrace_print_assignment(pcVar7,pcVar6,0,1);\n  }\n  sh_xfree(pcVar7,\"variables.c\",0xe7b);\n  return 1;\n}\n\n",
  "_rl_input_queued": "\nvoid _rl_input_queued(int param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = DAT_00240538;\n  if (-1 < param_1) {\n    DAT_00240538 = param_1;\n  }\n  if (rl_input_available_hook == (code *)0x0) {\n    FUN_001eb6c0();\n  }\n  else {\n    (*rl_input_available_hook)();\n  }\n  if (-1 < iVar1) {\n    DAT_00240538 = iVar1;\n  }\n  return;\n}\n\n",
  "FUN_001dc2f0": "\nvoid FUN_001dc2f0(int param_1,long param_2,char *param_3)\n\n{\n  undefined8 uVar1;\n  undefined *puVar2;\n  size_t sVar3;\n  char *pcVar4;\n  char *__dest;\n  long lVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  int iVar10;\n  \n  puVar7 = (undefined8 *)(param_2 + 8);\n  pcVar9 = \"\";\n  if (param_3 != (char *)0x0) {\n    pcVar9 = param_3;\n  }\n  iVar10 = 0;\n  do {\n    if (*(char *)(puVar7 + -1) == '\\x01') {\n      if (param_3 == (char *)0x0) {\n        if (iVar10 == 0x1b) {\n          pcVar4 = (char *)xmalloc(3);\n          lVar6 = 2;\n          lVar5 = 1;\n          __dest = pcVar4;\n          goto LAB_001dc4ae;\n        }\n        __dest = (char *)FUN_001da360(iVar10);\n      }\n      else {\n        sVar3 = strlen(param_3);\n        lVar6 = (long)(int)sVar3;\n        lVar5 = lVar6 + 1;\n        if (iVar10 == 0x1b) {\n          __dest = (char *)xmalloc((long)((int)sVar3 + 3));\n          strcpy(__dest,param_3);\n          pcVar4 = __dest + lVar6;\n          lVar6 = lVar6 + 2;\nLAB_001dc4ae:\n          *pcVar4 = '\\\\';\n          __dest[lVar5] = 'e';\n          __dest[lVar6] = '\\0';\n        }\n        else {\n          pcVar4 = (char *)FUN_001da360(iVar10);\n          sVar3 = strlen(pcVar4);\n          __dest = (char *)xmalloc(sVar3 + lVar5);\n          strcpy(__dest,param_3);\n          strcpy(__dest + lVar6,pcVar4);\n          xfree(pcVar4);\n        }\n      }\n      FUN_001dc2f0(param_1,*puVar7,__dest);\n      xfree(__dest);\n    }\n    else if (*(char *)(puVar7 + -1) == '\\x02') {\n      uVar1 = FUN_001da360(iVar10);\n      puVar2 = (undefined *)_rl_untranslate_macro_value(*puVar7,0);\n      puVar8 = &DAT_00213d70;\n      if (puVar2 != (undefined *)0x0) {\n        puVar8 = puVar2;\n      }\n      if (param_1 == 0) {\n        __fprintf_chk(rl_outstream,1,\"%s%s outputs %s\\n\",pcVar9,uVar1,puVar8);\n      }\n      else {\n        __fprintf_chk(rl_outstream,1,&DAT_0021340f,pcVar9,uVar1,puVar8);\n      }\n      xfree(uVar1);\n      xfree(puVar2);\n    }\n    iVar10 = iVar10 + 1;\n    puVar7 = puVar7 + 2;\n    if (iVar10 == 0x101) {\n      return;\n    }\n  } while( true );\n}\n\n",
  "FUN_001af670": "\nbool FUN_001af670(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar1 = 0;\n  if (DAT_00248b98 != (code *)0x0) {\n    uVar1 = (*DAT_00248b98)();\n  }\n  if (DAT_00248b90 != 0) {\n    uVar2 = rl_insert_text();\n    rl_startup_hook = DAT_00248b98;\n    DAT_00248b90 = 0;\n    DAT_00248b98 = (code *)0x0;\n    uVar1 = uVar1 | uVar2;\n  }\n  return uVar1 != 0;\n}\n\n",
  "progcomp_search": "\nundefined8 progcomp_search(undefined8 param_1)\n\n{\n  long lVar1;\n  \n  if (prog_completes == 0) {\n    return 0;\n  }\n  lVar1 = hash_search(param_1,prog_completes,0);\n  if (lVar1 != 0) {\n    return *(undefined8 *)(lVar1 + 0x10);\n  }\n  return 0;\n}\n\n",
  "FUN_0017fb90": "\nvoid FUN_0017fb90(void **param_1,int param_2)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  undefined8 *puVar6;\n  void *__s;\n  undefined8 *puVar7;\n  \n  if (param_1 == (void **)0x0) {\n    return;\n  }\n  iVar2 = *(int *)(param_1 + 1);\n  if (iVar2 != param_2) {\n    *(int *)(param_1 + 1) = param_2;\n    puVar4 = (undefined8 *)*param_1;\n    __s = (void *)sh_xmalloc((long)param_2 * 8,\"hashlib.c\",0x8b);\n    *param_1 = __s;\n    iVar3 = *(int *)(param_1 + 1);\n    if (0 < iVar3) {\n      __s = memset(__s,0,(long)iVar3 << 3);\n    }\n    if (0 < iVar2) {\n      puVar7 = puVar4;\n      do {\n        puVar6 = (undefined8 *)*puVar7;\n        while (puVar6 != (undefined8 *)0x0) {\n          puVar5 = (undefined8 *)*puVar6;\n          puVar1 = (undefined8 *)((long)__s + (long)(int)(*(uint *)(puVar6 + 3) & iVar3 - 1U) * 8);\n          *puVar6 = *puVar1;\n          *puVar1 = puVar6;\n          puVar6 = puVar5;\n        }\n        puVar7 = puVar7 + 1;\n      } while (puVar4 + (ulong)(iVar2 - 1) + 1 != puVar7);\n    }\n    sh_xfree(puVar4,\"hashlib.c\",0x9a);\n    return;\n  }\n  return;\n}\n\n",
  "tcgetattr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint tcgetattr(int __fd,termios *__termios_p)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_tcgetattr_00237d20)();\n  return iVar1;\n}\n\n",
  "all_variables_matching_prefix": "\nundefined8 * all_variables_matching_prefix(char *param_1)\n\n{\n  int iVar1;\n  long *__base;\n  undefined8 *puVar2;\n  char **ppcVar3;\n  size_t sVar4;\n  char *__dest;\n  char *pcVar5;\n  undefined8 *puVar6;\n  long lVar7;\n  int iVar8;\n  long *plVar9;\n  \n  iVar8 = 0;\n  if ((((param_1 != (char *)0x0) && (*param_1 != '\\0')) && (iVar8 = 1, param_1[1] != '\\0')) &&\n     (iVar8 = 2, param_1[2] != '\\0')) {\n    sVar4 = strlen(param_1);\n    iVar8 = (int)sVar4;\n  }\n  __base = (long *)map_over(FUN_00151280,shell_variables);\n  if (__base != (long *)0x0) {\n    iVar1 = strvec_len(__base);\n    qsort(__base,(long)iVar1,8,FUN_001513a0);\n    lVar7 = 0;\n    do {\n      iVar1 = (int)lVar7;\n      plVar9 = __base + lVar7;\n      lVar7 = lVar7 + 1;\n    } while (*plVar9 != 0);\n    if (iVar1 != 0) {\n      puVar2 = (undefined8 *)strvec_create(iVar1 + 1);\n      ppcVar3 = (char **)*__base;\n      puVar6 = puVar2;\n      if (ppcVar3 != (char **)0x0) {\n        lVar7 = 0;\n        plVar9 = __base + 1;\n        do {\n          while ((pcVar5 = *ppcVar3, iVar8 == 0 ||\n                 ((*param_1 == *pcVar5 && (iVar1 = strncmp(param_1,pcVar5,(long)iVar8), iVar1 == 0))\n                 ))) {\n            sVar4 = strlen(pcVar5);\n            __dest = (char *)sh_xmalloc(sVar4 + 1,\"variables.c\",0x1195);\n            pcVar5 = strcpy(__dest,pcVar5);\n            puVar2[lVar7] = pcVar5;\n            ppcVar3 = (char **)*plVar9;\n            lVar7 = (long)((int)lVar7 + 1);\n            plVar9 = plVar9 + 1;\n            if (ppcVar3 == (char **)0x0) goto LAB_00157359;\n          }\n          ppcVar3 = (char **)*plVar9;\n          plVar9 = plVar9 + 1;\n        } while (ppcVar3 != (char **)0x0);\nLAB_00157359:\n        puVar6 = puVar2 + lVar7;\n      }\n      *puVar6 = 0;\n      sh_xfree(__base,\"variables.c\",0x1198);\n      return puVar2;\n    }\n  }\n  return (undefined8 *)0x0;\n}\n\n",
  "rl_rubout_or_delete": "\nvoid rl_rubout_or_delete(void)\n\n{\n  if ((rl_end != 0) && (rl_end == rl_point)) {\n    _rl_rubout_char();\n    return;\n  }\n  rl_delete();\n  return;\n}\n\n",
  "FUN_001357c0": "\nvoid FUN_001357c0(char *param_1,undefined4 param_2,long param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  size_t sVar3;\n  \n  puVar2 = (undefined8 *)sh_xmalloc(0x40,\"/usr/local/src/chet/src/bash/src/parse.y\",0x776);\n  *(undefined4 *)(puVar2 + 1) = param_2;\n  puVar2[2] = DAT_00240da8;\n  uVar1 = DAT_00240d98;\n  *(undefined4 *)((long)puVar2 + 0x3c) = 0;\n  puVar2[4] = uVar1;\n  uVar1 = DAT_00240d90;\n  puVar2[3] = param_3;\n  puVar2[6] = uVar1;\n  puVar2[5] = DAT_00240da0;\n  *(undefined4 *)(puVar2 + 7) = DAT_00240d8c;\n  if (param_3 == 0) {\n    *puVar2 = pushed_string_list;\n  }\n  else {\n    *(undefined4 *)((long)puVar2 + 0x3c) = 1;\n    *puVar2 = pushed_string_list;\n    *(byte *)(param_3 + 0x10) = *(byte *)(param_3 + 0x10) | 2;\n  }\n  sVar3 = 0;\n  pushed_string_list = puVar2;\n  DAT_00240da8 = param_1;\n  if ((((param_1 != (char *)0x0) && (*param_1 != '\\0')) && (sVar3 = 1, param_1[1] != '\\0')) &&\n     (sVar3 = 2, param_1[2] != '\\0')) {\n    sVar3 = strlen(param_1);\n  }\n  DAT_00240da0 = 0;\n  DAT_00240d8c = 0;\n  DAT_00240d90 = sVar3;\n  DAT_00240d98 = sVar3;\n  FUN_001354e0();\n  return;\n}\n\n",
  "FUN_00151500": "\nundefined8 FUN_00151500(undefined8 param_1,char *param_2)\n\n{\n  size_t sVar1;\n  char *__dest;\n  long lVar2;\n  \n  if (param_2 != (char *)0x0) {\n    if (dollar_vars != (char *)0x0) {\n      sh_xfree(dollar_vars,\"variables.c\",0x61e);\n    }\n    sVar1 = strlen(param_2);\n    __dest = (char *)sh_xmalloc(sVar1 + 1,\"variables.c\",0x61f);\n    dollar_vars = strcpy(__dest,param_2);\n    lVar2 = 1;\n    if (((*param_2 != '\\0') && (lVar2 = 2, param_2[1] != '\\0')) && (lVar2 = 3, param_2[2] != '\\0'))\n    {\n      sVar1 = strlen(param_2);\n      lVar2 = sVar1 + 1;\n    }\n    DAT_002422e0 = (char *)sh_xrealloc(DAT_002422e0,lVar2,\"variables.c\",0x623);\n    shell_name = strcpy(DAT_002422e0,param_2);\n  }\n  return param_1;\n}\n\n",
  "run_error_trap": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid run_error_trap(void)\n\n{\n  if ((_DAT_00247f48 & 0x51) != 1) {\n    return;\n  }\n  FUN_001811f0(0x42,\"error trap\");\n  return;\n}\n\n",
  "get_working_directory": "\nchar * get_working_directory(char *param_1)\n\n{\n  size_t sVar1;\n  char *__dest;\n  char *pcVar2;\n  int *piVar3;\n  \n  if (no_symbolic_links == 0) {\n    if (the_current_working_directory != (char *)0x0) goto LAB_001a46eb;\n  }\n  else {\n    if (the_current_working_directory != (char *)0x0) {\n      sh_xfree(the_current_working_directory,\"common.c\",0x275);\n    }\n    the_current_working_directory = (char *)0x0;\n  }\n  the_current_working_directory = getcwd((char *)0x0,0);\n  if (the_current_working_directory == (char *)0x0) {\n    piVar3 = __errno_location();\n    pcVar2 = strerror(*piVar3);\n    if ((param_1 == (char *)0x0) || (*param_1 == '\\0')) {\n      param_1 = (char *)get_name_for_error();\n    }\n    __fprintf_chk(stderr,1,\"%s: error retrieving current directory: %s: %s\\n\",param_1,\n                  bash_getcwd_errstr,pcVar2);\n    return (char *)0x0;\n  }\nLAB_001a46eb:\n  pcVar2 = the_current_working_directory;\n  sVar1 = strlen(the_current_working_directory);\n  __dest = (char *)sh_xmalloc(sVar1 + 1,\"common.c\",0x289);\n  pcVar2 = strcpy(__dest,pcVar2);\n  return pcVar2;\n}\n\n",
  "all_local_variables": "\nvoid * all_local_variables(int param_1)\n\n{\n  long *plVar1;\n  undefined8 uVar2;\n  void *__base;\n  int iVar3;\n  void **ppvVar4;\n  undefined8 *puVar5;\n  long lVar6;\n  \n  lVar6 = shell_variables;\n  if (shell_variables != 0) {\n    do {\n      if (((*(uint *)(lVar6 + 0xc) & 4) != 0) && (*(int *)(lVar6 + 8) == variable_context)) {\n        if (*(long *)(lVar6 + 0x20) == 0) {\n          return (void *)0x0;\n        }\n        iVar3 = *(int *)(*(long *)(lVar6 + 0x20) + 0xc);\n        if (iVar3 == 0) {\n          return (void *)0x0;\n        }\n        if ((*(uint *)(lVar6 + 0xc) & 1) == 0) {\n          return (void *)0x0;\n        }\n        ppvVar4 = (void **)sh_xmalloc(0x10,\"variables.c\",0x104b);\n        puVar5 = (undefined8 *)sh_xmalloc((long)(iVar3 + 1) << 3,\"variables.c\",0x104c);\n        *(int *)(ppvVar4 + 1) = iVar3;\n        uVar2 = *(undefined8 *)(lVar6 + 0x20);\n        *ppvVar4 = puVar5;\n        *(undefined4 *)((long)ppvVar4 + 0xc) = 0;\n        *puVar5 = 0;\n        if (param_1 == 0) {\n          FUN_00152050(uVar2,FUN_00151320,ppvVar4);\n        }\n        else {\n          FUN_00152050(uVar2,FUN_00151340,ppvVar4);\n        }\n        __base = *ppvVar4;\n        sh_xfree(ppvVar4,\"variables.c\",0x116d);\n        if (__base == (void *)0x0) {\n          return (void *)0x0;\n        }\n        iVar3 = strvec_len(__base);\n        qsort(__base,(long)iVar3,8,FUN_001513a0);\n        return __base;\n      }\n      plVar1 = (long *)(lVar6 + 0x18);\n      lVar6 = *plVar1;\n    } while (*plVar1 != 0);\n  }\n  internal_error(\"all_local_variables: no function context at current scope\");\n  return (void *)0x0;\n}\n\n",
  "mktemp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * mktemp(char *__template)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_mktemp_00237ee0)();\n  return pcVar1;\n}\n\n",
  "_rl_read_mbstring": "\nint _rl_read_mbstring(int param_1,void *param_2,int param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  undefined8 local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  memset(param_2,0,(long)param_3);\n  if ((-1 < param_1) && (0 < param_3)) {\n    lVar2 = 1;\n    do {\n      *(char *)((long)param_2 + lVar2 + -1) = (char)param_1;\n      local_38 = 0;\n      iVar1 = _rl_get_char_len(param_2,&local_38);\n      if (iVar1 != -2) break;\n      rl_readline_state = rl_readline_state | 0x40;\n      param_1 = rl_read_key();\n      rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n      iVar1 = (int)lVar2;\n      lVar2 = lVar2 + 1;\n    } while ((iVar1 < param_3 & (byte)~(byte)((uint)param_1 >> 0x18) >> 7) != 0);\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "hash_copy": "\nlong * hash_copy(long *param_1,code *param_2)\n\n{\n  long lVar1;\n  undefined4 uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  size_t sVar5;\n  char *pcVar6;\n  char *pcVar7;\n  undefined8 *unaff_RBP;\n  long *plVar8;\n  undefined8 *puVar9;\n  long local_60;\n  long *local_40;\n  \n  if (param_1 == (long *)0x0) {\n    local_40 = (long *)0x0;\n  }\n  else {\n    local_40 = (long *)hash_create(*(undefined4 *)(param_1 + 1));\n    if (0 < *(int *)(param_1 + 1)) {\n      local_60 = 0;\n      do {\n        plVar8 = *(long **)(*param_1 + local_60 * 8);\n        lVar3 = *local_40;\n        lVar1 = local_60 * 8;\n        if (plVar8 == (long *)0x0) {\n          unaff_RBP = (undefined8 *)0x0;\n        }\n        else {\n          puVar9 = (undefined8 *)0x0;\n          do {\n            if (puVar9 == (undefined8 *)0x0) {\n              unaff_RBP = (undefined8 *)sh_xmalloc(0x20,\"hashlib.c\",0x68);\n              puVar4 = unaff_RBP;\n            }\n            else {\n              puVar4 = (undefined8 *)sh_xmalloc(0x20,\"hashlib.c\",0x6d);\n              *puVar9 = puVar4;\n            }\n            pcVar7 = (char *)plVar8[1];\n            sVar5 = strlen(pcVar7);\n            pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"hashlib.c\",0x71);\n            pcVar6 = strcpy(pcVar6,pcVar7);\n            pcVar7 = (char *)plVar8[2];\n            puVar4[1] = pcVar6;\n            if (pcVar7 != (char *)0x0) {\n              if (param_2 == (code *)0x0) {\n                sVar5 = strlen(pcVar7);\n                pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"hashlib.c\",0x72);\n                pcVar7 = strcpy(pcVar6,pcVar7);\n              }\n              else {\n                pcVar7 = (char *)(*param_2)();\n              }\n            }\n            uVar2 = *(undefined4 *)(plVar8 + 3);\n            puVar4[2] = pcVar7;\n            *(undefined4 *)(puVar4 + 3) = uVar2;\n            uVar2 = *(undefined4 *)((long)plVar8 + 0x1c);\n            *puVar4 = 0;\n            plVar8 = (long *)*plVar8;\n            *(undefined4 *)((long)puVar4 + 0x1c) = uVar2;\n            puVar9 = puVar4;\n          } while (plVar8 != (long *)0x0);\n        }\n        local_60 = local_60 + 1;\n        *(undefined8 **)(lVar3 + lVar1) = unaff_RBP;\n      } while (*(int *)(param_1 + 1) != (int)local_60 && (int)local_60 <= *(int *)(param_1 + 1));\n    }\n    *(undefined4 *)((long)local_40 + 0xc) = *(undefined4 *)((long)param_1 + 0xc);\n  }\n  return local_40;\n}\n\n",
  "set_pipestatus_array": "\nvoid set_pipestatus_array(int *param_1,int param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long lVar5;\n  long lVar6;\n  long lVar7;\n  long in_FS_OFFSET;\n  undefined local_4c [12];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = find_variable(\"PIPESTATUS\");\n  if (lVar2 == 0) {\n    lVar2 = FUN_00152bf0(\"PIPESTATUS\",*(undefined8 *)(global_variables + 0x20));\n    uVar3 = array_create();\n    *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) | 4;\n    *(undefined8 *)(lVar2 + 8) = uVar3;\n  }\n  else if ((*(byte *)(lVar2 + 0x28) & 4) == 0) goto LAB_0015a570;\n  lVar2 = *(long *)(lVar2 + 8);\n  if ((lVar2 == 0) || (lVar4 = *(long *)(lVar2 + 8), lVar4 == 0)) {\n    lVar4 = 0;\n    if (0 < param_2) {\n      do {\n        uVar3 = inttostr((long)param_1[lVar4],local_4c,0xc);\n        lVar7 = lVar4 + 1;\n        array_insert(lVar2,lVar4,uVar3);\n        lVar4 = lVar7;\n      } while (param_2 != lVar7);\n    }\n  }\n  else {\n    lVar7 = (long)param_2;\n    if (lVar4 == lVar7) {\n      if (param_2 == 1) {\n        lVar2 = *(long *)(*(long *)(lVar2 + 0x10) + 0x10);\n        sh_xfree(*(undefined8 *)(lVar2 + 8),\"variables.c\",0x18f4);\n        uVar3 = itos((long)*param_1);\n        *(undefined8 *)(lVar2 + 8) = uVar3;\n        goto LAB_0015a570;\n      }\n    }\n    else if (lVar4 != lVar7 && lVar7 <= lVar4) {\n      array_flush(lVar2);\n      if (0 < param_2) {\n        lVar4 = 0;\n        do {\n          uVar3 = inttostr((long)param_1[lVar4],local_4c,0xc);\n          lVar6 = lVar4 + 1;\n          array_insert(lVar2,lVar4,uVar3);\n          lVar4 = lVar6;\n        } while (lVar7 != lVar6);\n      }\n      goto LAB_0015a570;\n    }\n    lVar7 = *(long *)(lVar2 + 0x10);\n    if (lVar4 < 1) {\n      iVar1 = 0;\n    }\n    else {\n      lVar4 = 0;\n      do {\n        lVar7 = *(long *)(lVar7 + 0x10);\n        sh_xfree(*(undefined8 *)(lVar7 + 8),\"variables.c\",0x1903);\n        uVar3 = itos((long)param_1[lVar4]);\n        *(undefined8 *)(lVar7 + 8) = uVar3;\n        iVar1 = (int)lVar4 + 1;\n        lVar4 = lVar4 + 1;\n      } while (*(long *)(lVar2 + 8) != lVar4 && lVar4 <= *(long *)(lVar2 + 8));\n    }\n    if (iVar1 < param_2) {\n      lVar4 = (long)iVar1 + 1;\n      lVar7 = lVar4;\n      lVar6 = (long)iVar1;\n      while( true ) {\n        lVar5 = lVar7;\n        uVar3 = inttostr((long)param_1[lVar6],local_4c,0xc);\n        array_insert(lVar2,lVar6,uVar3);\n        if ((ulong)(uint)((param_2 + -1) - iVar1) + lVar4 == lVar5) break;\n        lVar7 = lVar5 + 1;\n        lVar6 = lVar5;\n      }\n    }\n  }\nLAB_0015a570:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "fnx_tofs": "\nundefined8 fnx_tofs(undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
  "FUN_00152830": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined * FUN_00152830(undefined *param_1,long param_2)\n\n{\n  char *pcVar1;\n  undefined8 uVar2;\n  undefined *puVar3;\n  long lVar4;\n  int iVar5;\n  \n  iVar5 = 8;\n  if (param_1 != (undefined *)0x0) {\n    while ((param_1[0x29] & 8) != 0) {\n      iVar5 = iVar5 + -1;\n      if (iVar5 == 0) {\n        return &DAT_00242300;\n      }\n      pcVar1 = *(char **)(param_1 + 8);\n      if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\\0')) {\n        return (undefined *)0x0;\n      }\n      uVar2 = *(undefined8 *)(param_2 + 0x20);\n      lVar4 = hash_search(pcVar1,uVar2,0);\n      if (lVar4 == 0) {\n        return param_1;\n      }\n      puVar3 = *(undefined **)(lVar4 + 0x10);\n      if (puVar3 == (undefined *)0x0) {\n        _DAT_002422f8 = uVar2;\n        return param_1;\n      }\n      param_1 = puVar3;\n      _DAT_002422f8 = uVar2;\n      if (puVar3 == (undefined *)0x0) {\n        return (undefined *)0x0;\n      }\n    }\n  }\n  return param_1;\n}\n\n",
  "ttonechar": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint ttonechar(void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  termios local_58;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00249ee0 == 0) {\n    iVar1 = -1;\n  }\n  else {\n    local_58._48_8_ = DAT_00249f70;\n    local_58.c_cflag = tRam0000000000249f48;\n    local_58.c_ospeed = DAT_00249f78;\n    local_58._16_4_ = _DAT_00249f50;\n    local_58.c_cc._7_4_ = uRam0000000000249f58;\n    local_58.c_cc._11_4_ = uRam0000000000249f5c;\n    local_58.c_cc._15_4_ = _DAT_00249f60;\n    local_58.c_cc._19_4_ = uRam0000000000249f64;\n    local_58.c_cc._23_4_ = uRam0000000000249f68;\n    local_58.c_cc._27_4_ = uRam0000000000249f6c;\n    local_58.c_lflag = uRam0000000000249f4c & 0xfffffffd | 0x8001;\n    local_58.c_iflag = _DAT_00249f40 & 0xffffffbf | 0x100;\n    local_58.c_oflag = uRam0000000000249f44 & 0xffffffc7 | 5;\n    local_58.c_cc._3_2_ = (undefined2)uRam0000000000249f54;\n    local_58.c_cc._5_2_ = 0x100;\n    iVar1 = tcsetattr(0,1,&local_58);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_clean_up_for_exit": "\nvoid _rl_clean_up_for_exit(void)\n\n{\n  if (_rl_echoing_p != 0) {\n    if (0 < _rl_vis_botlin) {\n      _rl_move_vert();\n    }\n    _rl_vis_botlin = 0;\n    fflush(rl_outstream);\n    rl_restart_output(1,0);\n    return;\n  }\n  return;\n}\n\n",
  "rl_vi_unix_word_rubout": "\nundefined8 rl_vi_unix_word_rubout(int param_1)\n\n{\n  char cVar1;\n  char cVar2;\n  long lVar3;\n  int iVar4;\n  ushort **ppuVar5;\n  size_t sVar6;\n  long lVar7;\n  long lVar8;\n  long lVar9;\n  int iVar10;\n  int iVar11;\n  bool bVar12;\n  \n  iVar4 = rl_point;\n  if (rl_point == 0) {\n    rl_ding();\n  }\n  else {\n    if (param_1 < 1) {\n      param_1 = 1;\n    }\n    iVar11 = rl_point;\n    iVar10 = param_1 + -1;\n    do {\n      while (lVar3 = rl_line_buffer, 0 < iVar11) {\n        lVar7 = (long)iVar11;\n        cVar1 = *(char *)(rl_line_buffer + -1 + lVar7);\n        lVar9 = (long)cVar1;\n        cVar2 = *(char *)(rl_line_buffer + lVar7);\n        lVar8 = (long)cVar2;\n        bVar12 = cVar1 == ' ' || cVar1 == '\\t';\n        if (cVar2 == '\\0') {\n          if (bVar12) {\n            do {\n              lVar7 = lVar7 + -1;\n              iVar11 = (int)lVar7;\n              rl_point = iVar11;\n              if (iVar11 < 1) goto LAB_001cfba0;\n              cVar1 = *(char *)(rl_line_buffer + lVar7);\n              lVar8 = (long)cVar1;\n            } while ((cVar1 == ' ') || (cVar1 == '\\t'));\n            cVar1 = *(char *)(rl_line_buffer + -1 + lVar7);\n            lVar9 = (long)cVar1;\n            bVar12 = cVar1 == ' ' || cVar1 == '\\t';\n          }\nLAB_001cfa9a:\n          ppuVar5 = __ctype_b_loc();\n          if (((*(byte *)(*ppuVar5 + lVar8) & 4) == 0) &&\n             ((bVar12 || ((*(byte *)(*ppuVar5 + (char)lVar9) & 4) != 0)))) {\n            iVar11 = iVar11 + -1;\n            rl_point = iVar11;\n            if (iVar11 == 0) break;\n            cVar1 = *(char *)(lVar3 + iVar11);\n            lVar8 = (long)cVar1;\n            lVar9 = (long)*(char *)(lVar3 + -1 + (long)iVar11);\n            if ((cVar1 == ' ') || (cVar1 == '\\t')) goto LAB_001cfbde;\n          }\n          ppuVar5 = __ctype_b_loc();\n          if ((*(byte *)(*ppuVar5 + lVar8) & 4) != 0) goto LAB_001cfbde;\n          while (((iVar11 = rl_point, (char)lVar9 != ' ' && ((char)lVar9 != '\\t')) &&\n                 ((*(byte *)(*ppuVar5 + lVar9) & 4) == 0))) {\n            sVar6 = __ctype_get_mb_cur_max();\n            if ((sVar6 == 1) || (rl_byte_oriented != 0)) {\n              iVar11 = rl_point + -1;\n            }\n            else {\n              iVar11 = _rl_backward_char_internal(1);\n              if (iVar11 < 0) {\n                rl_point = 0;\n                iVar11 = 0;\n                if ((iVar10 == 0) || (iVar10 = iVar10 + -2, iVar10 == -1)) goto LAB_001cfbaa;\n                goto LAB_001cfba0;\n              }\n            }\n            rl_point = iVar11;\n            if (iVar11 < 1) goto LAB_001cfba0;\n            lVar9 = (long)*(char *)(rl_line_buffer + -1 + (long)iVar11);\n          }\n        }\n        else {\n          if ((cVar2 != ' ') && (cVar2 != '\\t')) goto LAB_001cfa9a;\nLAB_001cfbde:\n          for (lVar7 = (long)(iVar11 + -1);\n              ((((char)lVar9 == ' ' || ((char)lVar9 == '\\t')) ||\n               (ppuVar5 = __ctype_b_loc(), iVar11 = rl_point, (*(byte *)(*ppuVar5 + lVar9) & 4) != 0\n               )) && (rl_point = (int)lVar7, iVar11 = rl_point, rl_point != 0)); lVar7 = lVar7 + -1)\n          {\n            lVar9 = (long)*(char *)(lVar3 + -1 + lVar7);\n          }\n        }\n        bVar12 = iVar10 == 0;\n        iVar10 = iVar10 + -1;\n        rl_point = iVar11;\n        if (bVar12) goto LAB_001cfbaa;\n      }\nLAB_001cfba0:\n      bVar12 = iVar10 != 0;\n      iVar10 = iVar10 + -1;\n    } while (bVar12);\nLAB_001cfbaa:\n    rl_kill_text(iVar4,iVar11);\n  }\n  return 0;\n}\n\n",
  "FUN_001da610": "\nundefined8 FUN_001da610(char *param_1)\n\n{\n  long lVar1;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    lVar1 = strtol(param_1,(char **)0x0,10);\n    _rl_keyseq_timeout = (int)lVar1;\n    if (_rl_keyseq_timeout < 0) {\n      _rl_keyseq_timeout = 0;\n    }\n    return 0;\n  }\n  _rl_keyseq_timeout = 0;\n  return 0;\n}\n\n",
  "array_subrange": "\nundefined8\narray_subrange(long *param_1,long param_2,long param_3,int param_4,undefined4 param_5,\n              undefined4 param_6)\n\n{\n  long *plVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  undefined8 uVar5;\n  long *plVar6;\n  \n  if (param_1 == (long *)0x0) {\n    return 0;\n  }\n  plVar1 = (long *)param_1[2];\n  if (plVar1 == (long *)0x0) {\n    return 0;\n  }\n  if (param_1[1] == 0) {\n    return 0;\n  }\n  if (*param_1 < param_2) {\n    return 0;\n  }\n  plVar6 = (long *)plVar1[2];\n  while( true ) {\n    if (plVar1 == plVar6) {\n      return 0;\n    }\n    if (param_2 <= *plVar6) break;\n    plVar6 = (long *)plVar6[2];\n  }\n  if (plVar1 == plVar6) {\n    return 0;\n  }\n  if (0 < param_3) {\n    lVar3 = 0;\n    do {\n      plVar6 = (long *)plVar6[2];\n      lVar3 = lVar3 + 1;\n      if (plVar1 == plVar6) break;\n    } while (lVar3 < param_3);\n  }\n  lVar3 = array_slice(param_1);\n  lVar4 = array_to_word_list(lVar3);\n  if (lVar3 != 0) {\n    array_flush(lVar3);\n    lVar2 = *(long *)(lVar3 + 0x10);\n    if (lVar2 != 0) {\n      if (*(long *)(lVar2 + 8) != 0) {\n        sh_xfree(*(long *)(lVar2 + 8),\"array.c\",0x21e);\n      }\n      sh_xfree(lVar2,\"array.c\",0x21f);\n    }\n    sh_xfree(lVar3,\"array.c\",0x7b);\n  }\n  if (lVar4 == 0) {\n    return 0;\n  }\n  uVar5 = string_list_pos_params((-(param_4 == 0) & 0x16U) + 0x2a,lVar4,param_5,param_6);\n  dispose_words(lVar4);\n  return uVar5;\n}\n\n",
  "strftime": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strftime(char *__s,size_t __maxsize,char *__format,tm *__tp)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strftime_00237cf0)();\n  return sVar1;\n}\n\n",
  "history_tokenize": "\nvoid history_tokenize(undefined8 param_1)\n\n{\n  FUN_001f2720(param_1,0xffffffff,0);\n  return;\n}\n\n",
  "_rl_dispatch_subseq": "\nulong _rl_dispatch_subseq(uint param_1,undefined1 *param_2,int param_3)\n\n{\n  char cVar1;\n  code *pcVar2;\n  undefined *puVar3;\n  undefined1 *puVar4;\n  undefined4 uVar5;\n  uint uVar6;\n  int iVar7;\n  int iVar8;\n  size_t sVar9;\n  char *__dest;\n  undefined8 *puVar10;\n  ushort **ppuVar11;\n  __int32_t **pp_Var12;\n  long lVar13;\n  char *pcVar14;\n  ulong uVar15;\n  ulong uVar16;\n  bool bVar17;\n  \n  uVar16 = (ulong)param_1;\n  do {\n    iVar7 = (int)uVar16;\n    if ((iVar7 - 0x80U < 0x80) && (_rl_convert_meta_chars_to_ascii != 0)) {\n      if (param_2[0x1b0] != '\\x01') {\n        rl_ding();\n        return 0;\n      }\n      if ((rl_readline_state & 0x1000) != 0) {\n        _rl_add_macro_char(0x1b);\n      }\n      if (_rl_executing_keyseq_size <= rl_key_sequence_length + 2) {\n        _rl_executing_keyseq_size = _rl_executing_keyseq_size + 0x10;\n        rl_executing_keyseq = xrealloc(rl_executing_keyseq,(long)_rl_executing_keyseq_size);\n      }\n      lVar13 = (long)rl_key_sequence_length;\n      rl_key_sequence_length = rl_key_sequence_length + 1;\n      uVar16 = uVar16 & 0xffffffffffffff7f;\n      *(undefined *)(rl_executing_keyseq + lVar13) = 0x1b;\n      param_2 = *(undefined1 **)(param_2 + 0x1b8);\n    }\n    else {\n      if ((rl_readline_state & 0x1000) != 0) {\n        _rl_add_macro_char(uVar16);\n      }\n      pcVar14 = param_2 + (long)iVar7 * 0x10;\n      cVar1 = *pcVar14;\n      if (cVar1 == '\\x01') {\n        if (*(long *)(pcVar14 + 8) == 0) goto LAB_001ce76c;\n        if (((rl_editing_mode == 0) && (iVar7 == 0x1b)) && (param_2 == &vi_insertion_keymap)) {\n          if ((rl_readline_state & 0x20800) == 0) {\n            iVar8 = _rl_pushed_input_available();\n            if (iVar8 == 0) {\n              iVar8 = 0;\n              if (0 < _rl_keyseq_timeout) {\n                iVar8 = _rl_keyseq_timeout * 1000;\n              }\n              iVar8 = _rl_input_queued(iVar8);\n              if (iVar8 == 0) goto LAB_001ce6ef;\n            }\n            if (rl_editing_mode != 0) goto LAB_001ce2df;\n          }\n          if ((((rl_readline_state & 0x20000) == 0) && ((rl_readline_state & 0x800) != 0)) &&\n             ((iVar8 = _rl_peek_macro_key(), iVar8 == 0 &&\n              (iVar8 = _rl_pushed_input_available(), iVar8 == 0)))) {\n            iVar8 = 0;\n            if (0 < _rl_keyseq_timeout) {\n              iVar8 = _rl_keyseq_timeout * 1000;\n            }\n            iVar8 = _rl_input_queued(iVar8);\n            if (iVar8 == 0) {\nLAB_001ce6ef:\n              uVar16 = _rl_dispatch(0x100,*(undefined8 *)(pcVar14 + 8));\n              return uVar16;\n            }\n          }\n        }\nLAB_001ce2df:\n        if (_rl_executing_keyseq_size <= rl_key_sequence_length + 2) {\n          _rl_executing_keyseq_size = _rl_executing_keyseq_size + 0x10;\n          rl_executing_keyseq = xrealloc(rl_executing_keyseq,(long)_rl_executing_keyseq_size);\n        }\n        lVar13 = (long)rl_key_sequence_length;\n        rl_key_sequence_length = rl_key_sequence_length + 1;\n        *(char *)(rl_executing_keyseq + lVar13) = (char)uVar16;\n        _rl_dispatching_keymap = *(undefined1 **)(pcVar14 + 8);\n        if (_rl_vi_redoing == 0) {\n          if ((rl_readline_state & 0x80000) != 0) {\nLAB_001ce531:\n            uVar16 = rl_readline_state & 0x200000;\n            puVar10 = (undefined8 *)xmalloc(0x30);\n            *puVar10 = 0;\n            *(undefined4 *)(puVar10 + 1) = 0;\n            puVar10[4] = _rl_kscxt;\n            *(undefined4 *)(puVar10 + 5) = 0x2a;\n            puVar4 = _rl_dispatching_keymap;\n            if (param_3 == 0) {\n              *(int *)((long)puVar10 + 0xc) = iVar7;\n              puVar10[3] = param_2;\n              lVar13 = *(long *)(puVar4 + 0x1008);\n              puVar10[2] = puVar4;\n              uVar6 = (uint)(lVar13 != 0);\n            }\n            else {\n              *(undefined4 *)puVar10 = 2;\n              *(int *)((long)puVar10 + 0xc) = iVar7;\n              puVar10[2] = puVar4;\n              uVar6 = 1;\n              puVar10[3] = param_2;\n            }\n            *(uint *)((long)puVar10 + 4) = uVar6;\n            rl_readline_state = rl_readline_state | 0x200000;\n            _rl_kscxt = puVar10;\n            return (ulong)(-(uint)(uVar16 != 0) & 0xfffffffd);\n          }\nLAB_001ce336:\n          if (((_rl_keyseq_timeout < 1) || ((rl_readline_state & 0x20800) != 0)) ||\n             ((iVar8 = _rl_pushed_input_available(), iVar8 != 0 ||\n              ((*(long *)(_rl_dispatching_keymap + 0x1008) == 0 ||\n               (iVar8 = _rl_input_queued(_rl_keyseq_timeout * 1000), iVar8 != 0)))))) {\n            if (iVar7 == 0x1b) {\n              rl_readline_state = rl_readline_state | 0x50;\n              iVar7 = rl_read_key();\n              rl_readline_state = rl_readline_state & 0xffffffffffffffaf;\n            }\n            else {\n              rl_readline_state = rl_readline_state | 0x40;\n              iVar7 = rl_read_key();\n              rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n            }\n            if (-1 < iVar7) {\n              bVar17 = true;\n              if (param_3 == 0) {\n                bVar17 = *(long *)(param_2 + 0x1008) != 0;\n              }\n              uVar5 = _rl_dispatch_subseq(iVar7,_rl_dispatching_keymap,bVar17);\n              goto LAB_001ce3af;\n            }\n            goto LAB_001ce76c;\n          }\n          if (0 < rl_key_sequence_length) {\n            rl_key_sequence_length = rl_key_sequence_length + -1;\n            *(undefined *)(rl_executing_keyseq + rl_key_sequence_length) = 0;\n          }\n        }\n        else {\n          if ((rl_readline_state & 0x80000) == 0) goto LAB_001ce336;\n          if (*(long *)(param_2 + 0x1008) == 0) goto LAB_001ce531;\n        }\n        uVar5 = 0xfffffffe;\nLAB_001ce3af:\n        uVar16 = FUN_001cec90(uVar5,param_2,uVar16,param_3);\n        return uVar16;\n      }\n      if (cVar1 == '\\x02') {\n        uVar15 = 0;\n        if (*(long *)(pcVar14 + 8) != 0) {\n          *(undefined *)(rl_executing_keyseq + rl_key_sequence_length) = 0;\n          pcVar14 = *(char **)(pcVar14 + 8);\n          sVar9 = strlen(pcVar14);\n          __dest = (char *)xmalloc(sVar9 + 1);\n          pcVar14 = strcpy(__dest,pcVar14);\n          _rl_with_macro_input(pcVar14);\n          return 0;\n        }\n        goto LAB_001ce210;\n      }\n      if (cVar1 != '\\0') {\n        uVar15 = 0;\n        goto LAB_001ce210;\n      }\n      pcVar2 = *(code **)(pcVar14 + 8);\n      if (pcVar2 == (code *)0x0) {\n        if (*(long *)(param_2 + 0x1008) == 0) {\n          if (param_3 == 0) {\n            rl_readline_state = rl_readline_state & 0xffffffffffdfffff;\n            while (_rl_kscxt != (undefined8 *)0x0) {\n              _rl_kscxt = *(undefined8 **)((long)_rl_kscxt + 0x20);\n              xfree();\n            }\nLAB_001ce76c:\n                    /* WARNING: Subroutine does not return */\n            _rl_abort_internal();\n          }\n          if ((rl_readline_state & 0x800) == 0) {\n            _rl_unget_char(uVar16);\n          }\n          else {\n            _rl_prev_macro_key();\n          }\n          uVar16 = 0xffffffff;\n        }\n        else {\n          if ((rl_readline_state & 0x800) == 0) {\n            _rl_unget_char(uVar16);\n          }\n          else {\n            _rl_prev_macro_key();\n          }\n          uVar16 = 0xfffffffe;\n        }\n        if (rl_key_sequence_length < 1) {\n          return uVar16;\n        }\n        rl_key_sequence_length = rl_key_sequence_length + -1;\n        *(undefined *)(rl_executing_keyseq + rl_key_sequence_length) = 0;\n        return uVar16;\n      }\n      if (pcVar2 != (code *)PTR_rl_do_lowercase_version_00237fa0) {\n        rl_executing_key = iVar7;\n        _rl_executing_func = pcVar2;\n        rl_executing_keymap = param_2;\n        if (_rl_executing_keyseq_size <= rl_key_sequence_length + 2) {\n          _rl_executing_keyseq_size = _rl_executing_keyseq_size + 0x10;\n          rl_executing_keyseq = xrealloc(rl_executing_keyseq,(long)_rl_executing_keyseq_size);\n        }\n        lVar13 = (long)rl_key_sequence_length;\n        rl_key_sequence_length = rl_key_sequence_length + 1;\n        *(char *)(rl_executing_keyseq + lVar13) = (char)uVar16;\n        *(undefined *)(rl_executing_keyseq + rl_key_sequence_length) = 0;\n        rl_readline_state = rl_readline_state | 0x20;\n        rl_dispatching = 1;\n        uVar6 = (*pcVar2)(rl_numeric_arg * rl_arg_sign,uVar16);\n        rl_readline_state = rl_readline_state & 0xffffffffffffffdf;\n        rl_dispatching = 0;\n        uVar15 = (ulong)uVar6;\n        if (((rl_pending_input == 0) &&\n            (puVar3 = *(undefined **)(pcVar14 + 8), puVar3 != PTR_rl_vi_arg_digit_00237f68)) &&\n           (puVar3 != PTR_rl_digit_argument_00237ee8)) {\n          rl_last_func = puVar3;\n        }\n        if (_rl_caught_signal != 0) {\n          _rl_signal_handler(_rl_caught_signal);\n        }\nLAB_001ce210:\n        if (((rl_editing_mode == 0) && (_rl_keymap == vi_movement_keymap)) &&\n           ((iVar7 != 0x100 &&\n            ((_rl_dispatching_keymap == vi_movement_keymap &&\n             (iVar7 = _rl_vi_textmod_command(uVar16), iVar7 != 0)))))) {\n          _rl_vi_set_last(uVar16,rl_numeric_arg,rl_arg_sign);\n        }\n        return uVar15;\n      }\n      ppuVar11 = __ctype_b_loc();\n      uVar15 = uVar16 & 0xff;\n      uVar16 = uVar16 & 0xff;\n      if ((*(byte *)((long)*ppuVar11 + uVar15 * 2 + 1) & 1) != 0) {\n        pp_Var12 = __ctype_tolower_loc();\n        uVar16 = (ulong)(uint)(*pp_Var12)[uVar15];\n      }\n    }\n    param_3 = 0;\n    _rl_dispatching_keymap = param_2;\n  } while( true );\n}\n\n",
  "suspend_builtin": "\nundefined8 suspend_builtin(undefined8 param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar2 = 0;\n  reset_internal_getopt();\n  while( true ) {\n    iVar1 = internal_getopt(param_1,\"f\");\n    if (iVar1 == -1) {\n      no_args(loptend);\n      if (iVar2 == 0) {\n        if (job_control == 0) {\n          sh_nojobs(\"cannot suspend\");\n          return 1;\n        }\n        if (login_shell != 0) {\n          builtin_error(\"cannot suspend a login shell\");\n          return 1;\n        }\n      }\n      DAT_00248c10 = set_signal_handler(0x12,FUN_001b4200);\n      killpg(shell_pgrp,0x13);\n      return 0;\n    }\n    if (iVar1 == -99) {\n      builtin_help();\n      return 0x102;\n    }\n    if (iVar1 != 0x66) break;\n    iVar2 = iVar2 + 1;\n  }\n  builtin_usage();\n  return 0x102;\n}\n\n",
  "rl_set_mark": "\nundefined8 rl_set_mark(int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (rl_explicit_arg == 0) {\n    param_1 = rl_point;\n  }\n  uVar1 = 1;\n  if ((-1 < param_1) && (param_1 <= rl_end)) {\n    uVar1 = 0;\n    rl_mark = param_1;\n  }\n  return uVar1;\n}\n\n",
  "local_exported_variables": "\nvoid * local_exported_variables(void)\n\n{\n  int iVar1;\n  void *__base;\n  \n  __base = (void *)map_over(FUN_001512e0,shell_variables);\n  if (__base != (void *)0x0) {\n    iVar1 = strvec_len(__base);\n    qsort(__base,(long)iVar1,8,FUN_001513a0);\n  }\n  return __base;\n}\n\n",
  "_malloc_unblock_signals": "\nvoid _malloc_unblock_signals(undefined8 param_1,sigset_t *param_2)\n\n{\n  sigprocmask(2,param_2,(sigset_t *)0x0);\n  return;\n}\n\n",
  "sigterm_sighandler": "\nvoid sigterm_sighandler(void)\n\n{\n  sigterm_received = 1;\n  return;\n}\n\n",
  "FUN_00135070": "\nvoid FUN_00135070(ulong param_1)\n\n{\n  char *__s;\n  long lVar1;\n  size_t sVar2;\n  char *__dest;\n  \n  lVar1 = find_token_in_alist(param_1,&word_token_alist,0);\n  if (lVar1 == 0) {\n    lVar1 = find_token_in_alist(param_1 & 0xffffffff,other_token_alist,0);\n    if (lVar1 == 0) {\n      if (current_token == 0x11d) {\n        if (CONCAT44(yylval._4_4_,(int)yylval) != 0) {\n          string_list(CONCAT44(yylval._4_4_,(int)yylval));\n          return;\n        }\n      }\n      else if (current_token < 0x11e) {\n        if (current_token < 0x11b) {\n          if ((0x118 < current_token) &&\n             ((char **)CONCAT44(yylval._4_4_,(int)yylval) != (char **)0x0)) {\n            __s = *(char **)CONCAT44(yylval._4_4_,(int)yylval);\n            sVar2 = strlen(__s);\n            __dest = (char *)sh_xmalloc(sVar2 + 1,\"/usr/local/src/chet/src/bash/src/parse.y\",0x17e7)\n            ;\n            strcpy(__dest,__s);\n            return;\n          }\n        }\n        else if (current_token == 0x11c) {\n          itos((long)(int)yylval);\n          return;\n        }\n      }\n      else if ((current_token == 0x11e) && (CONCAT44(yylval._4_4_,(int)yylval) != 0)) {\n        string_list_internal(CONCAT44(yylval._4_4_,(int)yylval),&DAT_001faa23);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
  "next_history": "\nundefined8 next_history(void)\n\n{\n  if (history_offset != history_length) {\n    history_offset = history_offset + 1;\n    return *(undefined8 *)(DAT_0024b6e8 + (long)history_offset * 8);\n  }\n  return 0;\n}\n\n",
  "get_original_tty_job_signals": "\nvoid get_original_tty_job_signals(void)\n\n{\n  if (DAT_0024659c != 0) {\n    return;\n  }\n  if (interactive_shell == 0) {\n    get_original_signal(0x14);\n    get_original_signal(0x15);\n    get_original_signal(0x16);\n    DAT_0024659c = 1;\n    return;\n  }\n  set_original_signal(0x14,0);\n  set_original_signal(0x15,0);\n  set_original_signal(0x16,0);\n  DAT_0024659c = 1;\n  return;\n}\n\n",
  "_rl_update_final": "\nvoid _rl_update_final(void)\n\n{\n  int iVar1;\n  bool bVar2;\n  long lVar3;\n  int iVar4;\n  int iVar5;\n  long lVar6;\n  long lVar7;\n  \n  if (DAT_0024a8dc != 0) {\n    bVar2 = false;\n    if (_rl_vis_botlin != 0) {\n      if (_rl_last_c_pos == 0) {\n        bVar2 = false;\n        if (*(char *)(*(long *)PTR_DAT_00240520 +\n                     (long)*(int *)(*(long *)(PTR_DAT_00240520 + 0x10) + (long)_rl_vis_botlin * 4))\n            == '\\0') {\n          _rl_vis_botlin = _rl_vis_botlin + -1;\n          bVar2 = true;\n        }\n      }\n      else {\n        bVar2 = false;\n      }\n    }\n    _rl_move_vert();\n    iVar5 = 0;\n    if (_rl_vis_botlin == 0) {\n      iVar5 = DAT_0024a884;\n    }\n    iVar1 = *(int *)(*(long *)(PTR_DAT_00240520 + 0x10) + -4 + ((long)_rl_vis_botlin + 1) * 4);\n    iVar4 = (*(int *)(*(long *)(PTR_DAT_00240520 + 0x10) + ((long)_rl_vis_botlin + 1) * 4) - iVar1)\n            - iVar5;\n    if (((bVar2) && (_rl_term_autowrap != 0)) && (_rl_screenwidth == iVar4)) {\n      DAT_0024a8d0 = 0xffffffff;\n      lVar7 = *(long *)PTR_DAT_00240520 + (long)iVar1;\n      lVar6 = (long)iVar1 + *(long *)(PTR_DAT_00240520 + 8);\n      FUN_001e1320(iVar5 + -1 + iVar4,lVar7,lVar6);\n      if (_rl_term_clreol != 0) {\n        tputs(_rl_term_clreol,1,_rl_output_character_function);\n      }\n      lVar3 = (long)(iVar5 + -1 + _rl_screenwidth);\n      FUN_001e0800(lVar7 + lVar3,lVar6 + lVar3,1);\n    }\n    _rl_vis_botlin = 0;\n    if ((0 < iVar4) || (0 < _rl_last_c_pos)) {\n      rl_crlf();\n    }\n    fflush(rl_outstream);\n    rl_display_fixed = rl_display_fixed + 1;\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001d4780": "\nundefined8 FUN_001d4780(long param_1)\n\n{\n  char *__src;\n  undefined8 uVar1;\n  size_t sVar2;\n  char *__dest;\n  \n  rl_mark = *(undefined4 *)(param_1 + 0x34);\n  if (rl_point == 0) {\n    if (DAT_0024a480 == (char *)0x0) {\n      rl_ding();\n      rl_restore_prompt();\n      rl_readline_state = rl_readline_state & 0xfffffffffffffeff;\n      return 0xffffffff;\n    }\n  }\n  else {\n    DAT_0024a478 = *(undefined4 *)(param_1 + 0x38);\n    if (DAT_0024a480 != (char *)0x0) {\n      free(DAT_0024a480);\n    }\n    __src = rl_line_buffer;\n    sVar2 = strlen(rl_line_buffer);\n    __dest = (char *)xmalloc(sVar2 + 1);\n    DAT_0024a480 = strcpy(__dest,__src);\n    rl_free_undo_list();\n  }\n  rl_restore_prompt();\n  uVar1 = FUN_001d4610(DAT_0024a480,*(undefined4 *)(param_1 + 100),*(uint *)(param_1 + 4) & 0x10);\n  return uVar1;\n}\n\n",
  "FUN_001d8df0": "\nlong * FUN_001d8df0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                   undefined4 param_5,undefined4 param_6)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  \n  rl_completion_found_quote = param_5;\n  rl_completion_quote_character = param_6;\n  if (rl_attempted_completion_function != (code *)0x0) {\n    plVar2 = (long *)(*rl_attempted_completion_function)();\n    if (_rl_caught_signal == 0) {\n      if (plVar2 != (long *)0x0) {\n        rl_attempted_completion_over = 0;\n        return plVar2;\n      }\n    }\n    else {\n      if (plVar2 != (long *)0x0) {\n        lVar1 = *plVar2;\n        plVar3 = plVar2;\n        while (lVar1 != 0) {\n          plVar3 = plVar3 + 1;\n          xfree();\n          lVar1 = *plVar3;\n        }\n        xfree(plVar2);\n      }\n      if (_rl_caught_signal != 0) {\n        _rl_signal_handler(_rl_caught_signal);\n      }\n    }\n    if (rl_attempted_completion_over != 0) {\n      rl_attempted_completion_over = 0;\n      return (long *)0x0;\n    }\n  }\n  plVar2 = (long *)rl_completion_matches(param_1,param_4);\n  if (_rl_caught_signal != 0) {\n    if (plVar2 != (long *)0x0) {\n      lVar1 = *plVar2;\n      plVar3 = plVar2;\n      while (lVar1 != 0) {\n        plVar3 = plVar3 + 1;\n        xfree();\n        lVar1 = *plVar3;\n      }\n      xfree(plVar2);\n    }\n    plVar2 = (long *)0x0;\n    if (_rl_caught_signal != 0) {\n      _rl_signal_handler(_rl_caught_signal);\n    }\n  }\n  return plVar2;\n}\n\n",
  "times_builtin": "\nundefined8 times_builtin(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined auStack_148 [144];\n  undefined local_b8 [152];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = no_options();\n  uVar2 = 0x102;\n  if (iVar1 == 0) {\n    getrusage(RUSAGE_SELF,(rusage *)auStack_148);\n    getrusage(RUSAGE_CHILDREN,(rusage *)local_b8);\n    print_timeval(stdout,auStack_148);\n    putc(0x20,stdout);\n    print_timeval(stdout,auStack_148 + 0x10);\n    putc(10,stdout);\n    print_timeval(stdout,(rusage *)local_b8);\n    putc(0x20,stdout);\n    print_timeval(stdout,local_b8 + 0x10);\n    putc(10,stdout);\n    uVar2 = sh_chkwrite(0);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "convert_var_to_assoc": "\nlong convert_var_to_assoc(long param_1)\n\n{\n  uint uVar1;\n  long lVar2;\n  uint uVar3;\n  undefined8 uVar4;\n  undefined2 *puVar5;\n  \n  lVar2 = *(long *)(param_1 + 8);\n  uVar4 = hash_create(0);\n  if (lVar2 != 0) {\n    puVar5 = (undefined2 *)sh_xmalloc(2,\"arrayfunc.c\",0x7c);\n    *puVar5 = 0x30;\n    assoc_insert(uVar4,puVar5,lVar2);\n  }\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"arrayfunc.c\",0x7e);\n  }\n  *(undefined8 *)(param_1 + 8) = uVar4;\n  *(undefined8 *)(param_1 + 0x18) = 0;\n  *(undefined8 *)(param_1 + 0x20) = 0;\n  if (*(long *)(param_1 + 0x10) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x10),\"arrayfunc.c\",0x85);\n    *(undefined8 *)(param_1 + 0x10) = 0;\n  }\n  uVar1 = *(uint *)(param_1 + 0x28);\n  if ((uVar1 & 1) != 0) {\n    array_needs_making = array_needs_making + 1;\n  }\n  uVar3 = uVar1 & 0xffffefff;\n  if (lVar2 == 0) {\n    uVar3 = uVar1;\n  }\n  *(uint *)(param_1 + 0x28) = uVar3 & 0xfffff7fb | 0x40;\n  return param_1;\n}\n\n",
  "file_error": "\nvoid file_error(undefined8 param_1)\n\n{\n  int *piVar1;\n  char *pcVar2;\n  \n  piVar1 = __errno_location();\n  pcVar2 = strerror(*piVar1);\n  report_error(\"%s: %s\",param_1,pcVar2);\n  return;\n}\n\n",
  "FUN_0015bee0": "\nulong FUN_0015bee0(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int iVar3;\n  char *pcVar4;\n  int iVar5;\n  int iVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  long lVar10;\n  undefined8 uVar11;\n  \n  uVar8 = DAT_00242458;\n  uVar7 = DAT_00242450;\n  iVar6 = DAT_00242448;\n  iVar5 = DAT_00242444;\n  pcVar4 = DAT_00242438;\n  uVar9 = DAT_00242430;\n  iVar3 = DAT_00242428;\n  lVar10 = DAT_002386d8;\n  uVar2 = DAT_002386d0;\n  uVar1 = DAT_002386c8;\n  uVar11 = DAT_002386c0;\n  if (DAT_00242448 == 0x21) {\n    FUN_0015d330();\n    lVar10 = FUN_0015bee0();\n    DAT_00242444 = 6;\n    uVar9 = (ulong)(lVar10 == 0);\n  }\n  else if (DAT_00242448 == 0x7e) {\n    FUN_0015d330();\n    uVar9 = FUN_0015bee0();\n    DAT_00242444 = 6;\n    uVar9 = ~uVar9;\n  }\n  else if (DAT_00242448 == 0x2d) {\n    FUN_0015d330();\n    lVar10 = FUN_0015bee0();\n    DAT_00242444 = 6;\n    uVar9 = -lVar10;\n  }\n  else if (DAT_00242448 == 0x2b) {\n    FUN_0015d330();\n    uVar9 = FUN_0015bee0();\n    DAT_00242444 = 6;\n  }\n  else if (DAT_00242448 - 0xeU < 2) {\n    DAT_00242444 = DAT_00242448;\n    FUN_0015d330();\n    if (DAT_00242448 != 5) {\n                    /* WARNING: Subroutine does not return */\n      FUN_0015bcf0(\"identifier expected after pre-increment or pre-decrement\");\n    }\n    uVar9 = (DAT_00242430 - 1) + (ulong)(iVar6 == 0xe) * 2;\n    uVar11 = itos(uVar9);\n    if (DAT_00242428 == 0) {\n      if (DAT_002386d8 == -1) {\n        if ((DAT_00242438 != (char *)0x0) && (*DAT_00242438 != '\\0')) {\n          FUN_0015bd90(DAT_00242438,uVar11);\n        }\n      }\n      else {\n        FUN_0015bdf0(DAT_002386c0,DAT_002386d8,uVar11);\n      }\n    }\n    sh_xfree(uVar11,\"expr.c\",0x415);\n    DAT_00242448 = 6;\n    FUN_0015d330();\n  }\n  else {\n    if (DAT_00242448 == 0x28) {\n      do {\n        FUN_0015d330();\n        uVar9 = FUN_0015ccc0();\n      } while (DAT_00242448 == 0x2c);\n      if (DAT_00242448 != 0x29) {\n                    /* WARNING: Subroutine does not return */\n        FUN_0015bcf0(\"missing `)\\'\");\n      }\n    }\n    else {\n      if (1 < DAT_00242448 - 5U) {\n                    /* WARNING: Subroutine does not return */\n        FUN_0015bcf0(\"syntax error: operand expected\");\n      }\n      DAT_002386c0 = uVar11;\n      DAT_002386c8 = uVar1;\n      DAT_002386d0 = uVar2;\n      DAT_002386d8 = lVar10;\n      DAT_00242428 = iVar3;\n      DAT_00242430 = uVar9;\n      DAT_00242438 = pcVar4;\n      DAT_00242444 = iVar5;\n      DAT_00242450 = uVar7;\n      DAT_00242458 = uVar8;\n      if (DAT_00242448 == 5) {\n        DAT_00242438 = (char *)0x0;\n        DAT_00242428 = 1;\n        FUN_0015d330();\n        if (DAT_00242448 - 0x10U < 2) {\n          DAT_00242444 = 5;\n          DAT_002386c0 = uVar11;\n          DAT_002386c8 = uVar1;\n          DAT_002386d0 = uVar2;\n          DAT_002386d8 = lVar10;\n          DAT_00242428 = iVar3;\n          DAT_00242438 = pcVar4;\n          uVar11 = itos((uVar9 - 1) + (ulong)(DAT_00242448 == 0x10) * 2);\n          if (DAT_00242428 == 0) {\n            if (DAT_002386d8 == -1) {\n              if ((DAT_00242438 != (char *)0x0) && (*DAT_00242438 != '\\0')) {\n                FUN_0015bd90(DAT_00242438,uVar11);\n              }\n            }\n            else {\n              FUN_0015bdf0(DAT_002386c0,DAT_002386d8,uVar11);\n            }\n          }\n          sh_xfree(uVar11,\"expr.c\",0x446);\n          DAT_00242448 = 6;\n        }\n        else {\n          if ((DAT_00242448 == 5) && (DAT_00242438 != (char *)0x0)) {\n            sh_xfree(DAT_00242438,\"expr.c\",0x44d);\n          }\n          DAT_00242448 = 5;\n          DAT_002386c0 = uVar11;\n          DAT_002386c8 = uVar1;\n          DAT_002386d0 = uVar2;\n          DAT_002386d8 = lVar10;\n          DAT_00242428 = iVar3;\n          DAT_00242430 = uVar9;\n          DAT_00242438 = pcVar4;\n          DAT_00242444 = iVar5;\n          DAT_00242450 = uVar7;\n          DAT_00242458 = uVar8;\n        }\n      }\n    }\n    FUN_0015d330();\n  }\n  return uVar9;\n}\n\n",
  "array_quote": "\nlong array_quote(long param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long lVar4;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  lVar1 = *(long *)(param_1 + 0x10);\n  lVar3 = lVar1;\n  if (lVar1 != 0) {\n    if (*(long *)(param_1 + 8) == 0) {\n      return 0;\n    }\n    lVar4 = *(long *)(lVar1 + 0x10);\n    lVar3 = param_1;\n    if (lVar1 != lVar4) {\n      do {\n        uVar2 = quote_string(*(undefined8 *)(lVar4 + 8));\n        if (*(long *)(lVar4 + 8) != 0) {\n          sh_xfree(*(long *)(lVar4 + 8),\"array.c\",0x142);\n        }\n        *(undefined8 *)(lVar4 + 8) = uVar2;\n        lVar4 = *(long *)(lVar4 + 0x10);\n      } while (*(long *)(param_1 + 0x10) != lVar4);\n    }\n  }\n  return lVar3;\n}\n\n",
  "alloc_history_entry": "\nchar ** alloc_history_entry(char *param_1,char *param_2)\n\n{\n  char **ppcVar1;\n  size_t sVar2;\n  char *__dest;\n  \n  ppcVar1 = (char **)xmalloc(0x18);\n  if (param_1 != (char *)0x0) {\n    sVar2 = strlen(param_1);\n    __dest = (char *)xmalloc(sVar2 + 1);\n    param_1 = strcpy(__dest,param_1);\n  }\n  *ppcVar1 = param_1;\n  ppcVar1[2] = (char *)0x0;\n  ppcVar1[1] = param_2;\n  return ppcVar1;\n}\n\n",
  "run_exit_trap": "\nundefined4 run_exit_trap(void)\n\n{\n  uint uVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  char *__dest;\n  char *pcVar4;\n  undefined4 local_24;\n  uint local_18;\n  \n  trap_saved_exit_value = last_command_exit_value;\n  uVar2 = save_pipestatus_array();\n  pcVar4 = trap_list;\n  local_18 = 0;\n  if ((DAT_00247e40 & 0x51) == 1) {\n    sVar3 = strlen(trap_list);\n    __dest = (char *)sh_xmalloc(sVar3 + 1,\"trap.c\",0x3dd);\n    pcVar4 = strcpy(__dest,pcVar4);\n    running_trap = 1;\n    DAT_00247e40 = DAT_00247e40 & 0xfffffffe | 0x10;\n    local_24 = trap_saved_exit_value;\n    uVar1 = __sigsetjmp(top_level,0);\n    if (return_catch_flag != 0) {\n      local_18 = __sigsetjmp(return_catch,0);\n    }\n    if ((uVar1 | local_18) == 0) {\n      reset_parser();\n      parse_and_execute(pcVar4,\"exit trap\",0x15);\n    }\n    else if (((uVar1 == 4) || (uVar1 == 3)) || (uVar1 == 6)) {\n      local_24 = last_command_exit_value;\n    }\n    else {\n      local_24 = return_catch_value;\n      if (local_18 == 0) {\n        local_24 = trap_saved_exit_value;\n      }\n    }\n    running_trap = 0;\n    array_dispose(uVar2);\n    return local_24;\n  }\n  restore_pipestatus_array(uVar2);\n  return trap_saved_exit_value;\n}\n\n",
  "valloc": "\nvoid * valloc(size_t __size)\n\n{\n  int iVar1;\n  void *pvVar2;\n  void *pvVar3;\n  long lVar4;\n  \n  iVar1 = getpagesize();\n  lVar4 = (long)iVar1;\n  pvVar2 = (void *)FUN_001f85f0(__size + lVar4,0,0);\n  pvVar3 = pvVar2;\n  if ((pvVar2 != (void *)0x0) && (((ulong)pvVar2 & lVar4 - 1U) != 0)) {\n    pvVar3 = (void *)((long)pvVar2 + lVar4 + -1 & -lVar4);\n    *(undefined *)((long)pvVar3 + -0x10) = 0xd6;\n    *(int *)((long)pvVar3 + -0xc) = (int)pvVar3 - (int)pvVar2;\n  }\n  return pvVar3;\n}\n\n",
  "free_buffered_stream": "\nvoid free_buffered_stream(int *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (int *)0x0) {\n    iVar1 = *param_1;\n    if (*(long *)(param_1 + 2) != 0) {\n      sh_xfree(*(long *)(param_1 + 2),\"input.c\",0x1b2);\n    }\n    sh_xfree(param_1,\"input.c\",0x1b3);\n    *(undefined8 *)(DAT_00247f68 + (long)iVar1 * 8) = 0;\n    return;\n  }\n  return;\n}\n\n",
  "sh_readonly": "\nvoid sh_readonly(undefined8 param_1)\n\n{\n  builtin_error(\"%s: readonly variable\",param_1);\n  return;\n}\n\n",
  "wctomb": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wctomb(char *__s,wchar_t __wchar)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wctomb_00237d18)();\n  return iVar1;\n}\n\n",
  "FUN_0019c700": "\n/* WARNING: Removing unreachable block (ram,0x0019ce68) */\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nint FUN_0019c700(long param_1,uint param_2,char **param_3)\n\n{\n  uint uVar1;\n  undefined *puVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  undefined4 uVar6;\n  char **ppcVar7;\n  char *pcVar8;\n  size_t sVar9;\n  int *piVar10;\n  undefined8 *puVar11;\n  size_t sVar12;\n  long lVar13;\n  ulong uVar14;\n  char **ppcVar15;\n  ulong uVar16;\n  undefined8 *puVar17;\n  undefined8 *puVar18;\n  undefined *puVar19;\n  char cVar21;\n  bool bVar22;\n  undefined8 uVar23;\n  long unaff_R15;\n  long in_FS_OFFSET;\n  undefined auStack_a8 [8];\n  char *apcStack_a0 [2];\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined local_64 [4];\n  long local_60;\n  int local_58 [2];\n  char *local_50;\n  int local_48;\n  int local_44;\n  long local_40;\n  undefined *puVar20;\n  \n  puVar17 = &local_88;\n  uVar1 = *(uint *)(param_1 + 0x18);\n  iVar5 = *(int *)(param_1 + 8);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((*(byte *)(param_1 + 0x14) & 8) != 0) {\n    param_2 = param_2 | 8;\n  }\n  puVar18 = &local_88;\n  ppcVar7 = *(char ***)(param_1 + 0x20);\n  local_78 = param_3;\n  iVar3 = *(int *)(param_1 + 0x20);\n  if ((uVar1 - 0xd & 0xfffffffa) == 0) {\n    local_90 = 0x19c75d;\n    ppcVar7 = (char **)redirection_expand(*(char ***)(param_1 + 0x20));\n    if (uVar1 - 0x11 < 2) {\n      if (ppcVar7 != (char **)0x0) goto LAB_0019c777;\nLAB_0019c8e9:\n      DAT_00248a00 = DAT_00248a00 & 0xffffffff00000000;\n      local_90 = 0x19c911;\n      local_70 = ppcVar7;\n      unaff_R15 = make_redirection(*(undefined8 *)(param_1 + 8),9,DAT_00248a00,0);\nLAB_0019c7ee:\n      local_90 = 0x19c805;\n      sh_xfree(local_70,\"redir.c\",0x364);\n      uVar1 = *(uint *)(unaff_R15 + 0x18);\n      if (uVar1 == 10) {\n        puVar19 = auStack_a8;\n        local_70 = apcStack_a0;\n        xbcopy(*(undefined8 *)(unaff_R15 + 0x20),local_70,0x10);\n        ppcVar7 = *(char ***)(unaff_R15 + 0x20);\n        sVar9 = strlen(*ppcVar7);\n        puVar20 = auStack_a8;\n        puVar2 = auStack_a8;\n        while (puVar20 != auStack_a8 + -(sVar9 + 0x18 & 0xfffffffffffff000)) {\n          puVar19 = puVar2 + -0x1000;\n          *(undefined8 *)(puVar2 + -8) = *(undefined8 *)(puVar2 + -8);\n          puVar20 = puVar2 + -0x1000;\n          puVar2 = puVar2 + -0x1000;\n        }\n        uVar16 = (ulong)((uint)(sVar9 + 0x18) & 0xff0);\n        lVar13 = -uVar16;\n        puVar17 = (undefined8 *)(puVar19 + lVar13);\n        if (uVar16 != 0) {\n          *(undefined8 *)(puVar19 + -8) = *(undefined8 *)(puVar19 + -8);\n        }\n        apcStack_a0[0] = (char *)((ulong)(puVar19 + lVar13 + 0xf) & 0xfffffffffffffff0);\n        pcVar8 = *ppcVar7;\n        *(undefined8 *)(puVar19 + lVar13 + -8) = 0x19cf13;\n        strcpy(apcStack_a0[0],pcVar8);\n        uVar1 = *(uint *)(unaff_R15 + 0x18);\n        local_80 = (char *)local_70;\n      }\n      else {\n        local_80 = (char *)*(char ***)(unaff_R15 + 0x20);\n      }\n      uVar6 = *(undefined4 *)(unaff_R15 + 0x20);\n      iVar5 = *(int *)(unaff_R15 + 8);\n      *(undefined4 *)(param_1 + 0x14) = *(undefined4 *)(unaff_R15 + 0x14);\n      local_70 = (char **)CONCAT44(local_70._4_4_,uVar6);\n      *(undefined8 *)((long)puVar17 + -8) = 0x19c836;\n      dispose_redirects(unaff_R15);\n      puVar18 = puVar17;\n      ppcVar7 = (char **)local_80;\n      iVar3 = (int)local_70;\n      goto LAB_0019c83e;\n    }\n    puVar18 = &local_88;\n    if (ppcVar7 != (char **)0x0) {\nLAB_0019c777:\n      if ((*(char *)ppcVar7 == '-') && (*(char *)((long)ppcVar7 + 1) == '\\0')) goto LAB_0019c8e9;\n      local_90 = 0x19c794;\n      local_70 = ppcVar7;\n      iVar3 = all_digits(ppcVar7);\n      if (iVar3 == 0) {\n        if (((uVar1 != 0xe) || ((*(byte *)(param_1 + 0x10) & 1) != 0)) || (iVar5 != 1)) {\n          local_90 = 0x19d85c;\n          sh_xfree(local_70,\"redir.c\",0x360);\n          puVar18 = &local_88;\n          goto LAB_0019d660;\n        }\n        uVar23 = *(undefined8 *)(param_1 + 8);\n        local_90 = 0x19c7ce;\n        DAT_00248a00 = make_bare_word(local_70);\n        local_90 = 0x19c7e7;\n        unaff_R15 = make_redirection(uVar23,10,DAT_00248a00,0);\n      }\n      else {\n        uVar23 = *(undefined8 *)(param_1 + 8);\n        local_90 = 0x19cdc0;\n        iVar3 = legal_number(local_70,&local_60);\n        iVar5 = -1;\n        if (iVar3 != 0) {\n          iVar5 = -1;\n          if (local_60 == (int)local_60) {\n            iVar5 = (int)local_60;\n          }\n        }\n        DAT_00248a00 = CONCAT44(DAT_00248a00._4_4_,iVar5);\n        if (uVar1 == 0x11) {\n          local_90 = 0x19d76a;\n          unaff_R15 = make_redirection(uVar23,0xf,DAT_00248a00,0);\n        }\n        else if (uVar1 < 0x12) {\n          if (uVar1 == 0xd) {\n            local_90 = 0x19d742;\n            unaff_R15 = make_redirection(uVar23,6,DAT_00248a00,0);\n          }\n          else if (uVar1 == 0xe) {\n            local_90 = 0x19ce1e;\n            unaff_R15 = make_redirection(uVar23,7,DAT_00248a00,0);\n          }\n        }\n        else if (uVar1 == 0x12) {\n          local_90 = 0x19ce54;\n          unaff_R15 = make_redirection(uVar23,0x10,DAT_00248a00,0);\n        }\n      }\n      goto LAB_0019c7ee;\n    }\nLAB_0019d660:\n    iVar3 = -1;\n    goto LAB_0019c8b3;\n  }\nLAB_0019c83e:\n  uVar16 = (ulong)uVar1;\n  switch(uVar16) {\n  case 0:\n  case 1:\n  case 2:\n  case 3:\n  case 10:\n  case 0xb:\n  case 0xc:\n  case 0x13:\n    if ((posixly_correct != 0) && (interactive_shell == 0)) {\n      local_88 = (char **)CONCAT44(local_88._4_4_,*(uint *)(ppcVar7 + 1));\n      *(uint *)(ppcVar7 + 1) = *(uint *)(ppcVar7 + 1) | 0x20;\n    }\n    local_70 = ppcVar7;\n    *(undefined8 *)((long)puVar18 + -8) = 0x19c946;\n    pcVar8 = (char *)redirection_expand(ppcVar7);\n    if ((posixly_correct != 0) && (interactive_shell == 0)) {\n      *(int *)(local_70 + 1) = (int)local_88;\n    }\n    if (pcVar8 == (char *)0x0) goto LAB_0019d660;\n    if ((restricted != 0) && ((0x81c09UL >> (uVar16 & 0x3f) & 1) != 0)) {\n      *(undefined8 *)((long)puVar18 + -8) = 0x19df1c;\n      sh_xfree(pcVar8,\"redir.c\",0x39d);\n      iVar3 = -3;\n      goto LAB_0019c8b3;\n    }\n    local_80 = (char *)CONCAT44(local_80._4_4_,*(undefined4 *)(param_1 + 0x14));\n    *(undefined8 *)((long)puVar18 + -8) = 0x19c9a3;\n    iVar3 = find_string_in_alist(pcVar8,&PTR_s__dev_tcp_____00238de0,1);\n    if (-1 < iVar3) {\n      if (iVar3 - 5U < 2) {\n        if (restricted != 0) {\n          *local_78 = pcVar8;\n          iVar3 = -3;\n          goto LAB_0019c8b3;\n        }\n        *(undefined8 *)((long)puVar18 + -8) = 0x19cff4;\n        iVar3 = netopen(pcVar8);\n        goto LAB_0019cff7;\n      }\n      *local_78 = pcVar8;\nLAB_0019cf9d:\n      *(undefined8 *)((long)puVar18 + -8) = 0x19cfa2;\n      piVar10 = __errno_location();\n      iVar3 = *piVar10;\n      goto LAB_0019c8b3;\n    }\n    if ((noclobber == 0) || ((uVar1 != 0 && (uVar1 != 10)))) {\n      *(undefined8 *)((long)puVar18 + -8) = 0x19cf25;\n      local_70 = (char **)__errno_location();\n      while( true ) {\n        iVar3 = (int)local_80;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19cf42;\n        iVar3 = open(pcVar8,iVar3,0x1b6);\n        if (*(int *)local_70 != 4) break;\n        if (-1 < iVar3) goto LAB_0019d500;\n        if (terminating_signal != 0) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19cfcb;\n          termsig_handler(terminating_signal);\n        }\n        if (interrupt_state != 0) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19cfb5;\n          throw_to_top_level();\n        }\n        *(undefined8 *)((long)puVar18 + -8) = 0x19cf70;\n        run_pending_traps();\n        *(undefined4 *)local_70 = 4;\n      }\n      if (iVar3 < 0) {\n        *local_78 = pcVar8;\n        if (iVar3 + 3U < 2) goto LAB_0019c8b3;\n        goto LAB_0019cf9d;\n      }\nLAB_0019d500:\n      *local_78 = pcVar8;\n    }\n    else {\n      *(undefined8 *)((long)puVar18 + -8) = 0x19c9d3;\n      iVar3 = FUN_0019c1e0(pcVar8);\n      if (iVar3 == -2) {\n        *local_78 = pcVar8;\n        goto LAB_0019c8b3;\n      }\nLAB_0019cff7:\n      *local_78 = pcVar8;\n      if (iVar3 + 3U < 2) goto LAB_0019c8b3;\n      if (iVar3 < 0) goto LAB_0019cf9d;\n    }\n    if ((param_2 & 1) == 0) {\n      if (iVar5 == iVar3) break;\nLAB_0019d0a7:\n      if ((uVar1 - 1 < 2) || (uVar1 == 0xb)) {\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d675;\n        close_buffered_fd();\n      }\n      else {\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d0c5;\n        close(iVar3);\n      }\nLAB_0019d0c5:\n      if ((uVar1 == 10 || uVar1 == 0x13) && ((param_2 & 1) != 0)) {\n        if ((param_2 & 2) != 0) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19dc1f;\n          FUN_0019bf00(2,uVar16,0xffffffff);\n        }\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d0fe;\n        iVar5 = dup2(1,2);\n        if (iVar5 < 0) goto LAB_0019cf9d;\n      }\n      break;\n    }\n    if ((*(byte *)(param_1 + 0x10) & 1) == 0) {\n      if ((param_2 & 2) != 0) {\nLAB_0019db50:\n        if (iVar5 != iVar3) {\n          local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19db6e;\n          iVar4 = fcntl(iVar5,1,0);\n          iVar3 = (int)local_70;\n          if (iVar4 != -1) {\n            *(undefined8 *)((long)puVar18 + -8) = 0x19db8b;\n            iVar4 = FUN_0019bf00(iVar5,uVar16,0xffffffff);\n            local_48 = (int)local_70;\n            iVar3 = (int)local_70;\n            if (iVar4 < 0) goto LAB_0019d8a6;\n            goto LAB_0019d02e;\n          }\n        }\nLAB_0019d24f:\n        local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n        DAT_00248a00 = DAT_00248a00 & 0xffffffff00000000;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d273;\n        puVar11 = (undefined8 *)make_redirection(iVar5,9,DAT_00248a00,0);\n        *(uint *)((long)puVar11 + 0x14) = *(uint *)((long)puVar11 + 0x14) | 8;\n        *puVar11 = redirection_undo_list;\n        redirection_undo_list = puVar11;\n        iVar3 = (int)local_70;\n      }\nLAB_0019d02e:\n      if (iVar5 == 0) {\n        if (((byte)subshell_environment & 1) == 0) {\n          local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d04b;\n          check_bash_input(0);\n          iVar3 = (int)local_70;\n        }\n      }\n      else {\n        local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d98c;\n        check_bash_input(iVar5);\n        if (iVar5 == 1) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d9a6;\n          iVar4 = fileno(stdout);\n          iVar3 = (int)local_70;\n          if (iVar4 == 1) {\n            *(undefined8 *)((long)puVar18 + -8) = 0x19d9bf;\n            fflush(stdout);\n            *(undefined8 *)((long)puVar18 + -8) = 0x19d9cb;\n            fpurge(stdout);\n            iVar3 = (int)local_70;\n          }\n        }\n        else {\n          iVar3 = (int)local_70;\n          if (iVar5 == 2) {\n            *(undefined8 *)((long)puVar18 + -8) = 0x19dbb9;\n            iVar4 = fileno(stderr);\n            iVar3 = (int)local_70;\n            if (iVar4 == 2) {\n              *(undefined8 *)((long)puVar18 + -8) = 0x19dbd2;\n              fflush(stderr);\n              *(undefined8 *)((long)puVar18 + -8) = 0x19dbde;\n              fpurge(stderr);\n              iVar3 = (int)local_70;\n            }\n          }\n        }\n      }\n      if ((*(byte *)(param_1 + 0x10) & 1) == 0) {\n        if (iVar5 != iVar3) {\n          local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d06d;\n          iVar4 = dup2(iVar3,iVar5);\n          iVar3 = (int)local_70;\n          if (iVar4 < 0) {\n            *(undefined8 *)((long)puVar18 + -8) = 0x19de73;\n            close(iVar3);\n            goto LAB_0019cf9d;\n          }\n        }\n      }\n      else {\n        puVar11 = *(undefined8 **)(param_1 + 8);\n        local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n        uVar23 = *puVar11;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d955;\n        lVar13 = bind_var_to_int(uVar23,(long)iVar5,0);\n        if ((lVar13 == 0) || ((*(uint *)(lVar13 + 0x28) & 0x4002) != 0)) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19de58;\n          close(iVar5);\n          iVar5 = (int)local_70;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19de60;\n          close(iVar5);\n          iVar3 = -5;\n          goto LAB_0019c8b3;\n        }\n        uVar23 = *puVar11;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d977;\n        stupidly_hack_special_variables(uVar23);\n        iVar3 = (int)local_70;\n      }\n      if ((uVar1 == 1) || (uVar1 == 0xb)) {\n        local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19db47;\n        duplicate_buffered_stream(iVar3,iVar5);\n        iVar3 = (int)local_70;\n      }\n      if (((param_2 & 4) != 0) && (2 < iVar5)) {\n        local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19dc5f;\n        fcntl(iVar5,2,1);\n        iVar3 = (int)local_70;\n      }\n      if (iVar5 != iVar3) goto LAB_0019d0a7;\n      goto LAB_0019d0c5;\n    }\n    local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n    *(undefined8 *)((long)puVar18 + -8) = 0x19d215;\n    iVar5 = fcntl(iVar3,0,10);\n    *(undefined8 *)((long)puVar18 + -8) = 0x19d21d;\n    piVar10 = __errno_location();\n    iVar3 = *piVar10;\n    if (-1 < iVar5) {\n      iVar3 = (int)local_70;\n      if ((param_2 & 2) != 0) {\n        if ((*(byte *)(param_1 + 0x10) & 1) == 0) goto LAB_0019db50;\n        if (varassign_redir_autoclose != 0) goto LAB_0019d24f;\n      }\n      goto LAB_0019d02e;\n    }\n    *(undefined8 *)((long)puVar18 + -8) = 0x19dd20;\n    sys_error(\"redirection error: cannot duplicate fd\");\n    iVar5 = (int)local_70;\n    *(undefined8 *)((long)puVar18 + -8) = 0x19dd28;\n    close(iVar5);\n    *(undefined8 *)((long)puVar18 + -8) = 0x19dd32;\n    set_exit_status(1);\n    goto joined_r0x0019d1f2;\n  case 4:\n  case 5:\n  case 8:\n    if (ppcVar7 != (char **)0x0) {\n      ppcVar15 = (char **)*ppcVar7;\n      if (ppcVar15 == (char **)0x0) {\nLAB_0019d700:\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d710;\n        local_48 = open(\"/dev/null\",0);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d718;\n        ppcVar7 = (char **)__errno_location();\n        uVar6 = *(undefined4 *)ppcVar7;\nLAB_0019ccd0:\n        *(undefined4 *)ppcVar7 = uVar6;\nLAB_0019ccd2:\n        if (local_48 < 0) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19dfff;\n          piVar10 = __errno_location();\n          iVar5 = *piVar10;\nLAB_0019d451:\n          iVar3 = -4;\n          DAT_002489f8 = iVar5;\n          goto LAB_0019c8b3;\n        }\n      }\n      else {\n        if (*(char *)ppcVar15 == '\\0') {\nLAB_0019cc7b:\n          local_78 = ppcVar15;\n          local_70 = ppcVar7;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19cc93;\n          local_48 = open(\"/dev/null\",0);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19cc9b;\n          ppcVar7 = (char **)__errno_location();\n          uVar6 = *(undefined4 *)ppcVar7;\n          ppcVar15 = local_78;\n          if (local_78 != (char **)*local_70) {\nLAB_0019ccad:\n            local_78 = (char **)CONCAT44(local_78._4_4_,uVar6);\n            local_70 = ppcVar7;\n            *(undefined8 *)((long)puVar18 + -8) = 0x19ccc8;\n            sh_xfree(ppcVar15,\"redir.c\",0x1ca);\n            ppcVar7 = local_70;\n            uVar6 = (int)local_78;\n          }\n          goto LAB_0019ccd0;\n        }\n        if (uVar1 == 5) {\n          expanding_redir = 1;\n          local_70 = ppcVar7;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d2b5;\n          sv_ifs(&DAT_001fce6e);\n          pcVar8 = *local_70;\n          local_80 = (char *)local_70;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d2c7;\n          local_78 = (char **)expand_assignment_string_to_string(pcVar8);\n          uVar6 = executing_builtin;\n          expanding_redir = 0;\n          executing_builtin = 1;\n          local_70 = (char **)CONCAT44(local_70._4_4_,uVar6);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d2f0;\n          sv_ifs(&DAT_001fce6e);\n          ppcVar7 = (char **)local_80;\n          executing_builtin = (int)local_70;\n          ppcVar15 = local_78;\n          if ((local_78 == (char **)0x0) || (*(char *)local_78 == '\\0')) {\n            local_80 = (char *)0x0;\n            bVar22 = true;\n            uVar14 = 1;\n            lVar13 = 2;\n          }\n          else if (*(char *)((long)local_78 + 1) == '\\0') {\n            local_80 = (char *)0x1;\n            bVar22 = true;\n            uVar14 = 2;\n            lVar13 = 3;\n          }\n          else {\nLAB_0019d31f:\n            ppcVar15 = local_78;\n            ppcVar7 = (char **)local_80;\n            if (*(char *)((long)local_78 + 2) == '\\0') {\n              if (uVar1 != 5) {\n                sVar9 = 2;\n                ppcVar15 = local_78;\n                goto joined_r0x0019da08;\n              }\n              local_80 = (char *)0x2;\n              bVar22 = true;\n              uVar14 = 3;\n              lVar13 = 4;\n            }\n            else {\n              local_78 = (char **)local_80;\n              local_70 = ppcVar15;\n              *(undefined8 *)((long)puVar18 + -8) = 0x19ddd8;\n              sVar9 = strlen((char *)ppcVar15);\n              if (uVar1 != 5) goto LAB_0019dd71;\n              lVar13 = sVar9 + 2;\n              uVar14 = sVar9 + 1;\n              bVar22 = uVar14 < 0x10001;\n              ppcVar7 = local_78;\n              ppcVar15 = local_70;\n              local_80 = (char *)sVar9;\n            }\n          }\n          local_78 = (char **)CONCAT71(local_78._1_7_,bVar22);\n          local_70 = ppcVar7;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19dcb6;\n          ppcVar15 = (char **)sh_xrealloc(ppcVar15,lVar13,\"redir.c\",400);\n          *(undefined *)((long)ppcVar15 + (long)local_80) = 10;\n          *(undefined *)((long)ppcVar15 + uVar14) = 0;\n          ppcVar7 = local_70;\n          local_80 = (char *)ppcVar15;\n          sVar9 = uVar14;\n          cVar21 = (char)local_78;\nLAB_0019dcd0:\n          if ((shell_compatibility_level < 0x33) || (cVar21 == '\\0')) goto LAB_0019d350;\nLAB_0019da0e:\n          local_88 = (char **)local_80;\n          local_80 = (char *)ppcVar7;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19da1f;\n          iVar3 = pipe(&local_48);\n          local_78 = (char **)CONCAT44(local_78._4_4_,iVar3);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19da27;\n          local_70 = (char **)__errno_location();\n          iVar3 = local_44;\n          ppcVar15 = (char **)local_80;\n          ppcVar7 = local_88;\n          if ((int)local_78 < 0) {\n            iVar5 = *(int *)local_70;\n            if (*(char ***)local_80 != local_88) {\n              local_78 = (char **)CONCAT44(local_78._4_4_,*(int *)local_70);\n              *(undefined8 *)((long)puVar18 + -8) = 0x19df89;\n              sh_xfree(ppcVar7,\"redir.c\",0x1dd);\n              iVar5 = (int)local_78;\n            }\n            *(int *)local_70 = iVar5;\n            goto LAB_0019d451;\n          }\n          local_80 = (char *)local_88;\n          local_78 = ppcVar15;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19da57;\n          iVar4 = fcntl(iVar3,0x408,0);\n          iVar3 = local_44;\n          ppcVar15 = (char **)local_80;\n          ppcVar7 = local_78;\n          if ((ulong)(long)iVar4 < sVar9) goto LAB_0019d350;\n          local_80 = (char *)local_78;\n          *(undefined4 *)local_70 = 0;\n          local_78 = ppcVar15;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19da8a;\n          uVar14 = write(iVar3,ppcVar15,sVar9);\n          ppcVar7 = local_78;\n          iVar3 = *(int *)local_70;\n          if (uVar14 != sVar9) {\n            if (iVar3 == 0) {\n              iVar3 = 0x1c;\n            }\n            if (local_78 == *(char ***)local_80) {\n              local_78 = (char **)CONCAT44(local_78._4_4_,iVar3);\n              *(undefined8 *)((long)puVar18 + -8) = 0x19dabf;\n              close(local_44);\n            }\n            else {\n              local_78 = (char **)CONCAT44(local_78._4_4_,iVar3);\n              *(undefined8 *)((long)puVar18 + -8) = 0x19e01d;\n              sh_xfree(ppcVar7,\"redir.c\",0x1e9);\n              *(undefined8 *)((long)puVar18 + -8) = 0x19e025;\n              close(local_44);\n            }\n            *(undefined8 *)((long)puVar18 + -8) = 0x19dacd;\n            close(local_48);\n            *(int *)local_70 = (int)local_78;\n            iVar5 = (int)local_78;\n            goto LAB_0019d451;\n          }\n          if (local_78 == *(char ***)local_80) {\n            *(undefined8 *)((long)puVar18 + -8) = 0x19dd09;\n            close(local_44);\n          }\n          else {\n            *(undefined8 *)((long)puVar18 + -8) = 0x19df59;\n            sh_xfree(ppcVar7,\"redir.c\",0x1e9);\n            *(undefined8 *)((long)puVar18 + -8) = 0x19df61;\n            close(local_44);\n          }\n          goto LAB_0019ccd2;\n        }\n        if ((*(byte *)(ppcVar7 + 1) & 2) == 0) {\n          expanding_redir = 1;\n          local_70 = ppcVar7;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19cc19;\n          sv_ifs(&DAT_001fce6e);\n          pcVar8 = *local_70;\n          local_80 = (char *)local_70;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19cc2e;\n          local_78 = (char **)expand_string_to_string(pcVar8);\n          uVar6 = executing_builtin;\n          expanding_redir = 0;\n          executing_builtin = 1;\n          local_70 = (char **)CONCAT44(local_70._4_4_,uVar6);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19cc57;\n          sv_ifs(&DAT_001fce6e);\n          executing_builtin = (int)local_70;\n          if (local_78 == (char **)0x0) goto LAB_0019d700;\n          ppcVar7 = (char **)local_80;\n          ppcVar15 = local_78;\n          if (*(char *)local_78 == '\\0') goto LAB_0019cc7b;\n          if (*(char *)((long)local_78 + 1) != '\\0') goto LAB_0019d31f;\n          sVar9 = 1;\n          ppcVar15 = local_78;\n        }\n        else if (*(char *)((long)ppcVar15 + 1) == '\\0') {\n          sVar9 = 1;\n        }\n        else {\n          if (*(char *)((long)ppcVar15 + 2) != '\\0') {\n            local_78 = ppcVar7;\n            local_70 = ppcVar15;\n            *(undefined8 *)((long)puVar18 + -8) = 0x19dd66;\n            sVar9 = strlen((char *)ppcVar15);\nLAB_0019dd71:\n            cVar21 = sVar9 < 0x10001;\n            ppcVar7 = local_78;\n            local_80 = (char *)local_70;\n            if (sVar9 != 0) goto LAB_0019dcd0;\n            *(undefined8 *)((long)puVar18 + -8) = 0x19dd92;\n            local_70 = (char **)__errno_location();\n            *(undefined8 *)((long)puVar18 + -8) = 0x19dda6;\n            local_48 = open(\"/dev/null\",0);\n            uVar6 = *(undefined4 *)local_70;\n            ppcVar7 = local_70;\n            ppcVar15 = (char **)local_80;\n            if (*local_78 != local_80) goto LAB_0019ccad;\n            goto LAB_0019ccd0;\n          }\n          sVar9 = 2;\n        }\njoined_r0x0019da08:\n        local_80 = (char *)ppcVar15;\n        if (0x32 < shell_compatibility_level) goto LAB_0019da0e;\nLAB_0019d350:\n        local_88 = (char **)local_80;\n        local_80 = (char *)ppcVar7;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d36d;\n        uVar6 = sh_mktmpfd(\"sh-thd\",5,&local_50);\n        local_70 = (char **)CONCAT44(local_70._4_4_,uVar6);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d375;\n        local_78 = (char **)__errno_location();\n        ppcVar7 = (char **)local_80;\n        iVar3 = (int)local_70;\n        if ((int)local_70 < 0) {\n          iVar5 = *(int *)local_78;\n          if (local_50 != (char *)0x0) {\n            local_80 = (char *)CONCAT44(local_80._4_4_,*(int *)local_78);\n            local_70 = ppcVar7;\n            *(undefined8 *)((long)puVar18 + -8) = 0x19d6a3;\n            sh_xfree(local_50,\"redir.c\",0x1fd);\n            ppcVar7 = local_70;\n            iVar5 = (int)local_80;\n          }\n          ppcVar15 = local_88;\n          if (((char **)*ppcVar7 != local_88) && (local_88 != (char **)0x0)) {\n            local_70 = (char **)CONCAT44(local_70._4_4_,iVar5);\n            *(undefined8 *)((long)puVar18 + -8) = 0x19d6cf;\n            sh_xfree(ppcVar15,\"redir.c\",0x1ff);\n            iVar5 = (int)local_70;\n          }\n          *(int *)local_78 = iVar5;\n          goto LAB_0019d451;\n        }\n        local_80 = (char *)local_88;\n        local_88 = ppcVar7;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d3a1;\n        fchmod(iVar3,0x180);\n        iVar3 = (int)local_70;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d3b5;\n        fcntl(iVar3,2,1);\n        ppcVar7 = (char **)local_80;\n        iVar3 = (int)local_70;\n        *(undefined4 *)local_78 = 0;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d3ce;\n        sVar12 = write(iVar3,ppcVar7,sVar9);\n        ppcVar7 = (char **)local_80;\n        iVar3 = *(int *)local_78;\n        if (sVar12 != sVar9) {\n          if (iVar3 == 0) {\n            iVar3 = 0x1c;\n          }\n          ppcVar15 = (char **)\"redir.c\";\n          if ((local_80 != *local_88) && ((char **)local_80 != (char **)0x0)) {\n            local_88 = (char **)CONCAT44(local_88._4_4_,iVar3);\n            local_80 = \"redir.c\";\n            *(undefined8 *)((long)puVar18 + -8) = 0x19d417;\n            sh_xfree(ppcVar7,\"redir.c\",0x20a);\n            ppcVar15 = (char **)local_80;\n            iVar3 = (int)local_88;\n          }\n          iVar5 = (int)local_70;\n          local_80 = (char *)CONCAT44(local_80._4_4_,iVar3);\n          local_88 = ppcVar15;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d42d;\n          close(iVar5);\n          pcVar8 = local_50;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d436;\n          unlink(pcVar8);\n          ppcVar7 = local_88;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d448;\n          sh_xfree(local_50,ppcVar7,0x210);\n          *(int *)local_78 = (int)local_80;\n          iVar5 = (int)local_80;\n          goto LAB_0019d451;\n        }\n        ppcVar15 = (char **)\"redir.c\";\n        if ((local_80 != *local_88) && ((char **)local_80 != (char **)0x0)) {\n          local_80 = \"redir.c\";\n          *(undefined8 *)((long)puVar18 + -8) = 0x19dc04;\n          sh_xfree(ppcVar7,\"redir.c\",0x20a);\n          ppcVar15 = (char **)local_80;\n        }\n        pcVar8 = local_50;\n        local_80 = (char *)ppcVar15;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d7a6;\n        local_48 = open(pcVar8,0,0x180);\n        pcVar8 = local_50;\n        ppcVar7 = local_78;\n        if (local_48 < 0) {\n          local_78 = (char **)CONCAT44(local_78._4_4_,*(undefined4 *)local_78);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19dfa9;\n          unlink(pcVar8);\n          ppcVar15 = (char **)local_80;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19dfbb;\n          sh_xfree(local_50,ppcVar15,0x21e);\n          iVar5 = (int)local_70;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19dfc3;\n          close(iVar5);\n          *(int *)ppcVar7 = (int)local_78;\n          iVar5 = (int)local_78;\n          goto LAB_0019d451;\n        }\n        iVar3 = (int)local_70;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d7c1;\n        close(iVar3);\n        pcVar8 = local_50;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d7ca;\n        iVar3 = unlink(pcVar8);\n        ppcVar15 = local_78;\n        ppcVar7 = (char **)local_80;\n        if (iVar3 < 0) {\n          local_70 = (char **)CONCAT44(local_70._4_4_,*(undefined4 *)local_78);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19dfde;\n          close(local_48);\n          ppcVar7 = (char **)local_80;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19dff0;\n          sh_xfree(local_50,ppcVar7,0x239);\n          *(int *)ppcVar15 = (int)local_70;\n          iVar5 = (int)local_70;\n          goto LAB_0019d451;\n        }\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d7e7;\n        sh_xfree(local_50,ppcVar7,0x23e);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d7f4;\n        fchmod(local_48,0x100);\n      }\n      if ((*(byte *)(param_1 + 0x10) & 1) != 0) {\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d561;\n        iVar5 = fcntl(local_48,0,10);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d569;\n        piVar10 = __errno_location();\n        if (iVar5 < 0) {\n          local_70 = (char **)CONCAT44(local_70._4_4_,*piVar10);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d587;\n          sys_error(\"redirection error: cannot duplicate fd\");\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d58f;\n          close(local_48);\n          goto LAB_0019d58f;\n        }\n      }\n      if ((param_2 & 1) == 0) {\nLAB_0019d4f0:\n        if (iVar5 == local_48) break;\n      }\n      else {\n        if ((param_2 & 2) != 0) {\n          if ((*(byte *)(param_1 + 0x10) & 1) == 0) {\n            if (iVar5 != local_48) {\n              *(undefined8 *)((long)puVar18 + -8) = 0x19d882;\n              iVar3 = fcntl(iVar5,1,0);\n              if (iVar3 != -1) {\n                *(undefined8 *)((long)puVar18 + -8) = 0x19d89b;\n                iVar3 = FUN_0019bf00(iVar5,uVar16,0xffffffff);\n                if (iVar3 < 0) goto LAB_0019d8a6;\n                goto LAB_0019d49d;\n              }\n            }\nLAB_0019d468:\n            DAT_00248a00 = DAT_00248a00 & 0xffffffff00000000;\n            *(undefined8 *)((long)puVar18 + -8) = 0x19d488;\n            puVar11 = (undefined8 *)make_redirection(iVar5,9,DAT_00248a00,0);\n            *(uint *)((long)puVar11 + 0x14) = *(uint *)((long)puVar11 + 0x14) | 8;\n            *puVar11 = redirection_undo_list;\n            redirection_undo_list = puVar11;\n            goto LAB_0019d49d;\n          }\n          if (varassign_redir_autoclose == 0) goto LAB_0019d49d;\n          if (iVar5 == local_48) goto LAB_0019d468;\n          DAT_00248a00 = DAT_00248a00 & 0xffffffff00000000;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19cd3a;\n          puVar11 = (undefined8 *)make_redirection(iVar5,9,DAT_00248a00,0);\n          *(uint *)((long)puVar11 + 0x14) = *(uint *)((long)puVar11 + 0x14) | 8;\n          *puVar11 = redirection_undo_list;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19cd57;\n          redirection_undo_list = puVar11;\n          check_bash_input(iVar5);\n          if ((*(byte *)(param_1 + 0x10) & 1) == 0) goto LAB_0019cd68;\nLAB_0019dae0:\n          puVar11 = *(undefined8 **)(param_1 + 8);\n          uVar23 = *puVar11;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19daf1;\n          lVar13 = bind_var_to_int(uVar23,(long)iVar5,0);\n          if ((lVar13 == 0) || ((*(uint *)(lVar13 + 0x28) & 0x4002) != 0)) {\n            *(undefined8 *)((long)puVar18 + -8) = 0x19de80;\n            close(iVar5);\n            *(undefined8 *)((long)puVar18 + -8) = 0x19de88;\n            close(local_48);\n            iVar3 = -5;\n            goto LAB_0019c8b3;\n          }\n          uVar23 = *puVar11;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19db0f;\n          stupidly_hack_special_variables(uVar23);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19db1a;\n          duplicate_buffered_stream(local_48,iVar5);\n          if (((param_2 & 4) != 0) && (2 < iVar5)) goto LAB_0019d4d7;\n          goto LAB_0019d4f0;\n        }\nLAB_0019d49d:\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d4a5;\n        check_bash_input(iVar5);\n        if ((*(byte *)(param_1 + 0x10) & 1) != 0) goto LAB_0019dae0;\n        if (iVar5 == local_48) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d4c3;\n          duplicate_buffered_stream(iVar5,iVar5);\n          if (((param_2 & 4) == 0) || (iVar5 < 3)) break;\nLAB_0019d4d7:\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d4eb;\n          fcntl(iVar5,2,1);\n          goto LAB_0019d4f0;\n        }\nLAB_0019cd68:\n        *(undefined8 *)((long)puVar18 + -8) = 0x19cd73;\n        iVar3 = dup2(local_48,iVar5);\n        if (iVar3 < 0) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19de98;\n          piVar10 = __errno_location();\n          local_70 = (char **)CONCAT44(local_70._4_4_,*piVar10);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19dea7;\n          close(local_48);\n          iVar3 = (int)local_70;\n          goto LAB_0019c8b3;\n        }\n        *(undefined8 *)((long)puVar18 + -8) = 0x19cd86;\n        duplicate_buffered_stream(local_48,iVar5);\n        if (((param_2 & 4) != 0) && (2 < iVar5)) goto LAB_0019d4d7;\n      }\n      *(undefined8 *)((long)puVar18 + -8) = 0x19cda8;\n      close_buffered_fd(local_48);\n      iVar3 = 0;\n      goto LAB_0019c8b3;\n    }\n    break;\n  case 6:\n  case 7:\n  case 0xf:\n  case 0x10:\n    if ((param_2 & 1) != 0) {\n      if ((*(byte *)(param_1 + 0x10) & 1) != 0) {\n        local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d5c5;\n        iVar5 = fcntl(iVar3,0,10);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d5cd;\n        piVar10 = __errno_location();\n        iVar3 = (int)local_70;\n        if (-1 < iVar5) goto LAB_0019ca04;\n        local_70 = (char **)CONCAT44(local_70._4_4_,*piVar10);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d5ef;\n        sys_error(\"redirection error: cannot duplicate fd\");\nLAB_0019d58f:\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d599;\n        set_exit_status(1);\n        iVar3 = (int)local_70;\n        goto joined_r0x0019d1f2;\n      }\nLAB_0019ca04:\n      if (iVar3 == iVar5) break;\n      if ((param_2 & 2) != 0) {\n        if ((*(byte *)(param_1 + 0x10) & 1) == 0) {\n          local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d815;\n          iVar4 = fcntl(iVar5,1,0);\n          iVar3 = (int)local_70;\n          if (iVar4 == -1) goto LAB_0019ca2b;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d830;\n          iVar4 = FUN_0019bf00(iVar5,uVar16,iVar3);\n          iVar3 = (int)local_70;\n          if (iVar4 < 0) goto LAB_0019d195;\n        }\n        else if (varassign_redir_autoclose != 0) {\nLAB_0019ca2b:\n          local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n          DAT_00248a00 = DAT_00248a00 & 0xffffffff00000000;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19ca4f;\n          puVar11 = (undefined8 *)make_redirection(iVar5,9,DAT_00248a00,0);\n          *(uint *)((long)puVar11 + 0x14) = *(uint *)((long)puVar11 + 0x14) | 8;\n          *puVar11 = redirection_undo_list;\n          redirection_undo_list = puVar11;\n          iVar3 = (int)local_70;\n        }\n        if (uVar1 - 0xf < 2) {\n          local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19ca87;\n          iVar4 = fcntl(iVar5,1,0);\n          iVar3 = (int)local_70;\n          if (iVar4 != -1) {\n            *(undefined8 *)((long)puVar18 + -8) = 0x19caa2;\n            iVar4 = FUN_0019bf00(iVar3,9,0xffffffff);\n            iVar3 = (int)local_70;\n            if (iVar4 < 0) goto LAB_0019d195;\n          }\n        }\n      }\n      if ((iVar5 != 0) || (((byte)subshell_environment & 1) == 0)) {\n        local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19caca;\n        check_bash_input(iVar5);\n        iVar3 = (int)local_70;\n      }\n      if ((*(byte *)(param_1 + 0x10) & 1) == 0) {\n        local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d6ef;\n        iVar4 = dup2(iVar3,iVar5);\n        iVar3 = (int)local_70;\n        if (iVar4 < 0) goto LAB_0019cf9d;\n      }\n      else {\n        puVar11 = *(undefined8 **)(param_1 + 8);\n        local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n        uVar23 = *puVar11;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19caed;\n        lVar13 = bind_var_to_int(uVar23,(long)iVar5,0);\n        if ((lVar13 == 0) || ((*(uint *)(lVar13 + 0x28) & 0x4002) != 0)) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19dd4b;\n          close(iVar5);\n          iVar3 = -5;\n          goto LAB_0019c8b3;\n        }\n        uVar23 = *puVar11;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19cb0b;\n        stupidly_hack_special_variables(uVar23);\n        iVar3 = (int)local_70;\n      }\n      if ((uVar1 == 6) || (uVar1 == 0xf)) {\n        local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d9e7;\n        duplicate_buffered_stream(iVar3,iVar5);\n        iVar3 = (int)local_70;\n      }\n      local_70 = (char **)CONCAT44(local_70._4_4_,iVar3);\n      *(undefined8 *)((long)puVar18 + -8) = 0x19cb38;\n      iVar3 = fcntl(iVar3,1,0);\n      uVar16 = (ulong)local_70 & 0xffffffff;\n      if ((iVar3 == 1) || ((((int)local_70 < 2 && ((param_2 & 8) != 0)) || ((param_2 & 4) != 0)))) {\n        if (2 < iVar5) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d542;\n          fcntl(iVar5,2,1);\n          uVar16 = (ulong)local_70 & 0xffffffff;\n          goto LAB_0019cb59;\n        }\n      }\n      else {\nLAB_0019cb59:\n        if ((((*(uint *)(param_1 + 0x14) & 0x28) == 0x28) && (2 < iVar5)) &&\n           ((9 < (int)uVar16 || ((*(uint *)(param_1 + 0x14) & 0x40) != 0)))) {\n          local_70 = (char **)CONCAT44(local_70._4_4_,(int)uVar16);\n          *(undefined8 *)((long)puVar18 + -8) = 0x19cb8b;\n          fcntl(iVar5,2,0);\n          uVar16 = (ulong)local_70 & 0xffffffff;\n        }\n      }\n      if (uVar1 - 0xf < 2) {\n        local_70 = (char **)CONCAT44(local_70._4_4_,(int)uVar16);\n        *(undefined8 *)((long)puVar18 + -8) = 0x19cbaa;\n        xtrace_fdchk(uVar16);\n        iVar5 = (int)local_70;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19cbb2;\n        close(iVar5);\n        uVar16 = (ulong)local_70 & 0xffffffff;\n        *(undefined8 *)((long)puVar18 + -8) = 0x19cbba;\n        coproc_fdchk(uVar16);\n        iVar3 = 0;\n        goto LAB_0019c8b3;\n      }\n    }\n    break;\n  case 9:\n    if ((param_2 & 1) == 0) break;\n    local_48 = iVar5;\n    if ((*(byte *)(param_1 + 0x10) & 1) != 0) {\n      uVar23 = **(undefined8 **)(param_1 + 8);\n      *(undefined8 *)((long)puVar18 + -8) = 0x19d609;\n      iVar5 = valid_array_reference(uVar23,0);\n      if (iVar5 == 0) {\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d61b;\n        lVar13 = find_variable(uVar23);\n        if (lVar13 == 0) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19de11;\n          lVar13 = find_variable_last_nameref(uVar23,0);\n          if (lVar13 != 0) {\n            if ((*(uint *)(lVar13 + 0x28) & 0x800) != 0) {\n              uVar23 = *(undefined8 *)(lVar13 + 8);\n              *(undefined8 *)((long)puVar18 + -8) = 0x19deee;\n              iVar5 = valid_array_reference(uVar23,0);\n              if (iVar5 != 0) goto LAB_0019d8f0;\n              *(undefined8 *)((long)puVar18 + -8) = 0x19df00;\n              lVar13 = find_variable(uVar23);\n              goto LAB_0019d905;\n            }\n            if ((*(uint *)(lVar13 + 0x28) & 0x1000) == 0) goto LAB_0019d62d;\n          }\n        }\n        else if ((*(byte *)(lVar13 + 0x29) & 0x10) == 0) {\nLAB_0019d62d:\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d632;\n          pcVar8 = (char *)get_variable_value(lVar13);\n          goto LAB_0019d635;\n        }\n      }\n      else {\nLAB_0019d8f0:\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d902;\n        lVar13 = array_variable_part(uVar23,0,&local_50,local_64);\nLAB_0019d905:\n        if ((lVar13 != 0) && ((*(uint *)(lVar13 + 0x28) & 0x1000) == 0)) {\n          if ((iVar5 == 0) || ((*(uint *)(lVar13 + 0x28) & 0x44) == 0)) goto LAB_0019d62d;\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d936;\n          pcVar8 = (char *)get_array_value(uVar23,0,0);\nLAB_0019d635:\n          if ((pcVar8 != (char *)0x0) && (*pcVar8 != '\\0')) {\n            *(undefined8 *)((long)puVar18 + -8) = 0x19d648;\n            iVar5 = legal_number(pcVar8,local_58);\n            if ((-1 < iVar5) && (local_48 = local_58[0], -1 < local_58[0])) goto LAB_0019c870;\n          }\n        }\n      }\n      goto LAB_0019d660;\n    }\nLAB_0019c870:\n    if ((param_2 & 2) == 0) {\nLAB_0019c87a:\n      *(undefined8 *)((long)puVar18 + -8) = 0x19c882;\n      coproc_fdchk(local_48);\n      *(undefined8 *)((long)puVar18 + -8) = 0x19c88a;\n      xtrace_fdchk(local_48);\n      if ((local_48 != 0) || (((byte)subshell_environment & 1) == 0)) {\n        *(undefined8 *)((long)puVar18 + -8) = 0x19c8a0;\n        check_bash_input(local_48);\n      }\n      *(undefined8 *)((long)puVar18 + -8) = 0x19c8a8;\n      iVar5 = close_buffered_fd(local_48);\n      if ((iVar5 < 0) && ((param_2 & 8) != 0)) {\n        *(undefined8 *)((long)puVar18 + -8) = 0x19d1cf;\n        piVar10 = __errno_location();\n        if ((*piVar10 == 5) || (*piVar10 == 0x1c)) {\n          *(undefined8 *)((long)puVar18 + -8) = 0x19d1ec;\n          set_exit_status(1);\n          iVar3 = *piVar10;\n          goto joined_r0x0019d1f2;\n        }\n      }\n      break;\n    }\n    *(undefined8 *)((long)puVar18 + -8) = 0x19d169;\n    iVar5 = fcntl(local_48,1,0);\n    if (iVar5 == -1) {\n      DAT_00248a00 = DAT_00248a00 & 0xffffffff00000000;\n      *(undefined8 *)((long)puVar18 + -8) = 0x19d8d0;\n      puVar11 = (undefined8 *)make_redirection(local_48,9,DAT_00248a00,0);\n      *(uint *)((long)puVar11 + 0x14) = *(uint *)((long)puVar11 + 0x14) | 8;\n      *puVar11 = redirection_undo_list;\n      redirection_undo_list = puVar11;\n      goto LAB_0019c87a;\n    }\n    *(undefined8 *)((long)puVar18 + -8) = 0x19d184;\n    iVar5 = FUN_0019bf00(local_48,9,0xffffffff);\n    if (-1 < iVar5) goto LAB_0019c87a;\n    if (-1 < local_48) {\nLAB_0019d8a6:\n      *(undefined8 *)((long)puVar18 + -8) = 0x19d8ab;\n      close(local_48);\n    }\nLAB_0019d195:\n    *(undefined8 *)((long)puVar18 + -8) = 0x19d19f;\n    set_exit_status(1);\n    *(undefined8 *)((long)puVar18 + -8) = 0x19d1a4;\n    piVar10 = __errno_location();\n    iVar3 = *piVar10;\njoined_r0x0019d1f2:\n    if (iVar3 == 0) {\n      iVar3 = 0x16;\n    }\n    goto LAB_0019c8b3;\n  }\n  iVar3 = 0;\nLAB_0019c8b3:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  *(undefined8 *)((long)puVar18 + -8) = 0x19df6b;\n  __stack_chk_fail();\n}\n\n",
  "rl_add_undo": "\nvoid rl_add_undo(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)xmalloc(0x20);\n  *(undefined4 *)(puVar1 + 3) = param_1;\n  *puVar1 = rl_undo_list;\n  *(undefined4 *)(puVar1 + 1) = param_2;\n  *(undefined4 *)((long)puVar1 + 0xc) = param_3;\n  puVar1[2] = param_4;\n  rl_undo_list = puVar1;\n  return;\n}\n\n",
  "remember_args": "\nvoid remember_args(long *param_1,int param_2)\n\n{\n  bool bVar1;\n  size_t sVar2;\n  char *__dest;\n  char *pcVar3;\n  int iVar4;\n  char **ppcVar5;\n  bool bVar6;\n  \n  ppcVar5 = (char **)&DAT_00242228;\n  iVar4 = 1;\n  bVar6 = param_2 != 0;\n  posparam_count = 0;\n  do {\n    while (bVar1 = param_1 != (long *)0x0 || bVar6, param_1 != (long *)0x0 || bVar6) {\n      if (*ppcVar5 != (char *)0x0) {\n        sh_xfree(*ppcVar5,\"common.c\",0x18e);\n        *ppcVar5 = (char *)0x0;\n      }\n      bVar1 = bVar6;\n      if (param_1 != (long *)0x0) {\n        pcVar3 = *(char **)param_1[1];\n        sVar2 = strlen(pcVar3);\n        __dest = (char *)sh_xmalloc(sVar2 + 1,\"common.c\",0x194);\n        posparam_count = iVar4;\n        pcVar3 = strcpy(__dest,pcVar3);\n        param_1 = (long *)*param_1;\n        *ppcVar5 = pcVar3;\n        bVar1 = param_1 != (long *)0x0 || bVar6;\n      }\n      iVar4 = iVar4 + 1;\n      ppcVar5 = ppcVar5 + 1;\n      if (iVar4 == 10) goto LAB_001a4250;\n    }\n    iVar4 = iVar4 + 1;\n    param_1 = (long *)0x0;\n    ppcVar5 = ppcVar5 + 1;\n  } while (iVar4 != 10);\nLAB_001a4250:\n  if (bVar1) {\n    dispose_words(rest_of_args);\n    rest_of_args = copy_word_list(param_1);\n    iVar4 = list_length(param_1);\n    posparam_count = posparam_count + iVar4;\n    if (param_2 != 0) {\n      if (variable_context == 0) {\n        if (this_shell_builtin == set_builtin) {\n          DAT_00248a98 = DAT_00248a98 | 4;\n        }\n        else {\n          DAT_00248a98 = DAT_00248a98 | 1;\n        }\n      }\n      else {\n        DAT_00248a98 = DAT_00248a98 | 2;\n      }\n    }\n  }\n  invalidate_cached_quoted_dollar_at();\n  return;\n}\n\n",
  "FUN_00152410": "\nlong FUN_00152410(long param_1)\n\n{\n  time_t tVar1;\n  undefined8 uVar2;\n  \n  tVar1 = time((time_t *)0x0);\n  uVar2 = itos(tVar1);\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x527);\n  }\n  *(undefined8 *)(param_1 + 8) = uVar2;\n  return param_1;\n}\n\n",
  "FUN_001f5220": "\nint FUN_001f5220(undefined8 param_1,int param_2,int param_3)\n\n{\n  char *pcVar1;\n  bool bVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  char *__file;\n  long lVar6;\n  size_t sVar7;\n  void *__buf;\n  char **ppcVar8;\n  ssize_t sVar9;\n  int *piVar10;\n  int iVar11;\n  int iVar12;\n  int iVar13;\n  long *plVar14;\n  long *plVar15;\n  long in_FS_OFFSET;\n  char *local_f8;\n  size_t local_e8;\n  int local_e0;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar13 = (-(uint)(param_3 == 0) & 0x1c0) + 0x241;\n  __file = (char *)FUN_001f5180();\n  if (__file == (char *)0x0) {\n    piVar10 = __errno_location();\n    iVar13 = *piVar10;\n    goto LAB_001f5500;\n  }\n  iVar3 = stat(__file,&local_d8);\n  if (iVar3 == 0) {\n    if (((param_3 == 0) || ((local_d8.st_mode & 0xf000) != 0x8000)) ||\n       (local_f8 = (char *)FUN_001f4f60(__file), local_f8 == (char *)0x0)) {\n      bVar2 = true;\n      goto LAB_001f52a1;\n    }\n    local_e0 = open(local_f8,iVar13,0x180);\n    if (local_e0 == -1) {\n      piVar10 = __errno_location();\n      iVar13 = *piVar10;\n      free(__file);\n      free(local_f8);\n      goto LAB_001f5500;\n    }\n    bVar2 = true;\nLAB_001f52c8:\n    iVar13 = history_length;\n    if (param_2 <= history_length) {\n      iVar13 = param_2;\n    }\n    lVar6 = history_list();\n    iVar3 = history_write_timestamps;\n    iVar11 = history_length - iVar13;\n    if (iVar11 < history_length) {\n      iVar4 = history_length + -1;\n      plVar14 = (long *)(lVar6 + (long)iVar11 * 8);\n      iVar12 = 0;\n      do {\n        ppcVar8 = (char **)*plVar14;\n        if (((iVar3 != 0) && (pcVar1 = ppcVar8[1], pcVar1 != (char *)0x0)) && (*pcVar1 != '\\0')) {\n          sVar7 = strlen(pcVar1);\n          iVar12 = iVar12 + 1 + (int)sVar7;\n        }\n        plVar14 = plVar14 + 1;\n        sVar7 = strlen(*ppcVar8);\n        iVar12 = iVar12 + 1 + (int)sVar7;\n      } while ((long *)(lVar6 + ((long)iVar11 + 1 + (ulong)(uint)(iVar4 - iVar11)) * 8) != plVar14);\n      local_e8 = (size_t)iVar12;\n    }\n    else {\n      local_e8 = 0;\n    }\n    __buf = malloc(local_e8);\n    iVar3 = history_write_timestamps;\n    if (__buf != (void *)0x0) {\n      iVar11 = history_length - iVar13;\n      if (iVar11 < history_length) {\n        iVar12 = history_length + -1;\n        iVar4 = 0;\n        plVar14 = (long *)(lVar6 + (long)iVar11 * 8);\n        do {\n          ppcVar8 = (char **)*plVar14;\n          if (((iVar3 != 0) && (pcVar1 = ppcVar8[1], pcVar1 != (char *)0x0)) && (*pcVar1 != '\\0')) {\n            strcpy((char *)((long)iVar4 + (long)__buf),pcVar1);\n            sVar7 = strlen(*(char **)(*plVar14 + 8));\n            iVar5 = (int)sVar7 + iVar4;\n            iVar4 = iVar5 + 1;\n            *(undefined *)((long)__buf + (long)iVar5) = 10;\n            ppcVar8 = (char **)*plVar14;\n          }\n          plVar15 = plVar14 + 1;\n          strcpy((char *)((long)iVar4 + (long)__buf),*ppcVar8);\n          sVar7 = strlen(*(char **)*plVar14);\n          iVar5 = (int)sVar7 + iVar4;\n          iVar4 = iVar5 + 1;\n          *(undefined *)((long)__buf + (long)iVar5) = 10;\n          plVar14 = plVar15;\n        } while (plVar15 !=\n                 (long *)(lVar6 + ((long)iVar11 + 1 + (ulong)(uint)(iVar12 - iVar11)) * 8));\n      }\n      sVar9 = write(local_e0,__buf,local_e8);\n      if (sVar9 < 0) {\n        piVar10 = __errno_location();\n        iVar3 = *piVar10;\n        xfree(__buf);\n        history_lines_written_to_file = iVar13;\n        iVar13 = close(local_e0);\n        if (-1 < iVar13) goto LAB_001f5580;\n        if (iVar3 == 0) goto LAB_001f5578;\nLAB_001f555f:\n        iVar13 = *piVar10;\n        if (local_f8 != (char *)0x0) {\nLAB_001f54a3:\n          unlink(local_f8);\n        }\n        history_lines_written_to_file = 0;\n        bVar2 = (bool)(bVar2 & iVar13 == 0);\nLAB_001f54c0:\n        if (bVar2) {\nLAB_001f54c7:\n          iVar13 = 0;\n          chown(__file,local_d8.st_uid,local_d8.st_gid);\n        }\n      }\n      else {\n        xfree(__buf);\n        history_lines_written_to_file = iVar13;\n        iVar13 = close(local_e0);\n        if (iVar13 < 0) {\nLAB_001f5578:\n          piVar10 = __errno_location();\n          iVar3 = *piVar10;\nLAB_001f5580:\n          if (iVar3 != 0) {\n            piVar10 = __errno_location();\n            goto LAB_001f555f;\n          }\n        }\n        if (local_f8 != (char *)0x0) {\n          iVar13 = FUN_001f50f0(local_f8,__file);\n          if (iVar13 != 0) {\n            piVar10 = __errno_location();\n            iVar13 = *piVar10;\n            goto LAB_001f54a3;\n          }\n          goto LAB_001f54c0;\n        }\n        iVar13 = 0;\n        if (bVar2) goto LAB_001f54c7;\n      }\n      free(__file);\n      if (local_f8 != (char *)0x0) {\n        free(local_f8);\n      }\n      goto LAB_001f5500;\n    }\n    piVar10 = __errno_location();\n    iVar13 = *piVar10;\n    close(local_e0);\n    if (local_f8 != (char *)0x0) {\n      unlink(local_f8);\n      free(__file);\n      free(local_f8);\n      goto LAB_001f5500;\n    }\n  }\n  else {\n    bVar2 = false;\nLAB_001f52a1:\n    local_e0 = open(__file,iVar13,0x180);\n    if (local_e0 != -1) {\n      local_f8 = (char *)0x0;\n      goto LAB_001f52c8;\n    }\n    piVar10 = __errno_location();\n    iVar13 = *piVar10;\n  }\n  free(__file);\nLAB_001f5500:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar13;\n}\n\n",
  "ferror": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_ferror_002378c0)();\n  return iVar1;\n}\n\n",
  "sh_mktmpname": "\nundefined8 * sh_mktmpname(char *param_1,uint param_2)\n\n{\n  uint uVar1;\n  undefined8 *__template;\n  undefined8 uVar2;\n  size_t sVar3;\n  char *pcVar4;\n  ulong uVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined8 *puVar8;\n  byte bVar9;\n  \n  bVar9 = 0;\n  __template = (undefined8 *)sh_xmalloc(0x1001,\"tmpfile.c\",0x90);\n  uVar2 = FUN_001c6e70(param_2);\n  if ((undefined8 *)param_1 == (undefined8 *)0x0) {\n    param_1 = \"shtmp\";\n  }\n  else if (((param_2 & 8) != 0) && (sVar3 = strlen(param_1), sVar3 < 0x1001)) {\n    uVar5 = sVar3 + 1;\n    uVar1 = (uint)uVar5;\n    if (uVar1 < 8) {\n      if ((uVar5 & 4) == 0) {\n        if ((uVar1 != 0) && (*(char *)__template = *param_1, (uVar5 & 2) != 0)) {\n          *(undefined2 *)((long)__template + ((uVar5 & 0xffffffff) - 2)) =\n               *(undefined2 *)((long)param_1 + ((uVar5 & 0xffffffff) - 2));\n        }\n      }\n      else {\n        *(undefined4 *)__template = *(undefined4 *)param_1;\n        *(undefined4 *)((long)__template + ((uVar5 & 0xffffffff) - 4)) =\n             *(undefined4 *)((long)param_1 + ((uVar5 & 0xffffffff) - 4));\n      }\n    }\n    else {\n      *__template = *(undefined8 *)param_1;\n      *(undefined8 *)((long)__template + ((uVar5 & 0xffffffff) - 8)) =\n           *(undefined8 *)((long)param_1 + ((uVar5 & 0xffffffff) - 8));\n      lVar6 = (long)__template - (long)(undefined8 *)((ulong)(__template + 1) & 0xfffffffffffffff8);\n      puVar7 = (undefined8 *)((long)param_1 - lVar6);\n      puVar8 = (undefined8 *)((ulong)(__template + 1) & 0xfffffffffffffff8);\n      for (uVar5 = (ulong)(uVar1 + (int)lVar6 >> 3); uVar5 != 0; uVar5 = uVar5 - 1) {\n        *puVar8 = *puVar7;\n        puVar7 = puVar7 + (ulong)bVar9 * -2 + 1;\n        puVar8 = puVar8 + (ulong)bVar9 * -2 + 1;\n      }\n    }\n    goto LAB_001c6ffb;\n  }\n  __sprintf_chk(__template,1,0xffffffffffffffff,\"%s/%s.XXXXXX\",uVar2,param_1);\nLAB_001c6ffb:\n  pcVar4 = mktemp((char *)__template);\n  puVar7 = __template;\n  if (pcVar4 == (char *)0x0) {\n    puVar7 = (undefined8 *)0x0;\n    sh_xfree(__template,\"tmpfile.c\",0xa2);\n  }\n  return puVar7;\n}\n\n",
  "buffered_ungetchar": "\nint buffered_ungetchar(int param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  lVar1 = *(long *)(DAT_00247f68 + (long)(int)DAT_00240a70 * 8);\n  if (((param_1 != -1) && (lVar1 != 0)) && (lVar2 = *(long *)(lVar1 + 0x28), lVar2 != 0)) {\n    *(long *)(lVar1 + 0x28) = lVar2 + -1;\n    *(char *)(*(long *)(lVar1 + 8) + -1 + lVar2) = (char)param_1;\n    return param_1;\n  }\n  return -1;\n}\n\n",
  "rl_history_substr_search_forward": "\nundefined8 rl_history_substr_search_forward(int param_1,undefined4 param_2)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  if ((rl_last_func != rl_history_substr_search_forward) &&\n     (rl_last_func != rl_history_substr_search_backward)) {\n    FUN_001d4840(0);\n  }\n  if (DAT_0024a46c != 0) {\n    iVar2 = -param_1;\n    if (0 < param_1) {\n      iVar2 = param_1;\n    }\n    uVar1 = FUN_001d4900(iVar2,((0 < param_1) - 1) + (uint)(0 < param_1));\n    return uVar1;\n  }\n  uVar1 = rl_get_next_history(param_1,param_2);\n  return uVar1;\n}\n\n",
  "assign_array_var_from_string": "\nlong assign_array_var_from_string(long param_1,long param_2,undefined4 param_3)\n\n{\n  long lVar1;\n  \n  if (param_2 != 0) {\n    lVar1 = expand_compound_array_assignment();\n    assign_compound_array_list(param_1,lVar1,param_3);\n    if (lVar1 != 0) {\n      dispose_words(lVar1);\n    }\n    if (param_1 != 0) {\n      *(uint *)(param_1 + 0x28) = *(uint *)(param_1 + 0x28) & 0xffffefff;\n    }\n  }\n  return param_1;\n}\n\n",
  "closedir": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint closedir(DIR *__dirp)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_closedir_00237aa0)();\n  return iVar1;\n}\n\n",
  "rl_dump_variables": "\nundefined8 rl_dump_variables(void)\n\n{\n  if (rl_dispatching != 0) {\n    fwrite(&DAT_001ff375,1,2,rl_outstream);\n  }\n  rl_variable_dumper(rl_explicit_arg);\n  rl_on_new_line();\n  return 0;\n}\n\n",
  "read_command": "\nundefined4 read_command(void)\n\n{\n  undefined4 uVar1;\n  uint __seconds;\n  long lVar2;\n  long lVar3;\n  undefined8 uVar4;\n  \n  set_current_prompt_level();\n  global_command = 0;\n  if (interactive != 0) {\n    lVar2 = find_variable();\n    if (lVar2 != 0) {\n      if (*(char **)(lVar2 + 8) == (char *)0x0) {\n        uVar4 = 0;\n        __seconds = 0;\n      }\n      else {\n        uVar4 = 0;\n        lVar3 = strtol(*(char **)(lVar2 + 8),(char **)0x0,10);\n        __seconds = (uint)lVar3;\n        if (0 < (int)__seconds) {\n          uVar4 = set_signal_handler(0xe,FUN_00134320);\n          alarm(__seconds);\n        }\n      }\n      goto LAB_001345a4;\n    }\n  }\n  uVar4 = 0;\n  __seconds = 0;\n  lVar2 = 0;\nLAB_001345a4:\n  if (terminating_signal != 0) {\n    termsig_handler();\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n  }\n  current_command_line_count = 0;\n  uVar1 = parse_command();\n  if (((interactive != 0) && (lVar2 != 0)) && (0 < (int)__seconds)) {\n    alarm(0);\n    set_signal_handler(0xe,uVar4);\n    return uVar1;\n  }\n  return uVar1;\n}\n\n",
  "array_dequote": "\nlong array_dequote(long param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long lVar4;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  lVar1 = *(long *)(param_1 + 0x10);\n  lVar3 = lVar1;\n  if (lVar1 != 0) {\n    if (*(long *)(param_1 + 8) == 0) {\n      return 0;\n    }\n    lVar4 = *(long *)(lVar1 + 0x10);\n    lVar3 = param_1;\n    if (lVar1 != lVar4) {\n      do {\n        uVar2 = dequote_string(*(undefined8 *)(lVar4 + 8));\n        if (*(long *)(lVar4 + 8) != 0) {\n          sh_xfree(*(long *)(lVar4 + 8),\"array.c\",0x164);\n        }\n        *(undefined8 *)(lVar4 + 8) = uVar2;\n        lVar4 = *(long *)(lVar4 + 0x10);\n      } while (*(long *)(param_1 + 0x10) != lVar4);\n    }\n  }\n  return lVar3;\n}\n\n",
  "FUN_0019c1e0": "\nint FUN_0019c1e0(char *param_1,uint param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  stat sStack_158;\n  stat local_c8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = stat(param_1,&sStack_158);\n  if (iVar1 == 0) {\n    if ((sStack_158.st_mode & 0xf000) != 0x8000) {\n      iVar1 = open(param_1,param_2 & 0xfffffdff,0x1b6);\n      if (iVar1 < 0) goto LAB_0019c260;\n      iVar2 = fstat(iVar1,&local_c8);\n      if (((iVar2 == 0) && ((local_c8.st_mode & 0xf000) != 0x8000)) &&\n         ((sStack_158.st_mode & 0xf000) != 0x8000)) {\n        iVar2 = same_file(param_1,param_1,&sStack_158,&local_c8);\n        if (iVar2 != 0) goto LAB_0019c235;\n      }\n      close(iVar1);\n      piVar3 = __errno_location();\n      *piVar3 = 0x11;\n    }\n  }\n  else {\n    iVar1 = open(param_1,param_2 & 0xfffffdff | 0x80,0x1b6);\n    if (-1 < iVar1) goto LAB_0019c235;\nLAB_0019c260:\n    piVar3 = __errno_location();\n    if (*piVar3 != 0x11) goto LAB_0019c235;\n  }\n  iVar1 = -2;\nLAB_0019c235:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "putenv": "\nint putenv(char *__string)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  int *piVar4;\n  long lVar5;\n  \n  if (*__string != '\\0') {\n    iVar1 = assignment(__string,0);\n    lVar5 = (long)iVar1;\n    if (__string[lVar5] == '=') {\n      sVar2 = strlen(__string);\n      pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"getenv.c\",0x7c);\n      pcVar3 = strcpy(pcVar3,__string);\n      pcVar3[lVar5] = '\\0';\n      lVar5 = bind_variable(pcVar3,pcVar3 + lVar5 + 1,0);\n      if (lVar5 != 0) {\n        *(uint *)(lVar5 + 0x28) = *(uint *)(lVar5 + 0x28) & 0xffffefff | 1;\n        return 0;\n      }\n    }\n  }\n  piVar4 = __errno_location();\n  *piVar4 = 0x16;\n  return -1;\n}\n\n",
  "with_input_from_stream": "\nvoid with_input_from_stream(undefined8 param_1,undefined8 param_2)\n\n{\n  init_yy_io(FUN_00135010,FUN_00135000,2,param_2,param_1);\n  return;\n}\n\n",
  "FUN_001cfa00": "\nvoid FUN_001cfa00(void)\n\n{\n  _rl_callback_func = 0;\n  _rl_want_redisplay = 1;\n  FUN_001cf980();\n  return;\n}\n\n",
  "FUN_001aba30": "\nvoid FUN_001aba30(int param_1)\n\n{\n  char *__file;\n  int __fd;\n  int *piVar1;\n  char *pcVar2;\n  char **ppcVar3;\n  \n  ppcVar3 = *(char ***)(shell_builtins + (long)param_1 * 0x30 + 0x18);\n  if ((ppcVar3 != (char **)0x0) && (__file = *ppcVar3, __file != (char *)0x0)) {\n    if ((*__file == '/') && (ppcVar3[1] == (char *)0x0)) {\n      __fd = open(__file,0);\n      if (__fd == -1) {\n        piVar1 = __errno_location();\n        pcVar2 = strerror(*piVar1);\n        builtin_error(\"%s: cannot open: %s\",__file,pcVar2);\n        return;\n      }\n      if (-1 < __fd) {\n        zcatfd(__fd,1,*ppcVar3);\n        close(__fd);\n        return;\n      }\n    }\n    else {\n      do {\n        ppcVar3 = ppcVar3 + 1;\n        __printf_chk(1,\"%*s%s\\n\",4,&DAT_001fdb1c);\n      } while (*ppcVar3 != (char *)0x0);\n    }\n  }\n  return;\n}\n\n",
  "readlink": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nssize_t readlink(char *__path,char *__buf,size_t __len)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = (*(code *)PTR_readlink_00237930)();\n  return sVar1;\n}\n\n",
  "sv_histsize": "\nvoid sv_histsize(long param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  char *pcVar4;\n  long in_FS_OFFSET;\n  ulong local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar3 = find_variable();\n  if (((lVar3 == 0) || (pcVar4 = (char *)get_variable_value(lVar3), pcVar4 == (char *)0x0)) ||\n     (*pcVar4 == '\\0')) {\n    cVar1 = *(char *)(param_1 + 4);\n  }\n  else {\n    iVar2 = legal_number(pcVar4,&local_28);\n    if (iVar2 == 0) goto LAB_00154215;\n    cVar1 = *(char *)(param_1 + 4);\n    iVar2 = (int)local_28;\n    if (-1 < iVar2) {\n      if (cVar1 == 'S') {\n        stifle_history(local_28 & 0xffffffff);\n        iVar2 = where_history();\n        if (iVar2 < history_lines_this_session) {\n          history_lines_this_session = iVar2;\n        }\n      }\n      else {\n        lVar3 = find_variable(\"HISTFILE\");\n        if (lVar3 != 0) {\n          lVar3 = get_variable_value(lVar3);\n        }\n        history_truncate_file(lVar3,local_28 & 0xffffffff);\n        if (iVar2 < history_lines_in_file) {\n          history_lines_in_file = iVar2;\n        }\n      }\n      goto LAB_00154215;\n    }\n  }\n  if (cVar1 == 'S') {\n    unstifle_history();\n  }\nLAB_00154215:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "internal_inform": "\nvoid internal_inform(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                    undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                    undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                    undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  FUN_0015b0b0(1);\n  fwrite(\"INFORM: \",1,8,stderr);\n  local_d0 = &stack0x00000008;\n  local_d8 = 8;\n  local_c8 = local_b8;\n  local_d4 = 0x30;\n  __vfprintf_chk(stderr,1,param_9,&local_d8);\n  fputc(10,stderr);\n  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "set_original_signal": "\nvoid set_original_signal(int param_1,long param_2)\n\n{\n  long lVar1;\n  \n  if (((param_1 - 1U < 0x40) &&\n      (lVar1 = (long)param_1, *(code **)(original_signals + lVar1 * 8) == initialize_traps)) &&\n     (*(long *)(original_signals + lVar1 * 8) = param_2, param_2 == 1)) {\n    (&DAT_00247e40)[lVar1] = (&DAT_00247e40)[lVar1] | 2;\n    return;\n  }\n  return;\n}\n\n",
  "sh_ttyerror": "\nvoid sh_ttyerror(int param_1)\n\n{\n  int *piVar1;\n  char *pcVar2;\n  \n  piVar1 = __errno_location();\n  if (param_1 != 0) {\n    pcVar2 = strerror(*piVar1);\n    builtin_error(\"error setting terminal attributes: %s\",pcVar2);\n    return;\n  }\n  pcVar2 = strerror(*piVar1);\n  builtin_error(\"error getting terminal attributes: %s\",pcVar2);\n  return;\n}\n\n",
  "_rl_start_using_history": "\nvoid _rl_start_using_history(void)\n\n{\n  using_history();\n  if (_rl_saved_line_for_history != 0) {\n    _rl_free_saved_history_line();\n  }\n  _rl_saved_line_for_history = 0;\n  _rl_history_search_pos = 0xffffff9d;\n  return;\n}\n\n",
  "unbind_nameref": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 unbind_nameref(undefined8 param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long lVar4;\n  \n  lVar4 = shell_variables;\n  if (shell_variables != 0) {\n    do {\n      uVar3 = *(undefined8 *)(lVar4 + 0x20);\n      lVar2 = hash_search(param_1,uVar3,0);\n      if ((lVar2 != 0) && (_DAT_002422f8 = uVar3, *(long *)(lVar2 + 0x10) != 0)) {\n        if ((*(byte *)(*(long *)(lVar2 + 0x10) + 0x29) & 8) == 0) {\n          return 0;\n        }\n        uVar3 = makunbound(param_1,shell_variables);\n        return uVar3;\n      }\n      plVar1 = (long *)(lVar4 + 0x18);\n      lVar4 = *plVar1;\n    } while (*plVar1 != 0);\n  }\n  return 0;\n}\n\n",
  "decode_prompt_string": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 decode_prompt_string(char *param_1)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  undefined4 uVar3;\n  int iVar4;\n  undefined *puVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined2 *puVar8;\n  tm *ptVar9;\n  char *pcVar10;\n  undefined8 uVar11;\n  char *pcVar12;\n  undefined2 *puVar13;\n  size_t sVar14;\n  char cVar15;\n  char cVar16;\n  undefined uVar17;\n  char *pcVar18;\n  uint uVar19;\n  long lVar20;\n  uint uVar21;\n  long in_FS_OFFSET;\n  bool bVar22;\n  int local_10ec;\n  ulong local_10e8;\n  long local_10e0;\n  time_t local_10d8;\n  char local_10cc [3];\n  undefined local_10c9;\n  char local_10c8 [127];\n  undefined local_1049;\n  char local_1048 [4104];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_10e8 = 0x30;\n  puVar5 = (undefined *)sh_xmalloc(0x30,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1635);\n  local_10e0 = 0;\n  *puVar5 = 0;\n  uVar19 = (uint)*param_1;\n  uVar21 = posixly_correct;\n  if (*param_1 != '\\0') {\n    pcVar18 = param_1 + 1;\n    pcVar10 = param_1;\n    do {\n      while( true ) {\n        pcVar12 = current_host_name;\n        if ((uVar21 != 0) && (uVar19 == 0x21)) {\n          if (pcVar10[1] == '!') {\n            puVar8 = (undefined2 *)sh_xmalloc(2,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1640);\n            *puVar8 = 0x21;\n          }\n          else {\n            iVar4 = FUN_00135030(param_1);\n            puVar8 = (undefined2 *)itos((long)iVar4);\n            pcVar18 = pcVar10;\n          }\n          goto LAB_00136985;\n        }\n        if (uVar19 != 0x5c) break;\n        cVar16 = pcVar10[1];\n        switch(cVar16) {\n        case '!':\n          iVar4 = FUN_00135030(param_1);\n          puVar8 = (undefined2 *)itos((long)iVar4);\n          break;\n        default:\nswitchD_001368f3_caseD_22:\n          puVar8 = (undefined2 *)sh_xmalloc(3,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1784);\n          *(undefined *)puVar8 = 0x5c;\n          *(char *)((long)puVar8 + 1) = cVar16;\n          *(undefined *)(puVar8 + 1) = 0;\n          goto LAB_00136ac3;\n        case '#':\n          local_10ec = current_command_number;\n          if ((ps0_prompt != param_1) && (ps1_prompt != param_1)) {\n            local_10ec = current_command_number - (uint)(ps2_prompt != param_1);\n          }\n          puVar8 = (undefined2 *)itos((long)local_10ec);\n          break;\n        case '$':\n          puVar8 = (undefined2 *)sh_xmalloc(3,\"/usr/local/src/chet/src/bash/src/parse.y\",0x174b);\n          puVar13 = puVar8;\n          if ((promptvars | posixly_correct) == 0) {\nLAB_00136e8a:\n            if (DAT_00238044 == 0) {\n              cVar16 = '#';\n            }\n          }\n          else {\n            if (DAT_00238044 != 0) {\n              *(undefined *)puVar8 = 0x5c;\n              puVar13 = (undefined2 *)((long)puVar8 + 1);\n              goto LAB_00136e8a;\n            }\n            cVar16 = '#';\n          }\n          *(char *)puVar13 = cVar16;\n          *(undefined *)((long)puVar13 + 1) = 0;\n          break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n          pcVar10 = strncpy(local_10cc,pcVar18,3);\n          local_10c9 = 0;\n          local_10ec = read_octal(pcVar10);\n          puVar8 = (undefined2 *)sh_xmalloc(3,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1660);\n          if ((local_10ec == 1) || (local_10ec == 0x7f)) {\n            *(undefined *)puVar8 = 1;\n            *(undefined *)(puVar8 + 1) = 0;\n            *(undefined *)((long)puVar8 + 1) = (undefined)local_10ec;\n            pcVar10 = pcVar18;\n            if (local_10ec != -1) goto LAB_00137018;\n          }\n          else if (local_10ec == -1) {\n            *puVar8 = 0x5c;\n            pcVar10 = pcVar18;\n          }\n          else {\n            *(undefined *)((long)puVar8 + 1) = 0;\n            *(undefined *)puVar8 = (undefined)local_10ec;\nLAB_00137018:\n            do {\n              pcVar12 = pcVar18 + 1;\n              pcVar10 = pcVar18;\n              if (7 < (byte)(*pcVar18 - 0x30U)) break;\n              pcVar18 = pcVar12;\n              pcVar10 = pcVar18 + 3;\n            } while (pcVar18 + 3 != pcVar12);\n          }\n          goto LAB_00136989;\n        case '@':\n        case 'A':\n        case 'T':\n        case 'd':\n        case 't':\n          time(&local_10d8);\n          sv_tz(&DAT_001faa61);\n          ptVar9 = localtime(&local_10d8);\n          if (cVar16 == 'd') {\n            sVar14 = strftime(local_10c8,0x80,\"%a %b %d\",ptVar9);\n            local_10ec = (int)sVar14;\n          }\n          else if (cVar16 == 't') {\n            sVar14 = strftime(local_10c8,0x80,\"%H:%M:%S\",ptVar9);\n            local_10ec = (int)sVar14;\n          }\n          else if (cVar16 == 'T') {\n            sVar14 = strftime(local_10c8,0x80,\"%I:%M:%S\",ptVar9);\n            local_10ec = (int)sVar14;\n          }\n          else if (cVar16 == '@') {\n            sVar14 = strftime(local_10c8,0x80,\"%I:%M %p\",ptVar9);\n            local_10ec = (int)sVar14;\n          }\n          else if (cVar16 == 'A') {\n            sVar14 = strftime(local_10c8,0x80,\"%H:%M\",ptVar9);\n            local_10ec = (int)sVar14;\n          }\n          if (local_10ec == 0) {\n            local_10c8[0] = '\\0';\n          }\n          else {\n            local_1049 = 0;\n          }\n          sVar14 = strlen(local_10c8);\n          uVar11 = 0x1695;\nLAB_00136c0f:\n          pcVar10 = (char *)sh_xmalloc(sVar14 + 1,\"/usr/local/src/chet/src/bash/src/parse.y\",uVar11)\n          ;\n          puVar8 = (undefined2 *)strcpy(pcVar10,local_10c8);\n          goto LAB_00136ac3;\n        case 'D':\n          if (pcVar10[2] != '{') goto switchD_001368f3_caseD_22;\n          pcVar18 = pcVar10 + 3;\n          time(&local_10d8);\n          ptVar9 = localtime(&local_10d8);\n          sVar14 = strlen(pcVar18);\n          puVar13 = (undefined2 *)\n                    sh_xmalloc(sVar14 + 3,\"/usr/local/src/chet/src/bash/src/parse.y\",0x169f);\n          cVar16 = pcVar10[3];\n          puVar8 = puVar13;\n          while ((cVar16 != '\\0' && (cVar16 != '}'))) {\n            pcVar18 = pcVar18 + 1;\n            *(char *)puVar8 = cVar16;\n            puVar8 = (undefined2 *)((long)puVar8 + 1);\n            cVar16 = *pcVar18;\n          }\n          *(undefined *)puVar8 = 0;\n          cVar16 = *pcVar18;\n          if (*(char *)puVar13 == '\\0') {\n            *(undefined *)(puVar13 + 1) = 0;\n            *puVar13 = 0x5825;\n          }\n          sVar14 = strftime(local_10c8,0x80,(char *)puVar13,ptVar9);\n          local_10ec = (int)sVar14;\n          sh_xfree(puVar13,\"/usr/local/src/chet/src/bash/src/parse.y\",0x16ab);\n          if (local_10ec == 0) {\n            local_10c8[0] = '\\0';\n          }\n          else {\n            local_1049 = 0;\n          }\n          if ((promptvars | posixly_correct) == 0) {\n            sVar14 = strlen(local_10c8);\n            uVar11 = 0x16b8;\n            goto LAB_00136c0f;\n          }\n          puVar8 = (undefined2 *)sh_backslash_quote_for_double_quotes(local_10c8,0);\n          goto LAB_00136ac3;\n        case 'H':\n        case 'h':\n          sVar14 = strlen(current_host_name);\n          pcVar10 = (char *)sh_xmalloc(sVar14 + 1,\"/usr/local/src/chet/src/bash/src/parse.y\",0x172c)\n          ;\n          pcVar10 = strcpy(pcVar10,pcVar12);\n          if ((cVar16 == 'h') && (pcVar12 = strchr(pcVar10,0x2e), pcVar12 != (char *)0x0)) {\n            *pcVar12 = '\\0';\n          }\n          if ((promptvars | posixly_correct) == 0) {\n            sVar14 = strlen(pcVar10);\n            pcVar12 = (char *)sh_xmalloc(sVar14 + 1,\"/usr/local/src/chet/src/bash/src/parse.y\",\n                                         0x1735);\n            puVar8 = (undefined2 *)strcpy(pcVar12,pcVar10);\n          }\n          else {\n            puVar8 = (undefined2 *)sh_backslash_quote_for_double_quotes(pcVar10,0);\n          }\n          sh_xfree(pcVar10,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1736);\n          goto LAB_00136ac3;\n        case 'V':\n        case 'v':\n          puVar8 = (undefined2 *)sh_xmalloc(0x10,\"/usr/local/src/chet/src/bash/src/parse.y\",0x16d2);\n          if (cVar16 != 'v') {\n            __sprintf_chk(puVar8,1,0xffffffffffffffff,\"%s.%d\",dist_version,patch_level);\n            goto LAB_00136ac3;\n          }\n          strcpy((char *)puVar8,dist_version);\n          break;\n        case 'W':\n        case 'w':\n          pcVar10 = (char *)get_string_value(&DAT_001fc3d5);\n          if (pcVar10 == (char *)0x0) {\n            pcVar10 = getcwd(local_1048,0x1000);\n            if (pcVar10 == (char *)0x0) {\n              local_1048[0] = '.';\n              iVar4 = 1;\n            }\n            else {\n              sVar14 = strlen(local_1048);\n              iVar4 = (int)sVar14;\n            }\n          }\n          else {\n            strncpy(local_1048,pcVar10,0xfff);\n            iVar4 = 0xfff;\n          }\n          local_1048[iVar4] = '\\0';\n          if ((cVar16 == 'W') &&\n             (((pcVar10 = (char *)get_string_value(&DAT_001faa94), cVar15 = local_1048[0],\n               pcVar10 == (char *)0x0 || (*pcVar10 != local_1048[0])) ||\n              (iVar4 = strcmp(pcVar10,local_1048), iVar4 != 0)))) {\n            if (((cVar15 != '/') ||\n                ((local_1048[1] != '\\0' && ((local_1048[1] != '/' || (local_1048[2] != '\\0')))))) &&\n               (pcVar10 = strrchr(local_1048,0x2f), pcVar10 != (char *)0x0)) {\n              sVar14 = strlen(pcVar10);\n              __memmove_chk(local_1048,pcVar10 + 1,sVar14,0x1000);\n            }\n          }\n          else {\n            pcVar10 = (char *)polite_directory_format(local_1048);\n            if (pcVar10 != local_1048) {\n              __strcpy_chk(local_1048,pcVar10,0x1000);\n            }\n          }\n          trim_pathname(local_1048,0xfff);\n          if ((promptvars | posixly_correct) == 0) {\n            puVar8 = (undefined2 *)sh_strvis(local_1048);\n          }\n          else {\n            uVar11 = sh_strvis(local_1048);\n            puVar8 = (undefined2 *)sh_backslash_quote_for_double_quotes(uVar11,0);\n            sh_xfree(uVar11,\"/usr/local/src/chet/src/bash/src/parse.y\",0x171c);\n          }\n          goto LAB_00136ac3;\n        case '[':\n        case ']':\n          if (no_line_editing != 0) {\n            pcVar10 = pcVar10 + 2;\n            goto LAB_001368a4;\n          }\n          puVar8 = (undefined2 *)sh_xmalloc(3,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1768);\n          if (cVar16 == '[') {\n            *(undefined *)puVar8 = 1;\n            puVar13 = (undefined2 *)((long)puVar8 + 1);\n            uVar17 = 1;\n            lVar20 = 2;\n            local_10ec = 1;\n          }\n          else {\n            local_10ec = 2;\n            uVar17 = 2;\n            lVar20 = 1;\n            puVar13 = puVar8;\n          }\n          *(undefined *)puVar13 = uVar17;\n          *(undefined *)((long)puVar8 + lVar20) = 0;\n          goto LAB_00136ac3;\n        case '\\\\':\n        case 'a':\n        case 'e':\n        case 'r':\n          puVar8 = (undefined2 *)sh_xmalloc(2,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1776);\n          cVar15 = '\\a';\n          if (((cVar16 != 'a') && (cVar15 = '\\x1b', cVar16 != 'e')) &&\n             (cVar15 = cVar16, cVar16 == 'r')) {\n            cVar15 = '\\r';\n          }\n          *(char *)puVar8 = cVar15;\n          *(undefined *)((long)puVar8 + 1) = 0;\nLAB_00136ac3:\n          pcVar10 = pcVar18;\n          if (cVar16 != '\\0') break;\n          goto LAB_00136989;\n        case 'j':\n          iVar4 = count_all_jobs();\n          puVar8 = (undefined2 *)itos((long)iVar4);\n          break;\n        case 'l':\n          pcVar10 = \"tty\";\n          iVar4 = fileno(stdin);\n          pcVar12 = ttyname(iVar4);\n          lVar20 = 4;\n          if (pcVar12 != (char *)0x0) {\n            pcVar10 = (char *)base_pathname(pcVar12);\n            sVar14 = strlen(pcVar10);\n            lVar20 = sVar14 + 1;\n          }\n          uVar11 = 0x175a;\n          goto LAB_00136e29;\n        case 'n':\n          puVar8 = (undefined2 *)sh_xmalloc(3,\"/usr/local/src/chet/src/bash/src/parse.y\",0x16bc);\n          *(byte *)puVar8 = (-(no_line_editing == 0) & 3U) + 10;\n          bVar22 = no_line_editing == 0;\n          *(undefined *)(puVar8 + 1) = 0;\n          *(byte *)((long)puVar8 + 1) = -bVar22 & 10;\n          break;\n        case 's':\n          uVar11 = base_pathname(shell_name);\n          if ((promptvars | posixly_correct) == 0) {\n            puVar8 = (undefined2 *)sh_strvis(uVar11);\n          }\n          else {\n            uVar11 = sh_strvis(uVar11);\n            puVar8 = (undefined2 *)sh_backslash_quote_for_double_quotes(uVar11,0);\n            sh_xfree(uVar11,\"/usr/local/src/chet/src/bash/src/parse.y\",0x16ca);\n          }\n          break;\n        case 'u':\n          if (DAT_00238050 == (char *)0x0) {\n            get_current_user_info();\n          }\n          pcVar10 = DAT_00238050;\n          sVar14 = strlen(DAT_00238050);\n          uVar11 = 0x1727;\n          lVar20 = sVar14 + 1;\nLAB_00136e29:\n          pcVar12 = (char *)sh_xmalloc(lVar20,\"/usr/local/src/chet/src/bash/src/parse.y\",uVar11);\n          puVar8 = (undefined2 *)strcpy(pcVar12,pcVar10);\n        }\nLAB_00136985:\n        pcVar10 = pcVar18 + 1;\nLAB_00136989:\n        puVar5 = (undefined *)sub_append_string(puVar8,puVar5,&local_10e0,&local_10e8);\n        pcVar18 = pcVar10 + 1;\n        puVar5[local_10e0] = 0;\n        uVar19 = (uint)*pcVar10;\n        uVar21 = posixly_correct;\n        if (*pcVar10 == '\\0') goto LAB_001369c5;\n      }\n      if (local_10e0 + 3U < local_10e8) {\n        uVar21 = uVar19;\n        if (uVar19 == 1) goto LAB_00136940;\nLAB_00136879:\n        uVar17 = (undefined)uVar21;\n        lVar20 = local_10e0;\n        if (uVar19 == 0x7f) goto LAB_00136940;\n      }\n      else {\n        do {\n          local_10e8 = local_10e8 + 0x30;\n        } while (local_10e8 <= local_10e0 + 3U);\n        puVar5 = (undefined *)\n                 sh_xrealloc(puVar5,local_10e8,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1795);\n        uVar21 = uVar19 & 0xff;\n        if (uVar19 != 1) goto LAB_00136879;\nLAB_00136940:\n        uVar17 = (undefined)uVar21;\n        lVar20 = local_10e0 + 1;\n        puVar5[local_10e0] = 1;\n      }\n      local_10e0 = lVar20 + 1;\n      puVar5[lVar20] = uVar17;\n      puVar5[local_10e0] = 0;\n      pcVar10 = pcVar18;\n      uVar21 = posixly_correct;\nLAB_001368a4:\n      uVar19 = (uint)*pcVar10;\n      pcVar18 = pcVar10 + 1;\n    } while (*pcVar10 != '\\0');\n  }\nLAB_001369c5:\n  uVar3 = last_command_exit_value;\n  uVar2 = _DAT_00240a18;\n  uVar11 = dstack;\n  uVar1 = last_command_subst_pid;\n  dstack = _DAT_001fb060;\n  _DAT_00240a18 = _UNK_001fb068;\n  if ((uVar21 | promptvars) == 0) {\n    uVar7 = dequote_string(puVar5);\n    sh_xfree(puVar5,\"/usr/local/src/chet/src/bash/src/parse.y\",0x17b9);\n  }\n  else {\n    uVar6 = expand_prompt_string(puVar5,1,0);\n    sh_xfree(puVar5,\"/usr/local/src/chet/src/bash/src/parse.y\",0x17b0);\n    uVar7 = string_list(uVar6);\n    dispose_words(uVar6);\n    last_command_subst_pid = uVar1;\n    last_command_exit_value = uVar3;\n  }\n  dstack = uVar11;\n  _DAT_00240a18 = uVar2;\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar7;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "strcat": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strcat(char *__dest,char *__src)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strcat_00237dc0)();\n  return pcVar1;\n}\n\n",
  "bind_variable_value": "\nundefined8 * bind_variable_value(undefined8 *param_1,long param_2,uint param_3)\n\n{\n  uint uVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  \n  uVar1 = *(uint *)(param_1 + 5);\n  *(uint *)(param_1 + 5) = uVar1 & 0xffffefff;\n  if ((code *)param_1[4] == (code *)0x0) {\n    uVar4 = make_variable_value(param_1,param_2,param_3);\n    if (((param_3 & 0x30) == 0x10) && (iVar2 = check_selfref(*param_1,uVar4,0), iVar2 != 0)) {\n      if (variable_context == 0) {\n        internal_error(\"%s: nameref variable self references not allowed\",*param_1);\n        uVar5 = 0xd3d;\n        goto LAB_00155f33;\n      }\n      internal_warning(\"%s: circular name reference\");\n    }\n    if (((param_3 & 0x10) != 0) && (iVar2 = valid_nameref_value(uVar4,0), iVar2 == 0)) {\n      uVar5 = 0xd45;\nLAB_00155f33:\n      sh_xfree(uVar4,\"variables.c\",uVar5);\n      if ((uVar1 & 0x1000) != 0) {\n        *(uint *)(param_1 + 5) = *(uint *)(param_1 + 5) | 0x1000;\n      }\n      return (undefined8 *)0x0;\n    }\n    if (param_1[1] != 0) {\n      sh_xfree(param_1[1],\"variables.c\",0xd4a);\n    }\n    param_1[1] = uVar4;\n  }\n  else if ((param_3 & 1) == 0) {\n    (*(code *)param_1[4])(param_1,param_2,0xffffffffffffffff,0);\n  }\n  else {\n    lVar3 = make_variable_value(param_1,param_2,param_3);\n    (*(code *)param_1[4])(param_1,lVar3,0xffffffffffffffff,0);\n    if ((param_2 != lVar3) && (lVar3 != 0)) {\n      sh_xfree(lVar3,\"variables.c\",0xd31);\n    }\n  }\n  if (param_1[2] != 0) {\n    sh_xfree(param_1[2],\"variables.c\",0xd4e);\n    param_1[2] = 0;\n  }\n  if (mark_modified_vars == 0) {\n    if ((*(uint *)(param_1 + 5) & 1) == 0) {\n      return param_1;\n    }\n  }\n  else {\n    *(uint *)(param_1 + 5) = *(uint *)(param_1 + 5) | 1;\n  }\n  array_needs_making = 1;\n  return param_1;\n}\n\n",
  "FUN_00194e70": "\nundefined8 FUN_00194e70(void)\n\n{\n  long lVar1;\n  \n  lVar1 = FUN_001942c0(rl_line_buffer);\n  if (lVar1 != 0) {\n    FUN_00194d10(lVar1);\n    return 0;\n  }\n  FUN_001934f0();\n  return 1;\n}\n\n",
  "cmd_init": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid cmd_init(void)\n\n{\n  wdcache = sh_xmalloc(0x400,\"make_cmd.c\",0x43);\n  _DAT_00241ec8 = 0x80;\n  wlcache = sh_xmalloc(0x400,\"make_cmd.c\",0x44);\n  _DAT_00241eb8 = 0x80;\n  return;\n}\n\n",
  "bash_brace_completion": "\nvoid bash_brace_completion(void)\n\n{\n  undefined4 uVar1;\n  undefined *puVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  \n  uVar5 = rl_completion_entry_function;\n  uVar4 = rl_attempted_completion_function;\n  uVar3 = rl_ignore_some_completions_function;\n  puVar2 = rl_filename_quoting_function;\n  uVar1 = rl_filename_quoting_desired;\n  rl_completion_entry_function = rl_filename_completion_function;\n  rl_attempted_completion_function = 0;\n  rl_ignore_some_completions_function = FUN_001903d0;\n  rl_filename_quoting_function = (undefined *)0x0;\n  rl_filename_quoting_desired = 0;\n  rl_complete_internal(9);\n  rl_ignore_some_completions_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar4;\n  rl_completion_entry_function = (code *)uVar5;\n  rl_filename_quoting_function = puVar2;\n  rl_filename_quoting_desired = uVar1;\n  return;\n}\n\n",
  "FUN_00162660": "\nvoid FUN_00162660(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = __errno_location();\n  DAT_00247694 = DAT_00247694 + 1;\n  iVar1 = *piVar2;\n  if (DAT_00247690 != 0) {\n    *piVar2 = iVar1;\n    return;\n  }\n  FUN_00161c20(0);\n  *piVar2 = iVar1;\n  return;\n}\n\n",
  "readline": "\nundefined8 readline(void)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  \n  if (rl_pending_input == -1) {\n    rl_clear_pending_input();\n    uVar2 = 0;\n  }\n  else {\n    rl_set_prompt();\n    rl_initialize();\n    if (rl_prep_term_function != (undefined *)0x0) {\n      (*(code *)rl_prep_term_function)(_rl_meta_flag);\n    }\n    rl_set_signals();\n    readline_internal_setup();\n    if (rl_done == 0) {\n      do {\n        uVar1 = readline_internal_char();\n      } while (rl_done == 0);\n    }\n    else {\n      uVar1 = 1;\n    }\n    rl_eof_found = uVar1;\n    uVar2 = readline_internal_teardown(uVar1);\n    if (rl_deprep_term_function != (undefined *)0x0) {\n      (*(code *)rl_deprep_term_function)();\n    }\n    rl_clear_signals();\n  }\n  return uVar2;\n}\n\n",
  "FUN_0017b800": "\nsize_t FUN_0017b800(char *param_1)\n\n{\n  byte bVar1;\n  char cVar2;\n  int iVar3;\n  long lVar4;\n  char *pcVar5;\n  size_t sVar6;\n  size_t sVar7;\n  char *__s;\n  long lVar8;\n  uint uVar9;\n  char *unaff_R12;\n  long lVar10;\n  long in_FS_OFFSET;\n  int local_3c;\n  char *local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  bVar1 = param_1[1];\n  if (bVar1 == 0) {\nLAB_0017b998:\n    iVar3 = number_of_args();\n    sVar7 = (size_t)iVar3;\n    goto LAB_0017b99f;\n  }\n  if ((bVar1 != 0x40) && (bVar1 != 0x2a)) {\n    if (((*(byte *)((long)&sh_syntaxtab + (ulong)bVar1 * 4 + 1) & 8) == 0) || (param_1[2] != '\\0'))\n    goto LAB_0017b87a;\n    switch(bVar1) {\n    case 0x21:\n      if (last_asynchronous_pid != -1) {\n        unaff_R12 = (char *)itos((long)last_asynchronous_pid);\n        break;\n      }\n      goto LAB_0017bad6;\n    case 0x23:\n      iVar3 = number_of_args();\n      unaff_R12 = (char *)itos((long)iVar3);\n      break;\n    case 0x24:\n      unaff_R12 = (char *)itos((long)dollar_dollar_pid);\n      break;\n    case 0x2d:\n      unaff_R12 = (char *)which_set_flags();\n      break;\n    case 0x3f:\n      unaff_R12 = (char *)itos((long)last_command_exit_value);\n    }\n    if (unaff_R12 != (char *)0x0) {\n      sVar7 = 0;\n      if (((*unaff_R12 != '\\0') && (sVar7 = 1, unaff_R12[1] != '\\0')) &&\n         (sVar7 = 2, unaff_R12[2] != '\\0')) {\n        sVar7 = strlen(unaff_R12);\n      }\n      sh_xfree(unaff_R12,\"subst.c\",0x1f4a);\n      goto LAB_0017b99f;\n    }\n    goto LAB_0017bad6;\n  }\n  if (param_1[2] == '\\0') goto LAB_0017b998;\nLAB_0017b87a:\n  pcVar5 = param_1 + 1;\n  iVar3 = valid_array_reference(pcVar5,0);\n  if (iVar3 != 0) {\n    lVar4 = array_variable_part(pcVar5,0,&local_38,&local_3c);\n    if ((lVar4 == 0) || (uVar9 = *(uint *)(lVar4 + 0x28), (uVar9 & 0x1000) != 0)) {\n      if (unbound_vars_is_error == 0) goto LAB_0017bad6;\n    }\n    else if (((uVar9 & 0x44) != 0) || (unbound_vars_is_error == 0)) {\n      lVar10 = 0;\n      if ((uVar9 & 4) != 0) {\n        lVar10 = *(long *)(lVar4 + 8);\n      }\n      cVar2 = *local_38;\n      if ((uVar9 & 0x40) != 0) {\n        if ((cVar2 != '@' && cVar2 != '*') || (local_38[1] != ']')) {\n          local_38[(long)local_3c + -1] = '\\0';\n          pcVar5 = (char *)expand_subscript_string(local_38,0);\n          local_38[(long)local_3c + -1] = ']';\n          if (pcVar5 == (char *)0x0) goto LAB_0017beec;\n          if (*pcVar5 == '\\0') {\n            err_badarraysub(local_38);\n            sh_xfree(pcVar5,\"subst.c\",0x1c62);\n            sVar7 = 0xffffffffffffffff;\n            goto LAB_0017b99f;\n          }\n          local_38 = (char *)assoc_reference(*(undefined8 *)(lVar4 + 8),pcVar5);\n          sh_xfree(pcVar5,\"subst.c\",0x1c66);\n          goto LAB_0017b95d;\n        }\n        if (*(long *)(lVar4 + 8) != 0) {\n          sVar7 = (size_t)*(int *)(*(long *)(lVar4 + 8) + 0xc);\n          goto LAB_0017b99f;\n        }\n        goto LAB_0017bad6;\n      }\n      if ((cVar2 == '@' || cVar2 == '*') && (local_38[1] == ']')) {\n        if ((uVar9 & 4) == 0) {\n          sVar7 = (size_t)(*(long *)(lVar4 + 8) != 0);\n        }\n        else {\n          sVar7 = 0;\n          if (lVar10 != 0) {\n            sVar7 = *(size_t *)(lVar10 + 8);\n          }\n        }\n        goto LAB_0017b99f;\n      }\n      lVar8 = array_expand_index(lVar4,local_38,local_3c,0);\n      if ((*(byte *)(lVar4 + 0x28) & 4) == 0) {\n        if (lVar8 < 0) goto LAB_0017beec;\n        local_38 = (char *)0x0;\n        if (lVar8 == 0) {\n          local_38 = *(char **)(lVar4 + 8);\n        }\n      }\n      else {\n        if ((lVar8 < 0) && (lVar8 + 1 + **(long **)(lVar4 + 8) < 0)) {\nLAB_0017beec:\n          err_badarraysub(local_38);\n          sVar7 = 0xffffffffffffffff;\n          goto LAB_0017b99f;\n        }\n        local_38 = (char *)array_reference(lVar10);\n      }\nLAB_0017b95d:\n      sVar6 = __ctype_get_mb_cur_max();\n      sVar7 = 0;\n      if (sVar6 < 2) {\n        if ((((local_38 != (char *)0x0) && (*local_38 != '\\0')) && (sVar7 = 1, local_38[1] != '\\0'))\n           && (sVar7 = 2, local_38[2] != '\\0')) {\n          sVar7 = strlen(local_38);\n          sVar7 = (size_t)(int)sVar7;\n        }\n      }\n      else if (((local_38 != (char *)0x0) && (*local_38 != '\\0')) &&\n              (sVar7 = 1, local_38[1] != '\\0')) {\n        iVar3 = mbstrlen();\n        sVar7 = (size_t)iVar3;\n      }\n      goto LAB_0017b99f;\n    }\n    cVar2 = local_38[-1];\n    local_38[-1] = '\\0';\n    local_38 = local_38 + -1;\n    set_exit_status(1);\n    err_unboundvar(pcVar5);\n    *local_38 = cVar2;\n    sVar7 = 0xffffffffffffffff;\n    goto LAB_0017b99f;\n  }\n  iVar3 = legal_number(pcVar5,&local_38);\n  if (iVar3 != 0) {\n    pcVar5 = (char *)get_dollar_var_value(local_38);\n    if (pcVar5 != (char *)0x0) {\n      sVar7 = __ctype_get_mb_cur_max();\n      if (sVar7 < 2) {\n        sVar7 = 0;\n        if (((*pcVar5 != '\\0') && (sVar7 = 1, pcVar5[1] != '\\0')) && (sVar7 = 2, pcVar5[2] != '\\0'))\n        {\n          sVar7 = strlen(pcVar5);\n        }\n      }\n      else {\n        sVar7 = 0;\n        if ((*pcVar5 != '\\0') && (sVar7 = 1, pcVar5[1] != '\\0')) {\n          sVar7 = mbstrlen(pcVar5);\n        }\n      }\n      sh_xfree(pcVar5,\"subst.c\",0x1f5a);\n      goto LAB_0017b99f;\n    }\nLAB_0017baa8:\n    if (unbound_vars_is_error == 0) {\n      __ctype_get_mb_cur_max();\n      sVar7 = 0;\n    }\n    else {\n      sVar7 = 0x8000000000000000;\n    }\n    goto LAB_0017b99f;\n  }\n  lVar4 = find_variable(pcVar5);\n  if (lVar4 == 0) {\n    lVar4 = find_variable(pcVar5);\n    if (lVar4 != 0) {\n      uVar9 = *(uint *)(lVar4 + 0x28);\n      goto LAB_0017bb68;\n    }\n    if (unbound_vars_is_error == 0) goto LAB_0017bad6;\nLAB_0017bbd0:\n    sVar7 = strlen(param_1);\n    pcVar5 = (char *)sh_xmalloc(sVar7 + 1,\"subst.c\",0x1f73);\n    pcVar5 = strcpy(pcVar5,param_1);\n    *pcVar5 = '$';\n    lVar4 = FUN_0017af90(pcVar5,1);\n    if (lVar4 == 0) {\n      sh_xfree(pcVar5,\"subst.c\",0x1f77);\n      sVar7 = 0;\n      goto LAB_0017b99f;\n    }\n    __s = (char *)string_list_internal(lVar4,&DAT_001fdb1c);\n    sh_xfree(pcVar5,\"subst.c\",0x1f77);\n    dispose_words(lVar4);\n    if (__s != (char *)0x0) {\n      sVar6 = __ctype_get_mb_cur_max();\n      sVar7 = 0;\n      if (sVar6 < 2) {\n        if (((*__s != '\\0') && (sVar7 = 1, __s[1] != '\\0')) && (sVar7 = 2, __s[2] != '\\0')) {\n          sVar7 = strlen(__s);\n        }\n      }\n      else if ((*__s != '\\0') && (sVar7 = 1, __s[1] != '\\0')) {\n        sVar7 = mbstrlen(__s);\n      }\n      sh_xfree(__s,\"subst.c\",0x1f7c);\n      goto LAB_0017b99f;\n    }\n  }\n  else {\n    uVar9 = *(uint *)(lVar4 + 0x28);\n    if (((uVar9 & 0x1000) == 0) && ((uVar9 & 0x44) != 0)) {\n      if ((uVar9 & 0x40) == 0) {\n        pcVar5 = (char *)array_reference(*(undefined8 *)(lVar4 + 8),0);\n      }\n      else {\n        pcVar5 = (char *)assoc_reference(*(undefined8 *)(lVar4 + 8),&DAT_00210deb);\n      }\n      if (pcVar5 == (char *)0x0) goto LAB_0017baa8;\n      sVar7 = __ctype_get_mb_cur_max();\n      if (sVar7 < 2) {\n        if (*pcVar5 == '\\0') goto LAB_0017bad6;\n        if (pcVar5[1] == '\\0') goto LAB_0017bbb1;\n        if (pcVar5[2] != '\\0') {\n          sVar7 = strlen(pcVar5);\n          goto LAB_0017b99f;\n        }\nLAB_0017bf8b:\n        sVar7 = 2;\n        goto LAB_0017b99f;\n      }\n      if (*pcVar5 != '\\0') {\n        if (pcVar5[1] != '\\0') {\n          sVar7 = mbstrlen(pcVar5);\n          goto LAB_0017b99f;\n        }\n        goto LAB_0017bbb1;\n      }\n    }\n    else {\nLAB_0017bb68:\n      if (((uVar9 & 0x1044) != 0) || (*(long *)(lVar4 + 0x18) != 0)) goto LAB_0017bbd0;\n      if (*(long *)(lVar4 + 8) != 0) {\n        sVar7 = __ctype_get_mb_cur_max();\n        pcVar5 = *(char **)(lVar4 + 8);\n        if (sVar7 < 2) {\n          if ((pcVar5 != (char *)0x0) && (*pcVar5 != '\\0')) {\n            if (pcVar5[1] != '\\0') {\n              if (pcVar5[2] != '\\0') {\n                sVar7 = strlen(pcVar5);\n                goto LAB_0017b99f;\n              }\n              goto LAB_0017bf8b;\n            }\n            goto LAB_0017bbb1;\n          }\n        }\n        else if ((pcVar5 != (char *)0x0) && (*pcVar5 != '\\0')) {\n          if (pcVar5[1] != '\\0') {\n            sVar7 = mbstrlen();\n            goto LAB_0017b99f;\n          }\nLAB_0017bbb1:\n          sVar7 = 1;\n          goto LAB_0017b99f;\n        }\n      }\n    }\n  }\nLAB_0017bad6:\n  sVar7 = 0;\nLAB_0017b99f:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return sVar7;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "zreadcintr": "\nssize_t zreadcintr(int param_1,undefined *param_2)\n\n{\n  undefined *puVar1;\n  ssize_t sVar2;\n  \n  if ((DAT_00248ec8 == DAT_00248ec0) || (DAT_00248ec0 == 0)) {\n    check_signals();\n    sVar2 = read(param_1,&DAT_00248ee0,0x1000);\n    DAT_00248ec8 = 0;\n    DAT_00248ec0 = sVar2;\n    if (sVar2 < 1) {\n      DAT_00248ec0 = 0;\n      return sVar2;\n    }\n  }\n  if (param_2 != (undefined *)0x0) {\n    puVar1 = &DAT_00248ee0 + DAT_00248ec8;\n    DAT_00248ec8 = DAT_00248ec8 + 1;\n    *param_2 = *puVar1;\n  }\n  return 1;\n}\n\n",
  "FUN_001df030": "\nvoid FUN_001df030(char *param_1,uint param_2)\n\n{\n  undefined *puVar1;\n  size_t sVar2;\n  undefined8 *puVar3;\n  int iVar4;\n  long lVar5;\n  int iVar6;\n  \n  if ((param_1 == (char *)0x0) || (*param_1 == '\\0')) {\n    lVar5 = 0x40;\n    iVar6 = 0;\n  }\n  else {\n    sVar2 = strlen(param_1);\n    iVar6 = (int)sVar2;\n    lVar5 = (long)(iVar6 + 0x40);\n  }\n  puVar1 = (undefined *)xmalloc(lVar5);\n  lVar5 = 1;\n  *puVar1 = 0x28;\n  iVar4 = 1;\n  if ((param_2 & 4) != 0) {\n    lVar5 = 8;\n    *(undefined8 *)(puVar1 + 1) = 0x2064656c696166;\n    iVar4 = 8;\n  }\n  if ((param_2 & 1) != 0) {\n    iVar4 = iVar4 + 8;\n    *(undefined8 *)(puVar1 + lVar5) = 0x2d65737265766572;\n    *(undefined *)((long)(puVar1 + lVar5) + 8) = 0;\n    lVar5 = (long)iVar4;\n  }\n  puVar3 = (undefined8 *)(puVar1 + lVar5);\n  iVar4 = iVar4 + 10;\n  *puVar3 = 0x6863726165732d69;\n  *(undefined2 *)(puVar3 + 1) = 0x6029;\n  *(undefined *)((long)puVar3 + 10) = 0;\n  if ((param_1 == (char *)0x0) || (*param_1 == '\\0')) {\n    _rl_optimize_redisplay();\n  }\n  else {\n    lVar5 = (long)iVar4;\n    iVar4 = iVar4 + iVar6;\n    strcpy(puVar1 + lVar5,param_1);\n  }\n  *(undefined4 *)(puVar1 + iVar4) = 0x203a27;\n  rl_message(&DAT_002102da,puVar1);\n  xfree(puVar1);\n  return;\n}\n\n",
  "_rl_current_display_line": "\nundefined  [16] _rl_current_display_line(undefined8 param_1,undefined8 param_2,ulong param_3)\n\n{\n  int iVar1;\n  ulong uVar2;\n  undefined auVar3 [16];\n  \n  iVar1 = _rl_last_c_pos - _rl_screenwidth;\n  if (rl_display_prompt == rl_prompt) {\n    iVar1 = iVar1 - rl_visible_prompt_length;\n  }\n  uVar2 = 0;\n  if (0 < iVar1) {\n    param_3 = (ulong)(uint)(iVar1 % _rl_screenwidth);\n    uVar2 = (ulong)(iVar1 / _rl_screenwidth + 1);\n  }\n  auVar3._8_8_ = param_3;\n  auVar3._0_8_ = uVar2;\n  return auVar3;\n}\n\n",
  "hash_size": "\nundefined4 hash_size(long param_1)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = 0;\n  if (param_1 != 0) {\n    uVar1 = *(undefined4 *)(param_1 + 0xc);\n  }\n  return uVar1;\n}\n\n",
  "FUN_00147c90": "\nvoid FUN_00147c90(sigset_t *param_1)\n\n{\n  sigprocmask(2,param_1,(sigset_t *)0x0);\n  return;\n}\n\n",
  "__ctype_get_mb_cur_max": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR___ctype_get_mb_cur_max_002379b0)();\n  return sVar1;\n}\n\n",
  "mk_msgstr": "\nvoid mk_msgstr(char *param_1,undefined4 *param_2)\n\n{\n  char cVar1;\n  undefined *puVar2;\n  int iVar3;\n  undefined4 *puVar4;\n  undefined4 *puVar5;\n  char *pcVar6;\n  int iVar7;\n  \n  iVar7 = 0;\n  pcVar6 = param_1;\n  if (param_1 == (char *)0x0) {\n    puVar2 = (undefined *)sh_xmalloc(3,\"locale.c\",0x1e3);\n    *puVar2 = 0x22;\n    puVar4 = (undefined4 *)(puVar2 + 1);\n  }\n  else {\n    for (; cVar1 = *pcVar6, cVar1 != '\\0'; pcVar6 = pcVar6 + 1) {\n      if ((cVar1 == '\\\"') || (cVar1 == '\\\\')) {\n        iVar7 = iVar7 + 2;\n      }\n      else {\n        iVar3 = iVar7 + 1;\n        iVar7 = iVar7 + 6;\n        if (cVar1 != '\\n') {\n          iVar7 = iVar3;\n        }\n      }\n    }\n    puVar2 = (undefined *)sh_xmalloc((long)(iVar7 + 3),\"locale.c\",0x1e3);\n    *puVar2 = 0x22;\n    puVar4 = (undefined4 *)(puVar2 + 1);\n    for (; cVar1 = *param_1, cVar1 != '\\0'; param_1 = param_1 + 1) {\n      if (cVar1 == '\\n') {\n        *puVar4 = 0xa226e5c;\n        puVar5 = (undefined4 *)((long)puVar4 + 5);\n        *(undefined *)(puVar4 + 1) = 0x22;\n        if (param_2 != (undefined4 *)0x0) {\n          *param_2 = 1;\n        }\n      }\n      else {\n        if ((cVar1 == '\\\"') || (cVar1 == '\\\\')) {\n          *(undefined *)puVar4 = 0x5c;\n          puVar4 = (undefined4 *)((long)puVar4 + 1);\n        }\n        *(char *)puVar4 = cVar1;\n        puVar5 = (undefined4 *)((long)puVar4 + 1);\n      }\n      puVar4 = puVar5;\n    }\n  }\n  *(undefined2 *)puVar4 = 0x22;\n  return;\n}\n\n",
  "strcasestr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strcasestr(char *__haystack,char *__needle)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strcasestr_00237d78)();\n  return pcVar1;\n}\n\n",
  "setpgid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint setpgid(__pid_t __pid,__pid_t __pgid)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_setpgid_00237dc8)();\n  return iVar1;\n}\n\n",
  "skip_to_histexp": "\nulong skip_to_histexp(long param_1,uint param_2,byte *param_3,uint param_4)\n\n{\n  char cVar1;\n  bool bVar2;\n  bool bVar3;\n  undefined4 uVar4;\n  mbstate_t mVar5;\n  uint uVar6;\n  size_t sVar7;\n  long lVar8;\n  byte bVar9;\n  ulong uVar10;\n  int iVar11;\n  int iVar12;\n  byte *pbVar13;\n  int iVar14;\n  int iVar15;\n  ulong uVar16;\n  int iVar17;\n  long in_FS_OFFSET;\n  mbstate_t local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  uVar10 = (ulong)(int)param_2;\n  uVar16 = (ulong)param_2;\n  pbVar13 = (byte *)(param_1 + uVar10);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50.__count = 0;\n  local_50.__value = (_union_27)0x0;\n  sVar7 = strlen((char *)pbVar13);\n  uVar4 = no_longjmp_on_fatal_error;\n  lVar8 = sVar7 + uVar10;\n  if ((param_4 & 1) != 0) {\n    no_longjmp_on_fatal_error = 1;\n  }\n  bVar9 = *pbVar13;\n  if (bVar9 == 0) {\nLAB_0016cd40:\n    no_longjmp_on_fatal_error = uVar4;\n    if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    return uVar16 & 0xffffffff;\n  }\n  iVar14 = 0;\n  iVar11 = 0;\n  iVar17 = 0;\n  bVar3 = false;\n  bVar2 = false;\nLAB_0016cce5:\n  mVar5 = local_50;\n  uVar6 = (uint)(char)bVar9;\n  iVar15 = (int)uVar16;\n  if (bVar2) {\n    if (locale_mb_cur_max < 2) {\nLAB_0016cda1:\n      uVar16 = (ulong)(iVar15 + 1);\n    }\n    else {\nLAB_0016ccf7:\n      if ((*(uint *)(is_basic_table + (ulong)(uVar6 >> 5 & 7) * 4) >> (bVar9 & 0x1f) & 1) == 0) {\n        if ((locale_utf8locale == 0) || (sVar7 = 1, (char)bVar9 < '\\0')) {\n          sVar7 = mbrtowc((wchar_t *)0x0,(char *)pbVar13,lVar8 - uVar10,&local_50);\n          if (0xfffffffffffffffd < sVar7) {\n            uVar16 = (ulong)(iVar15 + 1);\n            local_50 = mVar5;\n            goto LAB_0016cd2b;\n          }\n          if (sVar7 == 0) goto LAB_0016cda1;\n        }\n      }\n      else {\n        sVar7 = 1;\n      }\n      uVar16 = (ulong)(uint)(iVar15 + (int)sVar7);\n    }\nLAB_0016cd2b:\n    uVar10 = (ulong)(int)uVar16;\n    bVar2 = false;\n    pbVar13 = (byte *)(param_1 + uVar10);\n    bVar9 = *pbVar13;\n    goto joined_r0x0016cce3;\n  }\n  iVar12 = iVar11;\n  if (uVar6 == 0x5c) {\n    uVar16 = (ulong)(iVar15 + 1U);\n    bVar2 = true;\n    uVar10 = (ulong)(int)(iVar15 + 1U);\n  }\n  else if (uVar6 == 0x60) {\n    if (bVar3) {\n      bVar3 = false;\n      uVar10 = (ulong)(int)(iVar15 + 1U);\n      uVar16 = (ulong)(iVar15 + 1U);\n      iVar12 = iVar17;\n    }\n    else {\n      bVar3 = true;\n      uVar10 = (ulong)(int)(iVar15 + 1U);\n      uVar16 = (ulong)(iVar15 + 1U);\n      iVar12 = 0;\n      iVar17 = iVar11;\n    }\n  }\n  else if (iVar11 == 0) {\n    if (bVar9 == *param_3) goto LAB_0016cd40;\n    if (uVar6 == 0x27) {\n      uVar16 = (ulong)(iVar15 + 1U);\n      local_48.__count = 0;\n      local_48.__value = (_union_27)0x0;\n      uVar10 = (ulong)(int)(iVar15 + 1U);\n      pbVar13 = (byte *)(param_1 + uVar10);\n      bVar9 = *pbVar13;\n      if (bVar9 != 0) {\n        if (bVar9 != 0x27) {\n          do {\n            mVar5 = local_48;\n            iVar11 = (int)uVar16;\n            if (locale_mb_cur_max < 2) {\nLAB_0016cfc7:\n              uVar6 = iVar11 + 1;\n              uVar10 = (ulong)(int)uVar6;\n              pbVar13 = (byte *)(param_1 + uVar10);\n              bVar9 = *pbVar13;\n            }\n            else {\n              if ((*(uint *)(is_basic_table + (ulong)(bVar9 >> 5) * 4) >> (bVar9 & 0x1f) & 1) == 0)\n              {\n                if ((locale_utf8locale != 0) && (sVar7 = 1, -1 < (char)bVar9)) goto LAB_0016cf9f;\n                sVar7 = mbrtowc((wchar_t *)0x0,(char *)pbVar13,lVar8 - uVar10,&local_48);\n                if (sVar7 < 0xfffffffffffffffe) {\n                  if (sVar7 == 0) goto LAB_0016cfc7;\n                  goto LAB_0016cf9f;\n                }\n                uVar6 = iVar11 + 1;\n                local_48 = mVar5;\n              }\n              else {\n                sVar7 = 1;\nLAB_0016cf9f:\n                uVar6 = iVar11 + (int)sVar7;\n              }\n              uVar10 = (ulong)(int)uVar6;\n              pbVar13 = (byte *)(param_1 + uVar10);\n              bVar9 = *pbVar13;\n            }\n            uVar16 = (ulong)uVar6;\n            if (bVar9 == 0) goto LAB_0016cfe5;\n          } while (bVar9 != 0x27);\n          bVar9 = 0x27;\n        }\n        if (bVar9 != 0) {\n          uVar6 = (int)uVar16 + 1;\n          uVar16 = (ulong)uVar6;\n          bVar2 = false;\n          uVar10 = (ulong)(int)uVar6;\n          goto LAB_0016ccd8;\n        }\n      }\nLAB_0016cfe5:\n      bVar2 = false;\n    }\n    else {\nLAB_0016cde2:\n      if (posixly_correct == 0) {\n        if (uVar6 == 0x22) {\n          uVar10 = (ulong)(int)(iVar15 + 1U);\n          uVar16 = (ulong)(iVar15 + 1U);\n          iVar12 = 1 - iVar11;\n        }\n        else {\nLAB_0016cdfb:\n          if (((((uVar6 & 0xfffffffd) == 0x3c) || (uVar6 == 0x24)) &&\n              (*(char *)(param_1 + 1 + uVar10) == '(')) &&\n             (cVar1 = *(char *)(param_1 + 2 + uVar10), cVar1 != '(')) {\n            uVar16 = (ulong)(iVar15 + 2U);\n            if (cVar1 == '\\0') goto LAB_0016cd40;\n            iVar14 = iVar14 + 1;\n            uVar10 = (ulong)(int)(iVar15 + 2U);\n            iVar12 = 0;\n            iVar17 = iVar11;\n          }\n          else if ((iVar14 == 0) || (uVar6 != 0x29)) {\n            if (!bVar3) {\n              if (1 < locale_mb_cur_max) goto LAB_0016ccf7;\n              uVar16 = (ulong)(iVar15 + 1);\n              local_50 = mVar5;\n              goto LAB_0016cd2b;\n            }\n            if (locale_mb_cur_max < 2) goto LAB_0016cd86;\n            if ((*(uint *)(is_basic_table + (ulong)(uVar6 >> 5 & 7) * 4) >> (bVar9 & 0x1f) & 1) == 0\n               ) {\n              if (((locale_utf8locale == 0) || (sVar7 = 1, (char)bVar9 < '\\0')) &&\n                 ((sVar7 = mbrtowc((wchar_t *)0x0,(char *)pbVar13,lVar8 - uVar10,&local_50),\n                  0xfffffffffffffffd < sVar7 || (mVar5 = local_50, sVar7 == 0)))) goto LAB_0016cd86;\n            }\n            else {\n              sVar7 = 1;\n            }\n            uVar6 = iVar15 + (int)sVar7;\n            uVar10 = (ulong)(int)uVar6;\n            uVar16 = (ulong)uVar6;\n          }\n          else {\n            iVar14 = iVar14 + -1;\n            uVar10 = (ulong)(int)(iVar15 + 1U);\n            uVar16 = (ulong)(iVar15 + 1U);\n            iVar12 = iVar17;\n          }\n        }\n      }\n      else {\n        if (uVar6 != 0x22) goto LAB_0016cdfb;\n        iVar11 = FUN_0016a7c0(param_1,lVar8,iVar15 + 1,0);\n        uVar10 = (ulong)iVar11;\n        uVar16 = uVar10;\n      }\n    }\n  }\n  else {\n    if (bVar9 == *param_3) {\n      if (*(char *)(param_1 + 1 + uVar10) == '\\\"') goto LAB_0016cd86;\n      goto LAB_0016cd40;\n    }\n    if (uVar6 != 0x27) goto LAB_0016cde2;\nLAB_0016cd86:\n    local_50 = mVar5;\n    uVar10 = (ulong)(int)(iVar15 + 1U);\n    uVar16 = (ulong)(iVar15 + 1U);\n  }\nLAB_0016ccd8:\n  pbVar13 = (byte *)(param_1 + uVar10);\n  bVar9 = *pbVar13;\n  iVar11 = iVar12;\njoined_r0x0016cce3:\n  if (bVar9 == 0) goto LAB_0016cd40;\n  goto LAB_0016cce5;\n}\n\n",
  "base_pathname": "\nchar * base_pathname(char *param_1)\n\n{\n  char *pcVar1;\n  \n  if ((*param_1 == '/') && (param_1[1] == '\\0')) {\n    return param_1;\n  }\n  pcVar1 = strrchr(param_1,0x2f);\n  if (pcVar1 != (char *)0x0) {\n    param_1 = pcVar1 + 1;\n  }\n  return param_1;\n}\n\n",
  "sv_opterr": "\nvoid sv_opterr(void)\n\n{\n  long lVar1;\n  char *__nptr;\n  \n  lVar1 = find_variable(\"OPTERR\");\n  if (lVar1 != 0) {\n    __nptr = (char *)get_variable_value(lVar1);\n    if ((__nptr != (char *)0x0) && (*__nptr != '\\0')) {\n      lVar1 = strtol(__nptr,(char **)0x0,10);\n      sh_opterr = (int)lVar1;\n      return;\n    }\n  }\n  sh_opterr = 1;\n  return;\n}\n\n",
  "all_aliases": "\nlong ** all_aliases(void)\n\n{\n  long **pplVar1;\n  long *plVar2;\n  int iVar3;\n  int iVar4;\n  long **__base;\n  long **pplVar5;\n  long lVar6;\n  long *plVar7;\n  long **pplVar8;\n  \n  __base = aliases;\n  if (aliases != (long **)0x0) {\n    __base = (long **)0x0;\n    if (*(int *)((long)aliases + 0xc) != 0) {\n      __base = (long **)sh_xmalloc((long)(*(int *)((long)aliases + 0xc) + 1) << 3,\"alias.c\",0xe8);\n      iVar4 = *(int *)(aliases + 1);\n      if (0 < iVar4) {\n        iVar3 = 0;\n        pplVar1 = (long **)(*aliases + 1);\n        pplVar5 = (long **)*aliases;\n        pplVar8 = pplVar1;\n        while( true ) {\n          plVar7 = *pplVar5;\n          if (plVar7 != (long *)0x0) {\n            lVar6 = (long)(iVar3 + 1);\n            do {\n              plVar2 = (long *)plVar7[2];\n              plVar7 = (long *)*plVar7;\n              iVar3 = (int)lVar6;\n              __base[lVar6] = (long *)0x0;\n              __base[lVar6 + -1] = plVar2;\n              lVar6 = lVar6 + 1;\n            } while (plVar7 != (long *)0x0);\n          }\n          if (pplVar8 == pplVar1 + (iVar4 - 1)) break;\n          pplVar5 = pplVar8;\n          pplVar8 = pplVar8 + 1;\n        }\n      }\n      if (__base != (long **)0x0) {\n        iVar4 = strvec_len(__base);\n        qsort(__base,(long)iVar4,8,FUN_00187990);\n      }\n    }\n  }\n  return __base;\n}\n\n",
  "rl_vi_column": "\nundefined8 rl_vi_column(int param_1)\n\n{\n  if (rl_end < param_1) {\n    rl_end_of_line(1);\n    return 0;\n  }\n  rl_point = 0;\n  rl_point = _rl_forward_char_internal(param_1 + -1);\n  return 0;\n}\n\n",
  "alias_expand": "\nchar * alias_expand(char *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint uVar3;\n  char cVar4;\n  char cVar5;\n  int iVar6;\n  size_t sVar7;\n  char *__dest;\n  size_t sVar8;\n  ushort **ppuVar9;\n  int iVar10;\n  int iVar11;\n  char *__src;\n  long lVar12;\n  int iVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  bool bVar17;\n  char *local_60;\n  \n  sVar7 = strlen(param_1);\n  iVar11 = (int)sVar7 + 1;\n  local_60 = (char *)sh_xmalloc((long)iVar11,\"alias.c\",0x1e8);\n  __dest = (char *)sh_xmalloc((long)iVar11,\"alias.c\",0x1e9);\n  bVar17 = false;\n  DAT_0024868c = 1;\n  *local_60 = '\\0';\n  iVar13 = 0;\n  while( true ) {\n    lVar12 = (long)iVar13;\n    pcVar16 = param_1 + lVar12;\n    *__dest = '\\0';\n    cVar4 = *pcVar16;\n    if (cVar4 == '\\0') break;\n    bVar2 = false;\n    iVar10 = 0;\n    iVar14 = iVar13;\n    do {\n      if (bVar2) {\n        bVar2 = false;\n      }\n      else if ((cVar4 == ' ') || (cVar4 == '\\t')) {\n        iVar10 = 0;\n      }\n      else if (cVar4 == '\\\\') {\n        bVar1 = param_1[lVar12 + 1];\n        if (bVar1 == 0) {\nLAB_00188326:\n          __src = param_1 + iVar14;\n          if ((iVar13 != iVar14) || (*__src != '\\0')) goto LAB_00187fcb;\n          goto LAB_00188345;\n        }\n        ppuVar9 = __ctype_b_loc();\n        if ((*(byte *)((long)*ppuVar9 + (ulong)bVar1 * 2 + 1) & 4) == 0) {\n          bVar2 = true;\n        }\n        else {\n          iVar10 = iVar10 + 1;\n        }\n      }\n      else {\n        iVar6 = iVar14;\n        if ((cVar4 == '\\'') || (cVar4 == '\\\"')) {\n          do {\n            while( true ) {\n              iVar14 = iVar6 + 1;\n              lVar12 = (long)iVar14;\n              cVar5 = param_1[lVar12];\n              if (cVar5 == '\\0') goto LAB_00187fb8;\n              if (cVar5 != '\\\\') break;\n              iVar6 = iVar6 + 2;\n              lVar12 = (long)iVar6;\n              iVar14 = iVar6;\n              if (param_1[lVar12] == '\\0') goto LAB_00187fb8;\n            }\n            iVar6 = iVar14;\n          } while (cVar5 != cVar4);\n          if (param_1[lVar12] == '\\0') break;\n          ppuVar9 = __ctype_b_loc();\n          iVar10 = (iVar10 + 1) - (uint)(((*ppuVar9)[(byte)param_1[lVar12 + 1]] & 0x400) == 0);\n        }\n        else if (iVar10 == 0) {\n          lVar12 = mbschr(\"\\r\\n;|&(\",(int)cVar4);\n          if (lVar12 == 0) goto LAB_00188326;\n          DAT_0024868c = DAT_0024868c + 1;\n        }\n      }\n      iVar14 = iVar14 + 1;\n      lVar12 = (long)iVar14;\n      cVar4 = param_1[lVar12];\n    } while (cVar4 != '\\0');\nLAB_00187fb8:\n    if (iVar13 == iVar14) break;\n    __src = param_1 + lVar12;\nLAB_00187fcb:\n    sVar7 = strlen(local_60);\n    iVar13 = iVar14 - iVar13;\n    iVar10 = (int)sVar7;\n    iVar6 = iVar13 + 1 + iVar10;\n    if (iVar11 <= iVar6) {\n      do {\n        iVar11 = iVar11 + iVar13 + 0x32;\n      } while (iVar11 <= iVar6);\n      local_60 = (char *)sh_xrealloc(local_60,(long)iVar11,\"alias.c\",0x207);\n    }\n    strncpy(local_60 + iVar10,pcVar16,(long)iVar13);\n    uVar3 = DAT_0024868c;\n    local_60[iVar13 + iVar10] = '\\0';\n    pcVar16 = __dest;\n    iVar13 = iVar14;\n    if (uVar3 == 0) {\n      if (*__src != '\\0') {\n        lVar12 = mbschr(\"\\r\\n;|&(\");\n        cVar4 = *__src;\n        DAT_0024868c = (uint)(lVar12 != 0);\n        bVar17 = (bool)(bVar17 | lVar12 != 0);\n        goto LAB_0018803f;\n      }\nLAB_0018837d:\n      sVar7 = 0;\n    }\n    else {\n      bVar17 = true;\n      cVar4 = *__src;\n      DAT_0024868c = 1;\nLAB_0018803f:\n      pcVar15 = __src;\n      if (cVar4 == '\\0') goto LAB_0018837d;\n      do {\n        if (((cVar4 == ' ') || (cVar4 == '\\t')) ||\n           (lVar12 = mbschr(&DAT_001ff13f,(int)cVar4), lVar12 != 0)) {\n          pcVar15 = param_1 + iVar13;\n          break;\n        }\n        iVar10 = iVar13 + 1;\n        cVar4 = *pcVar15;\n        lVar12 = (long)iVar10;\n        pcVar15 = param_1 + lVar12;\n        cVar5 = *pcVar15;\n        if (cVar4 == '\\\\') {\n          if (cVar5 == '\\0') goto LAB_001882e0;\n          iVar13 = iVar13 + 2;\n        }\n        else if ((cVar4 == '\\'') || (iVar13 = iVar10, cVar4 == '\\\"')) {\n          if (cVar5 != '\\0') {\n            if (cVar5 == '\\\\') goto LAB_001883c0;\n            while (cVar4 != cVar5) {\n              while( true ) {\n                iVar10 = iVar10 + 1;\n                lVar12 = (long)iVar10;\n                pcVar15 = param_1 + lVar12;\n                cVar5 = *pcVar15;\n                if (cVar5 == '\\0') goto LAB_001882e0;\n                if (cVar5 != '\\\\') break;\nLAB_001883c0:\n                iVar10 = iVar10 + 1;\n                pcVar15 = param_1 + iVar10;\n                if (*pcVar15 == '\\0') goto LAB_001882e0;\n              }\n            }\n            pcVar15 = param_1 + lVar12;\n            if (*pcVar15 != '\\0') {\n              iVar13 = iVar10 + 1;\n              goto LAB_001880b2;\n            }\n          }\nLAB_001882e0:\n          iVar6 = iVar10 - iVar14;\n          iVar13 = iVar10;\n          goto joined_r0x001882ea;\n        }\nLAB_001880b2:\n        pcVar15 = param_1 + iVar13;\n        cVar4 = *pcVar15;\n      } while (cVar4 != '\\0');\n      iVar6 = iVar13 - iVar14;\njoined_r0x001882ea:\n      if (iVar6 == 0) {\n        if (*pcVar15 == '\\0') {\n          sVar7 = 0;\n        }\n        else {\n          sVar7 = 1;\n          pcVar16 = __dest + 1;\n          iVar13 = iVar13 + 1;\n        }\n      }\n      else {\n        sVar7 = (size_t)iVar6;\n        pcVar16 = __dest + sVar7;\n      }\n    }\n    strncpy(__dest,__src,sVar7);\n    *pcVar16 = '\\0';\n    lVar12 = mbschr(__dest,0x5c);\n    if (lVar12 == 0) {\n      if (*__dest == '\\0') goto LAB_00188280;\n      if (!bVar17) goto LAB_0018811a;\nLAB_00188130:\n      if ((aliases == 0) || (lVar12 = hash_search(__dest,aliases,0), lVar12 == 0))\n      goto LAB_00188280;\n      lVar12 = *(long *)(lVar12 + 0x10);\n      sVar7 = strlen(local_60);\n      if (lVar12 == 0) goto LAB_00188280;\n      pcVar16 = *(char **)(lVar12 + 8);\n      sVar8 = strlen(pcVar16);\n      iVar14 = (int)sVar8;\n      iVar10 = iVar14 + 3 + (int)sVar7;\n      if (iVar11 <= iVar10) {\n        do {\n          iVar11 = iVar11 + iVar14 + 0x32;\n        } while (iVar11 <= iVar10);\n        local_60 = (char *)sh_xrealloc(local_60,(long)iVar11,\"alias.c\",0x23a);\n      }\n      strcpy(local_60 + (int)sVar7,pcVar16);\n      if (((iVar14 == 0) || (!bVar17)) ||\n         ((pcVar16[(long)iVar14 + -1] != ' ' && (pcVar16[(long)iVar14 + -1] != '\\t')))) {\n        bVar17 = alias_expand_all != 0;\n        DAT_0024868c = 0;\n      }\n      else {\n        bVar17 = true;\n        DAT_0024868c = 0;\n      }\n    }\n    else {\n      if (*__dest != '\\0') {\nLAB_0018811a:\n        if (alias_expand_all != 0) {\n          bVar17 = false;\n          goto LAB_00188130;\n        }\n      }\nLAB_00188280:\n      sVar7 = strlen(local_60);\n      iVar14 = iVar13 - iVar14;\n      iVar10 = (int)sVar7;\n      iVar6 = iVar14 + 1 + iVar10;\n      if (iVar11 <= iVar6) {\n        do {\n          iVar11 = iVar11 + iVar14 + iVar10 + 0x32;\n        } while (iVar11 <= iVar6);\n        local_60 = (char *)sh_xrealloc(local_60,(long)iVar11,\"alias.c\",0x249);\n      }\n      strncpy(local_60 + iVar10,__src,(long)iVar14);\n      local_60[iVar14 + iVar10] = '\\0';\n      DAT_0024868c = 0;\n      bVar17 = false;\n    }\n  }\nLAB_00188345:\n  sh_xfree(__dest,\"alias.c\",0x1ff);\n  return local_60;\n}\n\n",
  "_rl_vi_initialize_line": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid _rl_vi_initialize_line(void)\n\n{\n  rl_readline_state = rl_readline_state & 0xffffffffffbfffff;\n  _DAT_0024a3c0 = 0xffffffffffffffff;\n  _DAT_0024a360 = 0xffffffff;\n  uRam000000000024a364 = 0xffffffff;\n  uRam000000000024a368 = 0xffffffff;\n  uRam000000000024a36c = 0xffffffff;\n  _DAT_0024a370 = 0xffffffff;\n  uRam000000000024a374 = 0xffffffff;\n  uRam000000000024a378 = 0xffffffff;\n  uRam000000000024a37c = 0xffffffff;\n  _DAT_0024a380 = 0xffffffff;\n  uRam000000000024a384 = 0xffffffff;\n  uRam000000000024a388 = 0xffffffff;\n  uRam000000000024a38c = 0xffffffff;\n  _DAT_0024a390 = 0xffffffff;\n  uRam000000000024a394 = 0xffffffff;\n  uRam000000000024a398 = 0xffffffff;\n  uRam000000000024a39c = 0xffffffff;\n  _DAT_0024a3a0 = 0xffffffff;\n  uRam000000000024a3a4 = 0xffffffff;\n  uRam000000000024a3a8 = 0xffffffff;\n  uRam000000000024a3ac = 0xffffffff;\n  _DAT_0024a3b0 = 0xffffffff;\n  uRam000000000024a3b4 = 0xffffffff;\n  uRam000000000024a3b8 = 0xffffffff;\n  uRam000000000024a3bc = 0xffffffff;\n  return;\n}\n\n",
  "close_new_fifos": "\nvoid close_new_fifos(long param_1,int param_2)\n\n{\n  long lVar1;\n  long lVar2;\n  int iVar3;\n  \n  if (param_1 == 0) {\n    if (DAT_00247834 == 0) {\n      return;\n    }\n    FUN_00168fd0();\n    return;\n  }\n  lVar1 = 0;\n  iVar3 = DAT_00247830;\n  if (0 < param_2) {\n    do {\n      if (((*(int *)(param_1 + lVar1 * 4) == 0) && ((int)lVar1 < iVar3)) &&\n         (*(int *)(DAT_00247838 + lVar1 * 4) != 0)) {\n        close((int)lVar1);\n        iVar3 = DAT_00247830;\n        DAT_00247834 = DAT_00247834 + -1;\n        *(undefined4 *)(DAT_00247838 + lVar1 * 4) = 0;\n      }\n      lVar1 = lVar1 + 1;\n    } while (param_2 != lVar1);\n  }\n  if (param_2 < iVar3) {\n    lVar2 = (long)param_2 << 2;\n    lVar1 = DAT_00247838;\n    do {\n      while (*(int *)(lVar1 + lVar2) != 0) {\n        iVar3 = param_2 + 1;\n        close(param_2);\n        lVar1 = DAT_00247838;\n        DAT_00247834 = DAT_00247834 + -1;\n        *(undefined4 *)(DAT_00247838 + lVar2) = 0;\n        lVar2 = lVar2 + 4;\n        param_2 = iVar3;\n        if (DAT_00247830 <= iVar3) {\n          return;\n        }\n      }\n      param_2 = param_2 + 1;\n      lVar2 = lVar2 + 4;\n    } while (param_2 < DAT_00247830);\n  }\n  return;\n}\n\n",
  "rl_beginning_of_history": "\nvoid rl_beginning_of_history(undefined8 param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = where_history();\n  rl_get_previous_history(iVar1 + 1,param_2);\n  return;\n}\n\n",
  "_rl_free_undo_list": "\nvoid _rl_free_undo_list(long *param_1)\n\n{\n  long *plVar1;\n  \n  if (param_1 == (long *)0x0) {\n    return;\n  }\n  do {\n    while (plVar1 = (long *)*param_1, *(int *)(param_1 + 3) != 0) {\n      xfree(param_1);\n      param_1 = plVar1;\n      if (plVar1 == (long *)0x0) {\n        return;\n      }\n    }\n    xfree(param_1[2]);\n    xfree(param_1);\n    param_1 = plVar1;\n  } while (plVar1 != (long *)0x0);\n  return;\n}\n\n",
  "FUN_0019e3e0": "\nundefined8 FUN_0019e3e0(uint *param_1)\n\n{\n  undefined *puVar1;\n  long *plVar2;\n  undefined8 *puVar3;\n  undefined **ppuVar4;\n  undefined8 *puVar5;\n  int iVar6;\n  long lVar7;\n  \n  if (word_token_alist == (undefined *)0x0) {\n    iVar6 = 0;\n    plVar2 = (long *)strlist_create(0);\n    puVar5 = (undefined8 *)*plVar2;\n  }\n  else {\n    iVar6 = 0;\n    ppuVar4 = &PTR_DAT_00238290;\n    do {\n      lVar7 = (long)iVar6;\n      iVar6 = iVar6 + 1;\n      puVar1 = *ppuVar4;\n      ppuVar4 = ppuVar4 + 2;\n    } while (puVar1 != (undefined *)0x0);\n    plVar2 = (long *)strlist_create(iVar6);\n    ppuVar4 = &word_token_alist;\n    puVar5 = (undefined8 *)*plVar2;\n    puVar3 = puVar5;\n    do {\n      puVar1 = *ppuVar4;\n      ppuVar4 = ppuVar4 + 2;\n      *puVar3 = puVar1;\n      puVar3 = puVar3 + 1;\n    } while (ppuVar4 != &PTR_DAT_00238290 + lVar7 * 2);\n    puVar5 = puVar5 + iVar6;\n  }\n  *(int *)((long)plVar2 + 0xc) = iVar6;\n  *puVar5 = 0;\n  *(long **)(param_1 + 4) = plVar2;\n  *param_1 = *param_1 | 0x20;\n  return 0;\n}\n\n",
  "time": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntime_t time(time_t *__timer)\n\n{\n  time_t tVar1;\n  \n  tVar1 = (*(code *)PTR_time_00237b98)();\n  return tVar1;\n}\n\n",
  "ungetc_with_restart": "\nint ungetc_with_restart(int param_1)\n\n{\n  if ((param_1 != -1) && (DAT_00247f74 != 0)) {\n    DAT_00247f74 = DAT_00247f74 + -1;\n    (&DAT_00247f80)[DAT_00247f74] = (char)param_1;\n    return param_1;\n  }\n  return -1;\n}\n\n",
  "locale_expand": "\nchar * locale_expand(long param_1,int param_2,int param_3,undefined4 param_4,int *param_5)\n\n{\n  char *pcVar1;\n  long lVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  int iVar7;\n  long in_FS_OFFSET;\n  int local_48;\n  int local_44;\n  long local_40;\n  \n  iVar7 = param_3 - param_2;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar1 = (char *)sh_xmalloc((long)(iVar7 + 1),\"locale.c\",0x20d);\n  if (param_2 < param_3) {\n    lVar2 = (long)param_2;\n    do {\n      pcVar1[lVar2 - param_2] = *(char *)(param_1 + lVar2);\n      lVar2 = lVar2 + 1;\n    } while ((int)lVar2 < param_3);\n    pcVar3 = pcVar1 + iVar7;\n    local_48 = param_3;\n  }\n  else {\n    iVar7 = 0;\n    pcVar3 = pcVar1;\n    local_48 = param_2;\n  }\n  *pcVar3 = '\\0';\n  if (dump_translatable_strings == 0) {\n    if (*pcVar1 == '\\0') {\n      if (param_5 != (int *)0x0) {\n        *param_5 = 0;\n      }\n    }\n    else {\n      pcVar3 = (char *)localetrans(pcVar1,iVar7,&local_48);\n      sh_xfree(pcVar1,\"locale.c\",0x22f);\n      pcVar1 = pcVar3;\n      if (param_5 != (int *)0x0) {\n        *param_5 = local_48;\n      }\n    }\n  }\n  else {\n    if (dump_po_strings == 0) {\n      __printf_chk(1,\"\\\"%s\\\"\\n\",pcVar1);\n    }\n    else {\n      local_44 = 0;\n      puVar6 = &DAT_001ff814;\n      uVar4 = mk_msgstr(pcVar1,&local_44);\n      if (local_44 == 0) {\n        puVar6 = &DAT_00213d70;\n      }\n      uVar5 = yy_input_name();\n      __printf_chk(1,\"#: %s:%d\\nmsgid %s%s\\nmsgstr \\\"\\\"\\n\",uVar5,param_4,puVar6,uVar4);\n      sh_xfree(uVar4,\"locale.c\",0x223);\n    }\n    if (param_5 != (int *)0x0) {\n      *param_5 = iVar7;\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pcVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00148b90": "\nvoid FUN_00148b90(long *param_1,int param_2,int param_3,int param_4)\n\n{\n  int iVar1;\n  int iVar2;\n  long *plVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  int local_50;\n  int local_3c;\n  \n  if (param_1 == (long *)0x0) {\n    putc(10,stderr);\n    return;\n  }\n  iVar5 = 1;\n  if (param_3 != 0) {\n    iVar5 = 1;\n    if (DAT_00242168 / param_3 != 0) {\n      iVar5 = DAT_00242168 / param_3;\n    }\n  }\n  if (param_2 == 0) {\n    local_50 = 1;\n    iVar5 = 1;\n  }\n  else {\n    iVar5 = (param_2 / iVar5 + 1) - (uint)(param_2 % iVar5 == 0);\n    if (iVar5 == 1) {\n      iVar5 = param_2;\n    }\n    if (iVar5 < 10) {\n      if (iVar5 < 1) {\n        return;\n      }\n      local_50 = 1;\n    }\n    else {\n      local_50 = 2;\n      if (((99 < iVar5) && (local_50 = 3, 999 < iVar5)) && (local_50 = 4, 9999 < iVar5)) {\n        local_50 = (99999 < iVar5) + 5;\n      }\n    }\n  }\n  local_3c = 0;\n  do {\n    iVar4 = local_3c;\n    iVar2 = local_50;\n    iVar6 = 0;\nLAB_00148c08:\n    plVar3 = param_1;\n    iVar1 = iVar4 + 1;\n    do {\n      iVar1 = iVar1 + -1;\n      if (iVar1 == 0) {\n        __fprintf_chk(stderr,1,\"%*d%s%s\",iVar2,iVar4 + 1,&DAT_001fc7cd,*(undefined8 *)plVar3[1]);\n        iVar1 = FUN_00148aa0(*(undefined8 *)plVar3[1]);\n        iVar2 = iVar2 + 2 + iVar1;\n        goto joined_r0x00148d78;\n      }\n      plVar3 = (long *)*plVar3;\n    } while (plVar3 != (long *)0x0);\n    iVar2 = iVar2 + 2;\njoined_r0x00148d78:\n    if (iVar4 + iVar5 < param_2) {\n      iVar4 = iVar4 + iVar5;\n      iVar1 = iVar6 + param_3;\n      iVar6 = iVar6 + iVar2;\n      if (iVar2 < param_3) {\n        do {\n          while (iVar6 / DAT_00242164 < iVar1 / DAT_00242164) {\n            putc(9,stderr);\n            iVar6 = iVar6 + (DAT_00242164 - iVar6 % DAT_00242164);\n            if (iVar1 <= iVar6) goto LAB_00148ca1;\n          }\n          iVar6 = iVar6 + 1;\n          putc(0x20,stderr);\n        } while (iVar6 < iVar1);\n      }\nLAB_00148ca1:\n      iVar2 = local_50;\n      iVar6 = iVar1;\n      if (iVar1 != 0) {\n        iVar2 = param_4;\n      }\n      goto LAB_00148c08;\n    }\n    putc(10,stderr);\n    local_3c = local_3c + 1;\n    if (iVar5 <= local_3c) {\n      return;\n    }\n  } while( true );\n}\n\n",
  "FUN_001daa10": "\nundefined8 FUN_001daa10(void)\n\n{\n  char *pcVar1;\n  \n  if (DAT_0024a794 == 0) {\n    FUN_001da6e0(\"$else found without matching $if\");\n    return 0;\n  }\n  if (0 < DAT_0024a794) {\n    pcVar1 = DAT_0024a798;\n    do {\n      if (*pcVar1 == '\\x01') {\n        return 0;\n      }\n      pcVar1 = pcVar1 + 1;\n    } while (pcVar1 != DAT_0024a798 + (ulong)(DAT_0024a794 - 1) + 1);\n  }\n  _rl_parsing_conditionalized_out = _rl_parsing_conditionalized_out == '\\0';\n  return 0;\n}\n\n",
  "rl_unbind_key_in_map": "\nvoid rl_unbind_key_in_map(undefined8 param_1,undefined *param_2)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = _rl_keymap;\n  _rl_keymap = param_2;\n  rl_bind_key(param_1,0);\n  _rl_keymap = puVar1;\n  return;\n}\n\n",
  "strvec_copy": "\nundefined8 * strvec_copy(char **param_1)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  undefined8 *puVar3;\n  size_t sVar4;\n  char *__dest;\n  char *pcVar5;\n  undefined8 *puVar6;\n  long lVar7;\n  \n  if (*param_1 == (char *)0x0) {\n    lVar7 = 8;\n  }\n  else {\n    lVar7 = 1;\n    do {\n      iVar2 = (int)lVar7;\n      ppcVar1 = param_1 + lVar7;\n      lVar7 = lVar7 + 1;\n    } while (*ppcVar1 != (char *)0x0);\n    lVar7 = (long)(iVar2 + 1) << 3;\n  }\n  puVar3 = (undefined8 *)sh_xmalloc(lVar7,\"stringvec.c\",0x97);\n  pcVar5 = *param_1;\n  puVar6 = puVar3;\n  if (pcVar5 != (char *)0x0) {\n    lVar7 = 0;\n    do {\n      sVar4 = strlen(pcVar5);\n      __dest = (char *)sh_xmalloc(sVar4 + 1,\"stringvec.c\",0x99);\n      pcVar5 = strcpy(__dest,pcVar5);\n      *(char **)((long)puVar3 + lVar7) = pcVar5;\n      lVar7 = lVar7 + 8;\n      pcVar5 = *(char **)((long)param_1 + lVar7);\n    } while (pcVar5 != (char *)0x0);\n    puVar6 = (undefined8 *)(lVar7 + (long)puVar3);\n  }\n  *puVar6 = 0;\n  return puVar3;\n}\n\n",
  "rl_empty_keymap": "\nundefined8 rl_empty_keymap(char *param_1)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = param_1 + 0x1000;\n  while ((*param_1 == '\\0' && (*(long *)(param_1 + 8) == 0))) {\n    param_1 = param_1 + 0x10;\n    if (param_1 == pcVar1) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
  "FUN_00162a10": "\nvoid FUN_00162a10(void)\n\n{\n  __pid_t __pid;\n  \n  initialize_job_signals();\n  set_signal_handler(0x12,DAT_00247670);\n  __pid = getpid();\n  kill(__pid,0x12);\n  return;\n}\n\n",
  "initialize_flags": "\nvoid initialize_flags(void)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  char *pcVar4;\n  char cVar5;\n  char cVar6;\n  \n  pcVar4 = shell_flags + 0x20;\n  lVar3 = 0;\n  cVar1 = 'b';\n  cVar6 = 'a';\n  while( true ) {\n    cVar5 = cVar1;\n    optflags[lVar3 + 1] = cVar6;\n    iVar2 = (int)lVar3;\n    lVar3 = lVar3 + 1;\n    if (cVar5 == '\\0') break;\n    cVar1 = *pcVar4;\n    pcVar4 = pcVar4 + 0x10;\n    cVar6 = cVar5;\n  }\n  optflags[iVar2 + 2] = 0x6f;\n  optflags[iVar2 + 3] = 0x3b;\n  optflags[iVar2 + 4] = 0;\n  return;\n}\n\n",
  "FUN_0019f840": "\n/* WARNING: Type propagation algorithm not settling */\n\nundefined8 FUN_0019f840(uint param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  \n  if (((param_1 & 1) == 0) || (lVar3 = FUN_0019f4a0(it_aliases), lVar3 == 0)) {\n    uVar5 = 0;\n  }\n  else {\n    uVar5 = strlist_append(0,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 2) != 0) && (lVar3 = FUN_0019f4a0(it_arrayvars,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 4) != 0) && (lVar3 = FUN_0019f4a0(it_bindings,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 8) != 0) && (lVar3 = FUN_0019f4a0(it_builtins,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x40) != 0) && (lVar3 = FUN_0019f4a0(it_disabled,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x80) != 0) && (lVar3 = FUN_0019f4a0(it_enabled,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x100) != 0) && (lVar3 = FUN_0019f4a0(it_exports,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x400) != 0) && (lVar3 = FUN_0019f4a0(it_functions,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x1000) != 0) && (lVar3 = FUN_0019f4a0(it_helptopics,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x2000) != 0) && (lVar3 = FUN_0019f4a0(it_hostnames,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x4000) != 0) && (lVar3 = FUN_0019f4a0(it_jobs,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x8000) != 0) && (lVar3 = FUN_0019f4a0(it_keywords,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x10000) != 0) && (lVar3 = FUN_0019f4a0(it_running,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x40000) != 0) && (lVar3 = FUN_0019f4a0(it_setopts,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x80000) != 0) && (lVar3 = FUN_0019f4a0(it_shopts,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x100000) != 0) && (lVar3 = FUN_0019f4a0(it_signals,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x200000) != 0) && (lVar3 = FUN_0019f4a0(it_stopped,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if (((param_1 & 0x800000) != 0) && (lVar3 = FUN_0019f4a0(it_variables,param_2), lVar3 != 0)) {\n    uVar5 = strlist_append(uVar5,lVar3);\n    strlist_dispose(lVar3);\n  }\n  if ((param_1 & 0x10) != 0) {\n    uVar4 = rl_completion_matches(param_2,command_word_completion_function);\n    uVar2 = completions_to_stringlist(uVar4);\n    uVar5 = strlist_append(uVar5,uVar2);\n    strvec_dispose(uVar4);\n    strlist_dispose(uVar2);\n  }\n  if ((param_1 & 0x200) != 0) {\n    uVar4 = rl_completion_matches(param_2,FUN_0019eb90);\n    uVar2 = completions_to_stringlist(uVar4);\n    uVar5 = strlist_append(uVar5,uVar2);\n    strvec_dispose(uVar4);\n    strlist_dispose(uVar2);\n  }\n  if ((param_1 & 0x400000) != 0) {\n    uVar4 = rl_completion_matches(param_2,rl_username_completion_function);\n    uVar2 = completions_to_stringlist(uVar4);\n    uVar5 = strlist_append(uVar5,uVar2);\n    strvec_dispose(uVar4);\n    strlist_dispose(uVar2);\n  }\n  if ((param_1 & 0x800) != 0) {\n    uVar4 = rl_completion_matches(param_2,bash_groupname_completion_function);\n    uVar2 = completions_to_stringlist(uVar4);\n    uVar5 = strlist_append(uVar5,uVar2);\n    strvec_dispose(uVar4);\n    strlist_dispose(uVar2);\n  }\n  iVar1 = rl_filename_completion_desired;\n  if ((param_1 & 0x20000) != 0) {\n    uVar4 = rl_completion_matches(param_2,bash_servicename_completion_function);\n    uVar2 = completions_to_stringlist(uVar4);\n    uVar5 = strlist_append(uVar5,uVar2);\n    strvec_dispose(uVar4);\n    strlist_dispose(uVar2);\n    iVar1 = rl_filename_completion_desired;\n  }\n  if ((param_1 & 0x20) != 0) {\n    rl_completion_mark_symlink_dirs = 1;\n    rl_filename_completion_desired = iVar1;\n    lVar3 = bash_directory_completion_matches(param_2);\n    if (((iVar1 == 0) && (lVar3 == 0)) && (rl_filename_completion_desired == 1)) {\n      rl_filename_completion_desired = 0;\n    }\n    uVar4 = completions_to_stringlist(lVar3);\n    uVar5 = strlist_append(uVar5,uVar4);\n    strvec_dispose(lVar3);\n    strlist_dispose(uVar4);\n    return uVar5;\n  }\n  rl_filename_completion_desired = iVar1;\n  return uVar5;\n}\n\n",
  "check_dev_tty": "\nvoid check_dev_tty(void)\n\n{\n  int iVar1;\n  char *__file;\n  \n  iVar1 = open(\"/dev/tty\",0x802);\n  if (-1 < iVar1) {\nLAB_00141c0f:\n    close(iVar1);\n    return;\n  }\n  iVar1 = fileno(stdin);\n  __file = ttyname(iVar1);\n  if (__file != (char *)0x0) {\n    iVar1 = open(__file,0x802);\n    if (-1 < iVar1) goto LAB_00141c0f;\n  }\n  return;\n}\n\n",
  "strcpy": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strcpy(char *__dest,char *__src)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strcpy_00237898)();\n  return pcVar1;\n}\n\n",
  "compopt_builtin": "\nundefined8 compopt_builtin(undefined8 param_1)\n\n{\n  char cVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  long *plVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  int iVar9;\n  long lVar10;\n  long *plVar11;\n  uint *puVar12;\n  long *plVar13;\n  char *__s2;\n  char *pcVar14;\n  undefined **ppuVar15;\n  undefined8 uVar16;\n  long in_FS_OFFSET;\n  uint local_48;\n  uint local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_44 = 0;\n  local_48 = 0;\n  reset_internal_getopt();\n  bVar4 = false;\n  bVar3 = false;\n  bVar2 = false;\n  while (iVar8 = internal_getopt(param_1,\"+o:DEI\"), pcVar14 = list_optarg, plVar5 = loptend,\n        iVar8 != -1) {\n    puVar12 = &local_44;\n    if (list_opttype == 0x2d) {\n      puVar12 = &local_48;\n    }\n    if (iVar8 == 0x45) {\n      bVar3 = true;\n    }\n    else if (iVar8 < 0x46) {\n      if (iVar8 == -99) {\n        builtin_help();\n        uVar16 = 0x102;\n        goto LAB_001bcd58;\n      }\n      if (iVar8 != 0x44) goto LAB_001bcd4d;\n      bVar2 = true;\n    }\n    else if (iVar8 == 0x49) {\n      bVar4 = true;\n    }\n    else {\n      if (iVar8 != 0x6f) {\nLAB_001bcd4d:\n        builtin_usage();\n        uVar16 = 0x102;\n        goto LAB_001bcd58;\n      }\n      iVar8 = 0;\n      ppuVar15 = &PTR_s_default_00235410;\n      __s2 = \"bashdefault\";\n      cVar1 = *list_optarg;\n      if (cVar1 == 'b') goto LAB_001bcd05;\n      do {\n        do {\n          __s2 = *ppuVar15;\n          ppuVar15 = ppuVar15 + 2;\n          iVar8 = iVar8 + 1;\n          if (__s2 == (char *)0x0) {\n            uVar16 = 0x102;\n            sh_invalidoptname(pcVar14);\n            goto LAB_001bcd58;\n          }\n        } while (*__s2 != cVar1);\nLAB_001bcd05:\n        iVar9 = strcmp(pcVar14,__s2);\n      } while (iVar9 != 0);\n      *puVar12 = *puVar12 | (uint)(&DAT_00235408)[(long)iVar8 * 2];\n    }\n  }\n  pcVar14 = \"_DefaultCmD_\";\n  if ((bVar2) || (pcVar14 = \"_EmptycmD_\", bVar3)) {\nLAB_001bce56:\n    uVar16 = make_bare_word(pcVar14);\n    plVar11 = (long *)make_word_list(uVar16,0);\n    if (((ulong)plVar11 | (ulong)plVar5) == 0) {\nLAB_001bce6d:\n      uVar7 = local_44;\n      uVar6 = local_48;\n      lVar10 = pcomp_curcs;\n      if (((rl_readline_state._1_1_ & 0x40) == 0) || (pcomp_curcs == 0)) {\n        uVar16 = 1;\n        builtin_error(\"not currently executing completion function\");\n      }\n      else {\n        if ((local_48 | local_44) == 0) {\n          FUN_001bbde0(pcomp_curcmd,pcomp_curcs);\n          if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n            uVar16 = sh_chkwrite(0);\n            return uVar16;\n          }\n          goto LAB_001bcf98;\n        }\n        pcomp_set_compspec_options(pcomp_curcs,local_48,1);\n        pcomp_set_compspec_options(lVar10,uVar7,0);\n        pcomp_set_readline_variables(uVar6,1);\n        uVar16 = 0;\n        pcomp_set_readline_variables(uVar7,0);\n      }\n    }\n    else {\n      plVar13 = plVar11;\n      if ((plVar11 != (long *)0x0) || (plVar13 = plVar5, plVar5 != (long *)0x0)) goto LAB_001bcde1;\n      uVar16 = 0;\n    }\n  }\n  else {\n    if (bVar4) {\n      pcVar14 = \"_InitialWorD_\";\n      goto LAB_001bce56;\n    }\n    if (loptend == (long *)0x0) goto LAB_001bce6d;\n    plVar11 = (long *)0x0;\n    plVar13 = plVar5;\nLAB_001bcde1:\n    uVar16 = 0;\n    do {\n      lVar10 = progcomp_search(*(undefined8 *)plVar13[1]);\n      uVar6 = local_44;\n      if (lVar10 == 0) {\n        uVar16 = 1;\n        builtin_error(\"%s: no completion specification\",*(undefined8 *)plVar13[1]);\n      }\n      else if ((local_48 | local_44) == 0) {\n        FUN_001bbde0(*(undefined8 *)plVar13[1],lVar10);\n      }\n      else {\n        pcomp_set_compspec_options(lVar10,local_48,1);\n        pcomp_set_compspec_options(lVar10,uVar6,0);\n      }\n      plVar13 = (long *)*plVar13;\n    } while (plVar13 != (long *)0x0);\n    if (plVar11 != (long *)0x0) {\n      dispose_words(plVar11);\n    }\n  }\nLAB_001bcd58:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar16;\n  }\nLAB_001bcf98:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_vi_put": "\nundefined8 rl_vi_put(int param_1,uint param_2)\n\n{\n  ushort **ppuVar1;\n  \n  ppuVar1 = __ctype_b_loc();\n  if (((*(byte *)((long)*ppuVar1 + (ulong)(param_2 & 0xff) * 2 + 1) & 1) == 0) &&\n     (rl_point < rl_end)) {\n    rl_point = _rl_find_next_mbchar(rl_line_buffer,rl_point,1,1);\n  }\n  if (param_1 != 0) {\n    do {\n      rl_yank(1,param_2);\n      param_1 = param_1 + -1;\n    } while (param_1 != 0);\n  }\n  rl_backward_char(1,param_2);\n  return 0;\n}\n\n",
  "FUN_001945d0": "\nsize_t FUN_001945d0(int param_1)\n\n{\n  char cVar1;\n  size_t sVar2;\n  size_t sVar3;\n  char *pcVar4;\n  \n  cVar1 = rl_line_buffer[param_1];\n  rl_line_buffer[param_1] = '\\0';\n  sVar2 = __ctype_get_mb_cur_max();\n  pcVar4 = rl_line_buffer;\n  sVar3 = 0;\n  if (sVar2 < 2) {\n    if ((((rl_line_buffer != (char *)0x0) && (*rl_line_buffer != '\\0')) &&\n        (sVar3 = 1, rl_line_buffer[1] != '\\0')) && (sVar3 = 2, rl_line_buffer[2] != '\\0')) {\n      sVar3 = strlen(rl_line_buffer);\n    }\n  }\n  else if (((rl_line_buffer != (char *)0x0) && (*rl_line_buffer != '\\0')) &&\n          (sVar3 = 1, rl_line_buffer[1] != '\\0')) {\n    sVar3 = mbstrlen(rl_line_buffer);\n    pcVar4 = rl_line_buffer;\n  }\n  pcVar4[param_1] = cVar1;\n  return sVar3;\n}\n\n",
  "sh_get_home_dir": "\nlong sh_get_home_dir(void)\n\n{\n  if (DAT_00238060 != 0) {\n    return DAT_00238060;\n  }\n  get_current_user_info();\n  return DAT_00238060;\n}\n\n",
  "ansic_quote": "\nundefined2 * ansic_quote(byte *param_1,undefined8 param_2,int *param_3)\n\n{\n  int iVar1;\n  size_t sVar2;\n  undefined2 *puVar3;\n  ushort **ppuVar4;\n  ulong uVar5;\n  ulong uVar6;\n  byte bVar7;\n  undefined2 *puVar8;\n  long in_FS_OFFSET;\n  bool bVar9;\n  wchar_t local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (byte *)0x0) {\n    puVar3 = (undefined2 *)0x0;\n  }\n  else {\n    puVar3 = (undefined2 *)0x0;\n    if (*param_1 != 0) {\n      sVar2 = strlen((char *)param_1);\n      puVar3 = (undefined2 *)sh_xmalloc((long)((int)sVar2 * 4 + 4),\"strtrans.c\",0xf8);\n      *puVar3 = 0x2724;\n      bVar7 = *param_1;\n      puVar8 = puVar3 + 1;\n      if (bVar7 != 0) {\n        do {\n          if ((char)bVar7 < '(') {\n            if ((char)bVar7 < '\\a') goto switchD_001c9c2b_caseD_e;\n            switch(bVar7) {\n            case 7:\n              bVar7 = 0x61;\n              break;\n            case 8:\n              bVar7 = 0x62;\n              break;\n            case 9:\n              bVar7 = 0x74;\n              break;\n            case 10:\n              bVar7 = 0x6e;\n              break;\n            case 0xb:\n              bVar7 = 0x76;\n              break;\n            case 0xc:\n              bVar7 = 0x66;\n              break;\n            case 0xd:\n              bVar7 = 0x72;\n              break;\n            default:\n              goto switchD_001c9c2b_caseD_e;\n            case 0x1b:\n              bVar7 = 0x45;\n              break;\n            case 0x27:\n              break;\n            }\nswitchD_001c9c2b_caseD_27:\n            *(undefined *)puVar8 = 0x5c;\n            puVar8 = (undefined2 *)((long)puVar8 + 1);\nLAB_001c9c88:\n            *(byte *)puVar8 = bVar7;\n            puVar8 = (undefined2 *)((long)puVar8 + 1);\n          }\n          else {\n            if (bVar7 == 0x5c) goto switchD_001c9c2b_caseD_27;\nswitchD_001c9c2b_caseD_e:\n            if ((*(uint *)(is_basic_table + (ulong)(bVar7 >> 5) * 4) >> (bVar7 & 0x1f) & 1) != 0) {\n              ppuVar4 = __ctype_b_loc();\n              if ((*(byte *)((long)*ppuVar4 + (ulong)bVar7 * 2 + 1) & 0x40) == 0) goto LAB_001c9da4;\n              goto LAB_001c9c88;\n            }\n            sVar2 = __ctype_get_mb_cur_max();\n            sVar2 = mbrtowc(&local_44,(char *)param_1,sVar2,(mbstate_t *)0x0);\n            if ((sVar2 < 0xfffffffffffffffe) && (iVar1 = iswprint(local_44), iVar1 != 0)) {\n              if (sVar2 == 0) break;\n              if (sVar2 == 1) goto LAB_001c9c88;\n              if (0 < (int)sVar2) {\n                uVar6 = (ulong)((int)sVar2 - 1);\n                uVar5 = 0;\n                do {\n                  *(byte *)((long)puVar8 + uVar5) = param_1[uVar5];\n                  bVar9 = uVar6 != uVar5;\n                  uVar5 = uVar5 + 1;\n                } while (bVar9);\n                puVar8 = (undefined2 *)((long)puVar8 + uVar6 + 1);\n              }\n              param_1 = param_1 + (sVar2 - 1);\n            }\n            else {\nLAB_001c9da4:\n              *(undefined *)puVar8 = 0x5c;\n              *(byte *)((long)puVar8 + 1) = (bVar7 >> 6) + 0x30;\n              *(byte *)(puVar8 + 1) = (bVar7 >> 3 & 7) + 0x30;\n              *(byte *)((long)puVar8 + 3) = (bVar7 & 7) + 0x30;\n              puVar8 = puVar8 + 2;\n            }\n          }\n          bVar7 = param_1[1];\n          param_1 = param_1 + 1;\n        } while (bVar7 != 0);\n      }\n      *puVar8 = 0x27;\n      if (param_3 != (int *)0x0) {\n        *param_3 = ((int)puVar8 + 1) - (int)puVar3;\n      }\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "restore_traps": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid restore_traps(void)\n\n{\n  byte bVar1;\n  uint uVar2;\n  ulong uVar3;\n  undefined4 *puVar4;\n  long lVar5;\n  ulong uVar6;\n  \n  if (trap_list != 0) {\n    uVar2 = DAT_00247e40 & 0xffffffbf | 1;\n    if (trap_list == 1) {\n      uVar2 = DAT_00247e40 | 0x41;\n    }\n    DAT_00247e40 = uVar2;\n    if ((uVar2 & 0x10) != 0) {\n      DAT_00247e40 = uVar2 | 0x20;\n    }\n  }\n  if (DAT_00247c08 == 0) {\n    if ((DAT_00247c18 == 0) || (function_trace_mode != 0)) goto LAB_001830d7;\n  }\n  else {\n    if (function_trace_mode != 0) goto LAB_001830d7;\n    uVar2 = DAT_00247f44 & 0xffffffbf | 1;\n    if (DAT_00247c08 == 1) {\n      uVar2 = DAT_00247f44 | 0x41;\n    }\n    DAT_00247f44 = uVar2;\n    if ((uVar2 & 0x10) != 0) {\n      DAT_00247f44 = uVar2 | 0x20;\n    }\n    if (DAT_00247c18 == 0) goto LAB_001830d7;\n  }\n  uVar2 = DAT_00247f4c & 0xffffffbf | 1;\n  if (DAT_00247c18 == 1) {\n    uVar2 = DAT_00247f4c | 0x41;\n  }\n  DAT_00247f4c = uVar2;\n  if ((uVar2 & 0x10) != 0) {\n    DAT_00247f4c = uVar2 | 0x20;\n  }\nLAB_001830d7:\n  if ((DAT_00247c10 != 0) && (error_trace_mode == 0)) {\n    uVar2 = _DAT_00247f48 & 0xffffffbf | 1;\n    if (DAT_00247c10 == 1) {\n      uVar2 = _DAT_00247f48 | 0x41;\n    }\n    _DAT_00247f48 = uVar2;\n    if ((uVar2 & 0x10) != 0) {\n      _DAT_00247f48 = uVar2 | 0x20;\n    }\n  }\n  puVar4 = &DAT_00247e44;\n  uVar3 = 1;\n  do {\n    lVar5 = (&trap_list)[uVar3];\n    uVar6 = uVar3 & 0xffffffff;\n    if ((*(byte *)puVar4 & 4) == 0) {\n      if (lVar5 == 1) {\n        FUN_00180f40(uVar3 & 0xffffffff);\n        bVar1 = *(byte *)puVar4;\njoined_r0x00183126:\n        if ((bVar1 & 8) == 0) {\n          set_signal_handler(uVar6 & 0xffffffff,1);\n        }\n      }\n      else if (lVar5 != 0) {\n        set_signal(uVar3 & 0xffffffff,lVar5);\n      }\n    }\n    else if ((lVar5 != 0) && (FUN_00180f40(uVar3 & 0xffffffff), lVar5 == 1)) {\n      bVar1 = *(byte *)puVar4;\n      goto joined_r0x00183126;\n    }\n    *(undefined4 *)(pending_traps + uVar3 * 4) = 0;\n    uVar3 = uVar3 + 1;\n    puVar4 = puVar4 + 1;\n    if (uVar3 == 0x41) {\n      return;\n    }\n  } while( true );\n}\n\n",
  "strip_trailing": "\nvoid strip_trailing(long param_1,int param_2,int param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  \n  lVar3 = (long)param_2;\n  if (param_2 < 0) {\nLAB_0019a2bd:\n    *(undefined *)(param_1 + 1 + lVar3) = 0;\n    return;\n  }\n  do {\n    cVar1 = *(char *)(param_1 + lVar3);\n    if (param_3 == 0) {\n      if ((cVar1 != ' ') && (cVar1 != '\\t')) goto LAB_0019a2bd;\n    }\n    else if (cVar1 != '\\n') goto LAB_0019a2bd;\n    iVar2 = (int)lVar3;\n    lVar3 = lVar3 + -1;\n    if ((int)lVar3 < 0) {\n      *(undefined *)(param_1 + 1 + (long)(iVar2 + -1)) = 0;\n      return;\n    }\n  } while( true );\n}\n\n",
  "sh_setclexec": "\nvoid sh_setclexec(int param_1)\n\n{\n  fcntl(param_1,2,1);\n  return;\n}\n\n",
  "_rl_nsearch_callback": "\nbool _rl_nsearch_callback(long param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = _rl_search_getchar();\n  if (iVar1 < 1) {\n    if (iVar1 != 0) {\n      rl_maybe_unsave_line();\n      rl_point = *(undefined4 *)(param_1 + 0x30);\n      rl_mark = *(undefined4 *)(param_1 + 0x34);\n      rl_restore_prompt();\n      rl_clear_message();\n      _rl_fix_point(1);\n      rl_readline_state = rl_readline_state & 0xfffffffffffffeff;\n    }\n  }\n  else {\n    iVar1 = FUN_001d4cd0(param_1,iVar1);\n    if (iVar1 == 0) {\n      iVar1 = FUN_001d4780(param_1);\n      if (-1 < iVar1) {\n        _rl_scxt_dispose(param_1,0);\n        rl_readline_state = rl_readline_state & 0xfffffffffffffeff;\n        _rl_nscxt = 0;\n        return iVar1 != 1;\n      }\n    }\n  }\n  return true;\n}\n\n",
  "strlist_to_word_list": "\nundefined8 strlist_to_word_list(long *param_1)\n\n{\n  undefined8 uVar1;\n  \n  if ((param_1 != (long *)0x0) && (*param_1 != 0)) {\n    uVar1 = strvec_to_word_list();\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "sbrand": "\nvoid sbrand(undefined4 param_1)\n\n{\n  DAT_0023b318 = param_1;\n  last_random_value = 0;\n  return;\n}\n\n",
  "new_fd_bitmap": "\nint * new_fd_bitmap(int param_1)\n\n{\n  int *piVar1;\n  void *__s;\n  \n  piVar1 = (int *)sh_xmalloc(0x10,\"execute_cmd.c\",0x147);\n  *piVar1 = param_1;\n  if (param_1 == 0) {\n    *(undefined8 *)(piVar1 + 2) = 0;\n    return piVar1;\n  }\n  __s = (void *)sh_xmalloc((long)param_1,\"execute_cmd.c\",0x14d);\n  *(void **)(piVar1 + 2) = __s;\n  memset(__s,0,(long)param_1);\n  return piVar1;\n}\n\n",
  "rl_vi_match": "\nundefined8 rl_vi_match(undefined8 param_1,undefined4 param_2)\n\n{\n  char cVar1;\n  uint uVar2;\n  size_t sVar3;\n  ulong uVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  int iVar9;\n  bool bVar10;\n  \n  uVar2 = rl_point;\n  cVar1 = *(char *)(rl_line_buffer + (int)rl_point);\n  if (cVar1 == ']') {\n    iVar7 = -2;\nLAB_001d39b5:\n    iVar9 = 1;\n    uVar8 = rl_point;\n    while( true ) {\n      sVar3 = __ctype_get_mb_cur_max();\n      if ((sVar3 == 1) || (rl_byte_oriented != 0)) {\n        uVar8 = uVar8 - 1;\n      }\n      else {\n        uVar2 = _rl_find_prev_mbchar(rl_line_buffer,uVar8,0);\n        uVar6 = uVar8 - 1;\n        bVar10 = uVar2 == uVar8;\n        uVar8 = uVar2;\n        if (bVar10) {\n          uVar8 = uVar6;\n        }\n      }\n      uVar2 = rl_point;\n      if ((int)uVar8 < 0) break;\n      cVar1 = *(char *)(rl_line_buffer + (int)uVar8);\n      if (cVar1 == ']') {\n        iVar5 = -2;\nLAB_001d3a2d:\n        iVar9 = iVar9 + (uint)(iVar7 == iVar5);\n      }\n      else if (cVar1 < '^') {\n        if (cVar1 == ')') {\n          iVar5 = -1;\n          goto LAB_001d3a2d;\n        }\n        iVar5 = 2;\n        if (cVar1 == '[') goto LAB_001d3a0d;\n        if ((cVar1 == '(') && (iVar7 == -1)) {\nLAB_001d3a11:\n          iVar9 = iVar9 + -1;\n          if (iVar9 == 0) {\n            rl_point = uVar8;\n            return 0;\n          }\n        }\n      }\n      else if (cVar1 == '{') {\n        iVar5 = 3;\nLAB_001d3a0d:\n        if (iVar5 + iVar7 == 0) goto LAB_001d3a11;\n      }\n      else if (cVar1 == '}') {\n        iVar5 = -3;\n        goto LAB_001d3a2d;\n      }\n    }\n    goto LAB_001d391b;\n  }\n  if (cVar1 < '^') {\n    if (cVar1 == ')') {\n      iVar7 = -1;\n      goto LAB_001d39b5;\n    }\n    uVar4 = (ulong)rl_point;\n    iVar7 = 2;\n    if ((cVar1 != '[') && (iVar7 = 1, cVar1 != '(')) {\nLAB_001d3a6d:\n      sVar3 = __ctype_get_mb_cur_max();\n      if ((sVar3 < 2) || (rl_byte_oriented != 0)) {\n        while( true ) {\n          uVar4 = (ulong)(int)rl_point;\n          cVar1 = *(char *)(rl_line_buffer + uVar4);\n          if (cVar1 == ']') break;\n          if (cVar1 < '^') {\n            if (cVar1 == ')') break;\n            if (cVar1 == '[') goto LAB_001d3b7f;\n            if (cVar1 == '(') goto LAB_001d3bac;\n          }\n          else {\n            if (cVar1 == '{') goto LAB_001d3bc0;\n            if (cVar1 == '}') break;\n          }\n          if (rl_end + -1 <= (int)rl_point) break;\n          rl_forward_char(1,param_2);\n        }\n      }\n      else {\n        do {\n          uVar8 = rl_point;\n          uVar4 = (ulong)rl_point;\n          cVar1 = *(char *)(rl_line_buffer + (int)rl_point);\n          if (cVar1 == ']') break;\n          if (cVar1 < '^') {\n            if (cVar1 == ')') break;\n            if (cVar1 == '[') goto LAB_001d3b7f;\n            if (cVar1 == '(') goto LAB_001d3bac;\n          }\n          else {\n            if (cVar1 == '{') goto LAB_001d3bc0;\n            if (cVar1 == '}') break;\n          }\n          rl_forward_char(1,param_2);\n        } while (rl_point != uVar8);\n      }\n      goto LAB_001d391b;\n    }\n  }\n  else {\n    if (cVar1 != '{') {\n      if (cVar1 != '}') goto LAB_001d3a6d;\n      iVar7 = -3;\n      goto LAB_001d39b5;\n    }\n    uVar4 = (ulong)rl_point;\n    iVar7 = 3;\n  }\n  goto LAB_001d3880;\nLAB_001d3b7f:\n  iVar7 = 2;\n  goto LAB_001d3880;\nLAB_001d3bac:\n  iVar7 = 1;\n  goto LAB_001d3880;\nLAB_001d3bc0:\n  iVar7 = 3;\nLAB_001d3880:\n  iVar9 = 1;\nLAB_001d3890:\n  uVar8 = (uint)uVar4;\n  sVar3 = __ctype_get_mb_cur_max();\n  if ((sVar3 != 1) && (rl_byte_oriented == 0)) goto LAB_001d38fc;\nLAB_001d38a5:\n  uVar8 = (int)uVar4 + 1;\n  uVar2 = rl_point;\n  if ((int)uVar8 < rl_end) {\n    do {\n      uVar4 = (ulong)uVar8;\n      cVar1 = *(char *)(rl_line_buffer + (int)uVar8);\n      if (cVar1 == ']') {\n        iVar5 = -2;\nLAB_001d3941:\n        if ((iVar5 == -iVar7) && (iVar9 = iVar9 + -1, iVar9 == 0)) {\n          rl_point = uVar8;\n          return 0;\n        }\n        goto LAB_001d3890;\n      }\n      if (cVar1 < '^') {\n        if (cVar1 == ')') {\n          iVar5 = -1;\n          goto LAB_001d3941;\n        }\n        iVar5 = 2;\n        if ((cVar1 != '[') && (iVar5 = 1, cVar1 != '(')) goto LAB_001d3890;\n      }\n      else {\n        if (cVar1 != '{') {\n          if (cVar1 == '}') {\n            iVar5 = -3;\n            goto LAB_001d3941;\n          }\n          goto LAB_001d3890;\n        }\n        iVar5 = 3;\n      }\n      iVar9 = iVar9 + (uint)(iVar7 == iVar5);\n      sVar3 = __ctype_get_mb_cur_max();\n      if ((sVar3 == 1) || (rl_byte_oriented != 0)) goto LAB_001d38a5;\nLAB_001d38fc:\n      uVar8 = _rl_find_next_mbchar(rl_line_buffer,uVar8,1,0);\n      uVar2 = rl_point;\n      if (rl_end <= (int)uVar8) break;\n    } while( true );\n  }\nLAB_001d391b:\n  rl_point = uVar2;\n  rl_ding();\n  return 1;\n}\n\n",
  "rl_end_kbd_macro": "\nvoid rl_end_kbd_macro(int param_1)\n\n{\n  long lVar1;\n  \n  if ((rl_readline_state & 0x1000) != 0) {\n    DAT_0024b190 = DAT_0024b190 - rl_key_sequence_length;\n    if (DAT_0024b190 < 0) {\n      DAT_0024b190 = 0;\n      lVar1 = 0;\n    }\n    else {\n      lVar1 = (long)DAT_0024b190;\n    }\n    *(undefined *)(DAT_0024b198 + lVar1) = 0;\n    rl_readline_state = rl_readline_state & 0xffffffffffffefff;\n    rl_call_last_kbd_macro(param_1 + -1,0);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  _rl_abort_internal();\n}\n\n",
  "disown_builtin": "\nundefined8 disown_builtin(undefined8 param_1)\n\n{\n  bool bVar1;\n  int iVar2;\n  long *plVar3;\n  uint uVar4;\n  char *pcVar5;\n  uint uVar6;\n  undefined8 uVar7;\n  long in_FS_OFFSET;\n  ulong local_150;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  bVar1 = false;\n  uVar6 = 0;\n  uVar4 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  reset_internal_getopt();\n  while (iVar2 = internal_getopt(param_1,&DAT_00210042), iVar2 != -1) {\n    if (iVar2 == 0x68) {\n      bVar1 = true;\n    }\n    else if (iVar2 < 0x69) {\n      if (iVar2 == -99) {\n        builtin_help();\n        uVar7 = 0x102;\n        goto LAB_001ad5d9;\n      }\n      if (iVar2 != 0x61) {\nLAB_001ad618:\n        builtin_usage();\n        uVar7 = 0x102;\n        goto LAB_001ad5d9;\n      }\n      uVar4 = 1;\n    }\n    else {\n      if (iVar2 != 0x72) goto LAB_001ad618;\n      uVar6 = 1;\n    }\n  }\n  if ((loptend == (long *)0x0) && ((uVar4 | uVar6) != 0)) {\n    if (bVar1) {\n      nohup_all_jobs();\n      uVar7 = 0;\n    }\n    else {\n      delete_all_jobs(uVar6);\n      uVar7 = 0;\n    }\n  }\n  else {\n    uVar7 = 0;\n    plVar3 = loptend;\n    do {\n      sigemptyset(&local_148);\n      sigaddset(&local_148,0x11);\n      sigemptyset(&local_c8);\n      sigprocmask(0,&local_148,&local_c8);\n      if (plVar3 == (long *)0x0) {\n        iVar2 = get_job_spec(0);\n        if ((((iVar2 == -1) || (iVar2 < 0)) || (jobs == 0)) || (DAT_0023877c <= iVar2)) {\nLAB_001ad778:\n          pcVar5 = \"current\";\n          goto LAB_001ad70f;\n        }\nLAB_001ad6e2:\n        if (*(long *)(jobs + (long)iVar2 * 8) == 0) {\n          if (plVar3 != (long *)0x0) goto LAB_001ad708;\n          goto LAB_001ad778;\n        }\nLAB_001ad6ec:\n        if (bVar1) {\n          nohup_job();\n        }\n        else {\n          delete_job(iVar2,1);\n        }\n      }\n      else {\n        iVar2 = legal_number(*(undefined8 *)plVar3[1],&local_150);\n        if ((iVar2 == 0) || (local_150 != (long)(int)local_150)) {\n          iVar2 = get_job_spec(plVar3);\n          if ((((iVar2 != -1) && (jobs != 0)) && (-1 < iVar2)) && (iVar2 < DAT_0023877c))\n          goto LAB_001ad6e2;\n        }\n        else {\n          iVar2 = get_job_by_pid(local_150 & 0xffffffff,0,0);\n          if (((iVar2 != -1) && ((jobs != 0 && (-1 < iVar2)))) &&\n             ((iVar2 < DAT_0023877c && (*(long *)(jobs + (long)iVar2 * 8) != 0))))\n          goto LAB_001ad6ec;\n        }\nLAB_001ad708:\n        pcVar5 = *(char **)plVar3[1];\nLAB_001ad70f:\n        sh_badjob(pcVar5);\n        uVar7 = 1;\n      }\n      sigprocmask(2,&local_c8,(sigset_t *)0x0);\n    } while ((plVar3 != (long *)0x0) && (plVar3 = (long *)*plVar3, plVar3 != (long *)0x0));\n  }\nLAB_001ad5d9:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar7;\n}\n\n",
  "expand_string": "\nundefined8 expand_string(char *param_1)\n\n{\n  undefined8 uVar1;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    uVar1 = FUN_0017af90();\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "first_pending_trap": "\nulong first_pending_trap(void)\n\n{\n  ulong uVar1;\n  \n  uVar1 = 1;\n  do {\n    if (*(int *)(pending_traps + uVar1 * 4) != 0) {\n      return uVar1 & 0xffffffff;\n    }\n    uVar1 = uVar1 + 1;\n  } while (uVar1 != 0x41);\n  return 0xffffffff;\n}\n\n",
  "tputs": "\nvoid tputs(void)\n\n{\n  (*(code *)PTR_tputs_00237848)();\n  return;\n}\n\n",
  "cd_builtin": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 cd_builtin(undefined8 param_1)\n\n{\n  char cVar1;\n  long *plVar2;\n  int iVar3;\n  undefined8 uVar4;\n  char *pcVar5;\n  int *piVar6;\n  char *pcVar7;\n  char *pcVar8;\n  long lVar9;\n  byte bVar10;\n  int iVar11;\n  long in_FS_OFFSET;\n  bool bVar12;\n  undefined4 local_44;\n  long local_40;\n  \n  iVar11 = no_symbolic_links;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (restricted == 0) {\n    DAT_00248a7c = 0;\n    _DAT_00248a78 = 0;\n    reset_internal_getopt();\nLAB_001a316f:\n    do {\n      iVar3 = internal_getopt(param_1,&DAT_0020f22b);\n      plVar2 = loptend;\n      if (iVar3 == -1) goto LAB_001a3200;\n      if (iVar3 != 0x50) {\n        if (iVar3 < 0x51) {\n          if (iVar3 == -99) {\n            builtin_help();\n            uVar4 = 0x102;\n            goto LAB_001a3199;\n          }\n          if (iVar3 == 0x4c) {\n            iVar11 = 0;\n            goto LAB_001a316f;\n          }\n        }\n        else if (iVar3 == 0x65) {\n          DAT_00248a7c = 1;\n          goto LAB_001a316f;\n        }\n        builtin_usage();\n        uVar4 = 0x102;\n        goto LAB_001a3199;\n      }\n      iVar11 = 1;\n    } while( true );\n  }\n  sh_restricted(0);\n  uVar4 = 1;\n  goto LAB_001a3199;\nLAB_001a3200:\n  bVar12 = cdable_vars != 0;\n  bVar10 = bVar12;\n  if ((interactive != 0) && (cdspelling != 0)) {\n    bVar10 = 2;\n  }\n  if ((DAT_00248a7c != 0) && (iVar11 == 0)) {\n    DAT_00248a7c = 0;\n  }\n  if (loptend == (long *)0x0) {\n    pcVar8 = (char *)get_string_value(&DAT_001faa94);\n    if (pcVar8 == (char *)0x0) {\n      builtin_error(\"HOME not set\");\n      uVar4 = 1;\n      goto LAB_001a3199;\n    }\n    iVar3 = FUN_001a2e10(pcVar8,iVar11);\n    if (iVar3 == 0) goto LAB_001a32ea;\nLAB_001a3374:\n    uVar4 = FUN_001a2cc0(iVar11);\n  }\n  else {\n    if (*loptend != 0) {\n      builtin_error(\"too many arguments\");\n      uVar4 = 1;\n      goto LAB_001a3199;\n    }\n    if ((**(char **)loptend[1] == '-') && ((*(char **)loptend[1])[1] == '\\0')) {\n      pcVar8 = (char *)get_string_value(&DAT_001fc3d2);\n      if (pcVar8 == (char *)0x0) {\n        builtin_error(\"OLDPWD not set\");\n        uVar4 = 1;\n        goto LAB_001a3199;\n      }\n      iVar3 = FUN_001a2e10(pcVar8,iVar11);\n      if (iVar3 != 0) {\n        puts(pcVar8);\n        goto LAB_001a3374;\n      }\n    }\n    else {\n      iVar3 = absolute_pathname();\n      if ((iVar3 == 0) && (privileged_mode == 0)) {\n        lVar9 = get_string_value(\"CDPATH\");\n        if (lVar9 == 0) goto LAB_001a3285;\n        pcVar8 = *(char **)plVar2[1];\n        local_44 = 0;\n        while( true ) {\n          pcVar5 = (char *)extract_colon_unit(lVar9,&local_44);\n          if (pcVar5 == (char *)0x0) break;\n          cVar1 = *pcVar5;\n          pcVar7 = (char *)sh_makepath(pcVar5,pcVar8,1);\n          sh_xfree(pcVar5,\"./cd.def\",0x177);\n          iVar3 = FUN_001a2e10(pcVar7,iVar11);\n          if (iVar3 != 0) {\n            if (cVar1 != '\\0') {\n              pcVar8 = pcVar7;\n              if (iVar11 == 0) {\n                pcVar8 = the_current_working_directory;\n              }\n              if (pcVar8 != (char *)0x0) {\n                puts(pcVar8);\n              }\n            }\n            sh_xfree(pcVar7,\"./cd.def\",0x182);\n            uVar4 = FUN_001a2cc0(iVar11);\n            goto LAB_001a3199;\n          }\n          sh_xfree(pcVar7,\"./cd.def\",0x18c);\n        }\n      }\n      else {\nLAB_001a3285:\n        pcVar8 = *(char **)plVar2[1];\n      }\n      iVar3 = FUN_001a2e10(pcVar8,iVar11);\n      if (iVar3 != 0) goto LAB_001a3374;\n      if (bVar12) {\n        pcVar5 = (char *)get_string_value(pcVar8);\n        if (pcVar5 != (char *)0x0) {\n          iVar3 = FUN_001a2e10(pcVar5,iVar11);\n          if (iVar3 != 0) {\n            puts(pcVar5);\n            uVar4 = FUN_001a2cc0(iVar11);\n            goto LAB_001a3199;\n          }\n        }\n      }\n      if ((bVar10 & 2) != 0) {\n        pcVar5 = (char *)dirspell(pcVar8);\n        if (pcVar5 != (char *)0x0) {\n          iVar3 = FUN_001a2e10(pcVar5,iVar11);\n          if (iVar3 != 0) {\n            puts(pcVar5);\n            sh_xfree(pcVar5,\"./cd.def\",0x1bf);\n            goto LAB_001a3374;\n          }\n          sh_xfree(pcVar5,\"./cd.def\",0x1c3);\n        }\n      }\n    }\nLAB_001a32ea:\n    piVar6 = __errno_location();\n    iVar11 = *piVar6;\n    pcVar5 = (char *)printable_filename(pcVar8,0);\n    pcVar7 = strerror(iVar11);\n    builtin_error(\"%s: %s\",pcVar5,pcVar7);\n    uVar4 = 1;\n    if (pcVar5 != pcVar8) {\n      sh_xfree(pcVar5,\"./cd.def\",0x1ca);\n      uVar4 = 1;\n    }\n  }\nLAB_001a3199:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "let_builtin": "\nulong let_builtin(long **param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  char *__s1;\n  long in_FS_OFFSET;\n  int local_24;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (long **)0x0) {\nLAB_001addf0:\n    builtin_error(\"expression expected\");\n    uVar3 = 1;\n  }\n  else {\n    __s1 = (char *)*param_1[1];\n    if (*__s1 == '-') {\n      iVar1 = strcmp(__s1,\"--help\");\n      if (iVar1 == 0) {\n        builtin_help();\n        uVar3 = 0x102;\n        goto LAB_001add8d;\n      }\n      if ((__s1[1] == '-') && (__s1[2] == '\\0')) {\n        param_1 = (long **)*param_1;\n        if (param_1 == (long **)0x0) goto LAB_001addf0;\n        __s1 = (char *)*param_1[1];\n      }\n    }\n    while( true ) {\n      lVar2 = evalexp(__s1,1,&local_24);\n      if (local_24 == 0) break;\n      param_1 = (long **)*param_1;\n      if (param_1 == (long **)0x0) {\n        uVar3 = (ulong)(lVar2 == 0);\n        goto LAB_001add8d;\n      }\n      __s1 = (char *)*param_1[1];\n    }\n    uVar3 = 1;\n  }\nLAB_001add8d:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "assign_compound_array_list": "\nvoid assign_compound_array_list(undefined8 *param_1,undefined8 *param_2,uint param_3)\n\n{\n  char *pcVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  uint uVar4;\n  long lVar5;\n  char *pcVar6;\n  undefined *puVar7;\n  long *plVar8;\n  char cVar9;\n  uint uVar10;\n  uint uVar11;\n  char *pcVar12;\n  long lVar13;\n  long lVar14;\n  uint uVar15;\n  undefined8 uVar16;\n  long local_70;\n  char *local_68;\n  long *local_60;\n  long *local_48;\n  long *local_40;\n  \n  uVar10 = param_3 & 1;\n  uVar4 = *(uint *)(param_1 + 5);\n  uVar11 = uVar4 & 0x40;\n  if ((uVar4 & 4) == 0) {\n    if (uVar11 != 0) {\n      local_60 = (long *)param_1[1];\n      if (uVar10 != 0) {\n        lVar14 = 0;\n        local_40 = (long *)0x0;\n        local_48 = local_60;\n        goto LAB_0018be88;\n      }\n      if (local_60 == (long *)0x0) goto LAB_0018c502;\nLAB_0018c35c:\n      plVar8 = (long *)hash_create(*(undefined4 *)(local_60 + 1));\n      local_48 = local_60;\n      uVar4 = *(uint *)(param_1 + 5);\n      local_60 = plVar8;\nLAB_0018c379:\n      local_40 = (long *)0x0;\n      lVar14 = 0;\n      uVar11 = uVar4 & 0x40;\n      goto LAB_0018be88;\n    }\n    if (uVar10 == 0) {\n      local_48 = (long *)0x0;\n      local_60 = (long *)0x0;\n      goto LAB_0018c379;\n    }\n    local_60 = (long *)0x0;\n    local_40 = (long *)0x0;\n    lVar14 = 0;\n    local_48 = (long *)0x0;\nLAB_0018c14d:\n    if (param_2 == (undefined8 *)0x0) goto LAB_0018bfab;\n  }\n  else {\n    local_40 = (long *)param_1[1];\n    local_60 = (long *)0x0;\n    if (uVar11 != 0) {\n      local_60 = local_40;\n    }\n    local_48 = local_60;\n    if (uVar10 != 0) {\n      if (local_40 == (long *)0x0) {\n        lVar14 = 0;\n      }\n      else {\n        lVar14 = *local_40 + 1;\n      }\nLAB_0018be88:\n      if (uVar11 != 0) {\n        if (param_2 != (undefined8 *)0x0) {\n          uVar4 = *(uint *)((char **)param_2[1] + 1);\n          pcVar12 = *(char **)param_2[1];\n          if (((uVar4 & 4) != 0) || (*pcVar12 == '[')) goto LAB_0018beb3;\n          while( true ) {\n            puVar2 = (undefined8 *)*param_2;\n            if (puVar2 == (undefined8 *)0x0) {\n              uVar16 = 0;\n            }\n            else {\n              uVar16 = *(undefined8 *)puVar2[1];\n              param_2 = puVar2;\n            }\n            pcVar6 = (char *)expand_subscript_string(pcVar12,0);\n            if (pcVar6 == (char *)0x0) {\n              err_badarraysub(pcVar12);\n            }\n            else if (*pcVar6 == '\\0') {\n              err_badarraysub(pcVar12);\n              sh_xfree(pcVar6,\"arrayfunc.c\",0x289);\n            }\n            else {\n              puVar7 = (undefined *)expand_subscript_string(uVar16,0);\n              if (puVar7 == (undefined *)0x0) {\n                puVar7 = (undefined *)sh_xmalloc(1,\"arrayfunc.c\",0x290);\n                *puVar7 = 0;\n              }\n              FUN_0018a950(param_1,local_60,pcVar6,puVar7,param_3 & 0xfffffffe);\n              sh_xfree(puVar7,\"arrayfunc.c\",0x295);\n            }\n            param_2 = (undefined8 *)*param_2;\n            if (param_2 == (undefined8 *)0x0) break;\n            pcVar12 = *(char **)param_2[1];\n          }\n          goto LAB_0018bfaf;\n        }\n        goto LAB_0018bfab;\n      }\n      goto LAB_0018c14d;\n    }\n    if (local_40 != (long *)0x0) {\n      array_flush();\n      uVar4 = *(uint *)(param_1 + 5);\n      lVar14 = 0;\n      uVar11 = uVar4 & 0x40;\n      goto LAB_0018be88;\n    }\n    if (local_60 == (long *)0x0) {\nLAB_0018c502:\n      local_48 = (long *)0x0;\n      goto LAB_0018c379;\n    }\n    if (uVar11 != 0) goto LAB_0018c35c;\n    lVar14 = 0;\n    if (param_2 == (undefined8 *)0x0) {\n      return;\n    }\n  }\n  pcVar12 = *(char **)param_2[1];\n  uVar4 = *(uint *)((char **)param_2[1] + 1);\nLAB_0018beb3:\n  local_68 = (char *)0x0;\n  local_70 = 0;\n  uVar10 = param_3 & 0xfffffffe;\n  do {\n    lVar5 = lVar14;\n    uVar11 = uVar10;\n    if (((uVar4 & 4) == 0) || (*pcVar12 != '[')) {\n      uVar4 = *(uint *)(param_1 + 5);\n      pcVar6 = pcVar12;\n      if ((uVar4 & 0x40) != 0) {\n        set_exit_status(1);\n        report_error(\"%s: %s: must use subscript when assigning associative array\",*param_1,pcVar12)\n        ;\n        goto LAB_0018bf11;\n      }\nLAB_0018bf4d:\n      local_70 = lVar14;\n      uVar15 = uVar4 & 0x10;\n      uVar16 = this_command_name;\n      if ((uVar4 & 0x10) == 0) {\nLAB_0018bf61:\n        FUN_0018a8b0(param_1,local_70,local_68);\n        this_command_name = uVar16;\n      }\n      else {\n        uVar15 = 0;\nLAB_0018bedb:\n        this_command_name = 0;\nLAB_0018bee6:\n        if ((uVar4 & 0x40) == 0) goto LAB_0018bf61;\n        FUN_0018a950(param_1,local_60,local_68,pcVar6,uVar11);\n        this_command_name = uVar16;\n      }\n      lVar14 = lVar5 + 1;\n      if (uVar15 == 0) goto LAB_0018bf11;\n      sh_xfree(pcVar6,\"arrayfunc.c\",0x361);\n      param_2 = (undefined8 *)*param_2;\n    }\n    else {\n      iVar3 = skipsubscript(pcVar12,0,0);\n      lVar13 = (long)iVar3;\n      pcVar6 = pcVar12 + lVar13;\n      if (*pcVar6 == ']') {\n        pcVar1 = pcVar12 + lVar13 + 1;\n        cVar9 = *pcVar1;\n        if ((cVar9 != '=') && ((cVar9 != '+' || (pcVar12[lVar13 + 2] != '=')))) goto LAB_0018c061;\n        if (iVar3 != 1) {\n          uVar4 = *(uint *)(param_1 + 5);\n          if ((pcVar12[1] == '*' || pcVar12[1] == '@') && (iVar3 == 2)) {\n            if ((uVar4 & 4) != 0) {\n              set_exit_status(1);\n              report_error(\"%s: cannot assign to non-numeric index\");\n              goto LAB_0018bf11;\n            }\nLAB_0018c1d0:\n            if ((uVar4 & 0x40) != 0) {\n              *pcVar6 = '\\0';\n              local_68 = (char *)expand_subscript_string(pcVar12 + 1);\n              *pcVar6 = ']';\n              if (local_68 == (char *)0x0) goto LAB_0018c110;\n              if (*local_68 == '\\0') {\n                err_badarraysub(pcVar12);\n                sh_xfree(local_68,\"arrayfunc.c\",0x32f);\n                goto LAB_0018bf11;\n              }\n              uVar4 = *(uint *)(param_1 + 5);\n              cVar9 = *pcVar1;\n              goto LAB_0018c408;\n            }\n            pcVar6 = pcVar12 + lVar13 + 2;\n            uVar15 = 0;\n            lVar14 = local_70;\n            if (cVar9 != '+') goto LAB_0018bf4d;\nLAB_0018c1ea:\n            if (*pcVar6 == '=') {\n              pcVar6 = pcVar12 + lVar13 + 3;\n              uVar11 = uVar10 | 1;\n            }\n          }\n          else {\n            if ((uVar4 & 4) == 0) goto LAB_0018c1d0;\n            lVar5 = array_expand_index(param_1,pcVar12 + 1,lVar13,0);\n            if ((lVar5 < 0) &&\n               (lVar5 = lVar5 + 1 + *(long *)param_1[1], local_70 = lVar5, lVar5 < 0))\n            goto LAB_0018c110;\n            uVar4 = *(uint *)(param_1 + 5);\n            cVar9 = *pcVar1;\n            local_70 = lVar5;\nLAB_0018c408:\n            uVar15 = uVar4 & 0x40;\n            pcVar6 = pcVar12 + lVar13 + 2;\n            if (cVar9 == '+') goto LAB_0018c1ea;\n          }\n          lVar14 = local_70;\n          if (uVar15 == 0) goto LAB_0018bf4d;\n          pcVar6 = (char *)expand_subscript_string(pcVar6,0);\n          if (pcVar6 == (char *)0x0) {\n            pcVar6 = (char *)sh_xmalloc(1,\"arrayfunc.c\",0x350);\n            *pcVar6 = '\\0';\n          }\n          uVar4 = *(uint *)(param_1 + 5);\n          uVar15 = 1;\n          uVar16 = this_command_name;\n          if ((uVar4 & 0x10) != 0) goto LAB_0018bedb;\n          goto LAB_0018bee6;\n        }\n      }\n      else {\nLAB_0018c061:\n        if ((*(byte *)(param_1 + 5) & 0x40) == 0) {\n          lVar5 = make_variable_value(param_1,pcVar12,param_3);\n          if ((code *)param_1[4] == (code *)0x0) {\n            array_insert(local_40,lVar14,lVar5);\n          }\n          else {\n            (*(code *)param_1[4])(param_1,lVar5,lVar14);\n          }\n          if (lVar5 != 0) {\n            sh_xfree(lVar5,\"arrayfunc.c\",0x305);\n          }\n          lVar14 = lVar14 + 1;\n          goto LAB_0018bf11;\n        }\n      }\nLAB_0018c110:\n      err_badarraysub(pcVar12);\nLAB_0018bf11:\n      param_2 = (undefined8 *)*param_2;\n    }\n    if (param_2 == (undefined8 *)0x0) break;\n    uVar4 = *(uint *)((char **)param_2[1] + 1);\n    pcVar12 = *(char **)param_2[1];\n  } while( true );\n  uVar4 = *(uint *)(param_1 + 5);\nLAB_0018bfab:\n  if ((uVar4 & 0x40) == 0) {\n    return;\n  }\nLAB_0018bfaf:\n  if ((local_60 != (long *)0x0) && (local_48 != local_60)) {\n    uVar16 = param_1[1];\n    param_1[1] = local_60;\n    assoc_dispose(uVar16);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_0014f110": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nbool FUN_0014f110(long param_1,int param_2,int param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  size_t sVar4;\n  char *__dest;\n  long lVar5;\n  uint uVar6;\n  long in_FS_OFFSET;\n  bool bVar7;\n  int local_158;\n  int local_154;\n  int local_150;\n  int local_14c;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00238428 != -1) {\n    if (-1 < (int)(DAT_0023842c & DAT_00238430)) {\n      internal_warning(\"execute_coproc: coproc [%d:%s] still exists\",_DAT_00238428 & 0xffffffff,\n                       sh_coproc);\n    }\n  }\n  _DAT_00238428 = 0xffffffffffffffff;\n  _DAT_00238438 = 0xffffffff;\n  _DAT_00238430 = 0xffffffffffffffff;\n  _DAT_00238440 = 0;\n  sh_coproc = 0;\n  uVar6 = *(uint *)(param_1 + 4);\n  uVar2 = expand_string_unsplit_to_string(*(undefined8 *)(*(long *)(param_1 + 0x18) + 8),0);\n  uVar6 = uVar6 & 4;\n  iVar1 = legal_identifier(uVar2);\n  if (iVar1 == 0) {\n    internal_error(\"`%s\\': not a valid identifier\",uVar2);\n    sh_xfree(uVar2,\"execute_cmd.c\",0x963);\n    bVar7 = uVar6 == 0;\n  }\n  else {\n    sh_xfree(*(undefined8 *)(*(long *)(param_1 + 0x18) + 8),\"execute_cmd.c\",0x968);\n    command_string_index = 0;\n    *(undefined8 *)(*(long *)(param_1 + 0x18) + 8) = uVar2;\n    pcVar3 = (char *)make_command_string(param_1);\n    sh_openpipe(&local_158);\n    sh_openpipe(&local_150);\n    sigemptyset(&local_148);\n    sigaddset(&local_148,0x11);\n    sigemptyset(&local_c8);\n    sigprocmask(0,&local_148,&local_c8);\n    sVar4 = strlen(pcVar3);\n    __dest = (char *)sh_xmalloc(sVar4 + 1,\"execute_cmd.c\",0x974);\n    pcVar3 = strcpy(__dest,pcVar3);\n    iVar1 = make_child(pcVar3,1);\n    if (iVar1 == 0) {\n      close(local_158);\n      close(local_14c);\n      sh_xfree(pcVar3,\"execute_cmd.c\",0x97c);\n      sigprocmask(2,&local_c8,(sigset_t *)0x0);\n      iVar1 = FUN_0014eab0(param_1,1,local_150,local_154,param_4);\n      fflush(stdout);\n      fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n      exit(iVar1);\n    }\n    close(local_154);\n    close(local_150);\n    lVar5 = coproc_alloc(*(undefined8 *)(*(long *)(param_1 + 0x18) + 8),iVar1);\n    *(int *)(lVar5 + 0xc) = local_158;\n    *(uint *)(lVar5 + 0x1c) = *(uint *)(lVar5 + 0x1c) | 1;\n    *(int *)(lVar5 + 0x10) = local_14c;\n    fcntl(local_158,2,1);\n    fcntl(*(int *)(lVar5 + 0x10),2,1);\n    coproc_setvars(lVar5);\n    sigprocmask(2,&local_c8,(sigset_t *)0x0);\n    if (-1 < param_2) {\n      close(param_2);\n    }\n    if (-1 < param_3) {\n      close(param_3);\n    }\n    unlink_fifo_list();\n    stop_pipeline(1,0);\n    if (interactive != 0) {\n      describe_pid(iVar1);\n    }\n    bVar7 = uVar6 != 0;\n    run_pending_traps();\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return bVar7;\n}\n\n",
  "trim_pathname": "\nundefined2 * trim_pathname(undefined2 *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  size_t sVar3;\n  char *pcVar4;\n  undefined2 *puVar5;\n  undefined2 *puVar6;\n  long lVar7;\n  long in_FS_OFFSET;\n  long local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 != (undefined2 *)0x0) {\n    sVar3 = strlen((char *)param_1);\n    if ((((int)sVar3 != 0) &&\n        (pcVar4 = (char *)get_string_value(\"PROMPT_DIRTRIM\"), pcVar4 != (char *)0x0)) &&\n       (*pcVar4 != '\\0')) {\n      local_28 = 0;\n      iVar2 = FUN_001411c0(pcVar4,&local_28);\n      if ((iVar2 != 0) && (0 < local_28)) {\n        cVar1 = *(char *)param_1;\n        puVar5 = param_1;\n        puVar6 = param_1;\n        if (cVar1 == '~') {\n          do {\n            puVar6 = puVar5;\n            if (*(char *)((long)puVar6 + 1) == '\\0') goto LAB_001422b0;\n            puVar5 = (undefined2 *)((long)puVar6 + 1);\n          } while (*(char *)((long)puVar6 + 1) != '/');\n          cVar1 = *(char *)(puVar6 + 1);\n          puVar6 = puVar6 + 1;\n        }\n        if (cVar1 != '\\0') {\n          iVar2 = 0;\n          puVar5 = puVar6;\n          do {\n            puVar5 = (undefined2 *)((long)puVar5 + 1);\n            iVar2 = iVar2 + (uint)(cVar1 == '/');\n            cVar1 = *(char *)puVar5;\n          } while (cVar1 != '\\0');\n          if (local_28 <= iVar2) {\n            pcVar4 = (char *)((long)(int)sVar3 + (long)param_1);\n            puVar5 = (undefined2 *)(pcVar4 + -(ulong)(*pcVar4 != '/'));\n            lVar7 = local_28;\n            if (puVar6 < puVar5) {\n              do {\n                if ((*(char *)puVar5 == '/') && (lVar7 = lVar7 + -1, lVar7 == 0)) {\n                  local_28 = 0;\n                  goto LAB_00142380;\n                }\n                puVar5 = (undefined2 *)((long)puVar5 + -1);\n              } while (puVar6 != puVar5);\n            }\n            else {\nLAB_00142380:\n              if ((puVar6 != puVar5) && (3 < (int)puVar5 - (int)puVar6)) {\n                *(undefined *)(puVar6 + 1) = 0x2e;\n                *puVar6 = 0x2e2e;\n                sVar3 = (size_t)((int)pcVar4 - (int)puVar5);\n                memmove((void *)((long)puVar6 + 3),puVar5,sVar3);\n                *(undefined *)((long)puVar6 + sVar3 + 3) = 0;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_001422b0:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return param_1;\n}\n\n",
  "reap_procsubs": "\nvoid reap_procsubs(void)\n\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  \n  iVar1 = DAT_00247830;\n  if ((0 < DAT_00247834) && (lVar3 = 0, lVar2 = DAT_00247838, 0 < DAT_00247830)) {\n    do {\n      if (*(int *)(lVar2 + lVar3 * 4) == -1) {\n        close((int)lVar3);\n        lVar2 = DAT_00247838;\n        DAT_00247834 = DAT_00247834 + -1;\n        *(undefined4 *)(DAT_00247838 + lVar3 * 4) = 0;\n      }\n    } while (((int)lVar3 + 1 < iVar1) && (lVar3 = lVar3 + 1, 0 < DAT_00247834));\n  }\n  return;\n}\n\n",
  "read_octal": "\nint read_octal(long param_1)\n\n{\n  byte bVar1;\n  long lVar2;\n  int iVar3;\n  \n  lVar2 = 0;\n  iVar3 = 0;\n  while( true ) {\n    bVar1 = *(char *)(param_1 + lVar2) - 0x30;\n    if (7 < bVar1) break;\n    lVar2 = lVar2 + 1;\n    iVar3 = (int)(char)bVar1 + iVar3 * 8;\n    if (0xfff < iVar3) {\n      return -1;\n    }\n  }\n  if (*(char *)(param_1 + lVar2) != '\\0') {\n    return -1;\n  }\n  if ((int)lVar2 == 0) {\n    return -1;\n  }\n  return iVar3;\n}\n\n",
  "set_working_directory": "\nvoid set_working_directory(char *param_1)\n\n{\n  size_t sVar1;\n  char *__dest;\n  \n  if (the_current_working_directory != (char *)0x0) {\n    sh_xfree(the_current_working_directory,\"common.c\",0x291);\n  }\n  sVar1 = strlen(param_1);\n  __dest = (char *)sh_xmalloc(sVar1 + 1,\"common.c\",0x292);\n  the_current_working_directory = strcpy(__dest,param_1);\n  return;\n}\n\n",
  "endservent": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid endservent(void)\n\n{\n  (*(code *)PTR_endservent_00237db8)();\n  return;\n}\n\n",
  "rl_untranslate_keyseq": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined1 * rl_untranslate_keyseq(uint param_1)\n\n{\n  ushort uVar1;\n  ushort *puVar2;\n  long lVar3;\n  ushort **ppuVar4;\n  __int32_t **pp_Var5;\n  undefined uVar6;\n  int iVar7;\n  ulong uVar8;\n  long lVar9;\n  \n  if (param_1 - 0x80 < 0x80) {\n    DAT_0024a782 = 0x2d;\n    param_1 = param_1 & 0xffffff7f;\n    _DAT_0024a780 = 0x4d5c;\n    goto LAB_001dbeea;\n  }\n  if (param_1 == 0x1b) {\n    uVar6 = 0x65;\n    iVar7 = 2;\n    _DAT_0024a780 = CONCAT11(DAT_0024a781,0x5c);\n    lVar3 = 1;\n    goto LAB_001dbf38;\n  }\n  if ((int)param_1 < 0x20) {\n    if ((param_1 & 0x80) != 0) {\n      uVar6 = (undefined)param_1;\n      iVar7 = 1;\n      lVar3 = 0;\n      goto LAB_001dbf38;\n    }\n    _DAT_0024a780 = 0x435c;\n    DAT_0024a782 = 0x2d;\n    ppuVar4 = __ctype_b_loc();\n    puVar2 = *ppuVar4;\n    uVar8 = (ulong)(param_1 & 0xff | 0x40);\n    uVar1 = puVar2[uVar8];\n    if ((uVar1 & 0x200) == 0) {\n      if ((uVar1 & 0x100) != 0) goto LAB_001dbfbd;\n      param_1 = param_1 | 0x40;\n    }\n    else {\n      pp_Var5 = __ctype_toupper_loc();\n      param_1 = (*pp_Var5)[uVar8];\n      uVar8 = (ulong)param_1 & 0xff;\n      if ((*(byte *)((long)puVar2 + uVar8 * 2 + 1) & 1) != 0) {\nLAB_001dbfbd:\n        pp_Var5 = __ctype_tolower_loc();\n        param_1 = (*pp_Var5)[uVar8];\n      }\n    }\nLAB_001dbeea:\n    lVar3 = 4;\n    lVar9 = 3;\n    if (param_1 == 0x1b) {\n      DAT_0024a783 = 0x5c;\n      uVar6 = 0x65;\n      iVar7 = 5;\n      goto LAB_001dbf38;\n    }\n  }\n  else {\n    if (param_1 == 0x7f) {\n      uVar6 = 0x3f;\n      DAT_0024a782 = 0x2d;\n      iVar7 = 4;\n      _DAT_0024a780 = 0x435c;\n      lVar3 = 3;\n      goto LAB_001dbf38;\n    }\n    lVar3 = 1;\n    lVar9 = 0;\n  }\n  uVar6 = (undefined)param_1;\n  iVar7 = (int)lVar3;\n  if ((param_1 == 0x5c) || (param_1 == 0x22)) {\n    iVar7 = iVar7 + 1;\n    (&DAT_0024a780)[lVar9] = 0x5c;\n  }\n  else {\n    lVar3 = (long)(int)lVar9;\n  }\nLAB_001dbf38:\n  (&DAT_0024a780)[lVar3] = uVar6;\n  (&DAT_0024a780)[iVar7] = 0;\n  return &DAT_0024a780;\n}\n\n",
  "_rl_to_upper": "\nuint _rl_to_upper(uint param_1)\n\n{\n  ushort **ppuVar1;\n  __int32_t **pp_Var2;\n  \n  ppuVar1 = __ctype_b_loc();\n  if ((*(byte *)((long)*ppuVar1 + (ulong)(param_1 & 0xff) * 2 + 1) & 2) != 0) {\n    pp_Var2 = __ctype_toupper_loc();\n    param_1 = (*pp_Var2)[param_1 & 0xff];\n  }\n  return param_1;\n}\n\n",
  "strncasecmp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncasecmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strncasecmp_00237be0)();\n  return iVar1;\n}\n\n",
  "assoc_quote": "\nlong * assoc_quote(long *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long lVar3;\n  \n  if (param_1 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  if (*(int *)((long)param_1 + 0xc) == 0) {\n    return (long *)0x0;\n  }\n  lVar3 = 0;\n  if (0 < *(int *)(param_1 + 1)) {\n    do {\n      for (puVar1 = *(undefined8 **)(*param_1 + lVar3 * 8); puVar1 != (undefined8 *)0x0;\n          puVar1 = (undefined8 *)*puVar1) {\n        uVar2 = quote_string(puVar1[2]);\n        if (puVar1[2] != 0) {\n          sh_xfree(puVar1[2],\"assoc.c\",0xa0);\n        }\n        puVar1[2] = uVar2;\n      }\n      lVar3 = lVar3 + 1;\n    } while (*(int *)(param_1 + 1) != (int)lVar3 && (int)lVar3 <= *(int *)(param_1 + 1));\n  }\n  return param_1;\n}\n\n",
  "setenv": "\nint setenv(char *__name,char *__value,int __replace)\n\n{\n  int iVar1;\n  char *pcVar2;\n  long lVar3;\n  int *piVar4;\n  \n  if (((__name == (char *)0x0) || (*__name == '\\0')) ||\n     (pcVar2 = strchr(__name,0x3d), pcVar2 != (char *)0x0)) {\n    piVar4 = __errno_location();\n    *piVar4 = 0x16;\n    iVar1 = -1;\n  }\n  else if (((__replace == 0) && (lVar3 = find_variable(__name), lVar3 != 0)) ||\n          (lVar3 = bind_variable(__name,__value,0), lVar3 != 0)) {\n    *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) & 0xffffefff | 1;\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = -1;\n  }\n  return iVar1;\n}\n\n",
  "merge_function_temporary_env": "\nvoid merge_function_temporary_env(void)\n\n{\n  if (temporary_env != 0) {\n    FUN_00159fb0(FUN_00156420);\n    return;\n  }\n  return;\n}\n\n",
  "execute_command_internal": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nulong execute_command_internal\n                (ulong **param_1,ulong param_2,ulong param_3,ulong param_4,ulong **param_5)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  uint uVar3;\n  long **pplVar4;\n  ulong **ppuVar5;\n  uint uVar6;\n  int iVar7;\n  uint uVar8;\n  int iVar9;\n  uint uVar10;\n  int iVar11;\n  undefined4 uVar12;\n  char *pcVar13;\n  size_t sVar14;\n  char *pcVar15;\n  ulong uVar16;\n  ulong **ppuVar17;\n  undefined *puVar18;\n  long **pplVar19;\n  ulong **ppuVar20;\n  undefined *puVar21;\n  long lVar22;\n  long *plVar23;\n  undefined8 *puVar24;\n  code *pcVar25;\n  long lVar26;\n  undefined8 uVar27;\n  long **pplVar28;\n  uint uVar29;\n  long **pplVar30;\n  undefined8 *puVar31;\n  undefined8 *puVar32;\n  undefined8 *puVar33;\n  ulong *puVar34;\n  undefined8 *puVar35;\n  undefined8 *puVar36;\n  long *plVar37;\n  char **ppcVar38;\n  undefined4 uVar39;\n  ulong *puVar40;\n  uint uVar41;\n  ulong **ppuVar42;\n  uint __fd;\n  long in_FS_OFFSET;\n  undefined uVar43;\n  bool bVar44;\n  byte bVar45;\n  ulong uStack_118;\n  ulong **ppuStack_110;\n  ulong **local_108;\n  ulong **ppuStack_100;\n  undefined8 local_f8;\n  undefined8 local_f0;\n  undefined8 local_e8;\n  undefined8 local_e0;\n  undefined8 local_d8;\n  ulong **local_d0;\n  ulong **local_c8;\n  undefined8 local_c0;\n  long local_b8;\n  ulong local_b0;\n  undefined8 local_a8;\n  ulong *local_a0;\n  uint local_98;\n  uint local_94;\n  undefined8 local_90;\n  long **local_88;\n  undefined8 local_80;\n  undefined *local_78;\n  uint local_70;\n  uint local_6c;\n  uint local_60;\n  undefined4 local_5c;\n  undefined local_58 [4];\n  int local_54;\n  undefined4 local_50;\n  uint local_4c;\n  ulong local_48;\n  long local_40;\n  \n  puVar33 = &local_f8;\n  puVar32 = &local_f8;\n  puVar35 = &local_f8;\n  puVar34 = &local_f8;\n  puVar36 = &local_f8;\n  puVar24 = &local_f8;\n  local_f8 = param_5;\n  ppuVar20 = (ulong **)(ulong)breaking;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  puVar31 = &local_f8;\n  uVar6 = last_command_exit_value;\n  if (breaking == 0) {\n    param_2 = param_2 & 0xffffffff;\n    puVar18 = (undefined *)(param_3 & 0xffffffff);\n    param_4 = param_4 & 0xffffffff;\n    uVar41 = (uint)param_4;\n    do {\n      puVar31 = &local_f8;\n      uVar6 = last_command_exit_value;\n      if (((continuing != 0) || (puVar31 = &local_f8, read_but_dont_execute != 0)) ||\n         (uVar6 = 0, puVar31 = &local_f8, param_1 == (ulong **)0x0)) break;\n      if (terminating_signal != 0) {\n        ppuStack_100 = (ulong **)0x14b4bb;\n        termsig_handler(terminating_signal);\n      }\n      if (interrupt_state != 0) {\n        ppuStack_100 = (ulong **)0x14b4ce;\n        throw_to_top_level();\n      }\n      ppuStack_100 = (ulong **)0x14b369;\n      run_pending_traps();\n      uVar10 = *(uint *)((long)param_1 + 4);\n      uVar29 = uVar10 & 4;\n      uVar43 = uVar29 != 0;\n      DAT_00242178 = param_1;\n      if ((exit_immediately_on_error != 0) && ((bool)uVar43)) {\n        *(uint *)((long)param_1 + 4) = uVar10 | 8;\n      }\n      uVar8 = breaking;\n      iVar11 = (int)param_2;\n      __fd = (uint)puVar18;\n      if (((ulong)*param_1 & 0x40ffffffff) == 0x400000000d) {\n        if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n          uVar16 = FUN_0014eab0(param_1,param_2,puVar18,param_4,local_f8);\n          return uVar16;\n        }\n        goto LAB_0014cbbb;\n      }\n      uVar2 = *(uint *)param_1;\n      if (uVar2 == 0xe) {\n        ppuStack_100 = (ulong **)0x14b672;\n        last_command_exit_value = FUN_0014f110(param_1,puVar18,param_4,local_f8);\n        puVar31 = &local_f8;\n        uVar6 = last_command_exit_value;\n        break;\n      }\n      if (uVar2 == 0xd) {\n        local_60 = line_number;\n        line_number = *(uint *)((long)param_1[3] + 4);\n        ppuStack_100 = (ulong **)0x14b6a4;\n        iVar7 = signal_in_progress(0x42);\n        local_e8 = (ulong **)CONCAT71(local_e8._1_7_,iVar11 != 0);\n        if ((iVar7 == 0) && (running_trap != 0x43)) {\n          line_number_for_err_trap = line_number;\n        }\n        ppuStack_100 = (ulong **)0x14b6cc;\n        pcVar13 = (char *)make_command_string(param_1);\n        ppuStack_100 = (ulong **)0x14b6d7;\n        sVar14 = strlen(pcVar13);\n        local_f0 = \"execute_cmd.c\";\n        ppuStack_100 = (ulong **)0x14b6f4;\n        pcVar15 = (char *)sh_xmalloc(sVar14 + 1,\"execute_cmd.c\",0x28e);\n        ppuStack_100 = (ulong **)0x14b6ff;\n        local_d0 = (ulong **)strcpy(pcVar15,pcVar13);\n        ppuStack_100 = (ulong **)0x14b711;\n        iVar7 = make_child(local_d0,(ulong)local_e8 & 0xff);\nLAB_0014b713:\n        ppuStack_100 = (ulong **)0x14b71d;\n        iVar9 = signal_is_trapped(0x42);\n        if (iVar9 != 0) {\n          ppuStack_100 = (ulong **)0x14c6fb;\n          uVar10 = signal_in_progress(0x41);\n          if ((uVar10 | running_trap) == 0) {\n            if (the_printed_command_except_trap != (ulong **)0x0) {\n              ppuStack_100 = (ulong **)0x14c722;\n              sh_xfree(the_printed_command_except_trap,local_f0,0x293);\n            }\n            local_e8 = the_printed_command;\n            ppuStack_100 = (ulong **)0x14c736;\n            sVar14 = strlen((char *)the_printed_command);\n            ppuStack_100 = (ulong **)0x14c749;\n            pcVar13 = (char *)sh_xmalloc(sVar14 + 1,local_f0,0x294);\n            ppuStack_100 = (ulong **)0x14c756;\n            the_printed_command_except_trap = (ulong **)strcpy(pcVar13,(char *)local_e8);\n          }\n        }\n        uVar12 = 1;\n        if (iVar7 == 0) {\n          ppuStack_100 = (ulong **)0x14b747;\n          sh_xfree(local_d0,local_f0,0x29a);\nLAB_0014b747:\n          ppuStack_100 = (ulong **)0x14b75b;\n          last_command_exit_value = FUN_0014eab0(param_1,param_2,puVar18,param_4,local_f8);\nLAB_0014b761:\n                    /* WARNING: Subroutine does not return */\n          ppuStack_100 = (ulong **)0x14b76c;\n          sh_exit(last_command_exit_value);\n        }\nLAB_0014b56f:\n        if (-1 < (int)__fd) {\n          local_f8 = (ulong **)CONCAT44(local_f8._4_4_,uVar12);\n          ppuStack_100 = (ulong **)0x14b580;\n          close(__fd);\n          uVar12 = SUB84(local_f8,0);\n        }\n        if ((int)uVar41 < 0) {\n          if (variable_context == 0) goto LAB_0014c61e;\n        }\n        else {\n          local_f8 = (ulong **)CONCAT44(local_f8._4_4_,uVar12);\n          ppuStack_100 = (ulong **)0x14c60c;\n          close(uVar41);\n          uVar12 = SUB84(local_f8,0);\n          puVar31 = &local_f8;\n          if (variable_context != 0) break;\nLAB_0014c61e:\n          local_f8 = (ulong **)CONCAT44(local_f8._4_4_,uVar12);\n          ppuStack_100 = (ulong **)0x14c627;\n          unlink_fifo_list();\n          uVar12 = SUB84(local_f8,0);\n        }\n        local_f8 = (ulong **)CONCAT44(local_f8._4_4_,uVar12);\n        puVar31 = &local_f8;\n        if (uVar41 != 0xffffffff) break;\n        ppuStack_100 = (ulong **)0x14b5b2;\n        stop_pipeline(param_2,0);\n        line_number = local_60;\n        if (iVar11 == 0) {\n          ppuStack_100 = (ulong **)0x14b5d1;\n          iVar11 = signal_is_trapped(0x42);\n          if (iVar11 == 0) {\n            uVar6 = *(uint *)((long)param_1 + 4);\n            uVar8 = uVar6 & 8;\n            ppuStack_100 = (ulong **)0x14b5fa;\n            uVar29 = wait_for(iVar7,0);\n            if ((uVar6 & 4) != 0) {\n              last_command_exit_value = (uint)(uVar29 == 0);\n              puVar31 = &local_f8;\n              uVar6 = last_command_exit_value;\n              break;\n            }\n            uVar10 = 0;\n            last_command_exit_value = uVar29;\n          }\n          else {\n            ppuStack_100 = (ulong **)0x14c9e7;\n            iVar11 = signal_is_ignored(0x42);\n            uVar41 = *(uint *)((long)param_1 + 4);\n            ppuStack_100 = (ulong **)0x14ca00;\n            uVar29 = wait_for(iVar7,0);\n            uVar10 = uVar41 & 4;\n            uVar8 = uVar41 & 8;\n            if (uVar10 == 0) {\n              last_command_exit_value = uVar29;\n              if (((uint)local_f8 & iVar11 == 0) == 0) goto LAB_0014ca2f;\n            }\n            else {\n              last_command_exit_value = (uint)(uVar29 == 0);\n              puVar31 = &local_f8;\n              uVar6 = last_command_exit_value;\n              if (((uint)local_f8 & iVar11 == 0) == 0) break;\n            }\n            uVar29 = last_command_exit_value;\n            if (((uVar41 & 0xc) == 0) && (last_command_exit_value != 0)) {\n              local_60 = line_number;\n              line_number = line_number_for_err_trap;\n              ppuStack_100 = (ulong **)0x14cbe2;\n              run_error_trap();\n              line_number = local_60;\n            }\n          }\nLAB_0014ca2f:\n          puVar31 = &local_f8;\n          uVar6 = last_command_exit_value;\n          if ((((uVar10 | uVar8) == 0) && (puVar31 = &local_f8, (uint)local_f8 != 0)) &&\n             (puVar31 = &local_f8, exit_immediately_on_error != 0)) {\njoined_r0x0014ca51:\n            puVar31 = &local_f8;\n            uVar6 = last_command_exit_value;\n            if (uVar29 != 0) {\nLAB_0014c7fc:\n              last_command_exit_value = uVar6;\n              ppuStack_100 = (ulong **)0x14c801;\n              run_pending_traps();\n                    /* WARNING: Subroutine does not return */\n              ppuStack_100 = (ulong **)0x14c80b;\n              jump_to_top_level(4);\n            }\n          }\n        }\n        else {\n          if (interactive != 0) {\n            ppuStack_100 = (ulong **)0x14c9d5;\n            describe_pid(iVar7);\n          }\n          ppuStack_100 = (ulong **)0x14c8b3;\n          run_pending_traps();\n          last_command_exit_value = 0;\n          puVar31 = &local_f8;\n        }\n        break;\n      }\n      uVar3 = *(uint *)((long)param_1 + 4);\n      if ((uVar3 & 3) != 0) {\nLAB_0014b4eb:\n        local_60 = line_number;\n        local_e8 = (ulong **)CONCAT71(local_e8._1_7_,iVar11 != 0);\n        local_d8 = (ulong **)(CONCAT44(local_d8._4_4_,uVar3) & 0xffffffff00000001);\n        ppuStack_100 = (ulong **)0x14b4fd;\n        pcVar13 = (char *)make_command_string(param_1);\n        ppuStack_100 = (ulong **)0x14b508;\n        sVar14 = strlen(pcVar13);\n        local_f0 = \"execute_cmd.c\";\n        ppuStack_100 = (ulong **)0x14b525;\n        pcVar15 = (char *)sh_xmalloc(sVar14 + 1,\"execute_cmd.c\",0x28e);\n        ppuStack_100 = (ulong **)0x14b530;\n        local_d0 = (ulong **)strcpy(pcVar15,pcVar13);\n        local_e0 = (long **)CONCAT71(local_e0._1_7_,(char)local_e8);\n        ppuStack_100 = (ulong **)0x14b54c;\n        local_e8 = local_d0;\n        iVar7 = make_child(local_d0);\n        ppuVar20 = local_e8;\n        if ((uint)local_d8 != 0) goto LAB_0014b713;\n        uVar12 = 0;\n        if (iVar7 == 0) {\n          local_e8 = (ulong **)CONCAT71(local_e8._1_7_,(undefined)local_e0);\n          ppuStack_100 = (ulong **)0x14c51c;\n          sh_xfree(ppuVar20,local_f0,0x29a);\n          if (*(int *)param_1 == 9) {\n            if (((uVar41 & __fd) == 0xffffffff) && ((char)local_e8 != '\\0')) {\n              ppuStack_100 = (ulong **)0x14caaa;\n              last_command_exit_value = FUN_0014eab0(param_1,param_2,puVar18,param_4,local_f8);\n              uVar6 = 0;\nLAB_0014c575:\n              ppuVar20 = (ulong **)(ulong)uVar6;\n              ppuStack_100 = (ulong **)0x14c580;\n              subshell_exit(last_command_exit_value);\n              ppuVar17 = param_1;\n              goto LAB_0014c580;\n            }\n            bVar44 = (uVar41 & __fd) != 0xffffffff && iVar11 == 0;\n            uVar6 = (uint)bVar44;\n            ppuStack_100 = (ulong **)0x14c567;\n            last_command_exit_value = FUN_0014eab0(param_1,param_2,puVar18,param_4,local_f8);\n            if (bVar44) goto LAB_0014c575;\n            goto LAB_0014b761;\n          }\n          goto LAB_0014b747;\n        }\n        goto LAB_0014b56f;\n      }\n      if ((uVar2 < 0xd) && ((0x1fafUL >> ((ulong)uVar2 & 0x3f) & 1) != 0)) {\n        if (((uVar41 & __fd) != 0xffffffff) || (iVar11 != 0)) goto LAB_0014b4eb;\n        param_2 = (ulong)(uVar3 & 0x80);\n        if ((uVar3 & 0x80) == 0) goto LAB_0014b787;\nLAB_0014b411:\n        ppuStack_100 = (ulong **)0x14b423;\n        uVar6 = FUN_00150980(param_1,puVar18,param_4,local_f8);\n        DAT_00242178 = (ulong **)0x0;\n        puVar31 = &local_f8;\n        break;\n      }\n      if ((uVar3 & 0x80) == 0) {\n        if (uVar2 < 0xd) {\nLAB_0014b787:\n          if (((0x1fafUL >> ((ulong)uVar2 & 0x3f) & 1) != 0) && (param_1[2] != (ulong *)0x0)) {\n            local_e8 = (ulong **)CONCAT71(local_e8._1_7_,uVar43);\n            local_f0 = (char *)(CONCAT44(local_f0._4_4_,uVar10) & 0xffffffff00000004);\n            ppuStack_100 = (ulong **)0x14b7a8;\n            stdin_redir = stdin_redirects();\n            uVar29 = (uint)local_f0;\n            uVar43 = (char)local_e8;\n          }\n        }\n        uVar6 = (uint)param_2;\n        if ((variable_context | executing_list) == 0) {\n          local_54 = 0;\n        }\n        else {\n          local_e8 = (ulong **)CONCAT71(local_e8._1_7_,uVar43);\n          local_f0 = (char *)CONCAT44(local_f0._4_4_,uVar29);\n          ppuStack_100 = (ulong **)0x14c59f;\n          local_5c = num_fifos();\n          ppuStack_100 = (ulong **)0x14c5b3;\n          lVar22 = copy_fifo_list(local_58);\n          ppuStack_100 = (ulong **)0x14c5c7;\n          local_b8 = lVar22;\n          begin_unwind_frame(\"internal_fifos\");\n          uVar29 = (uint)local_f0;\n          uVar43 = (char)local_e8;\n          if (lVar22 != 0) {\n            ppuStack_100 = (ulong **)0x14c5e6;\n            add_unwind_protect(xfree,lVar22);\n            uVar29 = (uint)local_f0;\n            uVar43 = (char)local_e8;\n          }\n          local_54 = 1;\n        }\n        local_e8 = (ulong **)CONCAT71(local_e8._1_7_,uVar43);\n        local_f0 = (char *)CONCAT44(local_f0._4_4_,uVar29);\n        ppuStack_100 = (ulong **)0x14b7e6;\n        uVar10 = signal_is_trapped(0x42);\n        uVar12 = SUB84(local_f0,0);\n        uVar43 = SUB81(local_e8,0);\n        if (uVar10 != 0) {\n          ppuStack_100 = (ulong **)0x14c81c;\n          iVar11 = signal_is_ignored(0x42);\n          uVar43 = SUB81(local_e8,0);\n          uVar12 = SUB84(local_f0,0);\n          uVar10 = (uint)(iVar11 == 0);\n        }\n        local_e0 = (long **)CONCAT71(local_e0._1_7_,uVar43);\n        local_f0 = (char *)CONCAT44(local_f0._4_4_,uVar12);\n        local_d8 = (ulong **)\n                   (CONCAT44(local_d8._4_4_,*(undefined4 *)((long)param_1 + 4)) & 0xffffffff00000008\n                   );\n        ppuStack_100 = (ulong **)0x14b81a;\n        iVar11 = do_redirections(param_1[2],3);\n        ppuVar42 = redirection_undo_list;\n        ppuVar17 = exec_redirection_undo_list;\n        local_e8 = (ulong **)CONCAT44(local_e8._4_4_,iVar11);\n        if (iVar11 == 0) {\n          redirection_undo_list = (ulong **)0x0;\n          exec_redirection_undo_list = (ulong **)0x0;\n          local_d0 = ppuVar42;\n          local_b0 = (ulong)ppuVar42 | (ulong)ppuVar17;\n          local_c8 = ppuVar17;\n          local_98 = (uint)local_e0 & 0xff;\n          uVar10 = (uint)local_f0;\n          if (local_b0 != 0) {\n            ppuStack_100 = (ulong **)0x14c687;\n            begin_unwind_frame(\"loop_redirections\");\n            uVar10 = (uint)local_f0;\n            uVar16 = (ulong)local_e0 & 0xff;\n            if (local_d0 != (ulong **)0x0) {\n              ppuStack_100 = (ulong **)0x14c6b3;\n              add_unwind_protect(FUN_00147c70,local_d0);\n              uVar10 = (uint)local_f0;\n              uVar16 = (ulong)local_e0 & 0xff;\n              local_98 = (uint)uVar16;\n              if (local_c8 == (ulong **)0x0) goto LAB_0014b86b;\n            }\n            local_e0 = (long **)CONCAT71(local_e0._1_7_,(char)uVar16);\n            local_f0 = (char *)CONCAT44(local_f0._4_4_,uVar10);\n            ppuStack_100 = (ulong **)0x14c6e3;\n            add_unwind_protect(dispose_redirects,local_c8);\n            uVar10 = (uint)local_f0;\n            local_98 = (uint)local_e0 & 0xff;\n          }\nLAB_0014b86b:\n          if (terminating_signal != 0) {\n            local_e0 = (long **)CONCAT71(local_e0._1_7_,(char)local_98);\n            local_f0 = (char *)CONCAT44(local_f0._4_4_,uVar10);\n            ppuStack_100 = (ulong **)0x14c8f0;\n            termsig_handler(terminating_signal);\n            local_98 = (uint)local_e0 & 0xff;\n            uVar10 = (uint)local_f0;\n          }\n          if (interrupt_state != 0) {\n            local_e0 = (long **)CONCAT71(local_e0._1_7_,(char)local_98);\n            local_f0 = (char *)CONCAT44(local_f0._4_4_,uVar10);\n            ppuStack_100 = (ulong **)0x14c8cf;\n            throw_to_top_level();\n            local_98 = (uint)local_e0 & 0xff;\n            uVar10 = (uint)local_f0;\n          }\n          uVar29 = *(uint *)param_1;\n          if (0xc < uVar29) {\n            ppuStack_100 = (ulong **)0x14ca91;\n            command_error(\"execute_command\",1,uVar29,0);\n            puVar35 = &local_f8;\n            goto LAB_0014b978;\n          }\n          switch(uVar29) {\n          case 0:\n            puVar40 = param_1[3];\n            if ((uint)local_d8 != 0) {\n              *(uint *)puVar40 = *(uint *)puVar40 | 8;\n            }\n            local_f8 = (ulong **)CONCAT44(local_f8._4_4_,line_number);\n            ppuStack_100 = (ulong **)0x14c049;\n            iVar11 = check_identifier(puVar40[1],1);\n            if (iVar11 == 0) {\n              local_e8 = (ulong **)CONCAT44(local_e8._4_4_,1);\n              puVar35 = &local_f8;\n              if ((posixly_correct == 0) || (puVar35 = &local_f8, interactive_shell != 0))\n              goto LAB_0014b978;\n              last_command_exit_value = 2;\n              goto LAB_0014c07d;\n            }\n            loop_level = loop_level + 1;\n            pcVar13 = *(char **)puVar40[1];\n            line_number = *(uint *)((long)puVar40 + 4);\n            ppuStack_100 = (ulong **)0x14cc79;\n            plVar23 = (long *)expand_words_no_vars(puVar40[2]);\n            ppuStack_100 = (ulong **)0x14cc88;\n            begin_unwind_frame(&DAT_001fab48);\n            ppuStack_100 = (ulong **)0x14cc99;\n            add_unwind_protect(dispose_words,plVar23);\n            if ((*(byte *)puVar40 & 8) != 0) {\n              *(uint *)(puVar40[3] + 4) = *(uint *)(puVar40[3] + 4) | 8;\n            }\n            plVar37 = plVar23;\n            if (plVar23 != (long *)0x0) goto LAB_0014ce55;\n            goto LAB_0014d607;\n          case 1:\n            puVar40 = param_1[3];\n            if ((uint)local_d8 != 0) {\n              *(uint *)puVar40 = *(uint *)puVar40 | 8;\n            }\n            command_string_index = 0;\n            local_c0 = CONCAT44(local_c0._4_4_,line_number);\n            line_number = *(uint *)((long)puVar40 + 4);\n            ppuStack_100 = (ulong **)0x14be00;\n            print_case_command_head(puVar40);\n            if (echo_command_at_execute != 0) {\n              ppuStack_100 = (ulong **)0x14cc26;\n              xtrace_print_case_command_head(puVar40);\n            }\n            ppuStack_100 = (ulong **)0x14be18;\n            uVar6 = signal_in_progress(0x41);\n            if ((uVar6 | running_trap) == 0) {\n              local_f0 = \"execute_cmd.c\";\n              if (the_printed_command_except_trap != (ulong **)0x0) {\n                ppuStack_100 = (ulong **)0x14be45;\n                sh_xfree(the_printed_command_except_trap,\"execute_cmd.c\",0xde3);\n              }\n              ppuVar20 = the_printed_command;\n              ppuStack_100 = (ulong **)0x14be54;\n              sVar14 = strlen((char *)the_printed_command);\n              ppuStack_100 = (ulong **)0x14be67;\n              pcVar13 = (char *)sh_xmalloc(sVar14 + 1,local_f0,0xde4);\n              ppuStack_100 = (ulong **)0x14be72;\n              the_printed_command_except_trap = (ulong **)strcpy(pcVar13,(char *)ppuVar20);\n            }\n            ppuStack_100 = (ulong **)0x14be7e;\n            iVar11 = run_debug_trap();\n            if ((debugging_mode != 0) && (iVar11 != 0)) goto LAB_0014c664;\n            ppuStack_100 = (ulong **)0x14be9b;\n            lVar22 = expand_word_leave_quoted(puVar40[1],0);\n            if (lVar22 == 0) {\n              local_f0 = \"execute_cmd.c\";\n              ppuStack_100 = (ulong **)0x14d6c6;\n              puVar18 = (undefined *)sh_xmalloc(1,\"execute_cmd.c\",0xdff);\n              *puVar18 = 0;\n            }\n            else {\n              ppuStack_100 = (ulong **)0x14beaf;\n              uVar27 = string_list(lVar22);\n              ppuStack_100 = (ulong **)0x14beba;\n              puVar18 = (undefined *)dequote_string(uVar27);\n              local_f0 = \"execute_cmd.c\";\n              ppuStack_100 = (ulong **)0x14bed9;\n              sh_xfree(uVar27,\"execute_cmd.c\",0xdfc);\n            }\n            ppuStack_100 = (ulong **)0x14bee1;\n            dispose_words(lVar22);\n            local_e0 = (long **)(CONCAT44(local_e0._4_4_,*(uint *)puVar40) & 0xffffffff00000008);\n            ppuStack_100 = (ulong **)0x14bef6;\n            begin_unwind_frame(\"case\");\n            ppuStack_100 = (ulong **)0x14bf07;\n            add_unwind_protect(xfree,puVar18);\n            ppuVar42 = (ulong **)puVar40[2];\n            ppuVar5 = param_1;\n            ppuVar17 = (ulong **)local_f0;\n            ppuVar20 = local_d8;\n            goto joined_r0x0014bf0e;\n          case 2:\n            puVar40 = param_1[3];\n            if ((uint)local_d8 != 0) {\n              *(uint *)puVar40 = *(uint *)puVar40 | 8;\n            }\n            ppuStack_100 = (ulong **)0x14bdc3;\n            uVar12 = FUN_0014e920(puVar40,0);\n            local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar12);\n            puVar35 = &local_f8;\n            goto LAB_0014b978;\n          case 3:\n            puVar40 = param_1[3];\n            if ((uint)local_d8 != 0) {\n              *(uint *)puVar40 = *(uint *)puVar40 | 8;\n            }\n            uVar6 = line_number;\n            *(uint *)(puVar40[1] + 4) = *(uint *)(puVar40[1] + 4) | 8;\n            ppuStack_100 = (ulong **)0x14bd61;\n            iVar11 = execute_command();\n            line_number = uVar6;\n            if (iVar11 == 0) {\n              if (terminating_signal != 0) {\n                ppuStack_100 = (ulong **)0x14d6a3;\n                termsig_handler(terminating_signal);\n              }\n              if (interrupt_state != 0) {\n                ppuStack_100 = (ulong **)0x14d693;\n                throw_to_top_level();\n              }\n              uVar16 = puVar40[2];\n            }\n            else {\n              if (terminating_signal != 0) {\n                ppuStack_100 = (ulong **)0x14d65a;\n                termsig_handler(terminating_signal);\n              }\n              if (interrupt_state != 0) {\n                ppuStack_100 = (ulong **)0x14d64a;\n                throw_to_top_level();\n              }\n              uVar16 = puVar40[3];\n            }\n            if ((uVar16 != 0) && ((*(byte *)puVar40 & 8) != 0)) {\n              *(uint *)(uVar16 + 4) = *(uint *)(uVar16 + 4) | 8;\n            }\n            ppuStack_100 = (ulong **)0x14bda2;\n            uVar12 = execute_command();\n            local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar12);\n            puVar35 = &local_f8;\n            goto LAB_0014b978;\n          case 4:\n            goto switchD_0014b8a8_caseD_4;\n          case 5:\n            puVar40 = param_1[3];\n            if ((uint)local_d8 != 0) {\n              *(uint *)puVar40 = *(uint *)puVar40 | 8;\n            }\n            ppuStack_100 = (ulong **)0x14c24b;\n            iVar11 = check_identifier(puVar40[1],1);\n            if (iVar11 == 0) {\n              local_e8 = (ulong **)CONCAT44(local_e8._4_4_,1);\n              puVar35 = &local_f8;\n              goto LAB_0014b978;\n            }\n            command_string_index = 0;\n            local_e0 = (long **)CONCAT44(local_e0._4_4_,line_number);\n            line_number = *(uint *)((long)puVar40 + 4);\n            ppuStack_100 = (ulong **)0x14c279;\n            print_select_command_head(puVar40);\n            if (echo_command_at_execute != 0) {\n              ppuStack_100 = (ulong **)0x14d4fc;\n              xtrace_print_select_command_head(puVar40);\n            }\n            ppuStack_100 = (ulong **)0x14c290;\n            uVar6 = signal_in_progress(0x41);\n            if ((uVar6 | running_trap) == 0) {\n              local_f0 = \"execute_cmd.c\";\n              if (the_printed_command_except_trap != (ulong **)0x0) {\n                ppuStack_100 = (ulong **)0x14c2bd;\n                sh_xfree(the_printed_command_except_trap,\"execute_cmd.c\",0xd57);\n              }\n              ppuVar20 = the_printed_command;\n              ppuStack_100 = (ulong **)0x14c2cc;\n              sVar14 = strlen((char *)the_printed_command);\n              ppuStack_100 = (ulong **)0x14c2df;\n              pcVar13 = (char *)sh_xmalloc(sVar14 + 1,local_f0,0xd58);\n              ppuStack_100 = (ulong **)0x14c2ea;\n              the_printed_command_except_trap = (ulong **)strcpy(pcVar13,(char *)ppuVar20);\n            }\n            ppuStack_100 = (ulong **)0x14c2f6;\n            iVar11 = run_debug_trap();\n            if ((debugging_mode != 0) && (puVar35 = &local_f8, iVar11 != 0)) goto LAB_0014b978;\n            this_command_name = (undefined *)0x0;\n            loop_level = loop_level + 1;\n            local_c0 = *(ulong *)puVar40[1];\n            ppuStack_100 = (ulong **)0x14c32e;\n            pplVar19 = (long **)expand_words_no_vars(puVar40[2]);\n            ppuStack_100 = (ulong **)0x14c33b;\n            iVar11 = list_length(pplVar19);\n            local_d8 = (ulong **)CONCAT44(local_d8._4_4_,iVar11);\n            if (pplVar19 != (long **)0x0) {\n              if (iVar11 != 0) {\n                ppuStack_100 = (ulong **)0x14c35f;\n                begin_unwind_frame(\"select\");\n                ppuStack_100 = (ulong **)0x14c370;\n                add_unwind_protect(dispose_words,pplVar19);\n                if ((*(byte *)puVar40 & 8) != 0) {\n                  *(uint *)(puVar40[3] + 4) = *(uint *)(puVar40[3] + 4) | 8;\n                }\n                local_e8 = (ulong **)(long)(int)(uint)local_d8;\n                local_f0 = (char *)CONCAT44(local_f0._4_4_,1);\n                local_f8 = param_1;\n                goto LAB_0014c395;\n              }\n              if (pplVar19 != (long **)0x0) {\n                ppuStack_100 = (ulong **)0x14d50e;\n                dispose_words(pplVar19);\n              }\n            }\n            line_number = (uint)local_e0;\n            puVar35 = &local_f8;\n            goto LAB_0014b978;\n          case 6:\n            ppuStack_100 = (ulong **)0x14ba21;\n            uVar12 = FUN_001504d0(param_1,param_2,puVar18,param_4,local_f8);\n            uVar41 = 0;\n            if (uVar6 == 0) {\n              uVar41 = local_98;\n            }\n            local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar12);\n            local_98 = uVar41;\n            puVar35 = &local_f8;\n            goto LAB_0014b978;\n          default:\n            local_f8 = (ulong **)CONCAT44(local_f8._4_4_,uVar10);\n            ppuStack_100 = (ulong **)0x14b8b8;\n            iVar11 = signal_is_trapped(0x42);\n            uVar12 = SUB84(local_f8,0);\n            bVar45 = (byte)iVar11;\n            if (iVar11 != 0) {\n              ppuStack_100 = (ulong **)0x14cbae;\n              iVar11 = signal_is_ignored(0x42);\n              uVar12 = SUB84(local_f8,0);\n              bVar45 = iVar11 == 0;\n            }\n            line_number_for_err_trap = line_number;\n            iVar11 = *(int *)param_1;\n            if ((uint)local_d8 == 0) {\n              local_60 = line_number;\n              if (iVar11 == 10) {\n                puVar40 = param_1[3];\n                goto LAB_0014d67c;\n              }\n              if (iVar11 == 0xb) {\n                puVar40 = param_1[3];\n                goto LAB_0014b900;\n              }\nLAB_0014cb2c:\n              local_60 = line_number_for_err_trap;\n              if (iVar11 != 7) goto LAB_0014b978;\n              local_f8 = (ulong **)CONCAT44(local_f8._4_4_,uVar12);\n              ppuStack_100 = (ulong **)0x14dd19;\n              uVar6 = FUN_001495c0(param_1[3][1]);\n            }\n            else if (iVar11 == 10) {\n              puVar40 = param_1[3];\n              *(uint *)puVar40 = *(uint *)puVar40 | 8;\nLAB_0014d67c:\n              local_f8 = (ulong **)CONCAT44(local_f8._4_4_,uVar12);\n              ppuStack_100 = (ulong **)0x14d684;\n              local_60 = line_number_for_err_trap;\n              uVar6 = FUN_00148830(puVar40);\n            }\n            else {\n              if (iVar11 != 0xb) {\n                local_60 = line_number;\n                goto LAB_0014cb2c;\n              }\n              puVar40 = param_1[3];\n              *(uint *)puVar40 = *(uint *)puVar40 | 8;\nLAB_0014b900:\n              local_f8 = (ulong **)CONCAT44(local_f8._4_4_,uVar12);\n              ppuStack_100 = (ulong **)0x14b908;\n              local_60 = line_number_for_err_trap;\n              uVar6 = FUN_00149470(puVar40);\n            }\n            line_number = local_60;\n            if (((uint)local_f8 | (uint)local_d8) == 0) {\n              if ((bVar45 & 1) == 0) {\n                uVar41 = uVar6;\n                if (exit_immediately_on_error == 0) goto LAB_0014d65f;\n              }\n              else {\n                if (uVar6 == 0) {\n                  local_e8 = (ulong **)((ulong)local_e8._4_4_ << 0x20);\n                  puVar35 = &local_f8;\n                  goto LAB_0014b978;\n                }\n                line_number = line_number_for_err_trap;\n                ppuStack_100 = (ulong **)0x14b953;\n                last_command_exit_value = uVar6;\n                run_error_trap();\n                local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar6);\n                line_number = local_60;\n                uVar41 = exit_immediately_on_error;\n              }\n              puVar35 = &local_f8;\n              local_60 = line_number;\n              if (uVar41 != 0) goto LAB_0014c7fc;\n            }\n            else {\nLAB_0014d65f:\n              local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar6);\n              puVar35 = &local_f8;\n            }\n            goto LAB_0014b978;\n          case 8:\n            puVar40 = param_1[3];\n            if ((uint)local_d8 != 0) {\n              *(uint *)puVar40 = *(uint *)puVar40 | 8;\n            }\n            ppuStack_100 = (ulong **)0x14ba8c;\n            uVar12 = FUN_0014e920(puVar40,1);\n            local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar12);\n            puVar35 = &local_f8;\n            goto LAB_0014b978;\n          case 9:\n            if (uVar6 == 0) {\n              uVar16 = param_1[3][1];\n              if (((uint)local_d8 != 0) && (uVar16 != 0)) {\n                *(uint *)(uVar16 + 4) = *(uint *)(uVar16 + 4) | 8;\n              }\n              ppuStack_100 = (ulong **)0x14ba68;\n              uVar12 = execute_command_internal(uVar16,0,puVar18,param_4,local_f8);\n              local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar12);\n              puVar35 = &local_f8;\n            }\n            else {\n              *(uint *)((long)param_1 + 4) = *(uint *)((long)param_1 + 4) | 2;\n              ppuStack_100 = (ulong **)0x14cb99;\n              uVar12 = execute_command_internal(param_1,1,puVar18,param_4,local_f8);\n              local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar12);\n              puVar35 = &local_f8;\n            }\n            goto LAB_0014b978;\n          case 0xc:\n            puVar40 = param_1[3];\n            if ((uint)local_d8 != 0) {\n              *(uint *)puVar40 = *(uint *)puVar40 | 8;\n            }\n            uVar6 = line_number;\n            loop_level = loop_level + 1;\n            if ((*(byte *)puVar40 & 8) != 0) {\n              *(uint *)(puVar40[4] + 4) = *(uint *)(puVar40[4] + 4) | 8;\n            }\n            uVar41 = *(uint *)((long)puVar40 + 4);\n            this_command_name = &DAT_001fc775;\n            line_number = uVar41;\n            if (((variable_context != 0) && (interactive_shell != 0)) &&\n               ((sourcelevel == 0 &&\n                (line_number = (uVar41 - DAT_00242170) + 1, (int)line_number < 1)))) {\n              line_number = 1;\n            }\n            ppuStack_100 = (ulong **)0x14c11c;\n            FUN_00148690(puVar40[1],&local_48);\n            if ((int)local_48 == 0) {\n              local_e8 = (ulong **)CONCAT44(local_e8._4_4_,1);\n              puVar35 = &local_f8;\n              line_number = uVar6;\n              goto LAB_0014b978;\n            }\n            uVar12 = (uint)local_e8;\n            local_f8 = param_1;\n            goto LAB_0014c1bb;\n          }\n        }\n        uVar29 = (uint)local_f0;\n        if (redirection_undo_list != (ulong **)0x0) {\n          local_f8 = (ulong **)CONCAT44(local_f8._4_4_,(uint)local_f0);\n          ppuStack_100 = (ulong **)0x14c77e;\n          do_redirections(redirection_undo_list,1);\n          ppuStack_100 = (ulong **)0x14c786;\n          dispose_redirects(ppuVar42);\n          uVar29 = (uint)local_f8;\n          redirection_undo_list = (ulong **)0x0;\n        }\n        if (exec_redirection_undo_list != (ulong **)0x0) {\n          local_f8 = (ulong **)CONCAT44(local_f8._4_4_,uVar29);\n          ppuStack_100 = (ulong **)0x14c7a8;\n          dispose_redirects();\n          uVar29 = (uint)local_f8;\n          exec_redirection_undo_list = (ulong **)0x0;\n        }\n        if (local_54 != 0) {\n          local_f8 = (ulong **)CONCAT44(local_f8._4_4_,uVar29);\n          ppuStack_100 = (ulong **)0x14c9ba;\n          sh_xfree(local_b8,\"execute_cmd.c\",0x324);\n          ppuStack_100 = (ulong **)0x14c9c6;\n          discard_unwind_frame(\"internal_fifos\");\n          uVar29 = (uint)local_f8;\n        }\n        last_command_exit_value = 1;\n        puVar31 = &local_f8;\n        uVar6 = last_command_exit_value;\n        if (((uVar29 | (uint)local_d8) == 0) && (puVar31 = &local_f8, (__fd & uVar41) == 0xffffffff)\n           ) {\n          uVar29 = exit_immediately_on_error;\n          if (uVar10 != 0) {\n            local_60 = line_number;\n            line_number = line_number_for_err_trap;\n            ppuStack_100 = (ulong **)0x14cad3;\n            run_error_trap();\n            line_number = local_60;\n            uVar29 = exit_immediately_on_error;\n          }\n          goto joined_r0x0014ca51;\n        }\n        break;\n      }\n      if (iVar11 == 0) goto LAB_0014b411;\n      param_2 = 1;\n      *(uint *)((long)param_1 + 4) = uVar3 | 2;\n      puVar31 = &local_f8;\n      uVar6 = last_command_exit_value;\n    } while (uVar8 == 0);\n  }\n  goto LAB_0014b431;\nLAB_0014c1bb:\n  do {\n    ppuStack_100 = (ulong **)0x14c1cd;\n    line_number = uVar41;\n    lVar22 = FUN_00148690(puVar40[2],&local_48);\n    if ((int)local_48 == 0) break;\n    if ((job_control == 0) || (line_number = uVar6, interactive_shell == 0)) {\n      ppuStack_100 = (ulong **)0x14c205;\n      line_number = uVar6;\n      reap_dead_jobs();\n    }\n    if (lVar22 == 0) {\nLAB_0014d637:\n      local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar12);\n      goto LAB_0014cb60;\n    }\n    if (terminating_signal != 0) {\n      ppuStack_100 = (ulong **)0x14c227;\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      ppuStack_100 = (ulong **)0x14c99c;\n      throw_to_top_level();\n    }\n    ppuStack_100 = (ulong **)0x14c152;\n    uVar12 = execute_command(puVar40[4]);\n    if (terminating_signal != 0) {\n      ppuStack_100 = (ulong **)0x14c992;\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      ppuStack_100 = (ulong **)0x14c982;\n      throw_to_top_level();\n    }\n    if (breaking != 0) {\n      breaking = breaking - 1;\n      local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar12);\n      goto LAB_0014cb60;\n    }\n    if ((continuing != 0) && (continuing = continuing + -1, continuing != 0)) goto LAB_0014d637;\n    ppuStack_100 = (ulong **)0x14c1aa;\n    line_number = uVar41;\n    FUN_00148690(puVar40[3],&local_48);\n  } while ((int)local_48 != 0);\n  local_e8 = (ulong **)CONCAT44(local_e8._4_4_,1);\nLAB_0014cb60:\n  loop_level = loop_level + -1;\n  puVar35 = &local_f8;\n  param_1 = local_f8;\n  line_number = uVar6;\n  goto LAB_0014b978;\nLAB_0014c395:\n  line_number = *(uint *)((long)puVar40 + 4);\n  ppuStack_100 = (ulong **)0x14c3ab;\n  pcVar13 = (char *)get_string_value(&DAT_001fcad4);\n  if (pcVar13 == (char *)0x0) {\n    pcVar13 = \"#? \";\n  }\n  if (terminating_signal != 0) {\n    ppuStack_100 = (ulong **)0x14dad9;\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    ppuStack_100 = (ulong **)0x14dac9;\n    throw_to_top_level();\n  }\n  ppuStack_100 = (ulong **)0x14c3dd;\n  DAT_00242168 = default_columns();\n  iVar11 = 0;\n  DAT_00242164 = 8;\n  pplVar30 = pplVar19;\n  do {\n    ppuStack_100 = (ulong **)0x14c3fe;\n    iVar7 = FUN_00148aa0(*pplVar30[1]);\n    pplVar30 = (long **)*pplVar30;\n    if (iVar11 < iVar7) {\n      iVar11 = iVar7;\n    }\n  } while (pplVar30 != (long **)0x0);\n  iVar7 = 1;\n  if ((((9 < (int)(uint)local_d8) && (iVar7 = 2, 99 < (int)(uint)local_d8)) &&\n      (iVar7 = 3, 999 < (int)(uint)local_d8)) && (iVar7 = 4, 9999 < (int)(uint)local_d8)) {\n    iVar7 = (99999 < (int)(uint)local_d8) + 5;\n  }\n  if ((uint)local_f0 != 0) goto LAB_0014c4da;\n  while( true ) {\n    ppuStack_100 = (ulong **)0x14c464;\n    fputs(pcVar13,stderr);\n    ppuStack_100 = (ulong **)0x14c470;\n    fflush(stderr);\n    if (terminating_signal != 0) {\n      ppuStack_100 = (ulong **)0x14d89e;\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      ppuStack_100 = (ulong **)0x14d88e;\n      throw_to_top_level();\n    }\n    uVar12 = executing_builtin;\n    executing_builtin = 1;\n    local_f0 = (char *)CONCAT44(local_f0._4_4_,uVar12);\n    ppuStack_100 = (ulong **)0x14c4a7;\n    iVar9 = read_builtin(0);\n    executing_builtin = (uint)local_f0;\n    if (iVar9 != 0) {\n      ppuStack_100 = (ulong **)0x14d881;\n      putc(10,stdout);\n      ppuVar20 = (ulong **)0x0;\n      goto LAB_0014d77f;\n    }\n    ppuStack_100 = (ulong **)0x14c4c5;\n    ppuVar20 = (ulong **)get_string_value(\"REPLY\");\n    if (ppuVar20 == (ulong **)0x0) goto LAB_0014d77f;\n    if (*(char *)ppuVar20 != '\\0') break;\nLAB_0014c4da:\n    ppuStack_100 = (ulong **)0x14c4ec;\n    FUN_00148b90(pplVar19,(ulong)local_d8 & 0xffffffff,iVar11 + 4 + iVar7,iVar7);\n  }\n  ppuStack_100 = (ulong **)0x14daee;\n  iVar11 = legal_number(ppuVar20,&local_48);\n  if (((iVar11 == 0) || ((long)local_48 < 1)) ||\n     (uVar16 = local_48, pplVar30 = pplVar19, (long)local_e8 < (long)local_48)) {\n    ppuVar20 = (ulong **)&DAT_00213d70;\n  }\n  else {\n    while (uVar16 - 1 != 0) {\n      pplVar30 = (long **)*pplVar30;\n      uVar16 = uVar16 - 1;\n      if (pplVar30 == (long **)0x0) {\n        do {\n          invalidInstructionException();\n        } while( true );\n      }\n    }\n    ppuVar20 = (ulong **)*pplVar30[1];\n  }\nLAB_0014d77f:\n  if (terminating_signal != 0) {\n    ppuStack_100 = (ulong **)0x14d8c7;\n    local_f0 = (char *)ppuVar20;\n    termsig_handler(terminating_signal);\n    ppuVar20 = (ulong **)local_f0;\n  }\n  if (interrupt_state != 0) {\n    ppuStack_100 = (ulong **)0x14d8ad;\n    local_f0 = (char *)ppuVar20;\n    throw_to_top_level();\n    ppuVar20 = (ulong **)local_f0;\n  }\n  if (ppuVar20 != (ulong **)0x0) {\n    ppuStack_100 = (ulong **)0x14d7b3;\n    lVar22 = bind_variable(local_c0,ppuVar20,0);\n    param_1 = local_f8;\n    if (lVar22 == 0) {\nLAB_0014e0c4:\n      ppuStack_100 = (ulong **)0x14e0cc;\n      dispose_words(pplVar19);\n      ppuStack_100 = (ulong **)0x14e0d4;\n      discard_unwind_frame(\"select\");\n      loop_level = loop_level + -1;\n      local_e8 = (ulong **)CONCAT44(local_e8._4_4_,1);\n      line_number = (uint)local_e0;\n      puVar35 = &local_f8;\n      goto LAB_0014b978;\n    }\n    if ((*(uint *)(lVar22 + 0x28) & 0x4002) != 0) {\n      if ((((*(uint *)(lVar22 + 0x28) & 2) == 0) || (interactive_shell != 0)) ||\n         (posixly_correct == 0)) goto LAB_0014e0c4;\n      goto LAB_0014e079;\n    }\n    ppuStack_100 = (ulong **)0x14d7d4;\n    stupidly_hack_special_variables(local_c0);\n    ppuStack_100 = (ulong **)0x14d7dd;\n    uVar12 = execute_command(puVar40[3]);\n    if ((job_control == 0) || (interactive_shell == 0)) {\n      ppuStack_100 = (ulong **)0x14d7f6;\n      reap_dead_jobs();\n    }\n    if (terminating_signal != 0) {\n      ppuStack_100 = (ulong **)0x14d86e;\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      ppuStack_100 = (ulong **)0x14d861;\n      throw_to_top_level();\n    }\n    local_f0 = (char *)CONCAT44(local_f0._4_4_,breaking);\n    if (breaking != 0) {\n      breaking = breaking - 1;\n      goto LAB_0014e090;\n    }\n    if ((continuing != 0) && (continuing = continuing + -1, continuing != 0)) goto LAB_0014e090;\n    ppuStack_100 = (ulong **)0x14d841;\n    pcVar13 = (char *)get_string_value(\"REPLY\");\n    if (pcVar13 != (char *)0x0) {\n      local_f0 = (char *)CONCAT44(local_f0._4_4_,(uint)(*pcVar13 == '\\0'));\n    }\n    goto LAB_0014c395;\n  }\n  uVar12 = 1;\nLAB_0014e090:\n  param_1 = local_f8;\n  loop_level = loop_level + -1;\n  line_number = (uint)local_e0;\n  ppuStack_100 = (ulong **)0x14e0a9;\n  dispose_words(pplVar19);\n  ppuStack_100 = (ulong **)0x14e0b1;\n  discard_unwind_frame(\"select\");\n  local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar12);\n  puVar35 = &local_f8;\n  goto LAB_0014b978;\nswitchD_0014b8a8_caseD_4:\n  local_60 = line_number;\n  ppuStack_100 = (ulong **)0x14baac;\n  local_6c = signal_is_trapped(0x42);\n  if (local_6c != 0) {\n    ppuStack_100 = (ulong **)0x14cc45;\n    iVar11 = signal_is_ignored(0x42);\n    local_6c = (uint)(iVar11 == 0);\n  }\n  puVar40 = param_1[3];\n  if (((uint)local_d8 != 0) && (puVar40 != (ulong *)0x0)) {\n    *(uint *)puVar40 = *(uint *)puVar40 | 8;\n  }\n  if ((*(byte *)((long)param_1 + 5) & 4) != 0) {\n    *(uint *)puVar40 = *(uint *)puVar40 | 0x400;\n  }\n  line_number = *(uint *)((long)puVar40 + 4);\n  ppuStack_100 = (ulong **)0x14baf1;\n  iVar11 = signal_in_progress(0x42);\n  if ((iVar11 == 0) && (running_trap != 0x43)) {\n    line_number_for_err_trap = line_number;\n  }\n  _DAT_00242180 = 0;\n  local_a0 = param_1[3];\n  if (terminating_signal != 0) {\n    ppuStack_100 = (ulong **)0x14cc36;\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    ppuStack_100 = (ulong **)0x14cbfd;\n    throw_to_top_level();\n  }\n  if ((((variable_context != 0) && (interactive_shell != 0)) && (sourcelevel == 0)) &&\n     (line_number = line_number - (DAT_00242170 + -1), (int)line_number < 1)) {\n    line_number = 1;\n  }\n  command_string_index = 0;\n  ppuStack_100 = (ulong **)0x14bb8c;\n  print_simple_command(local_a0);\n  ppuStack_100 = (ulong **)0x14bb96;\n  uVar10 = signal_in_progress(0x41);\n  ppuVar17 = the_printed_command_except_trap;\n  if ((uVar10 | running_trap) == 0) {\n    if (the_printed_command_except_trap != (ulong **)0x0) {\n      ppuStack_100 = (ulong **)0x14bbbe;\n      sh_xfree(the_printed_command_except_trap,\"execute_cmd.c\",0x112a);\n    }\n    ppuVar17 = the_printed_command;\n    if (the_printed_command != (ulong **)0x0) {\n      ppuStack_100 = (ulong **)0x14bbd2;\n      sVar14 = strlen((char *)the_printed_command);\n      ppuStack_100 = (ulong **)0x14bbea;\n      pcVar13 = (char *)sh_xmalloc(sVar14 + 1,\"execute_cmd.c\",0x112b);\n      ppuStack_100 = (ulong **)0x14bbf5;\n      ppuVar17 = (ulong **)strcpy(pcVar13,(char *)ppuVar17);\n    }\n  }\n  the_printed_command_except_trap = ppuVar17;\n  ppuStack_100 = (ulong **)0x14bc04;\n  uVar10 = run_debug_trap();\n  if ((debugging_mode != 0) && (uVar10 != 0)) {\n    uVar10 = 0;\n    puVar24 = &local_f8;\n    goto LAB_0014d315;\n  }\n  local_c0 = CONCAT44(local_c0._4_4_,*(undefined4 *)local_a0);\n  uVar29 = uVar41 & __fd;\n  bVar44 = uVar6 != 0;\n  local_e0 = (long **)CONCAT71(local_e0._1_7_,bVar44);\n  local_a8 = CONCAT44(local_a8._4_4_,uVar29);\n  if (local_a0[1] != 0) {\n    last_command_subst_pid = 0xffffffff;\n    ppcVar38 = *(char ***)(local_a0[1] + 8);\n    local_80 = (ulong **)\n               (CONCAT44(local_80._4_4_,*(undefined4 *)(ppcVar38 + 1)) & 0xffffffff00000002);\n    local_94 = last_asynchronous_pid;\n    if (uVar29 == 0xffffffff && !bVar44) {\nLAB_0014dca8:\n      last_command_subst_pid = 0xffffffff;\n      local_94 = 0;\n      local_a8 = CONCAT44(local_a8._4_4_,__fd);\n      uVar10 = uVar41;\n      goto LAB_0014cfa8;\n    }\n    if (uVar29 == 0xffffffff) {\n      pcVar13 = *ppcVar38;\n      if ((pcVar13 != (char *)0x0) && (*pcVar13 == '%')) {\n        local_94 = 0;\n        uVar10 = 0xffffffff;\n        goto LAB_0014cfa8;\n      }\n      ppuStack_100 = (ulong **)0x14d6e7;\n      maybe_make_export_env();\n      ppuVar17 = the_printed_command_except_trap;\n      ppuStack_100 = (ulong **)0x14d6f6;\n      sVar14 = strlen((char *)the_printed_command_except_trap);\n      local_f0 = \"execute_cmd.c\";\n      ppuStack_100 = (ulong **)0x14d713;\n      pcVar13 = (char *)sh_xmalloc(sVar14 + 1,\"execute_cmd.c\",0x115b);\n      ppuStack_100 = (ulong **)0x14d71e;\n      pcVar13 = strcpy(pcVar13,(char *)ppuVar17);\n      ppuStack_100 = (ulong **)0x14d72e;\n      iVar11 = make_child(pcVar13,(ulong)local_e0 & 0xff);\n      local_c0 = local_c0 | 0x40;\n      if (iVar11 == 0) goto LAB_0014d5a1;\n    }\n    else {\n      ppuStack_100 = (ulong **)0x14bc8a;\n      maybe_make_export_env();\n      ppuVar17 = the_printed_command_except_trap;\n      ppuStack_100 = (ulong **)0x14bc99;\n      sVar14 = strlen((char *)the_printed_command_except_trap);\n      local_f0 = \"execute_cmd.c\";\n      ppuStack_100 = (ulong **)0x14bcb6;\n      pcVar13 = (char *)sh_xmalloc(sVar14 + 1,\"execute_cmd.c\",0x115b);\n      ppuStack_100 = (ulong **)0x14bcc1;\n      pcVar13 = strcpy(pcVar13,(char *)ppuVar17);\n      ppuStack_100 = (ulong **)0x14bcd1;\n      iVar11 = make_child(pcVar13,(ulong)local_e0 & 0xff);\n      local_c0 = local_c0 | 0x40;\n      if (iVar11 == 0) goto LAB_0014bcde;\n    }\nLAB_0014d73b:\n    uVar29 = last_command_exit_value;\n    if (uVar41 == 0xffffffff) {\n      puVar24 = &local_f8;\n      if (-1 < (int)(uint)local_a8) {\n        ppuStack_100 = (ulong **)0x14dd04;\n        close(__fd);\n        puVar24 = &local_f8;\n      }\n      goto LAB_0014d315;\n    }\n    if ((int)__fd < 0) {\n      if ((int)uVar41 < 0) {\n        line_number = local_60;\n        ppuStack_100 = (ulong **)0x14d76f;\n        dispose_used_env_vars();\n        local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar29);\n        puVar36 = &local_f8;\n        goto LAB_0014d376;\n      }\n    }\n    else {\n      ppuStack_100 = (ulong **)0x14dcc5;\n      close(__fd);\n      puVar24 = &local_f8;\n      uVar10 = uVar29;\n      if ((int)uVar41 < 0) goto LAB_0014d315;\n    }\n    ppuStack_100 = (ulong **)0x14dcd6;\n    close(uVar41);\n    line_number = local_60;\n    ppuStack_100 = (ulong **)0x14dce8;\n    dispose_used_env_vars();\n    local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar29);\n    goto LAB_0014d376;\n  }\n  last_command_subst_pid = 0xffffffff;\n  local_94 = last_asynchronous_pid;\n  if (uVar29 == 0xffffffff && !bVar44) {\n    local_80 = (ulong **)((ulong)local_80._4_4_ << 0x20);\n    goto LAB_0014dca8;\n  }\n  ppuStack_100 = (ulong **)0x14d53e;\n  maybe_make_export_env();\n  ppuVar17 = the_printed_command_except_trap;\n  ppuStack_100 = (ulong **)0x14d54d;\n  sVar14 = strlen((char *)the_printed_command_except_trap);\n  local_f0 = \"execute_cmd.c\";\n  ppuStack_100 = (ulong **)0x14d56a;\n  pcVar13 = (char *)sh_xmalloc(sVar14 + 1,\"execute_cmd.c\",0x115b);\n  ppuStack_100 = (ulong **)0x14d575;\n  pcVar13 = strcpy(pcVar13,(char *)ppuVar17);\n  ppuStack_100 = (ulong **)0x14d585;\n  iVar11 = make_child(pcVar13,(ulong)local_e0 & 0xff);\n  local_80 = (ulong **)CONCAT44(local_80._4_4_,iVar11);\n  if (iVar11 != 0) goto LAB_0014d73b;\n  local_c0 = local_c0 | 0x40;\n  if ((uint)local_a8 == -1) {\nLAB_0014d5a1:\n    subshell_environment = 0x108;\nLAB_0014d5ab:\n    subshell_environment = subshell_environment | 1;\n  }\n  else {\nLAB_0014bcde:\n    subshell_environment = 0x118;\n    if (uVar6 != 0) goto LAB_0014d5ab;\n  }\n  ppuVar17 = local_f8;\n  if ((local_f8 != (ulong **)0x0) && (0 < *(int *)local_f8)) {\n    local_e0 = (long **)CONCAT44(local_e0._4_4_,uVar41);\n    lVar22 = 0;\n    do {\n      if (*(char *)((long)ppuVar17[1] + lVar22) != '\\0') {\n        ppuStack_100 = (ulong **)0x14bd35;\n        close((int)lVar22);\n        *(undefined *)((long)ppuVar17[1] + lVar22) = 0;\n      }\n      lVar22 = lVar22 + 1;\n    } while (*(int *)ppuVar17 != (int)lVar22 && (int)lVar22 <= *(int *)ppuVar17);\n    param_4 = (ulong)local_e0 & 0xffffffff;\n  }\n  uVar41 = (uint)param_4;\n  stdin_redir = stdin_redir | __fd != 0xffffffff;\n  ppuStack_100 = (ulong **)0x14cf31;\n  FUN_001497c0(puVar18,param_4);\n  if (-1 < DAT_0023842c) {\n    ppuStack_100 = (ulong **)0x14cf40;\n    close(DAT_0023842c);\n    DAT_0023842c = -1;\n  }\n  if (-1 < DAT_00238430) {\n    ppuStack_100 = (ulong **)0x14cf59;\n    close(DAT_00238430);\n    DAT_00238430 = -1;\n  }\n  _DAT_00238434 = 0xffffffffffffffff;\n  last_asynchronous_pid = local_94;\n  if (uVar6 != 0) {\n    subshell_level = subshell_level + 1;\n  }\n  ppuStack_100 = (ulong **)0x14cf98;\n  sh_xfree(pcVar13,local_f0,0x117d);\n  local_94 = 1;\n  local_a8 = CONCAT44(local_a8._4_4_,0xffffffff);\n  uVar10 = 0xffffffff;\nLAB_0014cfa8:\n  if (terminating_signal != 0) {\n    ppuStack_100 = (ulong **)0x14d5fd;\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    ppuStack_100 = (ulong **)0x14d4ef;\n    throw_to_top_level();\n  }\n  puVar40 = local_a0;\n  if ((local_c0 & 0x20) == 0) {\n    current_fds_to_close = local_f8;\n    ppuStack_100 = (ulong **)0x14cfe8;\n    FUN_00147eb0();\n    ppuVar20 = (ulong **)puVar40[1];\n    for (ppuVar17 = ppuVar20; ppuVar17 != (ulong **)0x0; ppuVar17 = (ulong **)*ppuVar17) {\n      ppcVar38 = (char **)ppuVar17[1];\n      if ((*(byte *)(ppcVar38 + 1) & 4) == 0) {\n        local_f0 = (char *)CONCAT44(local_f0._4_4_,uVar10);\n        local_e0 = (long **)CONCAT44(local_e0._4_4_,uVar6);\n        goto LAB_0014dd93;\n      }\n    }\n    goto LAB_0014d00b;\n  }\n  ppuStack_100 = (ulong **)0x14d2d7;\n  local_e0 = (long **)copy_word_list(local_a0[1]);\n  goto LAB_0014d03c;\n  while( true ) {\n    ppuStack_100 = (ulong **)0x14dda9;\n    iVar11 = strcmp(pcVar13,\"command\");\n    if (iVar11 != 0) break;\n    ppuVar17 = (ulong **)*ppuVar17;\n    if (ppuVar17 == (ulong **)0x0) {\n      param_2 = (ulong)local_e0 & 0xffffffff;\n      uVar10 = (uint)local_f0;\n      goto LAB_0014d00b;\n    }\n    ppcVar38 = (char **)ppuVar17[1];\n    if (ppcVar38 == (char **)0x0) break;\nLAB_0014dd93:\n    pcVar13 = *ppcVar38;\n    if ((pcVar13 == (char *)0x0) || (*pcVar13 != 'c')) break;\n  }\n  uVar10 = (uint)local_f0;\n  param_2 = (ulong)local_e0 & 0xffffffff;\n  ppuStack_100 = (ulong **)0x14dde6;\n  local_f0 = (char *)ppuVar17;\n  lVar22 = builtin_address_internal(*ppcVar38,0);\n  if ((lVar22 != 0) && ((*(byte *)(lVar22 + 0x10) & 0x80) != 0)) {\n    for (ppuVar20 = *(ulong ***)local_f0; ppuVar20 != (ulong **)0x0; ppuVar20 = (ulong **)*ppuVar20)\n    {\n      if ((ppuVar20[1] != (ulong *)0x0) && (lVar22 = *ppuVar20[1], lVar22 != 0)) {\n        ppuStack_100 = (ulong **)0x14de16;\n        iVar11 = valid_array_reference(lVar22,0);\n        if (iVar11 != 0) {\n          *(uint *)((long)ppuVar20[1] + 8U) = *(uint *)((long)ppuVar20[1] + 8U) | 0x200;\n        }\n      }\n    }\n  }\n  ppuVar20 = (ulong **)local_a0[1];\nLAB_0014d00b:\n  if ((local_c0 & 8) == 0) {\n    ppuStack_100 = (ulong **)0x14d5e8;\n    local_e0 = (long **)expand_words(ppuVar20);\n  }\n  else {\n    comsub_ignore_return = comsub_ignore_return + 1;\n    ppuStack_100 = (ulong **)0x14d025;\n    local_e0 = (long **)expand_words(ppuVar20);\n    comsub_ignore_return = comsub_ignore_return + -1;\n  }\n  current_fds_to_close = (ulong **)0x0;\nLAB_0014d03c:\n  uVar6 = (uint)param_2;\n  if (local_e0 == (long **)0x0) {\nLAB_0014d2a3:\n    uVar6 = (uint)param_2;\n    this_command_name = (undefined *)0x0;\n    uVar27 = *(undefined8 *)(*(long *)((long)puVar34 + 0x58) + 0x10);\n    if (*(int *)((long)puVar34 + 100) != 0) {\n      *(undefined8 *)((long)puVar34 + -8) = 0x14d2cb;\n      uVar12 = FUN_00149940(uVar27,*(undefined4 *)((long)puVar34 + 0x50),uVar10,0);\n                    /* WARNING: Subroutine does not return */\n      *(undefined8 *)((long)puVar34 + -8) = 0x14d2d2;\n      sh_exit(uVar12);\n    }\n    *(undefined8 *)((long)puVar34 + -8) = 0x14d2ee;\n    uVar10 = FUN_00149940(uVar27,*(undefined4 *)((long)puVar34 + 0x50),uVar10,param_2);\n    *(undefined8 *)((long)puVar34 + -8) = 0x14d305;\n    lVar22 = bind_variable(\"_\",&DAT_00213d70,0);\n    if (lVar22 != 0) {\n      *(uint *)(lVar22 + 0x28) = *(uint *)(lVar22 + 0x28) & 0xfffffffe;\n    }\n    *(undefined8 *)((long)puVar34 + -8) = 0x14d315;\n    set_pipestatus_from_exit(uVar10);\n    puVar24 = puVar34;\nLAB_0014d315:\n    line_number = *(uint *)((long)puVar24 + 0x98);\n    *(undefined8 *)((long)puVar24 + -8) = 0x14d327;\n    dispose_used_env_vars();\n    bVar44 = already_making_children != 0 && uVar41 == 0xffffffff;\n    puVar35 = puVar24;\n    if (bVar44) {\n      *(undefined8 *)((long)puVar24 + -8) = 0x14d9cb;\n      stop_pipeline(uVar6,0);\n      if (uVar6 == 0) {\nLAB_0014e24e:\n        puVar35 = puVar24;\n        if (last_made_pid == -1) {\n          *(uint *)((long)puVar24 + 0x10) = uVar10;\n          bVar44 = true;\n        }\n        else {\n          bVar44 = true;\n          *(undefined8 *)((long)puVar24 + -8) = 0x14e26c;\n          uVar12 = wait_for(last_made_pid,0);\n          *(undefined4 *)((long)puVar24 + 0x10) = uVar12;\n        }\n      }\n      else {\n        *(int *)((long)puVar24 + 0x60) = interactive;\n        if (interactive == 0) {\n          *(undefined4 *)((long)puVar24 + 0x10) = 0;\n        }\n        else {\n          *(undefined8 *)((long)puVar24 + -8) = 0x14e7b2;\n          describe_pid(last_made_pid);\n          *(undefined4 *)((long)puVar24 + 0x60) = 0;\n        }\n      }\n    }\n    else {\n      *(uint *)((long)puVar24 + 0x10) = uVar10;\n      bVar44 = uVar41 == 0xffffffff;\n    }\nLAB_0014d34a:\n    puVar36 = puVar35;\n    if ((((*(int *)((long)puVar35 + 0x20) == 0) && ((*(byte *)((long)puVar35 + 0x8c) & 1) != 0)) &&\n        (((__fd == 0xffffffff & ((byte)*(undefined4 *)((long)puVar35 + 0x60) ^ 1)) != 0 &&\n         ((bVar44 && ((*(uint *)param_1[3] & 0x800) == 0)))))) &&\n       (*(int *)((long)puVar35 + 0x10) != 0)) {\n      last_command_exit_value = *(uint *)((long)puVar35 + 0x10);\n      line_number = line_number_for_err_trap;\n      *(undefined8 *)((long)puVar35 + -8) = 0x14da27;\n      run_error_trap();\n      line_number = *(uint *)((long)puVar35 + 0x98);\n    }\nLAB_0014d376:\n    puVar35 = puVar36;\n    if ((((uint)(*(int *)((long)puVar36 + 0x20) != 0) | *(uint *)((long)puVar36 + 0x60)) != 0) ||\n       ((((posixly_correct == 0 || (interactive != 0)) || (_DAT_00242180 == 0)) &&\n        (((*(uint *)((long)puVar36 + 0x60) = exit_immediately_on_error,\n          exit_immediately_on_error == 0 ||\n          (*(undefined4 *)((long)puVar36 + 0x60) = 0, (__fd & uVar41) != 0xffffffff)) ||\n         (*(int *)((long)puVar36 + 0x10) == 0)))))) goto LAB_0014b978;\n    last_command_exit_value = *(undefined4 *)((long)puVar36 + 0x10);\n    *(undefined8 *)((long)puVar36 + -8) = 0x14d3e6;\n    run_pending_traps();\n    puVar32 = puVar36;\n    if (exit_immediately_on_error != 0) {\n      *(undefined8 *)((long)puVar36 + -8) = 0x14d3fa;\n      iVar11 = signal_is_trapped(0);\n      if (iVar11 != 0) {\n        *(undefined8 *)((long)puVar36 + -8) = 0x14d411;\n        iVar11 = unwind_protect_tag_on_stack(\"saved-redirects\");\n        if (iVar11 != 0) {\n          *(undefined8 *)((long)puVar36 + -8) = 0x14d421;\n          run_unwind_frame(\"saved-redirects\");\n        }\n      }\n    }\nLAB_0014c07d:\n                    /* WARNING: Subroutine does not return */\n    *(undefined **)((long)puVar32 + -8) = &UNK_0014c087;\n    jump_to_top_level(4);\n  }\n  ppuStack_100 = (ulong **)0x14d054;\n  begin_unwind_frame(\"simple-command\");\n  if ((echo_command_at_execute != 0) && ((local_c0 & 0x800) == 0)) {\n    ppuStack_100 = (ulong **)0x14da6e;\n    xtrace_print_word_list(local_e0,1);\n  }\n  local_90 = (ulong **)(CONCAT44(local_90._4_4_,(uint)local_c0) & 0xffffffff00000010);\n  if ((local_c0 & 0x10) == 0) {\n    plVar23 = local_e0[1];\n    if (posixly_correct == 0) {\nLAB_0014db5b:\n      ppuStack_100 = (ulong **)0x14db63;\n      local_f0 = (char *)find_function(*plVar23);\n      if ((posixly_correct != 0) && (tempenv_assign_error != 0)) {\nLAB_0014d5d6:\n        last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n        ppuStack_100 = (ulong **)0x14d5e0;\n        jump_to_top_level(2);\n      }\n      tempenv_assign_error = 0;\n      pcVar25 = (code *)0x0;\n      local_4c = 0xffffffff;\n      if ((ulong **)local_f0 == (ulong **)0x0) goto LAB_0014dba2;\n    }\n    else {\n      ppuStack_100 = (ulong **)0x14d09b;\n      pcVar25 = (code *)find_special_builtin(*plVar23);\n      if (pcVar25 == (code *)0x0) {\n        plVar23 = local_e0[1];\n        goto LAB_0014db5b;\n      }\n      if (posixly_correct == 0) {\n        tempenv_assign_error = 0;\n        local_4c = 0xffffffff;\n        local_f0 = (char *)0x0;\n        local_90 = (ulong **)CONCAT44(local_90._4_4_,1);\n      }\n      else {\n        if (tempenv_assign_error != 0) {\n          if (interactive_shell != 0) goto LAB_0014d5d6;\n          goto LAB_0014e079;\n        }\n        local_4c = 0xffffffff;\n        local_f0 = (char *)0x0;\n        local_90 = (ulong **)CONCAT44(local_90._4_4_,1);\n      }\n    }\n  }\n  else {\n    if (posixly_correct == 0) {\n      tempenv_assign_error = 0;\n    }\n    else if (tempenv_assign_error != 0) goto LAB_0014d5d6;\nLAB_0014dba2:\n    local_4c = 0xffffffff;\n    ppuStack_100 = (ulong **)0x14dbb3;\n    pcVar25 = (code *)find_shell_builtin(*local_e0[1]);\n    if (pcVar25 == command_builtin) {\n      local_f0 = (char *)CONCAT44(local_f0._4_4_,uVar10);\n      pplVar19 = local_e0;\n      do {\n        pplVar30 = (long **)*pplVar19;\n        if (pplVar30 == (long **)0x0) {\nLAB_0014dc5a:\n          uVar10 = (uint)local_f0;\n          local_e0 = pplVar19;\n          goto LAB_0014dc63;\n        }\n        uVar39 = 1;\n        pcVar13 = (char *)*pplVar30[1];\n        pplVar4 = pplVar19;\n        uVar12 = 1;\n        if (*pcVar13 == '-') {\n          if (pcVar13[1] == 'p') {\n            if (((pcVar13[2] != '\\0') || (restricted != 0)) ||\n               (pplVar30 = (long **)*pplVar30, pplVar30 == (long **)0x0)) goto LAB_0014dc5a;\n            uVar39 = 2;\n            uVar12 = 2;\n            pcVar13 = (char *)*pplVar30[1];\n            if (*pcVar13 != '-') goto LAB_0014dbec;\n          }\n          if (((pcVar13[1] != '-') || (pcVar13[2] != '\\0')) ||\n             ((pplVar30 = (long **)*pplVar30, pplVar30 == (long **)0x0 ||\n              (uVar12 = uVar39, *pplVar30[1] == 0)))) goto LAB_0014dc5a;\n        }\nLAB_0014dbec:\n        do {\n          pplVar19 = pplVar30;\n          pplVar28 = pplVar4;\n          pplVar4 = (long **)*pplVar28;\n          pplVar30 = pplVar19;\n        } while (pplVar4 != pplVar19);\n        *pplVar28 = (long *)0x0;\n        local_e0 = (long **)CONCAT44(local_e0._4_4_,uVar12);\n        ppuStack_100 = (ulong **)0x14dc07;\n        dispose_words();\n        if ((uint)local_e0 == 2) {\n          local_c0 = local_c0 | 0x4810;\n        }\n        else {\n          local_c0 = local_c0 | 0x810;\n        }\n        ppuStack_100 = (ulong **)0x14dc24;\n        pcVar25 = (code *)find_shell_builtin(*pplVar19[1]);\n      } while (pcVar25 == command_builtin);\n      uVar10 = (uint)local_f0;\n      local_e0 = pplVar19;\n    }\nLAB_0014dc63:\n    local_90 = (ulong **)(CONCAT44(local_90._4_4_,(uint)local_c0) & 0xffffffff00000800);\n    if ((local_c0 & 0x800) == 0) {\n      local_f0 = (char *)0x0;\n      pcVar25 = (code *)0x0;\n    }\n    else {\n      pcVar25 = (code *)0x0;\n      local_4c = executing_command_builtin;\n      ppuStack_100 = (ulong **)0x14dff7;\n      unwind_protect_mem(&executing_command_builtin,4);\n      executing_command_builtin = executing_command_builtin | 1;\n      local_90 = (ulong **)((ulong)local_90 & 0xffffffff00000000);\n      local_f0 = (char *)0x0;\n    }\n  }\n  ppuStack_100 = (ulong **)0x14d0f0;\n  add_unwind_protect(dispose_words,local_e0);\n  if (terminating_signal != 0) {\n    ppuStack_100 = (ulong **)0x14d8dc;\n    termsig_handler(terminating_signal);\n  }\n  local_88 = local_e0;\n  if (interrupt_state != 0) {\n    ppuStack_100 = (ulong **)0x14d8e6;\n    throw_to_top_level();\n    local_88 = local_e0;\n  }\n  do {\n    pplVar19 = local_88;\n    local_88 = (long **)*pplVar19;\n  } while (local_88 != (long **)0x0);\n  local_78 = (undefined *)*pplVar19[1];\n  if (*(char *)*local_e0[1] == '%') {\n    if (local_94 != 0) goto LAB_0014d16f;\n    this_command_name = &DAT_001fca62;\n    if (uVar6 == 0) {\n      this_command_name = &DAT_001fca65;\n    }\n    last_shell_builtin = this_shell_builtin;\n    ppuStack_100 = (ulong **)0x14d924;\n    this_shell_builtin = (code *)builtin_address();\n    ppuStack_100 = (ulong **)0x14d932;\n    uVar10 = (*this_shell_builtin)(local_e0);\n  }\n  else {\n    if (((job_control != 0) && (((uint)local_80 | local_94 | uVar6) == 0)) &&\n       ((*local_e0 == (long *)0x0 &&\n        (((*(char *)*local_e0[1] != '\\0' && (local_a0[2] == 0)) &&\n         (((uint)local_a8 & uVar10) == 0xffffffff)))))) {\n      ppuStack_100 = (ulong **)0x14e16f;\n      pcVar13 = (char *)get_string_value(\"auto_resume\");\n      if (pcVar13 == (char *)0x0) goto LAB_0014d16f;\n      if (*pcVar13 == 'e') {\n        ppuStack_100 = (ulong **)0x14e281;\n        iVar11 = strcmp(pcVar13,\"exact\");\n        iVar11 = (-(uint)(iVar11 == 0) & 3) + 0x19;\n      }\n      else {\n        iVar11 = 0x19;\n        if (*pcVar13 == 's') {\n          ppuStack_100 = (ulong **)0x14e19b;\n          iVar11 = strcmp(pcVar13,\"substring\");\n          iVar11 = 0x1a - (uint)(iVar11 != 0);\n        }\n      }\n      ppuStack_100 = (ulong **)0x14e1b3;\n      iVar11 = get_job_by_name(*local_e0[1],iVar11);\n      if (iVar11 == -1) goto LAB_0014d16f;\n      local_f8 = (ulong **)CONCAT44(local_f8._4_4_,iVar11);\n      ppuStack_100 = (ulong **)0x14e1cb;\n      run_unwind_frame(\"simple-command\");\n      this_command_name = &DAT_001fca65;\n      last_shell_builtin = this_shell_builtin;\n      ppuStack_100 = (ulong **)0x14e1ec;\n      this_shell_builtin = (code *)builtin_address();\n      ppuStack_100 = (ulong **)0x14e200;\n      iVar11 = start_job((ulong)local_f8 & 0xffffffff,1);\n      local_e8._0_4_ = iVar11;\n      if (iVar11 < 0) {\n        local_e8._0_4_ = 1;\n      }\n      line_number = local_60;\n      ppuStack_100 = (ulong **)0x14e222;\n      dispose_used_env_vars();\n      bVar44 = uVar41 == 0xffffffff;\n      puVar35 = &local_f8;\n      if ((already_making_children != 0) && (puVar35 = &local_f8, bVar44)) {\n        ppuStack_100 = (ulong **)0x14e24a;\n        stop_pipeline(0,0);\n        uVar10 = (uint)local_e8;\n        goto LAB_0014e24e;\n      }\n      goto LAB_0014d34a;\n    }\nLAB_0014d16f:\n    local_80 = (ulong **)CONCAT44(local_80._4_4_,uVar10);\n    pplVar19 = local_e0;\n    local_70 = uVar6;\n    while( true ) {\n      this_command_name = (undefined *)*pplVar19[1];\n      if (terminating_signal != 0) {\n        ppuStack_100 = (ulong **)0x14da4e;\n        termsig_handler(terminating_signal);\n      }\n      if (interrupt_state != 0) {\n        ppuStack_100 = (ulong **)0x14da3e;\n        throw_to_top_level();\n      }\n      if (((ulong)local_f0 | (ulong)pcVar25) == 0) {\n        ppuStack_100 = (ulong **)0x14db41;\n        pcVar25 = (code *)find_shell_builtin(this_command_name);\n      }\n      uVar6 = local_70;\n      ppuVar17 = local_80;\n      last_shell_builtin = this_shell_builtin;\n      uVar10 = (uint)local_80;\n      this_shell_builtin = pcVar25;\n      if (((ulong)local_f0 | (ulong)pcVar25) != 0) break;\n      if (((autocd == 0) || (interactive == 0)) || (pplVar19[1] == (long *)0x0)) {\n        local_f0 = \"execute_cmd.c\";\n        goto LAB_0014dec4;\n      }\n      lVar22 = *pplVar19[1];\n      ppuStack_100 = (ulong **)0x14d45a;\n      lVar26 = search_for_command(lVar22,0);\n      if (lVar26 == 0) {\n        ppuStack_100 = (ulong **)0x14dc99;\n        iVar11 = file_isdir(lVar22);\n      }\n      else {\n        ppuStack_100 = (ulong **)0x14d46e;\n        iVar11 = file_isdir(lVar26);\n      }\n      local_f0 = \"execute_cmd.c\";\n      ppuStack_100 = (ulong **)0x14d48c;\n      sh_xfree(lVar26,\"execute_cmd.c\",0x10fb);\n      if (iVar11 == 0) {\n        uVar10 = (uint)local_80;\nLAB_0014dec4:\n        param_2 = (ulong)local_70;\n        local_90 = the_printed_command_except_trap;\n        if (the_printed_command_except_trap == (ulong **)0x0) {\n          local_90 = (ulong **)&DAT_00213d70;\n        }\n        ppuStack_100 = (ulong **)0x14dedd;\n        local_e0 = pplVar19;\n        sVar14 = strlen((char *)local_90);\n        ppuStack_100 = (ulong **)0x14def0;\n        pcVar13 = (char *)sh_xmalloc(sVar14 + 1,local_f0,0x12c2);\n        ppuStack_100 = (ulong **)0x14defd;\n        local_88 = (long **)strcpy(pcVar13,(char *)local_90);\n        if (local_94 == 0) {\nLAB_0014df09:\n          if ((local_c0 & 0x40) != 0) {\n            ppuStack_100 = (ulong **)0x14df5b;\n            iVar11 = fifos_pending();\n            if (0 < iVar11) {\n              local_c0 = local_c0 & 0xffffffffffffffbf;\n            }\n          }\n        }\n        uVar6 = (uint)param_2;\n        pcVar25 = (code *)0x0;\n        ppuStack_100 = (ulong **)(local_c0 & 0xffffffff);\n        local_108 = local_f8;\n        ppuStack_110 = (ulong **)0x14df41;\n        uVar10 = FUN_0014ab30(local_e0,local_a0[2],local_88,local_a8 & 0xffffffff,uVar10,param_2);\n        goto LAB_0014d934;\n      }\n      pcVar25 = (code *)0x0;\n      ppuStack_100 = (ulong **)0x14d4a2;\n      uVar27 = make_word(\"--\");\n      ppuStack_100 = (ulong **)0x14d4ad;\n      make_word_list(uVar27,pplVar19);\n      ppuStack_100 = (ulong **)0x14d4bc;\n      uVar27 = make_word(&DAT_00210a34);\n      ppuStack_100 = (ulong **)0x14d4c7;\n      pplVar19 = (long **)make_word_list(uVar27);\n      ppuStack_100 = (ulong **)0x14d4d4;\n      xtrace_print_word_list(pplVar19);\n      ppuStack_100 = (ulong **)0x14d4e0;\n      local_f0 = (char *)find_function(&DAT_00210a34);\n    }\n    param_2 = (ulong)local_70;\n    local_e0 = pplVar19;\n    if (pcVar25 != (code *)0x0) {\n      local_50 = executing_builtin;\n      ppuStack_100 = (ulong **)0x14d219;\n      unwind_protect_mem(&executing_builtin,4);\n      if (local_4c == 0xffffffff) {\n        local_4c = executing_command_builtin;\n        ppuStack_100 = (ulong **)0x14e2be;\n        unwind_protect_mem(&executing_command_builtin,4);\n      }\n    }\n    if (local_94 != 0) {\n      ppuStack_100 = (ulong **)0x14d239;\n      reset_signal_handlers();\n      subshell_environment = subshell_environment & 0xfffffeff | 0x80;\n      if (uVar6 == 0) {\n        subshell_level = subshell_level + 1;\n      }\n      else {\n        if (((local_c0 & 0x400) != 0) && ((uint)local_a8 == -1)) {\n          ppuStack_100 = (ulong **)0x14e7cd;\n          iVar11 = stdin_redirects(local_a0[2]);\n          if (iVar11 == 0) {\n            ppuStack_100 = (ulong **)0x14e7da;\n            async_redirect_stdin();\n          }\n        }\n        if (job_control == 0) {\n          ppuStack_100 = (ulong **)0x14df98;\n          get_original_signal(2);\n          ppuStack_100 = (ulong **)0x14dfa7;\n          set_signal_handler(2,1);\n          ppuStack_100 = (ulong **)0x14dfb1;\n          get_original_signal(3);\n          ppuStack_100 = (ulong **)0x14dfc0;\n          set_signal_handler(3,1);\n        }\n      }\n      local_108 = (ulong **)(local_c0 & 0xffffffff);\n      ppuStack_110 = local_f8;\n      puVar34 = &uStack_118;\n      uStack_118 = param_2;\n      ppuStack_100 = ppuVar20;\n      FUN_0014b010(local_e0,local_a0[2],pcVar25,local_f0,local_a8 & 0xffffffff,\n                   (ulong)ppuVar17 & 0xffffffff);\n      goto LAB_0014d2a3;\n    }\n    uVar16 = local_a0[2];\n    ppuStack_100 = (ulong **)0x14e2fc;\n    begin_unwind_frame(\"saved_fifos\");\n    ppuStack_100 = (ulong **)0x14e301;\n    local_94 = num_fifos();\n    ppuStack_100 = (ulong **)0x14e312;\n    local_a8 = copy_fifo_list(&local_48);\n    if (local_a8 != 0) {\n      ppuStack_100 = (ulong **)0x14e32d;\n      add_unwind_protect(xfree,local_a8);\n    }\n    ppuStack_100 = (ulong **)0x14e33a;\n    iVar11 = do_redirections(uVar16,3);\n    ppuVar20 = redirection_undo_list;\n    if (iVar11 == 0) {\n      if (pcVar25 == (code *)PTR_exec_builtin_00237f98) {\n        ppuStack_100 = (ulong **)0x14e70b;\n        dispose_redirects(redirection_undo_list);\n        ppuVar20 = exec_redirection_undo_list;\n        exec_redirection_undo_list = (ulong **)0x0;\n        if (ppuVar20 != (ulong **)0x0) goto LAB_0014e381;\nLAB_0014e3be:\n        redirection_undo_list = (ulong **)0x0;\n        ppuStack_100 = (ulong **)0x14e3d6;\n        local_f0 = (char *)ppuVar20;\n        uVar10 = FUN_00148110(pcVar25,local_e0,local_c0 & 0xffffffff,0);\n        ppuStack_100 = (ulong **)0x14e3e4;\n        fflush(stdout);\n        ppuStack_100 = (ulong **)0x14e3f0;\n        fpurge(stdout);\n        ppuStack_100 = (ulong **)0x14e3fc;\n        iVar11 = ferror(stdout);\n        ppuVar20 = (ulong **)local_f0;\n        if (iVar11 != 0) {\nLAB_0014e6ca:\n          ppuStack_100 = (ulong **)0x14e6db;\n          local_f0 = (char *)ppuVar20;\n          clearerr(stdout);\n        }\n        ppuVar20 = (ulong **)local_f0;\n        if ((pcVar25 != (code *)PTR_command_builtin_00237fe0) ||\n           (this_shell_builtin != exec_builtin)) goto LAB_0014e416;\n        if ((ulong **)local_f0 == (ulong **)0x0) {\n          redirection_undo_list = exec_redirection_undo_list;\n          exec_redirection_undo_list = (ulong **)0x0;\n        }\n        else {\n          ppuStack_100 = (ulong **)0x14e64b;\n          dispose_redirects(local_f0);\n          redirection_undo_list = exec_redirection_undo_list;\n          exec_redirection_undo_list = (ulong **)0x0;\n          ppuStack_100 = (ulong **)0x14e670;\n          discard_unwind_frame(\"saved-redirects\");\n        }\n      }\n      else {\n        if (exec_redirection_undo_list != (ulong **)0x0) {\n          local_80 = redirection_undo_list;\n          ppuStack_100 = (ulong **)0x14e36c;\n          dispose_redirects();\n          exec_redirection_undo_list = (ulong **)0x0;\n          ppuVar20 = local_80;\n        }\n        if (ppuVar20 != (ulong **)0x0) {\nLAB_0014e381:\n          ppuStack_100 = (ulong **)0x14e392;\n          local_80 = ppuVar20;\n          begin_unwind_frame(\"saved-redirects\");\n          ppuStack_100 = (ulong **)0x14e3a5;\n          add_unwind_protect(FUN_00147c70,local_80);\n          ppuVar20 = local_80;\n        }\n        redirection_undo_list = (ulong **)0x0;\n        if (pcVar25 != (code *)0x0) goto LAB_0014e3be;\n        ppuStack_100 = (ulong **)0x14e697;\n        local_80 = ppuVar20;\n        uVar10 = FUN_0014f460(local_f0,local_e0,local_c0 & 0xffffffff,local_f8,0,0);\n        ppuStack_100 = (ulong **)0x14e6a5;\n        fflush(stdout);\n        ppuStack_100 = (ulong **)0x14e6b1;\n        fpurge(stdout);\n        ppuStack_100 = (ulong **)0x14e6bd;\n        iVar11 = ferror(stdout);\n        ppuVar20 = local_80;\n        if (iVar11 != 0) goto LAB_0014e6ca;\nLAB_0014e416:\n        if (ppuVar20 != (ulong **)0x0) {\n          ppuStack_100 = (ulong **)0x14e42e;\n          redirection_undo_list = ppuVar20;\n          discard_unwind_frame(\"saved-redirects\");\n        }\n      }\n      if (redirection_undo_list != (ulong **)0x0) {\n        local_f0 = (char *)redirection_undo_list;\n        ppuStack_100 = (ulong **)0x14e449;\n        do_redirections(redirection_undo_list,1);\n        ppuStack_100 = (ulong **)0x14e453;\n        dispose_redirects(local_f0);\n        redirection_undo_list = (ulong **)0x0;\n      }\n      ppuStack_100 = (ulong **)0x14e463;\n      iVar11 = num_fifos();\n      if ((int)local_94 < iVar11) {\n        ppuStack_100 = (ulong **)0x14e535;\n        close_new_fifos(local_a8,local_48 & 0xffffffff);\n      }\n      if (local_a8 != 0) {\n        ppuStack_100 = (ulong **)0x14e488;\n        sh_xfree(local_a8,\"execute_cmd.c\",0x159b);\n      }\n      ppuStack_100 = (ulong **)0x14e494;\n      discard_unwind_frame(\"saved_fifos\");\n      ppuVar20 = the_printed_command_except_trap;\n      if (pcVar25 == (code *)0x0) {\n        if (uVar10 == 0x102) {\n          uVar10 = 2;\n        }\n        else if (0x100 < (int)uVar10) {\n          uVar10 = ~-(uint)(uVar10 - 0x101 < 2) + 2;\n        }\n      }\n      else {\n        if (0x100 < (int)uVar10) {\n          if (0x105 < (int)uVar10) {\n            if (uVar10 == 0x106) {\n              executing_builtin = local_50;\n              executing_command_builtin = local_4c;\n              if (the_printed_command_except_trap == (ulong **)0x0) {\n                uVar10 = 0xffffffff;\n                ppuStack_100 = (ulong **)0x14e553;\n                local_88 = (long **)sh_xmalloc(1,\"execute_cmd.c\",0x12c2);\n                local_a8 = CONCAT44(local_a8._4_4_,0xffffffff);\n                *(undefined *)local_88 = 0;\n              }\n              else {\n                uVar10 = 0xffffffff;\n                ppuStack_100 = (ulong **)0x14e4f2;\n                sVar14 = strlen((char *)the_printed_command_except_trap);\n                ppuStack_100 = (ulong **)0x14e507;\n                pcVar13 = (char *)sh_xmalloc(sVar14 + 1,\"execute_cmd.c\",0x12c2);\n                ppuStack_100 = (ulong **)0x14e512;\n                local_88 = (long **)strcpy(pcVar13,(char *)ppuVar20);\n                local_a8 = CONCAT44(local_a8._4_4_,0xffffffff);\n              }\n              goto LAB_0014df09;\n            }\n            goto LAB_0014e568;\n          }\n          if (0x102 < (int)uVar10) goto LAB_0014e58f;\n          uVar10 = 2;\n          goto LAB_0014e56d;\n        }\n        if ((posixly_correct != 0) && (((ulong)local_90 & 1) != 0)) goto LAB_0014e5c0;\n      }\n    }\n    else {\n      if (redirection_undo_list != (ulong **)0x0) {\n        ppuStack_100 = (ulong **)0x14e74f;\n        do_redirections(redirection_undo_list,1);\n        ppuStack_100 = (ulong **)0x14e757;\n        dispose_redirects(ppuVar20);\n        redirection_undo_list = (ulong **)0x0;\n      }\n      if (exec_redirection_undo_list != (ulong **)0x0) {\n        ppuStack_100 = (ulong **)0x14e773;\n        dispose_redirects();\n        exec_redirection_undo_list = (ulong **)0x0;\n      }\n      ppuStack_100 = (ulong **)0x14e794;\n      sh_xfree(local_a8,\"execute_cmd.c\",0x1553);\n      if (pcVar25 == (code *)0x0) {\n        uVar10 = 1;\n      }\n      else {\nLAB_0014e58f:\n        if ((posixly_correct == 0) || (((ulong)local_90 & 1) == 0)) {\nLAB_0014e568:\n          uVar10 = 1;\nLAB_0014e56d:\n          if ((int)local_90 == 0) goto LAB_0014e574;\n        }\n        else {\n          if (interactive_shell == 0) {\n            last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n            ppuStack_100 = (ulong **)0x14e61c;\n            jump_to_top_level(4);\n          }\n          uVar10 = 1;\n        }\n        _DAT_00242180 = 1;\n        if (posixly_correct != 0) {\nLAB_0014e5c0:\n          if (temporary_env != 0) {\n            ppuStack_100 = (ulong **)0x14e5cf;\n            merge_temporary_env();\n          }\n        }\n      }\n    }\nLAB_0014e574:\n    ppuStack_100 = (ulong **)0x14e57b;\n    set_pipestatus_from_exit(uVar10);\n  }\nLAB_0014d934:\n  if (local_78 == (undefined *)0x0) {\n    local_78 = &DAT_00213d70;\n  }\n  ppuStack_100 = (ulong **)0x14d959;\n  lVar22 = bind_variable(\"_\",local_78,0);\n  if (lVar22 != 0) {\n    *(uint *)(lVar22 + 0x28) = *(uint *)(lVar22 + 0x28) & 0xfffffffe;\n  }\n  if (local_88 != (long **)0x0) {\n    ppuStack_100 = (ulong **)0x14d97d;\n    sh_xfree(local_88,\"execute_cmd.c\",0x12d1);\n  }\n  ppuStack_100 = (ulong **)0x14d987;\n  dispose_words(local_e0);\n  if (pcVar25 != (code *)0x0) {\n    executing_builtin = local_50;\n    executing_command_builtin = local_4c;\n  }\n  ppuStack_100 = (ulong **)0x14d9b2;\n  discard_unwind_frame(\"simple-command\");\n  this_command_name = (undefined *)0x0;\n  puVar24 = &local_f8;\n  goto LAB_0014d315;\njoined_r0x0014bf0e:\n  local_d8 = ppuVar5;\n  param_1 = local_d8;\n  if (ppuVar42 != (ulong **)0x0) {\n    if (terminating_signal != 0) {\n      ppuStack_100 = (ulong **)0x14c95c;\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      ppuStack_100 = (ulong **)0x14c94c;\n      throw_to_top_level();\n    }\n    ppuVar20 = (ulong **)ppuVar42[1];\n    for (; ppuVar20 != (ulong **)0x0; ppuVar20 = (ulong **)*ppuVar20) {\n      ppuStack_100 = (ulong **)0x14bf75;\n      local_f8 = ppuVar42;\n      param_4 = expand_word_leave_quoted(ppuVar20[1],0);\n      if ((((param_4 == 0) || (*(char ***)(param_4 + 8) == (char **)0x0)) ||\n          (pcVar13 = **(char ***)(param_4 + 8), pcVar13 == (char *)0x0)) || (*pcVar13 == '\\0')) {\n        ppuStack_100 = (ulong **)0x14bfa9;\n        puVar21 = (undefined *)sh_xmalloc(1,ppuVar17,0xe20);\n        *puVar21 = 0;\n      }\n      else {\nLAB_0014c580:\n        ppuStack_100 = (ulong **)0x14c58a;\n        puVar21 = (undefined *)quote_string_for_globbing();\n      }\n      ppuStack_100 = (ulong **)0x14bfe0;\n      iVar11 = strmatch(puVar21,puVar18,\n                        (uint)(extended_glob != 0) << 5 | (uint)(match_ignore_case != 0) << 4);\n      ppuStack_100 = (ulong **)0x14bff3;\n      sh_xfree(puVar21,ppuVar17,0xe28);\n      ppuStack_100 = (ulong **)0x14bffb;\n      dispose_words(param_4);\n      if (iVar11 != 1) {\n        bVar44 = (uint)local_e0 != 0;\n        ppuVar42 = local_f8;\n        goto LAB_0014c865;\n      }\n      if (terminating_signal != 0) {\n        ppuStack_100 = (ulong **)0x14c01e;\n        termsig_handler(terminating_signal);\n      }\n      if (interrupt_state != 0) {\n        ppuStack_100 = (ulong **)0x14c4fd;\n        throw_to_top_level();\n      }\n      ppuVar42 = local_f8;\n    }\n    goto LAB_0014c634;\n  }\n  goto LAB_0014c646;\nLAB_0014c865:\n  if ((ppuVar42[2] != (ulong *)0x0) && (bVar44)) {\n    puVar1 = (uint *)((long)ppuVar42[2] + 4);\n    *puVar1 = *puVar1 | 8;\n  }\n  ppuStack_100 = (ulong **)0x14c87c;\n  uVar12 = execute_command();\n  param_1 = local_d8;\n  ppuVar20 = local_d8;\n  if ((*(uint *)(ppuVar42 + 3) & 1) == 0) goto code_r0x0014c886;\n  ppuVar42 = (ulong **)*ppuVar42;\n  if (ppuVar42 == (ulong **)0x0) {\n    local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar12);\n    goto LAB_0014c646;\n  }\n  goto LAB_0014c865;\ncode_r0x0014c886:\n  local_e8 = (ulong **)CONCAT44(local_e8._4_4_,uVar12);\n  if ((*(uint *)(ppuVar42 + 3) & 2) == 0) goto LAB_0014c646;\nLAB_0014c634:\n  ppuVar42 = (ulong **)*ppuVar42;\n  ppuVar5 = local_d8;\n  ppuVar20 = local_d8;\n  goto joined_r0x0014bf0e;\nLAB_0014c646:\n  local_d8 = ppuVar20;\n  ppuStack_100 = (ulong **)0x14c658;\n  sh_xfree(puVar18,local_f0,0xe40);\n  ppuStack_100 = (ulong **)0x14c664;\n  discard_unwind_frame(\"case\");\nLAB_0014c664:\n  puVar35 = &local_f8;\n  line_number = (uint)local_c0;\n  goto LAB_0014b978;\nLAB_0014ce55:\n  do {\n    if (terminating_signal != 0) {\n      ppuStack_100 = (ulong **)0x14ce6e;\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      ppuStack_100 = (ulong **)0x14ce85;\n      throw_to_top_level();\n    }\n    command_string_index = 0;\n    line_number = *(uint *)((long)puVar40 + 4);\n    ppuStack_100 = (ulong **)0x14cce9;\n    print_for_command_head(puVar40);\n    if (echo_command_at_execute != 0) {\n      ppuStack_100 = (ulong **)0x14ce7b;\n      xtrace_print_for_command_head(puVar40);\n    }\n    ppuStack_100 = (ulong **)0x14cd01;\n    uVar6 = signal_in_progress(0x41);\n    if ((uVar6 | running_trap) == 0) {\n      if (the_printed_command_except_trap != (ulong **)0x0) {\n        ppuStack_100 = (ulong **)0x14cd26;\n        sh_xfree(the_printed_command_except_trap,\"execute_cmd.c\",0xb70);\n      }\n      ppuVar20 = the_printed_command;\n      ppuStack_100 = (ulong **)0x14cd35;\n      sVar14 = strlen((char *)the_printed_command);\n      ppuStack_100 = (ulong **)0x14cd4a;\n      pcVar15 = (char *)sh_xmalloc(sVar14 + 1,\"execute_cmd.c\",0xb71);\n      ppuStack_100 = (ulong **)0x14cd55;\n      the_printed_command_except_trap = (ulong **)strcpy(pcVar15,(char *)ppuVar20);\n    }\n    ppuStack_100 = (ulong **)0x14cd61;\n    iVar11 = run_debug_trap();\n    if ((debugging_mode == 0) || (iVar11 == 0)) {\n      this_command_name = (undefined *)0x0;\n      ppuStack_100 = (ulong **)0x14cd8f;\n      puVar24 = (undefined8 *)find_variable_last_nameref(pcVar13,1);\n      if ((puVar24 == (undefined8 *)0x0) || ((*(byte *)((long)puVar24 + 0x29) & 8) == 0)) {\n        ppuStack_100 = (ulong **)0x14cdb2;\n        puVar24 = (undefined8 *)bind_variable(pcVar13,*(undefined8 *)plVar37[1],0);\nLAB_0014cdb5:\n        if (puVar24 == (undefined8 *)0x0) {\n          line_number = (uint)local_f8;\n        }\n        else {\nLAB_0014cdbe:\n          if ((*(uint *)(puVar24 + 5) & 0x4002) == 0) {\n            if ((((*pcVar13 == 'I') && (pcVar13[1] == 'F')) && (pcVar13[2] == 'S')) &&\n               (pcVar13[3] == '\\0')) {\n              ppuStack_100 = (ulong **)0x14ceee;\n              setifs(puVar24);\n            }\n            else {\n              ppuStack_100 = (ulong **)0x14cde8;\n              stupidly_hack_special_variables(pcVar13);\n            }\n            ppuStack_100 = (ulong **)0x14cdf1;\n            iVar11 = execute_command(puVar40[3]);\n            if ((job_control == 0) || (interactive_shell == 0)) {\n              ppuStack_100 = (ulong **)0x14ce0d;\n              reap_dead_jobs();\n            }\n            if (terminating_signal != 0) {\n              ppuStack_100 = (ulong **)0x14ce9c;\n              termsig_handler(terminating_signal);\n            }\n            if (interrupt_state != 0) {\n              ppuStack_100 = (ulong **)0x14ce8f;\n              throw_to_top_level();\n            }\n            if (breaking != 0) {\n              breaking = breaking - 1;\n              local_e8 = (ulong **)CONCAT44(local_e8._4_4_,iVar11);\n              goto LAB_0014d607;\n            }\n            if ((continuing == 0) || (continuing = continuing + -1, continuing == 0))\n            goto LAB_0014ce48;\n            break;\n          }\n          line_number = (uint)local_f8;\n          if (((*(uint *)(puVar24 + 5) & 2) != 0) &&\n             ((interactive_shell == 0 && (posixly_correct != 0)))) {\nLAB_0014e079:\n            last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n            ppuStack_100 = (ulong **)0x14e083;\n            jump_to_top_level(1);\n          }\n        }\n      }\n      else {\n        ppuStack_100 = (ulong **)0x14ceb2;\n        iVar11 = valid_nameref_value(*(undefined8 *)plVar37[1],1);\n        if (iVar11 != 0) {\n          if ((*(byte *)(puVar24 + 5) & 2) == 0) {\n            ppuStack_100 = (ulong **)0x14cf07;\n            puVar24 = (undefined8 *)bind_variable_value(puVar24,*(undefined8 *)plVar37[1],0x10);\n            goto LAB_0014cdb5;\n          }\n          ppuStack_100 = (ulong **)0x14cec9;\n          err_readonly(*puVar24);\n          goto LAB_0014cdbe;\n        }\n        ppuStack_100 = (ulong **)0x14df80;\n        sh_invalidid(*(undefined8 *)plVar37[1]);\n        line_number = (uint)local_f8;\n      }\n      ppuStack_100 = (ulong **)0x14dd4e;\n      dispose_words(plVar23);\n      ppuStack_100 = (ulong **)0x14dd5a;\n      discard_unwind_frame(&DAT_001fab48);\n      loop_level = loop_level + -1;\n      local_e8 = (ulong **)CONCAT44(local_e8._4_4_,1);\n      puVar35 = &local_f8;\n      goto LAB_0014b978;\n    }\nLAB_0014ce48:\n    plVar37 = (long *)*plVar37;\n  } while (plVar37 != (long *)0x0);\n  local_e8 = (ulong **)CONCAT44(local_e8._4_4_,iVar11);\nLAB_0014d607:\n  loop_level = loop_level + -1;\n  line_number = (uint)local_f8;\n  ppuStack_100 = (ulong **)0x14d61f;\n  dispose_words(plVar23);\n  ppuStack_100 = (ulong **)0x14d62b;\n  discard_unwind_frame(&DAT_001fab48);\n  puVar35 = &local_f8;\nLAB_0014b978:\n  lVar22 = puVar35[5];\n  if (lVar22 == 0) {\n    if (puVar35[9] != 0) goto LAB_0014b9a3;\n  }\n  else {\n    puVar35[-1] = 0x14b993;\n    do_redirections(lVar22,1);\n    puVar35[-1] = 0x14b99b;\n    dispose_redirects(lVar22);\n    if (puVar35[6] != 0) {\nLAB_0014b9a3:\n      puVar35[-1] = 0x14b9ad;\n      dispose_redirects(puVar35[6]);\n    }\n    puVar35[-1] = 0x14b9b9;\n    discard_unwind_frame(\"loop_redirections\");\n  }\n  if (*(int *)((long)puVar35 + 0xa4) != 0) {\n    puVar35[-1] = 0x14c903;\n    uVar12 = num_fifos();\n    *(undefined4 *)(puVar35 + 0x16) = uVar12;\n    if (*(int *)((long)puVar35 + 0x9c) < *(int *)(puVar35 + 0x16)) {\n      puVar35[-1] = 0x14ca71;\n      close_new_fifos(puVar35[8],*(undefined4 *)(puVar35 + 0x14));\n    }\n    puVar35[-1] = 0x14c936;\n    sh_xfree(puVar35[8],\"execute_cmd.c\",0x45d);\n    puVar35[-1] = 0x14c942;\n    discard_unwind_frame(\"internal_fifos\");\n  }\n  if (*(int *)(puVar35 + 0xc) != 0) {\n    *(uint *)(puVar35 + 2) = (uint)(*(int *)(puVar35 + 2) == 0);\n  }\n  if (*(int *)param_1 - 10U < 2) {\n    puVar35[-1] = 0x14c96a;\n    set_pipestatus_from_exit(*(undefined4 *)(puVar35 + 2));\n  }\n  last_command_exit_value = *(uint *)(puVar35 + 2);\n  puVar35[-1] = 0x14b9fd;\n  run_pending_traps();\n  DAT_00242178 = (ulong **)0x0;\n  puVar31 = puVar35;\n  uVar6 = last_command_exit_value;\nLAB_0014b431:\n  puVar33 = puVar31;\n  if (puVar31[0x17] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return (ulong)uVar6;\n  }\nLAB_0014cbbb:\n                    /* WARNING: Subroutine does not return */\n  *(undefined8 *)((long)puVar33 + -8) = 0x14cbc0;\n  __stack_chk_fail();\n}\n\n",
  "strcoll": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcoll(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcoll_00237c28)();\n  return iVar1;\n}\n\n",
  "set_maxchild": "\nvoid set_maxchild(int param_1)\n\n{\n  long lVar1;\n  int *piVar2;\n  long lVar3;\n  \n  lVar3 = (long)DAT_00238720;\n  if (DAT_00238720 < 0) {\n    piVar2 = __errno_location();\n    *piVar2 = 0;\n    DAT_00238720 = getmaxchild();\n    lVar3 = (long)DAT_00238720;\n    if (DAT_00238720 < 0) {\n      if (*piVar2 == 0) {\n        DAT_00238720 = 0x8000;\n        lVar3 = 0x8000;\n      }\n      else {\n        DAT_00238720 = 0x1000;\n        lVar3 = 0x1000;\n      }\n    }\n  }\n  lVar1 = 0x8000;\n  if (param_1 < 0x8001) {\n    lVar1 = (long)param_1;\n  }\n  if ((int)lVar3 <= param_1) {\n    lVar3 = lVar1;\n  }\n  js = lVar3;\n  return;\n}\n\n",
  "ttfd_onechar": "\nvoid ttfd_onechar(int param_1,termios *param_2)\n\n{\n  param_2->c_lflag = param_2->c_lflag & 0xfffffffd | 0x8001;\n  param_2->c_iflag = param_2->c_iflag & 0xffffffbf | 0x100;\n  param_2->c_oflag = param_2->c_oflag & 0xffffffc7 | 5;\n  *(undefined2 *)(param_2->c_cc + 5) = 0x100;\n  tcsetattr(param_1,1,param_2);\n  return;\n}\n\n",
  "FUN_00159fb0": "\nvoid FUN_00159fb0(undefined8 param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined8 *puVar3;\n  \n  iVar2 = 1;\n  if (temporary_env != 0) {\n    iVar2 = *(int *)(temporary_env + 0xc) + 1;\n  }\n  tempvar_list = (undefined8 *)strvec_create(iVar2);\n  lVar1 = temporary_env;\n  tvlist_ind = 0;\n  *tempvar_list = 0;\n  temporary_env = 0;\n  hash_flush(lVar1,param_1);\n  hash_dispose(lVar1);\n  puVar3 = tempvar_list;\n  iVar2 = tvlist_ind;\n  tempvar_list[tvlist_ind] = 0;\n  array_needs_making = 1;\n  if (0 < iVar2) {\n    lVar1 = 0;\n    do {\n      puVar3 = puVar3 + lVar1;\n      lVar1 = lVar1 + 1;\n      stupidly_hack_special_variables(*puVar3);\n      puVar3 = tempvar_list;\n    } while ((int)lVar1 < tvlist_ind);\n  }\n  strvec_dispose();\n  tempvar_list = (undefined8 *)0x0;\n  tvlist_ind = 0;\n  return;\n}\n\n",
  "ttgetattr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ttgetattr(int __fd,termios *__termios_p)\n\n{\n  int iVar1;\n  \n  iVar1 = tcgetattr(__fd,__termios_p);\n  return iVar1;\n}\n\n",
  "towupper": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nwint_t towupper(wint_t __wc)\n\n{\n  wint_t wVar1;\n  \n  wVar1 = (*(code *)PTR_towupper_00237db0)();\n  return wVar1;\n}\n\n",
  "FUN_00184010": "\nvoid FUN_00184010(void)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  long lVar6;\n  \n  puVar2 = DAT_00248390;\n  if (DAT_00248390 == (undefined8 *)0x0) {\n    return;\n  }\n  if (DAT_0024838c < DAT_00248388) {\n    puVar4 = DAT_00248390 + 1;\n    puVar1 = DAT_00248390 + 4;\n    uVar3 = *DAT_00248390;\n    *DAT_00248390 = 0xdfdfdfdfdfdfdfdf;\n    DAT_00248390 = (undefined8 *)uVar3;\n    do {\n      *(undefined *)puVar4 = 0xdf;\n      puVar5 = puVar4 + 1;\n      *(undefined *)((long)puVar4 + 1) = 0xdf;\n      *(undefined *)((long)puVar4 + 2) = 0xdf;\n      *(undefined *)((long)puVar4 + 3) = 0xdf;\n      *(undefined *)((long)puVar4 + 4) = 0xdf;\n      *(undefined *)((long)puVar4 + 5) = 0xdf;\n      *(undefined *)((long)puVar4 + 6) = 0xdf;\n      *(undefined *)((long)puVar4 + 7) = 0xdf;\n      puVar4 = puVar5;\n    } while (puVar5 != puVar1);\n    lVar6 = (long)DAT_0024838c;\n    DAT_0024838c = DAT_0024838c + 1;\n    *(undefined8 **)(uwcache + lVar6 * 8) = puVar2;\n    return;\n  }\n  DAT_00248390 = (undefined8 *)*DAT_00248390;\n  sh_xfree(puVar2,\"unwind_prot.c\",0xf1);\n  return;\n}\n\n",
  "strtol": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = (*(code *)PTR_strtol_00237b50)();\n  return lVar1;\n}\n\n",
  "xtrace_reset": "\nvoid xtrace_reset(void)\n\n{\n  if (-1 < xtrace_fd) {\n    if (xtrace_fp == (FILE *)0x0) {\n      close(xtrace_fd);\n    }\n    else {\n      fflush(xtrace_fp);\n      fclose(xtrace_fp);\n    }\n  }\n  xtrace_fd = 0xffffffff;\n  xtrace_fp = (FILE *)stderr;\n  return;\n}\n\n",
  "FUN_00196050": "\nulong FUN_00196050(undefined8 param_1,int param_2)\n\n{\n  char cVar1;\n  undefined *puVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined4 uVar6;\n  uint uVar7;\n  int iVar8;\n  ulong uVar9;\n  char *__pattern;\n  int iVar10;\n  \n  if (rl_point < rl_end) {\n    cVar1 = *(char *)(rl_line_buffer + rl_point);\n    if ((cVar1 != ' ') && (cVar1 != '\\t')) {\n      cVar1 = *(char *)(rl_line_buffer + 1 + (long)rl_point);\n      if ((cVar1 != ' ') && (cVar1 != '\\t')) {\n        rl_vi_end_word(1,0x45);\n      }\n      rl_point = rl_point + 1;\n    }\n  }\n  iVar8 = rl_point;\n  if (rl_point < 1) {\nLAB_001960c1:\n    if (param_2 != 0x2a) goto LAB_001960ca;\nLAB_00196203:\n    uVar5 = rl_completion_entry_function;\n    uVar4 = rl_attempted_completion_function;\n    uVar3 = rl_ignore_some_completions_function;\n    rl_completion_entry_function = FUN_00192780;\n    rl_attempted_completion_function = 0;\n    uVar7 = rl_complete_internal(0x2a);\n    rl_ignore_some_completions_function = uVar3;\n    rl_attempted_completion_function = uVar4;\n    rl_completion_entry_function = (code *)uVar5;\n  }\n  else {\n    rl_vi_bWord(1,0x42);\n    iVar10 = rl_point;\n    rl_point = iVar8;\n    __pattern = (char *)substring(rl_line_buffer,iVar10,iVar8);\n    if (__pattern == (char *)0x0) goto LAB_001960c1;\n    iVar8 = glob_pattern_p(__pattern,iVar10);\n    if (iVar8 != 1) {\n      rl_explicit_arg = 1;\n    }\n    sh_xfree(__pattern,\"bashline.c\",0xfcf);\n    if (param_2 == 0x2a) goto LAB_00196203;\nLAB_001960ca:\n    uVar5 = rl_completion_entry_function;\n    uVar4 = rl_attempted_completion_function;\n    uVar3 = rl_ignore_some_completions_function;\n    puVar2 = rl_filename_quoting_function;\n    if (param_2 == 0x3d) {\n      rl_completion_entry_function = FUN_00192780;\n      rl_attempted_completion_function = 0;\n      uVar7 = rl_complete_internal(0x3f);\n      rl_ignore_some_completions_function = uVar3;\n      rl_attempted_completion_function = uVar4;\n      rl_completion_entry_function = (code *)uVar5;\n      goto LAB_00196183;\n    }\n    if (param_2 != 0x5c) {\n      uVar9 = rl_complete(0,param_2);\n      return uVar9;\n    }\n    if (rl_editing_mode == 1) {\n      rl_explicit_arg = 1;\n    }\n    rl_filename_quoting_function = FUN_00195af0;\n    uVar6 = rl_completion_mode(FUN_00195580);\n    uVar5 = rl_completion_entry_function;\n    uVar4 = rl_attempted_completion_function;\n    uVar3 = rl_ignore_some_completions_function;\n    rl_attempted_completion_function = 0;\n    rl_completion_entry_function = FUN_00192780;\n    uVar7 = rl_complete_internal(uVar6);\n    rl_filename_quoting_function = puVar2;\n    rl_ignore_some_completions_function = uVar3;\n    rl_attempted_completion_function = uVar4;\n    rl_completion_entry_function = (code *)uVar5;\n  }\n  rl_vi_start_inserting(param_2,1,1);\nLAB_00196183:\n  return (ulong)uVar7;\n}\n\n",
  "rl_timeout_remaining": "\nundefined4 rl_timeout_remaining(int *param_1,int *param_2)\n\n{\n  ulong uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  int *piVar4;\n  long in_FS_OFFSET;\n  timeval local_38;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((DAT_0024b400 | DAT_0024b408) == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    uVar3 = 0xffffffff;\n  }\n  else {\n    iVar2 = gettimeofday(&local_38,(__timezone_ptr_t)0x0);\n    if (iVar2 == 0) {\n      uVar3 = 0;\n      if ((local_38.tv_sec == DAT_0024b400 || local_38.tv_sec < (long)DAT_0024b400) &&\n         ((local_38.tv_sec != DAT_0024b400 || (local_38.tv_usec < (long)DAT_0024b408)))) {\n        if ((param_1 != (int *)0x0) && (param_2 != (int *)0x0)) {\n          *param_1 = (int)DAT_0024b400 - (int)local_38.tv_sec;\n          uVar1 = DAT_0024b408;\n          *param_2 = (int)DAT_0024b408 - (int)local_38.tv_usec;\n          if ((long)uVar1 < local_38.tv_usec) {\n            *param_1 = *param_1 + -1;\n            *param_2 = *param_2 + 1000000;\n          }\n        }\n        uVar3 = 1;\n      }\n    }\n    else {\n      uVar3 = 0xffffffff;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
  "_ITM_deregisterTMCloneTable": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_deregisterTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n",
  "FUN_0015ec90": "\nvoid FUN_0015ec90(uint param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if (((bgpids != 0) && (DAT_0024253c != 0)) && (DAT_00242540 != 0)) {\n    iVar1 = *(int *)(pidstat_table + (ulong)(param_1 & 0xfff) * 4);\n    while( true ) {\n      if (iVar1 == -1) {\n        return;\n      }\n      piVar2 = (int *)((long)iVar1 * 0x10 + bgpids);\n      if (param_1 == piVar2[2]) break;\n      iVar1 = *piVar2;\n      if (*(int *)(pidstat_table + (ulong)(param_1 & 0xfff) * 4) == iVar1) {\n        internal_warning(\"bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next\");\n        return;\n      }\n    }\n    FUN_0015e640(iVar1);\n    DAT_00242540 = DAT_00242540 + -1;\n    return;\n  }\n  return;\n}\n\n",
  "push_token": "\nvoid push_token(undefined4 param_1)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = current_token;\n  DAT_00240d68 = DAT_00240d6c;\n  DAT_00240d6c = DAT_00240d70;\n  current_token = param_1;\n  DAT_00240d70 = uVar1;\n  return;\n}\n\n",
  "phash_create": "\nvoid phash_create(void)\n\n{\n  if (hashed_filenames != 0) {\n    return;\n  }\n  hashed_filenames = hash_create(0x100);\n  return;\n}\n\n",
  "FUN_00194dc0": "\nundefined8 FUN_00194dc0(void)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  lVar1 = FUN_001942c0(rl_line_buffer);\n  if (lVar1 != 0) {\n    lVar2 = alias_expand(lVar1);\n    sh_xfree(lVar1,\"bashline.c\",0xb2c);\n    if (lVar2 != 0) {\n      FUN_00194d10(lVar2);\n      return 0;\n    }\n  }\n  FUN_001934f0();\n  return 1;\n}\n\n",
  "dispose_word_desc": "\nvoid dispose_word_desc(undefined8 *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  long lVar3;\n  \n  iVar2 = DAT_00241ecc;\n  iVar1 = DAT_00241ec8;\n  *param_1 = 0;\n  if (iVar1 <= iVar2) {\n    sh_xfree(param_1,\"dispose_cmd.c\",0x103);\n    return;\n  }\n  *param_1 = 0xdfdfdfdfdfdfdfdf;\n  param_1[1] = 0xdfdfdfdfdfdfdfdf;\n  lVar3 = (long)DAT_00241ecc;\n  DAT_00241ecc = DAT_00241ecc + 1;\n  *(undefined8 **)(wdcache + lVar3 * 8) = param_1;\n  return;\n}\n\n",
  "setup_async_signals": "\nvoid setup_async_signals(void)\n\n{\n  if (job_control != 0) {\n    return;\n  }\n  get_original_signal(2);\n  set_signal_handler(2,1);\n  get_original_signal(3);\n  set_signal_handler(3,1);\n  return;\n}\n\n",
  "array_assign_list": "\nundefined8 array_assign_list(undefined8 param_1,long *param_2)\n\n{\n  long lVar1;\n  \n  if (param_2 != (long *)0x0) {\n    lVar1 = 0;\n    do {\n      array_insert(param_1,lVar1,*(undefined8 *)param_2[1]);\n      param_2 = (long *)*param_2;\n      lVar1 = lVar1 + 1;\n    } while (param_2 != (long *)0x0);\n  }\n  return param_1;\n}\n\n",
  "rl_push_macro_input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid rl_push_macro_input(undefined8 param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  \n  if (_DAT_0024b180 < 0x11) {\n    puVar2 = (undefined8 *)xmalloc(0x18);\n    _DAT_0024b180 = _DAT_0024b180 + 1;\n    puVar1 = puVar2;\n    *puVar2 = DAT_0024b188;\n    DAT_0024b188 = puVar1;\n    rl_readline_state = rl_readline_state | 0x800;\n    *(undefined4 *)(puVar2 + 2) = DAT_0024b1a0;\n    DAT_0024b1a0 = 0;\n    puVar2[1] = rl_executing_macro;\n    rl_executing_macro = param_1;\n    return;\n  }\n  _rl_errmsg(\"maximum macro execution nesting level exceeded\");\n                    /* WARNING: Subroutine does not return */\n  _rl_abort_internal();\n}\n\n",
  "FUN_001b7830": "\nundefined4 FUN_001b7830(undefined4 param_1,long *param_2)\n\n{\n  char cVar1;\n  char *__s1;\n  char cVar2;\n  int iVar3;\n  long lVar4;\n  char *__s2;\n  undefined **ppuVar5;\n  int iVar6;\n  undefined4 local_3c;\n  \n  if (param_2 == (long *)0x0) {\n    local_3c = 0;\n  }\n  else {\n    local_3c = 0;\n    do {\n      ppuVar5 = &PTR_s_assoc_expand_once_00236438;\n      iVar6 = 0;\n      __s2 = \"autocd\";\n      __s1 = *(char **)param_2[1];\n      cVar2 = 'a';\n      cVar1 = *__s1;\n      while( true ) {\n        if (cVar1 == cVar2) {\n          iVar3 = strcmp(__s1,__s2);\n          if (iVar3 == 0) {\n            lVar4 = (long)iVar6;\n            *(undefined4 *)(&PTR_autocd_00236428)[lVar4 * 3] = param_1;\n            if ((code *)(&DAT_00236430)[lVar4 * 3] != (code *)0x0) {\n              (*(code *)(&DAT_00236430)[lVar4 * 3])((&PTR_DAT_00236420)[lVar4 * 3],param_1);\n            }\n            goto LAB_001b78cd;\n          }\n        }\n        __s2 = *ppuVar5;\n        ppuVar5 = ppuVar5 + 3;\n        iVar6 = iVar6 + 1;\n        if (__s2 == (char *)0x0) break;\n        cVar2 = *__s2;\n      }\n      builtin_error(\"%s: invalid shell option name\",__s1);\n      local_3c = 1;\nLAB_001b78cd:\n      param_2 = (long *)*param_2;\n    } while (param_2 != (long *)0x0);\n  }\n  lVar4 = find_variable(\"BASHOPTS\");\n  if (lVar4 != 0) {\n    set_bashopts();\n  }\n  return local_3c;\n}\n\n",
  "sv_tz": "\nvoid sv_tz(void)\n\n{\n  long lVar1;\n  \n  lVar1 = find_variable();\n  if ((lVar1 == 0) || ((*(byte *)(lVar1 + 0x28) & 1) != 0)) {\n    array_needs_making = 1;\n  }\n  else if (array_needs_making == 0) {\n    return;\n  }\n  FUN_00156bc0();\n  tzset();\n  return;\n}\n\n",
  "rl_extend_line_buffer": "\nvoid rl_extend_line_buffer(int param_1)\n\n{\n  if (rl_line_buffer_len <= param_1) {\n    do {\n      rl_line_buffer_len = rl_line_buffer_len + 0x100;\n      rl_line_buffer = xrealloc(rl_line_buffer,(long)rl_line_buffer_len);\n    } while (rl_line_buffer_len <= param_1);\n  }\n  _rl_set_the_line();\n  return;\n}\n\n",
  "FUN_00186e30": "\nulong FUN_00186e30(void)\n\n{\n  byte bVar1;\n  char *pcVar2;\n  ulong uVar3;\n  byte bVar4;\n  int iVar5;\n  byte *pbVar6;\n  long in_FS_OFFSET;\n  undefined auStack_18 [8];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar2 = *(char **)(DAT_00248560 + (long)DAT_0024856c * 8);\n  if (((*pcVar2 == '-') && (bVar4 = pcVar2[1], bVar4 != 0)) && (pcVar2[2] == '\\0')) {\n    pbVar6 = (byte *)((long)DAT_0024856c * 8);\n    if ((0x33 < (byte)(bVar4 - 0x47)) ||\n       ((0xbfb93fc0019a1U >> ((ulong)(bVar4 - 0x47) & 0x3f) & 1) == 0)) goto LAB_00186e66;\n    iVar5 = DAT_0024856c + 1;\n    if (bVar4 != 0x74) {\n      if (DAT_00248568 <= iVar5) {\n        DAT_0024856c = iVar5;\n        FUN_00186440();\n        bVar4 = *pbVar6;\n        if (bVar4 == 0x3d) {\n          bVar4 = pbVar6[1];\n          if (bVar4 == 0) {\n            return 1;\n          }\n        }\n        else {\n          if ((bVar4 & 0xfd) == 0x3c) {\n            return (ulong)(pbVar6[1] == 0);\n          }\n          if (bVar4 != 0x21) {\n            if (bVar4 != 0x2d) {\n              return 0;\n            }\n            bVar4 = pbVar6[1];\n            if (bVar4 == 0) {\n              return 0;\n            }\n            bVar1 = pbVar6[2];\n            if (bVar1 == 0) {\n              return 0;\n            }\n            if (pbVar6[3] != 0) {\n              return 0;\n            }\n            if (bVar1 == 0x74) {\n              if ((byte)(bVar4 + 0x99) < 9) {\n                return (ulong)((uint)(0x1a1L >> (bVar4 + 0x99 & 0x3f)) & 1);\n              }\n              return 0;\n            }\n            if (bVar4 == 0x65) {\n              if (bVar1 != 0x66) {\n                return (ulong)(bVar1 == 0x71);\n              }\n              return 1;\n            }\n            if (bVar1 != 0x65) {\n              return 0;\n            }\n            if (7 < (byte)(bVar4 + 0x99)) {\n              return 0;\n            }\n            return (ulong)((uint)(0xa1L >> (bVar4 + 0x99 & 0x3f)) & 1);\n          }\n          bVar4 = pbVar6[1];\n        }\n        if (bVar4 != 0x3d) {\n          return 0;\n        }\n        return (ulong)(pbVar6[2] == 0);\n      }\n      DAT_0024856c = DAT_0024856c + 2;\n      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n        uVar3 = unary_test(pcVar2,*(undefined8 *)(pbVar6 + DAT_00248560 + 8),0);\n        return uVar3;\n      }\n      goto LAB_00186f76;\n    }\n    if (DAT_00248568 <= iVar5) {\n      DAT_0024856c = iVar5;\n      if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n        uVar3 = unary_test(pcVar2,&DAT_001fea52,0);\n        return uVar3;\n      }\n      goto LAB_00186f76;\n    }\n    DAT_0024856c = iVar5;\n    iVar5 = legal_number(*(undefined8 *)(pbVar6 + DAT_00248560 + 8),auStack_18);\n    if (iVar5 == 0) goto LAB_00186e66;\n    DAT_0024856c = DAT_0024856c + 1;\n    uVar3 = unary_test(pcVar2,*(undefined8 *)(DAT_00248560 + -8 + (long)DAT_0024856c * 8),0);\n  }\n  else {\nLAB_00186e66:\n    uVar3 = 0;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\nLAB_00186f76:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "same_file": "\nundefined8 same_file(char *param_1,char *param_2,stat *param_3,stat *param_4)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  stat local_148;\n  stat local_b8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_3 != (stat *)0x0) ||\n     (iVar1 = stat(param_1,&local_148), param_3 = &local_148, iVar1 == 0)) {\n    if (param_4 == (stat *)0x0) {\n      param_4 = &local_b8;\n      iVar1 = stat(param_2,param_4);\n      if (iVar1 != 0) goto LAB_00141c8e;\n    }\n    if ((param_3->st_dev == param_4->st_dev) &&\n       (uVar2 = 1, *(__dev_t *)((long)param_3 + 8) == param_4->st_ino)) goto LAB_00141c90;\n  }\nLAB_00141c8e:\n  uVar2 = 0;\nLAB_00141c90:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_vi_overstrike_delete": "\nundefined8 rl_vi_overstrike_delete(int param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  \n  if (0 < param_1) {\n    iVar3 = 0;\n    do {\n      while( true ) {\n        iVar1 = rl_point;\n        if (DAT_0024a410 == 0) {\n          rl_ding();\n          goto LAB_001cf868;\n        }\n        iVar2 = rl_do_undo();\n        if (iVar2 != 0) {\n          DAT_0024a410 = DAT_0024a410 + -1;\n        }\n        if (rl_point != iVar1) break;\n        iVar3 = iVar3 + 1;\n        rl_backward_char(1,param_2);\n        if (param_1 == iVar3) goto LAB_001cf868;\n      }\n      iVar3 = iVar3 + 1;\n    } while (param_1 != iVar3);\n  }\nLAB_001cf868:\n  if ((DAT_0024a410 == 0) && (DAT_0024a420 != 0)) {\n    rl_end_undo_group();\n    rl_do_undo();\n    DAT_0024a420 = 0;\n    return 0;\n  }\n  return 0;\n}\n\n",
  "default_tty_job_signals": "\nvoid default_tty_job_signals(void)\n\n{\n  int iVar1;\n  \n  iVar1 = signal_is_trapped(0x14);\n  if (iVar1 == 0) {\n    iVar1 = signal_is_hard_ignored(0x14);\n    if (iVar1 == 0) goto LAB_00161504;\n    set_signal_handler(0x14,1);\n  }\n  else {\nLAB_00161504:\n    set_signal_handler(0x14,0);\n  }\n  iVar1 = signal_is_trapped(0x15);\n  if (iVar1 == 0) {\n    iVar1 = signal_is_hard_ignored(0x15);\n    if (iVar1 != 0) {\n      set_signal_handler(0x15,1);\n      goto LAB_00161538;\n    }\n  }\n  set_signal_handler(0x15,0);\nLAB_00161538:\n  iVar1 = signal_is_trapped(0x16);\n  if (iVar1 == 0) {\n    iVar1 = signal_is_hard_ignored(0x16);\n    if (iVar1 != 0) {\n      set_signal_handler(0x16,1);\n      return;\n    }\n  }\n  set_signal_handler(0x16,0);\n  return;\n}\n\n",
  "test_command": "\nundefined4 test_command(int param_1,char **param_2)\n\n{\n  char *pcVar1;\n  int iVar2;\n  uint uVar3;\n  \n  iVar2 = __sigsetjmp(&DAT_00248580,0);\n  if (iVar2 != 0) {\n    return DAT_00248570;\n  }\n  pcVar1 = *param_2;\n  DAT_00248560 = param_2;\n  if (((pcVar1 == (char *)0x0) || (*pcVar1 != '[')) || (pcVar1[1] != '\\0')) {\n    DAT_0024856c = 1;\n    param_1 = param_1;\n    DAT_00248568 = param_1;\n    if (param_1 < 2) goto LAB_0018775e;\n  }\n  else {\n    param_1 = param_1 + -1;\n    pcVar1 = param_2[param_1];\n    if ((pcVar1 != (char *)0x0) && ((*pcVar1 != ']' || (pcVar1[1] != '\\0')))) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00186410(\"missing `]\\'\",0);\n    }\n    if (param_1 < 2) {\nLAB_0018775e:\n      DAT_00248570 = 1;\n                    /* WARNING: Subroutine does not return */\n      __longjmp_chk(&DAT_00248580,1);\n    }\n  }\n  DAT_00248568 = param_1;\n  DAT_0024856c = 1;\n  iVar2 = DAT_00248568 + -1;\n  if (iVar2 == 3) {\n    uVar3 = FUN_001871c0();\n  }\n  else {\n    if (iVar2 < 4) {\n      if (iVar2 == 1) {\n        DAT_0024856c = 2;\n        uVar3 = (uint)(*param_2[1] != '\\0');\n        goto LAB_00187669;\n      }\n      if (iVar2 == 2) {\nLAB_00187658:\n        uVar3 = FUN_00187140();\n        DAT_0024856c = DAT_00248568;\n        goto LAB_00187669;\n      }\n    }\n    else if (iVar2 == 4) {\n      pcVar1 = param_2[1];\n      if (*pcVar1 == '!') {\n        if (pcVar1[1] == '\\0') {\n          DAT_0024856c = 2;\n          iVar2 = FUN_001871c0();\n          uVar3 = (uint)(iVar2 == 0);\n          goto LAB_001876b0;\n        }\n      }\n      else if (((*pcVar1 == '(') && (pcVar1[1] == '\\0')) &&\n              ((*param_2[4] == ')' && (param_2[4][1] == '\\0')))) {\n        DAT_0024856c = 2;\n        goto LAB_00187658;\n      }\n    }\n    uVar3 = FUN_00187510();\n  }\nLAB_001876b0:\n  if (DAT_0024856c != DAT_00248568) {\n    if ((DAT_0024856c < DAT_00248568) && (*DAT_00248560[DAT_0024856c] == '-')) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00186410(\"syntax error: `%s\\' unexpected\");\n    }\n                    /* WARNING: Subroutine does not return */\n    FUN_00186410(\"too many arguments\",0);\n  }\nLAB_00187669:\n  DAT_00248570 = (uint)(uVar3 == 0);\n                    /* WARNING: Subroutine does not return */\n  __longjmp_chk(&DAT_00248580,1);\n}\n\n",
  "skip_to_delim": "\nulong skip_to_delim(long param_1,uint param_2,undefined8 param_3,uint param_4)\n\n{\n  int iVar1;\n  char cVar2;\n  undefined4 uVar3;\n  mbstate_t mVar4;\n  uint uVar5;\n  int iVar6;\n  size_t sVar7;\n  ulong uVar8;\n  long lVar9;\n  byte bVar10;\n  ulong uVar11;\n  ulong uVar12;\n  undefined *puVar13;\n  ulong uVar14;\n  byte *pbVar15;\n  char *pcVar16;\n  uint uVar17;\n  uint uVar18;\n  uint uVar19;\n  long in_FS_OFFSET;\n  bool bVar20;\n  bool bVar21;\n  uint local_a0;\n  uint local_58;\n  mbstate_t local_54;\n  mbstate_t local_4c;\n  undefined local_43;\n  undefined2 local_42;\n  long local_40;\n  \n  uVar14 = (ulong)param_2;\n  uVar12 = (ulong)(int)param_2;\n  pbVar15 = (byte *)(param_1 + uVar12);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_54.__count = 0;\n  local_54.__value = (_union_27)0x0;\n  sVar7 = strlen((char *)pbVar15);\n  uVar3 = no_longjmp_on_fatal_error;\n  uVar8 = sVar7 + uVar12;\n  if ((param_4 & 1) != 0) {\n    no_longjmp_on_fatal_error = 1;\n  }\n  uVar11 = (ulong)(uint)(int)(char)*pbVar15;\n  uVar5 = param_4 * 4 & 0x400;\n  local_a0 = param_4 & 0x400;\n  if (*pbVar15 != 0) {\n    bVar21 = false;\n    iVar1 = 0;\n    uVar18 = 0;\n    do {\n      while( true ) {\n        mVar4 = local_54;\n        uVar17 = 0;\n        uVar19 = (uint)uVar11;\n        if ((param_4 & 4) != 0) {\n          uVar17 = (uint)(uVar19 == 0x27 || uVar19 == 0x22);\n        }\n        iVar6 = (int)uVar14;\n        bVar10 = (byte)uVar11;\n        if (uVar18 == 0) break;\n        if (locale_mb_cur_max < 2) goto LAB_0016c515;\n        if ((*(uint *)(is_basic_table + (ulong)((uint)(uVar11 >> 5) & 7) * 4) >> (bVar10 & 0x1f) & 1\n            ) != 0) goto LAB_0016c7a0;\n        if ((locale_utf8locale == 0) || (sVar7 = 1, (char)bVar10 < '\\0')) {\nLAB_0016c7c8:\n          mVar4 = local_54;\n          sVar7 = mbrtowc((wchar_t *)0x0,(char *)pbVar15,uVar8 - uVar12,&local_54);\n          if (sVar7 < 0xfffffffffffffffe) {\n            if (sVar7 == 0) goto LAB_0016c515;\n            goto LAB_0016c4eb;\n          }\n          uVar14 = (ulong)(iVar6 + 1);\n          local_54 = mVar4;\n        }\n        else {\nLAB_0016c4eb:\n          uVar14 = (ulong)(uint)(iVar6 + (int)sVar7);\n        }\nLAB_0016c4ee:\n        uVar12 = (ulong)(int)uVar14;\n        uVar18 = 0;\n        pbVar15 = (byte *)(param_1 + uVar12);\n        uVar11 = (ulong)(uint)(int)(char)*pbVar15;\n        if (*pbVar15 == 0) goto LAB_0016c503;\n      }\n      if (uVar19 == 0x5c) {\n        uVar14 = (ulong)(iVar6 + 1U);\n        uVar18 = 1;\n        uVar12 = (ulong)(int)(iVar6 + 1U);\n        local_54 = mVar4;\n      }\n      else if (bVar21) {\n        bVar21 = uVar19 != 0x60;\n        if (locale_mb_cur_max < 2) {\nLAB_0016c64c:\n          uVar14 = (ulong)(iVar6 + 1U);\n          uVar12 = (ulong)(int)(iVar6 + 1U);\n          local_54 = mVar4;\n        }\n        else if ((*(uint *)(is_basic_table + (ulong)((uint)(uVar11 >> 5) & 7) * 4) >>\n                  (bVar10 & 0x1f) & 1) == 0) {\n          if ((locale_utf8locale == 0) || (sVar7 = 1, (char)bVar10 < '\\0')) {\n            sVar7 = mbrtowc((wchar_t *)0x0,(char *)pbVar15,uVar8 - uVar12,&local_54);\n            if (sVar7 < 0xfffffffffffffffe) {\n              if (sVar7 != 0) goto LAB_0016c56e;\n              uVar14 = (ulong)(iVar6 + 1U);\n              uVar12 = (ulong)(int)(iVar6 + 1U);\n            }\n            else {\n              uVar14 = (ulong)(iVar6 + 1U);\n              uVar12 = (ulong)(int)(iVar6 + 1U);\n              local_54 = mVar4;\n            }\n          }\n          else {\nLAB_0016c56e:\n            uVar19 = iVar6 + (int)sVar7;\n            uVar14 = (ulong)uVar19;\n            uVar12 = (ulong)(int)uVar19;\n          }\n        }\n        else {\n          uVar14 = (ulong)(iVar6 + 1U);\n          uVar12 = (ulong)(int)(iVar6 + 1U);\n          local_54 = mVar4;\n        }\n      }\n      else if (uVar19 == 0x60) {\n        uVar14 = (ulong)(iVar6 + 1U);\n        bVar21 = true;\n        uVar12 = (ulong)(int)(iVar6 + 1U);\n        local_54 = mVar4;\n      }\n      else {\n        bVar20 = local_a0 != 0;\n        if ((iVar1 != 0 && uVar19 == 0x3a) && (bVar20)) {\n          iVar1 = iVar1 + -1;\n          goto LAB_0016c64c;\n        }\n        if ((uVar19 == 0x3f) && (bVar20)) {\n          iVar1 = iVar1 + 1;\n          uVar18 = 0;\n          uVar12 = (ulong)(int)(iVar6 + 1U);\n          uVar14 = (ulong)(iVar6 + 1U);\n          local_54 = mVar4;\n        }\n        else {\n          uVar17 = uVar17 | param_4 & 2;\n          if (uVar17 == 0) {\n            lVar9 = mbschr(param_3);\n            uVar11 = uVar11 & 0xff;\n            if (lVar9 != 0) break;\n          }\n          if (((uVar5 == 0) || (iVar6 < 1)) || (*(char *)(param_1 + -1 + uVar12) != '$')) {\n            if (uVar19 != 0x27) goto LAB_0016c5b6;\n            local_4c.__count = 0;\n            local_4c.__value = (_union_27)0x0;\n            uVar14 = (ulong)(iVar6 + 1);\nLAB_0016c698:\n            uVar12 = (ulong)(int)uVar14;\n            pbVar15 = (byte *)(param_1 + uVar12);\n            bVar10 = *pbVar15;\n            if (bVar10 != 0) {\n              while( true ) {\n                mVar4 = local_4c;\n                iVar6 = (int)uVar14;\n                if (bVar10 == 0x27) {\n                  uVar14 = (ulong)(iVar6 + 1U);\n                  uVar18 = 0;\n                  uVar12 = (ulong)(int)(iVar6 + 1U);\n                  goto LAB_0016c478;\n                }\n                if (locale_mb_cur_max < 2) break;\n                if ((*(uint *)(is_basic_table + (ulong)(bVar10 >> 5) * 4) >> (bVar10 & 0x1f) & 1) ==\n                    0) {\n                  if ((locale_utf8locale == 0) || (sVar7 = 1, (char)bVar10 < '\\0')) {\n                    sVar7 = mbrtowc((wchar_t *)0x0,(char *)pbVar15,uVar8 - uVar12,&local_4c);\n                    if (0xfffffffffffffffd < sVar7) {\n                      uVar14 = (ulong)(iVar6 + 1);\n                      local_4c = mVar4;\n                      goto LAB_0016c698;\n                    }\n                    if (sVar7 == 0) break;\n                  }\n                }\n                else {\n                  sVar7 = 1;\n                }\n                uVar18 = iVar6 + (int)sVar7;\n                uVar14 = (ulong)uVar18;\n                uVar12 = (ulong)(int)uVar18;\n                pbVar15 = (byte *)(param_1 + uVar12);\n                bVar10 = *pbVar15;\n                if (bVar10 == 0) goto LAB_0016c710;\n              }\n              uVar14 = (ulong)(iVar6 + 1);\n              goto LAB_0016c698;\n            }\nLAB_0016c710:\n            uVar18 = 0;\n          }\n          else if (uVar19 == 0x27) {\n            iVar6 = FUN_00167020(param_1,uVar8,iVar6 + 1,0x400);\n            uVar18 = 0;\n            uVar12 = (ulong)iVar6;\n            uVar14 = uVar12;\n          }\n          else {\nLAB_0016c5b6:\n            if (uVar19 == 0x22) {\n              iVar6 = FUN_0016a7c0(param_1,uVar8,iVar6 + 1,uVar5);\n              uVar18 = 0;\n              uVar12 = (ulong)iVar6;\n              uVar14 = uVar12;\n            }\n            else {\n              if ((uVar19 == 0x28) && (bVar20)) {\n                local_58 = iVar6 + 1;\n                uVar14 = (ulong)local_58;\n                if (*(char *)(param_1 + (int)local_58) == '\\0') goto LAB_0016c618;\n                puVar13 = &DAT_001fe091;\n                pcVar16 = \")\";\nLAB_0016c5fe:\n                local_58 = iVar6 + 1;\n                FUN_0016b780(param_1,&local_58,puVar13,puVar13,pcVar16,1);\n                uVar14 = (ulong)(int)local_58;\n              }\n              else {\n                if (uVar19 != 0x24) {\n                  if (((param_4 & 0x88) == 0) && ((uVar19 & 0xfffffffd) == 0x3c)) {\n                    if (*(char *)(param_1 + 1 + uVar12) != '(') goto LAB_0016c86f;\n                    local_58 = iVar6 + 2;\n                    uVar14 = (ulong)local_58;\n                    uVar18 = param_4 & 0x88;\n                    if (*(char *)(param_1 + (int)local_58) != '\\0') {\n                      puVar13 = &DAT_001fe096;\n                      if (uVar19 != 0x3c) {\n                        puVar13 = &DAT_001fe099;\n                      }\n                      FUN_0016b780(param_1,&local_58,puVar13,&DAT_001fe091,&DAT_001fc61f,9);\n                      uVar14 = (ulong)(int)local_58;\n                      if (uVar8 <= uVar14) goto LAB_0016cb4f;\n                      if (*(char *)(param_1 + uVar14) != '\\0') {\n                        bVar21 = false;\n                        uVar12 = (ulong)(int)(local_58 + 1);\n                        uVar14 = (ulong)(local_58 + 1);\n                        goto LAB_0016c478;\n                      }\n                    }\n                    goto LAB_0016c618;\n                  }\n                  if ((param_4 & 0x10) != 0) {\nLAB_0016c87a:\n                    if ((extended_glob != 0) && (*(char *)(param_1 + 1 + uVar12) == '(')) {\n                      lVar9 = mbschr(&DAT_001fe09c);\n                      if (lVar9 != 0) {\n                        local_58 = iVar6 + 2;\n                        uVar14 = (ulong)local_58;\n                        if (*(char *)(param_1 + (int)local_58) != '\\0') {\n                          local_42 = 0x28;\n                          local_43 = (char)uVar11;\n                          FUN_0016b780(param_1,&local_58,&local_43,&DAT_001fe091,&DAT_001fc61f,1);\n                          goto LAB_0016cb3c;\n                        }\n                        goto LAB_0016c618;\n                      }\n                    }\n                  }\n                  if (((param_4 >> 6 & 1) != 0) && (uVar19 == 0x5b)) {\n                    local_58 = iVar6 + 1;\n                    uVar14 = (ulong)local_58;\n                    if (*(char *)(param_1 + (int)local_58) != '\\0') {\n                      puVar13 = &DAT_0021404a;\n                      pcVar16 = \"]\";\n                      goto LAB_0016c5fe;\n                    }\n                    goto LAB_0016c618;\n                  }\nLAB_0016c760:\n                  if ((uVar17 == 0) || (lVar9 = mbschr(param_3), lVar9 != 0)) {\n                    if (locale_mb_cur_max < 2) {\nLAB_0016c515:\n                      uVar14 = (ulong)(iVar6 + 1);\n                      goto LAB_0016c4ee;\n                    }\n                    bVar10 = *pbVar15;\n                    if ((*(uint *)(is_basic_table + (ulong)(bVar10 >> 5) * 4) >> (bVar10 & 0x1f) & 1\n                        ) == 0) {\n                      if ((locale_utf8locale == 0) || ((char)bVar10 < '\\0')) goto LAB_0016c7c8;\n                      if (bVar10 == 0) goto LAB_0016c515;\n                    }\nLAB_0016c7a0:\n                    sVar7 = 1;\n                    goto LAB_0016c4eb;\n                  }\n                  break;\n                }\n                cVar2 = *(char *)(param_1 + 1 + uVar12);\n                if (((param_4 & 8) == 0) && (cVar2 == '(')) {\n                  local_58 = iVar6 + 2;\n                  uVar14 = (ulong)local_58;\n                  if (*(char *)(param_1 + (int)local_58) == '\\0') goto LAB_0016c618;\n                  FUN_0016b780(param_1,&local_58,&DAT_001fe090,&DAT_001fe091,&DAT_001fc61f,uVar5 | 9\n                              );\n                }\n                else {\n                  if (cVar2 != '{') {\nLAB_0016c86f:\n                    if ((param_4 & 0x10) != 0) goto LAB_0016c87a;\n                    goto LAB_0016c760;\n                  }\n                  local_58 = iVar6 + 2;\n                  uVar14 = (ulong)local_58;\n                  if (*(char *)(param_1 + (int)local_58) == '\\0') goto LAB_0016c618;\n                  FUN_001691b0(param_1,&local_58,0,1);\n                }\nLAB_0016cb3c:\n                uVar14 = (ulong)(int)local_58;\n                if (uVar8 <= uVar14) {\nLAB_0016cb4f:\n                  uVar14 = uVar8 & 0xffffffff;\n                  goto LAB_0016c618;\n                }\n              }\n              if (*(char *)(param_1 + uVar14) == '\\0') goto LAB_0016c618;\n              uVar19 = (int)uVar14 + 1;\n              uVar18 = 0;\n              uVar12 = (ulong)(int)uVar19;\n              uVar14 = (ulong)uVar19;\n            }\n          }\n        }\n      }\nLAB_0016c478:\n      pbVar15 = (byte *)(param_1 + uVar12);\n      uVar11 = (ulong)(uint)(int)(char)*pbVar15;\n    } while (*pbVar15 != 0);\nLAB_0016c503:\n    uVar14 = uVar14 & 0xffffffff;\n  }\nLAB_0016c618:\n  no_longjmp_on_fatal_error = uVar3;\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar14;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_vi_movement_mode": "\nundefined8 rl_vi_movement_mode(void)\n\n{\n  if (0 < rl_point) {\n    rl_backward_char(1);\n  }\n  _rl_keymap = vi_movement_keymap;\n  _rl_vi_done_inserting();\n  if ((rl_readline_state & 0x400000) == 0) {\n    rl_free_undo_list();\n  }\n  if (_rl_show_mode_in_prompt != 0) {\n    _rl_reset_prompt();\n  }\n  rl_readline_state = rl_readline_state | 0x400000;\n  return 0;\n}\n\n",
  "ttsave": "\nvoid ttsave(void)\n\n{\n  if (DAT_00249ee0 != 0) {\n    return;\n  }\n  tcgetattr(0,(termios *)&DAT_00249f40);\n  tcgetattr(1,(termios *)&DAT_00249f00);\n  DAT_00249ee0 = 1;\n  return;\n}\n\n",
  "FUN_00187990": "\nvoid FUN_00187990(undefined8 *param_1,undefined8 *param_2)\n\n{\n  if (**(char **)*param_1 == **(char **)*param_2) {\n    strcmp(*(char **)*param_1,*(char **)*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "getopts_reset": "\nvoid getopts_reset(undefined4 param_1)\n\n{\n  sh_optind = param_1;\n  sh_badopt = 0;\n  return;\n}\n\n",
  "FUN_00173b20": "\nundefined4 FUN_00173b20(char **param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  size_t sVar3;\n  char *pcVar4;\n  char *pcVar5;\n  undefined8 *puVar6;\n  char *__dest;\n  undefined8 uVar7;\n  long lVar8;\n  undefined4 uVar9;\n  uint uVar10;\n  bool bVar11;\n  \n  if (param_1 == (char **)0x0) {\n    return 0;\n  }\n  pcVar5 = *param_1;\n  if (pcVar5 == (char *)0x0) {\n    return 0;\n  }\n  iVar1 = assignment(pcVar5,0);\n  sVar3 = strlen(pcVar5);\n  pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",0xde4);\n  pcVar5 = strcpy(pcVar4,pcVar5);\n  lVar8 = (long)iVar1;\n  if (pcVar5[lVar8] == '=') {\n    bVar11 = pcVar5[lVar8 + -1] == '+';\n    if (bVar11) {\n      pcVar5[lVar8 + -1] = '\\0';\n    }\n    uVar10 = (uint)bVar11;\n    pcVar5[lVar8] = '\\0';\n    pcVar4 = pcVar5 + lVar8 + 1;\n    if (param_2 == 0) {\nLAB_00173cd5:\n      param_2 = 0;\n      sVar3 = strlen(pcVar4);\n      __dest = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",0xdfd);\n      pcVar4 = strcpy(__dest,pcVar4);\n    }\n    else {\n      if ((*(byte *)((long)param_1 + 9) & 0x80) == 0) {\n        if (*pcVar4 == '\\0') goto LAB_00173cd5;\n        param_2 = 0;\n        pcVar4 = (char *)FUN_001738e0(pcVar4,0,expand_string_assignment);\n      }\n      else {\n        sVar3 = strlen(pcVar4);\n        if (pcVar4[(long)(int)sVar3 + -1] != ')') goto LAB_00173b9d;\n        pcVar4 = (char *)substring(pcVar4,1,(int)sVar3 + -1);\n      }\n      if (pcVar4 == (char *)0x0) goto LAB_00173b9d;\n    }\n  }\n  else {\n    param_2 = 0;\n    uVar10 = 0;\nLAB_00173b9d:\n    pcVar4 = (char *)sh_xmalloc(1,\"subst.c\",0xe02);\n    *pcVar4 = '\\0';\n  }\n  if (echo_command_at_execute != 0) {\n    if (uVar10 == 0) {\n      xtrace_print_assignment(pcVar5,pcVar4,param_2,1);\n    }\n    else {\n      pcVar5[lVar8 + -1] = '+';\n      xtrace_print_assignment(pcVar5,pcVar4,param_2,1);\n      pcVar5[lVar8 + -1] = '\\0';\n    }\n  }\n  lVar8 = mbschr(pcVar5,0x5b);\n  if (lVar8 == 0) {\n    if (param_2 == 0) {\n      puVar6 = (undefined8 *)bind_variable(pcVar5,pcVar4,uVar10);\n      if (puVar6 != (undefined8 *)0x0) goto LAB_00173c38;\nLAB_00173e3a:\n      uVar9 = 0;\n      stupidly_hack_special_variables(pcVar5);\n      goto LAB_00173c67;\n    }\n    uVar2 = *(uint *)(param_1 + 1);\n    if ((uVar2 & 0x10020000) == 0x10020000) {\n      uVar10 = uVar10 | 0x40;\n    }\n    if ((uVar2 & 0x2020000) == 0x20000) {\n      uVar10 = uVar10 | 2;\n    }\n    else if ((uVar2 & 0x2020000) == 0x2020000) {\n      uVar10 = uVar10 | 8;\n    }\n    bVar11 = (uVar2 & 0x400000) != 0;\n    if (bVar11) {\n      uVar10 = uVar10 | 4;\n    }\n    if ((uVar10 & 2) == 0) {\n      if (((uVar10 & 8) == 0) || (variable_context == 0)) goto LAB_00173db1;\n      if (((uVar10 & 0x40) == 0) ||\n         (((puVar6 = (undefined8 *)find_variable(pcVar5), puVar6 == (undefined8 *)0x0 ||\n           (uVar2 = *(uint *)(puVar6 + 5), (uVar2 & 0x20) == 0)) ||\n          (*(int *)((long)puVar6 + 0x2c) != variable_context)))) {\n        puVar6 = (undefined8 *)find_global_variable(pcVar5);\n        if (puVar6 != (undefined8 *)0x0) {\n          uVar2 = *(uint *)(puVar6 + 5);\n          goto LAB_00173eb1;\n        }\n        uVar7 = nameref_transform_name(pcVar5,uVar10);\n        lVar8 = expand_compound_array_assignment(0,pcVar4,uVar10);\n        if (bVar11) {\n          puVar6 = (undefined8 *)make_new_assoc_variable(uVar7);\n        }\n        else {\n          puVar6 = (undefined8 *)make_new_array_variable(uVar7);\n        }\n        goto LAB_001740e8;\n      }\nLAB_00173eb1:\n      if ((uVar2 & 2) != 0) goto LAB_00173eb9;\n      if ((uVar2 & 0x4000) != 0) goto LAB_00173c38;\n      lVar8 = expand_compound_array_assignment(puVar6,pcVar4,uVar10);\n      if (bVar11) {\n        if ((*(byte *)(puVar6 + 5) & 0x40) == 0) {\n          puVar6 = (undefined8 *)convert_var_to_assoc(puVar6);\n          goto LAB_001740e8;\n        }\n      }\n      else if ((*(byte *)(puVar6 + 5) & 4) == 0) {\n        puVar6 = (undefined8 *)convert_var_to_array(puVar6);\nLAB_001740e8:\n        if (puVar6 == (undefined8 *)0x0) {\n          if (lVar8 != 0) {\n            dispose_words(lVar8);\n          }\n          goto LAB_00173e3a;\n        }\n      }\n      assign_compound_array_list(puVar6,lVar8,uVar10);\n      if (lVar8 != 0) {\n        dispose_words(lVar8);\n      }\n      goto LAB_00173c38;\n    }\n    if (variable_context == 0) {\nLAB_00173db1:\n      puVar6 = (undefined8 *)assign_array_from_string(pcVar5,pcVar4,uVar10);\n      if (puVar6 == (undefined8 *)0x0) goto LAB_00173e3a;\n      if ((*(byte *)(puVar6 + 5) & 2) == 0) goto LAB_00173c38;\nLAB_00173eb9:\n      err_readonly(pcVar5);\n      uVar7 = *puVar6;\n    }\n    else {\n      puVar6 = (undefined8 *)find_variable(pcVar5);\n      if (puVar6 == (undefined8 *)0x0) {\n        uVar7 = nameref_transform_name(pcVar5,uVar10);\n        lVar8 = expand_compound_array_assignment(0,pcVar4,uVar10);\n        if (bVar11) {\nLAB_0017416b:\n          puVar6 = (undefined8 *)make_local_assoc_variable(uVar7,0);\n        }\n        else {\nLAB_00173f43:\n          puVar6 = (undefined8 *)make_local_array_variable(uVar7,0);\n        }\n        if (puVar6 == (undefined8 *)0x0) {\n          if (lVar8 != 0) {\n            dispose_words(lVar8);\n          }\n          goto LAB_00173e3a;\n        }\nLAB_00174110:\n        assign_compound_array_list(puVar6,lVar8,uVar10);\n        if (lVar8 != 0) {\n          dispose_words(lVar8);\n        }\n        goto LAB_00173c38;\n      }\n      uVar7 = *puVar6;\n      if ((*(uint *)(puVar6 + 5) & 2) != 0) goto LAB_00173eb9;\n      if ((*(uint *)(puVar6 + 5) & 0x4000) == 0) {\n        lVar8 = expand_compound_array_assignment(puVar6,pcVar4,uVar10);\n        if (bVar11) goto LAB_0017416b;\n        if (((*(byte *)(puVar6 + 5) & 0x44) == 0) ||\n           (*(int *)((long)puVar6 + 0x2c) != variable_context)) goto LAB_00173f43;\n        goto LAB_00174110;\n      }\n    }\n  }\n  else {\n    if (param_2 != 0) {\n      report_error(\"%s: cannot assign list to array member\",pcVar5);\n      sh_xfree(pcVar4,\"subst.c\",0xe1a);\n      sh_xfree(pcVar5,\"subst.c\",0xe1a);\n      return 0;\n    }\n    puVar6 = (undefined8 *)assign_array_element(pcVar5,pcVar4,uVar10 | 0x800,0);\n    if (puVar6 == (undefined8 *)0x0) {\n      sh_xfree(pcVar4,\"subst.c\",0xe1f);\n      sh_xfree(pcVar5,\"subst.c\",0xe1f);\n      return 0;\n    }\nLAB_00173c38:\n    uVar7 = *puVar6;\n  }\n  uVar9 = 0;\n  stupidly_hack_special_variables(uVar7);\n  uVar10 = *(uint *)(puVar6 + 5);\n  if ((uVar10 & 2) == 0) {\n    if ((uVar10 & 0x4000) != 0) {\n      uVar9 = 1;\n      set_exit_status(1);\n      uVar10 = *(uint *)(puVar6 + 5);\n      if ((uVar10 & 0x4000) != 0) goto LAB_00173c67;\n    }\n    uVar9 = 1;\n    *(uint *)(puVar6 + 5) = uVar10 & 0xffffefff;\n  }\nLAB_00173c67:\n  sh_xfree(pcVar4,\"subst.c\",0xe44);\n  sh_xfree(pcVar5,\"subst.c\",0xe44);\n  return uVar9;\n}\n\n",
  "FUN_00187510": "\nuint FUN_00187510(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  \n  uVar1 = FUN_00187300();\n  if ((DAT_0024856c < DAT_00248568) &&\n     (pcVar4 = *(char **)(DAT_00248560 + (long)DAT_0024856c * 8), *pcVar4 == '-')) {\n    if ((pcVar4[1] == 'a') && (pcVar4[2] == '\\0')) {\n      DAT_0024856c = DAT_0024856c + 1;\n      uVar3 = FUN_001874a0();\n      uVar1 = (uint)((int)uVar3 != 0) & (uint)CONCAT71((int7)((ulong)uVar3 >> 8),uVar1 != 0);\n      if (DAT_00248568 <= DAT_0024856c) {\n        return uVar1;\n      }\n      pcVar4 = *(char **)(DAT_00248560 + (long)DAT_0024856c * 8);\n      if (*pcVar4 != '-') {\n        return uVar1;\n      }\n    }\n    if ((pcVar4[1] == 'o') && (pcVar4[2] == '\\0')) {\n      DAT_0024856c = DAT_0024856c + 1;\n      uVar2 = FUN_00187510();\n      uVar1 = (uint)((uVar1 | uVar2) != 0);\n    }\n  }\n  return uVar1;\n}\n\n",
  "map_over": "\nundefined8 map_over(undefined8 param_1,long param_2)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  \n  if (param_2 == 0) {\n    uVar5 = 0;\n  }\n  else {\n    iVar3 = 0;\n    lVar4 = param_2;\n    do {\n      if (*(long *)(lVar4 + 0x20) != 0) {\n        iVar3 = iVar3 + *(int *)(*(long *)(lVar4 + 0x20) + 0xc);\n      }\n      lVar4 = *(long *)(lVar4 + 0x18);\n    } while (lVar4 != 0);\n    uVar5 = 0;\n    if (iVar3 != 0) {\n      puVar1 = (undefined8 *)sh_xmalloc(0x10,\"variables.c\",0x104b);\n      puVar2 = (undefined8 *)sh_xmalloc((long)(iVar3 + 1) << 3,\"variables.c\",0x104c);\n      *(int *)(puVar1 + 1) = iVar3;\n      *puVar1 = puVar2;\n      *(undefined4 *)((long)puVar1 + 0xc) = 0;\n      *puVar2 = 0;\n      do {\n        FUN_00152050(*(undefined8 *)(param_2 + 0x20),param_1,puVar1);\n        param_2 = *(long *)(param_2 + 0x18);\n      } while (param_2 != 0);\n      uVar5 = *puVar1;\n      sh_xfree(puVar1,\"variables.c\",0x1091);\n    }\n  }\n  return uVar5;\n}\n\n",
  "notify_and_cleanup": "\nvoid notify_and_cleanup(void)\n\n{\n  if (DAT_00247660 == 0) {\n    FUN_001628b0();\n    return;\n  }\n  return;\n}\n\n",
  "strvec_to_word_list": "\nlong * strvec_to_word_list(long *param_1,int param_2,int param_3)\n\n{\n  int iVar1;\n  long *plVar2;\n  long *plVar3;\n  int iVar4;\n  long lVar5;\n  \n  if ((param_1 != (long *)0x0) && (*param_1 != 0)) {\n    plVar2 = param_1 + 1;\n    iVar1 = 0;\n    do {\n      iVar4 = iVar1;\n      lVar5 = *plVar2;\n      plVar2 = plVar2 + 1;\n      iVar1 = iVar4 + 1;\n    } while (lVar5 != 0);\n    if (param_3 < iVar1) {\n      plVar2 = (long *)0x0;\n      lVar5 = (long)param_3;\n      do {\n        if (param_2 == 0) {\n          plVar3 = (long *)make_bare_word(&DAT_00213d70);\n          sh_xfree(*plVar3,\"stringvec.c\",0x10a);\n          *plVar3 = param_1[lVar5];\n        }\n        else {\n          plVar3 = (long *)make_bare_word(param_1[lVar5]);\n        }\n        plVar2 = (long *)make_word_list(plVar3,plVar2);\n        iVar1 = (int)lVar5;\n        lVar5 = lVar5 + 1;\n      } while (iVar1 < iVar4);\n      if (plVar2 != (long *)0x0) {\n        if (*plVar2 == 0) {\n          return plVar2;\n        }\n        plVar2 = (long *)list_reverse(plVar2);\n        return plVar2;\n      }\n    }\n  }\n  return (long *)0x0;\n}\n\n",
  "setup_glob_ignore": "\nvoid setup_glob_ignore(void)\n\n{\n  long lVar1;\n  \n  lVar1 = get_string_value();\n  setup_ignore_patterns(&PTR_s_GLOBIGNORE_00238b20);\n  if (DAT_00238b30 == 0) {\n    if (lVar1 == 0) {\n      glob_dot_filenames = 0;\n      return;\n    }\n  }\n  else {\n    glob_dot_filenames = 1;\n  }\n  return;\n}\n\n",
  "_rl_set_insert_mode": "\nvoid _rl_set_insert_mode(undefined4 param_1)\n\n{\n  rl_insert_mode = param_1;\n  return;\n}\n\n",
  "FUN_001495c0": "\nundefined8 FUN_001495c0(char **param_1,long param_2)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *__s;\n  undefined8 *puVar3;\n  long lVar4;\n  \n  iVar1 = check_identifier(param_1,posixly_correct);\n  if (iVar1 == 0) {\n    if ((posixly_correct != 0) && (interactive_shell == 0)) {\n      last_command_exit_value = 2;\n                    /* WARNING: Subroutine does not return */\n      jump_to_top_level(4);\n    }\n  }\n  else {\n    __s = *param_1;\n    pcVar2 = strchr(__s,1);\n    if (pcVar2 != (char *)0x0) {\n      __s = (char *)dequote_escapes(__s);\n      sh_xfree(*param_1,\"execute_cmd.c\",0x17f1);\n      *param_1 = __s;\n    }\n    if (posixly_correct != 0) {\n      lVar4 = find_special_builtin(__s);\n      if (lVar4 != 0) {\n        internal_error(\"`%s\\': is a special builtin\",*param_1);\n        last_command_exit_value = 2;\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level((-(interactive_shell == 0) & 2U) + 2);\n      }\n      __s = *param_1;\n    }\n    puVar3 = (undefined8 *)find_function(__s);\n    if ((puVar3 == (undefined8 *)0x0) || ((*(uint *)(puVar3 + 5) & 0x4002) == 0)) {\n      bind_function_def(*param_1,param_2,1);\n      bind_function(*param_1,*(undefined8 *)(param_2 + 0x10));\n      return 0;\n    }\n    if ((*(uint *)(puVar3 + 5) & 2) != 0) {\n      internal_error(\"%s: readonly function\",*puVar3);\n    }\n  }\n  return 1;\n}\n\n",
  "print_cond_command": "\nvoid print_cond_command(undefined8 param_1)\n\n{\n  FUN_001446d0(&DAT_001fc74e);\n  FUN_00144a20(param_1);\n  FUN_001446d0(&DAT_0020ef86);\n  return;\n}\n\n",
  "signal_in_progress": "\nuint signal_in_progress(int param_1)\n\n{\n  return (&DAT_00247e40)[param_1] & 0x10;\n}\n\n",
  "_INIT_0": "\nvoid _INIT_0(void)\n\n{\n  FUN_001335b0();\n  return;\n}\n\n",
  "sigwinch_sighandler": "\nvoid sigwinch_sighandler(void)\n\n{\n  sigwinch_received = 1;\n  return;\n}\n\n",
  "FUN_001936e0": "\nundefined8 FUN_001936e0(int param_1)\n\n{\n  mbstate_t mVar1;\n  int iVar2;\n  size_t sVar3;\n  undefined8 uVar4;\n  int iVar5;\n  long lVar6;\n  int iVar7;\n  int iVar8;\n  long in_FS_OFFSET;\n  int local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  if (param_1 < 0) {\n    uVar4 = FUN_00193990(-param_1);\n  }\n  else {\n    lVar6 = (long)rl_end;\n    iVar5 = rl_point;\n    if (param_1 == 0) {\nLAB_001937ba:\n      uVar4 = 0;\n      rl_point = iVar5;\n    }\n    else {\n      if (rl_point != 0) {\n        local_4c = param_1;\nLAB_00193740:\n        do {\n          iVar7 = iVar5 + -1;\n          if (1 < locale_mb_cur_max) {\n            if (iVar5 < 1) break;\n            iVar7 = 0;\n            iVar8 = 0;\n            do {\n              mVar1 = local_48;\n              sVar3 = mbrtowc((wchar_t *)0x0,(char *)(iVar8 + rl_line_buffer),lVar6 - iVar8,\n                              &local_48);\n              if (sVar3 < 0xfffffffffffffffe) {\n                if (sVar3 == 0) {\n                  iVar8 = iVar8 + 1;\n                }\n                else {\n                  iVar7 = iVar8;\n                  iVar8 = iVar8 + (int)sVar3;\n                }\n              }\n              else {\n                iVar8 = iVar8 + 1;\n                local_48 = mVar1;\n              }\n            } while (iVar8 < iVar5);\n          }\nLAB_00193758:\n          iVar5 = iVar7;\n          if (0 < iVar5) {\n            while( true ) {\n              iVar7 = iVar5;\n              iVar8 = iVar5;\n              if (((&sh_syntaxtab)[*(byte *)(rl_line_buffer + iVar5)] & 0x2001) == 0)\n              goto LAB_00193855;\n              iVar2 = char_is_quoted(rl_line_buffer,iVar5);\n              if (iVar2 != 0) goto LAB_00193855;\n              if (1 < locale_mb_cur_max) break;\n              iVar5 = iVar5 + -1;\n              if (iVar5 < 1) goto LAB_001937a0;\n            }\n            iVar7 = 0;\n            iVar8 = 0;\n            do {\n              while (mVar1 = local_48,\n                    sVar3 = mbrtowc((wchar_t *)0x0,(char *)(iVar8 + rl_line_buffer),lVar6 - iVar8,\n                                    &local_48), 0xfffffffffffffffd < sVar3) {\n                iVar2 = iVar8 + 1;\n                local_48 = mVar1;\nLAB_001937e1:\n                iVar8 = iVar2;\n                if (iVar5 <= iVar2) goto LAB_00193758;\n              }\n              if (sVar3 != 0) {\n                iVar2 = iVar8 + (int)sVar3;\n                iVar7 = iVar8;\n                goto LAB_001937e1;\n              }\n              iVar8 = iVar8 + 1;\n            } while (iVar8 < iVar5);\n            goto LAB_00193758;\n          }\nLAB_001937a0:\n          if (iVar5 == 0) break;\nLAB_001937b0:\n          local_4c = local_4c + -1;\n          if (local_4c == 0) goto LAB_001937ba;\n        } while( true );\n      }\nLAB_001938f4:\n      rl_point = 0;\n      uVar4 = 0;\n    }\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n  while( true ) {\n    iVar5 = iVar8 + -1;\n    if (1 < locale_mb_cur_max) {\n      iVar5 = 0;\n      iVar7 = 0;\n      do {\n        mVar1 = local_48;\n        sVar3 = mbrtowc((wchar_t *)0x0,(char *)(iVar7 + rl_line_buffer),lVar6 - iVar7,&local_48);\n        if (sVar3 < 0xfffffffffffffffe) {\n          if (sVar3 == 0) {\n            iVar2 = iVar7 + 1;\n          }\n          else {\n            iVar2 = iVar7 + (int)sVar3;\n            iVar5 = iVar7;\n          }\n        }\n        else {\n          iVar2 = iVar7 + 1;\n          local_48 = mVar1;\n        }\n        iVar7 = iVar2;\n      } while (iVar2 < iVar8);\n    }\n    iVar7 = iVar8;\n    iVar8 = iVar5;\n    if (iVar5 < 1) break;\nLAB_00193855:\n    iVar5 = iVar7;\n    if ((((&sh_syntaxtab)[*(byte *)(rl_line_buffer + iVar8)] & 0x2001) != 0) &&\n       (iVar7 = char_is_quoted(rl_line_buffer,iVar8), iVar7 == 0)) goto LAB_001937b0;\n  }\n  local_4c = local_4c + -1;\n  if (local_4c == 0) goto LAB_001937ba;\n  if (iVar5 == 0) goto LAB_001938f4;\n  goto LAB_00193740;\n}\n\n",
  "rl_function_dumper": "\nvoid rl_function_dumper(int param_1)\n\n{\n  char *__s2;\n  char **ppcVar1;\n  int iVar2;\n  char **ppcVar3;\n  long *plVar4;\n  long lVar5;\n  undefined8 *puVar6;\n  char *pcVar7;\n  undefined *puVar8;\n  char **ppcVar9;\n  long *plVar10;\n  \n  ppcVar3 = (char **)rl_funmap_names();\n  fputc(10,rl_outstream);\n  __s2 = *ppcVar3;\n  ppcVar9 = ppcVar3;\n  do {\n    if (__s2 == (char *)0x0) {\n      xfree(ppcVar3);\n      return;\n    }\n    ppcVar9 = ppcVar9 + 1;\n    rl_initialize_funmap();\n    ppcVar1 = (char **)*funmap;\n    puVar6 = funmap;\n    while (ppcVar1 != (char **)0x0) {\n      puVar6 = puVar6 + 1;\n      iVar2 = strcasecmp(*ppcVar1,__s2);\n      if (iVar2 == 0) {\n        pcVar7 = ppcVar1[1];\n        goto LAB_001debd4;\n      }\n      ppcVar1 = (char **)*puVar6;\n    }\n    pcVar7 = (char *)0x0;\nLAB_001debd4:\n    plVar4 = (long *)rl_invoking_keyseqs_in_map(pcVar7,_rl_keymap);\n    if (param_1 == 0) {\n      if (plVar4 != (long *)0x0) {\n        __fprintf_chk(rl_outstream,1,\"%s can be found on \",__s2);\n        lVar5 = *plVar4;\n        plVar10 = plVar4 + 1;\n        if (lVar5 != 0) {\n          do {\n            puVar8 = &DAT_0021366a;\n            if (*plVar10 != 0) {\n              puVar8 = &DAT_0020f034;\n            }\n            __fprintf_chk(rl_outstream,1,\"\\\"%s\\\"%s\",lVar5,puVar8);\n            lVar5 = *plVar10;\n            if (lVar5 == 0) goto LAB_001ded2d;\n            plVar10 = plVar10 + 1;\n          } while (plVar4 + 6 != plVar10);\n          fwrite(&DAT_00213668,1,4,rl_outstream);\nLAB_001ded2d:\n          lVar5 = *plVar4;\n          plVar4 = plVar4 + 1;\n          while (lVar5 != 0) {\n            xfree();\n            lVar5 = *plVar4;\n            plVar4 = plVar4 + 1;\n          }\n        }\n        goto LAB_001dec3e;\n      }\n      __fprintf_chk(rl_outstream,1,\"%s is not bound to any keys\\n\",__s2);\n    }\n    else if (plVar4 == (long *)0x0) {\n      __fprintf_chk(rl_outstream,1,\"# %s (not bound)\\n\",__s2);\n    }\n    else {\n      lVar5 = *plVar4;\n      while (lVar5 != 0) {\n        __fprintf_chk(rl_outstream,1,&DAT_0021362d,lVar5,__s2);\n        xfree(*plVar4);\n        lVar5 = plVar4[1];\n        plVar4 = plVar4 + 1;\n      }\nLAB_001dec3e:\n      xfree();\n    }\n    __s2 = *ppcVar9;\n  } while( true );\n}\n\n",
  "match_pattern_char": "\nbool match_pattern_char(byte *param_1,byte *param_2,uint param_3)\n\n{\n  byte bVar1;\n  byte bVar2;\n  ushort *puVar3;\n  ulong uVar4;\n  ushort **ppuVar5;\n  __int32_t **pp_Var6;\n  byte bVar7;\n  uint uVar8;\n  uint uVar9;\n  ulong uVar10;\n  \n  bVar1 = *param_2;\n  uVar8 = (uint)bVar1;\n  bVar2 = *param_1;\n  uVar10 = (ulong)bVar2;\n  if (bVar1 == 0) {\n    return bVar2 == 0x2a;\n  }\n  bVar7 = bVar2 - 0x21;\n  if (bVar7 < 0x3c) {\n    uVar4 = 1L << (bVar7 & 0x3f);\n    if ((uVar4 & 0x400000040000200) != 0) {\n      return true;\n    }\n    if ((uVar4 & 0x80000401) == 0) {\n      if (bVar7 == 0x3b) {\n        uVar10 = (ulong)param_1[1];\n      }\n      goto LAB_001c3fbf;\n    }\n    if (param_1[1] == 0x28) {\n      return true;\n    }\n    if ((param_3 & 0x10) == 0) {\nLAB_001c4064:\n      uVar9 = (uint)(char)bVar2;\n      goto LAB_001c3ffc;\n    }\n    ppuVar5 = __ctype_b_loc();\n    puVar3 = *ppuVar5;\n    if ((*(byte *)((long)puVar3 + (ulong)bVar1 * 2 + 1) & 1) != 0) {\n      pp_Var6 = __ctype_tolower_loc();\n      uVar8 = (*pp_Var6)[bVar1];\n    }\n    uVar10 = (ulong)(char)bVar2;\n    if ((*(byte *)((long)puVar3 + uVar10 * 2 + 1) & 1) == 0) goto LAB_001c4064;\n  }\n  else {\nLAB_001c3fbf:\n    uVar9 = (uint)uVar10;\n    if ((param_3 & 0x10) == 0) goto LAB_001c3ffc;\n    ppuVar5 = __ctype_b_loc();\n    puVar3 = *ppuVar5;\n    if ((*(byte *)((long)puVar3 + (ulong)bVar1 * 2 + 1) & 1) != 0) {\n      pp_Var6 = __ctype_tolower_loc();\n      uVar8 = (*pp_Var6)[bVar1];\n    }\n    if ((*(byte *)((long)puVar3 + uVar10 * 2 + 1) & 1) == 0) goto LAB_001c3ffc;\n  }\n  pp_Var6 = __ctype_tolower_loc();\n  uVar9 = (*pp_Var6)[uVar10];\nLAB_001c3ffc:\n  return uVar9 == uVar8;\n}\n\n",
  "rl_bind_keyseq_if_unbound": "\nundefined8 rl_bind_keyseq_if_unbound(long param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (param_1 != 0) {\n    uVar1 = FUN_001dbd80(param_1,param_2,_rl_keymap);\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "FUN_00194290": "\nvoid FUN_00194290(undefined8 param_1,undefined8 param_2)\n\n{\n  if (posixly_correct != 0) {\n    FUN_001931e0(param_1,param_2,0,&DAT_001ff38e);\n    return;\n  }\n  FUN_001931e0(param_1,param_2,0,\"fc -e \\\"${VISUAL:-${EDITOR:-vi}}\\\"\");\n  return;\n}\n\n",
  "dispose_partial_redirects": "\nvoid dispose_partial_redirects(void)\n\n{\n  if (redirection_undo_list != 0) {\n    dispose_redirects();\n    redirection_undo_list = 0;\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001518e0": "\nlong FUN_001518e0(long param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = get_directory_stack(0);\n  uVar2 = array_from_word_list(uVar1);\n  array_dispose(*(undefined8 *)(param_1 + 8));\n  dispose_words(uVar1);\n  *(undefined8 *)(param_1 + 8) = uVar2;\n  return param_1;\n}\n\n",
  "FUN_00154e30": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 * FUN_00154e30(undefined8 param_1,char *param_2,long param_3,int param_4,uint param_5)\n\n{\n  char cVar1;\n  code *pcVar2;\n  uint uVar3;\n  int iVar4;\n  undefined8 *puVar5;\n  undefined8 uVar6;\n  long lVar7;\n  undefined2 *puVar8;\n  char *pcVar9;\n  size_t sVar10;\n  size_t sVar11;\n  bool bVar12;\n  \n  if (param_4 == 0) {\n    bVar12 = false;\n    lVar7 = hash_search(param_1,param_3,0);\n    if ((lVar7 == 0) ||\n       (puVar5 = *(undefined8 **)(lVar7 + 0x10), _DAT_002422f8 = param_3,\n       puVar5 == (undefined8 *)0x0)) goto LAB_00154e58;\n    uVar3 = *(uint *)(puVar5 + 5) & 0x1800;\n    if (uVar3 == 0x800) {\n      if (*(long *)(global_variables + 0x20) == param_3) {\n        puVar5 = (undefined8 *)find_global_variable(*puVar5);\n        if ((puVar5 == (undefined8 *)0x0) &&\n           (puVar5 = (undefined8 *)find_variable_last_nameref(param_1,0),\n           puVar5 == (undefined8 *)0x0)) {\n          return (undefined8 *)0x0;\n        }\n        uVar3 = *(uint *)(puVar5 + 5) & 0x1800;\n        goto LAB_00154faf;\n      }\nLAB_00154fba:\n      uVar3 = *(uint *)(puVar5 + 5);\n      if ((uVar3 & 0x800) == 0) {\n        if (puVar5[4] != 0) {\n          if ((uVar3 & 2) == 0) {\n            if ((uVar3 & 0x4000) != 0) {\n              return puVar5;\n            }\n          }\n          else if (((param_5 & 0x20) == 0) || ((uVar3 & 0x4000) != 0)) goto LAB_00155160;\n          if (puVar5[2] != 0) {\n            sh_xfree(puVar5[2],\"variables.c\",0xc60);\n            puVar5[2] = 0;\n          }\n          pcVar9 = param_2;\n          if ((param_5 & 1) != 0) {\n            pcVar9 = (char *)make_variable_value(puVar5,param_2,param_5);\n          }\n          pcVar2 = (code *)puVar5[4];\n          if ((*(uint *)(puVar5 + 5) & 0x40) == 0) {\n            puVar8 = (undefined2 *)0x0;\n            if ((*(uint *)(puVar5 + 5) & 4) != 0) {\n              puVar5 = (undefined8 *)(*pcVar2)(puVar5,pcVar9,0,0);\n              goto LAB_0015504e;\n            }\n          }\n          else {\n            puVar8 = (undefined2 *)sh_xmalloc(2,\"variables.c\",0xc63);\n            *puVar8 = 0x30;\n          }\n          puVar5 = (undefined8 *)(*pcVar2)(puVar5,pcVar9,0xffffffffffffffff,puVar8);\nLAB_0015504e:\n          if (pcVar9 != param_2) {\n            sh_xfree(pcVar9,\"variables.c\",0xc69);\n            return puVar5;\n          }\n          return puVar5;\n        }\nLAB_0015507a:\n        uVar3 = *(uint *)(puVar5 + 5);\n        if ((uVar3 & 2) == 0) goto LAB_00155087;\n        if (((param_5 & 0x20) == 0) || ((uVar3 & 0x4000) != 0)) {\nLAB_00155160:\n          err_readonly(*puVar5);\n          return puVar5;\n        }\n        goto LAB_00155090;\n      }\n      param_1 = puVar5[1];\n      iVar4 = valid_nameref_value(param_1,0);\n      if (iVar4 == 0) {\n        sh_invalidid(param_1);\n        return (undefined8 *)0x0;\n      }\n      iVar4 = valid_array_reference(param_1,0);\n      if (iVar4 == 0) goto LAB_00154e58;\n      lVar7 = array_variable_name(param_1,0,0,0);\n      if (lVar7 != 0) {\n        if (expanding_redir == 0) {\n          bVar12 = (assigning_in_environment | executing_builtin) != 0;\n        }\n        puVar5 = (undefined8 *)FUN_00152c60(lVar7,bVar12);\n        if ((puVar5 != (undefined8 *)0x0) && ((*(byte *)((long)puVar5 + 0x29) & 8) != 0)) {\n          internal_warning(\"%s: removing nameref attribute\",*puVar5);\n          if (puVar5[1] != 0) {\n            sh_xfree(puVar5[1],\"variables.c\",0xc3b);\n          }\n          *(uint *)(puVar5 + 5) = *(uint *)(puVar5 + 5) & 0xfffff7ff;\n          puVar5[1] = 0;\n        }\n      }\n      sh_xfree(lVar7,\"variables.c\",0xc3f);\n      puVar5 = (undefined8 *)assign_array_element(param_1,param_2,param_5 | 0x10,0);\n      if (puVar5 == (undefined8 *)0x0) {\n        return (undefined8 *)0x0;\n      }\n    }\n    else {\nLAB_00154faf:\n      if (uVar3 != 0x1800) goto LAB_00154fba;\n      if (((param_5 & 0x20) != 0) || (param_2 == (char *)0x0)) goto LAB_0015507a;\n      iVar4 = valid_nameref_value(param_2,0);\n      if (iVar4 == 0) {\n        sh_invalidid(param_2);\n        return (undefined8 *)0x0;\n      }\n      uVar3 = *(uint *)(puVar5 + 5);\n      if ((uVar3 & 2) != 0) goto LAB_00155160;\nLAB_00155087:\n      if ((uVar3 & 0x4000) != 0) {\n        return puVar5;\n      }\nLAB_00155090:\n      *(uint *)(puVar5 + 5) = uVar3 & 0xffffefff;\n      if (((param_5 & 1) != 0) && ((uVar3 & 0x4756) == 0)) {\n        if (puVar5[2] != 0) {\n          sh_xfree(puVar5[2],\"variables.c\",0xc7d);\n          puVar5[2] = 0;\n        }\n        pcVar9 = (char *)puVar5[1];\n        sVar11 = 0;\n        if ((((pcVar9 != (char *)0x0) && (*pcVar9 != '\\0')) && (sVar11 = 1, pcVar9[1] != '\\0')) &&\n           (sVar11 = 2, pcVar9[2] != '\\0')) {\n          sVar11 = strlen(pcVar9);\n        }\n        if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\n          lVar7 = 0;\nLAB_00154f20:\n          lVar7 = sh_xrealloc(pcVar9,sVar11 + 8 + lVar7,\"variables.c\",0xbf9);\nLAB_00154f37:\n          strcpy((char *)(lVar7 + sVar11),param_2);\n        }\n        else {\n          if (param_2[1] != '\\0') {\n            if (param_2[2] == '\\0') {\n              lVar7 = 2;\n              goto LAB_00154f20;\n            }\n            sVar10 = strlen(param_2);\n            lVar7 = sh_xrealloc(pcVar9,sVar10 + sVar11 + 8,\"variables.c\",0xbf9);\n            if (sVar10 == 1) goto LAB_00155436;\n            goto LAB_00154f37;\n          }\n          lVar7 = sh_xrealloc(pcVar9,sVar11 + 9,\"variables.c\",0xbf9);\nLAB_00155436:\n          cVar1 = *param_2;\n          *(undefined *)(lVar7 + 1 + sVar11) = 0;\n          *(char *)(lVar7 + sVar11) = cVar1;\n        }\n        iVar4 = mark_modified_vars;\n        uVar3 = *(uint *)(puVar5 + 5);\n        puVar5[1] = lVar7;\n        goto joined_r0x00154f55;\n      }\n      if ((uVar3 & 0x44) == 0) {\n        uVar6 = make_variable_value(puVar5,param_2,param_5);\n      }\n      else {\n        uVar6 = make_array_variable_value(puVar5,0,&DAT_00210deb,param_2,param_5);\n      }\n      if (puVar5[2] != 0) {\n        sh_xfree(puVar5[2],\"variables.c\",0xc91);\n        puVar5[2] = 0;\n      }\n      uVar3 = *(uint *)(puVar5 + 5);\n      if ((uVar3 & 0x40) != 0) {\n        puVar8 = (undefined2 *)sh_xmalloc(2,\"variables.c\",0xc9a);\n        *puVar8 = 0x30;\n        assoc_insert(puVar5[1],puVar8,uVar6);\n        sh_xfree(uVar6,\"variables.c\",0xc9b);\n        uVar3 = *(uint *)(puVar5 + 5);\n        iVar4 = mark_modified_vars;\n        goto joined_r0x00154f55;\n      }\n      lVar7 = puVar5[1];\n      if ((uVar3 & 4) == 0) {\n        if (lVar7 != 0) {\n          sh_xfree(lVar7,\"variables.c\",0xca5);\n          uVar3 = *(uint *)(puVar5 + 5);\n        }\n        puVar5[1] = uVar6;\n        iVar4 = mark_modified_vars;\n        goto joined_r0x00154f55;\n      }\n      array_insert(lVar7,0,uVar6);\n      sh_xfree(uVar6,\"variables.c\",0xca0);\n    }\n  }\n  else {\nLAB_00154e58:\n    puVar5 = (undefined8 *)FUN_00152bf0(param_1,param_3);\n    uVar6 = make_variable_value(puVar5,param_2,param_5);\n    puVar5[1] = uVar6;\n  }\n  uVar3 = *(uint *)(puVar5 + 5);\n  iVar4 = mark_modified_vars;\njoined_r0x00154f55:\n  if (iVar4 == 0) {\n    if ((uVar3 & 1) == 0) {\n      return puVar5;\n    }\n  }\n  else {\n    *(uint *)(puVar5 + 5) = uVar3 | 1;\n  }\n  array_needs_making = 1;\n  return puVar5;\n}\n\n",
  "strcmp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcmp_00237b08)();\n  return iVar1;\n}\n\n",
  "FUN_00152c60": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong FUN_00152c60(undefined8 param_1,uint param_2)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  \n  lVar3 = temporary_env;\n  if (((((param_2 & 1) != 0) || ((expanding_redir == 0 && (subshell_environment != 0)))) &&\n      (temporary_env != 0)) && (lVar2 = hash_search(param_1,temporary_env,0), lVar2 != 0)) {\n    lVar2 = *(long *)(lVar2 + 0x10);\n    _DAT_002422f8 = lVar3;\n    if (lVar2 != 0) {\nLAB_00152cc4:\n      if (*(code **)(lVar2 + 0x18) == (code *)0x0) {\n        return lVar2;\n      }\n                    /* WARNING: Could not recover jumptable at 0x00152cd1. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      lVar3 = (**(code **)(lVar2 + 0x18))();\n      return lVar3;\n    }\n  }\n  lVar3 = shell_variables;\n  if ((param_2 & 2) == 0) {\n    for (; lVar3 != 0; lVar3 = *(long *)(lVar3 + 0x18)) {\n      lVar1 = *(long *)(lVar3 + 0x20);\n      lVar2 = hash_search(param_1,lVar1,0);\n      if ((lVar2 != 0) && (lVar2 = *(long *)(lVar2 + 0x10), _DAT_002422f8 = lVar1, lVar2 != 0))\n      goto LAB_00152cc4;\n    }\n  }\n  else {\n    for (; lVar3 != 0; lVar3 = *(long *)(lVar3 + 0x18)) {\n      lVar1 = *(long *)(lVar3 + 0x20);\n      lVar2 = hash_search(param_1,lVar1,0);\n      if (((lVar2 != 0) && (lVar2 = *(long *)(lVar2 + 0x10), _DAT_002422f8 = lVar1, lVar2 != 0)) &&\n         ((*(byte *)(lVar2 + 0x29) & 0x10) == 0)) goto LAB_00152cc4;\n    }\n  }\n  return 0;\n}\n\n",
  "stdin_redirects": "\nint stdin_redirects(long **param_1)\n\n{\n  ulong uVar1;\n  int iVar2;\n  \n  iVar2 = 0;\n  if (param_1 == (long **)0x0) {\n    return 0;\n  }\n  do {\n    while (((*(byte *)(param_1 + 2) & 1) != 0 || (0xd < *(uint *)(param_1 + 3)))) {\nLAB_0019e170:\n      param_1 = (long **)*param_1;\n      if (param_1 == (long **)0x0) {\n        return iVar2;\n      }\n    }\n    uVar1 = 1L << ((byte)*(uint *)(param_1 + 3) & 0x3f);\n    if ((uVar1 & 0x936) == 0) {\n      if ((uVar1 & 0x2240) != 0) {\n        iVar2 = iVar2 + (uint)(*(int *)(param_1 + 1) == 0);\n      }\n      goto LAB_0019e170;\n    }\n    param_1 = (long **)*param_1;\n    iVar2 = iVar2 + 1;\n    if (param_1 == (long **)0x0) {\n      return iVar2;\n    }\n  } while( true );\n}\n\n",
  "coproc_wclose": "\nvoid coproc_wclose(long param_1,int param_2)\n\n{\n  int __fd;\n  \n  __fd = *(int *)(param_1 + 0x10);\n  if ((-1 < __fd) && (__fd == param_2)) {\n    close(__fd);\n    *(undefined4 *)(param_1 + 0x10) = 0xffffffff;\n    return;\n  }\n  return;\n}\n\n",
  "hash_search": "\nundefined8 * hash_search(char *param_1,long *param_2,uint param_3)\n\n{\n  undefined8 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined8 *puVar5;\n  char cVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  uint local_3c;\n  \n  if ((param_2 == (long *)0x0) || (((param_3 & 2) == 0 && (*(int *)((long)param_2 + 0xc) == 0)))) {\n    puVar5 = (undefined8 *)0x0;\n  }\n  else {\n    uVar7 = 0x811c9dc5;\n    cVar6 = *param_1;\n    cVar2 = cVar6;\n    pcVar8 = param_1;\n    while (cVar2 != '\\0') {\n      pcVar8 = pcVar8 + 1;\n      uVar7 = (int)cVar2 ^ uVar7 * 0x1000193;\n      cVar2 = *pcVar8;\n    }\n    iVar3 = *(int *)(param_2 + 1);\n    local_3c = iVar3 - 1;\n    uVar9 = uVar7 & local_3c;\n    if (*param_2 != 0) {\n      for (puVar5 = *(undefined8 **)(*param_2 + (long)(int)uVar9 * 8); puVar5 != (undefined8 *)0x0;\n          puVar5 = (undefined8 *)*puVar5) {\n        if (((*(uint *)(puVar5 + 3) == uVar7) && (cVar6 == *(char *)puVar5[1])) &&\n           (iVar4 = strcmp((char *)puVar5[1],param_1), iVar4 == 0)) {\n          *(int *)((long)puVar5 + 0x1c) = *(int *)((long)puVar5 + 0x1c) + 1;\n          return puVar5;\n        }\n      }\n    }\n    puVar5 = (undefined8 *)0x0;\n    if ((param_3 & 2) != 0) {\n      if (iVar3 * 2 <= *(int *)((long)param_2 + 0xc)) {\n        if (0 < iVar3 << 2) {\n          FUN_0017fb90(param_2);\n          cVar6 = *param_1;\n          local_3c = *(int *)(param_2 + 1) - 1;\n        }\n        if (cVar6 == '\\0') {\n          uVar7 = 0x811c9dc5;\n        }\n        else {\n          uVar7 = 0x811c9dc5;\n          pcVar8 = param_1;\n          do {\n            pcVar8 = pcVar8 + 1;\n            uVar9 = (uint)cVar6;\n            cVar6 = *pcVar8;\n            uVar7 = uVar9 ^ uVar7 * 0x1000193;\n          } while (cVar6 != '\\0');\n        }\n        uVar9 = uVar7 & local_3c;\n      }\n      puVar5 = (undefined8 *)sh_xmalloc(0x20,\"hashlib.c\",0x118);\n      puVar1 = (undefined8 *)(*param_2 + (long)(int)uVar9 * 8);\n      *puVar5 = *puVar1;\n      *puVar1 = puVar5;\n      puVar5[2] = 0;\n      puVar5[1] = param_1;\n      *(uint *)(puVar5 + 3) = uVar7;\n      *(undefined4 *)((long)puVar5 + 0x1c) = 0;\n      *(int *)((long)param_2 + 0xc) = *(int *)((long)param_2 + 0xc) + 1;\n    }\n  }\n  return puVar5;\n}\n\n",
  "gethostname": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint gethostname(char *__name,size_t __len)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_gethostname_00237dd0)();\n  return iVar1;\n}\n\n",
  "make_builtin_argv": "\nvoid make_builtin_argv(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)strvec_from_word_list(param_1,0,1,param_2);\n  *puVar1 = this_command_name;\n  return;\n}\n\n",
  "imaxdiv": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nimaxdiv_t imaxdiv(intmax_t __numer,intmax_t __denom)\n\n{\n  imaxdiv_t iVar1;\n  \n  iVar1 = (imaxdiv_t)(*(code *)PTR_imaxdiv_00237908)();\n  return iVar1;\n}\n\n",
  "sigaction": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigaction(int __sig,sigaction *__act,sigaction *__oact)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigaction_002378d8)();\n  return iVar1;\n}\n\n",
  "strtod": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ndouble strtod(char *__nptr,char **__endptr)\n\n{\n  double dVar1;\n  \n  dVar1 = (double)(*(code *)PTR_strtod_002378f0)();\n  return dVar1;\n}\n\n",
  "FUN_0013e020": "\nvoid FUN_0013e020(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  uVar1 = FUN_0013d9a0();\n  if (DAT_00240b38 != 0x120) {\n    return;\n  }\n  uVar2 = FUN_0013d9a0();\n  if (DAT_00240b38 == 0x120) {\n    uVar3 = FUN_0013e020();\n    uVar2 = make_cond_node(1,0,uVar2,uVar3);\n  }\n  make_cond_node(1,0,uVar1,uVar2);\n  return;\n}\n\n",
  "array_keys": "\nundefined8 array_keys(undefined8 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  uint uVar1;\n  long lVar2;\n  long lVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  undefined local_3c [4];\n  char *local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = array_variable_name(param_1,0,&local_38,local_3c);\n  if (lVar2 != 0) {\n    lVar3 = find_variable(lVar2);\n    sh_xfree(lVar2,\"arrayfunc.c\",0x5ad);\n    if (lVar3 != 0) {\n      if ((((*local_38 == '@') || (*local_38 == '*')) && (local_38[1] == ']')) &&\n         ((*(long *)(lVar3 + 8) != 0 && (uVar1 = *(uint *)(lVar3 + 0x28), (uVar1 & 0x1000) == 0))))\n      {\n        if ((uVar1 & 0x44) == 0) {\n          uVar4 = make_word(&DAT_00210deb);\n          lVar2 = make_word_list(uVar4,0);\n        }\n        else if ((uVar1 & 0x40) == 0) {\n          lVar2 = array_keys_to_word_list();\n        }\n        else {\n          lVar2 = assoc_keys_to_word_list();\n        }\n        if (lVar2 != 0) {\n          uVar4 = string_list_pos_params((int)*local_38,lVar2,param_2,param_3);\n          dispose_words(lVar2);\n          goto LAB_0018d533;\n        }\n      }\n    }\n  }\n  uVar4 = 0;\nLAB_0018d533:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "set_buffered_stream": "\nundefined8 set_buffered_stream(int param_1,undefined8 param_2)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  \n  puVar1 = (undefined8 *)(DAT_00247f68 + (long)param_1 * 8);\n  uVar2 = *puVar1;\n  *puVar1 = param_2;\n  return uVar2;\n}\n\n",
  "array_slice": "\nundefined8 * array_slice(undefined8 param_1,undefined8 *param_2,undefined8 *param_3)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  undefined8 uVar4;\n  int iVar5;\n  long lVar6;\n  \n  puVar2 = (undefined8 *)array_create();\n  if (param_2 == param_3) {\n    lVar6 = 0;\n    uVar4 = 0;\n  }\n  else {\n    iVar5 = 0;\n    do {\n      iVar5 = iVar5 + 1;\n      puVar3 = (undefined8 *)array_create_element(*param_2,param_2[1]);\n      lVar6 = puVar2[2];\n      lVar1 = *(long *)(lVar6 + 0x18);\n      *(undefined8 **)(lVar1 + 0x10) = puVar3;\n      puVar3[3] = lVar1;\n      *(undefined8 **)(lVar6 + 0x18) = puVar3;\n      puVar3[2] = lVar6;\n      param_2 = (undefined8 *)param_2[2];\n      uVar4 = *puVar3;\n    } while (param_3 != param_2);\n    lVar6 = (long)iVar5;\n  }\n  *puVar2 = uVar4;\n  puVar2[1] = lVar6;\n  return puVar2;\n}\n\n",
  "parser_in_command_position": "\nbool parser_in_command_position(void)\n\n{\n  bool bVar1;\n  int iVar2;\n  \n  bVar1 = true;\n  if (DAT_00240d70 != 0x11a) {\n    if ((parser_state._2_1_ & 8) != 0) {\n      if (0x12e < (int)DAT_00240d70) {\n        return true;\n      }\n      if ((int)DAT_00240d70 < 0x122) {\n        if ((DAT_00240d70 & 0xfffffffd) != 0x3c) {\n          return true;\n        }\n        goto LAB_001364de;\n      }\n      if ((0x1b1fUL >> ((ulong)(DAT_00240d70 - 0x122) & 0x3f) & 1) == 0) {\n        return true;\n      }\n    }\n    bVar1 = false;\n    if (2 < DAT_00240d70 - 0x127) {\nLAB_001364de:\n      iVar2 = FUN_00134c60();\n      return iVar2 != 0;\n    }\n  }\n  return bVar1;\n}\n\n",
  "u32reset": "\nvoid u32reset(void)\n\n{\n  if ((DAT_0024a114 != 0) && (DAT_0024a108 != &DAT_ffffffffffffffff)) {\n    iconv_close(DAT_0024a108);\n    DAT_0024a108 = &DAT_ffffffffffffffff;\n  }\n  DAT_0024a114 = 0;\n  DAT_0024a110 = 0;\n  return;\n}\n\n",
  "setup_history_ignore": "\nvoid setup_history_ignore(void)\n\n{\n  setup_ignore_patterns(&PTR_s_HISTIGNORE_00238d20);\n  return;\n}\n\n",
  "signal_is_ignored": "\nuint signal_is_ignored(int param_1)\n\n{\n  return (&DAT_00247e40)[param_1] & 0x40;\n}\n\n",
  "_rl_is_mbchar_matched": "\nundefined8 _rl_is_mbchar_matched(long param_1,int param_2,int param_3,long param_4,int param_5)\n\n{\n  long lVar1;\n  \n  if (param_3 - param_2 < param_5) {\n    return 0;\n  }\n  if (0 < param_5) {\n    lVar1 = 0;\n    do {\n      if (*(char *)(param_1 + param_2 + lVar1) != *(char *)(param_4 + lVar1)) {\n        return 0;\n      }\n      lVar1 = lVar1 + 1;\n    } while (lVar1 != param_5);\n  }\n  return 1;\n}\n\n",
  "read_tty_cleanup": "\nvoid read_tty_cleanup(void)\n\n{\n  if (DAT_00248c04 == 0) {\n    return;\n  }\n  ttsetattr(DAT_00248bc0,&DAT_00248bc4);\n  DAT_00248c04 = 0;\n  return;\n}\n\n",
  "unbind_global_variable": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid unbind_global_variable(undefined8 param_1)\n\n{\n  long *plVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  \n  lVar5 = global_variables;\n  if (global_variables != 0) {\n    do {\n      uVar2 = *(undefined8 *)(lVar5 + 0x20);\n      lVar3 = hash_search(param_1,uVar2,0);\n      if ((lVar3 != 0) && (_DAT_002422f8 = uVar2, *(long *)(lVar3 + 0x10) != 0)) {\n        if (((*(byte *)(*(long *)(lVar3 + 0x10) + 0x29) & 8) != 0) &&\n           (puVar4 = (undefined8 *)find_variable_nameref(), puVar4 != (undefined8 *)0x0)) {\n          makunbound(*puVar4,shell_variables);\n          return;\n        }\n        break;\n      }\n      plVar1 = (long *)(lVar5 + 0x18);\n      lVar5 = *plVar1;\n    } while (*plVar1 != 0);\n  }\n  makunbound(param_1,global_variables);\n  return;\n}\n\n",
  "reset_completer_word_break_chars": "\nvoid reset_completer_word_break_chars(void)\n\n{\n  if (perform_hostname_completion != 0) {\n    rl_completer_word_break_characters = (undefined8 *)sh_xmalloc(0xf,\"bashline.c\",0x171);\n    *rl_completer_word_break_characters = 0x3c3e4027220a0920;\n    *(undefined4 *)(rl_completer_word_break_characters + 1) = 0x267c3b3d;\n    *(undefined2 *)((long)rl_completer_word_break_characters + 0xc) = 0x3a28;\n    *(undefined *)((long)rl_completer_word_break_characters + 0xe) = 0;\n    return;\n  }\n  rl_completer_word_break_characters = (undefined8 *)sh_xmalloc(0xe,\"bashline.c\",0x171);\n  *rl_completer_word_break_characters = 0x3d3c3e27220a0920;\n  *(undefined4 *)(rl_completer_word_break_characters + 1) = 0x28267c3b;\n  *(undefined2 *)((long)rl_completer_word_break_characters + 0xc) = 0x3a;\n  return;\n}\n\n",
  "assoc_patsub": "\nundefined8 assoc_patsub(long param_1,undefined8 param_2,undefined8 param_3,uint param_4)\n\n{\n  long *plVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  if (((param_1 == 0) || (*(int *)(param_1 + 0xc) == 0)) ||\n     (plVar1 = (long *)FUN_0018d590(param_1,0), plVar5 = plVar1, plVar1 == (long *)0x0)) {\n    uVar3 = 0;\n  }\n  else {\n    do {\n      lVar2 = pat_subst(*(undefined8 *)plVar5[1],param_2,param_3,param_4);\n      plVar4 = (long *)plVar5[1];\n      if (*plVar4 != 0) {\n        sh_xfree(*plVar4,\"assoc.c\",0x142);\n        plVar4 = (long *)plVar5[1];\n      }\n      plVar5 = (long *)*plVar5;\n      *plVar4 = lVar2;\n    } while (plVar5 != (long *)0x0);\n    uVar3 = string_list_pos_params\n                      ((-((param_4 & 0x80) == 0) & 0x16U) + 0x2a,plVar1,(int)param_4 >> 5 & 1,\n                       (int)param_4 >> 3 & 8);\n    dispose_words(plVar1);\n  }\n  return uVar3;\n}\n\n",
  "coproc_init": "\nvoid coproc_init(undefined8 *param_1)\n\n{\n  *param_1 = 0;\n  param_1[1] = 0xffffffffffffffff;\n  param_1[2] = 0xffffffffffffffff;\n  param_1[3] = 0xffffffff;\n  param_1[4] = 0;\n  return;\n}\n\n",
  "FUN_001b1a00": "\nint FUN_001b1a00(int param_1,char *param_2)\n\n{\n  if (param_1 == 0x2d) {\n    rl_variable_bind(\"editing-mode\");\n    if (interactive != 0) {\n      with_input_from_stdin();\n    }\n    no_line_editing = 0;\n    return 1;\n  }\n  if (rl_editing_mode == 1) {\n    if (*param_2 == 'e') goto LAB_001b1a34;\n  }\n  else if (*param_2 == 'v') {\nLAB_001b1a34:\n    if (interactive != 0) {\n      with_input_from_stream(stdin,\"stdin\");\n    }\n    no_line_editing = 1;\n    return 0;\n  }\n  return 1 - no_line_editing;\n}\n\n",
  "_rl_copy_undo_list": "\nundefined8 * _rl_copy_undo_list(long *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  \n  if (param_1 == (long *)0x0) {\n    puVar4 = (undefined8 *)0x0;\n  }\n  else {\n    puVar2 = (undefined8 *)_rl_copy_undo_entry();\n    puVar1 = puVar2;\n    while (puVar4 = puVar1, puVar3 = puVar2, param_1 = (long *)*param_1, param_1 != (long *)0x0) {\n      puVar2 = (undefined8 *)_rl_copy_undo_entry(param_1);\n      puVar1 = puVar2;\n      if (puVar4 != (undefined8 *)0x0) {\n        *puVar3 = puVar2;\n        puVar1 = puVar4;\n      }\n    }\n    *puVar3 = 0;\n  }\n  return puVar4;\n}\n\n",
  "rl_backward_char": "\nundefined8 rl_backward_char(int param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  undefined8 uVar3;\n  \n  sVar2 = __ctype_get_mb_cur_max();\n  if ((sVar2 == 1) || (rl_byte_oriented != 0)) {\n    uVar3 = rl_backward_byte(param_1,param_2);\n    return uVar3;\n  }\n  if (param_1 < 0) {\n    uVar3 = rl_forward_char(-param_1,param_2);\n    return uVar3;\n  }\n  if (param_1 != 0) {\n    iVar1 = rl_point;\n    if (0 < rl_point) {\n      do {\n        param_1 = param_1 + -1;\n        iVar1 = _rl_find_prev_mbchar(rl_line_buffer,iVar1,1);\n        if (param_1 < 1) break;\n      } while (0 < iVar1);\n      if (param_1 == 0) {\n        rl_point = iVar1;\n        return 0;\n      }\n    }\n    rl_point = 0;\n    rl_ding();\n  }\n  return 0;\n}\n\n",
  "multimeval": "\nlong * multimeval(long *param_1,int param_2)\n\n{\n  long lVar1;\n  \n  lVar1 = param_1[1] * (long)param_2;\n  *param_1 = (long)param_2 * *param_1 + lVar1 / 1000000;\n  param_1[1] = lVar1 % 1000000;\n  return param_1;\n}\n\n",
  "FUN_00152460": "\nlong FUN_00152460(long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = history_number();\n  uVar2 = itos((long)(iVar1 - executing));\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x527);\n  }\n  *(undefined8 *)(param_1 + 8) = uVar2;\n  return param_1;\n}\n\n",
  "FUN_00194a70": "\nundefined8 FUN_00194a70(void)\n\n{\n  int iVar1;\n  \n  if (sigterm_received != 0) {\n    return 0;\n  }\n  iVar1 = terminating_signal;\n  if ((terminating_signal != 0) || (iVar1 = 2, interrupt_state != 0)) goto LAB_00194a97;\n  iVar1 = 0xe;\n  if (read_timeout == 0) {\n    if ((rl_readline_state & 0x4000000) != 0) goto LAB_00194a97;\n  }\n  else {\n    if (*(int *)(read_timeout + 0x18) != 0) goto LAB_00194a97;\n    if ((rl_readline_state & 0x4000000) != 0) {\n      *(undefined4 *)(read_timeout + 0x18) = 1;\n      goto LAB_00194a97;\n    }\n  }\n  iVar1 = first_pending_trap();\nLAB_00194a97:\n  if (((terminating_signal != 0) || (interrupt_state != 0)) ||\n     ((read_timeout != 0 && (*(int *)(read_timeout + 0x18) != 0)))) {\n    rl_cleanup_after_signal();\n  }\n  rl_readline_state = rl_readline_state & 0xfffffffffbffffff;\n  rl_signal_event_hook = 0;\n  if (((posixly_correct != 0) && (this_shell_builtin == read_builtin)) && (iVar1 == 2)) {\n    last_command_exit_value = 0x82;\n    throw_to_top_level();\n  }\n  check_signals_and_traps();\n  return 0;\n}\n\n",
  "get_string_value": "\nundefined8 get_string_value(void)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = find_variable();\n  if (lVar1 != 0) {\n    uVar2 = get_variable_value(lVar1);\n    return uVar2;\n  }\n  return 0;\n}\n\n",
  "print_for_command_head": "\nvoid print_for_command_head(long param_1)\n\n{\n  long **pplVar1;\n  undefined *puVar2;\n  \n  FUN_001446d0(\"for %s in \",**(undefined8 **)(param_1 + 8));\n  for (pplVar1 = *(long ***)(param_1 + 0x10); pplVar1 != (long **)0x0; pplVar1 = (long **)*pplVar1)\n  {\n    puVar2 = &DAT_00213d70;\n    if (*pplVar1 != (long *)0x0) {\n      puVar2 = &DAT_001fdb1c;\n    }\n    FUN_001446d0(&DAT_001fc632,*pplVar1[1],puVar2);\n  }\n  return;\n}\n\n",
  "dirspell": "\nvoid * dirspell(char *param_1)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  void *__ptr;\n  \n  sVar2 = strlen(param_1);\n  __ptr = malloc((long)((int)(sVar2 * 3 + 1 >> 1) + 1));\n  if (__ptr != (void *)0x0) {\n    uVar1 = spname(param_1,__ptr);\n    if (1 < uVar1) {\n      free(__ptr);\n      return (void *)0x0;\n    }\n  }\n  return __ptr;\n}\n\n",
  "sh_realpath": "\nchar * sh_realpath(char *param_1,char *param_2)\n\n{\n  long lVar1;\n  char *pcVar2;\n  char *__src;\n  size_t sVar3;\n  int *piVar4;\n  int iVar5;\n  \n  if (param_1 == (char *)0x0) {\n    iVar5 = 0x16;\n  }\n  else {\n    iVar5 = 2;\n    if (*param_1 != '\\0') {\n      if (*param_1 == '/') {\n        sVar3 = strlen(param_1);\n        pcVar2 = (char *)sh_xmalloc(sVar3 + 1,\"pathphys.c\",0x114);\n        pcVar2 = strcpy(pcVar2,param_1);\n      }\n      else {\n        lVar1 = get_working_directory(\"sh_realpath\");\n        if (lVar1 == 0) {\n          return (char *)0x0;\n        }\n        pcVar2 = (char *)sh_makepath(lVar1,param_1,0);\n        sh_xfree(lVar1,\"pathphys.c\",0x111);\n      }\n      __src = (char *)sh_physpath(pcVar2,0);\n      sh_xfree(pcVar2,\"pathphys.c\",0x117);\n      if (param_2 != (char *)0x0) {\n        if (__src == (char *)0x0) {\n          *param_2 = '\\0';\n          return (char *)0x0;\n        }\n        strncpy(param_2,__src,0xfff);\n        param_2[0xfff] = '\\0';\n        sh_xfree(__src,\"pathphys.c\",0x120);\n        __src = param_2;\n      }\n      return __src;\n    }\n  }\n  piVar4 = __errno_location();\n  *piVar4 = iVar5;\n  return (char *)0x0;\n}\n\n",
  "FUN_001518c0": "\nundefined8 FUN_001518c0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  set_dirstack_element(param_3,1,param_2);\n  return param_1;\n}\n\n",
  "tcgetpgrp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__pid_t tcgetpgrp(int __fd)\n\n{\n  __pid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_tcgetpgrp_00237bc0)();\n  return _Var1;\n}\n\n",
  "FUN_001da660": "\nundefined8 FUN_001da660(char *param_1)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  \n  uVar2 = 500;\n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    uVar1 = strtol(param_1,(char **)0x0,10);\n    uVar2 = uVar1 & 0xffffffff;\n    if ((int)uVar1 < 0) {\n      unstifle_history();\n      return 0;\n    }\n  }\n  stifle_history(uVar2);\n  return 0;\n}\n\n",
  "FUN_001b6930": "\nundefined FUN_001b6930(undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined uVar3;\n  \n  iVar1 = legal_identifier();\n  if (iVar1 != 0) {\n    lVar2 = bind_variable(param_1,param_2,0);\n    if ((lVar2 == 0) || (uVar3 = 2, (*(uint *)(lVar2 + 0x28) & 0x4002) == 0)) {\n      uVar3 = lVar2 == 0;\n    }\n    return uVar3;\n  }\n  sh_invalidid(param_1);\n  return 1;\n}\n\n",
  "set_trap_state": "\nvoid set_trap_state(int param_1)\n\n{\n  trapped_signal_received = param_1;\n  *(int *)(pending_traps + (long)param_1 * 4) = *(int *)(pending_traps + (long)param_1 * 4) + 1;\n  DAT_00247e28 = 1;\n  return;\n}\n\n",
  "fifos_pending": "\nundefined8 fifos_pending(void)\n\n{\n  return 0;\n}\n\n",
  "bind_variable": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid bind_variable(undefined8 param_1,char *param_2,undefined4 param_3)\n\n{\n  long *plVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  long lVar4;\n  size_t sVar5;\n  char *pcVar6;\n  long lVar7;\n  undefined8 *puVar8;\n  undefined8 uVar9;\n  undefined8 *puVar10;\n  long lVar11;\n  \n  if (shell_variables == 0) {\n    FUN_00152b20();\n    if ((temporary_env != 0) && (param_2 != (char *)0x0)) goto LAB_00155590;\nLAB_0015561c:\n    if (shell_variables == 0) goto LAB_00155780;\n  }\n  else if ((temporary_env != 0) && (param_2 != (char *)0x0)) {\nLAB_00155590:\n    lVar11 = temporary_env;\n    lVar4 = hash_search(param_1,temporary_env,0);\n    if ((lVar4 != 0) && (lVar4 = *(long *)(lVar4 + 0x10), _DAT_002422f8 = lVar11, lVar4 != 0)) {\n      if (*(long *)(lVar4 + 8) != 0) {\n        sh_xfree(*(long *)(lVar4 + 8),\"variables.c\",0x11af);\n      }\n      sVar5 = strlen(param_2);\n      pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"variables.c\",0x11b0);\n      pcVar6 = strcpy(pcVar6,param_2);\n      *(char **)(lVar4 + 8) = pcVar6;\n      if (*(long *)(lVar4 + 0x10) != 0) {\n        sh_xfree(*(long *)(lVar4 + 0x10),\"variables.c\",0x11b1);\n        *(undefined8 *)(lVar4 + 0x10) = 0;\n      }\n    }\n    goto LAB_0015561c;\n  }\n  lVar11 = shell_variables;\n  do {\n    if ((*(byte *)(lVar11 + 0xc) & 0xc) != 0) {\n      lVar4 = *(long *)(lVar11 + 0x20);\n      lVar7 = hash_search(param_1,lVar4,0);\n      if ((lVar7 != 0) &&\n         (puVar2 = *(undefined8 **)(lVar7 + 0x10), _DAT_002422f8 = lVar4,\n         puVar2 != (undefined8 *)0x0)) {\n        puVar8 = puVar2;\n        lVar4 = lVar11;\n        lVar7 = lVar11;\n        puVar10 = puVar2;\n        if ((*(byte *)((long)puVar2 + 0x29) & 8) != 0) {\n          do {\n            puVar8 = (undefined8 *)FUN_00152830(puVar10,lVar7);\n            if (puVar8 == (undefined8 *)&DAT_00242300) goto LAB_001557c0;\n            if ((puVar8 != (undefined8 *)0x0) &&\n               (lVar4 = lVar7, puVar10 = puVar8, (*(byte *)((long)puVar8 + 0x29) & 8) == 0))\n            goto LAB_0015567a;\n            puVar8 = puVar10;\n            plVar1 = (long *)(lVar7 + 0x18);\n            lVar7 = *plVar1;\n            puVar10 = puVar8;\n          } while (*plVar1 != 0);\n          puVar10 = puVar2;\n          lVar7 = lVar11;\n          if ((*(byte *)((long)puVar8 + 0x29) & 8) != 0) {\n            do {\n              puVar8 = (undefined8 *)FUN_00152830(puVar10,lVar7);\n              if (puVar8 == (undefined8 *)&DAT_00242300) {\n                puVar10 = (undefined8 *)&DAT_00242300;\n                if ((DAT_00242329 & 8) != 0) goto LAB_00155723;\n                goto LAB_001557c0;\n              }\n              if (puVar8 != (undefined8 *)0x0) {\n                lVar4 = lVar7;\n              }\n              plVar1 = (long *)(lVar7 + 0x18);\n              if (puVar8 != (undefined8 *)0x0) {\n                puVar10 = puVar8;\n              }\n              lVar7 = *plVar1;\n            } while (*plVar1 != 0);\n            if ((*(byte *)((long)puVar10 + 0x29) & 8) == 0) goto LAB_00155638;\nLAB_00155723:\n            if (puVar10[1] == 0) {\n              uVar9 = *(undefined8 *)(lVar4 + 0x20);\n              param_1 = *puVar10;\n            }\n            else {\n              iVar3 = valid_array_reference(puVar10[1],0);\n              if (iVar3 != 0) {\n                assign_array_element(puVar10[1],param_2,param_3,0);\n                return;\n              }\n              uVar9 = *(undefined8 *)(lVar4 + 0x20);\n              param_1 = puVar10[1];\n            }\n            goto LAB_0015568d;\n          }\n          if (puVar8 == (undefined8 *)&DAT_00242300) {\nLAB_001557c0:\n            internal_warning(\"%s: circular name reference\",*puVar2);\n            param_1 = *puVar2;\n            if (shell_variables == 0) {\n              FUN_00152b20();\n            }\n            uVar9 = *(undefined8 *)(global_variables + 0x20);\n            goto LAB_0015568d;\n          }\n        }\nLAB_0015567a:\n        uVar9 = *(undefined8 *)(lVar4 + 0x20);\n        param_1 = *puVar8;\n        goto LAB_0015568d;\n      }\n    }\nLAB_00155638:\n    lVar11 = *(long *)(lVar11 + 0x18);\n  } while (lVar11 != 0);\nLAB_00155780:\n  uVar9 = *(undefined8 *)(global_variables + 0x20);\nLAB_0015568d:\n  FUN_00154e30(param_1,param_2,uVar9,0,param_3);\n  return;\n}\n\n",
  "bind_array_variable": "\nundefined1 *\nbind_array_variable(undefined8 param_1,undefined8 param_2,undefined8 param_3,uint param_4)\n\n{\n  uint uVar1;\n  undefined1 *puVar2;\n  \n  puVar2 = (undefined1 *)find_shell_variable();\n  if (puVar2 == (undefined1 *)0x0) {\n    puVar2 = (undefined1 *)find_variable_nameref_for_create(param_1,0);\n    if (puVar2 == nameref_invalid_value) {\n      return (undefined1 *)0x0;\n    }\n    if (puVar2 != (undefined1 *)0x0) {\n      uVar1 = *(uint *)(puVar2 + 0x28);\n      if ((uVar1 & 0x800) == 0) goto LAB_0018a9f7;\n      puVar2 = (undefined1 *)make_new_array_variable(*(undefined8 *)(puVar2 + 8));\n      if (puVar2 != (undefined1 *)0x0) goto LAB_0018a9f4;\n    }\n    puVar2 = (undefined1 *)make_new_array_variable(param_1);\n  }\n  else {\nLAB_0018a9f4:\n    uVar1 = *(uint *)(puVar2 + 0x28);\nLAB_0018a9f7:\n    if ((uVar1 & 2) == 0) {\n      if ((uVar1 & 0x4000) != 0) {\n        return puVar2;\n      }\n    }\n    else if (((param_4 & 0x20) == 0) || ((uVar1 & 0x4000) != 0)) {\n      err_readonly(param_1);\n      return puVar2;\n    }\n    if ((uVar1 & 4) == 0) {\n      puVar2 = (undefined1 *)convert_var_to_array(puVar2);\n    }\n  }\n  puVar2 = (undefined1 *)FUN_0018a8b0(puVar2,param_2,0,param_3,param_4);\n  return puVar2;\n}\n\n",
  "qsort": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)\n\n{\n  (*(code *)PTR_qsort_002378c8)();\n  return;\n}\n\n",
  "__mbstowcs_chk": "\nvoid __mbstowcs_chk(void)\n\n{\n  (*(code *)PTR___mbstowcs_chk_002378a8)();\n  return;\n}\n\n",
  "array_to_kvpair": "\nundefined * array_to_kvpair(long param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined *puVar3;\n  char *__s;\n  char *__s_00;\n  size_t sVar4;\n  long lVar5;\n  undefined *puVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  undefined2 *__dest;\n  undefined8 *puVar10;\n  long in_FS_OFFSET;\n  undefined local_58 [24];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    puVar3 = (undefined *)0x0;\n  }\n  else {\n    puVar3 = (undefined *)0x0;\n    if (*(long *)(param_1 + 8) != 0) {\n      puVar3 = (undefined *)sh_xmalloc(0x80,\"array.c\",0x3c4);\n      *puVar3 = 0;\n      puVar10 = (undefined8 *)(*(undefined8 **)(param_1 + 0x10))[2];\n      puVar6 = puVar3;\n      if (*(undefined8 **)(param_1 + 0x10) != puVar10) {\n        iVar9 = 0;\n        iVar8 = 0x80;\n        do {\n          __s = (char *)inttostr(*puVar10,local_58,0x16);\n          if (puVar10[1] == 0) {\n            iVar2 = 9;\n            __s_00 = (char *)0x0;\n            if (__s != (char *)0x0) {\n              if (*__s == '\\0') {\n                iVar7 = 8;\n              }\n              else {\n                if (__s[1] != '\\0') goto LAB_00189ec7;\n                iVar7 = 9;\n              }\n              goto LAB_00189f3d;\n            }\n          }\n          else {\n            iVar2 = ansic_shouldquote(puVar10[1]);\n            if (iVar2 == 0) {\n              __s_00 = (char *)sh_double_quote(puVar10[1]);\n            }\n            else {\n              __s_00 = (char *)ansic_quote(puVar10[1],0,0);\n            }\n            iVar7 = 8;\n            if (((__s != (char *)0x0) && (*__s != '\\0')) && (iVar7 = 9, __s[1] != '\\0')) {\nLAB_00189ec7:\n              iVar7 = 10;\n              if (__s[2] != '\\0') {\n                sVar4 = strlen(__s);\n                iVar7 = (int)sVar4 + 8;\n              }\n            }\n            if (__s_00 == (char *)0x0) {\nLAB_00189f3d:\n              iVar2 = iVar7 + 1;\n              __s_00 = (char *)0x0;\n            }\n            else {\n              iVar2 = iVar7 + 1;\n              if (((*__s_00 != '\\0') && (iVar2 = iVar7 + 2, __s_00[1] != '\\0')) &&\n                 (iVar2 = iVar7 + 3, __s_00[2] != '\\0')) {\n                sVar4 = strlen(__s_00);\n                iVar2 = iVar7 + 1 + (int)sVar4;\n              }\n            }\n          }\n          iVar2 = iVar2 + iVar9;\n          iVar7 = iVar8;\n          if (iVar8 <= iVar2) {\n            do {\n              iVar8 = iVar7 * 2;\n              iVar1 = iVar7 * -2;\n              iVar7 = iVar8;\n            } while (SBORROW4(iVar2,iVar8) == iVar2 + iVar1 < 0);\n            puVar6 = (undefined *)sh_xrealloc(puVar6,(long)iVar8,\"array.c\",0x3cf);\n          }\n          strcpy(puVar6 + iVar9,__s);\n          iVar2 = 0;\n          if (((*__s != '\\0') && (iVar2 = 1, __s[1] != '\\0')) && (iVar2 = 2, __s[2] != '\\0')) {\n            sVar4 = strlen(__s);\n            iVar2 = (int)sVar4;\n          }\n          iVar2 = iVar2 + iVar9;\n          puVar6[iVar2] = 0x20;\n          __dest = (undefined2 *)(puVar6 + (iVar2 + 1));\n          if (__s_00 == (char *)0x0) {\n            *(undefined *)(__dest + 1) = 0;\n            *__dest = 0x2222;\n            iVar9 = iVar2 + 3;\n            if (puVar10[2] == *(long *)(param_1 + 0x10)) break;\n            lVar5 = (long)iVar9;\n            iVar9 = iVar2 + 4;\n            puVar6[lVar5] = 0x20;\n          }\n          else {\n            strcpy((char *)__dest,__s_00);\n            iVar9 = 0;\n            if (((*__s_00 != '\\0') && (iVar9 = 1, __s_00[1] != '\\0')) &&\n               (iVar9 = 2, __s_00[2] != '\\0')) {\n              sVar4 = strlen(__s_00);\n              iVar9 = (int)sVar4;\n            }\n            iVar9 = iVar2 + 1 + iVar9;\n            if (puVar10[2] != *(long *)(param_1 + 0x10)) {\n              lVar5 = (long)iVar9;\n              iVar9 = iVar9 + 1;\n              puVar6[lVar5] = 0x20;\n            }\n            sh_xfree(__s_00,\"array.c\",0x3df);\n          }\n          puVar10 = (undefined8 *)puVar10[2];\n        } while (*(undefined8 **)(param_1 + 0x10) != puVar10);\n        if (iVar8 <= iVar9 + 1) {\n          puVar6 = (undefined *)\n                   sh_xrealloc(puVar6,(long)(int)(iVar8 + 8 + ((iVar9 + 1) - iVar8 & 0xfffffff8U)),\n                               \"array.c\",0x3e1);\n        }\n        puVar3 = puVar6 + iVar9;\n      }\n      *puVar3 = 0;\n      puVar3 = puVar6;\n      if (param_2 != 0) {\n        puVar3 = (undefined *)sh_single_quote(puVar6);\n        sh_xfree(puVar6,\"array.c\",999);\n      }\n    }\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar3;\n}\n\n",
  "rl_list_funmap_names": "\nvoid rl_list_funmap_names(void)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  \n  plVar2 = (long *)rl_funmap_names();\n  if (plVar2 != (long *)0x0) {\n    lVar1 = *plVar2;\n    plVar3 = plVar2;\n    while (lVar1 != 0) {\n      plVar3 = plVar3 + 1;\n      __fprintf_chk(rl_outstream,1,&DAT_0020fbe7);\n      lVar1 = *plVar3;\n    }\n    xfree(plVar2);\n    return;\n  }\n  return;\n}\n\n",
  "bash_directory_completion_matches": "\nlong * bash_directory_completion_matches(long param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  \n  if ((rl_dispatching == 0) || (rl_completion_found_quote != 0)) {\n    plVar1 = (long *)rl_completion_matches(param_1,rl_filename_completion_function);\n  }\n  else {\n    lVar2 = FUN_00191560(param_1,rl_completion_quote_character);\n    plVar1 = (long *)rl_completion_matches(lVar2,rl_filename_completion_function);\n    if (param_1 != lVar2) {\n      sh_xfree(lVar2,\"bashline.c\",0x1299);\n    }\n  }\n  if ((plVar1 != (long *)0x0) && (*plVar1 != 0)) {\n    FUN_00191ae0(plVar1,FUN_001921d0);\n  }\n  return plVar1;\n}\n\n",
  "rl_complete_internal": "\nint rl_complete_internal(int param_1)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  size_t sVar5;\n  char *pcVar6;\n  char *pcVar7;\n  char **ppcVar8;\n  int iVar9;\n  code *pcVar10;\n  long in_FS_OFFSET;\n  int local_5c;\n  char local_51;\n  undefined4 local_50;\n  undefined4 local_4c;\n  char **local_48;\n  long local_40;\n  \n  iVar4 = DAT_0024a72c;\n  pcVar7 = rl_line_buffer;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  rl_readline_state = rl_readline_state | 0x4000;\n  rl_filename_completion_desired = 0;\n  rl_filename_quoting_desired = 1;\n  rl_completion_suppress_quote = 0;\n  rl_completion_suppress_append = 0;\n  rl_completion_append_character = 0x20;\n  rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;\n  DAT_0024a728 = 0;\n  rl_completion_type = param_1;\n  if (rl_line_buffer != (char *)0x0) {\n    sVar5 = strlen(rl_line_buffer);\n    pcVar6 = (char *)xmalloc(sVar5 + 1);\n    pcVar7 = strcpy(pcVar6,pcVar7);\n  }\n  iVar2 = rl_point;\n  local_50 = 0;\n  local_4c = 0;\n  local_51 = '\\0';\n  pcVar10 = rl_completion_entry_function;\n  if (rl_completion_entry_function == (code *)0x0) {\n    pcVar10 = rl_filename_completion_function;\n  }\n  iVar9 = 0;\n  if (rl_point != 0) {\n    local_51 = _rl_find_completion_word(&local_4c,&local_50);\n    iVar9 = rl_point;\n  }\n  rl_point = iVar2;\n  pcVar6 = (char *)rl_copy_text(iVar9,iVar2);\n  local_48 = (char **)FUN_001d8df0(pcVar6,iVar9,iVar2,pcVar10,local_4c,(int)local_51);\n  if (local_48 == (char **)0x0) {\n    xfree(pcVar6);\n    rl_ding();\n    if (pcVar7 != (char *)0x0) {\n      free(pcVar7);\n    }\n    rl_readline_state = rl_readline_state & 0xffffffffffffbfff;\n    iVar4 = 0;\n    DAT_0024a730 = 0;\n    DAT_0024a72c = 1;\n    rl_completion_found_quote = 0;\n    rl_completion_quote_character = 0;\n    goto LAB_001d9258;\n  }\n  iVar2 = FUN_001d5e50(pcVar6,*local_48);\n  if (param_1 == 0x40 || param_1 == 0x21) {\n    sVar5 = strlen(pcVar6);\n    local_5c = (int)sVar5;\n  }\n  xfree(pcVar6);\n  iVar3 = FUN_001d74a0(&local_48,rl_filename_completion_desired);\n  ppcVar1 = local_48;\n  if (iVar3 == 0) {\n    rl_ding();\n    if (pcVar7 != (char *)0x0) {\n      free(pcVar7);\n    }\n    rl_readline_state = rl_readline_state & 0xffffffffffffbfff;\n    DAT_0024a730 = 0;\n    DAT_0024a72c = 1;\n    rl_completion_found_quote = 0;\n    rl_completion_quote_character = 0;\n    iVar4 = 0;\n    goto LAB_001d9258;\n  }\n  if (((local_48 != (char **)0x0) && (*local_48 != (char *)0x0)) && (**local_48 != '\\0')) {\n    DAT_0024a72c = 0;\n  }\n  if (param_1 == 0x2a) {\n    rl_begin_undo_group();\n    if (((local_51 != '\\0') && (iVar9 != 0)) && (local_51 == rl_line_buffer[(long)iVar9 + -1])) {\n      iVar9 = iVar9 + -1;\n    }\n    rl_delete_text(iVar9,rl_point);\n    pcVar6 = ppcVar1[1];\n    rl_point = iVar9;\n    if (pcVar6 == (char *)0x0) {\n      pcVar6 = (char *)FUN_001d5ec0(*ppcVar1,1,&local_51);\n      rl_insert_text(pcVar6);\n      rl_insert_text(&DAT_001fdb1c);\n      if (pcVar6 != *ppcVar1) {\n        xfree(pcVar6);\n      }\n    }\n    else {\n      ppcVar8 = ppcVar1;\n      do {\n        pcVar6 = (char *)FUN_001d5ec0(pcVar6,1,&local_51);\n        rl_insert_text(pcVar6);\n        rl_insert_text(&DAT_001fdb1c);\n        if (pcVar6 != ppcVar8[1]) {\n          xfree(pcVar6);\n        }\n        pcVar6 = ppcVar8[2];\n        ppcVar8 = ppcVar8 + 1;\n      } while (pcVar6 != (char *)0x0);\n    }\n    rl_end_undo_group();\nLAB_001d939f:\n    pcVar6 = *ppcVar1;\n    ppcVar8 = ppcVar1;\n    while (pcVar6 != (char *)0x0) {\n      ppcVar8 = ppcVar8 + 1;\n      xfree();\n      pcVar6 = *ppcVar8;\n    }\n    xfree(ppcVar1);\n  }\n  else {\n    if (param_1 < 0x2b) {\n      if (param_1 != 9) {\n        if (param_1 != 0x21) goto LAB_001d91de;\n        goto LAB_001d9165;\n      }\n      if (**local_48 != '\\0') {\n        FUN_001d5f60(*local_48,iVar9,2 - (uint)(local_48[1] == (char *)0x0),&local_51);\n      }\n      if (ppcVar1[1] == (char *)0x0) goto LAB_001d9542;\nLAB_001d92f1:\n      if (rl_editing_mode != 0) {\n        rl_ding();\n      }\n      goto LAB_001d939f;\n    }\n    if (param_1 != 0x3f) {\n      if (param_1 != 0x40) {\nLAB_001d91de:\n        _rl_ttymsg(\"bad value %d for what_to_do in rl_complete\",param_1);\n        rl_ding();\n        if (pcVar7 != (char *)0x0) {\n          free(pcVar7);\n        }\n        rl_readline_state = rl_readline_state & 0xffffffffffffbfff;\n        if (ppcVar1 != (char **)0x0) {\n          pcVar7 = *ppcVar1;\n          ppcVar8 = ppcVar1;\n          while (pcVar7 != (char *)0x0) {\n            ppcVar8 = ppcVar8 + 1;\n            xfree();\n            pcVar7 = *ppcVar8;\n          }\n          xfree(ppcVar1);\n        }\n        rl_completion_found_quote = 0;\n        iVar4 = 1;\n        rl_completion_quote_character = 0;\n        goto LAB_001d9258;\n      }\nLAB_001d9165:\n      pcVar6 = *local_48;\n      if (*pcVar6 == '\\0') {\nLAB_001d919f:\n        if (ppcVar1[1] == (char *)0x0) goto LAB_001d9542;\n      }\n      else {\n        if (local_48[1] == (char *)0x0) {\n          FUN_001d5f60(pcVar6,iVar9,1,&local_51);\n          goto LAB_001d919f;\n        }\n        sVar5 = strlen(pcVar6);\n        if (local_5c <= (int)sVar5) {\n          FUN_001d5f60(pcVar6,iVar9,2,&local_51);\n          goto LAB_001d919f;\n        }\n      }\n      if (param_1 != 0x21) {\n        if (param_1 != 0x40 && param_1 != 0x21) goto LAB_001d92f1;\n        if (iVar2 != 0) goto LAB_001d939f;\n      }\n      FUN_001d8aa0(ppcVar1);\n      goto LAB_001d939f;\n    }\n    if (((iVar4 != 0) && (pcVar6 = *local_48, pcVar6 != (char *)0x0)) &&\n       ((*pcVar6 != '\\0' && (local_48[1] == (char *)0x0)))) {\n      FUN_001d5f60(pcVar6,iVar9,1,&local_51);\nLAB_001d9542:\n      FUN_001d7d90(*ppcVar1,local_50,(int)local_51,iVar2 != 0);\n      goto LAB_001d939f;\n    }\n    if (rl_completion_display_matches_hook == 0) {\n      _rl_sigcleanup = FUN_001d7d30;\n      DAT_0024a728 = 0;\n      _rl_sigcleanarg = local_48;\n    }\n    FUN_001d8aa0(local_48);\n    if (DAT_0024a728 == 0) {\n      _rl_sigcleanup = (code *)0x0;\n      _rl_sigcleanarg = (char **)0x0;\n      if (ppcVar1 != (char **)0x0) goto LAB_001d939f;\n    }\n    else {\n      local_48 = (char **)0x0;\n      DAT_0024a728 = 0;\n      if (rl_signal_event_hook != (code *)0x0) {\n        (*rl_signal_event_hook)();\n      }\n      _rl_sigcleanup = (code *)0x0;\n      _rl_sigcleanarg = (char **)0x0;\n    }\n  }\n  if (pcVar7 != (char *)0x0) {\n    iVar4 = strcmp(rl_line_buffer,pcVar7);\n    DAT_0024a730 = (uint)(iVar4 != 0);\n    xfree(pcVar7);\n  }\n  rl_readline_state = rl_readline_state & 0xffffffffffffbfff;\n  rl_completion_found_quote = 0;\n  rl_completion_quote_character = 0;\n  iVar4 = _rl_caught_signal;\n  if (_rl_caught_signal != 0) {\n    iVar4 = 0;\n    _rl_signal_handler(_rl_caught_signal);\n  }\nLAB_001d9258:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "fwrite": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_fwrite_00237e08)();\n  return sVar1;\n}\n\n",
  "init_job_stats": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid init_job_stats(void)\n\n{\n  js._0_4_ = _DAT_001fe040;\n  js._4_4_ = _UNK_001fe044;\n  _DAT_00238768 = _UNK_001fe048;\n  _DAT_0023876c = _UNK_001fe04c;\n  _DAT_00238770 = _DAT_001fe050;\n  _DAT_00238774 = _UNK_001fe054;\n  _DAT_00238778 = _UNK_001fe058;\n  DAT_0023877c = _UNK_001fe05c;\n  _DAT_002387a0 = DAT_001fe080;\n  DAT_00238780 = _DAT_001fe060;\n  _DAT_00238784 = _UNK_001fe064;\n  DAT_00238788 = _UNK_001fe068;\n  _DAT_0023878c = _UNK_001fe06c;\n  DAT_00238790 = _DAT_001fe070;\n  DAT_00238794 = _UNK_001fe074;\n  _DAT_00238798 = _UNK_001fe078;\n  uRam000000000023879c = _UNK_001fe07c;\n  return;\n}\n\n",
  "_rl_make_prompt_for_search": "\nchar * _rl_make_prompt_for_search(char param_1)\n\n{\n  int iVar1;\n  char *pcVar2;\n  size_t sVar3;\n  char *__dest;\n  char *pcVar4;\n  long lVar5;\n  \n  rl_save_prompt();\n  pcVar4 = rl_prompt;\n  if (rl_prompt == (char *)0x0) {\nLAB_001e2680:\n    lVar5 = 1;\n    pcVar4 = (char *)xmalloc(2);\n    __dest = pcVar4;\n  }\n  else {\n    pcVar2 = strrchr(rl_prompt,10);\n    if (pcVar2 != (char *)0x0) {\n      sVar3 = strlen(pcVar2 + 1);\n      iVar1 = (int)sVar3;\n      __dest = (char *)xmalloc((long)(iVar1 + 2));\n      if (iVar1 != 0) {\n        __dest = strcpy(__dest,pcVar2 + 1);\n      }\n      __dest[iVar1] = param_1;\n      __dest[(long)iVar1 + 1] = '\\0';\n      goto LAB_001e260a;\n    }\n    if (*pcVar4 == '\\0') goto LAB_001e2680;\n    sVar3 = strlen(pcVar4);\n    iVar1 = (int)sVar3;\n    pcVar4 = (char *)xmalloc((long)(iVar1 + 2));\n    lVar5 = (long)iVar1 + 1;\n    __dest = pcVar4;\n    if (iVar1 != 0) {\n      __dest = strcpy(pcVar4,rl_prompt);\n      pcVar4 = __dest + iVar1;\n    }\n  }\n  *pcVar4 = param_1;\n  __dest[lVar5] = '\\0';\nLAB_001e260a:\n  DAT_0024a870 = DAT_0024a830 + 1;\n  return __dest;\n}\n\n",
  "FUN_00190710": "\nchar FUN_00190710(char *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  \n  if ((parser_state & 0x20000 | DAT_00240a18) != 0) {\n    return '\\0';\n  }\n  if (param_1 == (char *)0x0) {\n    return '\\0';\n  }\n  cVar1 = *param_1;\n  pcVar3 = param_1;\n  if (cVar1 == '\\0') {\n    iVar2 = 0;\n  }\n  else {\n    do {\n      if ((cVar1 != ' ') && (cVar1 != '\\t')) {\n        if (cVar1 == '#') {\n          return '\\x01';\n        }\n        break;\n      }\n      cVar1 = pcVar3[1];\n      pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\n    iVar2 = (int)pcVar3 - (int)param_1;\n  }\n  iVar2 = skip_to_delim(param_1,iVar2,&DAT_001ff2e3,0x151);\n  return (param_1[iVar2] == '#') * '\\x02';\n}\n\n",
  "unclosed_pair": "\nint unclosed_pair(char *param_1,int param_2,byte *param_3)\n\n{\n  byte *__s1;\n  byte bVar1;\n  int iVar2;\n  mbstate_t mVar3;\n  int iVar4;\n  int iVar5;\n  size_t sVar6;\n  size_t sVar7;\n  int iVar8;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  iVar8 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar6 = strlen(param_1);\n  sVar7 = strlen((char *)param_3);\n  iVar5 = 0;\n  iVar2 = (int)sVar7;\n  if (param_2 < 0) {\nLAB_0016d7c0:\n    iVar5 = 0;\n  }\n  else {\nLAB_0016d71b:\n    do {\n      while( true ) {\n        mVar3 = local_48;\n        __s1 = (byte *)(param_1 + iVar8);\n        bVar1 = *__s1;\n        if (bVar1 != 0x5c) break;\n        iVar4 = iVar8 + 1;\n        if (param_2 < iVar4) goto LAB_0016d7c3;\n        if (param_2 == iVar4) goto LAB_0016d7c0;\n        if (locale_mb_cur_max < 2) {\n          iVar8 = iVar8 + 2;\n          goto joined_r0x0016d8f7;\n        }\n        bVar1 = param_1[iVar4];\n        if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n          if ((locale_utf8locale != 0) && (-1 < (char)bVar1)) {\n            if (bVar1 == 0) goto joined_r0x0016d95d;\n            goto LAB_0016d8d0;\n          }\n          sVar7 = mbrtowc((wchar_t *)0x0,param_1 + iVar4,sVar6 - (long)iVar4,&local_48);\n          if ((0xfffffffffffffffd < sVar7) || (mVar3 = local_48, sVar7 == 0)) {\njoined_r0x0016d95d:\n            iVar8 = iVar8 + 2;\n            local_48 = mVar3;\n            goto joined_r0x0016d8f7;\n          }\n        }\n        else {\nLAB_0016d8d0:\n          sVar7 = 1;\n        }\n        iVar8 = iVar4 + (int)sVar7;\njoined_r0x0016d8f7:\n        if (param_2 < iVar8) goto LAB_0016d7c3;\n      }\n      if ((iVar2 != 0) &&\n         ((bVar1 != *param_3 ||\n          (iVar4 = strncmp((char *)__s1,(char *)param_3,(long)iVar2), iVar4 != 0)))) {\n        mVar3 = local_48;\n        if (bVar1 == 0x27) {\n          iVar8 = iVar8 + 1;\n        }\n        else {\n          if (bVar1 != 0x22) {\n            if (locale_mb_cur_max < 2) {\n              iVar8 = iVar8 + 1;\n              local_48 = mVar3;\n              goto joined_r0x0016d8f7;\n            }\n            if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n              if ((locale_utf8locale == 0) || ((char)bVar1 < '\\0')) {\n                sVar7 = mbrtowc((wchar_t *)0x0,(char *)__s1,sVar6 - (long)iVar8,&local_48);\n                if (sVar7 < 0xfffffffffffffffe) {\n                  if (sVar7 == 0) goto LAB_0016d798;\n                  goto LAB_0016d9b5;\n                }\n                iVar8 = iVar8 + 1;\n                local_48 = mVar3;\n              }\n              else {\n                if (bVar1 != 0) goto LAB_0016d9b0;\nLAB_0016d798:\n                iVar8 = iVar8 + 1;\n              }\n            }\n            else {\nLAB_0016d9b0:\n              sVar7 = 1;\nLAB_0016d9b5:\n              iVar8 = iVar8 + (int)sVar7;\n            }\n            goto joined_r0x0016d8f7;\n          }\n          iVar8 = FUN_0016a7c0(param_1,sVar6,iVar8,0x400);\n        }\n        if (param_2 < iVar8) goto LAB_0016d7c0;\n        goto LAB_0016d71b;\n      }\n      iVar8 = iVar8 + iVar2;\n      iVar5 = 1 - iVar5;\n    } while (iVar8 <= param_2);\n  }\nLAB_0016d7c3:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar5;\n}\n\n",
  "delete_all_jobs": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid delete_all_jobs(int param_1)\n\n{\n  long lVar1;\n  ulong uVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  sigset_t sStack_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_138);\n  sigaddset(&sStack_138,0x11);\n  sigemptyset(&local_b8);\n  sigprocmask(0,&sStack_138,&local_b8);\n  if (DAT_0023877c == 0) {\n    if (param_1 != 0) goto LAB_00164e78;\n  }\n  else {\n    _DAT_00238790 = 0xffffffffffffffff;\n    if (0 < DAT_0023877c) {\n      uVar2 = 0;\n      do {\n        while( true ) {\n          uVar3 = uVar2 & 0xffffffff;\n          lVar1 = *(long *)(jobs + uVar2 * 8);\n          if ((lVar1 == 0) ||\n             (((param_1 != 0 && (*(int *)(lVar1 + 0x14) != 1)) || (DAT_00247660 != 0)))) break;\n          uVar2 = uVar2 + 1;\n          FUN_0015f990(uVar3,3);\n          if (DAT_0023877c <= (int)uVar2) goto LAB_00164e70;\n        }\n        uVar2 = uVar2 + 1;\n      } while ((int)uVar2 < DAT_0023877c);\n    }\nLAB_00164e70:\n    if (param_1 != 0) goto LAB_00164e78;\n    sh_xfree(jobs,\"jobs.c\",0x1287);\n    _DAT_0023877c = 0;\n    _DAT_00238784 = 0;\n  }\n  if ((bgpids != 0) && (DAT_0024253c != 0)) {\n    sh_xfree(bgpids,\"jobs.c\",0x3a4);\n    bgpids = 0;\n    _DAT_00242538 = 0;\n    DAT_00242540 = 0;\n  }\nLAB_00164e78:\n  sigprocmask(2,&local_b8,(sigset_t *)0x0);\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "setitimer": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint setitimer(__itimer_which_t __which,itimerval *__new,itimerval *__old)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_setitimer_00237ca8)();\n  return iVar1;\n}\n\n",
  "zreadc": "\nlong zreadc(undefined8 param_1,undefined *param_2)\n\n{\n  undefined *puVar1;\n  long lVar2;\n  \n  if ((DAT_00248ec8 == DAT_00248ec0) || (DAT_00248ec0 == 0)) {\n    lVar2 = zread(param_1,&DAT_00248ee0,0x1000);\n    DAT_00248ec8 = 0;\n    DAT_00248ec0 = lVar2;\n    if (lVar2 < 1) {\n      DAT_00248ec0 = 0;\n      return lVar2;\n    }\n  }\n  if (param_2 != (undefined *)0x0) {\n    puVar1 = &DAT_00248ee0 + DAT_00248ec8;\n    DAT_00248ec8 = DAT_00248ec8 + 1;\n    *param_2 = *puVar1;\n  }\n  return 1;\n}\n\n",
  "FUN_001691b0": "\nlong FUN_001691b0(long param_1,int *param_2,uint param_3,uint param_4)\n\n{\n  byte bVar1;\n  char cVar2;\n  bool bVar3;\n  mbstate_t mVar4;\n  size_t sVar5;\n  ulong uVar6;\n  char *pcVar7;\n  long lVar8;\n  ulong uVar9;\n  undefined8 uVar10;\n  char *__s;\n  undefined8 uVar11;\n  int iVar12;\n  uint uVar13;\n  byte *pbVar14;\n  bool bVar15;\n  long lVar16;\n  int iVar17;\n  int iVar18;\n  long lVar19;\n  long lVar20;\n  ulong uVar21;\n  long in_FS_OFFSET;\n  bool bVar22;\n  bool bVar23;\n  int local_a0;\n  int local_90;\n  uint local_88;\n  int local_80;\n  int local_7c;\n  int local_58;\n  int local_54;\n  mbstate_t local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50.__count = 0;\n  local_50.__value = (_union_27)0x0;\n  iVar18 = (-(uint)((param_4 & 0x200) == 0) & 0xfffffffd) + 4;\n  local_88 = param_3 & 3;\n  if (((((param_3 & 3) == 0) || ((param_4 & 0x100) == 0)) || (iVar18 = 0x40, param_3 != 2)) ||\n     ((param_4 & 1) != 0)) {\n    local_a0 = *param_2;\n    uVar21 = (ulong)local_a0;\n    pbVar14 = (byte *)(param_1 + uVar21);\n    sVar5 = strlen((char *)pbVar14);\n    uVar6 = sVar5 + uVar21;\n    bVar1 = *pbVar14;\n    if (bVar1 != 0) {\n      local_90 = 1;\n      bVar3 = false;\n      uVar9 = uVar21;\n      do {\n        mVar4 = local_50;\n        uVar13 = (uint)(char)bVar1;\n        iVar12 = (int)uVar9;\n        if (bVar3) {\n          if (locale_mb_cur_max < 2) {\nLAB_00169410:\n            uVar9 = (ulong)(iVar12 + 1);\n          }\n          else if ((*(uint *)(is_basic_table + (ulong)(uVar13 >> 5 & 7) * 4) >> (bVar1 & 0x1f) & 1)\n                   == 0) {\n            if ((locale_utf8locale == 0) || (iVar17 = 1, (char)bVar1 < '\\0')) {\n              sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - uVar21,&local_50);\n              if (0xfffffffffffffffd < sVar5) {\n                uVar9 = (ulong)(iVar12 + 1);\n                local_50 = mVar4;\n                goto LAB_00169413;\n              }\n              iVar17 = (int)sVar5;\n              if (sVar5 == 0) goto LAB_00169410;\n            }\n            uVar9 = (ulong)(uint)(iVar12 + iVar17);\n          }\n          else {\n            uVar9 = (ulong)(iVar12 + 1);\n            local_50 = mVar4;\n          }\nLAB_00169413:\n          bVar3 = false;\n        }\n        else {\n          bVar15 = uVar13 == 1 || uVar13 == 0x5c;\n          if (bVar15) {\n            uVar9 = (ulong)(iVar12 + 1);\n            bVar3 = true;\n            local_50 = mVar4;\n          }\n          else if ((bVar1 == 0x24) && (*(char *)(param_1 + 1 + uVar21) == '{')) {\n            local_90 = local_90 + 1;\n            uVar9 = (ulong)(iVar12 + 2);\n            if ((iVar18 == 0x40) || (local_50 = mVar4, iVar18 == 4)) {\n              iVar18 = 1;\n              local_50 = mVar4;\n            }\n          }\n          else {\n            if (uVar13 == 0x7d) {\n              local_90 = local_90 + -1;\n              if (local_90 != 0) goto LAB_001696a0;\n              lVar8 = 0;\n              if ((param_4 & 1) == 0) {\n                lVar8 = substring(param_1,*param_2,uVar9 & 0xffffffff);\n              }\n              *param_2 = iVar12;\n              goto LAB_0016946d;\n            }\n            local_a0 = (int)uVar6;\n            if (uVar13 == 0x60) {\n              local_54 = iVar12 + 1;\n              FUN_0016b540(param_1,&local_54,&DAT_00213e43,param_4 | 1);\nLAB_00169752:\n              iVar12 = local_54;\n              if (uVar6 <= (ulong)(long)local_54) break;\n            }\n            else {\n              if (bVar1 == 0x24) {\n                if (*(char *)(param_1 + 1 + uVar21) != '(') goto LAB_001692af;\n                local_54 = iVar12 + 2;\n                extract_command_subst(param_1,&local_54,param_4 | 1);\n                goto LAB_00169752;\n              }\n              if (((bVar1 & 0xfd) == 0x3c) && (*(char *)(param_1 + 1 + uVar21) == '(')) {\n                local_54 = iVar12 + 2;\n                xparse_dolparen(param_1,param_1 + local_54,&local_54,\n                                (uint)(no_longjmp_on_fatal_error != 0) << 6 | param_4 | 1);\n                goto LAB_00169752;\n              }\nLAB_001692af:\n              if (uVar13 == 0x22) {\n                local_54 = iVar12 + 1;\n                uVar13 = FUN_0016a7c0(param_1,uVar6,local_54,0);\n                uVar9 = (ulong)uVar13;\n                goto LAB_001693a9;\n              }\n              if (uVar13 != 0x27) {\n                bVar22 = iVar18 == 1;\n                if ((uVar13 == 0x5b) && (bVar22)) {\n                  local_54 = FUN_0016af90(param_1,uVar9 & 0xffffffff,0);\n                  if (uVar6 <= (ulong)(long)local_54) break;\n                  bVar23 = *(char *)(param_1 + local_54) == ']';\n                  if (bVar23) {\n                    iVar12 = local_54;\n                  }\n                  uVar13 = bVar23 + 0x5b + (uint)bVar23;\n                }\n                else {\n                  bVar15 = uVar13 == 0x25 && bVar22;\n                }\n                mVar4 = local_50;\n                if (locale_mb_cur_max < 2) {\nLAB_00169330:\n                  uVar9 = (ulong)(iVar12 + 1);\n                }\n                else {\n                  pbVar14 = (byte *)(param_1 + iVar12);\n                  bVar1 = *pbVar14;\n                  if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) ==\n                      0) {\n                    if ((locale_utf8locale == 0) || ((char)bVar1 < '\\0')) {\n                      sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - (long)iVar12,&local_50)\n                      ;\n                      if (sVar5 < 0xfffffffffffffffe) {\n                        if (sVar5 == 0) goto LAB_00169330;\n                        uVar9 = (ulong)(uint)(iVar12 + (int)sVar5);\n                      }\n                      else {\n                        uVar9 = (ulong)(iVar12 + 1);\n                        local_50 = mVar4;\n                      }\n                      goto LAB_00169333;\n                    }\n                    if (bVar1 == 0) goto LAB_00169330;\n                  }\n                  uVar9 = (ulong)(iVar12 + 1);\n                  local_50 = mVar4;\n                }\nLAB_00169333:\n                iVar12 = (int)uVar9;\n                if (bVar15) {\n                  if (iVar12 - *param_2 < 2) {\n                    if ((uVar13 != 0x5e) || (!bVar22)) {\nLAB_0016981e:\n                      if ((uVar13 == 0x2c) && (bVar22)) goto LAB_00169702;\n                      if (iVar18 != 1) {\n                        if ((iVar18 == 2) &&\n                           (pcVar7 = strchr(\"#%^,~:-=?+/\",uVar13), pcVar7 == (char *)0x0)) {\n                          iVar18 = 4;\n                        }\n                        goto LAB_001693a9;\n                      }\n                    }\n                    goto LAB_00169711;\n                  }\n                }\n                else {\n                  if ((uVar13 != 0x23) || (!bVar22)) {\n                    if ((uVar13 == 0x2f) && (bVar22)) {\n                      if (iVar12 - *param_2 < 2) goto LAB_00169711;\n                      iVar18 = 0x80;\n                      goto LAB_001693a9;\n                    }\n                    if ((uVar13 != 0x5e) || (!bVar22)) goto LAB_0016981e;\n                  }\nLAB_00169702:\n                  if (iVar12 - *param_2 < 2) {\nLAB_00169711:\n                    pcVar7 = strchr(\"#%^,~:-=?+/\",uVar13);\n                    if (pcVar7 != (char *)0x0) {\n                      iVar18 = 2;\n                    }\n                    goto LAB_001693a9;\n                  }\n                }\n                iVar18 = 0x40;\n                goto LAB_001693a9;\n              }\n              if (((posixly_correct == 0) || (shell_compatibility_level < 0x2b || iVar18 == 0x40))\n                 || (local_88 == 0)) {\n                iVar12 = iVar12 + 1;\n                local_48.__count = 0;\n                local_48.__value = (_union_27)0x0;\n                lVar8 = (long)iVar12;\n                pbVar14 = (byte *)(param_1 + lVar8);\n                bVar1 = *pbVar14;\n                local_54 = iVar12;\n                mVar4 = local_48;\n                while ((local_48 = mVar4, bVar1 != 0 && (bVar1 != 0x27))) {\n                  if (locale_mb_cur_max < 2) {\nLAB_00169940:\n                    iVar12 = iVar12 + 1;\n                  }\n                  else {\n                    if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1)\n                        == 0) {\n                      if ((locale_utf8locale == 0) || (iVar17 = 1, (char)bVar1 < '\\0')) {\n                        sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - lVar8,&local_48);\n                        if (0xfffffffffffffffd < sVar5) {\n                          iVar12 = iVar12 + 1;\n                          local_48 = mVar4;\n                          goto LAB_001698ed;\n                        }\n                        iVar17 = (int)sVar5;\n                        if (sVar5 == 0) goto LAB_00169940;\n                      }\n                    }\n                    else {\n                      iVar17 = 1;\n                    }\n                    iVar12 = iVar12 + iVar17;\n                  }\nLAB_001698ed:\n                  lVar8 = (long)iVar12;\n                  pbVar14 = (byte *)(param_1 + lVar8);\n                  mVar4 = local_48;\n                  bVar1 = *pbVar14;\n                }\n                uVar9 = (ulong)((iVar12 + 1) - (uint)(bVar1 == 0));\n                goto LAB_001693a9;\n              }\n              if (1 < locale_mb_cur_max) {\n                iVar17 = 1;\n                if (((uint)is_basic_table._4_4_ >> 7 & 1 | locale_utf8locale) == 0) {\n                  sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - uVar21,&local_50);\n                  iVar17 = (int)sVar5;\n                  if (0xfffffffffffffffd < sVar5) {\n                    uVar9 = (ulong)(iVar12 + 1);\n                    local_50 = mVar4;\n                    goto LAB_001693a9;\n                  }\n                  if (sVar5 == 0) goto LAB_001696a0;\n                }\n                uVar9 = (ulong)(uint)(iVar12 + iVar17);\n                goto LAB_001693a9;\n              }\n            }\nLAB_001696a0:\n            uVar9 = (ulong)(iVar12 + 1);\n          }\n        }\nLAB_001693a9:\n        local_a0 = (int)uVar9;\n        uVar21 = (ulong)local_a0;\n        pbVar14 = (byte *)(param_1 + uVar21);\n        bVar1 = *pbVar14;\n      } while (bVar1 != 0);\n    }\n    if (no_longjmp_on_fatal_error == 0) goto LAB_0016a77d;\n    *param_2 = local_a0;\n    lVar8 = 0;\n  }\n  else {\n    local_48.__count = 0;\n    local_48.__value = (_union_27)0x0;\n    iVar18 = *param_2;\n    sVar5 = strlen((char *)(param_1 + iVar18));\n    uVar6 = sVar5 + (long)iVar18;\n    lVar8 = sh_xmalloc(uVar6 + 1,\"subst.c\",0x60c);\n    local_90 = *param_2;\n    lVar16 = (long)local_90;\n    pbVar14 = (byte *)(param_1 + lVar16);\n    bVar1 = *pbVar14;\n    if (bVar1 != 0) {\n      bVar3 = false;\n      local_7c = 1;\n      local_80 = 0x40;\n      uVar21 = uVar6;\n      lVar20 = 0;\n      iVar18 = local_90;\n      do {\n        mVar4 = local_48;\n        uVar13 = (uint)(char)bVar1;\n        iVar12 = local_80;\n        if (bVar3) {\n          uVar9 = (locale_mb_cur_max + 1) + lVar20;\n          if (uVar21 <= uVar9) {\n            do {\n              uVar21 = uVar21 + 0x40;\n            } while (uVar21 <= uVar9);\n            lVar8 = sh_xrealloc(lVar8,uVar21,\"subst.c\",0x617);\n          }\n          mVar4 = local_48;\n          bVar1 = *pbVar14;\n          local_90 = iVar18 + 1;\n          lVar19 = lVar20 + 1;\n          if (locale_mb_cur_max < 2) {\n            *(byte *)(lVar8 + lVar20) = bVar1;\n            bVar3 = false;\n            goto LAB_001699ba;\n          }\n          if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale != 0) && (sVar5 = 1, -1 < (char)bVar1)) goto LAB_00169f1e;\n            sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - lVar16,&local_48);\n            if (sVar5 < 0xfffffffffffffffe) {\n              if (sVar5 == 0) {\n                sVar5 = 1;\n              }\n              goto LAB_00169f1e;\n            }\n            *(byte *)(lVar8 + lVar20) = *(byte *)(param_1 + lVar16);\n            local_48 = mVar4;\n          }\n          else {\n            sVar5 = 1;\nLAB_00169f1e:\n            lVar19 = lVar20;\n            do {\n              lVar19 = lVar19 + 1;\n              *(undefined *)(lVar8 + -1 + lVar19) =\n                   *(undefined *)(param_1 + (lVar16 - lVar20) + -1 + lVar19);\n            } while (lVar19 != lVar20 + sVar5);\n            local_90 = iVar18 + (int)sVar5;\n          }\n          bVar3 = false;\n        }\n        else if ((uVar13 == 1) || (uVar13 == 0x5c)) {\n          if (uVar21 <= lVar20 + 2U) {\n            do {\n              uVar21 = uVar21 + 0x40;\n            } while (uVar21 <= lVar20 + 2U);\n            lVar8 = sh_xrealloc(lVar8,uVar21,\"subst.c\",0x620);\n          }\n          *(byte *)(lVar8 + lVar20) = bVar1;\n          lVar19 = lVar20 + 1;\n          bVar3 = true;\n          local_90 = iVar18 + 1;\n        }\n        else {\n          local_90 = (int)uVar6;\n          if (uVar13 == 0x24) {\n            pcVar7 = (char *)(param_1 + 1 + lVar16);\n            cVar2 = *pcVar7;\n            if (cVar2 == '\\'') {\n              if ((posixly_correct == 0) && (extended_quote != 0)) {\n                local_58 = iVar18 + 2;\n                __s = (char *)FUN_001674a0(param_1,&local_58,1);\n                if (uVar6 <= (ulong)(long)local_58) break;\n                iVar18 = (local_58 - iVar18) + -2;\n                pcVar7 = (char *)ansiexpand(__s,0,iVar18,&local_54);\n                sh_xfree(__s,\"subst.c\",0x63b);\n                if ((local_80 - 0x40U & 0xffffffbf) == 0) goto LAB_0016a0f8;\n                sVar5 = (size_t)iVar18;\n                if (extended_quote != 0) {\n                  sVar5 = strlen(pcVar7);\n                  __s = pcVar7;\n                }\n              }\n              else {\n                if ((local_80 - 0x40U & 0xffffffbf) != 0) {\n                  if (uVar21 <= lVar20 + 3U) {\n                    do {\n                      uVar21 = uVar21 + 0x40;\n                    } while (uVar21 <= lVar20 + 3U);\n                    lVar8 = sh_xrealloc(lVar8,uVar21,\"subst.c\",0x62e);\n                  }\n                  *(undefined *)(lVar8 + lVar20) = 0x24;\n                  lVar19 = lVar20 + 2;\n                  *(undefined *)(lVar8 + lVar20 + 1) = 0x27;\n                  local_90 = iVar18 + 2;\n                  goto LAB_001699ba;\n                }\n                local_58 = iVar18 + 2;\n                uVar11 = FUN_001674a0(param_1,&local_58,1);\n                if (uVar6 <= (ulong)(long)local_58) break;\n                pcVar7 = (char *)ansiexpand(uVar11,0,(local_58 - iVar18) + -2,&local_54);\n                sh_xfree(uVar11,\"subst.c\",0x63b);\nLAB_0016a0f8:\n                __s = (char *)sh_single_quote(pcVar7);\n                sVar5 = strlen(__s);\n                sh_xfree(pcVar7,\"subst.c\",0x642);\n              }\n              lVar19 = lVar20 + sVar5;\n              if (uVar21 <= lVar19 + 1U) {\n                do {\n                  uVar21 = uVar21 + 0x40;\n                } while (uVar21 <= lVar19 + 1U);\n                lVar8 = sh_xrealloc(lVar8,uVar21,\"subst.c\",0x64b);\n              }\n              strncpy((char *)(lVar8 + lVar20),__s,sVar5);\n              uVar11 = 0x64e;\n            }\n            else {\n              if (cVar2 != '\\\"') {\n                if (cVar2 != '{') goto LAB_00169579;\n                local_7c = local_7c + 1;\n                if (uVar21 <= lVar20 + 3U) {\n                  do {\n                    uVar21 = uVar21 + 0x40;\n                  } while (uVar21 <= lVar20 + 3U);\n                  lVar8 = sh_xrealloc(lVar8,uVar21,\"subst.c\",0x671);\n                }\n                *(undefined *)(lVar8 + lVar20) = 0x24;\n                lVar19 = lVar20 + 2;\n                *(char *)(lVar8 + lVar20 + 1) = *pcVar7;\n                local_90 = iVar18 + 2;\n                if (((local_80 - 0x40U & 0xffffffbf) == 0) || (local_80 == 4)) {\n                  local_80 = 1;\n                  iVar12 = local_80;\n                }\n                goto LAB_001699ba;\n              }\n              local_58 = iVar18 + 2;\n              uVar11 = FUN_0016aa90(param_1,&local_58,param_4);\n              if (uVar6 <= (ulong)(long)local_58) break;\n              uVar10 = locale_expand(uVar11,0,(local_58 - iVar18) + -2,line_number,&local_54);\n              sh_xfree(uVar11,\"subst.c\",0x65f);\n              if (singlequote_translations == 0) {\n                __s = (char *)sh_mkdoublequoted(uVar10,local_54,0);\n              }\n              else {\n                __s = (char *)sh_single_quote(uVar10);\n              }\n              sVar5 = strlen(__s);\n              sh_xfree(uVar10,\"subst.c\",0x663);\n              lVar19 = lVar20 + sVar5;\n              if (uVar21 <= lVar19 + 1U) {\n                do {\n                  uVar21 = uVar21 + 0x40;\n                } while (uVar21 <= lVar19 + 1U);\n                lVar8 = sh_xrealloc(lVar8,uVar21,\"subst.c\",0x665);\n              }\n              strncpy((char *)(lVar8 + lVar20),__s,sVar5);\n              uVar11 = 0x668;\n            }\n            sh_xfree(__s,\"subst.c\",uVar11);\n            local_90 = local_58;\n          }\n          else if (uVar13 == 0x7d) {\n            local_7c = local_7c + -1;\n            if (local_7c == 0) {\n              *param_2 = iVar18;\n              *(undefined *)(lVar8 + lVar20) = 0;\n              goto LAB_0016946d;\n            }\n            if (uVar21 <= lVar20 + 2U) {\n              do {\n                uVar21 = uVar21 + 0x40;\n              } while (uVar21 <= lVar20 + 2U);\n              lVar8 = sh_xrealloc(lVar8,uVar21,\"subst.c\",0x67f);\n            }\n            *(undefined *)(lVar8 + lVar20) = 0x7d;\n            lVar19 = lVar20 + 1;\n            local_90 = iVar18 + 1;\n          }\n          else {\n            if (uVar13 == 0x60) {\n              local_58 = iVar18 + 1;\n              pcVar7 = (char *)FUN_0016b540(param_1,&local_58,&DAT_00213e43,param_4);\n              if (uVar6 <= (ulong)(long)local_58) break;\n              sVar5 = (size_t)((local_58 - iVar18) + -1);\n              uVar9 = lVar20 + 3 + sVar5;\n              if (uVar21 <= uVar9) {\n                do {\n                  uVar21 = uVar21 + 0x40;\n                } while (uVar21 <= uVar9);\n                lVar8 = sh_xrealloc(lVar8,uVar21,\"subst.c\",0x68e);\n              }\n              *(undefined *)(lVar8 + lVar20) = 0x60;\n              lVar16 = sVar5 + lVar20 + 1;\n              lVar19 = lVar16 + 1;\n              strncpy((char *)(lVar8 + lVar20 + 1),pcVar7,sVar5);\n              uVar11 = 0x693;\n              *(undefined *)(lVar8 + lVar16) = *(undefined *)(param_1 + local_58);\n            }\n            else {\nLAB_00169579:\n              if (bVar1 == 0x24) {\n                if (*(char *)(param_1 + 1 + lVar16) != '(') goto LAB_00169599;\n                local_58 = iVar18 + 2;\n                pcVar7 = (char *)extract_command_subst(param_1,&local_58,param_4);\n                if (uVar6 <= (ulong)(long)local_58) break;\n                sVar5 = (size_t)((local_58 - iVar18) + -1);\n                uVar9 = lVar20 + 4 + sVar5;\n                if (uVar21 <= uVar9) {\n                  do {\n                    uVar21 = uVar21 + 0x40;\n                  } while (uVar21 <= uVar9);\n                  lVar8 = sh_xrealloc(lVar8,uVar21,\"subst.c\",0x6a1);\n                }\n                *(undefined *)(lVar8 + lVar20) = 0x24;\n                *(undefined *)(lVar8 + 1 + lVar20) = 0x28;\n                strncpy((char *)(lVar8 + lVar20 + 2),pcVar7,sVar5);\n                lVar16 = sVar5 + lVar20 + 2;\n                lVar19 = lVar16 + 1;\n                *(undefined *)(lVar8 + lVar16) = *(undefined *)(param_1 + local_58);\n                uVar11 = 0x6a7;\n              }\n              else {\n                if (((bVar1 & 0xfd) != 0x3c) || (*(char *)(param_1 + 1 + lVar16) != '(')) {\nLAB_00169599:\n                  iVar17 = iVar18 + 1;\n                  if (uVar13 == 0x27) {\n                    if (((posixly_correct != 0) && (0x2a < shell_compatibility_level)) &&\n                       (local_80 != 0x40)) {\n                      lVar19 = lVar20 + 1;\n                      if (locale_mb_cur_max < 2) {\n                        *(undefined *)(lVar8 + lVar20) = 0x27;\n                        local_48 = mVar4;\n                        local_90 = iVar17;\n                      }\n                      else {\n                        sVar5 = 1;\n                        if ((((uint)is_basic_table._4_4_ >> 7 & 1 | locale_utf8locale) == 0) &&\n                           (sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - lVar16,&local_48)\n                           , 0xfffffffffffffffd < sVar5)) {\n                          *(undefined *)(lVar8 + lVar20) = *(undefined *)(param_1 + lVar16);\n                          local_48 = mVar4;\n                          local_90 = iVar17;\n                        }\n                        else {\n                          if (sVar5 == 0) {\n                            sVar5 = 1;\n                          }\n                          lVar16 = lVar16 - lVar20;\n                          lVar19 = lVar20 + sVar5;\n                          do {\n                            lVar20 = lVar20 + 1;\n                            *(undefined *)(lVar8 + -1 + lVar20) =\n                                 *(undefined *)(lVar16 + param_1 + -1 + lVar20);\n                          } while (lVar20 != lVar19);\n                          local_90 = iVar18 + (int)sVar5;\n                        }\n                      }\n                      goto LAB_001699ba;\n                    }\n                    local_58 = iVar17;\n                    pcVar7 = (char *)FUN_001674a0(param_1,&local_58,0);\n                  }\n                  else {\n                    if (uVar13 != 0x22) {\n                      lVar19 = lVar20 + 1;\n                      if (locale_mb_cur_max < 2) {\n                        *(byte *)(lVar8 + lVar20) = bVar1;\n                        local_48 = mVar4;\n                        local_90 = iVar17;\n                      }\n                      else {\n                        if ((*(uint *)(is_basic_table + (ulong)(uVar13 >> 5 & 7) * 4) >>\n                             (bVar1 & 0x1f) & 1) == 0) {\n                          if ((locale_utf8locale == 0) || (sVar5 = 1, (char)bVar1 < '\\0')) {\n                            sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - lVar16,&local_48)\n                            ;\n                            if (0xfffffffffffffffd < sVar5) {\n                              *(byte *)(lVar8 + lVar20) = *(byte *)(param_1 + lVar16);\n                              local_48 = mVar4;\n                              local_90 = iVar17;\n                              goto LAB_001695d4;\n                            }\n                            if (sVar5 == 0) {\n                              sVar5 = 1;\n                            }\n                          }\n                        }\n                        else {\n                          sVar5 = 1;\n                        }\n                        lVar19 = lVar20;\n                        do {\n                          lVar19 = lVar19 + 1;\n                          *(undefined *)(lVar8 + -1 + lVar19) =\n                               *(undefined *)((lVar16 - lVar20) + param_1 + -1 + lVar19);\n                        } while (lVar19 != lVar20 + sVar5);\n                        local_90 = iVar18 + (int)sVar5;\n                      }\nLAB_001695d4:\n                      bVar15 = local_80 == 1;\n                      if (((uVar13 == 0x25) && (bVar15)) || ((uVar13 == 0x23 && (bVar15)))) {\nLAB_001695ed:\n                        if (local_90 - *param_2 < 2) {\nLAB_0016a672:\n                          pcVar7 = strchr(\"#%^,~:-=?+/\",uVar13);\n                          iVar12 = 2;\n                          if (pcVar7 == (char *)0x0) {\n                            iVar12 = local_80;\n                          }\n                        }\n                        else {\n                          local_80 = 0x40;\n                          iVar12 = local_80;\n                        }\n                      }\n                      else if ((uVar13 == 0x2f) && (bVar15)) {\n                        if (local_90 - *param_2 < 2) goto LAB_0016a672;\n                        local_80 = 0x80;\n                        iVar12 = local_80;\n                      }\n                      else {\n                        if (((uVar13 == 0x5e) && (bVar15)) || ((uVar13 == 0x2c && (bVar15))))\n                        goto LAB_001695ed;\n                        if (local_80 == 1) goto LAB_0016a672;\n                        if (local_80 == 2) {\n                          pcVar7 = strchr(\"#%^,~:-=?+/\",uVar13);\n                          iVar12 = 4;\n                          if (pcVar7 != (char *)0x0) {\n                            iVar12 = local_80;\n                          }\n                        }\n                      }\n                      goto LAB_001699ba;\n                    }\n                    local_58 = iVar17;\n                    pcVar7 = (char *)FUN_0016aa90(param_1,&local_58,param_4);\n                  }\n                  if ((ulong)(long)local_58 < uVar6) {\n                    sVar5 = (size_t)((local_58 - iVar18) + -2);\n                    uVar9 = lVar20 + 3 + sVar5;\n                    if (uVar21 <= uVar9) {\n                      do {\n                        uVar21 = uVar21 + 0x40;\n                      } while (uVar21 <= uVar9);\n                      lVar8 = sh_xrealloc(lVar8,uVar21,\"subst.c\",0x6d2);\n                    }\n                    *(byte *)(lVar8 + lVar20) = bVar1;\n                    lVar16 = sVar5 + lVar20 + 1;\n                    lVar19 = lVar16 + 1;\n                    strncpy((char *)(lVar8 + lVar20 + 1),pcVar7,sVar5);\n                    *(undefined *)(lVar8 + lVar16) = *(undefined *)(param_1 + -1 + (long)local_58);\n                    sh_xfree(pcVar7,\"subst.c\",0x6d7);\n                    local_90 = local_58;\n                    goto LAB_001699ba;\n                  }\n                  break;\n                }\n                local_58 = iVar18 + 2;\n                pcVar7 = (char *)xparse_dolparen(param_1,param_1 + local_58,&local_58,\n                                                 (uint)(no_longjmp_on_fatal_error != 0) << 6 |\n                                                 param_4);\n                if (uVar6 <= (ulong)(long)local_58) break;\n                sVar5 = (size_t)((local_58 - iVar18) + -1);\n                uVar9 = lVar20 + 4 + sVar5;\n                if (uVar21 <= uVar9) {\n                  do {\n                    uVar21 = uVar21 + 0x40;\n                  } while (uVar21 <= uVar9);\n                  lVar8 = sh_xrealloc(lVar8,uVar21,\"subst.c\",0x6b5);\n                }\n                *(byte *)(lVar8 + lVar20) = bVar1;\n                *(undefined *)(lVar8 + 1 + lVar20) = 0x28;\n                strncpy((char *)(lVar8 + lVar20 + 2),pcVar7,sVar5);\n                lVar16 = sVar5 + lVar20 + 2;\n                lVar19 = lVar16 + 1;\n                *(undefined *)(lVar8 + lVar16) = *(undefined *)(param_1 + local_58);\n                uVar11 = 0x6bb;\n              }\n            }\n            sh_xfree(pcVar7,\"subst.c\",uVar11);\n            local_90 = local_58 + 1;\n          }\n        }\nLAB_001699ba:\n        local_80 = iVar12;\n        lVar16 = (long)local_90;\n        pbVar14 = (byte *)(param_1 + lVar16);\n        bVar1 = *pbVar14;\n        lVar20 = lVar19;\n        iVar18 = local_90;\n      } while (bVar1 != 0);\n    }\n    sh_xfree(lVar8,\"subst.c\",0x6f5);\n    if (no_longjmp_on_fatal_error == 0) {\nLAB_0016a77d:\n      last_command_exit_value = 1;\n      report_error(\"bad substitution: no closing `%s\\' in %s\",&DAT_0020ef45,param_1);\n                    /* WARNING: Subroutine does not return */\n      FUN_001667f0(2);\n    }\n    *param_2 = local_90;\n    lVar8 = 0;\n  }\nLAB_0016946d:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar8;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "parser_error": "\nvoid parser_error(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined4 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  int iVar1;\n  char in_AL;\n  int iVar2;\n  char *__s1;\n  char *pcVar3;\n  char *pcVar4;\n  long in_FS_OFFSET;\n  undefined4 local_f8;\n  undefined4 local_f4;\n  undefined *local_f0;\n  undefined *local_e8;\n  long local_e0;\n  undefined local_d8 [16];\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined4 local_a8;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  \n  if (in_AL != '\\0') {\n    local_a8 = param_1;\n    local_98 = param_2;\n    local_88 = param_3;\n    local_78 = param_4;\n    local_68 = param_5;\n    local_58 = param_6;\n    local_48 = param_7;\n    local_38 = param_8;\n  }\n  local_e0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_c8 = param_11;\n  local_c0 = param_12;\n  local_b8 = param_13;\n  local_b0 = param_14;\n  __s1 = (char *)get_name_for_error();\n  pcVar3 = (char *)yy_input_name();\n  iVar1 = gnu_error_format;\n  if (interactive == 0) {\n    if ((interactive_shell == 0) && (*__s1 == *pcVar3)) {\n      iVar2 = strcmp(__s1,pcVar3);\n      if (iVar2 == 0) {\n        pcVar3 = \"\";\n        if (iVar1 == 0) {\n          pcVar3 = \" line \";\n        }\n        __fprintf_chk(stderr,1,\"%s:%s%d: \",__s1,pcVar3,param_9);\n        goto LAB_0015b9d2;\n      }\n    }\n    pcVar4 = \"\";\n    if (iVar1 == 0) {\n      pcVar4 = \" line \";\n    }\n    __fprintf_chk(stderr,1,\"%s: %s:%s%d: \",__s1,pcVar3,pcVar4,param_9);\n  }\n  else {\n    __fprintf_chk(stderr,1,&DAT_001fd57b,__s1);\n  }\nLAB_0015b9d2:\n  local_f0 = &stack0x00000008;\n  local_f8 = 0x10;\n  local_e8 = local_d8;\n  local_f4 = 0x30;\n  __vfprintf_chk(stderr,1,param_10,&local_f8);\n  fputc(10,stderr);\n  if (exit_immediately_on_error != 0) {\n    last_command_exit_value = 2;\n                    /* WARNING: Subroutine does not return */\n    exit_shell(2);\n  }\n  if (local_e0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00195170": "\nvoid FUN_00195170(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined4 uVar4;\n  \n  uVar4 = rl_completion_mode(FUN_00195170);\n  uVar3 = rl_completion_entry_function;\n  uVar2 = rl_attempted_completion_function;\n  uVar1 = rl_ignore_some_completions_function;\n  rl_attempted_completion_function = 0;\n  rl_completion_entry_function = command_word_completion_function;\n  rl_complete_internal(uVar4);\n  rl_completion_entry_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar2;\n  rl_ignore_some_completions_function = uVar1;\n  return;\n}\n\n",
  "yyerror": "\nundefined8 yyerror(void)\n\n{\n  if ((parser_state._2_1_ & 0x80) != 0) {\n    reset_parser();\n    return 0;\n  }\n  FUN_00135180(0);\n  reset_parser();\n  return 0;\n}\n\n",
  "bind_array_element": "\nvoid bind_array_element(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  FUN_0018a8b0(param_1,param_2,0,param_3,param_4);\n  return;\n}\n\n",
  "_rl_redisplay_after_sigwinch": "\nvoid _rl_redisplay_after_sigwinch(void)\n\n{\n  char *pcVar1;\n  \n  if (_rl_term_cr == 0) {\n    rl_crlf();\nLAB_001e72d1:\n    if (DAT_0024a88c <= _rl_screenwidth) goto LAB_001e72df;\n  }\n  else {\n    rl_clear_visible_line();\n    if (_rl_last_v_pos < 1) goto LAB_001e72d1;\n    _rl_move_vert(0);\n    if (DAT_0024a88c <= _rl_screenwidth) goto LAB_001e72df;\n  }\n  rl_visible_prompt_length = rl_expand_prompt(rl_prompt);\nLAB_001e72df:\n  pcVar1 = strrchr(rl_display_prompt,10);\n  if (pcVar1 != (char *)0x0) {\n    FUN_001e2490(pcVar1 + 1);\n    return;\n  }\n  rl_forced_update_display();\n  return;\n}\n\n",
  "check_signals_and_traps": "\nvoid check_signals_and_traps(void)\n\n{\n  check_read_timeout();\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n    run_pending_traps();\n    return;\n  }\n  run_pending_traps();\n  return;\n}\n\n",
  "zreadn": "\nlong zreadn(undefined8 param_1,undefined *param_2,ulong param_3)\n\n{\n  undefined *puVar1;\n  long lVar2;\n  \n  if ((DAT_00248ec8 == DAT_00248ec0) || (DAT_00248ec0 == 0)) {\n    if (0x1000 < param_3) {\n      param_3 = 0x1000;\n    }\n    lVar2 = zread(param_1,&DAT_00248ee0,param_3);\n    DAT_00248ec8 = 0;\n    DAT_00248ec0 = lVar2;\n    if (lVar2 < 1) {\n      DAT_00248ec0 = 0;\n      return lVar2;\n    }\n  }\n  if (param_2 != (undefined *)0x0) {\n    puVar1 = &DAT_00248ee0 + DAT_00248ec8;\n    DAT_00248ec8 = DAT_00248ec8 + 1;\n    *param_2 = *puVar1;\n  }\n  return 1;\n}\n\n",
  "FUN_001d5e50": "\nint FUN_001d5e50(char *param_1,char *param_2)\n\n{\n  int iVar1;\n  char *__s1;\n  \n  if ((((rl_filename_completion_desired != 0) && (rl_filename_quoting_desired != 0)) &&\n      (rl_completion_found_quote != 0)) && (rl_filename_dequoting_function != (code *)0x0)) {\n    __s1 = (char *)(*rl_filename_dequoting_function)(param_1,rl_completion_quote_character);\n    iVar1 = strcmp(__s1,param_2);\n    xfree(__s1);\n    return iVar1;\n  }\n  iVar1 = strcmp(param_1,param_2);\n  return iVar1;\n}\n\n",
  "sh_calloc": "\nvoid * sh_calloc(long param_1,long param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  void *__s;\n  \n  __s = (void *)FUN_001f85f0(param_2 * param_1,param_3,param_4);\n  if (__s != (void *)0x0) {\n    __s = memset(__s,0,param_2 * param_1);\n  }\n  return __s;\n}\n\n",
  "set_impossible_sigchld_trap": "\nvoid set_impossible_sigchld_trap(void)\n\n{\n  uint uVar1;\n  \n  restore_default_signal(0x11);\n  if ((DAT_00247e84 & 0x10) == 0) {\n    if ((((DAT_00247e84 & 1) == 0) || (DAT_00247a88 == initialize_traps)) ||\n       (DAT_00247a88 < (code *)0x2)) {\n      uVar1 = DAT_00247e84 & 0xffffffbf;\n    }\n    else {\n      sh_xfree(DAT_00247a88,\"trap.c\",0x347);\n      uVar1 = DAT_00247e84 & 0xffffffbf;\n      if ((DAT_00247e84 & 0x10) != 0) goto LAB_00182aba;\n    }\n    DAT_00247a88 = initialize_traps;\n    DAT_00247e84 = uVar1 & 0xfffffffe;\n    return;\n  }\n  uVar1 = DAT_00247e84 & 0xffffffbf;\nLAB_00182aba:\n  DAT_00247a88 = initialize_traps;\n  DAT_00247e84 = (uVar1 | 0x21) & 0xfffffffe;\n  return;\n}\n\n",
  "path_dot_or_dotdot": "\nbool path_dot_or_dotdot(char *param_1)\n\n{\n  char cVar1;\n  \n  if (param_1 == (char *)0x0) {\n    return false;\n  }\n  if (*param_1 == '.') {\n    cVar1 = param_1[1];\n    if ((cVar1 == '/') || (cVar1 == '\\0')) {\n      return true;\n    }\n    if (cVar1 == '.') {\n      return param_1[2] == '/' || param_1[2] == '\\0';\n    }\n  }\n  return false;\n}\n\n",
  "kill_current_pipeline": "\nvoid kill_current_pipeline(void)\n\n{\n  already_making_children = 0;\n  start_pipeline();\n  return;\n}\n\n",
  "rl_forward": "\nvoid rl_forward(void)\n\n{\n  rl_forward_char();\n  return;\n}\n\n",
  "discard_unwind_frame": "\nvoid discard_unwind_frame(char *param_1)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  undefined8 *puVar6;\n  \n  puVar6 = DAT_00248390;\n  if (DAT_00248390 == (undefined8 *)0x0) {\n    return;\n  }\n  do {\n    while( true ) {\n      puVar5 = (undefined8 *)*puVar6;\n      DAT_00248390 = puVar5;\n      if (((puVar6[1] == 0) && (*(char *)puVar6[2] == *param_1)) &&\n         (iVar1 = strcmp((char *)puVar6[2],param_1), iVar1 == 0)) {\n        if (DAT_0024838c < DAT_00248388) {\n          *puVar6 = 0xdfdfdfdfdfdfdfdf;\n          puVar5 = puVar6 + 1;\n          do {\n            *(undefined *)puVar5 = 0xdf;\n            puVar2 = puVar5 + 1;\n            *(undefined *)((long)puVar5 + 1) = 0xdf;\n            *(undefined *)((long)puVar5 + 2) = 0xdf;\n            *(undefined *)((long)puVar5 + 3) = 0xdf;\n            *(undefined *)((long)puVar5 + 4) = 0xdf;\n            *(undefined *)((long)puVar5 + 5) = 0xdf;\n            *(undefined *)((long)puVar5 + 6) = 0xdf;\n            *(undefined *)((long)puVar5 + 7) = 0xdf;\n            puVar5 = puVar2;\n          } while (puVar2 != puVar6 + 4);\n          lVar4 = (long)DAT_0024838c;\n          DAT_0024838c = DAT_0024838c + 1;\n          *(undefined8 **)(uwcache + lVar4 * 8) = puVar6;\n          return;\n        }\n        sh_xfree(puVar6,\"unwind_prot.c\",0x115);\n        return;\n      }\n      if (DAT_00248388 <= DAT_0024838c) break;\n      *puVar6 = 0xdfdfdfdfdfdfdfdf;\n      puVar2 = puVar6 + 1;\n      do {\n        *(undefined *)puVar2 = 0xdf;\n        puVar3 = puVar2 + 1;\n        *(undefined *)((long)puVar2 + 1) = 0xdf;\n        *(undefined *)((long)puVar2 + 2) = 0xdf;\n        *(undefined *)((long)puVar2 + 3) = 0xdf;\n        *(undefined *)((long)puVar2 + 4) = 0xdf;\n        *(undefined *)((long)puVar2 + 5) = 0xdf;\n        *(undefined *)((long)puVar2 + 6) = 0xdf;\n        *(undefined *)((long)puVar2 + 7) = 0xdf;\n        puVar2 = puVar3;\n      } while (puVar3 != puVar6 + 4);\n      lVar4 = (long)DAT_0024838c;\n      DAT_0024838c = DAT_0024838c + 1;\n      *(undefined8 **)(uwcache + lVar4 * 8) = puVar6;\n      puVar6 = puVar5;\n      if (puVar5 == (undefined8 *)0x0) goto LAB_0018441f;\n    }\n    sh_xfree(puVar6,\"unwind_prot.c\",0x11a);\n    puVar6 = DAT_00248390;\n  } while (DAT_00248390 != (undefined8 *)0x0);\nLAB_0018441f:\n  internal_warning(\"unwind_frame_discard: %s: frame not found\",param_1);\n  return;\n}\n\n",
  "progcomp_walk": "\nvoid progcomp_walk(long param_1)\n\n{\n  if (((prog_completes != 0) && (param_1 != 0)) && (*(int *)(prog_completes + 0xc) != 0)) {\n    hash_walk();\n    return;\n  }\n  return;\n}\n\n",
  "coproc_checkfd": "\nvoid coproc_checkfd(long param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar1 = *(int *)(param_1 + 0xc);\n  iVar2 = *(int *)(param_1 + 0x10);\n  if (iVar1 < 0) {\n    if (iVar2 < 0) {\n      return;\n    }\nLAB_0014a296:\n    if (param_2 != iVar2) {\n      return;\n    }\n  }\n  else {\n    if (iVar1 != param_2) {\n      if (iVar2 < 0) {\n        return;\n      }\n      goto LAB_0014a296;\n    }\n    *(undefined4 *)(param_1 + 0xc) = 0xffffffff;\n    if ((iVar2 < 0) || (iVar1 != iVar2)) goto LAB_0014a2b6;\n  }\n  *(undefined4 *)(param_1 + 0x10) = 0xffffffff;\nLAB_0014a2b6:\n  coproc_setvars();\n  return;\n}\n\n",
  "rl_add_defun": "\nundefined8 rl_add_defun(undefined8 param_1,undefined8 param_2,int param_3)\n\n{\n  if (param_3 != -1) {\n    rl_bind_key(param_3);\n  }\n  rl_add_funmap_entry(param_1,param_2);\n  return 0;\n}\n\n",
  "unbind_unix_command": "\nundefined8 unbind_unix_command(undefined8 param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  uVar2 = rl_get_keymap();\n  uVar2 = FUN_001944d0(uVar2);\n  iVar1 = rl_bind_keyseq_in_map(param_1,0,uVar2);\n  if (iVar1 == 0) {\n    return 1;\n  }\n  builtin_error(\"`%s\\': cannot unbind in command keymap\",param_1);\n  return 0;\n}\n\n",
  "FUN_001d4cd0": "\nundefined8 FUN_001d4cd0(long param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  \n  if (param_2 < 0) {\nswitchD_001d4cfc_caseD_3:\n    rl_ding();\n    goto LAB_001d4d55;\n  }\n  if (param_2 < 0x1c) {\n    if (2 < param_2) {\n      switch(param_2) {\n      case 3:\n      case 7:\n        goto switchD_001d4cfc_caseD_3;\n      default:\n        goto switchD_001d4cfc_caseD_4;\n      case 8:\n        goto switchD_001d4cfc_caseD_8;\n      case 10:\n      case 0xd:\n        return 0;\n      case 0x15:\n        rl_unix_line_discard(1,0x15);\n        break;\n      case 0x17:\n        rl_unix_word_rubout(1,0x17);\n        break;\n      case 0x1b:\n        if ((_rl_enable_bracketed_paste == 0) || (iVar1 = _rl_nchars_available(), iVar1 < 5)) {\n          _rl_insert_char(1,0x1b);\n        }\n        else {\n          iVar1 = _rl_read_bracketed_paste_prefix(0x1b);\n          if (iVar1 == 1) {\n            rl_bracketed_paste_begin(1,0x1b);\n          }\n          else {\n            uVar2 = rl_read_key();\n            _rl_insert_char(1,uVar2);\n          }\n        }\n      }\n      goto LAB_001d4d34;\n    }\n  }\n  else if (param_2 == 0x7f) {\nswitchD_001d4cfc_caseD_8:\n    if (rl_point == 0) {\nLAB_001d4d55:\n      rl_maybe_unsave_line();\n      rl_point = *(undefined4 *)(param_1 + 0x30);\n      rl_mark = *(undefined4 *)(param_1 + 0x34);\n      rl_restore_prompt();\n      rl_clear_message();\n      _rl_fix_point(1);\n      rl_readline_state = rl_readline_state & 0xfffffffffffffeff;\n      return 0xffffffff;\n    }\n    _rl_rubout_char(1);\n    goto LAB_001d4d34;\n  }\nswitchD_001d4cfc_caseD_4:\n  sVar3 = __ctype_get_mb_cur_max();\n  if ((sVar3 < 2) || (rl_byte_oriented != 0)) {\n    _rl_insert_char(1);\n  }\n  else {\n    rl_insert_text(param_1 + 0x70,param_2);\n  }\nLAB_001d4d34:\n  (*(code *)rl_redisplay_function)();\n  rl_deactivate_mark();\n  return 1;\n}\n\n",
  "command_word_completion_function": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nchar * command_word_completion_function(char *param_1,int param_2)\n\n{\n  code *pcVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  char *pcVar5;\n  size_t sVar6;\n  char *pcVar7;\n  char **ppcVar8;\n  long lVar9;\n  undefined2 *puVar10;\n  undefined2 *puVar11;\n  char cVar12;\n  size_t __n;\n  undefined8 uVar13;\n  code *pcVar14;\n  uint uVar15;\n  long lVar16;\n  long in_FS_OFFSET;\n  undefined local_49;\n  undefined8 local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 0) {\n    rl_filename_stat_hook = FUN_00194470;\n    iVar3 = 0;\n    if (DAT_00248790 == (char *)0x0) {\nLAB_00196693:\n      if (DAT_00248788 != (char *)0x0) goto LAB_00196698;\n    }\n    else {\n      if (DAT_00248790 != DAT_00248788) {\n        iVar3 = 0x1ff311;\n        sh_xfree(DAT_00248790,\"bashline.c\",0x7c9);\n        goto LAB_00196693;\n      }\nLAB_00196698:\n      iVar3 = 0x1ff311;\n      sh_xfree(DAT_00248788,\"bashline.c\",0x7cb);\n    }\n    DAT_00248780 = 0;\n    DAT_0024877c = 0;\n    iVar2 = absolute_pathname(param_1);\n    if (((iVar2 == 0) && (iVar2 = absolute_program(param_1), iVar2 == 0)) && (*param_1 != '~')) {\n      uVar13 = bash_tilde_expand(param_1,0);\n      iVar2 = file_isdir(uVar13);\n      iVar3 = 0x1ff311;\n      sh_xfree(uVar13,\"bashline.c\",0xc38);\n      DAT_00248778 = (uint)(iVar2 != 0);\n    }\n    else {\n      DAT_00248778 = 0;\n    }\n    DAT_00248770 = (char *)0x0;\n    pcVar5 = (char *)rl_variable_value(\"completion-ignore-case\");\n    DAT_00248768 = 0;\n    if ((*pcVar5 == 'o') && (pcVar5[1] == 'n')) {\n      DAT_00248768 = (uint)(pcVar5[2] == '\\0');\n    }\n    DAT_00248764 = glob_ignore_case;\n    if (DAT_00248850 != (char **)0x0) {\n      iVar3 = 0x1ff311;\n      sh_xfree(DAT_00248850,\"bashline.c\",0x7d8);\n      DAT_00248850 = (char **)0x0;\n    }\n    iVar3 = glob_pattern_p(param_1,iVar3);\n    DAT_00248760 = (uint)(iVar3 == 1);\n    if ((iVar3 != 1) && (iVar3 = absolute_program(param_1), iVar3 == 0)) {\n      sVar6 = strlen(param_1);\n      pcVar5 = (char *)sh_xmalloc(sVar6 + 1,\"bashline.c\",0x824);\n      pcVar5 = strcpy(pcVar5,param_1);\n      DAT_00248788 = pcVar5;\n      DAT_00248790 = pcVar5;\n      sVar6 = strlen(pcVar5);\n      DAT_00248750 = (int)sVar6;\n      if ((rl_completion_found_quote != 0) && (rl_completion_quote_character == 0)) {\n        DAT_00248790 = (char *)FUN_00191560(pcVar5,0);\n      }\n      DAT_00248730 = get_string_value(\"PATH\");\n      _DAT_00248874 = 0;\n      DAT_0024872c = 0;\n      DAT_00248728 = 0;\n      if (DAT_00248720 != 0) {\n        sh_xfree(DAT_00248720,\"bashline.c\",0x831);\n      }\n      DAT_00248720 = all_visible_functions();\n      if (DAT_00248718 != 0) {\n        sh_xfree(DAT_00248718,\"bashline.c\",0x837);\n      }\n      DAT_00248718 = all_aliases();\n      goto LAB_00196990;\n    }\n    if (*param_1 == '~') {\n      DAT_00248788 = (char *)bash_tilde_expand(param_1,0);\n      sVar6 = strlen(param_1);\n      pcVar5 = (char *)sh_xmalloc(sVar6 + 1,\"bashline.c\",0x7eb);\n      pcVar5 = strcpy(pcVar5,param_1);\n      DAT_00248758 = pcVar5;\n      pcVar7 = strchr(pcVar5,0x2f);\n      if (pcVar7 == (char *)0x0) {\n        sh_xfree(pcVar5,\"bashline.c\",0x7f1);\n        DAT_00248758 = (char *)0x0;\n      }\n      else {\n        *pcVar7 = '\\0';\n      }\n    }\n    else {\n      sVar6 = strlen(param_1);\n      if (dircomplete_expand == 0) {\n        pcVar5 = (char *)sh_xmalloc(sVar6 + 1,\"bashline.c\",0x7fb);\n        DAT_00248788 = strcpy(pcVar5,param_1);\n      }\n      else {\n        pcVar5 = (char *)sh_xmalloc(sVar6 + 1,\"bashline.c\",0x7f7);\n        DAT_00248788 = strcpy(pcVar5,param_1);\n        FUN_00195b80(&DAT_00248788);\n      }\n    }\n    DAT_00248790 = DAT_00248788;\n    if ((rl_completion_found_quote != 0) && (rl_completion_quote_character == 0)) {\n      DAT_00248790 = (char *)FUN_00191560(DAT_00248788,0);\n      sh_xfree(DAT_00248788,\"bashline.c\",0x806);\n    }\n    pcVar5 = DAT_00248790;\n    DAT_00248788 = DAT_00248790;\n    sVar6 = strlen(DAT_00248790);\n    DAT_00248750 = (int)sVar6;\n    if (DAT_00248748 != (char *)0x0) {\n      sh_xfree(DAT_00248748,\"bashline.c\",0x80c);\n      pcVar5 = DAT_00248788;\n    }\n    sVar6 = strlen(pcVar5);\n    pcVar7 = (char *)sh_xmalloc(sVar6 + 1,\"bashline.c\",0x80e);\n    DAT_00248740 = strcpy(pcVar7,pcVar5);\n    DAT_00248738 = 0;\n    DAT_00248748 = DAT_00248740;\n    if (DAT_00248760 == 0) {\n      uVar15 = dircomplete_expand;\n      if ((dircomplete_expand != 0) &&\n         (iVar3 = path_dot_or_dotdot(DAT_00248740), uVar15 = DAT_00248738, iVar3 != 0)) {\n        rl_directory_completion_hook = (code *)0x0;\n        rl_directory_rewrite_hook = FUN_00195b80;\n        dircomplete_expand = 1;\n      }\n      DAT_0024877c = 4;\n      do {\n        do {\n          while( true ) {\n            DAT_00248770 = (char *)rl_filename_completion_function(DAT_00248740,uVar15);\n            if ((DAT_0024877c == 4) && (dircomplete_expand != 0)) {\n              rl_directory_rewrite_hook = (code *)0x0;\n              rl_directory_completion_hook = FUN_00195b80;\n            }\n            DAT_00248738 = 1;\n            if (DAT_00248770 == (char *)0x0) break;\n            iVar3 = absolute_program(DAT_00248788);\n            pcVar14 = rl_directory_rewrite_hook;\n            pcVar5 = DAT_00248770;\n            if (iVar3 == 0) {\n              pcVar7 = strrchr(DAT_00248770,0x2f);\n              if (pcVar7 != (char *)0x0) {\n                pcVar7 = pcVar7 + 1;\n                if (DAT_00248768 == 0) {\n                  iVar3 = strncmp(pcVar7,DAT_00248788,(long)DAT_00248750);\n                }\n                else {\n                  iVar3 = strncasecmp(pcVar7,DAT_00248788,(long)DAT_00248750);\n                }\n                if (iVar3 == 0) {\n                  sVar6 = strlen(pcVar7);\n                  uVar13 = 0x928;\n                  pcVar5 = pcVar7;\n                  goto LAB_001970ab;\n                }\n              }\n            }\n            else {\n              if (*param_1 == '~') {\n                if (dircomplete_expand == 0) {\n                  rl_directory_rewrite_hook = (code *)0x0;\n                  pcVar7 = (char *)FUN_00191750(DAT_00248770,DAT_00248758);\n                  pcVar1 = rl_directory_rewrite_hook;\n                  if ((pcVar14 != (code *)0x0) && (pcVar1 = pcVar14, dircomplete_expand != 0)) {\n                    pcVar1 = rl_directory_rewrite_hook;\n                    rl_directory_completion_hook = pcVar14;\n                  }\n                }\n                else {\n                  pcVar7 = (char *)FUN_00191750(DAT_00248770,DAT_00248758);\n                  pcVar1 = rl_directory_rewrite_hook;\n                }\n              }\n              else {\n                sVar6 = strlen(DAT_00248770);\n                uVar13 = 0x919;\nLAB_001970ab:\n                pcVar7 = (char *)sh_xmalloc(sVar6 + 1,\"bashline.c\",uVar13);\n                pcVar7 = strcpy(pcVar7,pcVar5);\n                pcVar1 = rl_directory_rewrite_hook;\n              }\n              rl_directory_rewrite_hook = pcVar1;\n              iVar3 = DAT_00248780;\n              pcVar5 = DAT_00248770;\n              local_49 = 0;\n              local_48 = FUN_00195700(DAT_00248770,1,&local_49);\n              FUN_00195b80(&local_48);\n              uVar13 = local_48;\n              if (iVar3 == 0) {\n                iVar3 = executable_or_directory();\n              }\n              else {\n                iVar3 = executable_file();\n              }\n              sh_xfree(uVar13,\"bashline.c\",0x7a4);\n              if (iVar3 != 0) {\n                if (DAT_00248770 != pcVar5) {\n                  sh_xfree(pcVar5,\"bashline.c\",0x94d);\n                  pcVar5 = DAT_00248770;\n                }\n                sh_xfree(pcVar5,\"bashline.c\",0x94e);\n                DAT_00248770 = \"\";\n                goto LAB_00196c30;\n              }\n              sh_xfree(pcVar7,\"bashline.c\",0x955);\n              if (DAT_00248770 != pcVar5) {\n                sh_xfree(pcVar5,\"bashline.c\",0x957);\n                pcVar5 = DAT_00248770;\n              }\n            }\n            sh_xfree(pcVar5,\"bashline.c\",0x958);\n            uVar15 = DAT_00248738;\n          }\n          iVar3 = absolute_program(DAT_00248788);\n          if (iVar3 != 0) goto LAB_001972fd;\nLAB_00196c70:\n          DAT_00248738 = (uint)(DAT_00248770 != (char *)0x0);\n          uVar15 = DAT_00248738;\n        } while (DAT_00248770 != (char *)0x0);\n        if (((DAT_00248730 == 0) || (*(char *)(DAT_00248730 + DAT_0024872c) == '\\0')) ||\n           (puVar10 = (undefined2 *)extract_colon_unit(DAT_00248730,&DAT_0024872c),\n           puVar10 == (undefined2 *)0x0)) goto LAB_001972fd;\n        cVar12 = *(char *)puVar10;\n        DAT_00248780 = 1;\n        if (cVar12 == '\\0') {\n          sh_xfree(puVar10,\"bashline.c\",0x8d2);\n          puVar10 = (undefined2 *)sh_xmalloc(2,\"bashline.c\",0x8d3);\n          cVar12 = '.';\n          *puVar10 = 0x2e;\n        }\n        puVar11 = puVar10;\n        if (cVar12 == '~') {\n          puVar11 = (undefined2 *)bash_tilde_expand(puVar10,0);\n          sh_xfree(puVar10,\"bashline.c\",0x8db);\n          cVar12 = *(char *)puVar11;\n        }\n        if ((cVar12 == '.') && (*(char *)((long)puVar11 + 1) == '\\0')) {\n          _DAT_00248874 = 1;\n        }\n        if (DAT_00248740 == (char *)0x0) {\nLAB_00196d21:\n          pcVar5 = DAT_00248748;\n          if (DAT_00248748 != (char *)0x0) goto LAB_001975d0;\n        }\n        else {\n          pcVar5 = DAT_00248740;\n          if (DAT_00248748 != DAT_00248740) {\n            sh_xfree(DAT_00248740,\"bashline.c\",0x8e3);\n            goto LAB_00196d21;\n          }\nLAB_001975d0:\n          sh_xfree(pcVar5,\"bashline.c\",0x8e5);\n        }\n        pcVar5 = (char *)sh_makepath(puVar11,DAT_00248788,0);\n        DAT_00248748 = pcVar5;\n        pcVar7 = strpbrk(pcVar5,\"\\\"\\'\\\\\");\n        if (pcVar7 != (char *)0x0) {\n          pcVar5 = (char *)sh_backslash_quote(pcVar5,&DAT_00248880,0);\n        }\n        DAT_00248740 = pcVar5;\n        sh_xfree(puVar11,\"bashline.c\",0x8f0);\n        uVar15 = DAT_00248738;\n      } while( true );\n    }\n    DAT_0024877c = 5;\nLAB_00196833:\n    rl_filename_completion_desired = 1;\n    glob_ignore_case = DAT_00248768;\n    ppcVar8 = (char **)shell_glob_filename(DAT_00248788,0);\n    glob_ignore_case = DAT_00248764;\n    if ((ppcVar8 == (char **)0x0) || (ppcVar8 == (char **)&glob_error_return)) {\n      DAT_00248850 = (char **)0x0;\n      pcVar7 = (char *)0x0;\n    }\n    else {\n      DAT_00248728 = 0;\n      DAT_00248850 = ppcVar8;\n      if ((ppcVar8[1] == (char *)0x0) || (rl_completion_type != 9)) {\n        DAT_00248728 = 1;\n        goto LAB_00196ba5;\n      }\nLAB_001972fd:\n      pcVar7 = (char *)0x0;\n    }\n  }\n  else {\nLAB_00196990:\n    pcVar5 = DAT_00248788;\n    uVar15 = DAT_00248768;\n    iVar3 = DAT_00248750;\n    lVar9 = DAT_00248718;\n    if (DAT_0024877c == 2) {\nLAB_00196f21:\n      pcVar5 = DAT_00248788;\n      uVar15 = DAT_00248768;\n      iVar3 = DAT_00248750;\n      lVar9 = DAT_00248720;\n      if (DAT_00248720 != 0) {\n        sVar6 = (size_t)DAT_00248750;\n        for (lVar16 = (long)(DAT_00248728 + 1); ppcVar8 = *(char ***)(lVar9 + -8 + lVar16 * 8),\n            ppcVar8 != (char **)0x0; lVar16 = lVar16 + 1) {\n          pcVar7 = *ppcVar8;\n          DAT_00248728 = (int)lVar16;\n          if (uVar15 == 0) {\n            if ((iVar3 == 0) ||\n               ((*pcVar7 == *pcVar5 && (iVar2 = strncmp(pcVar7,pcVar5,sVar6), iVar2 == 0)))) {\n              sVar6 = strlen(pcVar7);\n              uVar13 = 0x86b;\nLAB_00196fbd:\n              pcVar5 = (char *)sh_xmalloc(sVar6 + 1,\"bashline.c\",uVar13);\n              param_1 = pcVar7;\n              if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) goto LAB_00197666;\n              goto LAB_00196a7f;\n            }\n          }\n          else {\n            iVar2 = strncasecmp(pcVar7,pcVar5,sVar6);\n            if (iVar2 == 0) {\n              sVar6 = strlen(pcVar7);\n              uVar13 = 0x86d;\n              goto LAB_00196fbd;\n            }\n          }\n        }\n      }\n      DAT_0024877c = DAT_0024877c + 1;\n      DAT_00248728 = 0;\nLAB_00196aa8:\n      pcVar5 = DAT_00248788;\n      iVar3 = num_shell_builtins;\n      if (DAT_00248728 < num_shell_builtins) {\n        __n = (size_t)DAT_00248750;\n        ppcVar8 = (char **)(shell_builtins + (long)DAT_00248728 * 0x30);\n        sVar6 = __n;\n        do {\n          iVar2 = DAT_00248728;\n          if ((ppcVar8[1] != (char *)0x0) && ((*(byte *)(ppcVar8 + 2) & 1) != 0)) {\n            pcVar7 = *ppcVar8;\n            if ((int)sVar6 == 0) {\nLAB_00196b3c:\n              DAT_00248728 = iVar2 + 1;\n              sVar6 = strlen(pcVar7);\n              uVar13 = 0x87f;\n              param_1 = pcVar7;\nLAB_00196a59:\n              pcVar5 = (char *)sh_xmalloc(sVar6 + 1,\"bashline.c\",uVar13);\n              if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) goto LAB_00196a7f;\n              goto LAB_00197666;\n            }\n            if (*pcVar7 == *pcVar5) {\n              iVar4 = strncmp(pcVar7,pcVar5,__n);\n              sVar6 = sVar6 & 0xffffffff;\n              if (iVar4 == 0) goto LAB_00196b3c;\n            }\n          }\n          DAT_00248728 = iVar2 + 1;\n          ppcVar8 = ppcVar8 + 6;\n        } while (DAT_00248728 != iVar3);\n      }\n      DAT_0024877c = DAT_0024877c + 1;\n      DAT_00248728 = 0;\n    }\n    else {\n      if (DAT_0024877c < 3) {\n        if (DAT_0024877c == 0) {\n          if (DAT_00248718 != 0) {\n            sVar6 = (size_t)DAT_00248750;\n            for (lVar16 = (long)(DAT_00248728 + 1); ppcVar8 = *(char ***)(lVar9 + -8 + lVar16 * 8),\n                ppcVar8 != (char **)0x0; lVar16 = lVar16 + 1) {\n              pcVar7 = *ppcVar8;\n              DAT_00248728 = (int)lVar16;\n              if (uVar15 == 0) {\n                if ((iVar3 == 0) ||\n                   ((*pcVar7 == *pcVar5 && (iVar2 = strncmp(pcVar7,pcVar5,sVar6), iVar2 == 0)))) {\n                  sVar6 = strlen(pcVar7);\n                  uVar13 = 0x84b;\nLAB_00196e4c:\n                  pcVar5 = (char *)sh_xmalloc(sVar6 + 1,\"bashline.c\",uVar13);\n                  param_1 = pcVar7;\n                  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) goto LAB_00197666;\n                  goto LAB_00196a7f;\n                }\n              }\n              else {\n                iVar2 = strncasecmp(pcVar7,pcVar5,sVar6);\n                if (iVar2 == 0) {\n                  sVar6 = strlen(pcVar7);\n                  uVar13 = 0x84d;\n                  goto LAB_00196e4c;\n                }\n              }\n            }\n          }\n          DAT_0024877c = 1;\n          DAT_00248728 = 0;\n        }\n        else if (DAT_0024877c != 1) goto LAB_00196b71;\n        pcVar7 = DAT_00248788;\n        iVar3 = DAT_00248750;\n        pcVar5 = (&word_token_alist)[(long)DAT_00248728 * 2];\n        if (pcVar5 != (char *)0x0) {\n          sVar6 = (size_t)DAT_00248750;\n          lVar9 = (long)(DAT_00248728 + 1);\n          do {\n            DAT_00248728 = (int)lVar9;\n            if ((iVar3 == 0) ||\n               ((*pcVar5 == *pcVar7 && (iVar2 = strncmp(pcVar5,pcVar7,sVar6), iVar2 == 0)))) {\n              sVar6 = strlen(pcVar5);\n              uVar13 = 0x85c;\n              param_1 = pcVar5;\n              goto LAB_00196a59;\n            }\n            lVar9 = lVar9 + 1;\n            pcVar5 = *(char **)(&DAT_00238270 + lVar9 * 0x10);\n          } while (pcVar5 != (char *)0x0);\n        }\n        DAT_0024877c = DAT_0024877c + 1;\n        DAT_00248728 = 0;\n        goto LAB_00196f21;\n      }\n      if (DAT_0024877c == 3) goto LAB_00196aa8;\n    }\nLAB_00196b71:\n    if (DAT_00248760 == 0) {\n      if (DAT_00248778 == 0) goto LAB_00196c70;\n      DAT_00248778 = 0;\n      sVar6 = strlen(param_1);\n      pcVar5 = (char *)sh_xmalloc(sVar6 + 1,\"bashline.c\",0x8bb);\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\nLAB_00196a7f:\n        pcVar5 = strcpy(pcVar5,param_1);\n        return pcVar5;\n      }\n      goto LAB_00197666;\n    }\n    if (param_2 == 0) goto LAB_00196833;\n    ppcVar8 = DAT_00248850 + DAT_00248728;\n    DAT_00248728 = DAT_00248728 + 1;\nLAB_00196ba5:\n    DAT_00248770 = *ppcVar8;\n    while (DAT_00248770 != (char *)0x0) {\n      iVar3 = executable_or_directory();\n      pcVar14 = rl_directory_rewrite_hook;\n      if (iVar3 != 0) {\n        pcVar7 = DAT_00248770;\n        if ((*param_1 == '~') && (DAT_00248758 != (char *)0x0)) {\n          if (dircomplete_expand == 0) {\n            rl_directory_rewrite_hook = (code *)0x0;\n            pcVar7 = (char *)FUN_00191750(DAT_00248770);\n            pcVar1 = rl_directory_rewrite_hook;\n            if ((pcVar14 != (code *)0x0) && (pcVar1 = pcVar14, dircomplete_expand != 0)) {\n              pcVar1 = rl_directory_rewrite_hook;\n              rl_directory_completion_hook = pcVar14;\n            }\n          }\n          else {\n            pcVar7 = (char *)FUN_00191750(DAT_00248770);\n            pcVar1 = rl_directory_rewrite_hook;\n          }\n          rl_directory_rewrite_hook = pcVar1;\n          sh_xfree(DAT_00248770,\"bashline.c\",0x8a8);\n          DAT_00248770 = pcVar7;\n        }\n        goto LAB_00196c30;\n      }\n      sh_xfree(DAT_00248770,\"bashline.c\",0x8ad);\n      lVar9 = (long)DAT_00248728;\n      DAT_00248728 = DAT_00248728 + 1;\n      DAT_00248770 = DAT_00248850[lVar9];\n    }\n    pcVar7 = (char *)0x0;\n    glob_ignore_case = DAT_00248764;\n  }\nLAB_00196c30:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pcVar7;\n  }\nLAB_00197666:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_hs_replace_history_data": "\nvoid _hs_replace_history_data(int param_1,long param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  long lVar5;\n  \n  lVar3 = DAT_0024b6e8;\n  if ((((-3 < param_1) && (history_length != 0)) && (param_1 < history_length)) &&\n     (DAT_0024b6e8 != 0)) {\n    if (param_1 < 0) {\n      lVar4 = (long)history_length;\n      lVar2 = 0;\n      lVar5 = -1;\n      if (history_length < 1) {\n        return;\n      }\n      do {\n        lVar1 = *(long *)(lVar3 + lVar2 * 8);\n        if (((lVar1 != 0) && (*(long *)(lVar1 + 0x10) == param_2)) &&\n           (lVar5 = (long)(int)lVar2, param_1 == -1)) {\n          *(undefined8 *)(lVar1 + 0x10) = param_3;\n        }\n        lVar2 = lVar2 + 1;\n      } while (lVar2 != lVar4);\n      if (param_1 != -2) {\n        return;\n      }\n      if ((int)lVar5 < 0) {\n        return;\n      }\n      lVar3 = *(long *)(lVar3 + lVar5 * 8);\n    }\n    else {\n      lVar3 = *(long *)(DAT_0024b6e8 + (long)param_1 * 8);\n      if (lVar3 == 0) {\n        return;\n      }\n      if (*(long *)(lVar3 + 0x10) != param_2) {\n        return;\n      }\n    }\n    *(undefined8 *)(lVar3 + 0x10) = param_3;\n  }\n  return;\n}\n\n",
  "set_locale_var": "\nuint set_locale_var(char *param_1,char *param_2)\n\n{\n  char cVar1;\n  uint uVar2;\n  int *piVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  size_t sVar7;\n  \n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  if (*param_1 == 'T') {\n    if (param_1[10] == '\\0') {\n      if (DAT_002489c0 != (char *)0x0) {\n        sh_xfree(DAT_002489c0,\"locale.c\",0xbb);\n      }\n      if (param_2 != (char *)0x0) {\n        sVar7 = strlen(param_2);\n        pcVar4 = (char *)sh_xmalloc(sVar7 + 1,\"locale.c\",0xbc);\n        param_2 = strcpy(pcVar4,param_2);\n      }\n      DAT_002489c0 = param_2;\n      return 1;\n    }\n    if (DAT_002489b8 != (char *)0x0) {\n      sh_xfree(DAT_002489b8,\"locale.c\",0xc3);\n    }\n    if (param_2 != (char *)0x0) {\n      sVar7 = strlen(param_2);\n      pcVar4 = (char *)sh_xmalloc(sVar7 + 1,\"locale.c\",0xc4);\n      param_2 = strcpy(pcVar4,param_2);\n    }\n    DAT_002489b8 = param_2;\n    return 1;\n  }\n  cVar1 = param_1[3];\n  if (cVar1 != 'A') {\n    if (cVar1 == 'C') {\n      if (param_1[4] == 'T') {\n        if ((DAT_002489b0 != (char *)0x0) && (*DAT_002489b0 != '\\0')) {\n          return 1;\n        }\n        pcVar4 = (char *)get_locale_var();\n        pcVar4 = setlocale(0,pcVar4);\n        FUN_0019a310();\n        sVar7 = __ctype_get_mb_cur_max();\n        locale_mb_cur_max = (undefined4)sVar7;\n        if (pcVar4 != (char *)0x0) {\n          locale_utf8locale = FUN_0019a3c0();\n        }\n        locale_shiftstates = mblen((char *)0x0,0);\n        u32reset();\n      }\n      else {\n        if (param_1[4] != 'O') {\n          return 1;\n        }\n        if ((DAT_002489b0 != (char *)0x0) && (*DAT_002489b0 != '\\0')) {\n          return 1;\n        }\n        pcVar4 = (char *)get_locale_var(\"LC_COLLATE\");\n        pcVar4 = setlocale(3,pcVar4);\n      }\n    }\n    else if (cVar1 == 'M') {\n      if (param_1[4] != 'E') {\n        return 1;\n      }\n      if ((DAT_002489b0 != (char *)0x0) && (*DAT_002489b0 != '\\0')) {\n        return 1;\n      }\n      pcVar4 = (char *)get_locale_var(\"LC_MESSAGES\");\n      pcVar4 = setlocale(5,pcVar4);\n    }\n    else if (cVar1 == 'N') {\n      if (param_1[4] != 'U') {\n        return 1;\n      }\n      if ((DAT_002489b0 != (char *)0x0) && (*DAT_002489b0 != '\\0')) {\n        return 1;\n      }\n      pcVar4 = (char *)get_locale_var(\"LC_NUMERIC\");\n      pcVar4 = setlocale(1,pcVar4);\n    }\n    else {\n      if (cVar1 != 'T') {\n        return 1;\n      }\n      if (param_1[4] != 'I') {\n        return 1;\n      }\n      if ((DAT_002489b0 != (char *)0x0) && (*DAT_002489b0 != '\\0')) {\n        return 1;\n      }\n      pcVar4 = (char *)get_locale_var(\"LC_TIME\");\n      pcVar4 = setlocale(2,pcVar4);\n    }\n    if (pcVar4 == (char *)0x0) {\n      if (*piVar3 == 0) {\n        uVar5 = get_locale_var(param_1);\n        internal_warning(\"setlocale: %s: cannot change locale (%s)\",param_1,uVar5);\n        uVar2 = 0;\n      }\n      else {\n        pcVar4 = strerror(*piVar3);\n        uVar5 = get_locale_var(param_1);\n        uVar2 = 0;\n        internal_warning(\"setlocale: %s: cannot change locale (%s): %s\",param_1,uVar5,pcVar4);\n      }\n    }\n    else {\n      uVar2 = 1;\n    }\n    return uVar2;\n  }\n  if (DAT_002489b0 != (char *)0x0) {\n    sh_xfree(DAT_002489b0,\"locale.c\",0xce);\n  }\n  if (param_2 == (char *)0x0) {\n    DAT_002489b0 = (char *)sh_xmalloc(1,\"locale.c\",0xd3);\n    *DAT_002489b0 = '\\0';\nLAB_0019abfc:\n    uVar2 = FUN_0019a780();\n  }\n  else {\n    sVar7 = strlen(param_2);\n    pcVar4 = (char *)sh_xmalloc(sVar7 + 1,\"locale.c\",0xd0);\n    pcVar4 = strcpy(pcVar4,param_2);\n    DAT_002489b0 = pcVar4;\n    if (*pcVar4 == '\\0') goto LAB_0019abfc;\n    pcVar6 = setlocale(6,pcVar4);\n    uVar2 = (uint)(pcVar6 != (char *)0x0);\n    if (pcVar6 == (char *)0x0) {\n      if (*piVar3 == 0) {\n        internal_warning();\n      }\n      else {\n        pcVar6 = strerror(*piVar3);\n        internal_warning(\"setlocale: LC_ALL: cannot change locale (%s): %s\",pcVar4,pcVar6);\n      }\n      FUN_0019a310();\n      sVar7 = __ctype_get_mb_cur_max();\n      locale_mb_cur_max = (undefined4)sVar7;\n      goto LAB_0019abc4;\n    }\n  }\n  FUN_0019a310();\n  sVar7 = __ctype_get_mb_cur_max();\n  locale_mb_cur_max = (undefined4)sVar7;\n  if (*DAT_002489b0 != '\\0') {\n    locale_utf8locale = FUN_0019a3c0();\n  }\nLAB_0019abc4:\n  locale_shiftstates = mblen((char *)0x0,0);\n  u32reset();\n  return uVar2;\n}\n\n",
  "make_local_assoc_variable": "\nlong make_local_assoc_variable(undefined8 param_1,uint param_2)\n\n{\n  uint uVar1;\n  long lVar2;\n  undefined8 uVar3;\n  \n  lVar2 = make_local_variable(param_1,param_2 & 4);\n  if ((lVar2 != 0) && (uVar1 = *(uint *)(lVar2 + 0x28), (uVar1 & 0x40) == 0)) {\n    if ((param_2 & 2) == 0) {\n      if (localvar_inherit == 0) {\nLAB_00154935:\n        FUN_001522f0(*(undefined8 *)(lVar2 + 8));\n        uVar3 = hash_create(0x400);\n        *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) | 0x40;\n        *(undefined8 *)(lVar2 + 8) = uVar3;\n        return lVar2;\n      }\n      if ((uVar1 & 4) != 0) {\n        internal_warning(\"%s: cannot inherit value from incompatible type\",param_1);\n        *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) & 0xfffffffb;\n        goto LAB_00154935;\n      }\n    }\n    else {\n      if ((uVar1 & 4) != 0) {\n        return lVar2;\n      }\n      if (localvar_inherit == 0) goto LAB_00154935;\n    }\n    lVar2 = convert_var_to_assoc(lVar2);\n    *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) | 0x40;\n  }\n  return lVar2;\n}\n\n",
  "FUN_0019e9b0": "\nvoid FUN_0019e9b0(undefined8 param_1)\n\n{\n  FUN_0019e8a0(param_1,0xffffffff);\n  return;\n}\n\n",
  "make_case_command": "\nvoid make_case_command(undefined8 param_1,long *param_2,undefined4 param_3)\n\n{\n  undefined4 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x18,\"make_cmd.c\",0x169);\n  *puVar1 = 0;\n  puVar1[1] = param_3;\n  *(undefined8 *)(puVar1 + 2) = param_1;\n  if ((param_2 != (long *)0x0) && (*param_2 != 0)) {\n    param_2 = (long *)list_reverse(param_2);\n  }\n  *(long **)(puVar1 + 4) = param_2;\n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar2[3] = puVar1;\n  *puVar2 = 1;\n  *puVar1 = 0;\n  puVar2[2] = 0;\n  return;\n}\n\n",
  "FUN_001cf980": "\nundefined8 FUN_001cf980(void)\n\n{\n  int iVar1;\n  \n  rl_readline_state = rl_readline_state | 0x40;\n  iVar1 = rl_read_key();\n  rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n  if (iVar1 == 0x60) {\n    rl_point = rl_mark;\n    _rl_fix_point(1);\n    return 0;\n  }\n  if (iVar1 - 0x61U < 0x1a) {\n    if (*(int *)(&DAT_0024a360 + (long)(int)(iVar1 - 0x61U) * 4) != -1) {\n      rl_point = *(int *)(&DAT_0024a360 + (long)(int)(iVar1 - 0x61U) * 4);\n      _rl_fix_point(1);\n      return 0;\n    }\n  }\n  rl_ding();\n  return 1;\n}\n\n",
  "rl_set_retained_kills": "\nundefined8 rl_set_retained_kills(void)\n\n{\n  return 0;\n}\n\n",
  "putchar": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putchar(int __c)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_putchar_00237840)();\n  return iVar1;\n}\n\n",
  "initialize_itemlist": "\nvoid initialize_itemlist(uint *param_1)\n\n{\n  (**(code **)(param_1 + 2))();\n  *param_1 = *param_1 & 0xfffffffd | 4;\n  return;\n}\n\n",
  "FUN_001a8720": "\nvoid FUN_001a8720(undefined8 param_1)\n\n{\n  if (the_printed_command_except_trap != 0) {\n    sh_xfree(the_printed_command_except_trap,\"evalstring.c\",0x53);\n  }\n  the_printed_command_except_trap = param_1;\n  return;\n}\n\n",
  "ttcbreak": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint ttcbreak(void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  termios local_58;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00249ee0 == 0) {\n    iVar1 = -1;\n  }\n  else {\n    local_58._48_8_ = DAT_00249f70;\n    local_58.c_cflag = tRam0000000000249f48;\n    local_58.c_ospeed = DAT_00249f78;\n    local_58._16_4_ = _DAT_00249f50;\n    local_58.c_cc._7_4_ = uRam0000000000249f58;\n    local_58.c_cc._11_4_ = uRam0000000000249f5c;\n    local_58.c_cc._15_4_ = _DAT_00249f60;\n    local_58.c_cc._19_4_ = uRam0000000000249f64;\n    local_58.c_cc._23_4_ = uRam0000000000249f68;\n    local_58.c_cc._27_4_ = uRam0000000000249f6c;\n    local_58.c_iflag = _DAT_00249f40 & 0xffffffbf | 0x100;\n    local_58.c_oflag = uRam0000000000249f44 & 0xffffffc7 | 5;\n    local_58.c_cc._3_2_ = (undefined2)uRam0000000000249f54;\n    local_58.c_cc._5_2_ = 0x100;\n    local_58.c_lflag = uRam0000000000249f4c & 0xffffff95 | 0x8001;\n    iVar1 = tcsetattr(0,1,&local_58);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00191f40": "\nundefined8 FUN_00191f40(char **param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  size_t sVar7;\n  char *__s;\n  \n  __s = *param_1;\n  lVar3 = mbschr(__s,0x24);\n  if (((lVar3 != 0) || (lVar3 = mbschr(__s,0x60), lVar3 != 0)) &&\n     (iVar2 = FUN_00191e10(__s,0), iVar2 == 0)) {\n    sVar7 = strlen(__s);\n    pcVar6 = (char *)sh_xmalloc(sVar7 + 1,\"bashline.c\",0xd43);\n    pcVar6 = strcpy(pcVar6,__s);\n    uVar1 = unbound_vars_is_error;\n    unbound_vars_is_error = 0;\n    lVar3 = expand_prompt_string(pcVar6,0,0x8100400);\n    unbound_vars_is_error = uVar1;\n    if (lVar3 == 0) {\n      sh_xfree(pcVar6,\"bashline.c\",0xd5c);\n    }\n    else {\n      sh_xfree(pcVar6,\"bashline.c\",0xd4c);\n      pcVar6 = (char *)string_list(lVar3);\n      if ((pcVar6 == (char *)0x0) || (*pcVar6 == '\\0')) {\n        sh_xfree(pcVar6,\"bashline.c\",0xd58);\n        pcVar6 = __s;\n      }\n      else {\n        sh_xfree(__s,\"bashline.c\",0xd53);\n        *param_1 = pcVar6;\n      }\n      dispose_words(lVar3);\n      __s = pcVar6;\n    }\n  }\n  if ((no_symbolic_links == 0) && ((*__s != '.' || (__s[1] != '\\0')))) {\n    uVar4 = get_working_directory(\"symlink-hook\");\n    uVar5 = make_absolute(__s,uVar4);\n    sh_xfree(uVar4,\"bashline.c\",0xd68);\n    pcVar6 = (char *)sh_canonpath(uVar5,3);\n    if (pcVar6 == (char *)0x0) {\n      sh_xfree(uVar5,\"bashline.c\",0xd6e);\n    }\n    else {\n      sh_xfree(__s,\"bashline.c\",0xd72);\n      *param_1 = pcVar6;\n      sh_xfree(uVar5,\"bashline.c\",0xd74);\n    }\n  }\n  return 0;\n}\n\n",
  "rl_delete": "\nulong rl_delete(int param_1,undefined4 param_2)\n\n{\n  size_t sVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = rl_point;\n  if (param_1 < 0) {\n    uVar3 = _rl_rubout_char(-param_1);\n    return uVar3;\n  }\n  if (rl_point == rl_end) {\n    rl_ding();\n    uVar3 = 1;\n  }\n  else {\n    if ((param_1 < 2) && (uVar3 = (ulong)rl_explicit_arg, rl_explicit_arg == 0)) {\n      sVar1 = __ctype_get_mb_cur_max();\n      if ((sVar1 < 2) || (rl_byte_oriented != 0)) {\n        iVar2 = rl_point + 1;\n      }\n      else {\n        iVar2 = _rl_find_next_mbchar(rl_line_buffer,rl_point,1,1);\n      }\n      rl_delete_text(rl_point,iVar2);\n      return uVar3;\n    }\n    sVar1 = __ctype_get_mb_cur_max();\n    if ((sVar1 < 2) || (rl_byte_oriented != 0)) {\n      rl_forward_byte();\n    }\n    else {\n      rl_forward_char(param_1,param_2);\n    }\n    uVar3 = 0;\n    rl_kill_text(iVar2,rl_point);\n    rl_point = iVar2;\n  }\n  return uVar3;\n}\n\n",
  "FUN_001ec080": "\nvoid FUN_001ec080(void)\n\n{\n  rl_initialize();\n  if (DAT_0024b508 == 0) {\n    DAT_0024b508 = 1;\n    if (rl_prep_term_function != (undefined *)0x0) {\n      (*(code *)rl_prep_term_function)(_rl_meta_flag);\n    }\n    if (rl_persistent_signal_handlers != 0) {\n      rl_set_signals();\n    }\n  }\n  readline_internal_setup();\n  if (_rl_caught_signal == 0) {\n    return;\n  }\n  _rl_signal_handler(_rl_caught_signal);\n  return;\n}\n\n",
  "FUN_00151a90": "\nundefined8 * FUN_00151a90(long *param_1)\n\n{\n  undefined2 *puVar1;\n  int iVar2;\n  undefined8 *puVar3;\n  char **ppcVar4;\n  size_t sVar5;\n  undefined8 *puVar6;\n  void *pvVar7;\n  char *pcVar8;\n  char *pcVar9;\n  undefined2 *puVar10;\n  size_t sVar11;\n  uint uVar12;\n  int local_54;\n  \n  iVar2 = strvec_len();\n  puVar3 = (undefined8 *)strvec_create(iVar2 + 1);\n  ppcVar4 = (char **)*param_1;\n  puVar6 = puVar3;\n  if (ppcVar4 != (char **)0x0) {\n    local_54 = 0;\n    param_1 = param_1 + 1;\n    do {\n      while ((uVar12 = *(uint *)(ppcVar4 + 5), (uVar12 & 0x40000) != 0 &&\n             ((code *)ppcVar4[3] != (code *)0x0))) {\n        ppcVar4 = (char **)(*(code *)ppcVar4[3])(ppcVar4);\n        if (ppcVar4[2] != (char *)0x0) {\n          sh_xfree(ppcVar4[2],\"variables.c\",0x132b);\n          ppcVar4[2] = (char *)0x0;\n        }\nLAB_00151b07:\n        if ((*(uint *)(ppcVar4 + 5) & 8) == 0) {\n          if ((*(uint *)(ppcVar4 + 5) & 0x44) == 0) {\n            pcVar8 = ppcVar4[1];\n            goto LAB_00151d00;\n          }\n        }\n        else {\n          pcVar8 = (char *)named_function_string(0,ppcVar4[1],0);\nLAB_00151d00:\n          if (pcVar8 != (char *)0x0) {\n            uVar12 = *(uint *)(ppcVar4 + 5);\n            if (ppcVar4[2] == pcVar8) goto LAB_00151b40;\n            goto LAB_00151b4a;\n          }\n        }\n        ppcVar4 = (char **)*param_1;\n        param_1 = param_1 + 1;\n        if (ppcVar4 == (char **)0x0) goto LAB_00151c54;\n      }\n      pcVar8 = ppcVar4[2];\n      if (pcVar8 == (char *)0x0) goto LAB_00151b07;\nLAB_00151b40:\n      if ((uVar12 & 0x44) == 0) {\n        sVar5 = strlen(pcVar8);\n        pcVar9 = (char *)sh_xmalloc(sVar5 + 1,\"variables.c\",0x1347);\n        puVar6 = (undefined8 *)strcpy(pcVar9,pcVar8);\n      }\n      else {\nLAB_00151b4a:\n        pcVar9 = *ppcVar4;\n        sVar5 = strlen(pcVar9);\n        sVar11 = 0;\n        if (((*pcVar8 != '\\0') && (sVar11 = 1, pcVar8[1] != '\\0')) &&\n           (sVar11 = 2, pcVar8[2] != '\\0')) {\n          sVar11 = strlen(pcVar8);\n        }\n        if ((uVar12 & 8) == 0) {\n          puVar6 = (undefined8 *)sh_xmalloc(sVar11 + 2 + sVar5,\"variables.c\",0x12d2);\n          memcpy(puVar6,pcVar9,sVar5);\n          puVar10 = (undefined2 *)((long)puVar6 + sVar5);\n          *(undefined *)puVar10 = 0x3d;\n          if (*pcVar8 == '\\0') goto LAB_00151bfa;\n          memcpy((undefined *)((long)puVar10 + 1),pcVar8,sVar11 + 1);\n        }\n        else {\n          puVar6 = (undefined8 *)sh_xmalloc(sVar11 + 0xe + sVar5,\"variables.c\",0x12a6);\n          *puVar6 = 0x4e55465f48534142;\n          *(undefined2 *)(puVar6 + 1) = 0x5f43;\n          pvVar7 = memcpy((void *)((long)puVar6 + 10),pcVar9,sVar5);\n          puVar1 = (undefined2 *)((long)pvVar7 + sVar5);\n          *puVar1 = 0x2525;\n          puVar10 = puVar1 + 1;\n          *(undefined *)(puVar1 + 1) = 0x3d;\n          if (*pcVar8 == '\\0') {\nLAB_00151bfa:\n            *(undefined *)((long)puVar10 + 1) = 0;\n          }\n          else {\n            pcVar9 = (char *)dequote_escapes(pcVar8);\n            sVar5 = 1;\n            if (((pcVar9 != (char *)0x0) && (*pcVar9 != '\\0')) &&\n               ((sVar5 = 2, pcVar9[1] != '\\0' && (sVar5 = 3, pcVar9[2] != '\\0')))) {\n              sVar5 = strlen(pcVar9);\n              sVar5 = sVar5 + 1;\n            }\n            memcpy((void *)((long)puVar1 + 3),pcVar9,sVar5);\n            sh_xfree(pcVar9,\"variables.c\",0x12df);\n          }\n        }\n      }\n      puVar3[local_54] = puVar6;\n      if ((ppcVar4[2] != pcVar8) || ((*(byte *)(ppcVar4 + 5) & 0x44) != 0)) {\n        sVar5 = strlen((char *)puVar6);\n        pcVar8 = (char *)sh_xmalloc(sVar5 + 1,\"variables.c\",0x134b);\n        pcVar8 = strcpy(pcVar8,(char *)puVar6);\n        ppcVar4[2] = pcVar8;\n      }\n      ppcVar4 = (char **)*param_1;\n      param_1 = param_1 + 1;\n      local_54 = local_54 + 1;\n    } while (ppcVar4 != (char **)0x0);\nLAB_00151c54:\n    puVar6 = puVar3 + local_54;\n  }\n  *puVar6 = 0;\n  return puVar3;\n}\n\n",
  "execve": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint execve(char *__path,char **__argv,char **__envp)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_execve_00237af0)();\n  return iVar1;\n}\n\n",
  "FUN_0018d590": "\nlong * FUN_0018d590(long *param_1,int param_2)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long *plVar3;\n  long lVar4;\n  \n  if (((param_1 != (long *)0x0) && (*(int *)((long)param_1 + 0xc) != 0)) &&\n     (0 < *(int *)(param_1 + 1))) {\n    lVar4 = 0;\n    plVar3 = (long *)0x0;\n    do {\n      for (puVar1 = *(undefined8 **)(*param_1 + lVar4 * 8); puVar1 != (undefined8 *)0x0;\n          puVar1 = (undefined8 *)*puVar1) {\n        uVar2 = puVar1[2];\n        if (param_2 != 0) {\n          uVar2 = puVar1[1];\n        }\n        uVar2 = make_bare_word(uVar2);\n        plVar3 = (long *)make_word_list(uVar2,plVar3);\n      }\n      lVar4 = lVar4 + 1;\n    } while (*(int *)(param_1 + 1) != (int)lVar4 && (int)lVar4 <= *(int *)(param_1 + 1));\n    if (plVar3 != (long *)0x0) {\n      if (*plVar3 == 0) {\n        return plVar3;\n      }\n      plVar3 = (long *)list_reverse(plVar3);\n      return plVar3;\n    }\n  }\n  return (long *)0x0;\n}\n\n",
  "rl_skip_csi_sequence": "\nuint rl_skip_csi_sequence(void)\n\n{\n  uint uVar1;\n  \n  rl_readline_state = rl_readline_state | 0x40;\n  do {\n    uVar1 = rl_read_key();\n  } while (uVar1 - 0x20 < 0x20);\n  rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n  return uVar1 >> 0x1f;\n}\n\n",
  "sv_mail": "\nvoid sv_mail(long param_1)\n\n{\n  if (*(char *)(param_1 + 4) != 'C') {\n    free_mail_files();\n    remember_mail_dates();\n    return;\n  }\n  reset_mail_timer();\n  return;\n}\n\n",
  "dispose_cond_node": "\nvoid dispose_cond_node(long param_1)\n\n{\n  if (param_1 != 0) {\n    if (*(long *)(param_1 + 0x18) != 0) {\n      dispose_cond_node();\n    }\n    if (*(long *)(param_1 + 0x20) != 0) {\n      dispose_cond_node();\n    }\n    if (*(long *)(param_1 + 0x10) != 0) {\n      dispose_word();\n    }\n    sh_xfree(param_1,\"dispose_cmd.c\",0xde);\n    return;\n  }\n  return;\n}\n\n",
  "restore_original_signals": "\nvoid restore_original_signals(void)\n\n{\n  FUN_00181650(FUN_00181610);\n  return;\n}\n\n",
  "rl_tty_set_default_bindings": "\nvoid rl_tty_set_default_bindings(void)\n\n{\n  rltty_set_default_bindings();\n  return;\n}\n\n",
  "_rl_put_indicator": "\nvoid _rl_put_indicator(size_t *param_1)\n\n{\n  fwrite((void *)param_1[1],*param_1,1,rl_outstream);\n  return;\n}\n\n",
  "FUN_0019e240": "\nundefined8 FUN_0019e240(uint *param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  uint uVar5;\n  undefined8 *puVar6;\n  undefined8 *puVar7;\n  int iVar8;\n  \n  plVar2 = (long *)strlist_create();\n  if (num_shell_builtins < 1) {\n    puVar7 = (undefined8 *)*plVar2;\n    iVar8 = 0;\n  }\n  else {\n    uVar5 = num_shell_builtins - 1;\n    lVar1 = *plVar2;\n    iVar8 = 0;\n    puVar7 = (undefined8 *)(shell_builtins + 0x30);\n    puVar3 = (undefined8 *)shell_builtins;\n    puVar6 = puVar7;\n    while( true ) {\n      if ((puVar3[1] != 0) && ((*(byte *)(puVar3 + 2) & 1) == 0)) {\n        lVar4 = (long)iVar8;\n        iVar8 = iVar8 + 1;\n        *(undefined8 *)(lVar1 + lVar4 * 8) = *puVar3;\n      }\n      if (puVar6 == puVar7 + (ulong)uVar5 * 6) break;\n      puVar3 = puVar6;\n      puVar6 = puVar6 + 6;\n    }\n    puVar7 = (undefined8 *)(lVar1 + (long)iVar8 * 8);\n  }\n  *(int *)((long)plVar2 + 0xc) = iVar8;\n  *puVar7 = 0;\n  *(long **)(param_1 + 4) = plVar2;\n  *param_1 = *param_1 | 0x20;\n  return 0;\n}\n\n",
  "urandom_close": "\nvoid urandom_close(void)\n\n{\n  if (DAT_0023b310 < 0) {\n    DAT_0023b310 = 0xffffffff;\n    return;\n  }\n  close(DAT_0023b310);\n  DAT_0023b310 = 0xffffffff;\n  return;\n}\n\n",
  "FUN_00166b00": "\n/* WARNING: Type propagation algorithm not settling */\n\nundefined8 FUN_00166b00(char *param_1,char *param_2,int param_3,char **param_4,char **param_5)\n\n{\n  int iVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *pcVar5;\n  char cVar6;\n  char *pcVar7;\n  size_t sVar8;\n  long lVar9;\n  \n  cVar6 = *param_2;\n  if (cVar6 == '\\0') {\n    lVar9 = 3;\n  }\n  else if (param_2[1] == '\\0') {\n    if (cVar6 == '*') {\nLAB_00166df2:\n      iVar1 = strmatch(param_2,param_1,\n                       (uint)(match_ignore_case != 0) << 4 | (uint)(extended_glob != 0) << 5);\n      goto LAB_00166c32;\n    }\n    lVar9 = 4;\n  }\n  else {\n    sVar8 = 2;\n    if (param_2[2] != '\\0') {\n      sVar8 = strlen(param_2);\n    }\n    if ((cVar6 == '*') &&\n       (((param_2[1] != '(' || (extended_glob == 0)) && (param_2[sVar8 - 1] == '*'))))\n    goto LAB_00166df2;\n    lVar9 = sVar8 + 3;\n  }\n  pcVar3 = (char *)sh_xmalloc(lVar9,\"subst.c\",0x14fe);\n  cVar6 = *param_2;\n  pcVar4 = param_2;\n  pcVar7 = pcVar3;\n  if (param_3 == 1) {\n    if (cVar6 != '\\0') goto LAB_00166bc0;\nLAB_00166bd7:\n    if (pcVar4[-1] == '*') {\n      if (pcVar4[-2] != '\\\\') goto LAB_00166be8;\n      if (param_2 <= pcVar4 + -3) {\n        iVar1 = 1;\n        pcVar4 = pcVar4 + -3;\n        do {\n          pcVar5 = pcVar4 + -1;\n          if (*pcVar4 != '\\\\') break;\n          iVar1 = 1 - iVar1;\n          pcVar4 = pcVar5;\n        } while (param_2 + -1 != pcVar5);\n        if (iVar1 == 0) goto LAB_00166be8;\n      }\n    }\n    *pcVar7 = '*';\n    pcVar7 = pcVar7 + 1;\n  }\n  else {\n    if ((cVar6 != '*') || ((param_2[1] == '(' && (extended_glob != 0)))) {\n      *pcVar3 = '*';\n      cVar6 = *param_2;\n      goto joined_r0x00166bb1;\n    }\nLAB_00166bc0:\n    do {\n      pcVar4 = pcVar4 + 1;\n      *pcVar7 = cVar6;\n      cVar6 = *pcVar4;\njoined_r0x00166bb1:\n      pcVar7 = pcVar7 + 1;\n    } while (cVar6 != '\\0');\n    if (param_3 != 2) goto LAB_00166bd7;\n  }\nLAB_00166be8:\n  *pcVar7 = '\\0';\n  iVar1 = strmatch(pcVar3,param_1,\n                   (uint)(extended_glob != 0) << 5 | (uint)(match_ignore_case != 0) << 4);\n  if (param_2 != pcVar3) {\n    sh_xfree(pcVar3,\"subst.c\",0x151f);\n  }\nLAB_00166c32:\n  if (iVar1 != 1) {\n    if (param_1 == (char *)0x0) {\n      pcVar7 = (char *)0x0;\n      iVar1 = 0;\n      sVar8 = 0;\n    }\n    else if (*param_1 == '\\0') {\n      iVar1 = 0;\n      sVar8 = 0;\n      pcVar7 = param_1;\n    }\n    else if (param_1[1] == '\\0') {\n      iVar1 = 1;\n      sVar8 = 1;\n      pcVar7 = param_1 + 1;\n    }\n    else if (param_1[2] == '\\0') {\n      iVar1 = 2;\n      sVar8 = 2;\n      pcVar7 = param_1 + 2;\n    }\n    else {\n      sVar8 = strlen(param_1);\n      iVar1 = (int)sVar8;\n      pcVar7 = param_1 + sVar8;\n    }\n    iVar2 = umatchlen(param_2,sVar8);\n    if (iVar2 <= iVar1) {\n      if (param_3 == 1) {\n        iVar1 = match_pattern_char(param_2,param_1,(ulong)(match_ignore_case != 0) << 4);\n        if (iVar1 != 0) {\n          if (iVar2 != -1) {\n            pcVar7 = param_1 + iVar2;\n          }\n          for (; param_1 <= pcVar7; pcVar7 = pcVar7 + -1) {\n            cVar6 = *pcVar7;\n            *pcVar7 = '\\0';\n            iVar1 = strmatch(param_2,param_1,\n                             (uint)(match_ignore_case != 0) << 4 | (uint)(extended_glob != 0) << 5);\n            *pcVar7 = cVar6;\n            if (iVar1 == 0) goto LAB_00166f18;\n            if (iVar2 != -1) {\n              return 0;\n            }\n          }\n        }\n      }\n      else if (param_3 == 2) {\n        if (iVar2 != -1) {\n          param_1 = pcVar7 + -(long)iVar2;\n        }\n        for (; param_1 <= pcVar7; param_1 = param_1 + 1) {\n          iVar1 = strmatch(param_2,param_1,\n                           (uint)(extended_glob != 0) << 5 | (uint)(match_ignore_case != 0) << 4);\n          if (iVar1 == 0) {\nLAB_00166f18:\n            *param_4 = param_1;\n            *param_5 = pcVar7;\n            return 1;\n          }\n          if (iVar2 != -1) {\n            return 0;\n          }\n        }\n      }\n      else {\n        if (param_3 != 0) {\n          return 0;\n        }\n        if (param_1 <= pcVar7) {\n          do {\n            iVar1 = match_pattern_char(param_2,param_1,(ulong)(match_ignore_case != 0) << 4);\n            if (iVar1 != 0) {\n              pcVar4 = pcVar7;\n              if ((iVar2 != -1) && (pcVar4 = param_1 + iVar2, pcVar7 < param_1 + iVar2)) {\n                return 0;\n              }\n              for (; param_1 <= pcVar4; pcVar4 = pcVar4 + -1) {\n                cVar6 = *pcVar4;\n                *pcVar4 = '\\0';\n                iVar1 = strmatch(param_2,param_1,\n                                 (uint)(match_ignore_case != 0) << 4 |\n                                 (uint)(extended_glob != 0) << 5);\n                *pcVar4 = cVar6;\n                if (iVar1 == 0) {\n                  *param_4 = param_1;\n                  *param_5 = pcVar4;\n                  return 1;\n                }\n                if (iVar2 != -1) break;\n              }\n            }\n            param_1 = param_1 + 1;\n          } while (param_1 <= pcVar7);\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
  "open_redir_file": "\nint open_redir_file(long param_1,char **param_2)\n\n{\n  int iVar1;\n  char *__file;\n  \n  if (*(int *)(param_1 + 0x18) != 1) {\n    return -1;\n  }\n  if ((posixly_correct != 0) && (interactive_shell == 0)) {\n    disallow_filename_globbing = disallow_filename_globbing + 1;\n  }\n  __file = (char *)redirection_expand(*(undefined8 *)(param_1 + 0x20));\n  if ((posixly_correct != 0) && (interactive_shell == 0)) {\n    disallow_filename_globbing = disallow_filename_globbing + -1;\n  }\n  if (__file == (char *)0x0) {\n    redirection_error(param_1,0xffffffff,0);\n  }\n  else {\n    iVar1 = open(__file,0);\n    if (-1 < iVar1) {\n      if (param_2 == (char **)0x0) {\n        return iVar1;\n      }\n      *param_2 = __file;\n      return iVar1;\n    }\n    file_error(__file);\n    sh_xfree(__file,\"evalstring.c\",0x2df);\n    if (param_2 != (char **)0x0) {\n      *param_2 = (char *)0x0;\n      return -1;\n    }\n  }\n  return -1;\n}\n\n",
  "shtimer_cleanup": "\nvoid shtimer_cleanup(undefined8 *param_1)\n\n{\n  long lVar1;\n  \n  *param_1 = 0;\n  param_1[1] = 0;\n  if ((*(uint *)((long)param_1 + 0x14) & 1) == 0) {\n    return;\n  }\n  *(undefined4 *)(param_1 + 3) = 0;\n  if ((*(uint *)((long)param_1 + 0x14) & 0x200) == 0) {\n    lVar1 = param_1[5];\n  }\n  else {\n    falarm(0,0);\n    lVar1 = param_1[5];\n  }\n  if ((lVar1 != 0) && ((*(byte *)((long)param_1 + 0x15) & 1) != 0)) {\n    set_signal_handler(0xe);\n    *(uint *)((long)param_1 + 0x14) = *(uint *)((long)param_1 + 0x14) & 0xfffffeff;\n    param_1[5] = 0;\n    return;\n  }\n  return;\n}\n\n",
  "history_search_pos": "\nint history_search_pos(undefined8 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  \n  uVar1 = where_history();\n  history_set_pos(param_3);\n  iVar2 = FUN_001f6220(param_1,param_2,0);\n  if (iVar2 != -1) {\n    iVar2 = where_history();\n  }\n  history_set_pos(uVar1);\n  return iVar2;\n}\n\n",
  "setgrent": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid setgrent(void)\n\n{\n  (*(code *)PTR_setgrent_00237a10)();\n  return;\n}\n\n",
  "FUN_0019e9c0": "\nvoid FUN_0019e9c0(undefined8 param_1)\n\n{\n  FUN_0019e8a0(param_1,0);\n  return;\n}\n\n",
  "FUN_0013a0d0": "\nundefined8 FUN_0013a0d0(char **param_1)\n\n{\n  int iVar1;\n  char *__src;\n  char *__dest;\n  long lVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  int local_34;\n  long local_30;\n  \n  uVar3 = 0xffffffff;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  __src = (char *)FUN_00138cc0(0,0x28,0x29,&local_34,0);\n  if (__src == &DAT_00240b10) goto LAB_0013a20a;\n  iVar1 = FUN_00137960(0);\n  if (iVar1 == 0x29) {\n    lVar2 = (long)(local_34 + 4);\nLAB_0013a1ba:\n    uVar3 = 1;\n    __dest = (char *)sh_xmalloc(lVar2,\"/usr/local/src/chet/src/bash/src/parse.y\",0x119e);\n    strncpy(__dest,__src,(long)(local_34 + -1));\n    __dest[(long)local_34 + -1] = '\\0';\n  }\n  else {\n    lVar2 = (long)(local_34 + 4);\n    if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))\n    goto LAB_0013a1ba;\n    __dest = (char *)sh_xmalloc(lVar2,\"/usr/local/src/chet/src/bash/src/parse.y\",0x119e);\n    *__dest = '(';\n    strncpy(__dest + 1,__src,(long)(local_34 + -1));\n    __dest[local_34] = ')';\n    __dest[(long)local_34 + 1] = (char)iVar1;\n    uVar3 = 0;\n    __dest[(long)local_34 + 2] = '\\0';\n  }\n  *param_1 = __dest;\n  sh_xfree(__src,\"/usr/local/src/chet/src/bash/src/parse.y\",0x11b7);\nLAB_0013a20a:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "bind_int_variable": "\nlong bind_int_variable(undefined8 param_1,undefined8 param_2,uint param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  uVar4 = (int)param_3 >> 7 & 1;\n  if ((param_3 & 0x1000) == 0) {\n    iVar1 = valid_array_reference(param_1,uVar4);\n    uVar4 = param_3 >> 2 & 0x20;\n    if (iVar1 != 0) goto LAB_00155ff7;\n  }\n  else {\n    iVar1 = valid_array_reference(param_1,uVar4 | 2);\n    if (iVar1 != 0) {\n      uVar4 = param_3 >> 2 & 0x20 | 0x40;\nLAB_00155ff7:\n      uVar3 = 0;\n      lVar2 = array_variable_part(param_1,uVar4,0,0);\n      if (lVar2 != 0) {\n        uVar3 = *(uint *)(lVar2 + 0x28);\n        *(uint *)(lVar2 + 0x28) = uVar3 & 0xffffffef;\n        uVar3 = uVar3 & 0x10;\n      }\n      lVar2 = assign_array_element(param_1,param_2,param_3,0);\n      goto LAB_0015602b;\n    }\n  }\n  iVar1 = legal_identifier(param_1);\n  if (iVar1 == 0) {\n    sh_invalidid(param_1);\n    return 0;\n  }\n  lVar2 = find_variable();\n  uVar3 = 0;\n  if (lVar2 != 0) {\n    uVar4 = *(uint *)(lVar2 + 0x28);\n    uVar3 = uVar4 & 0x10;\n    *(uint *)(lVar2 + 0x28) = uVar4 & 0xffffffef;\n    if ((uVar4 & 4) != 0) {\n      lVar2 = bind_array_variable(param_1,0,param_2,0);\n      goto LAB_0015602b;\n    }\n  }\n  lVar2 = bind_variable(param_1,param_2,0);\nLAB_0015602b:\n  if (lVar2 != 0) {\n    uVar4 = *(uint *)(lVar2 + 0x28);\n    if (uVar3 != 0) {\n      uVar4 = *(uint *)(lVar2 + 0x28) | 0x10;\n    }\n    *(uint *)(lVar2 + 0x28) = uVar4 & 0xffffefff;\n    if ((uVar4 & 0x800) != 0) {\n      internal_warning(\"%s: assigning integer to name reference\",param_1);\n      return lVar2;\n    }\n  }\n  return lVar2;\n}\n\n",
  "FUN_00144520": "\nvoid FUN_00144520(void)\n\n{\n  DAT_00241f30 = 0;\n  DAT_00241f34 = 0;\n  DAT_00241f24 = 0;\n  DAT_00241f18 = 0;\n  DAT_00241f20 = 0;\n  return;\n}\n\n",
  "confstr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t confstr(int __name,char *__buf,size_t __len)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_confstr_00237c40)();\n  return sVar1;\n}\n\n",
  "_rl_refresh_line": "\nvoid _rl_refresh_line(void)\n\n{\n  char *pcVar1;\n  \n  rl_clear_visible_line();\n  pcVar1 = strrchr(rl_display_prompt,10);\n  if (pcVar1 != (char *)0x0) {\n    FUN_001e2490(pcVar1 + 1);\n    rl_keep_mark_active();\n    return;\n  }\n  rl_forced_update_display();\n  rl_keep_mark_active();\n  return;\n}\n\n",
  "FUN_0016b780": "\nchar * FUN_0016b780(long param_1,uint *param_2,byte *param_3,char *param_4,char *param_5,\n                   uint param_6)\n\n{\n  byte bVar1;\n  bool bVar2;\n  mbstate_t mVar3;\n  int iVar4;\n  size_t sVar5;\n  ulong uVar6;\n  size_t sVar7;\n  char *pcVar8;\n  byte bVar9;\n  ulong uVar10;\n  uint uVar11;\n  ulong uVar12;\n  uint uVar13;\n  byte *pbVar14;\n  ulong uVar15;\n  uint uVar16;\n  long in_FS_OFFSET;\n  bool bVar17;\n  uint local_a0;\n  int local_98;\n  int local_78;\n  int local_60;\n  uint local_54;\n  mbstate_t local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  uVar11 = *param_2;\n  uVar12 = (ulong)(int)uVar11;\n  pbVar14 = (byte *)(param_1 + uVar12);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50.__count = 0;\n  local_50.__value = (_union_27)0x0;\n  sVar5 = strlen((char *)pbVar14);\n  local_98 = 0;\n  uVar6 = sVar5 + uVar12;\n  if (((*param_3 != 0) && (local_98 = 1, param_3[1] != 0)) && (local_98 = 2, param_3[2] != 0)) {\n    sVar7 = strlen((char *)param_3);\n    local_98 = (int)sVar7;\n  }\n  if (*param_4 == '\\0') {\n    local_60 = 0;\n  }\n  else {\n    local_60 = 1;\n    if ((param_4[1] != '\\0') && (local_60 = 2, param_4[2] != '\\0')) {\n      sVar7 = strlen(param_4);\n      local_60 = (int)sVar7;\n    }\n  }\n  if (*param_5 == '\\0') {\n    local_78 = 0;\n  }\n  else {\n    local_78 = 1;\n    if ((param_5[1] != '\\0') && (local_78 = 2, param_5[2] != '\\0')) {\n      sVar7 = strlen(param_5);\n      local_78 = (int)sVar7;\n    }\n  }\n  bVar9 = *pbVar14;\n  bVar17 = false;\n  local_a0 = param_6 & 8;\n  uVar13 = (uint)uVar6;\n  if (CARRY8(sVar5,uVar12) == false) {\n    uVar15 = (ulong)uVar11;\n    bVar2 = false;\n    do {\n      mVar3 = local_50;\n      uVar16 = (uint)(char)bVar9;\n      uVar10 = (ulong)uVar16;\n      uVar11 = (uint)uVar15;\n      if (uVar16 == 0) goto LAB_0016bc2a;\n      if (bVar17) {\n        bVar17 = uVar16 != 10;\n        if (locale_mb_cur_max < 2) {\nLAB_0016bb91:\n          uVar15 = (ulong)(uVar11 + 1);\n          uVar12 = (ulong)(int)(uVar11 + 1);\n        }\n        else {\n          if ((*(uint *)(is_basic_table + (ulong)(uVar16 >> 5 & 7) * 4) >> (bVar9 & 0x1f) & 1) == 0)\n          {\n            if ((locale_utf8locale == 0) || (sVar5 = 1, (char)bVar9 < '\\0')) {\n              sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - uVar12,&local_50);\n              if (0xfffffffffffffffd < sVar5) {\n                uVar15 = (ulong)(uVar11 + 1);\n                uVar12 = (ulong)(int)(uVar11 + 1);\n                local_50 = mVar3;\n                goto LAB_0016ba60;\n              }\n              if (sVar5 == 0) goto LAB_0016bb91;\n            }\n          }\n          else {\n            sVar5 = 1;\n          }\n          uVar11 = uVar11 + (int)sVar5;\n          uVar15 = (ulong)uVar11;\n          uVar12 = (ulong)(int)uVar11;\n        }\n      }\n      else if (bVar2) {\n        if (locale_mb_cur_max < 2) {\nLAB_0016bba8:\n          uVar15 = (ulong)(uVar11 + 1);\n        }\n        else {\n          if ((*(uint *)(is_basic_table + (ulong)(uVar16 >> 5 & 7) * 4) >> (bVar9 & 0x1f) & 1) == 0)\n          {\n            if ((locale_utf8locale == 0) || (sVar5 = 1, (char)bVar9 < '\\0')) {\n              sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - uVar12,&local_50);\n              if (0xfffffffffffffffd < sVar5) {\n                uVar15 = (ulong)(uVar11 + 1);\n                local_50 = mVar3;\n                goto LAB_0016bb46;\n              }\n              if (sVar5 == 0) goto LAB_0016bba8;\n            }\n          }\n          else {\n            sVar5 = 1;\n          }\n          uVar15 = (ulong)(uVar11 + (int)sVar5);\n        }\nLAB_0016bb46:\n        bVar2 = false;\n        uVar12 = (ulong)(int)uVar15;\n      }\n      else if (local_a0 == 0) {\n        if ((uVar16 != 1) && (uVar16 != 0x5c)) goto LAB_0016b8fe;\nLAB_0016baf0:\n        uVar15 = (ulong)(uVar11 + 1);\n        bVar17 = false;\n        bVar2 = true;\n        uVar12 = (ulong)(int)(uVar11 + 1);\n        local_50 = mVar3;\n      }\n      else {\n        if (uVar16 == 0x23) {\n          if (((uVar11 == 0) || (bVar1 = *(byte *)(param_1 + -1 + uVar12), bVar1 == 10)) ||\n             ((*(byte *)((long)&sh_syntaxtab + (ulong)bVar1 * 4 + 1) & 0x20) != 0)) {\n            if (locale_mb_cur_max < 2) {\nLAB_0016be60:\n              uVar15 = (ulong)(uVar11 + 1);\n            }\n            else if (((uint)is_basic_table._4_4_ >> 3 & 1 | locale_utf8locale) == 0) {\n              sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - uVar12,&local_50);\n              if (sVar5 < 0xfffffffffffffffe) {\n                if (sVar5 == 0) goto LAB_0016be60;\n                uVar15 = (ulong)(uVar11 + (int)sVar5);\n              }\n              else {\n                uVar15 = (ulong)(uVar11 + 1);\n                local_50 = mVar3;\n              }\n            }\n            else {\n              uVar15 = (ulong)(uVar11 + 1);\n              local_50 = mVar3;\n            }\n            bVar17 = true;\n            uVar12 = (ulong)(int)uVar15;\n            goto LAB_0016ba60;\n          }\n        }\n        else if ((uVar16 == 1) || (uVar16 == 0x5c)) goto LAB_0016baf0;\n        if ((bVar9 == 0x24) && (*(char *)(param_1 + 1 + uVar12) == '(')) {\n          local_54 = uVar11 + 2;\n          extract_command_subst(param_1,&local_54,param_6 | 1);\n        }\n        else {\nLAB_0016b8fe:\n          if (local_98 == 0) {\nLAB_0016bbe5:\n            local_54 = uVar11 + local_98;\n            FUN_0016b780(param_1,&local_54,param_3,param_4,param_5,param_6 | 1);\n          }\n          else {\n            if (*param_3 == bVar9) {\n              iVar4 = strncmp((char *)pbVar14,(char *)param_3,(long)local_98);\n              uVar10 = (ulong)bVar9;\n              if (iVar4 == 0) goto LAB_0016bbe5;\n            }\n            if ((local_60 != 0) && (*param_4 == (char)uVar10)) {\n              iVar4 = strncmp((char *)pbVar14,param_4,(long)local_60);\n              uVar10 = uVar10 & 0xff;\n              if (iVar4 == 0) {\n                local_54 = uVar11 + local_60;\n                FUN_0016b780(param_1,&local_54,param_4,param_4,param_5,param_6 | 1);\n                uVar11 = uVar13;\n                if ((ulong)(long)(int)local_54 < uVar6) {\n                  uVar15 = (ulong)(local_54 + 1);\n                  bVar2 = false;\n                  uVar12 = (ulong)(int)(local_54 + 1);\n                  bVar17 = false;\n                  goto LAB_0016ba60;\n                }\n                goto LAB_0016bc2a;\n              }\n            }\n            if (local_78 == 0) {\nLAB_0016bdb5:\n              uVar11 = (uVar11 - 1) + local_78;\n              goto LAB_0016ba87;\n            }\n            if (*param_5 == (char)uVar10) {\n              iVar4 = strncmp((char *)pbVar14,param_5,(long)local_78);\n              uVar10 = uVar10 & 0xff;\n              if (iVar4 == 0) goto LAB_0016bdb5;\n            }\n            mVar3 = local_50;\n            if (uVar16 != 0x60) {\n              if ((uVar16 != 0x27) && (uVar16 != 0x22)) {\n                if (locale_mb_cur_max < 2) {\nLAB_0016bdf8:\n                  uVar15 = (ulong)(uVar11 + 1);\n                }\n                else if ((*(uint *)(is_basic_table + (ulong)((uint)(uVar10 >> 5) & 7) * 4) >>\n                          ((byte)uVar10 & 0x1f) & 1) == 0) {\n                  if ((locale_utf8locale == 0) || (sVar5 = 1, (char)(byte)uVar10 < '\\0')) {\n                    sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - uVar12,&local_50);\n                    if (0xfffffffffffffffd < sVar5) {\n                      uVar15 = (ulong)(uVar11 + 1);\n                      local_50 = mVar3;\n                      goto LAB_0016bdfb;\n                    }\n                    if (sVar5 == 0) goto LAB_0016bdf8;\n                  }\n                  uVar15 = (ulong)(uVar11 + (int)sVar5);\n                }\n                else {\n                  uVar15 = (ulong)(uVar11 + 1);\n                  local_50 = mVar3;\n                }\nLAB_0016bdfb:\n                bVar17 = false;\n                uVar12 = (ulong)(int)uVar15;\n                goto LAB_0016ba60;\n              }\n              local_54 = uVar11 + 1;\n              uVar15 = (ulong)local_54;\n              if (uVar16 == 0x27) {\n                uVar12 = (ulong)(int)local_54;\n                local_48.__count = 0;\n                local_48.__value = (_union_27)0x0;\n                pbVar14 = (byte *)(param_1 + uVar12);\n                bVar9 = *pbVar14;\n                if (bVar9 != 0x27) {\n                  if (bVar9 == 0) goto LAB_0016be42;\n                  do {\n                    mVar3 = local_48;\n                    iVar4 = (int)uVar15;\n                    if (locale_mb_cur_max < 2) {\nLAB_0016bf70:\n                      uVar15 = (ulong)(iVar4 + 1);\n                    }\n                    else {\n                      if ((*(uint *)(is_basic_table + (ulong)(bVar9 >> 5) * 4) >> (bVar9 & 0x1f) & 1\n                          ) == 0) {\n                        if ((locale_utf8locale == 0) || (sVar5 = 1, (char)bVar9 < '\\0')) {\n                          sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,uVar6 - uVar12,&local_48);\n                          if (0xfffffffffffffffd < sVar5) {\n                            uVar15 = (ulong)(iVar4 + 1);\n                            local_48 = mVar3;\n                            goto LAB_0016bf06;\n                          }\n                          if (sVar5 == 0) goto LAB_0016bf70;\n                        }\n                      }\n                      else {\n                        sVar5 = 1;\n                      }\n                      uVar15 = (ulong)(uint)(iVar4 + (int)sVar5);\n                    }\nLAB_0016bf06:\n                    uVar12 = (ulong)(int)uVar15;\n                    pbVar14 = (byte *)(param_1 + uVar12);\n                    bVar9 = *pbVar14;\n                    if (bVar9 == 0) goto LAB_0016be42;\n                  } while (bVar9 != 0x27);\n                }\n                if (bVar9 != 0) {\n                  uVar11 = (int)uVar15 + 1;\n                  uVar15 = (ulong)uVar11;\n                  uVar12 = (ulong)(int)uVar11;\n                }\n              }\n              else {\n                iVar4 = FUN_0016a7c0(param_1,uVar6,uVar15,0);\n                uVar15 = (ulong)iVar4;\n                uVar12 = uVar15;\n              }\nLAB_0016be42:\n              bVar17 = false;\n              goto LAB_0016ba60;\n            }\n            local_54 = uVar11 + 1;\n            FUN_0016b540(param_1,&local_54,&DAT_00213e43,param_6 | 1);\n          }\n        }\n        uVar11 = uVar13;\n        if (uVar6 <= (ulong)(long)(int)local_54) goto LAB_0016bc2a;\n        uVar15 = (ulong)(local_54 + 1);\n        bVar17 = false;\n        uVar12 = (ulong)(int)(local_54 + 1);\n      }\nLAB_0016ba60:\n      pbVar14 = (byte *)(param_1 + uVar12);\n      bVar9 = *pbVar14;\n    } while (uVar12 <= uVar6);\n  }\n  uVar11 = uVar13;\n  if (*(char *)(param_1 + (int)uVar13) == '\\0') {\nLAB_0016bc2a:\n    if (no_longjmp_on_fatal_error == 0) {\n      last_command_exit_value = 1;\n      report_error(\"bad substitution: no closing `%s\\' in %s\",param_5,param_1);\n                    /* WARNING: Subroutine does not return */\n      FUN_001667f0(2);\n    }\n    pcVar8 = (char *)0x0;\n  }\n  else {\nLAB_0016ba87:\n    pcVar8 = (char *)0x0;\n    local_78 = (uVar11 - *param_2) - local_78;\n    local_54 = local_78 + 1;\n    if ((param_6 & 1) == 0) {\n      pcVar8 = (char *)sh_xmalloc((long)(local_78 + 2),\"subst.c\",0x5e9);\n      pcVar8 = strncpy(pcVar8,(char *)((int)*param_2 + param_1),(long)(int)local_54);\n      pcVar8[(int)local_54] = '\\0';\n    }\n  }\n  *param_2 = uVar11;\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pcVar8;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001bd510": "\nulong FUN_001bd510(char *param_1,char *param_2)\n\n{\n  char *pcVar1;\n  char cVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  uint uVar6;\n  size_t sVar7;\n  char *pcVar8;\n  char *pcVar9;\n  ulong uVar10;\n  char *pcVar11;\n  ulong unaff_R14;\n  \n  iVar5 = extglob_pattern_p();\n  if (iVar5 == 0) {\n    if (glob_always_skip_dot_and_dotdot == 0) {\n      if (noglob_dot_filenames != 0) {\n        if (*param_2 == '.') {\nLAB_001bd599:\n          if ((*param_1 != '.') && ((*param_1 != '\\\\' || (param_1[1] != '.')))) goto LAB_001bd5b0;\n        }\n        goto LAB_001bd570;\n      }\n    }\n    else if (*param_2 == '.') {\n      if ((param_2[1] == '\\0') || ((param_2[1] == '.' && (param_2[2] == '\\0')))) goto LAB_001bd5b0;\n      if (noglob_dot_filenames != 0) goto LAB_001bd599;\n    }\n    else if (noglob_dot_filenames != 0) goto LAB_001bd570;\n    if (((*param_1 != '.') && (((*param_1 != '\\\\' || (param_1[1] != '.')) && (*param_2 == '.')))) &&\n       ((param_2[1] == '\\0' || ((param_2[1] == '.' && (param_2[2] == '\\0')))))) {\nLAB_001bd5b0:\n      unaff_R14 = 1;\n      goto LAB_001bd573;\n    }\n  }\n  else {\n    cVar2 = *param_1;\n    param_1 = param_1 + 2;\n    sVar7 = strlen(param_1);\n    pcVar1 = param_1 + sVar7;\n    pcVar8 = (char *)glob_patscan(param_1,pcVar1,0);\n    if (pcVar8 != (char *)0x0) {\n      if ((((pcVar1 == pcVar8) && (*pcVar1 == '\\0')) && (pcVar1[-1] == ')')) &&\n         (pcVar11 = strchr(param_1,0x7c), pcVar11 == (char *)0x0)) {\n        pcVar1[-1] = '\\0';\n        uVar6 = FUN_001bd790(param_1,param_2);\n        pcVar1[-1] = ')';\n        unaff_R14 = (ulong)uVar6;\n        goto LAB_001bd573;\n      }\n      do {\n        pcVar9 = (char *)glob_patscan(param_1,pcVar8,0x7c);\n        pcVar11 = param_1;\n        if (pcVar9 == (char *)0x0) break;\n        cVar3 = pcVar9[-1];\n        iVar5 = extglob_pattern_p(param_1);\n        if ((iVar5 == 0) || (cVar4 = ')', cVar3 != ')')) {\n          cVar4 = '\\0';\n        }\n        pcVar9[-1] = cVar4;\n        uVar6 = FUN_001bd790(param_1,param_2);\n        pcVar9[-1] = cVar3;\n        unaff_R14 = (ulong)uVar6;\n        if (uVar6 == 0) goto LAB_001bd570;\n        param_1 = pcVar9;\n        pcVar11 = pcVar8;\n      } while (pcVar8 != pcVar9);\n      if (pcVar1 == pcVar11) goto LAB_001bd573;\n      if (((cVar2 == '*') || (cVar2 == '?')) && (*pcVar8 != '\\0')) {\n        uVar10 = FUN_001bd790(pcVar8,param_2);\n        return uVar10;\n      }\n      goto LAB_001bd5b0;\n    }\n  }\nLAB_001bd570:\n  unaff_R14 = 0;\nLAB_001bd573:\n  return unaff_R14 & 0xffffffff;\n}\n\n",
  "do_assignment": "\nvoid do_assignment(undefined8 param_1)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_28;\n  undefined4 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = 4;\n  local_28 = param_1;\n  FUN_00173b20(&local_28,1);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001515d0": "\nlong FUN_001515d0(long param_1)\n\n{\n  undefined8 *puVar1;\n  long *plVar2;\n  long *plVar3;\n  size_t sVar4;\n  char *__dest;\n  char *pcVar5;\n  long lVar6;\n  \n  if (*(long *)(param_1 + 8) != 0) {\n    assoc_dispose();\n  }\n  plVar2 = aliases;\n  if (aliases != (long *)0x0) {\n    if (*(int *)((long)aliases + 0xc) == 0) {\n      plVar2 = (long *)0x0;\n    }\n    else {\n      plVar2 = (long *)hash_create(*(undefined4 *)(aliases + 1));\n      if (0 < *(int *)(aliases + 1)) {\n        lVar6 = 0;\n        plVar3 = aliases;\n        do {\n          puVar1 = *(undefined8 **)(*plVar3 + lVar6 * 8);\n          for (; puVar1 != (undefined8 *)0x0; puVar1 = (undefined8 *)*puVar1) {\n            pcVar5 = (char *)puVar1[1];\n            sVar4 = strlen(pcVar5);\n            __dest = (char *)sh_xmalloc(sVar4 + 1,\"variables.c\",0x71b);\n            pcVar5 = strcpy(__dest,pcVar5);\n            assoc_insert(plVar2,pcVar5,*(undefined8 *)(puVar1[2] + 8));\n            plVar3 = aliases;\n          }\n          lVar6 = lVar6 + 1;\n        } while (*(int *)(plVar3 + 1) != (int)lVar6 && (int)lVar6 <= *(int *)(plVar3 + 1));\n      }\n    }\n  }\n  *(long **)(param_1 + 8) = plVar2;\n  return param_1;\n}\n\n",
  "FUN_00144560": "\nvoid FUN_00144560(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_d0 = &stack0x00000008;\n  local_d8 = 8;\n  local_c8 = local_b8;\n  local_d4 = 0x30;\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  __vfprintf_chk(stdout,1,param_9,&local_d8);\n  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "setlocale": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_setlocale_00237cc0)();\n  return pcVar1;\n}\n\n",
  "unlink_fifo": "\nvoid unlink_fifo(int param_1)\n\n{\n  if (*(int *)(DAT_00247838 + (long)param_1 * 4) == 0) {\n    return;\n  }\n  close(param_1);\n  DAT_00247834 = DAT_00247834 + -1;\n  *(undefined4 *)(DAT_00247838 + (long)param_1 * 4) = 0;\n  return;\n}\n\n",
  "FUN_001b8510": "\nvoid FUN_001b8510(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_e8;\n  undefined4 local_e4;\n  undefined *local_e0;\n  undefined *local_d8;\n  long local_d0;\n  undefined local_c8 [8];\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  \n  if (in_AL != '\\0') {\n    local_98 = param_1;\n    local_88 = param_2;\n    local_78 = param_3;\n    local_68 = param_4;\n    local_58 = param_5;\n    local_48 = param_6;\n    local_38 = param_7;\n    local_28 = param_8;\n  }\n  local_d0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e0 = &stack0x00000008;\n  local_d8 = local_c8;\n  local_e8 = 8;\n  local_e4 = 0x30;\n  local_c0 = param_10;\n  local_b8 = param_11;\n  local_b0 = param_12;\n  local_a8 = param_13;\n  local_a0 = param_14;\n  iVar1 = __vsnprintf_chk(DAT_00248d88 + DAT_00248da0,DAT_00248d90 - (long)DAT_00248d88,1,\n                          0xffffffffffffffff,param_9,&local_e8);\n  iVar1 = DAT_00248d88 + iVar1;\n  if (DAT_00248d90 <= (ulong)(long)(iVar1 + 1)) {\n    DAT_00248d90 = (long)(iVar1 + 1) + 0x3fU & 0xffffffffffffffc0;\n    DAT_00248da0 = sh_xrealloc(DAT_00248da0,DAT_00248d90,\"./printf.def\",0x45b);\n    local_e0 = &stack0x00000008;\n    local_d8 = local_c8;\n    local_e8 = 8;\n    local_e4 = 0x30;\n    iVar1 = __vsnprintf_chk(DAT_00248da0 + DAT_00248d88,DAT_00248d90 - (long)DAT_00248d88,1,\n                            0xffffffffffffffff,param_9,&local_e8);\n    iVar1 = DAT_00248d88 + iVar1;\n  }\n  DAT_00248d88 = iVar1;\n  *(undefined *)(DAT_00248da0 + iVar1) = 0;\n  if (local_d0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "procsub_delete": "\nundefined8 * procsub_delete(int param_1)\n\n{\n  uint uVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  uint uVar5;\n  undefined8 *puVar6;\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_128);\n  sigaddset(&sStack_128,0x11);\n  sigemptyset(&local_a8);\n  sigprocmask(0,&sStack_128,&local_a8);\n  puVar3 = procsubs;\n  puVar4 = procsubs;\n  puVar6 = procsubs;\n  do {\n    puVar2 = puVar6;\n    puVar6 = puVar4;\n    if (puVar6 == (undefined8 *)0x0) {\n      puVar6 = (undefined8 *)0x0;\n      sigprocmask(2,&local_a8,(sigset_t *)0x0);\n      goto LAB_00160e07;\n    }\n    puVar4 = (undefined8 *)*puVar6;\n  } while (*(int *)(puVar6 + 1) != param_1);\n  *puVar2 = (undefined8 *)*puVar6;\n  if (puVar6 == puVar3) {\n    procsubs = (undefined8 *)*puVar6;\n  }\n  else if (puVar6 == DAT_00242518) {\n    DAT_00242518 = puVar2;\n  }\n  DAT_00242520 = DAT_00242520 + -1;\n  if (DAT_00242520 == 0) {\n    DAT_00242518 = (undefined8 *)0x0;\n    procsubs = (undefined8 *)0x0;\n  }\n  else if (DAT_00242520 == 1) {\n    DAT_00242518 = procsubs;\n  }\n  uVar1 = *(uint *)((long)puVar6 + 0xc);\n  if ((char)(((byte)uVar1 & 0x7f) + 1) < '\\x02') {\n    uVar5 = uVar1 >> 8 & 0xff;\n    if ((byte)uVar1 == 0x7f) {\n      uVar5 = 0;\n    }\n  }\n  else {\n    uVar5 = (uVar1 & 0x7f) + 0x80;\n  }\n  FUN_0015ed20(param_1,uVar5);\n  sigprocmask(2,&local_a8,(sigset_t *)0x0);\nLAB_00160e07:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar6;\n}\n\n",
  "array_insert": "\nundefined8 array_insert(long *param_1,long param_2,undefined8 param_3)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long *plVar3;\n  long lVar4;\n  long lVar5;\n  long lVar6;\n  int iVar7;\n  \n  if (param_1 == (long *)0x0) {\n    return 0xffffffff;\n  }\n  lVar5 = array_create_element(param_2,param_3);\n  if (*param_1 < param_2) {\n    lVar6 = param_1[2];\n    lVar4 = *(long *)(lVar6 + 0x18);\n    *(long *)(lVar4 + 0x10) = lVar5;\n    *(long *)(lVar5 + 0x18) = lVar4;\n    *(long *)(lVar6 + 0x18) = lVar5;\n    *(long *)(lVar5 + 0x10) = lVar6;\n    param_1[1] = param_1[1] + 1;\n    *param_1 = param_2;\n    param_1[3] = lVar5;\n    return 0;\n  }\n  plVar1 = (long *)param_1[2];\n  plVar2 = (long *)plVar1[2];\n  if (param_2 < *plVar2) {\n    plVar2[3] = lVar5;\n    *(long **)(lVar5 + 0x10) = plVar2;\n    *(long **)(lVar5 + 0x18) = plVar1;\n    plVar1[2] = lVar5;\n    param_1[1] = param_1[1] + 1;\n    param_1[3] = lVar5;\n    return 0;\n  }\n  plVar3 = (long *)param_1[3];\n  if (plVar3 == (long *)0x0) {\n    iVar7 = 1;\n    lVar6 = *plVar2 / 2;\n  }\n  else {\n    lVar6 = *plVar3;\n    iVar7 = 1;\n    if (param_2 < lVar6 / 2) goto joined_r0x00188f7b;\n    iVar7 = -1;\n    plVar2 = plVar3;\n  }\n  if (lVar6 <= param_2) {\n    iVar7 = 1;\n  }\njoined_r0x00188f7b:\n  while( true ) {\n    if (plVar1 == plVar2) {\n      if (lVar5 != 0) {\n        if (*(long *)(lVar5 + 8) != 0) {\n          sh_xfree(*(long *)(lVar5 + 8),\"array.c\",0x21e);\n        }\n        sh_xfree(lVar5,\"array.c\",0x21f);\n      }\n      param_1[3] = 0;\n      return 0xffffffff;\n    }\n    lVar6 = *plVar2;\n    if (lVar6 == param_2) break;\n    if (iVar7 == 1) {\n      if (param_2 < lVar6) {\n        lVar6 = plVar2[3];\n        *(long *)(lVar6 + 0x10) = lVar5;\n        *(long *)(lVar5 + 0x18) = lVar6;\n        plVar2[3] = lVar5;\n        *(long **)(lVar5 + 0x10) = plVar2;\n        param_1[1] = param_1[1] + 1;\n        param_1[3] = lVar5;\n        return 0;\n      }\n      plVar2 = (long *)plVar2[2];\n    }\n    else {\n      if ((iVar7 == -1) && (lVar6 < param_2)) {\n        lVar6 = plVar2[2];\n        *(long *)(lVar6 + 0x18) = lVar5;\n        *(long *)(lVar5 + 0x10) = lVar6;\n        *(long **)(lVar5 + 0x18) = plVar2;\n        plVar2[2] = lVar5;\n        param_1[1] = param_1[1] + 1;\n        param_1[3] = lVar5;\n        return 0;\n      }\n      plVar2 = (long *)plVar2[3];\n    }\n  }\n  sh_xfree(plVar2[1],\"array.c\",0x262);\n  plVar2[1] = *(long *)(lVar5 + 8);\n  *(undefined8 *)(lVar5 + 8) = 0;\n  sh_xfree(lVar5,\"array.c\",0x21f);\n  param_1[3] = (long)plVar2;\n  return 0;\n}\n\n",
  "FUN_0015cad0": "\nulong FUN_0015cad0(void)\n\n{\n  ulong uVar1;\n  long lVar2;\n  \n  uVar1 = FUN_0015c720();\n  while (DAT_00242448 == 7) {\n    if (uVar1 == 0) {\n      DAT_00242428 = DAT_00242428 + 1;\n      FUN_0015d330();\n      lVar2 = FUN_0015c720();\n      DAT_00242428 = DAT_00242428 + -1;\n    }\n    else {\n      FUN_0015d330();\n      lVar2 = FUN_0015c720();\n    }\n    DAT_00242444 = 7;\n    uVar1 = (ulong)(lVar2 != 0 && uVar1 != 0);\n  }\n  return uVar1;\n}\n\n",
  "_rl_free_saved_history_line": "\nundefined8 _rl_free_saved_history_line(void)\n\n{\n  void *__ptr;\n  void **ppvVar1;\n  \n  if (_rl_saved_line_for_history == (void **)0x0) {\n    return 0;\n  }\n  if ((rl_undo_list == (void *)0x0) || (rl_undo_list != _rl_saved_line_for_history[2])) {\n    if (_rl_saved_line_for_history[2] == (void *)0x0) {\n      __ptr = *_rl_saved_line_for_history;\n      ppvVar1 = _rl_saved_line_for_history;\n      goto joined_r0x001f0ec2;\n    }\n  }\n  else {\n    rl_undo_list = (void *)0x0;\n  }\n  _rl_free_undo_list();\n  if (_rl_saved_line_for_history == (void **)0x0) {\n    _rl_saved_line_for_history = (void **)0x0;\n    return 0;\n  }\n  __ptr = *_rl_saved_line_for_history;\n  ppvVar1 = _rl_saved_line_for_history;\njoined_r0x001f0ec2:\n  _rl_saved_line_for_history = ppvVar1;\n  if (__ptr != (void *)0x0) {\n    free(__ptr);\n  }\n  if (ppvVar1[1] != (void *)0x0) {\n    free(ppvVar1[1]);\n  }\n  xfree(ppvVar1);\n  _rl_saved_line_for_history = (void **)0x0;\n  return 0;\n}\n\n",
  "FUN_0019e9d0": "\nvoid FUN_0019e9d0(undefined8 param_1)\n\n{\n  FUN_0019e8a0(param_1,1);\n  return;\n}\n\n",
  "FUN_001cf960": "\nvoid FUN_001cf960(void)\n\n{\n  int iVar1;\n  \n  iVar1 = rl_end;\n  rl_unix_line_discard();\n  DAT_0024a410 = DAT_0024a410 - (iVar1 - rl_end);\n  return;\n}\n\n",
  "sh_free": "\nvoid sh_free(void)\n\n{\n  FUN_001f8ee0();\n  return;\n}\n\n",
  "restore_input_line_state": "\nvoid restore_input_line_state(undefined8 *param_1)\n\n{\n  if (DAT_00240da8 != 0) {\n    sh_xfree(DAT_00240da8,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1a30);\n  }\n  DAT_00240da8 = *param_1;\n  DAT_00240d98 = param_1[2];\n  DAT_00240d90 = param_1[3];\n  DAT_00240da0 = param_1[1];\n  if (DAT_00240e48 != 0) {\n    sh_xfree(DAT_00240e48,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1a37);\n  }\n  DAT_00240e48 = param_1[4];\n  DAT_00240e40 = param_1[5];\n  return;\n}\n\n",
  "wcdequote_pathname": "\nvoid wcdequote_pathname(long param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  \n  lVar1 = 0;\n  iVar3 = 0;\n  do {\n    iVar4 = (int)lVar1;\n    if (param_1 == 0) {\n      return;\n    }\n    iVar2 = *(int *)(param_1 + (long)iVar3 * 4);\n    if (iVar2 == 0) break;\n    if (iVar2 == 0x5c) {\n      iVar2 = *(int *)(param_1 + 4 + (long)iVar3 * 4);\n      iVar3 = iVar3 + 1;\n    }\n    iVar3 = iVar3 + 1;\n    *(int *)(param_1 + lVar1 * 4) = iVar2;\n    iVar4 = iVar4 + 1;\n    lVar1 = lVar1 + 1;\n  } while (*(int *)(param_1 + -4 + (long)iVar3 * 4) != 0);\n  *(undefined4 *)(param_1 + (long)iVar4 * 4) = 0;\n  return;\n}\n\n",
  "wait_for": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nuint wait_for(int param_1,uint param_2)\n\n{\n  int iVar1;\n  long *plVar2;\n  char cVar3;\n  byte bVar4;\n  undefined4 uVar5;\n  int iVar6;\n  uint uVar7;\n  __pid_t __pid;\n  code *pcVar8;\n  long lVar9;\n  long lVar10;\n  int *piVar11;\n  uint uVar12;\n  long lVar13;\n  long lVar14;\n  long *plVar15;\n  int iVar16;\n  long in_FS_OFFSET;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_148);\n  sigaddset(&local_148,0x11);\n  sigemptyset(&local_c8);\n  sigprocmask(0,&local_148,&local_c8);\n  DAT_002475c0 = 0;\n  DAT_002475c4 = 0;\n  if ((job_control == 0) || (uVar12 = last_command_exit_value, (subshell_environment & 4) != 0)) {\n    pcVar8 = (code *)set_signal_handler(2,FUN_0015f840);\n    if (pcVar8 == FUN_0015f840) {\n      internal_debug(\"wait_for: recursively setting old_sigint_handler to wait_sigint_handler: running_trap = %d\"\n                     ,running_trap);\n      pcVar8 = (code *)PTR_wait_for_background_pids_002387a8;\n    }\n    PTR_wait_for_background_pids_002387a8 = pcVar8;\n    waiting_for_child = 0;\n    if ((code *)PTR_wait_for_background_pids_002387a8 == (code *)0x1) {\n      waiting_for_child = 0;\n      set_signal_handler(2,1);\n    }\n    uVar12 = last_command_exit_value;\n    if ((interactive != 0) && (job_control == 0)) {\n      if (terminating_signal != 0) {\n        termsig_handler(terminating_signal);\n      }\n      if (interrupt_state != 0) {\n        throw_to_top_level();\n      }\n    }\n  }\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if ((((wait_intr_flag != 0) && (wait_signal_received != 0)) &&\n      (this_shell_builtin == (code *)PTR_wait_builtin_00237f70)) &&\n     (this_shell_builtin != (code *)0x0)) {\nLAB_0016372d:\n                    /* WARNING: Subroutine does not return */\n    __longjmp_chk(wait_intr_buf,1);\n  }\n  lVar9 = 0;\n  iVar16 = -1;\n  do {\n    do {\n      if (param_1 == -1) goto LAB_001632c0;\n      lVar9 = FUN_00160ba0(param_1,0,0);\n      if (lVar9 == 0) {\n        uVar12 = 0x7f;\n        give_terminal_to(shell_pgrp,0);\n        sigprocmask(2,&local_c8,(sigset_t *)0x0);\n        internal_error(\"wait_for: No record of process %ld\",(long)param_1);\n        if ((code *)PTR_wait_for_background_pids_002387a8 != wait_for_background_pids) {\n          set_signal_handler(2);\n          PTR_wait_for_background_pids_002387a8 = wait_for_background_pids;\n          waiting_for_child = 0;\n        }\n        goto LAB_00163545;\n      }\n      iVar6 = iVar16;\n      if (iVar16 != -1) {\nLAB_001635ad:\n        iVar16 = iVar6;\n        if ((*(int *)(lVar9 + 0x10) != 1) &&\n           (*(int *)(*(long *)(jobs + (long)iVar16 * 8) + 0x14) != 1)) goto LAB_00163334;\nLAB_001632c0:\n        uVar5 = waiting_for_child;\n        DAT_00247690 = 1;\n        waiting_for_child = 1;\n        if (((wait_intr_flag != 0) && (wait_signal_received != 0)) &&\n           ((this_shell_builtin != (code *)0x0 &&\n            (this_shell_builtin == (code *)PTR_wait_builtin_00237f70)))) goto LAB_0016372d;\n        iVar6 = FUN_00161c20(1);\n        DAT_00247690 = 0;\n        waiting_for_child = uVar5;\n        if ((iVar6 != -1) || (piVar11 = __errno_location(), *piVar11 != 10)) goto LAB_00163334;\n        if (this_shell_builtin != wait_builtin) {\n          if (lVar9 != 0) {\n            *(undefined8 *)(lVar9 + 0xc) = 0;\n          }\n          _DAT_00238768 = 0;\n          if (iVar16 != -1) {\n            _DAT_0023876c = _DAT_0023876c + 1;\n            *(undefined4 *)(*(long *)(jobs + (long)iVar16 * 8) + 0x14) = 4;\n            _DAT_0023878c = _DAT_0023878c + 1;\n          }\n          if (param_1 != -1) goto LAB_00163334;\n          if ((code *)PTR_wait_for_background_pids_002387a8 == wait_for_background_pids)\n          goto LAB_00163420;\n          goto LAB_00163402;\n        }\n        uVar12 = 0xffffffff;\n        if ((code *)PTR_wait_for_background_pids_002387a8 != wait_for_background_pids) {\nLAB_00163757:\n          set_signal_handler(2);\n          PTR_wait_for_background_pids_002387a8 = wait_for_background_pids;\n          waiting_for_child = 0;\n        }\n        goto LAB_00163536;\n      }\n      lVar13 = 0;\n      if (0 < DAT_0023877c) {\n        do {\n          lVar14 = *(long *)(jobs + lVar13 * 8);\n          if (lVar14 != 0) {\n            plVar15 = *(long **)(lVar14 + 8);\n            iVar1 = *(int *)(plVar15 + 1);\n            plVar2 = plVar15;\n            while( true ) {\n              iVar6 = (int)lVar13;\n              if (param_1 == iVar1) goto LAB_001635ad;\n              plVar2 = (long *)*plVar2;\n              if (plVar15 == plVar2) break;\n              iVar1 = *(int *)(plVar2 + 1);\n            }\n          }\n          lVar13 = lVar13 + 1;\n        } while (lVar13 != DAT_0023877c);\n      }\n      if (*(int *)(lVar9 + 0x10) == 1) goto LAB_001632c0;\nLAB_00163334:\n      if ((interactive != 0) && (job_control == 0)) {\n        if (terminating_signal != 0) {\n          termsig_handler(terminating_signal);\n        }\n        if (interrupt_state != 0) {\n          throw_to_top_level();\n        }\n      }\n      if (terminating_signal != 0) {\n        termsig_handler(terminating_signal);\n      }\n      if ((((wait_intr_flag != 0) && (wait_signal_received != 0)) &&\n          (this_shell_builtin == (code *)PTR_wait_builtin_00237f70)) &&\n         (this_shell_builtin != (code *)0x0)) goto LAB_0016372d;\n      if (param_1 == -1) {\n        if ((code *)PTR_wait_for_background_pids_002387a8 != wait_for_background_pids)\n        goto LAB_00163757;\n        goto LAB_00163536;\n      }\n    } while (*(int *)(lVar9 + 0x10) == 1);\n    if (iVar16 == -1) {\n      if ((code *)PTR_wait_for_background_pids_002387a8 != wait_for_background_pids) {\n        set_signal_handler(2);\n        PTR_wait_for_background_pids_002387a8 = wait_for_background_pids;\n        waiting_for_child = 0;\n      }\n      goto LAB_001637ae;\n    }\n    lVar14 = (long)iVar16;\n    lVar13 = lVar14 * 8;\n    plVar15 = (long *)(jobs + lVar13);\n  } while (*(int *)(*plVar15 + 0x14) == 1);\n  if ((code *)PTR_wait_for_background_pids_002387a8 == wait_for_background_pids) {\nLAB_0016343f:\n    uVar7 = FUN_0015e730(iVar16);\n    if ((char)(((byte)uVar7 & 0x7f) + 1) < '\\x02') {\n      uVar12 = uVar7 >> 8 & 0xff;\n      last_command_exit_signal = 0;\n      if ((byte)uVar7 == 0x7f) {\n        uVar12 = 0;\n      }\n      lVar10 = *plVar15;\n      if (*(int *)(lVar10 + 0x14) != 2) goto LAB_00163486;\nLAB_0016384b:\n      uVar7 = *(uint *)(lVar9 + 0xc);\nLAB_0016384e:\n      uVar12 = (uVar7 >> 8 & 0xff) + 0x80;\nLAB_00163496:\n      lVar13 = lVar14 * 8;\n      lVar10 = *(long *)(jobs + lVar14 * 8);\n    }\n    else {\n      last_command_exit_signal = uVar7 & 0x7f;\n      uVar12 = last_command_exit_signal + 0x80;\n      lVar10 = *plVar15;\n      if (*(int *)(lVar10 + 0x14) == 2) goto LAB_0016384b;\nLAB_00163486:\n      if (lVar9 != 0) {\n        uVar7 = *(uint *)(lVar9 + 0xc);\n        if ((char)uVar7 == '\\x7f') goto LAB_0016384e;\n        goto LAB_00163496;\n      }\n    }\n    if (((*(byte *)(lVar10 + 0x18) & 4) != 0) && ((param_2 & 0x100) == 0)) {\n      if ((running_in_background == 0) && ((subshell_environment & 0x11) == 0)) goto LAB_00163809;\n      goto LAB_001634d4;\n    }\n    if (interactive_shell == 0) goto LAB_00163884;\nLAB_001634ea:\n    if (subshell_environment == 0) {\n      lVar9 = *(long *)(jobs + lVar13);\n      plVar15 = *(long **)(lVar9 + 8);\n      do {\n        uVar7 = *(uint *)((long)plVar15 + 0xc);\n        bVar4 = (byte)uVar7;\n        cVar3 = (char)((bVar4 & 0x7f) + 1) >> 1;\n        if (('\\0' < cVar3) || (bVar4 == 0x7f)) {\n          set_tty_state();\n          if (check_window_size == 0) {\n            lVar9 = *(long *)(jobs + lVar13);\n          }\n          else if ((DAT_00238790 == iVar16) ||\n                  (lVar9 = *(long *)(jobs + lVar13), (*(byte *)(lVar9 + 0x18) & 1) != 0)) {\n            get_new_window_size(0,0,0);\n            lVar9 = *(long *)(jobs + lVar13);\n          }\n          if ((((job_control != 0) && ((*(uint *)(lVar9 + 0x18) & 5) == 5)) && ('\\0' < cVar3)) &&\n             ((uVar7 & 0x7f) == 2)) {\n            iVar6 = signal_is_trapped(2);\n            if ((((iVar6 == 0) &&\n                 ((loop_level != 0 || ((0x20 < shell_compatibility_level && (executing_list != 0))))\n                 )) || ((iVar6 = signal_is_trapped(2), iVar6 != 0 && (loop_level != 0)))) ||\n               (((interactive_shell != 0 && (iVar6 = signal_is_trapped(2), iVar6 == 0)) &&\n                (sourcelevel != 0)))) {\n              interrupt_state = interrupt_state + 1;\n              lVar9 = *(long *)(jobs + lVar13);\n            }\n            else {\n              putc(10,stdout);\n              fflush(stdout);\n              lVar9 = *(long *)(jobs + lVar13);\n            }\n          }\n          goto LAB_0016351d;\n        }\n        plVar15 = (long *)*plVar15;\n      } while (*(long **)(lVar9 + 8) != plVar15);\n      if ((rl_readline_state & 0x4024) == 0) {\n        get_tty_state();\n        lVar9 = *(long *)(jobs + lVar13);\n      }\n    }\n    else {\n      if ((subshell_environment & 0x14) != 0) {\nLAB_001634f6:\n        if (((DAT_002475c4 != 0) && (DAT_002475c0 == 0)) &&\n           (iVar6 = signal_is_trapped(2), iVar6 == 0)) {\n          sigprocmask(2,&local_c8,(sigset_t *)0x0);\n          PTR_wait_for_background_pids_002387a8 = (undefined *)set_signal_handler(2,0);\n          if (PTR_wait_for_background_pids_002387a8 == (undefined *)0x1) {\n            set_signal_handler(2,1);\n            PTR_wait_for_background_pids_002387a8 = wait_for_background_pids;\n            waiting_for_child = 0;\n            lVar9 = *(long *)(jobs + lVar13);\n          }\n          else {\n            __pid = getpid();\n            kill(__pid,2);\n            lVar9 = *(long *)(jobs + lVar13);\n          }\n          goto LAB_0016351d;\n        }\n      }\n      lVar9 = *(long *)(jobs + lVar13);\n    }\nLAB_0016351d:\n    if ((*(int *)(lVar9 + 0x14) == 4) && ((*(byte *)(lVar9 + 0x18) & 1) != 0)) {\nLAB_00163916:\n      FUN_0015ede0(iVar16);\n    }\n  }\n  else {\nLAB_00163402:\n    set_signal_handler(2,PTR_wait_for_background_pids_002387a8);\n    PTR_wait_for_background_pids_002387a8 = wait_for_background_pids;\n    waiting_for_child = 0;\nLAB_00163420:\n    if (iVar16 != -1) {\n      lVar14 = (long)iVar16;\n      lVar13 = lVar14 * 8;\n      plVar15 = (long *)(jobs + lVar13);\n      goto LAB_0016343f;\n    }\n    if (lVar9 == 0) {\n      last_command_exit_signal = 0;\n      uVar12 = 0;\n    }\n    else {\nLAB_001637ae:\n      uVar7 = *(uint *)(lVar9 + 0xc);\n      if ((char)(((byte)uVar7 & 0x7f) + 1) < '\\x02') {\n        if ((uVar7 & 0xff) == 0x7f) {\n          last_command_exit_signal = 0;\nLAB_001639eb:\n          uVar12 = (uVar7 >> 8 & 0xff) + 0x80;\n        }\n        else {\n          last_command_exit_signal = 0;\n          uVar12 = uVar7 >> 8 & 0xff;\n        }\n      }\n      else {\n        last_command_exit_signal = uVar7 & 0x7f;\n        uVar12 = last_command_exit_signal + 0x80;\n        if ((uVar7 & 0xff) == 0x7f) goto LAB_001639eb;\n      }\n    }\n    if (((param_2 & 0x100 | running_in_background) != 0) || ((subshell_environment & 0x11) != 0))\n    goto LAB_00163536;\n    iVar16 = -1;\nLAB_00163809:\n    give_terminal_to(shell_pgrp,0);\n    if (iVar16 == -1) goto LAB_00163536;\n    lVar14 = (long)iVar16;\nLAB_001634d4:\n    lVar13 = lVar14 * 8;\n    if (interactive_shell != 0) goto LAB_001634ea;\nLAB_00163884:\n    if ((subshell_environment & 0x14) != 0) goto LAB_001634f6;\n    lVar9 = *(long *)(jobs + lVar13);\n    if (subshell_environment != 0) goto LAB_0016351d;\n    if ((*(uint *)(lVar9 + 0x18) & 1) != 0) {\n      plVar15 = *(long **)(lVar9 + 8);\n      while( true ) {\n        bVar4 = (byte)*(uint *)((long)plVar15 + 0xc);\n        if ('\\x01' < (char)((bVar4 & 0x7f) + 1)) break;\n        if ((bVar4 == 0x7f) || (plVar15 = (long *)*plVar15, *(long **)(lVar9 + 8) == plVar15))\n        goto LAB_001638fe;\n      }\n      if (((job_control != 0) && ((*(uint *)(lVar9 + 0x18) & 4) != 0)) &&\n         ((*(uint *)((long)plVar15 + 0xc) & 0x7f) == 2)) {\n        interrupt_state = interrupt_state + 1;\n      }\nLAB_001638fe:\n      if (check_window_size != 0) {\n        get_new_window_size(0,0,0);\n        lVar9 = *(long *)(jobs + lVar13);\n        goto LAB_0016351d;\n      }\n      if (*(int *)(lVar9 + 0x14) != 4) goto LAB_00163527;\n      goto LAB_00163916;\n    }\n  }\nLAB_00163527:\n  if (DAT_00247660 == 0) {\n    FUN_001628b0();\n  }\nLAB_00163536:\n  sigprocmask(2,&local_c8,(sigset_t *)0x0);\nLAB_00163545:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar12;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "internal_strmatch": "\nundefined8 internal_strmatch(char *param_1,char *param_2,undefined4 param_3)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  undefined8 uVar3;\n  \n  if (param_2 == (char *)0x0) {\n    return 1;\n  }\n  if (param_1 != (char *)0x0) {\n    sVar1 = strlen(param_2);\n    sVar2 = strlen(param_1);\n    uVar3 = FUN_001c0390(param_2,param_2 + sVar1,param_1,param_1 + sVar2,0,param_3);\n    return uVar3;\n  }\n  return 1;\n}\n\n",
  "FUN_001528d0": "\nlong FUN_001528d0(long param_1)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  char *__dest;\n  \n  pcVar1 = dollar_vars;\n  if ((dollar_vars == (char *)0x0) || (*dollar_vars == '\\0')) {\n    pcVar1 = (char *)sh_xmalloc(1,\"variables.c\",0x537);\n    *pcVar1 = '\\0';\n  }\n  else {\n    sVar2 = strlen(dollar_vars);\n    __dest = (char *)sh_xmalloc(sVar2 + 1,\"variables.c\",0x534);\n    pcVar1 = strcpy(__dest,pcVar1);\n  }\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x53a);\n  }\n  *(char **)(param_1 + 8) = pcVar1;\n  return param_1;\n}\n\n",
  "extract_array_assignment_list": "\nundefined8 extract_array_assignment_list(char *param_1,int *param_2)\n\n{\n  size_t sVar1;\n  undefined8 uVar2;\n  int iVar3;\n  \n  sVar1 = strlen(param_1);\n  if (param_1[(long)(int)sVar1 + -1] != ')') {\n    return 0;\n  }\n  iVar3 = (int)sVar1 + -1;\n  uVar2 = substring(param_1,*param_2,iVar3);\n  *param_2 = iVar3;\n  return uVar2;\n}\n\n",
  "getenv": "\nchar * getenv(char *__name)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  size_t sVar4;\n  char *__dest;\n  char *pcVar5;\n  char **ppcVar6;\n  size_t __n;\n  \n  if (*__name != '\\0') {\n    lVar3 = find_tempenv_variable();\n    ppcVar6 = environ;\n    if (lVar3 != 0) {\n      if (DAT_00248e90 != (char *)0x0) {\n        sh_xfree(DAT_00248e90,\"getenv.c\",0x3d);\n      }\n      pcVar5 = *(char **)(lVar3 + 8);\n      if (pcVar5 != (char *)0x0) {\n        sVar4 = strlen(pcVar5);\n        __dest = (char *)sh_xmalloc(sVar4 + 1,\"getenv.c\",0x3f);\n        pcVar5 = strcpy(__dest,pcVar5);\n      }\n      DAT_00248e90 = pcVar5;\n      return DAT_00248e90;\n    }\n    if (shell_variables == 0) {\n      if (environ != (char **)0x0) {\n        sVar4 = strlen(__name);\n        pcVar5 = *ppcVar6;\n        if (pcVar5 != (char *)0x0) {\n          __n = (size_t)(int)sVar4;\n          do {\n            ppcVar6 = ppcVar6 + 1;\n            if ((int)sVar4 == 0) {\n              cVar1 = pcVar5[__n];\njoined_r0x001c4857:\n              if (cVar1 == '=') {\n                return pcVar5 + __n + 1;\n              }\n            }\n            else if ((*pcVar5 == *__name) && (iVar2 = strncmp(pcVar5,__name,__n), iVar2 == 0)) {\n              cVar1 = pcVar5[__n];\n              goto joined_r0x001c4857;\n            }\n            pcVar5 = *ppcVar6;\n          } while (pcVar5 != (char *)0x0);\n        }\n      }\n    }\n    else {\n      lVar3 = find_variable(__name);\n      if ((lVar3 != 0) && ((*(byte *)(lVar3 + 0x28) & 1) != 0)) {\n        return *(char **)(lVar3 + 8);\n      }\n    }\n  }\n  return (char *)0x0;\n}\n\n",
  "expand_word": "\nundefined8 expand_word(undefined8 *param_1,undefined8 param_2)\n\n{\n  undefined *puVar1;\n  long lVar2;\n  undefined8 uVar3;\n  \n  puVar1 = (undefined *)FUN_00177e80(param_1,param_2,0,0,0);\n  if (puVar1 == &DAT_00247880) {\n    *param_1 = 0;\n    uVar3 = 2;\n  }\n  else {\n    if (puVar1 != &DAT_00247870) {\n      lVar2 = FUN_00171b00(puVar1);\n      dispose_words(puVar1);\n      if (lVar2 != 0) {\n        uVar3 = dequote_list(lVar2);\n        return uVar3;\n      }\n      return 0;\n    }\n    *param_1 = 0;\n    uVar3 = 1;\n  }\n  last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n  FUN_001667f0(uVar3);\n}\n\n",
  "rl_upcase_word": "\nvoid rl_upcase_word(undefined8 param_1)\n\n{\n  FUN_001eedd0(param_1,1);\n  return;\n}\n\n",
  "internal_error": "\nvoid internal_error(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                   undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                   undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                   undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  FUN_0015b0b0(1);\n  local_d0 = &stack0x00000008;\n  local_d8 = 8;\n  local_c8 = local_b8;\n  local_d4 = 0x30;\n  __vfprintf_chk(stderr,1,param_9,&local_d8);\n  fputc(10,stderr);\n  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "find_reserved_word": "\nint find_reserved_word(char *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined **ppuVar3;\n  char *__s2;\n  int iVar4;\n  \n  if (word_token_alist != (undefined *)0x0) {\n    cVar1 = *param_1;\n    ppuVar3 = &PTR_DAT_00238290;\n    iVar4 = 0;\n    __s2 = word_token_alist;\n    do {\n      if (cVar1 == *__s2) {\n        iVar2 = strcmp(param_1,__s2);\n        if (iVar2 == 0) {\n          return iVar4;\n        }\n      }\n      __s2 = *ppuVar3;\n      ppuVar3 = ppuVar3 + 2;\n      iVar4 = iVar4 + 1;\n    } while (__s2 != (char *)0x0);\n  }\n  return -1;\n}\n\n",
  "kvpair_assignment_p": "\nbool kvpair_assignment_p(long param_1)\n\n{\n  bool bVar1;\n  \n  bVar1 = false;\n  if ((param_1 != 0) && ((*(byte *)(*(char ***)(param_1 + 8) + 1) & 4) == 0)) {\n    bVar1 = ***(char ***)(param_1 + 8) != '[';\n  }\n  return bVar1;\n}\n\n",
  "show_local_var_attributes": "\nundefined8 show_local_var_attributes(undefined8 param_1,undefined4 param_2)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  undefined8 uVar5;\n  \n  puVar3 = (undefined8 *)all_local_variables(0);\n  if (puVar3 == (undefined8 *)0x0) {\n    uVar5 = 0;\n  }\n  else {\n    ppcVar1 = (char **)*puVar3;\n    puVar4 = puVar3;\n    while (ppcVar1 != (char **)0x0) {\n      puVar4 = puVar4 + 1;\n      if ((**ppcVar1 == '-') && ((*ppcVar1)[1] == '\\0')) {\n        puts(\"local -\");\n        iVar2 = sh_chkwrite(0);\n      }\n      else {\n        show_var_attributes(ppcVar1,this_shell_builtin == readonly_builtin ||\n                                    this_shell_builtin == export_builtin,param_2);\n        iVar2 = sh_chkwrite(0);\n      }\n      if (iVar2 != 0) {\n        uVar5 = 1;\n        goto LAB_001b3393;\n      }\n      ppcVar1 = (char **)*puVar4;\n    }\n    uVar5 = 0;\nLAB_001b3393:\n    sh_xfree(puVar3,\"./setattr.def\",0x192);\n  }\n  return uVar5;\n}\n\n",
  "fpurge": "\nundefined8 fpurge(void)\n\n{\n  __fpurge();\n  return 0;\n}\n\n",
  "FUN_00171de0": "\nundefined8\nFUN_00171de0(undefined4 param_1,undefined8 param_2,long *param_3,int param_4,uint param_5)\n\n{\n  long *plVar1;\n  undefined *puVar2;\n  undefined8 *puVar3;\n  undefined8 uVar4;\n  uint local_3c;\n  \n  if (param_3 != (long *)0x0) {\n    plVar1 = (long *)0x0;\n    do {\n      puVar2 = (undefined *)FUN_0016fa40(param_1,param_2,*(undefined8 *)param_3[1]);\n      puVar3 = (undefined8 *)alloc_word_desc();\n      if (puVar2 == (undefined *)0x0) {\n        puVar2 = (undefined *)sh_xmalloc(1,\"subst.c\",0x213f);\n        *puVar2 = 0;\n      }\n      *puVar3 = puVar2;\n      plVar1 = (long *)make_word_list(puVar3,plVar1);\n      param_3 = (long *)*param_3;\n    } while (param_3 != (long *)0x0);\n    if (plVar1 != (long *)0x0) {\n      if (*plVar1 != 0) {\n        plVar1 = (long *)list_reverse(plVar1);\n      }\n      goto LAB_00171e88;\n    }\n  }\n  plVar1 = (long *)0x0;\nLAB_00171e88:\n  local_3c = param_5;\n  if (((param_4 == 0x2a) && (DAT_00247848 != 0)) && (ifs_is_null != 0)) {\n    local_3c = param_5 | 1;\n  }\n  uVar4 = string_list_pos_params(param_4,plVar1,local_3c,0);\n  dispose_words(plVar1);\n  return uVar4;\n}\n\n",
  "wait_sigint_cleanup": "\nvoid wait_sigint_cleanup(void)\n\n{\n  DAT_00247690 = 0;\n  waiting_for_child = 0;\n  if ((code *)PTR_wait_for_background_pids_002387a8 != wait_for_background_pids) {\n    set_signal_handler(2);\n    PTR_wait_for_background_pids_002387a8 = wait_for_background_pids;\n  }\n  waiting_for_child = 0;\n  return;\n}\n\n",
  "rl_vi_bword": "\nundefined8 rl_vi_bword(int param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  long lVar3;\n  ushort **ppuVar4;\n  size_t sVar5;\n  int iVar6;\n  byte bVar7;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\nLAB_001d1170:\n  if (rl_point < 1) {\n    return 0;\n  }\n  lVar3 = (long)rl_point;\n  bVar7 = rl_line_buffer[lVar3];\n  if ((bVar7 != 0x20) && (bVar7 != 9)) {\n    bVar1 = rl_line_buffer[lVar3 + -1];\n    if ((bVar1 == 0x20) || (bVar1 == 9)) {\n      rl_point = rl_point + -1;\n      if (rl_point == 0) {\n        return 0;\n      }\n      bVar7 = rl_line_buffer[lVar3 + -1];\n    }\n  }\n  iVar2 = rl_point;\n  ppuVar4 = __ctype_b_loc();\n  bVar7 = (byte)((*ppuVar4)[bVar7] >> 3) & 1 | bVar7 == 0x5f;\n  sVar5 = __ctype_get_mb_cur_max();\n  iVar6 = rl_point;\n  if ((sVar5 == 1) || (rl_byte_oriented != 0)) {\n    rl_point = rl_point + -1;\n    iVar6 = iVar2;\nLAB_001d11ff:\n    if (bVar7 == ((byte)((*ppuVar4)[rl_line_buffer[rl_point]] >> 3) & 1 |\n                 rl_line_buffer[rl_point] == 0x5f)) {\nLAB_001d1479:\n      rl_point = iVar6;\n    }\n    do {\n      while( true ) {\n        if (rl_point < 1) goto LAB_001d1293;\n        bVar7 = rl_line_buffer[rl_point];\n        if ((bVar7 != 0x20) && (bVar7 != 9)) {\n          if (((*(byte *)(*ppuVar4 + bVar7) & 8) != 0) || (bVar7 == 0x5f)) goto LAB_001d12e0;\n          goto LAB_001d12d0;\n        }\n        sVar5 = __ctype_get_mb_cur_max();\n        if ((sVar5 != 1) && (rl_byte_oriented == 0)) break;\n        rl_point = rl_point + -1;\n      }\n      rl_point = _rl_backward_char_internal(1);\n    } while (-1 < rl_point);\n    goto LAB_001d1289;\n  }\n  rl_point = _rl_backward_char_internal(1);\n  if (-1 < rl_point) goto LAB_001d11ff;\n  rl_point = 0;\n  if (bVar7 == ((byte)((*ppuVar4)[*rl_line_buffer] >> 3) & 1 | *rl_line_buffer == 0x5f))\n  goto LAB_001d1479;\n  goto LAB_001d1293;\nLAB_001d12e0:\n  iVar2 = rl_point;\n  if (rl_point < 1) goto LAB_001d1339;\n  sVar5 = __ctype_get_mb_cur_max();\n  iVar6 = rl_point;\n  if ((sVar5 == 1) || (rl_byte_oriented != 0)) {\n    rl_point = rl_point + -1;\n    iVar6 = iVar2;\n  }\n  else {\n    rl_point = _rl_backward_char_internal(1);\n    if (rl_point < 0) goto LAB_001d1289;\n  }\n  iVar2 = rl_point;\n  if ((rl_point < 1) ||\n     (((*(byte *)(*ppuVar4 + rl_line_buffer[rl_point]) & 8) == 0 &&\n      (iVar2 = iVar6, rl_line_buffer[rl_point] != 0x5f)))) goto LAB_001d1339;\n  goto LAB_001d12e0;\nLAB_001d12d0:\n  iVar2 = rl_point;\n  if (rl_point < 1) goto LAB_001d1339;\n  sVar5 = __ctype_get_mb_cur_max();\n  iVar6 = rl_point;\n  if ((sVar5 == 1) || (rl_byte_oriented != 0)) {\n    rl_point = rl_point + -1;\n    iVar6 = iVar2;\n  }\n  else {\n    rl_point = _rl_backward_char_internal(1);\n    if (rl_point < 0) goto LAB_001d1289;\n  }\n  iVar2 = rl_point;\n  if ((((rl_point < 1) ||\n       (bVar7 = rl_line_buffer[rl_point], iVar2 = iVar6, (*(byte *)(*ppuVar4 + bVar7) & 8) != 0)) ||\n      (bVar7 == 0x5f)) || ((bVar7 == 0x20 || (bVar7 == 9)))) goto LAB_001d1339;\n  goto LAB_001d12d0;\nLAB_001d1339:\n  rl_point = iVar2;\n  if (rl_point < 0) {\nLAB_001d1289:\n    rl_point = 0;\n  }\nLAB_001d1293:\n  param_1 = param_1 + -1;\n  if (param_1 == 0) {\n    return 0;\n  }\n  goto LAB_001d1170;\n}\n\n",
  "builtin_find_indexed_array": "\nlong builtin_find_indexed_array(undefined8 param_1,uint param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  long lVar3;\n  \n  if (((param_2 & 2) == 0) || (iVar2 = legal_identifier(), iVar2 != 0)) {\n    lVar3 = find_or_make_array_variable(param_1,1);\n    if (lVar3 != 0) {\n      uVar1 = *(uint *)(lVar3 + 0x28);\n      if ((uVar1 & 4) == 0) {\n        builtin_error(\"%s: not an indexed array\",param_1);\n        lVar3 = 0;\n      }\n      else {\n        if ((uVar1 & 0x1000) != 0) {\n          *(uint *)(lVar3 + 0x28) = uVar1 & 0xffffefff;\n        }\n        if ((param_2 & 1) != 0) {\n          array_flush(*(undefined8 *)(lVar3 + 8));\n          return lVar3;\n        }\n      }\n    }\n  }\n  else {\n    builtin_error(\"`%s\\': not a valid identifier\",param_1);\n    lVar3 = 0;\n  }\n  return lVar3;\n}\n\n",
  "coproc_fdclose": "\nvoid coproc_fdclose(long param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)(param_1 + 0xc);\n  if ((-1 < iVar1) && (param_2 == iVar1)) {\n    close(iVar1);\n    *(undefined4 *)(param_1 + 0xc) = 0xffffffff;\n  }\n  iVar1 = *(int *)(param_1 + 0x10);\n  if ((-1 < iVar1) && (param_2 == iVar1)) {\n    close(iVar1);\n    *(undefined4 *)(param_1 + 0x10) = 0xffffffff;\n    coproc_setvars(param_1);\n    return;\n  }\n  coproc_setvars(param_1);\n  return;\n}\n\n",
  "find_token_in_alist": "\nchar * find_token_in_alist(int param_1,char **param_2)\n\n{\n  size_t sVar1;\n  char *__dest;\n  char *pcVar2;\n  \n  pcVar2 = *param_2;\n  if (pcVar2 != (char *)0x0) {\n    param_2 = param_2 + 2;\n    do {\n      if (*(int *)(param_2 + -1) == param_1) {\n        sVar1 = strlen(pcVar2);\n        __dest = (char *)sh_xmalloc(sVar1 + 1,\"stringlib.c\",0x58);\n        pcVar2 = strcpy(__dest,pcVar2);\n        return pcVar2;\n      }\n      pcVar2 = *param_2;\n      param_2 = param_2 + 2;\n    } while (pcVar2 != (char *)0x0);\n  }\n  return (char *)0x0;\n}\n\n",
  "FUN_0019ea20": "\nundefined8 FUN_0019ea20(uint *param_1)\n\n{\n  undefined4 uVar1;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  \n  puVar2 = (undefined8 *)strlist_create(0);\n  uVar3 = get_shopt_options();\n  *puVar2 = uVar3;\n  uVar1 = strvec_len(uVar3);\n  *(undefined4 *)((long)puVar2 + 0xc) = uVar1;\n  *(undefined8 **)(param_1 + 4) = puVar2;\n  *param_1 = *param_1 | 0x20;\n  return 0;\n}\n\n",
  "test_builtin": "\nundefined4 test_builtin(long param_1)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined4 local_24;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    uVar1 = 1;\n    if ((*this_command_name == '[') && (this_command_name[1] == '\\0')) {\n      uVar1 = 2;\n      builtin_error(\"missing `]\\'\");\n    }\n  }\n  else {\n    uVar2 = make_builtin_argv(param_1,&local_24);\n    uVar1 = test_command(local_24,uVar2);\n    sh_xfree(uVar2,\"./test.def\",0x9c);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_set_cursor": "\nvoid _rl_set_cursor(int param_1,int param_2)\n\n{\n  if (((DAT_0024b5c0 != 0) && (DAT_0024b5c8 != 0)) &&\n     ((param_2 != 0 || (rl_insert_mode != param_1)))) {\n    if (param_1 == 0) {\n      tputs(DAT_0024b5c8,1,_rl_output_character_function);\n      return;\n    }\n    tputs(DAT_0024b5c0,1,_rl_output_character_function);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_0019e9e0": "\nundefined8 FUN_0019e9e0(uint *param_1)\n\n{\n  undefined4 uVar1;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  \n  puVar2 = (undefined8 *)strlist_create(0);\n  uVar3 = get_minus_o_opts();\n  *puVar2 = uVar3;\n  uVar1 = strvec_len(uVar3);\n  *(undefined4 *)((long)puVar2 + 0xc) = uVar1;\n  *(undefined8 **)(param_1 + 4) = puVar2;\n  *param_1 = *param_1 | 0x20;\n  return 0;\n}\n\n",
  "help_builtin": "\nundefined8 help_builtin(undefined8 param_1)\n\n{\n  wchar_t *__s;\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  long *plVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  undefined8 uVar9;\n  size_t sVar10;\n  ulong uVar11;\n  int *piVar12;\n  char *pcVar13;\n  char *pcVar14;\n  wchar_t *pwVar15;\n  int iVar16;\n  long lVar17;\n  bool bVar18;\n  char *pcVar19;\n  int iVar20;\n  char **ppcVar21;\n  long lVar22;\n  long in_FS_OFFSET;\n  int local_10c;\n  long *local_e0;\n  char *local_d0;\n  undefined local_c8 [136];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  reset_internal_getopt();\n  bVar3 = false;\n  bVar1 = false;\n  bVar4 = false;\n  while( true ) {\n    iVar20 = 0x20fcbb;\n    iVar6 = internal_getopt(param_1);\n    plVar5 = loptend;\n    if (iVar6 == -1) break;\n    if (iVar6 == 0x6d) {\n      bVar3 = true;\n    }\n    else if (iVar6 < 0x6e) {\n      if (iVar6 == -99) {\n        builtin_help();\n        uVar9 = 0x102;\n        goto LAB_001abc2b;\n      }\n      if (iVar6 != 100) {\nLAB_001abc70:\n        builtin_usage();\n        uVar9 = 0x102;\n        goto LAB_001abc2b;\n      }\n      bVar1 = true;\n    }\n    else {\n      if (iVar6 != 0x73) goto LAB_001abc70;\n      bVar4 = true;\n    }\n  }\n  local_e0 = loptend;\n  if (loptend != (long *)0x0) {\n    iVar6 = glob_pattern_p(*(char **)loptend[1],iVar20);\n    if (iVar6 == 1) {\n      pcVar14 = \"Shell commands matching keyword `\";\n      if (*plVar5 != 0) {\n        pcVar14 = \"Shell commands matching keywords `\";\n      }\n      __printf_chk(1,&DAT_002102da,pcVar14);\n      print_word_list(plVar5,&DAT_0020f034);\n      puts(\"\\'\\n\");\n    }\n    iVar6 = 0;\n    ppcVar21 = (char **)shell_builtins;\nLAB_001abcd0:\n    bVar18 = false;\n    pcVar14 = *(char **)local_e0[1];\n    sVar10 = strlen(pcVar14);\n    local_10c = 1;\n    do {\n      iVar20 = 0;\n      lVar17 = 0;\n      pcVar13 = *ppcVar21;\n      while (pcVar13 != (char *)0x0) {\n        if (terminating_signal == 0) {\n          if (interrupt_state == 0) goto LAB_001abd1e;\nLAB_001abdd1:\n          throw_to_top_level();\n          if (local_10c == 1) goto LAB_001abde1;\nLAB_001abd29:\n          iVar7 = strncmp(pcVar14,pcVar13,(long)(int)sVar10);\n          if (iVar7 == 0) goto LAB_001abd3d;\n        }\n        else {\n          termsig_handler(terminating_signal);\n          if (interrupt_state != 0) goto LAB_001abdd1;\nLAB_001abd1e:\n          if (local_10c != 1) goto LAB_001abd29;\nLAB_001abde1:\n          iVar7 = strcmp(pcVar14,pcVar13);\n          if ((iVar7 == 0) ||\n             (iVar7 = strmatch(pcVar14,pcVar13,(ulong)(extended_glob != 0) << 5), iVar7 != 1)) {\nLAB_001abd3d:\n            iVar6 = iVar6 + 1;\n            if (bVar1) {\n              ppcVar21 = *(char ***)(shell_builtins + lVar17 + 0x18);\n              bVar18 = bVar1;\n              if (ppcVar21 == (char **)0x0) {\n                pcVar19 = (char *)0x0;\nLAB_001ac0af:\n                local_d0 = pcVar19;\n                __printf_chk(1,&DAT_0020fcdc,pcVar13);\n                if (local_d0 == (char *)0x0) {\n                  fflush(stdout);\n                }\n                else {\n                  bVar2 = false;\nLAB_001ac0da:\n                  lVar22 = 0;\n                  do {\n                    if (local_d0[lVar22] == '\\0') {\n                      fflush(stdout);\n                      if (!bVar2) goto LAB_001abd8e;\n                      goto LAB_001ac377;\n                    }\n                    putc((int)local_d0[lVar22],stdout);\n                  } while ((local_d0[lVar22] != '\\n') &&\n                          (lVar22 = lVar22 + 1, local_d0 != (char *)0x0));\n                  fflush(stdout);\n                  if (bVar2) goto LAB_001ac377;\n                }\n              }\n              else {\n                pcVar19 = *ppcVar21;\n                if (((pcVar19 == (char *)0x0) || (*pcVar19 != '/')) || (ppcVar21[1] != (char *)0x0))\n                goto LAB_001ac0af;\n                iVar7 = open(pcVar19,0);\n                if (iVar7 == -1) {\n                  piVar12 = __errno_location();\n                  pcVar13 = strerror(*piVar12);\n                  builtin_error(\"%s: cannot open: %s\",pcVar19,pcVar13);\n                  goto LAB_001abd8e;\n                }\n                if (iVar7 < 0) goto LAB_001abd8e;\n                zmapfd(iVar7,&local_d0,*ppcVar21);\n                close(iVar7);\n                __printf_chk(1,&DAT_0020fcdc,pcVar13);\n                bVar2 = bVar1;\n                if (local_d0 != (char *)0x0) goto LAB_001ac0da;\n                fflush(stdout);\nLAB_001ac377:\n                sh_xfree(local_d0,\"./help.def\",0x122);\n              }\n            }\n            else {\n              if (!bVar3) {\n                __printf_chk(1,\"%s: %s\\n\",pcVar13,*(undefined8 *)(shell_builtins + lVar17 + 0x20));\n                bVar18 = bVar4;\n                if (!bVar4) {\n                  FUN_001aba30(iVar20);\n                  bVar18 = true;\n                }\n                goto LAB_001abd8e;\n              }\n              ppcVar21 = *(char ***)(shell_builtins + lVar17 + 0x18);\n              bVar18 = bVar3;\n              if (ppcVar21 == (char **)0x0) {\n                pcVar19 = (char *)0x0;\nLAB_001abe40:\n                local_d0 = pcVar19;\n                puts(\"NAME\");\n                __printf_chk(1,&DAT_0020fcd9,4,&DAT_001fdb1c,pcVar13);\n                if (local_d0 == (char *)0x0) {\n                  putchar(10);\n                  puts(\"SYNOPSIS\");\n                  __printf_chk(1,\"%*s%s\\n\\n\",4,&DAT_001fdb1c,\n                               *(undefined8 *)(shell_builtins + lVar17 + 0x20));\n                  puts(\"DESCRIPTION\");\n                }\n                else {\n                  bVar2 = false;\nLAB_001abe8c:\n                  lVar22 = 0;\n                  do {\n                    if ((local_d0[lVar22] == '\\0') ||\n                       (putc((int)local_d0[lVar22],stdout), local_d0[lVar22] == '\\n')) break;\n                    lVar22 = lVar22 + 1;\n                  } while (local_d0 != (char *)0x0);\n                  putchar(10);\n                  puts(\"SYNOPSIS\");\n                  __printf_chk(1,\"%*s%s\\n\\n\",4,&DAT_001fdb1c,\n                               *(undefined8 *)(shell_builtins + lVar17 + 0x20));\n                  puts(\"DESCRIPTION\");\n                  if (bVar2) goto LAB_001ac220;\n                }\n                pcVar13 = *ppcVar21;\n                while (pcVar13 != (char *)0x0) {\n                  ppcVar21 = ppcVar21 + 1;\n                  __printf_chk(1,\"%*s%s\\n\",4,&DAT_001fdb1c);\n                  pcVar13 = *ppcVar21;\n                }\n                putc(10,stdout);\n                puts(\"SEE ALSO\");\n                __printf_chk(1,\"%*sbash(1)\\n\\n\",4,&DAT_001fdb1c);\n                puts(\"IMPLEMENTATION\");\n                __printf_chk(1,&DAT_001fdb4d,4,&DAT_001fdb1c);\n                show_shell_version(0);\n                __printf_chk(1,&DAT_001fdb4d,4,&DAT_001fdb1c);\n                puts(bash_copyright);\n                __printf_chk(1,&DAT_001fdb4d,4,&DAT_001fdb1c);\n                puts(bash_license);\n                fflush(stdout);\n              }\n              else {\n                pcVar19 = *ppcVar21;\n                if (((pcVar19 == (char *)0x0) || (*pcVar19 != '/')) || (ppcVar21[1] != (char *)0x0))\n                goto LAB_001abe40;\n                iVar7 = open(pcVar19,0);\n                if (iVar7 == -1) {\n                  piVar12 = __errno_location();\n                  pcVar13 = strerror(*piVar12);\n                  builtin_error(\"%s: cannot open: %s\",pcVar19,pcVar13);\n                  goto LAB_001abd8e;\n                }\n                if (iVar7 < 0) goto LAB_001abd8e;\n                zmapfd(iVar7,&local_d0,*ppcVar21);\n                close(iVar7);\n                puts(\"NAME\");\n                __printf_chk(1,&DAT_0020fcd9,4,&DAT_001fdb1c,pcVar13);\n                bVar2 = bVar3;\n                if (local_d0 != (char *)0x0) goto LAB_001abe8c;\n                putchar(10);\n                puts(\"SYNOPSIS\");\n                __printf_chk(1,\"%*s%s\\n\\n\",4,&DAT_001fdb1c,\n                             *(undefined8 *)(shell_builtins + lVar17 + 0x20));\n                puts(\"DESCRIPTION\");\nLAB_001ac220:\n                lVar22 = 0;\n                while (local_d0 != (char *)0x0) {\n                  while( true ) {\n                    if (local_d0[lVar22] == '\\0') goto LAB_001ac297;\n                    putc((int)local_d0[lVar22],stdout);\n                    if (local_d0[lVar22] != '\\n') break;\n                    lVar22 = lVar22 + 1;\n                    __printf_chk(1,&DAT_001fdb4d,4,&DAT_001fdb1c);\n                    if (local_d0 == (char *)0x0) goto LAB_001ac297;\n                  }\n                  lVar22 = lVar22 + 1;\n                }\nLAB_001ac297:\n                putc(10,stdout);\n                puts(\"SEE ALSO\");\n                __printf_chk(1,\"%*sbash(1)\\n\\n\",4,&DAT_001fdb1c);\n                puts(\"IMPLEMENTATION\");\n                __printf_chk(1,&DAT_001fdb4d,4,&DAT_001fdb1c);\n                show_shell_version(0);\n                __printf_chk(1,&DAT_001fdb4d,4,&DAT_001fdb1c);\n                puts(bash_copyright);\n                __printf_chk(1,&DAT_001fdb4d,4,&DAT_001fdb1c);\n                puts(bash_license);\n                fflush(stdout);\n                sh_xfree(local_d0,\"./help.def\",0x16d);\n              }\n            }\n          }\n        }\nLAB_001abd8e:\n        lVar17 = lVar17 + 0x30;\n        iVar20 = iVar20 + 1;\n        ppcVar21 = (char **)shell_builtins;\n        pcVar13 = *(char **)(shell_builtins + lVar17);\n      }\n      if (((local_10c == 1) && (bVar18)) || (local_10c == 2)) goto LAB_001ac038;\n      local_10c = 2;\n    } while( true );\n  }\n  show_shell_version(0);\n  puts(\n      \"These shell commands are defined internally.  Type `help\\' to see this list.\\nType `help name\\' to find out more about the function `name\\'.\\nUse `info bash\\' to find out more about the shell in general.\\nUse `man -k\\' or `info\\' to find out more about commands not in this list.\\n\\nA star (*) next to a name means that the command is disabled.\\n\"\n      );\n  iVar20 = default_columns();\n  iVar6 = 0x80;\n  if (((uint)(iVar20 - (iVar20 >> 0x1f)) < 0x102) && (iVar6 = 0x28, 7 < iVar20)) {\n    iVar6 = iVar20 / 2;\n  }\n  iVar20 = (num_shell_builtins + 1) / 2;\n  if (0 < num_shell_builtins) {\n    lVar17 = 0;\n    iVar16 = 0;\n    iVar7 = iVar6 + -2;\n    do {\n      if (terminating_signal != 0) {\n        termsig_handler();\n      }\n      if (interrupt_state != 0) {\n        throw_to_top_level();\n      }\n      sVar10 = __ctype_get_mb_cur_max();\n      if (sVar10 < 2) {\nLAB_001ac868:\n        FUN_001ab8e0(iVar16,local_c8,iVar6,iVar20);\n      }\n      else {\n        pcVar14 = *(char **)(shell_builtins + lVar17 + 0x20);\n        sVar10 = mbstowcs((wchar_t *)0x0,pcVar14,0);\n        if (sVar10 == 0xffffffffffffffff) goto LAB_001ac868;\n        if ((ulong)(long)iVar6 <= sVar10) {\n          sVar10 = (long)iVar7;\n        }\n        piVar12 = (int *)sh_xmalloc((ulong)(iVar6 + 2) << 2,\"./help.def\",0x1b5);\n        __s = piVar12 + 1;\n        uVar11 = __mbstowcs_chk(__s,pcVar14,sVar10 + 1,0x3fffffffffffffff);\n        piVar12[uVar11 + 1] = 0;\n        pwVar15 = __s;\n        if (1 < uVar11) {\n          do {\n            if ((uint)(*pwVar15 + L'\\xfffffff7') < 2) {\n              *pwVar15 = L' ';\n            }\n            pwVar15 = pwVar15 + 1;\n          } while (piVar12 + uVar11 != pwVar15);\n        }\n        iVar8 = wcsnwidth(__s,sVar10,iVar7);\n        sVar10 = (size_t)iVar8;\n        iVar8 = wcswidth(__s,sVar10);\n        iVar8 = iVar8 + 1;\n        *piVar12 = (-(uint)((*(uint *)(shell_builtins + lVar17 + 0x10) & 1) == 0) & 10) + 0x20;\n        if (iVar7 <= iVar8) {\n          piVar12[sVar10] = 0x3e;\n          piVar12[sVar10 + 1] = 0;\n        }\n        __printf_chk(1,&DAT_0020fcbf,piVar12);\n        if ((iVar16 * 2 < num_shell_builtins) && (iVar20 + iVar16 < num_shell_builtins)) {\n          if (iVar8 < iVar6) {\n            do {\n              iVar8 = iVar8 + 1;\n              putc(0x20,stdout);\n            } while (iVar6 != iVar8);\n          }\n          lVar22 = (long)(iVar20 + iVar16) * 0x30;\n          pcVar14 = *(char **)(shell_builtins + lVar22 + 0x20);\n          sVar10 = mbstowcs((wchar_t *)0x0,pcVar14,0);\n          if (sVar10 == 0xffffffffffffffff) {\n            __printf_chk(1,\"%c%s\\n\",\n                         (-((*(uint *)(shell_builtins + lVar22 + 0x10) & 1) == 0) & 10U) + 0x20,\n                         pcVar14);\n            sh_xfree(piVar12,\"./help.def\",0x1df);\n          }\n          else {\n            if ((ulong)(long)iVar6 <= sVar10) {\n              sVar10 = (long)iVar7;\n            }\n            uVar11 = __mbstowcs_chk(__s,pcVar14,sVar10 + 1,0x3fffffffffffffff);\n            piVar12[uVar11 + 1] = 0;\n            pwVar15 = __s;\n            if (1 < uVar11) {\n              do {\n                if ((uint)(*pwVar15 + L'\\xfffffff7') < 2) {\n                  *pwVar15 = L' ';\n                }\n                pwVar15 = pwVar15 + 1;\n              } while (piVar12 + uVar11 != pwVar15);\n            }\n            iVar8 = wcsnwidth(__s,sVar10,iVar7);\n            sVar10 = (size_t)iVar8;\n            iVar8 = wcswidth(__s,sVar10);\n            *piVar12 = (-(uint)((*(uint *)(shell_builtins + lVar22 + 0x10) & 1) == 0) & 10) + 0x20;\n            if (iVar7 <= iVar8 + 1) {\n              piVar12[sVar10 - 1] = 0x3e;\n              piVar12[sVar10] = 0;\n            }\n            __printf_chk(1,&DAT_0020fcd4,piVar12);\n            sh_xfree(piVar12,\"./help.def\",0x1ff);\n          }\n        }\n        else {\n          putchar(10);\n          sh_xfree(piVar12,\"./help.def\",0x1d0);\n        }\n      }\n      iVar16 = iVar16 + 1;\n      lVar17 = lVar17 + 0x30;\n    } while (iVar16 < iVar20);\n  }\n  uVar9 = 0;\nLAB_001abc2b:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar9;\n  }\nLAB_001ac927:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\nLAB_001ac038:\n  local_e0 = (long *)*local_e0;\n  if (local_e0 == (long *)0x0) goto code_r0x001ac04e;\n  goto LAB_001abcd0;\ncode_r0x001ac04e:\n  if (iVar6 != 0) {\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar9 = sh_chkwrite(0);\n      return uVar9;\n    }\n    goto LAB_001ac927;\n  }\n  builtin_error(\"no help topics match `%s\\'.  Try `help help\\' or `man -k %s\\' or `info %s\\'.\",\n                pcVar14,pcVar14,pcVar14);\n  uVar9 = 1;\n  goto LAB_001abc2b;\n}\n\n",
  "glob_vector": "\n/* WARNING: Removing unreachable block (ram,0x001bde2e) */\n/* WARNING: Removing unreachable block (ram,0x001be6c4) */\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nundefined8 * glob_vector(char *param_1,undefined8 *param_2,undefined4 param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  char *pcVar4;\n  undefined8 *puVar5;\n  undefined8 *puVar6;\n  undefined8 *puVar7;\n  size_t sVar8;\n  char *__dest;\n  undefined8 *puVar9;\n  dirent *pdVar10;\n  long *plVar11;\n  undefined8 *puVar12;\n  undefined8 uVar13;\n  undefined *puVar14;\n  undefined *puVar15;\n  undefined *puVar16;\n  undefined8 *puVar17;\n  long lVar18;\n  undefined8 *puVar19;\n  long in_FS_OFFSET;\n  undefined auStack_168 [8];\n  undefined8 local_160;\n  char *local_158;\n  undefined8 local_150;\n  undefined auStack_148 [8];\n  undefined8 *local_140;\n  char *local_138;\n  undefined8 *local_130;\n  int local_124;\n  undefined8 local_120;\n  int local_118;\n  uint local_114;\n  uint local_110;\n  uint local_10c;\n  char *local_108;\n  uint local_100;\n  uint local_fc;\n  undefined8 *local_f8;\n  undefined8 local_f0;\n  undefined8 local_e8;\n  undefined8 *local_e0;\n  stat local_d8;\n  long local_40;\n  \n  puVar16 = auStack_148;\n  puVar15 = auStack_148;\n  local_f0 = (undefined8 *)CONCAT44(local_f0._4_4_,param_3);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e0 = param_2;\n  if ((param_1 == (char *)0x0) || (*param_1 == '\\0')) {\n    local_150 = 0x1bde08;\n    iVar2 = stat((char *)param_2,&local_d8);\n    if ((iVar2 < 0) || ((local_d8.st_mode & 0xf000) != 0x4000)) {\nLAB_001be318:\n      puVar5 = &glob_error_return;\n      puVar15 = auStack_148;\n      goto LAB_001bdf55;\n    }\n    puVar16 = auStack_168;\n    puVar14 = auStack_168;\n    puVar19 = &local_160;\n    local_160 = 0;\n    local_e0 = puVar19;\n    pcVar4 = (char *)sh_malloc(1,\"glob.c\",0x2ce);\n    puVar15 = auStack_168;\n    if (pcVar4 != (char *)0x0) {\n      *pcVar4 = '\\0';\n      local_158 = pcVar4;\n      if (param_1 == (char *)0x0) {\n        local_e8 = CONCAT44(local_e8._4_4_,1);\n        puVar17 = (undefined8 *)0x0;\nLAB_001bdea3:\n        uVar3 = (int)local_e8 + 1;\n        *(undefined8 *)(puVar16 + -8) = 0x1bdebd;\n        puVar5 = (undefined8 *)sh_malloc((ulong)uVar3 << 3,\"glob.c\",0x3e5);\n        puVar14 = puVar16;\n        if (puVar5 != (undefined8 *)0x0) {\nLAB_001bdec9:\n          if ((int)local_e8 != 0) {\nLAB_001bded3:\n            puVar6 = puVar5;\n            puVar9 = puVar19;\n            do {\n              puVar12 = puVar9 + 1;\n              puVar7 = puVar6 + 1;\n              puVar9 = (undefined8 *)*puVar9;\n              *puVar6 = *puVar12;\n              puVar6 = puVar7;\n            } while (puVar7 != puVar5 + (ulong)((int)local_e8 - 1) + 1);\n          }\n          puVar5[local_e8 & 0xffffffff] = 0;\n          puVar15 = puVar14;\n          if (puVar17 != (undefined8 *)0x0) {\n            while (puVar19 != (undefined8 *)0x0) {\n              if (puVar19 == puVar17) {\n                *(undefined8 *)(puVar14 + -8) = 0x1bdf55;\n                sh_xfree(puVar17,\"glob.c\",0x41a);\n                break;\n              }\n              puVar9 = (undefined8 *)*puVar19;\n              *(undefined8 *)(puVar14 + -8) = 0x1bdf3b;\n              sh_xfree(puVar19,\"glob.c\",0x41a);\n              puVar19 = puVar9;\n            }\n          }\n          goto LAB_001bdf55;\n        }\n      }\n      else {\n        if (*param_1 != '\\0') {\n          local_e8 = CONCAT44(local_e8._4_4_,1);\n          puVar17 = (undefined8 *)0x0;\n          puVar16 = auStack_168;\n          puVar19 = local_e0;\n          goto LAB_001be704;\n        }\n        puVar5 = (undefined8 *)sh_malloc(0x10,\"glob.c\",0x3e5);\n        if (puVar5 != (undefined8 *)0x0) {\n          local_e8 = CONCAT44(local_e8._4_4_,1);\n          puVar17 = (undefined8 *)0x0;\n          goto LAB_001bded3;\n        }\n        puVar17 = (undefined8 *)0x0;\n        puVar16 = auStack_168;\n        puVar19 = local_e0;\n      }\nLAB_001be410:\n      do {\n        puVar15 = puVar16;\n        if (puVar17 == (undefined8 *)0x0) goto LAB_001be458;\n        uVar13 = puVar19[1];\n        if (puVar19 == puVar17) {\n          puVar17 = (undefined8 *)0x0;\n        }\n        *(undefined8 *)(puVar16 + -8) = 0x1be438;\n        sh_xfree(uVar13,\"glob.c\",0x3fc);\n        puVar5 = (undefined8 *)*puVar19;\n        *(undefined8 *)(puVar16 + -8) = 0x1be44b;\n        sh_xfree(puVar19,\"glob.c\",0x3fe);\n        puVar19 = puVar5;\n      } while (puVar5 != (undefined8 *)0x0);\n    }\n  }\n  else {\n    local_150 = 0x1bdf85;\n    sVar8 = strlen(param_1);\n    local_150 = 0x1bdf90;\n    uVar3 = glob_pattern_p(param_1,(int)param_2);\n    if ((uVar3 & 0xfffffffd) != 0) {\n      puVar5 = &glob_error_return;\n      local_150 = 0x1be073;\n      puVar9 = (undefined8 *)opendir((char *)local_e0);\n      if (puVar9 != (undefined8 *)0x0) {\n        local_fc = (-(uint)(noglob_dot_filenames == 0) & 0x7c) + 5;\n        if (glob_ignore_case != 0) {\n          local_fc = local_fc | 0x10;\n        }\n        if (extended_glob != 0) {\n          local_fc = local_fc | 0x20;\n        }\n        local_118 = 0;\n        local_e8 = local_e8 & 0xffffffff00000000;\n        local_10c = (uint)local_f0 & 0x210;\n        uVar3 = (int)(uint)local_f0 >> 2 & 4;\n        local_114 = (uint)local_f0 & 0x100;\n        local_110 = uVar3 | 8;\n        if (((ulong)local_f0 & 0x100) == 0) {\n          local_110 = uVar3;\n        }\n        local_100 = (uint)local_f0 & 0x18;\n        puVar17 = (undefined8 *)0x0;\n        local_f8 = (undefined8 *)0x0;\nLAB_001be128:\n        do {\n          puVar19 = local_f8;\n          if ((interrupt_state != 0) || (terminating_signal != 0)) goto LAB_001be5d4;\n          *(undefined8 *)(puVar16 + -8) = 0x1be14e;\n          iVar2 = signal_is_pending(2);\n          puVar19 = local_f8;\n          if (iVar2 != 0) goto LAB_001be5d4;\n          *(undefined8 *)(puVar16 + -8) = 0x1be15e;\n          pdVar10 = readdir((DIR *)puVar9);\n          puVar19 = local_f8;\n          if (pdVar10 == (dirent *)0x0) {\n            *(undefined8 *)(puVar16 + -8) = 0x1be333;\n            closedir((DIR *)puVar9);\n            if (local_10c != 0x210) goto LAB_001be704;\n            *(undefined8 *)(puVar16 + -8) = 0x1be356;\n            sVar8 = strlen((char *)local_e0);\n            sVar8 = (size_t)((int)sVar8 + 1);\n            *(undefined8 *)(puVar16 + -8) = 0x1be36d;\n            local_f0 = (undefined8 *)sh_malloc(sVar8,\"glob.c\",0x3ce);\n            *(undefined8 *)(puVar16 + -8) = 0x1be386;\n            puVar9 = (undefined8 *)sh_malloc(0x10,\"glob.c\",0x3cf);\n            puVar5 = local_f0;\n            if (puVar9 != (undefined8 *)0x0) {\n              if (local_f0 != (undefined8 *)0x0) {\n                puVar9[1] = local_f0;\n                *puVar9 = puVar19;\n                if (local_114 == 0) {\n                  *(undefined8 *)(puVar16 + -8) = 0x1be7fc;\n                  memmove(local_f0,local_e0,sVar8);\n                }\n                else {\n                  *(undefined *)local_f0 = 0;\n                }\n                local_e8 = CONCAT44(local_e8._4_4_,(int)local_e8 + 1);\n                puVar19 = puVar9;\n                goto LAB_001bdea3;\n              }\n              if (puVar9 != (undefined8 *)0x0) {\n                local_e0 = local_f0;\n                *(undefined8 *)(puVar16 + -8) = 0x1be3e4;\n                sh_xfree(puVar9,\"glob.c\",0x3d2);\n                puVar5 = local_e0;\n              }\n            }\n            if (puVar5 != (undefined8 *)0x0) {\n              *(undefined8 *)(puVar16 + -8) = 0x1be400;\n              sh_xfree(puVar5,\"glob.c\",0x3d3);\n            }\n            goto LAB_001be400;\n          }\n        } while (pdVar10->d_ino == 0);\n        *(undefined8 *)(puVar16 + -8) = 0x1be175;\n        sVar8 = __ctype_get_mb_cur_max();\n        pcVar4 = pdVar10->d_name;\n        if (1 < sVar8) {\n          *(undefined8 *)(puVar16 + -8) = 0x1be18a;\n          iVar2 = FUN_001bd790(param_1,pcVar4);\n          if (iVar2 != 0) goto LAB_001be128;\n        }\n        *(undefined8 *)(puVar16 + -8) = 0x1be199;\n        iVar2 = FUN_001bd510(param_1,pcVar4);\n        if (iVar2 == 0) {\n          if (local_100 == 0) {\nLAB_001be1df:\n            if (((ulong)local_f0 & 0x10) == 0) {\n              if (((ulong)local_f0 & 8) != 0) {\n                *(undefined8 *)(puVar16 + -8) = 0x1be49d;\n                sh_xfree(local_108,\"glob.c\",0x399);\n              }\nLAB_001be49d:\n              *(undefined8 *)(puVar16 + -8) = 0x1be4a5;\n              sVar8 = strlen(pcVar4);\n              *(undefined8 *)(puVar16 + -8) = 0x1be4b0;\n              uVar13 = fnx_fromfs(pcVar4,sVar8);\n              *(undefined8 *)(puVar16 + -8) = 0x1be4c1;\n              iVar2 = strmatch(param_1,uVar13,local_fc);\n              if (iVar2 != 1) {\n                puVar15 = puVar16;\n                if (local_118 < 100000) {\n                  for (; puVar15 != puVar16; puVar15 = puVar15 + -0x1000) {\n                    *(undefined8 *)(puVar15 + -8) = *(undefined8 *)(puVar15 + -8);\n                  }\n                  puVar16 = puVar15 + -0x20;\n                  *(undefined8 *)(puVar15 + -8) = *(undefined8 *)(puVar15 + -8);\n                  local_118 = local_118 + 0x10;\n                  local_120 = (undefined8 *)((ulong)(puVar15 + -0x11) & 0xfffffffffffffff0);\n                }\n                else {\n                  *(undefined8 *)(puVar16 + -8) = 0x1be813;\n                  local_120 = (undefined8 *)sh_malloc(0x10,\"glob.c\",0x3a5);\n                  if (puVar17 == (undefined8 *)0x0) {\n                    puVar17 = local_120;\n                  }\n                }\n                *(undefined8 *)(puVar16 + -8) = 0x1be761;\n                sVar8 = strlen(pcVar4);\n                *(undefined8 *)(puVar16 + -8) = 0x1be772;\n                puVar5 = (undefined8 *)sh_malloc(sVar8 + 1,\"glob.c\",0x3aa);\n                puVar19 = local_f8;\n                if ((local_120 == (undefined8 *)0x0) || (puVar5 == (undefined8 *)0x0)) {\n                  if (puVar17 != (undefined8 *)0x0) {\n                    if (local_120 == puVar17) {\n                      puVar17 = (undefined8 *)0x0;\n                    }\n                    else if (local_120 == (undefined8 *)0x0) goto LAB_001be977;\n                    *(undefined8 *)(puVar16 + -8) = 0x1be9bb;\n                    local_e0 = puVar5;\n                    sh_xfree(local_120,\"glob.c\",0x3b7);\n                    puVar5 = local_e0;\n                  }\nLAB_001be977:\n                  if (puVar5 != (undefined8 *)0x0) {\n                    *(undefined8 *)(puVar16 + -8) = 0x1be990;\n                    sh_xfree(puVar5,\"glob.c\",0x3b9);\n                  }\n                  goto LAB_001be5d4;\n                }\n                local_120[1] = puVar5;\n                *local_120 = local_f8;\n                local_f8 = local_120;\n                *(undefined8 *)(puVar16 + -8) = 0x1be7b2;\n                local_120 = puVar5;\n                sVar8 = strlen(pcVar4);\n                *(undefined8 *)(puVar16 + -8) = 0x1be7c5;\n                memmove(local_120,pcVar4,sVar8 + 1);\n                local_e8 = CONCAT44(local_e8._4_4_,(int)local_e8 + 1);\n              }\n              goto LAB_001be128;\n            }\n            if (local_124 == 0) {\n              *(undefined8 *)(puVar16 + -8) = 0x1be20f;\n              plVar11 = (long *)glob_vector(param_1,local_108,(uint)local_f0 & 0xfffffdff);\n              if (plVar11 != (long *)0x0) {\n                lVar18 = 0;\n                puVar5 = (undefined8 *)0x0;\n                puVar6 = (undefined8 *)0x0;\n                pcVar4 = param_1;\n                if (*plVar11 != 0) {\nLAB_001be27d:\n                  local_120 = puVar9;\n                  local_130 = puVar17;\n                  local_138 = pcVar4;\n                  *(undefined8 *)(puVar16 + -8) = 0x1be292;\n                  puVar12 = (undefined8 *)sh_malloc(0x10,\"glob.c\",0x271);\n                  puVar19 = local_f8;\n                  puVar9 = local_120;\n                  puVar17 = local_130;\n                  param_1 = local_138;\n                  if (puVar12 != (undefined8 *)0x0) goto LAB_001be258;\n                  if (puVar5 != (undefined8 *)0x0) {\n                    local_e0 = local_120;\n                    do {\n                      puVar6 = (undefined8 *)*puVar5;\n                      *(undefined8 *)(puVar16 + -8) = 0x1be2db;\n                      sh_xfree(puVar5,\"glob.c\",0x277);\n                      puVar9 = local_e0;\n                      puVar5 = puVar6;\n                    } while (puVar6 != (undefined8 *)0x0);\n                  }\n                  *(undefined8 *)(puVar16 + -8) = 0x1be2fa;\n                  sh_xfree(plVar11,\"glob.c\",0x27b);\n                  goto LAB_001be2fa;\n                }\n                if (plVar11 != &glob_error_return) {\n                  *(undefined8 *)(puVar16 + -8) = 0x1be95c;\n                  sh_xfree(plVar11,\"glob.c\",0x26c);\n                }\n              }\n            }\n          }\n          else {\n            *(undefined8 *)(puVar16 + -8) = 0x1be1bc;\n            local_108 = (char *)sh_makepath(local_e0,pcVar4,local_110);\n            *(undefined8 *)(puVar16 + -8) = 0x1be1d1;\n            local_124 = FUN_001bd040(local_108,(ulong)local_f0 & 0xffffffff);\n            if (-1 < local_124) goto LAB_001be1df;\n            if (((ulong)local_f0 & 8) != 0) {\n              *(undefined8 *)(puVar16 + -8) = 0x1be7e5;\n              sh_xfree(local_108,\"glob.c\",0x365);\n              goto LAB_001be128;\n            }\n            if (((ulong)local_f0 & 0x10) == 0) goto LAB_001be49d;\n          }\n          *(undefined8 *)(puVar16 + -8) = 0x1be528;\n          local_120 = (undefined8 *)sh_malloc(0x10,\"glob.c\",0x380);\n          if (puVar17 == (undefined8 *)0x0) {\n            puVar17 = local_120;\n          }\n          goto LAB_001be532;\n        }\n        goto LAB_001be128;\n      }\n      goto LAB_001bdf55;\n    }\n    local_150 = 0x1bdfaf;\n    iVar2 = stat((char *)local_e0,&local_d8);\n    if ((iVar2 < 0) || ((local_d8.st_mode & 0xf000) != 0x4000)) goto LAB_001be318;\n    local_150 = 0x1bdfe0;\n    local_e8 = strlen((char *)local_e0);\n    local_150 = 0x1bdffc;\n    pcVar4 = (char *)sh_malloc((long)((int)local_e8 + 2 + (int)sVar8),\"glob.c\",0x2ed);\n    local_150 = 0x1be013;\n    __dest = (char *)sh_malloc((long)((int)sVar8 + 1),\"glob.c\",0x2ee);\n    if (pcVar4 != (char *)0x0) {\n      if (__dest != (char *)0x0) {\n        local_150 = 0x1be651;\n        strcpy(__dest,param_1);\n        local_150 = 0x1be656;\n        sVar8 = __ctype_get_mb_cur_max();\n        if (sVar8 < 2) {\n          local_150 = 0x1be92c;\n          udequote_pathname(__dest);\n        }\n        else {\n          local_150 = 0x1be668;\n          FUN_001bdca0();\n        }\n        local_150 = 0x1be677;\n        strcpy(pcVar4,(char *)local_e0);\n        pcVar4[(int)local_e8] = '/';\n        local_150 = 0x1be699;\n        strcpy(pcVar4 + ((int)local_e8 + 1),__dest);\n        local_150 = 0x1be6a4;\n        iVar2 = lstat(pcVar4,&local_d8);\n        if (iVar2 < 0) {\n          puVar19 = (undefined8 *)0x0;\n          local_150 = 0x1be908;\n          sh_xfree(pcVar4,\"glob.c\",0x311);\n          local_150 = 0x1be918;\n          sh_xfree(__dest,\"glob.c\",0x312);\n          local_e8 = local_e8 & 0xffffffff00000000;\n          puVar16 = auStack_148;\n        }\n        else {\n          local_150 = 0x1be6bc;\n          sh_xfree(pcVar4,\"glob.c\",0x300);\n          local_e8 = CONCAT44(local_e8._4_4_,1);\n          puVar19 = &local_160;\n          local_160 = 0;\n          puVar16 = auStack_168;\n          local_158 = __dest;\n        }\n        puVar17 = (undefined8 *)0x0;\nLAB_001be704:\n        uVar3 = (int)local_e8 + 1;\n        *(undefined8 *)(puVar16 + -8) = 0x1be71e;\n        puVar5 = (undefined8 *)sh_malloc((ulong)uVar3 << 3,\"glob.c\",0x3e5);\n        puVar14 = puVar16;\n        if (puVar5 != (undefined8 *)0x0) goto LAB_001bdec9;\n        goto LAB_001be400;\n      }\n      if (pcVar4 != (char *)0x0) {\n        local_150 = 0x1be039;\n        sh_xfree(pcVar4,\"glob.c\",0x2f1);\n      }\n    }\n    puVar15 = auStack_148;\n    if (__dest != (char *)0x0) {\n      local_150 = 0x1be04e;\n      sh_xfree(__dest,\"glob.c\",0x2f2);\n      puVar15 = auStack_148;\n    }\n  }\n  goto LAB_001be050;\nLAB_001be258:\n  lVar1 = plVar11[lVar18];\n  *puVar12 = puVar5;\n  if (puVar6 == (undefined8 *)0x0) {\n    puVar6 = puVar12;\n  }\n  puVar12[1] = lVar1;\n  iVar2 = (int)lVar18;\n  lVar18 = lVar18 + 1;\n  puVar5 = puVar12;\n  pcVar4 = local_138;\n  if (plVar11[lVar18] == 0) goto LAB_001be822;\n  goto LAB_001be27d;\nLAB_001be822:\n  local_120 = (undefined8 *)CONCAT44(local_120._4_4_,iVar2 + 1);\n  *(undefined8 *)(puVar16 + -8) = 0x1be85a;\n  local_140 = puVar6;\n  sh_xfree(plVar11,\"glob.c\",0x28b);\n  puVar19 = local_f8;\n  if (puVar12 == (undefined8 *)&DAT_00248e70) goto LAB_001be2fa;\n  if (puVar17 == (undefined8 *)0x0) {\n    puVar17 = local_140;\n  }\n  local_e8 = CONCAT44(local_e8._4_4_,(int)local_e8 + (int)local_120);\n  *local_140 = local_f8;\n  *(undefined8 *)(puVar16 + -8) = 0x1be8a0;\n  local_120 = (undefined8 *)sh_malloc(0x10,\"glob.c\",0x380);\n  local_f8 = puVar12;\nLAB_001be532:\n  *(undefined8 *)(puVar16 + -8) = 0x1be545;\n  sVar8 = strlen(local_108);\n  sVar8 = (size_t)((int)sVar8 + 1);\n  *(undefined8 *)(puVar16 + -8) = 0x1be55c;\n  puVar5 = (undefined8 *)sh_malloc(sVar8,\"glob.c\",900);\n  puVar19 = local_f8;\n  pcVar4 = local_108;\n  if ((local_120 != (undefined8 *)0x0) && (puVar5 != (undefined8 *)0x0)) {\n    local_120[1] = puVar5;\n    local_f8 = local_120;\n    *local_120 = puVar19;\n    *(undefined8 *)(puVar16 + -8) = 0x1be8d9;\n    memmove(puVar5,local_108,sVar8);\n    *(undefined8 *)(puVar16 + -8) = 0x1be8e9;\n    sh_xfree(pcVar4,\"glob.c\",0x394);\n    local_e8 = CONCAT44(local_e8._4_4_,(int)local_e8 + 1);\n    goto LAB_001be128;\n  }\n  if ((puVar17 == (undefined8 *)0x0) || (puVar17 != local_120)) {\n    if (local_120 == (undefined8 *)0x0) goto LAB_001be5ab;\n  }\n  else {\n    puVar17 = (undefined8 *)0x0;\n  }\n  *(undefined8 *)(puVar16 + -8) = 0x1be5a4;\n  local_e0 = puVar5;\n  sh_xfree(local_120,\"glob.c\",0x38a);\n  puVar5 = local_e0;\nLAB_001be5ab:\n  if (puVar5 != (undefined8 *)0x0) {\n    *(undefined8 *)(puVar16 + -8) = 0x1be5c0;\n    sh_xfree(puVar5,\"glob.c\",0x38b);\n  }\n  *(undefined8 *)(puVar16 + -8) = 0x1be5d4;\n  sh_xfree(local_108,\"glob.c\",0x38c);\n  goto LAB_001be5d4;\nLAB_001be458:\n  do {\n    uVar13 = puVar19[1];\n    *(undefined8 *)(puVar16 + -8) = 0x1be469;\n    sh_xfree(uVar13,\"glob.c\",0x3fc);\n    puVar19 = (undefined8 *)*puVar19;\n  } while (puVar19 != (undefined8 *)0x0);\n  goto LAB_001be050;\nLAB_001be2fa:\n  *(undefined8 *)(puVar16 + -8) = 0x1be30e;\n  sh_xfree(local_108,\"glob.c\",0x371);\nLAB_001be5d4:\n  *(undefined8 *)(puVar16 + -8) = 0x1be5dc;\n  closedir((DIR *)puVar9);\nLAB_001be400:\n  puVar15 = puVar16;\n  if (puVar19 != (undefined8 *)0x0) goto LAB_001be410;\nLAB_001be050:\n  puVar5 = (undefined8 *)0x0;\nLAB_001bdf55:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  *(undefined8 *)(puVar15 + -8) = 0x1be9c9;\n  __stack_chk_fail();\n}\n\n",
  "logout_builtin": "\nundefined8 logout_builtin(long param_1)\n\n{\n  char *__s1;\n  int iVar1;\n  undefined8 uVar2;\n  \n  if (((param_1 != 0) && (*(char ***)(param_1 + 8) != (char **)0x0)) &&\n     (__s1 = **(char ***)(param_1 + 8), *__s1 == '-')) {\n    iVar1 = strcmp(__s1,\"--help\");\n    if (iVar1 == 0) {\n      builtin_help();\n      return 0x102;\n    }\n  }\n  if (login_shell == 0) {\n    builtin_error(\"not login shell: use `exit\\'\");\n    return 1;\n  }\n  uVar2 = FUN_001a9d90(param_1);\n  return uVar2;\n}\n\n",
  "FUN_001bfde0": "\nbool FUN_001bfde0(int param_1,char *param_2,char *param_3,char *param_4,char *param_5,uint param_6)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  char *pcVar4;\n  char *pcVar5;\n  uint uVar6;\n  char *pcVar7;\n  char *pcVar8;\n  char *local_50;\n  char *local_48;\n  \n  if ((param_4 + (*param_4 == '(') != param_5) &&\n     (pcVar4 = (char *)FUN_001bfab0(param_4 + (*param_4 == '('),param_5,0), pcVar4 != (char *)0x0))\n  {\n    if (param_1 < 0x2c) {\n      if (param_1 < 0x2a) {\n        if ((param_1 == 0x21) && (param_2 <= param_3)) {\n          pcVar7 = param_2;\n          do {\n            pcVar8 = param_4 + 1;\n            do {\n              while (pcVar8 == param_5) {\n                if ((pcVar8 != (char *)0x0 && param_2 != (char *)0x0) &&\n                   (iVar3 = FUN_001c0390(param_2,pcVar7,param_5,0xffffffffffffffff,0,param_6),\n                   iVar3 == 0)) goto LAB_001c00eb;\n                pcVar8 = (char *)0x0;\n              }\n              pcVar5 = (char *)FUN_001bfab0(pcVar8,param_5,0x7c);\n              if ((pcVar8 != (char *)0x0 && param_2 != (char *)0x0) &&\n                 (iVar3 = FUN_001c0390(param_2,pcVar7,pcVar8,pcVar5 + -1,0,param_6), iVar3 == 0))\n              goto LAB_001c00eb;\n              pcVar8 = pcVar5;\n            } while (pcVar4 != pcVar5);\n            if ((param_6 & 4) == 0) {\n              if (((param_6 & 0x80) != 0) && (*param_2 == '.')) {\n                cVar2 = param_2[1];\n                if (cVar2 == '\\0') {\n                  return true;\n                }\n                if ((cVar2 == '.') && (param_2[2] == '\\0')) {\n                  return true;\n                }\n                if (((param_6 & 1) != 0) && (param_2[-1] == '/')) {\n                  if (cVar2 == '/') {\n                    return true;\n                  }\n                  if (cVar2 == '\\0') {\n                    return true;\n                  }\n                  if (cVar2 == '.') {\n                    if (param_2[2] == '/') {\n                      return true;\n                    }\n                    if (param_2[2] == '\\0') {\n                      return true;\n                    }\n                  }\n                }\n              }\n            }\n            else if (*param_2 == '.') {\n              return true;\n            }\n            uVar6 = param_6 & 0xffffff7b;\n            if (pcVar7 <= param_2) {\n              uVar6 = param_6;\n            }\n            if ((pcVar7 != (char *)0x0) &&\n               (iVar3 = FUN_001c0390(pcVar7,param_3,pcVar5,param_5,0,uVar6), iVar3 == 0)) {\n              return false;\n            }\nLAB_001c00eb:\n            pcVar7 = pcVar7 + 1;\n          } while (pcVar7 <= param_3);\n        }\n      }\n      else {\n        if (((param_1 == 0x2a) && (param_2 != (char *)0x0)) &&\n           (iVar3 = FUN_001c0390(param_2,param_3,pcVar4,param_5,0,param_6), iVar3 == 0)) {\n          return false;\n        }\n        local_50._0_4_ = param_6 & 0xffffff7b;\n        local_48 = param_4 + 1;\nLAB_001c0124:\n        do {\n          pcVar7 = local_48;\n          if (pcVar7 == param_5) {\n            local_48 = (char *)0x0;\n            pcVar8 = &DAT_ffffffffffffffff;\n            if (param_3 < param_2) goto LAB_001c0124;\nLAB_001c0151:\n            pcVar5 = param_2;\n            do {\n              if ((pcVar7 != (char *)0x0 && param_2 != (char *)0x0) &&\n                 (iVar3 = FUN_001c0390(param_2,pcVar5,pcVar7,pcVar8,0,param_6), iVar3 == 0)) {\n                uVar6 = (uint)local_50;\n                if (pcVar5 <= param_2) {\n                  uVar6 = param_6;\n                }\n                if (pcVar5 != (char *)0x0) {\n                  iVar3 = FUN_001c0390(pcVar5,param_3,pcVar4,param_5,0);\n                  if (iVar3 == 0) {\n                    return false;\n                  }\n                  if ((param_2 != pcVar5) &&\n                     (iVar3 = FUN_001c0390(pcVar5,param_3,param_4 + -1,param_5,0,uVar6), iVar3 == 0)\n                     ) {\n                    return false;\n                  }\n                }\n              }\n              pcVar5 = pcVar5 + 1;\n            } while (pcVar5 <= param_3);\n          }\n          else {\n            local_48 = (char *)FUN_001bfab0(pcVar7,param_5,0x7c);\n            if (param_2 <= param_3) {\n              pcVar8 = local_48 + -1;\n              goto LAB_001c0151;\n            }\n          }\n        } while (pcVar4 != local_48);\n      }\n    }\n    else if (param_1 - 0x3fU < 2) {\n      if (((param_1 == 0x3f) && (param_2 != (char *)0x0)) &&\n         (iVar3 = FUN_001c0390(param_2,param_3,pcVar4,param_5,0,param_6), iVar3 == 0)) {\n        return false;\n      }\n      param_4 = param_4 + 1;\n      pcVar7 = param_3;\n      if (param_5 != pcVar4) {\n        pcVar7 = param_2;\n      }\n      do {\n        if (param_4 == param_5) {\n          local_50 = (char *)0x0;\n        }\n        else {\n          local_50 = (char *)FUN_001bfab0(param_4,param_5,0x7c);\n        }\n        if ((param_5 == pcVar4) || (param_2 <= param_3)) {\n          pcVar8 = pcVar7;\n          do {\n            uVar6 = param_6 & 0xffffff7b;\n            if (pcVar8 <= param_2) {\n              uVar6 = param_6;\n            }\n            if (((param_2 != (char *)0x0 && param_4 != (char *)0x0) &&\n                (iVar3 = FUN_001c0390(param_2,pcVar8,param_4,local_50 + -1,0,param_6), iVar3 == 0))\n               && ((pcVar8 != (char *)0x0 &&\n                   (iVar3 = FUN_001c0390(pcVar8,param_3,pcVar4,param_5,0,uVar6), iVar3 == 0)))) {\n              return false;\n            }\n            pcVar8 = pcVar8 + 1;\n          } while (pcVar8 <= param_3);\n        }\n        param_4 = local_50;\n      } while (pcVar4 != local_50);\n    }\n    return true;\n  }\n  param_4 = param_4 + -1;\n  if ((int)param_5 - (int)param_4 != (int)param_3 - (int)param_2) {\n    return true;\n  }\n  cVar2 = *param_5;\n  cVar1 = *param_3;\n  if (cVar2 == '\\0') {\n    if (cVar1 == '\\0') {\n      iVar3 = strcoll(param_4,param_2);\n      goto LAB_001c0316;\n    }\n    *param_3 = '\\0';\n    iVar3 = strcoll(param_4,param_2);\n  }\n  else {\n    *param_5 = '\\0';\n    if (cVar1 == '\\0') {\n      iVar3 = strcoll(param_4,param_2);\n      *param_5 = cVar2;\n      goto LAB_001c0316;\n    }\n    *param_3 = '\\0';\n    iVar3 = strcoll(param_4,param_2);\n    *param_5 = cVar2;\n  }\n  *param_3 = cVar1;\nLAB_001c0316:\n  return iVar3 != 0;\n}\n\n",
  "FUN_00167220": "\nbyte * FUN_00167220(byte *param_1,int param_2)\n\n{\n  char *pcVar1;\n  bool bVar2;\n  bool bVar3;\n  mbstate_t mVar4;\n  byte bVar5;\n  size_t sVar6;\n  byte *pbVar7;\n  size_t sVar8;\n  char cVar9;\n  char *pcVar10;\n  size_t sVar11;\n  byte *__s;\n  byte *pbVar12;\n  byte *pbVar13;\n  byte bVar14;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar6 = strlen((char *)param_1);\n  if (ifs_value == (char *)0x0) {\n    bVar3 = false;\n    bVar14 = 0;\n    bVar2 = false;\n  }\n  else if (*ifs_value == '\\0') {\n    bVar3 = true;\n    bVar14 = 0;\n    bVar2 = false;\n  }\n  else {\n    bVar14 = 0;\n    bVar2 = false;\n    cVar9 = *ifs_value;\n    pcVar10 = ifs_value;\n    while (cVar9 != '\\0') {\n      if (param_2 == 0) {\n        if (cVar9 == '\\x01') {\n          bVar2 = true;\n        }\n        bVar14 = bVar14 | cVar9 == '\\x7f';\n      }\n      pcVar1 = pcVar10 + 1;\n      pcVar10 = pcVar10 + 1;\n      cVar9 = *pcVar1;\n    }\n    bVar3 = false;\n  }\n  pbVar7 = (byte *)sh_xmalloc(sVar6 * 2 + 1,\"subst.c\",0x1254);\n  bVar5 = *param_1;\n  pbVar12 = pbVar7;\n  if (bVar5 != 0) {\n    __s = param_1;\n    do {\n      while( true ) {\n        mVar4 = local_48;\n        if ((((bVar5 == 1) && (!bVar2)) || ((bVar5 == 0x7f && ((bool)(bVar14 ^ 1))))) ||\n           ((pbVar13 = pbVar12, bVar5 == 0x20 && (bVar3)))) {\n          *pbVar12 = 1;\n          pbVar13 = pbVar12 + 1;\n        }\n        bVar5 = *__s;\n        pbVar12 = pbVar13 + 1;\n        if (locale_mb_cur_max < 2) break;\n        if (((*(uint *)(is_basic_table + (ulong)(bVar5 >> 5) * 4) >> (bVar5 & 0x1f) & 1) == 0) &&\n           ((locale_utf8locale == 0 || ((char)bVar5 < '\\0')))) {\n          sVar8 = mbrtowc((wchar_t *)0x0,(char *)__s,(size_t)(param_1 + (sVar6 - (long)__s)),\n                          &local_48);\n          if (0xfffffffffffffffd < sVar8) {\n            *pbVar13 = *__s;\n            goto LAB_001672c9;\n          }\n          sVar11 = 1;\n          if (sVar8 != 0) {\n            sVar11 = sVar8;\n          }\n          sVar8 = 0;\n          bVar5 = *__s;\n          while( true ) {\n            pbVar13[sVar8] = bVar5;\n            sVar8 = sVar8 + 1;\n            if (sVar11 == sVar8) break;\n            bVar5 = __s[sVar8];\n          }\n        }\n        else {\n          *pbVar13 = bVar5;\n          sVar8 = 1;\n        }\n        pbVar12 = pbVar13 + sVar8;\n        bVar5 = __s[sVar8];\n        __s = __s + sVar8;\n        if (bVar5 == 0) goto LAB_00167350;\n      }\n      *pbVar13 = bVar5;\nLAB_001672c9:\n      bVar5 = __s[1];\n      __s = __s + 1;\n      local_48 = mVar4;\n    } while (bVar5 != 0);\n  }\nLAB_00167350:\n  *pbVar12 = 0;\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pbVar7;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_vi_tilde_expand": "\nundefined8 rl_vi_tilde_expand(undefined8 param_1,undefined4 param_2)\n\n{\n  rl_tilde_expand(0);\n  DAT_0023b36c = 1;\n  DAT_0023b368 = rl_arg_sign;\n  _rl_vi_last_command = param_2;\n  rl_begin_undo_group();\n  DAT_0024a3c8 = param_2;\n  _rl_keymap = &vi_insertion_keymap;\n  if (_rl_show_mode_in_prompt == 0) {\n    return 0;\n  }\n  _rl_reset_prompt();\n  return 0;\n}\n\n",
  "FUN_00141070": "\nvoid FUN_00141070(void)\n\n{\n  int iVar1;\n  uint uVar2;\n  int *piVar3;\n  long lVar4;\n  int *piVar5;\n  int iVar6;\n  int iVar7;\n  \n  if (DAT_00240e80 == 0) {\n    DAT_00240e80 = getmaxgroups();\n  }\n  DAT_00240e84 = 0;\n  piVar3 = (int *)sh_xrealloc(DAT_00240e78,(long)DAT_00240e80 * 4,\"general.c\",0x4e3);\n  iVar1 = DAT_00240e80;\n  DAT_00240e78 = piVar3;\n  uVar2 = __getgroups_chk(DAT_00240e80,piVar3,0xffffffffffffffff);\n  iVar7 = DAT_00238048;\n  if (uVar2 == 0) {\n    uVar2 = 1;\n    DAT_00240e84 = 1;\n    *piVar3 = DAT_00238048;\n  }\n  else {\n    iVar7 = *piVar3;\n    DAT_00240e84 = uVar2;\n    if ((int)uVar2 < 1) {\n      return;\n    }\n  }\n  lVar4 = 1;\n  iVar6 = iVar7;\n  do {\n    if (DAT_00238048 == iVar6) {\nLAB_00141117:\n      if ((iVar7 != iVar6) && (0 < (int)DAT_00240e84)) {\n        piVar5 = piVar3;\n        do {\n          piVar5 = piVar5 + 1;\n          if (piVar3 + DAT_00240e84 == piVar5) {\n            return;\n          }\n        } while (*piVar5 != iVar6);\n        *piVar5 = iVar7;\n        *piVar3 = DAT_00238048;\n      }\n      return;\n    }\n    if ((int)uVar2 <= (int)(uint)lVar4) {\n      iVar6 = DAT_00238048;\n      if (((int)uVar2 < iVar1) && ((uint)lVar4 == uVar2)) {\n        lVar4 = (long)(int)uVar2;\n        memmove(piVar3 + (lVar4 - (int)(uVar2 - 1)),piVar3 + ((lVar4 + -1) - (long)(int)(uVar2 - 1))\n                ,lVar4 * 4);\n        DAT_00240e84 = uVar2 + 1;\n        *piVar3 = DAT_00238048;\n        return;\n      }\n      goto LAB_00141117;\n    }\n    iVar6 = piVar3[lVar4];\n    lVar4 = lVar4 + 1;\n  } while( true );\n}\n\n",
  "array_shift": "\nlong * array_shift(undefined8 *param_1,int param_2,uint param_3)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  undefined8 *puVar4;\n  long *plVar5;\n  long *plVar6;\n  int iVar7;\n  \n  if (((param_1 != (undefined8 *)0x0) && (lVar1 = param_1[1], 0 < param_2)) && (lVar1 != 0)) {\n    param_1[3] = 0;\n    plVar2 = (long *)param_1[2];\n    plVar3 = (long *)plVar2[2];\n    if (plVar2 == plVar3) {\nLAB_001887d8:\n      plVar6 = plVar3;\n      if ((param_3 & 1) == 0) {\n        do {\n          plVar5 = plVar6;\n          plVar6 = (long *)plVar5[2];\n        } while (plVar2 != plVar6);\n        plVar5[2] = 0;\n        plVar2[3] = (long)plVar2;\n        plVar2[2] = (long)plVar2;\n        *param_1 = 0xffffffffffffffff;\n        param_1[1] = 0;\n        return plVar3;\n      }\n      array_flush(param_1);\n    }\n    else {\n      iVar7 = 0;\n      plVar6 = plVar3;\n      do {\n        plVar6 = (long *)plVar6[2];\n        iVar7 = iVar7 + 1;\n        if (plVar2 == plVar6) goto LAB_001887d8;\n      } while (iVar7 < param_2);\n      *(undefined8 *)(plVar6[3] + 0x10) = 0;\n      plVar2[2] = (long)plVar6;\n      plVar6[3] = (long)plVar2;\n      do {\n        *plVar6 = *plVar6 - (long)param_2;\n        plVar6 = (long *)plVar6[2];\n      } while (plVar2 != plVar6);\n      puVar4 = (undefined8 *)plVar2[3];\n      param_1[1] = lVar1 - param_2;\n      *param_1 = *puVar4;\n      if ((param_3 & 1) == 0) {\n        return plVar3;\n      }\n      while (plVar3 != (long *)0x0) {\n        plVar2 = (long *)plVar3[2];\n        if (plVar3[1] != 0) {\n          sh_xfree(plVar3[1],\"array.c\",0x21e);\n        }\n        sh_xfree(plVar3,\"array.c\",0x21f);\n        plVar3 = plVar2;\n      }\n    }\n  }\n  return (long *)0x0;\n}\n\n",
  "shopt_builtin": "\nundefined8 shopt_builtin(undefined8 param_1)\n\n{\n  char cVar1;\n  bool bVar2;\n  bool bVar3;\n  undefined4 uVar4;\n  char cVar5;\n  int iVar6;\n  uint uVar7;\n  int iVar8;\n  undefined8 uVar9;\n  uint *puVar10;\n  int *piVar11;\n  char *pcVar12;\n  undefined *puVar13;\n  uint uVar14;\n  char *pcVar15;\n  undefined *puVar16;\n  undefined **ppuVar17;\n  long **pplVar18;\n  undefined4 local_3c;\n  \n  uVar14 = 0;\n  bVar3 = false;\n  bVar2 = false;\n  reset_internal_getopt();\nLAB_001b79aa:\n  iVar6 = internal_getopt(param_1,\"psuoq\");\n  if (iVar6 != -1) {\n    do {\n      if (iVar6 == -99) {\n        builtin_help();\n        return 0x102;\n      }\n      switch(iVar6) {\n      case 0x6f:\n        goto switchD_001b79d7_caseD_6f;\n      case 0x70:\n        bVar3 = true;\n        goto LAB_001b79aa;\n      case 0x71:\n        bVar2 = true;\n        goto LAB_001b79aa;\n      default:\n        builtin_usage();\n        return 0x102;\n      case 0x73:\n        uVar14 = uVar14 | 1;\n        goto LAB_001b79aa;\n      case 0x75:\n        uVar14 = uVar14 | 2;\n        iVar6 = internal_getopt(param_1,\"psuoq\");\n        if (iVar6 == -1) goto LAB_001b79f8;\n      }\n    } while( true );\n  }\nLAB_001b79f8:\n  uVar7 = uVar14 & 3;\n  if (uVar7 == 3) {\n    builtin_error(\"cannot set and unset shell options simultaneously\");\n    return 1;\n  }\n  if (uVar14 == 8) {\n    local_3c = 0;\n    pplVar18 = loptend;\n    if (loptend != (long **)0x0) {\n      do {\n        iVar6 = minus_o_option_value(*pplVar18[1]);\n        if (iVar6 == -1) {\n          local_3c = 1;\n          sh_invalidoptname(*pplVar18[1]);\n        }\n        else {\n          if (iVar6 == 0) {\n            local_3c = 1;\n          }\n          if (!bVar2) {\n            if (bVar3 == false) {\n              pcVar12 = \"off\";\n              if (iVar6 != 0) {\n                pcVar12 = \"on\";\n              }\n              __printf_chk(1,\"%-15s\\t%s\\n\",*pplVar18[1],pcVar12);\n            }\n            else {\n              __printf_chk(1,\"set %co %s\\n\",(-(uint)(iVar6 == 0) & 0xfffffffe) + 0x2d,*pplVar18[1]);\n            }\n          }\n        }\n        pplVar18 = (long **)*pplVar18;\n      } while (pplVar18 != (long **)0x0);\n      goto LAB_001b7ad7;\n    }\n    if (!bVar2) {\n      list_minus_o_opts(0xffffffff,(ulong)bVar3 << 4);\n      local_3c = 0;\n      goto LAB_001b7ad7;\n    }\n  }\n  else {\n    if (loptend != (long **)0x0) {\n      if ((uVar14 & 8) != 0) {\n        uVar9 = 0;\n        pplVar18 = loptend;\n        do {\n          iVar6 = set_minus_o_option((-(uint)((uVar14 & 1) == 0) & 0xfffffffe) + 0x2d,*pplVar18[1]);\n          pplVar18 = (long **)*pplVar18;\n          if (iVar6 == 1) {\n            uVar9 = 1;\n          }\n        } while (pplVar18 != (long **)0x0);\n        set_shellopts();\n        return uVar9;\n      }\n      if (uVar7 != 0) {\n        uVar9 = FUN_001b7830(uVar14 & 1,loptend);\n        return uVar9;\n      }\n      local_3c = 0;\n      pplVar18 = loptend;\n      do {\n        ppuVar17 = &PTR_s_assoc_expand_once_00236438;\n        iVar6 = 0;\n        pcVar15 = \"autocd\";\n        pcVar12 = (char *)*pplVar18[1];\n        cVar5 = 'a';\n        cVar1 = *pcVar12;\n        while( true ) {\n          if ((cVar1 == cVar5) && (iVar8 = strcmp(pcVar12,pcVar15), iVar8 == 0)) {\n            iVar6 = *(int *)(&PTR_autocd_00236428)[(long)iVar6 * 3];\n            uVar4 = 1;\n            if (iVar6 != 0) {\n              uVar4 = local_3c;\n            }\n            local_3c = uVar4;\n            if (!bVar2) {\n              if (bVar3) {\n                puVar13 = &DAT_00210a43;\n                if (iVar6 == 0) {\n                  puVar13 = &DAT_00210a46;\n                }\n                __printf_chk(1,\"shopt %s %s\\n\",puVar13,pcVar12);\n              }\n              else {\n                pcVar15 = \"off\";\n                if (iVar6 != 0) {\n                  pcVar15 = \"on\";\n                }\n                __printf_chk(1,\"%-15s\\t%s\\n\",pcVar12,pcVar15);\n              }\n            }\n            goto LAB_001b7ac7;\n          }\n          pcVar15 = *ppuVar17;\n          ppuVar17 = ppuVar17 + 3;\n          iVar6 = iVar6 + 1;\n          if (pcVar15 == (char *)0x0) break;\n          cVar5 = *pcVar15;\n        }\n        builtin_error(\"%s: invalid shell option name\",pcVar12);\n        local_3c = 1;\nLAB_001b7ac7:\n        pplVar18 = (long **)*pplVar18;\n      } while (pplVar18 != (long **)0x0);\n      goto LAB_001b7ad7;\n    }\n    if ((uVar14 & 8) == 0) {\n      if (uVar7 != 0) {\n        puVar10 = &autocd;\n        puVar13 = &DAT_00210a30;\n        ppuVar17 = &PTR_s_assoc_expand_once_00236438;\n        while( true ) {\n          uVar7 = *puVar10;\n          if (((uVar14 & 1) == uVar7) && (!bVar2)) {\n            if (bVar3 == false) {\n              pcVar12 = \"off\";\n              if (uVar7 != 0) {\n                pcVar12 = \"on\";\n              }\n              __printf_chk(1,\"%-15s\\t%s\\n\",puVar13,pcVar12);\n            }\n            else {\n              puVar16 = &DAT_00210a46;\n              if (uVar7 != 0) {\n                puVar16 = &DAT_00210a43;\n              }\n              __printf_chk(1,\"shopt %s %s\\n\",puVar16,puVar13);\n            }\n          }\n          puVar13 = *ppuVar17;\n          if (puVar13 == (undefined *)0x0) break;\n          puVar10 = (uint *)ppuVar17[1];\n          ppuVar17 = ppuVar17 + 3;\n        }\n        local_3c = 0;\n        goto LAB_001b7ad7;\n      }\n      piVar11 = &autocd;\n      puVar13 = &DAT_00210a30;\n      ppuVar17 = &PTR_s_assoc_expand_once_00236438;\n      while( true ) {\n        if (!bVar2) {\n          if (bVar3 == false) {\n            pcVar12 = \"off\";\n            if (*piVar11 != 0) {\n              pcVar12 = \"on\";\n            }\n            __printf_chk(1,\"%-15s\\t%s\\n\",puVar13,pcVar12);\n          }\n          else {\n            puVar16 = &DAT_00210a46;\n            if (*piVar11 != 0) {\n              puVar16 = &DAT_00210a43;\n            }\n            __printf_chk(1,\"shopt %s %s\\n\",puVar16,puVar13);\n          }\n        }\n        puVar13 = *ppuVar17;\n        if (puVar13 == (undefined *)0x0) break;\n        piVar11 = (int *)ppuVar17[1];\n        ppuVar17 = ppuVar17 + 3;\n      }\n    }\n    else if (!bVar2) {\n      list_minus_o_opts(uVar14 & 1,(ulong)bVar3 << 4);\n      local_3c = 0;\n      goto LAB_001b7ad7;\n    }\n  }\n  local_3c = 0;\nLAB_001b7ad7:\n  uVar9 = sh_chkwrite(local_3c);\n  return uVar9;\nswitchD_001b79d7_caseD_6f:\n  uVar14 = uVar14 | 8;\n  goto LAB_001b79aa;\n}\n\n",
  "get_numeric_arg": "\nundefined8 get_numeric_arg(long *param_1,int param_2,undefined8 *param_3)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  char *pcVar3;\n  \n  if (param_3 != (undefined8 *)0x0) {\n    *param_3 = 1;\n  }\n  if (param_1 == (long *)0x0) {\n    return 1;\n  }\n  pcVar3 = *(char **)param_1[1];\n  if (((*pcVar3 == '-') && (pcVar3[1] == '-')) && (pcVar3[2] == '\\0')) {\n    param_1 = (long *)*param_1;\n    if (param_1 == (long *)0x0) {\n      return 1;\n    }\n    pcVar3 = *(char **)param_1[1];\n    if (pcVar3 != (char *)0x0) goto LAB_001a448c;\nLAB_001a44f8:\n    puVar2 = &DAT_0020f367;\nLAB_001a44a4:\n    builtin_error(\"%s: numeric argument required\",puVar2);\n    if (param_2 == 0) {\n      return 0;\n    }\n    if (param_2 != 1) goto LAB_001a4516;\n    throw_to_top_level();\n  }\n  else {\nLAB_001a448c:\n    iVar1 = legal_number(pcVar3,param_3);\n    if (iVar1 == 0) {\n      puVar2 = *(undefined **)param_1[1];\n      if (puVar2 == (undefined *)0x0) goto LAB_001a44f8;\n      goto LAB_001a44a4;\n    }\n  }\n  if (*param_1 == 0) {\n    return 1;\n  }\n  FUN_001a3b30();\nLAB_001a4516:\n  top_level_cleanup();\n                    /* WARNING: Subroutine does not return */\n  jump_to_top_level(2);\n}\n\n",
  "set_signal": "\nvoid set_signal(ulong param_1,char *param_2)\n\n{\n  uint uVar1;\n  size_t sVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  long lVar5;\n  ulong uVar6;\n  int iVar7;\n  long in_FS_OFFSET;\n  sigset_t sStack_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  iVar7 = (int)param_1;\n  uVar6 = param_1 & 0xffffffff;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((iVar7 == 0) || (iVar7 == 0x41)) {\n    sVar2 = strlen(param_2);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"trap.c\",0x31a);\n    pcVar3 = strcpy(pcVar3,param_2);\n    FUN_001815b0(uVar6,pcVar3);\n    if (((uint)uVar6 | interactive) == 0) {\n      if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n        initialize_terminating_signals();\n        return;\n      }\n      goto LAB_0018275b;\n    }\n  }\n  else {\n    if (iVar7 - 0x42U < 2) {\n      sVar2 = strlen(param_2);\n      uVar4 = 0x31a;\nLAB_00182651:\n      pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"trap.c\",uVar4);\n      pcVar3 = strcpy(pcVar3,param_2);\n      if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n        FUN_001815b0(uVar6,pcVar3);\n        return;\n      }\n      goto LAB_0018275b;\n    }\n    lVar5 = (long)iVar7;\n    uVar1 = (&DAT_00247e40)[lVar5];\n    if ((uVar1 & 2) == 0) {\n      if ((uVar1 & 1) == 0) {\n        if (*(code **)(original_signals + lVar5 * 8) == initialize_traps) {\n          uVar4 = set_signal_handler(param_1,0);\n          *(undefined8 *)(original_signals + lVar5 * 8) = uVar4;\n          set_signal_handler(uVar6,uVar4);\n          if (*(long *)(original_signals + lVar5 * 8) != 1) {\n            uVar1 = (&DAT_00247e40)[lVar5];\n            goto LAB_00182588;\n          }\n          (&DAT_00247e40)[lVar5] = (&DAT_00247e40)[lVar5] | 2;\n        }\n        else if (*(code **)(original_signals + lVar5 * 8) != (code *)0x1) goto LAB_00182588;\n      }\n      else {\nLAB_00182588:\n        if ((uVar1 & 8) != 0) {\n          sVar2 = strlen(param_2);\n          uVar4 = 0x33c;\n          goto LAB_00182651;\n        }\n        sigemptyset(&sStack_138);\n        sigaddset(&sStack_138,(uint)uVar6);\n        sigemptyset(&local_b8);\n        sigprocmask(0,&sStack_138,&local_b8);\n        sVar2 = strlen(param_2);\n        pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"trap.c\",0x337);\n        pcVar3 = strcpy(pcVar3,param_2);\n        FUN_001815b0(uVar6,pcVar3);\n        set_signal_handler(uVar6,trap_handler);\n        sigprocmask(2,&local_b8,(sigset_t *)0x0);\n      }\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\nLAB_0018275b:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "all_shell_variables": "\nvoid * all_shell_variables(void)\n\n{\n  int iVar1;\n  void *__base;\n  \n  __base = (void *)map_over(0,shell_variables);\n  if (__base != (void *)0x0) {\n    iVar1 = strvec_len(__base);\n    qsort(__base,(long)iVar1,8,FUN_001513a0);\n  }\n  return __base;\n}\n\n",
  "FUN_00180670": "\nvoid FUN_00180670(undefined8 param_1,char *param_2)\n\n{\n  char cVar1;\n  char *__s1;\n  long lVar2;\n  long lVar3;\n  int iVar4;\n  int iVar5;\n  char *pcVar6;\n  char **ppcVar7;\n  size_t sVar8;\n  long lVar9;\n  long lVar10;\n  long in_FS_OFFSET;\n  char *local_e0;\n  undefined local_d8 [48];\n  undefined8 local_a8;\n  undefined8 local_90;\n  undefined8 local_80;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar6 = (char *)full_pathname();\n  lVar2 = DAT_002478b8;\n  iVar5 = DAT_002478b0;\n  if (0 < DAT_002478b0) {\n    lVar10 = (long)DAT_002478b0;\n    cVar1 = *pcVar6;\n    lVar9 = 0;\n    do {\n      __s1 = **(char ***)(lVar2 + lVar9);\n      if (*__s1 == cVar1) {\n        iVar4 = strcmp(__s1,pcVar6);\n        if (iVar4 == 0) {\n          iVar5 = mailstat(pcVar6,local_d8);\n          if (iVar5 == 0) {\n            lVar2 = *(long *)(DAT_002478b8 + lVar9);\n            *(undefined8 *)(lVar2 + 0x10) = local_90;\n            *(undefined8 *)(lVar2 + 0x18) = local_80;\n            *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) | 1;\n            *(undefined8 *)(lVar2 + 0x20) = local_a8;\n          }\n          sh_xfree(pcVar6,\"mailcheck.c\",0xba);\n          goto LAB_0018081b;\n        }\n      }\n      lVar9 = lVar9 + 8;\n    } while (lVar10 * 8 != lVar9);\n  }\n  DAT_002478b0 = iVar5 + 1;\n  lVar9 = (long)DAT_002478b0 * 8;\n  DAT_002478b8 = sh_xrealloc(lVar2,lVar9,\"mailcheck.c\",0xbf);\n  lVar2 = DAT_002478b8 + -8;\n  ppcVar7 = (char **)sh_xmalloc(0x30,\"mailcheck.c\",0xd8);\n  *ppcVar7 = pcVar6;\n  local_e0 = param_2;\n  if (param_2 != (char *)0x0) {\n    sVar8 = strlen(param_2);\n    pcVar6 = (char *)sh_xmalloc(sVar8 + 1,\"mailcheck.c\",0xda);\n    local_e0 = strcpy(pcVar6,param_2);\n  }\n  lVar3 = DAT_002478b8;\n  *(undefined4 *)(ppcVar7 + 5) = 0;\n  ppcVar7[1] = local_e0;\n  lVar10 = DAT_002478a8;\n  *(char ***)(lVar2 + lVar9) = ppcVar7;\n  lVar2 = *(long *)(lVar3 + -8 + lVar9);\n  if (lVar10 == 0) {\n    lVar10 = shell_start_time;\n  }\n  *(undefined8 *)(lVar2 + 0x20) = 0;\n  *(long *)(lVar2 + 0x18) = lVar10;\n  *(long *)(lVar2 + 0x10) = lVar10;\n  *(undefined4 *)(lVar2 + 0x28) = 0;\nLAB_0018081b:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "signal_is_pending": "\nundefined4 signal_is_pending(int param_1)\n\n{\n  return *(undefined4 *)(pending_traps + (long)param_1 * 4);\n}\n\n",
  "progcomp_insert": "\nundefined8 progcomp_insert(char *param_1,int *param_2)\n\n{\n  int *piVar1;\n  long lVar2;\n  size_t sVar3;\n  char *pcVar4;\n  \n  if (param_2 == (int *)0x0) {\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"progcomp_insert: %s: NULL COMPSPEC\",param_1);\n  }\n  if (prog_completes == 0) {\n    prog_completes = hash_create(0x200);\n  }\n  lVar2 = prog_completes;\n  *param_2 = *param_2 + 1;\n  lVar2 = hash_insert(param_1,lVar2,0);\n  piVar1 = *(int **)(lVar2 + 0x10);\n  if (piVar1 != (int *)0x0) {\n    *piVar1 = *piVar1 + -1;\n    if (*piVar1 == 0) {\n      FUN_001a1120();\n    }\n    *(int **)(lVar2 + 0x10) = param_2;\n    return 1;\n  }\n  sVar3 = strlen(param_1);\n  pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"pcomplib.c\",0xc0);\n  pcVar4 = strcpy(pcVar4,param_1);\n  *(int **)(lVar2 + 0x10) = param_2;\n  *(char **)(lVar2 + 8) = pcVar4;\n  return 1;\n}\n\n",
  "_rl_reset_prompt": "\nvoid _rl_reset_prompt(void)\n\n{\n  rl_visible_prompt_length = rl_expand_prompt(rl_prompt);\n  return;\n}\n\n",
  "history_number": "\nint history_number(void)\n\n{\n  int iVar1;\n  \n  using_history();\n  iVar1 = 1;\n  if ((remember_on_history | enable_history_list) != 0) {\n    iVar1 = where_history();\n    iVar1 = iVar1 + history_base;\n  }\n  return iVar1;\n}\n\n",
  "_rl_ttyflush": "\nvoid _rl_ttyflush(void)\n\n{\n  fflush(rl_outstream);\n  return;\n}\n\n",
  "xrealloc": "\nvoid * xrealloc(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  if (DAT_00248a48 == 0) {\n    DAT_00248a50 = sbrk(0);\n    DAT_00248a48 = 1;\n  }\n  if (param_1 == (void *)0x0) {\n    pvVar1 = malloc(param_2);\n  }\n  else {\n    pvVar1 = realloc(param_1,param_2);\n  }\n  if (pvVar1 == (void *)0x0) {\n    FUN_001a1750(\"xrealloc\",param_2);\n  }\n  return pvVar1;\n}\n\n",
  "strlist_resize": "\nlong * strlist_resize(long *param_1,int param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  long *plVar3;\n  \n  if (param_1 == (long *)0x0) {\n    plVar3 = (long *)strlist_create(param_2);\n    return plVar3;\n  }\n  if (param_2 <= *(int *)(param_1 + 1)) {\n    return param_1;\n  }\n  lVar2 = strvec_resize(*param_1);\n  iVar1 = *(int *)(param_1 + 1);\n  *param_1 = lVar2;\n  if (iVar1 <= param_2) {\n    memset((void *)(lVar2 + (long)iVar1 * 8),0,(ulong)(uint)(param_2 - iVar1) * 8 + 8);\n  }\n  *(int *)(param_1 + 1) = param_2;\n  return param_1;\n}\n\n",
  "_rl_set_mark_at_pos": "\nundefined8 _rl_set_mark_at_pos(int param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = 1;\n  if ((-1 < param_1) && (param_1 <= rl_end)) {\n    uVar1 = 0;\n    rl_mark = param_1;\n  }\n  return uVar1;\n}\n\n",
  "FUN_001524b0": "\nlong FUN_001524b0(long param_1)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = get_urandom32();\n  uVar2 = itos(uVar1);\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x527);\n  }\n  *(undefined8 *)(param_1 + 8) = uVar2;\n  *(uint *)(param_1 + 0x28) = *(uint *)(param_1 + 0x28) | 0x10;\n  return param_1;\n}\n\n",
  "report_error": "\nvoid report_error(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  FUN_0015b0b0(1);\n  local_d0 = &stack0x00000008;\n  local_d8 = 8;\n  local_c8 = local_b8;\n  local_d4 = 0x30;\n  __vfprintf_chk(stderr,1,param_9,&local_d8);\n  fputc(10,stderr);\n  if (exit_immediately_on_error == 0) {\n    if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return;\n    }\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  if (last_command_exit_value == 0) {\n    last_command_exit_value = 1;\n  }\n                    /* WARNING: Subroutine does not return */\n  exit_shell(last_command_exit_value);\n}\n\n",
  "_rl_vi_reset_last": "\nvoid _rl_vi_reset_last(void)\n\n{\n  _rl_vi_last_command = 0x69;\n  DAT_0023b36c = 1;\n  DAT_0023b368 = 1;\n  DAT_0024a400 = 0;\n  return;\n}\n\n",
  "FUN_001bb780": "\nvoid FUN_001bb780(char *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if (*param_1 == '_') {\n    iVar1 = strcmp(param_1,\"_DefaultCmD_\");\n    if (iVar1 == 0) {\n      __printf_chk(1,&DAT_0021115f);\n      return;\n    }\n    iVar1 = strcmp(param_1,\"_EmptycmD_\");\n    if (iVar1 == 0) {\n      __printf_chk(1,&DAT_00211162);\n      return;\n    }\n    iVar1 = strcmp(param_1,\"_InitialWorD_\");\n    if (iVar1 == 0) {\n      __printf_chk(1,&DAT_00211165);\n      return;\n    }\n  }\n  else if (*param_1 == '\\0') {\n    __printf_chk(1,&DAT_001fc752);\n    return;\n  }\n  iVar1 = sh_contains_shell_metas(param_1);\n  if (iVar1 != 0) {\n    uVar2 = sh_single_quote(param_1);\n    __printf_chk(1,&DAT_002102da,uVar2);\n    sh_xfree(uVar2,\"./complete.def\",0x22e);\n    return;\n  }\n  __printf_chk(1,&DAT_002102da,param_1);\n  return;\n}\n\n",
  "rl_newline": "\nundefined8 rl_newline(void)\n\n{\n  int iVar1;\n  \n  if (DAT_0024b688 != 0) {\n    DAT_0024b688 = 0;\n    (*(code *)rl_redisplay_function)();\n    _rl_want_redisplay = 0;\n  }\n  rl_done = 1;\n  if ((_rl_history_preserve_point != 0) && (_rl_history_saved_point = rl_point, rl_point == rl_end))\n  {\n    _rl_history_saved_point = 0xffffffff;\n  }\n  rl_readline_state = rl_readline_state | 0x2000000;\n  if (rl_editing_mode == 0) {\n    _rl_vi_done_inserting();\n    iVar1 = _rl_vi_textmod_command(_rl_vi_last_command);\n    if (iVar1 == 0) {\n      _rl_vi_reset_last();\n    }\n  }\n  if (((rl_erase_empty_line == 0) || ((rl_point | rl_end) != 0)) && (_rl_echoing_p != 0)) {\n    _rl_update_final();\n    return 0;\n  }\n  return 0;\n}\n\n",
  "strtoumax": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuintmax_t strtoumax(char *__nptr,char **__endptr,int __base)\n\n{\n  uintmax_t uVar1;\n  \n  uVar1 = (*(code *)PTR_strtoumax_00237da0)();\n  return uVar1;\n}\n\n",
  "FUN_0017b140": "\nundefined * FUN_0017b140(char *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  size_t sVar2;\n  char *__dest;\n  undefined *puVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  char *local_48;\n  undefined4 local_40;\n  long local_30;\n  \n  uVar1 = DAT_00247848;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_40 = 0x40;\n  DAT_00247848 = 1;\n  sVar2 = strlen(param_1);\n  __dest = (char *)sh_xmalloc(sVar2 + 1,\"subst.c\",0x11d1);\n  local_48 = strcpy(__dest,param_1);\n  puVar3 = (undefined *)FUN_00177e80(&local_48,param_2,1,0,0);\n  if (puVar3 == &DAT_00247880) {\n    uVar4 = 2;\n  }\n  else {\n    if (puVar3 != &DAT_00247870) {\n      DAT_00247848 = uVar1;\n      sh_xfree(local_48,\"subst.c\",0x11d4);\n      if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return puVar3;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    uVar4 = 1;\n  }\n  last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n  FUN_001667f0(uVar4);\n}\n\n",
  "fc_builtin": "\nulong fc_builtin(long *param_1)\n\n{\n  bool bVar1;\n  bool bVar2;\n  int iVar3;\n  uint uVar4;\n  long **pplVar5;\n  long *plVar6;\n  size_t sVar7;\n  char *pcVar8;\n  char *pcVar9;\n  char *pcVar10;\n  long **pplVar11;\n  long *plVar12;\n  size_t sVar13;\n  undefined8 uVar14;\n  FILE *__stream;\n  int *piVar15;\n  long lVar16;\n  uint uVar17;\n  uint uVar18;\n  long *plVar19;\n  ulong uVar20;\n  long in_FS_OFFSET;\n  bool bVar21;\n  uint local_54;\n  uint local_50;\n  uint local_4c;\n  char *local_48;\n  long local_40;\n  \n  bVar1 = false;\n  uVar20 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  reset_internal_getopt();\n  local_54 = 0;\n  bVar2 = true;\n  pcVar9 = (char *)0x0;\n  lcurrent = param_1;\nLAB_001aa37b:\n  loptend = lcurrent;\n  if (((lcurrent != (long *)0x0) &&\n      (iVar3 = legal_number(*(char **)lcurrent[1] + (**(char **)lcurrent[1] == '-'),0), iVar3 != 0))\n     || (iVar3 = internal_getopt(param_1), iVar3 == -1)) {\n    plVar19 = loptend;\n    if ((((pcVar9 != (char *)0x0) && (*pcVar9 == '-')) && (pcVar9[1] == '\\0')) || ((int)uVar20 != 0)\n       ) {\n      pplVar11 = (long **)0x0;\n      if (loptend != (long *)0x0) goto LAB_001aa559;\n      lVar16 = history_list();\n      if (lVar16 != 0) {\n        uVar14 = 0;\n        pplVar5 = (long **)0x0;\n        goto LAB_001aa598;\n      }\n      builtin_error(\"no command found\");\n      goto LAB_001aa7fa;\n    }\n    plVar6 = (long *)history_list();\n    if (plVar6 == (long *)0x0) goto LAB_001aa3eb;\n    if (*plVar6 == 0) {\n      if (remember_on_history != 0) {\n        uVar18 = 0;\n        uVar4 = 0;\n        uVar17 = ~hist_last_line_added;\n        goto LAB_001aa8b6;\n      }\n      if ((subshell_environment & 4) != 0) {\n        uVar18 = 0;\n        goto LAB_001aacae;\n      }\n      uVar4 = 0;\n      uVar17 = -hist_last_line_added;\n      uVar18 = 0;\n    }\n    else {\n      plVar12 = plVar6;\n      uVar18 = 0;\n      do {\n        uVar17 = uVar18;\n        plVar12 = plVar12 + 1;\n        uVar18 = uVar17 + 1;\n      } while (*plVar12 != 0);\n      uVar17 = uVar17 - hist_last_line_added;\n      if ((remember_on_history == 0) &&\n         (uVar17 = uVar18 - hist_last_line_added, (subshell_environment & 4) != 0)) {\nLAB_001aacae:\n        uVar17 = ((uVar18 - 1) + (uint)(enable_history_list == 0)) - hist_last_line_added;\n        if (uVar18 != 0) goto LAB_001aa88a;\nLAB_001aacc6:\n        uVar4 = 0;\n      }\n      else {\nLAB_001aa88a:\n        lVar16 = (long)(int)(uVar18 - 1);\n        while (uVar4 = (uint)lVar16, plVar6[lVar16] == 0) {\n          lVar16 = lVar16 + -1;\n          if (((long)(int)uVar18 + -2) - (ulong)(uVar18 - 1) == lVar16) goto LAB_001aacc6;\n        }\n      }\n    }\nLAB_001aa8b6:\n    local_50 = 0;\n    if (-1 < (int)uVar17) {\n      local_50 = uVar17;\n    }\n    if (uVar17 == uVar18) {\n      lVar16 = (long)(int)(uVar17 - 1);\n      do {\n        uVar18 = (uint)lVar16;\n        if (uVar18 == 0xffffffff) {\n          local_50 = 0;\n          goto LAB_001aa8c9;\n        }\n        plVar12 = plVar6 + lVar16;\n        lVar16 = lVar16 + -1;\n      } while (*plVar12 == 0);\n      local_50 = 0;\n      if (-1 < (int)uVar18) {\n        local_50 = uVar18;\n      }\n    }\nLAB_001aa8c9:\n    uVar18 = local_50;\n    if (plVar19 != (long *)0x0) {\n      uVar17 = FUN_001aa0a0(*(undefined8 *)plVar19[1],plVar6,local_54 | 2);\n      if (*plVar19 == 0) {\n        uVar18 = uVar17;\n        if (uVar4 != uVar17) {\n          bVar21 = uVar17 == 0x80000000;\n          uVar18 = local_50;\n          if (local_54 == 0) {\n            uVar18 = uVar17;\n          }\n          goto LAB_001aa929;\n        }\nLAB_001aa931:\n        if ((uVar17 != 0x80000001) && (uVar18 != 0x80000001)) {\n          if ((uVar17 != 0x80000002) && (uVar18 != 0x80000002)) {\n            local_4c = 0;\n            if (-1 < (int)uVar17) {\n              local_4c = uVar17;\n            }\n            if ((int)uVar18 < 0) {\n              uVar18 = 0;\n            }\n            if (local_54 == 0) goto LAB_001aad0f;\n            goto LAB_001aa985;\n          }\n          uVar20 = 1;\n          builtin_error(\"no command found\");\n          goto LAB_001aa3eb;\n        }\n      }\n      else {\n        uVar18 = FUN_001aa0a0(**(undefined8 **)(*plVar19 + 8),plVar6,local_54);\n        bVar21 = uVar17 == 0x80000000 || uVar18 == 0x80000000;\nLAB_001aa929:\n        if (!bVar21) goto LAB_001aa931;\n      }\n      uVar20 = 1;\n      sh_erange(0,\"history specification\");\n      goto LAB_001aa3eb;\n    }\n    if (local_54 == 0) {\n      local_4c = local_50;\nLAB_001aad0f:\n      uVar4 = uVar18;\n      if (hist_last_line_added == 0) {\nLAB_001aad1f:\n        uVar18 = 0;\n        if (-1 < (int)uVar4) {\n          uVar18 = uVar4;\n        }\n        local_50 = uVar18;\n        if ((int)uVar18 < (int)local_4c) {\n          bVar1 = true;\n          local_50 = local_4c;\n          local_4c = uVar18;\n        }\n      }\n      else {\n        bash_delete_last_history();\n        uVar4 = local_50;\n        if ((local_4c == uVar18) && (uVar18 == local_50)) {\n          if (plVar6[(int)local_50] != 0) goto LAB_001aad1f;\n          local_4c = uVar18 - 1;\n          local_50 = local_4c;\n          uVar4 = local_4c;\n          uVar18 = local_4c;\n          if (plVar6[(int)local_4c] == 0) goto LAB_001aaf97;\n        }\n        else {\n          if (plVar6[(int)local_50] == 0) {\nLAB_001aaf97:\n            uVar4 = local_50 - 1;\n            local_50 = uVar4;\n            if ((int)uVar4 <= (int)uVar18) goto LAB_001aaf54;\n          }\n          else if ((int)local_50 <= (int)uVar18) goto LAB_001aad1f;\n          uVar4 = uVar18;\n          if ((int)local_50 <= (int)local_4c) {\n            local_4c = local_50;\n          }\n        }\nLAB_001aaf54:\n        local_50 = 0;\n        if (-1 < (int)uVar4) {\n          local_50 = uVar4;\n        }\n        if (local_4c != 0xffffffff) goto LAB_001aad1f;\n        local_4c = 0;\n      }\n      __stream = (FILE *)sh_mktmpfp(&DAT_0020fb44,5,&local_48);\n      bVar2 = false;\n      if (__stream != (FILE *)0x0) goto LAB_001aacf6;\n      piVar15 = __errno_location();\n      pcVar8 = strerror(*piVar15);\n      pcVar9 = local_48;\n      if (local_48 == (char *)0x0) {\n        pcVar9 = \"\";\n      }\n      builtin_error(\"%s: cannot open temp file: %s\",pcVar9,pcVar8);\n      if (local_48 != (char *)0x0) {\n        uVar20 = 1;\n        sh_xfree(local_48,\"./fc.def\",0x1bd);\n        goto LAB_001aa3eb;\n      }\n      goto LAB_001aa7fa;\n    }\n    local_4c = 0;\n    if (-1 < (int)(local_50 - 0xf)) {\n      local_4c = local_50 - 0xf;\n    }\nLAB_001aa985:\n    local_50 = uVar18;\n    uVar4 = local_4c;\n    __stream = stdout;\n    if ((int)local_50 < (int)local_4c) {\n      local_4c = local_50;\n      bVar1 = true;\n      local_50 = uVar4;\n    }\n    else {\nLAB_001aacf6:\n      uVar4 = local_50;\n      if (!bVar1) {\n        uVar4 = local_4c;\n      }\n    }\n    while( true ) {\n      if (bVar1) {\n        bVar21 = (int)local_4c <= (int)uVar4;\n      }\n      else {\n        bVar21 = (int)uVar4 <= (int)local_50;\n      }\n      if (!bVar21) break;\n      if (terminating_signal != 0) {\n        termsig_handler();\n      }\n      if (interrupt_state != 0) {\n        throw_to_top_level();\n      }\n      pplVar11 = (long **)(plVar6 + (int)uVar4);\n      if (*pplVar11 != (long *)0x0) {\n        if (bVar2) {\n          __fprintf_chk(__stream,1,\"%d\",history_base + uVar4);\n        }\n        if (local_54 != 0) {\n          if (posixly_correct == 0) {\n            __fprintf_chk(__stream,1,&DAT_0020fb6a,\n                          (-(uint)((*pplVar11)[2] == 0) & 0xfffffff6) + 0x2a);\n          }\n          else {\n            fputc(9,__stream);\n          }\n        }\n        if (**pplVar11 != 0) {\n          __fprintf_chk(__stream,1,&DAT_0020fbe7);\n        }\n      }\n      uVar18 = uVar4 + 1;\n      uVar4 = uVar4 - 1;\n      if (!bVar1) {\n        uVar4 = uVar18;\n      }\n    }\n    if (local_54 == 0) {\n      fflush(__stream);\n      iVar3 = ferror(__stream);\n      if (iVar3 != 0) {\n        sh_wrerror();\n        fclose(__stream);\n        if (local_48 == (char *)0x0) goto LAB_001aa7fa;\n        uVar20 = 1;\n        sh_xfree(local_48,\"./fc.def\",0x1dc);\n        goto LAB_001aa3eb;\n      }\n      fclose(__stream);\n      if (pcVar9 == (char *)0x0) {\n        pcVar9 = \"${FCEDIT:-${EDITOR:-ed}}\";\n        if (posixly_correct == 0) {\n          pcVar9 = \"${FCEDIT:-${EDITOR:-vi}}\";\n        }\n        sVar7 = strlen(local_48);\n        uVar14 = sh_xmalloc(sVar7 + 0x1b,\"./fc.def\",0x1ea);\n      }\n      else {\n        sVar7 = strlen(pcVar9);\n        sVar13 = strlen(local_48);\n        uVar14 = sh_xmalloc(sVar7 + 2 + sVar13,\"./fc.def\",0x1e4);\n      }\n      __sprintf_chk(uVar14,1,0xffffffffffffffff,\"%s %s\",pcVar9,local_48);\n      iVar3 = parse_and_execute(uVar14,&DAT_0020fb49,4);\n      if (iVar3 == 0) {\n        remember_on_history = 1;\n        begin_unwind_frame(\"fc builtin\");\n        add_unwind_protect(xfree,local_48);\n        add_unwind_protect(PTR_unlink_00237f10,local_48);\n        add_unwind_protect(FUN_001aa080,0);\n        unwind_protect_mem(&suppress_debug_trap_verbose,4);\n        echo_input_at_read = 1;\n        suppress_debug_trap_verbose = 1;\n        uVar4 = fc_execute_file(local_48);\n        uVar20 = (ulong)uVar4;\n        run_unwind_frame(\"fc builtin\");\n        goto LAB_001aa3eb;\n      }\n      unlink(local_48);\n      sh_xfree(local_48,\"./fc.def\",0x1f1);\n      goto LAB_001aa7fa;\n    }\n    uVar4 = sh_chkwrite(0);\n    uVar20 = (ulong)uVar4;\n    goto LAB_001aa3eb;\n  }\n  if (iVar3 == -99) {\n    builtin_help();\n    uVar20 = 0x102;\n    goto LAB_001aa3eb;\n  }\n  switch(iVar3) {\n  case 0x65:\n    pcVar9 = list_optarg;\n    goto LAB_001aa37b;\n  default:\n    builtin_usage();\n    uVar20 = 0x102;\n    break;\n  case 0x6c:\n    local_54 = 1;\n    goto LAB_001aa37b;\n  case 0x6e:\n    bVar2 = false;\n    goto LAB_001aa37b;\n  case 0x72:\n    bVar1 = true;\n    goto LAB_001aa37b;\n  case 0x73:\n    goto switchD_001aa3d5_caseD_73;\n  }\nLAB_001aa3eb:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar20;\n  }\nLAB_001aafb2:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n  while( true ) {\n    *pcVar9 = '\\0';\n    pplVar5 = (long **)sh_xmalloc(0x18,\"./fc.def\",0xf7);\n    *pplVar5 = (long *)0x0;\n    pcVar8 = *(char **)plVar19[1];\n    sVar7 = strlen(pcVar8);\n    pcVar10 = (char *)sh_xmalloc(sVar7 + 1,\"./fc.def\",0xf9);\n    plVar6 = (long *)strcpy(pcVar10,pcVar8);\n    pplVar5[1] = plVar6;\n    sVar7 = strlen(pcVar9 + 1);\n    pcVar8 = (char *)sh_xmalloc(sVar7 + 1,\"./fc.def\",0xfa);\n    plVar6 = (long *)strcpy(pcVar8,pcVar9 + 1);\n    pplVar5[2] = plVar6;\n    if (pplVar11 != (long **)0x0) {\n      *pplVar5 = (long *)pplVar11;\n    }\n    plVar19 = (long *)*plVar19;\n    pplVar11 = pplVar5;\n    if (plVar19 == (long *)0x0) break;\nLAB_001aa559:\n    pcVar9 = strchr(*(char **)plVar19[1],0x3d);\n    if (pcVar9 == (char *)0x0) {\n      if (pplVar11 == (long **)0x0) {\n        lVar16 = history_list();\n        pplVar11 = (long **)0x0;\n      }\n      else if (*pplVar11 == (long *)0x0) {\n        lVar16 = history_list();\n      }\n      else {\n        pplVar11 = (long **)list_reverse(pplVar11);\n        lVar16 = history_list();\n      }\n      uVar14 = *(undefined8 *)plVar19[1];\n      goto LAB_001aa58f;\n    }\n  }\n  if (*pplVar5 == (long *)0x0) {\n    lVar16 = history_list();\n    uVar14 = 0;\n    if (lVar16 == 0) {\n      builtin_error(\"no command found\");\n      goto LAB_001aa7b0;\n    }\nLAB_001aa598:\n    iVar3 = FUN_001aa0a0(uVar14,lVar16,0);\n    pplVar11 = pplVar5;\n    if (-1 < iVar3) {\n      pcVar9 = **(char ***)(lVar16 + (long)iVar3 * 8);\n      sVar7 = strlen(pcVar9);\n      pcVar8 = (char *)sh_xmalloc(sVar7 + 1,\"./fc.def\",0x29e);\n      pcVar9 = strcpy(pcVar8,pcVar9);\n      if (pplVar5 == (long **)0x0) {\n        __fprintf_chk(stderr,1,&DAT_0020fbe7,pcVar9);\nLAB_001aa6ca:\n        if (*pcVar9 != '\\0') {\n          sVar7 = strlen(pcVar9);\n          if ((pcVar9[(long)(int)sVar7 + -1] != '\\n') ||\n             (pcVar9[(long)(int)sVar7 + -1] = '\\0', *pcVar9 != '\\0')) {\n            bash_delete_last_history();\n            maybe_add_history(pcVar9);\n          }\n        }\n      }\n      else {\n        sVar7 = strlen(pcVar9);\n        pcVar8 = (char *)sh_xmalloc(sVar7 + 1,\"./fc.def\",0x2db);\n        pcVar8 = strcpy(pcVar8,pcVar9);\n        do {\n          pcVar10 = (char *)strsub(pcVar8,pplVar11[1],pplVar11[2],1);\n          sh_xfree(pcVar8,\"./fc.def\",0x2de);\n          pplVar11 = (long **)*pplVar11;\n          pcVar8 = pcVar10;\n        } while (pplVar11 != (long **)0x0);\n        sh_xfree(pcVar9,\"./fc.def\",0x11d);\n        do {\n          pplVar11 = (long **)*pplVar5;\n          if (pplVar5[1] != (long *)0x0) {\n            sh_xfree(pplVar5[1],\"./fc.def\",0x11e);\n          }\n          if (pplVar5[2] != (long *)0x0) {\n            sh_xfree(pplVar5[2],\"./fc.def\",0x11e);\n          }\n          sh_xfree(pplVar5,\"./fc.def\",0x11e);\n          pplVar5 = pplVar11;\n        } while (pplVar11 != (long **)0x0);\n        __fprintf_chk(stderr,1,&DAT_0020fbe7,pcVar10);\n        pcVar9 = pcVar10;\n        if (pcVar10 != (char *)0x0) goto LAB_001aa6ca;\n      }\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        uVar20 = parse_and_execute(pcVar9,&DAT_0020fb49,4);\n        return uVar20;\n      }\n      goto LAB_001aafb2;\n    }\n  }\n  else {\n    pplVar11 = (long **)list_reverse(pplVar5);\n    lVar16 = history_list();\n    uVar14 = 0;\nLAB_001aa58f:\n    pplVar5 = pplVar11;\n    if (lVar16 != 0) goto LAB_001aa598;\n  }\n  builtin_error(\"no command found\");\n  pplVar5 = pplVar11;\n  while (pplVar5 != (long **)0x0) {\nLAB_001aa7b0:\n    pplVar11 = (long **)*pplVar5;\n    if (pplVar5[1] != (long *)0x0) {\n      sh_xfree(pplVar5[1],\"./fc.def\",0x115);\n    }\n    if (pplVar5[2] != (long *)0x0) {\n      sh_xfree(pplVar5[2],\"./fc.def\",0x115);\n    }\n    sh_xfree(pplVar5,\"./fc.def\",0x115);\n    pplVar5 = pplVar11;\n  }\nLAB_001aa7fa:\n  uVar20 = 1;\n  goto LAB_001aa3eb;\nswitchD_001aa3d5_caseD_73:\n  uVar20 = 1;\n  goto LAB_001aa37b;\n}\n\n",
  "brace_expand": "\nchar ** brace_expand(char *param_1)\n\n{\n  ushort *puVar1;\n  uint uVar2;\n  int iVar3;\n  mbstate_t mVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  size_t sVar8;\n  char **ppcVar9;\n  byte *__haystack;\n  long lVar10;\n  long lVar11;\n  char *pcVar12;\n  byte *pbVar13;\n  byte *__nptr;\n  ushort **ppuVar14;\n  int *piVar15;\n  char **ppcVar16;\n  char *pcVar17;\n  char **ppcVar18;\n  long lVar19;\n  char **ppcVar20;\n  byte *pbVar21;\n  byte bVar22;\n  byte *pbVar23;\n  undefined8 uVar24;\n  long lVar25;\n  int iVar26;\n  uint uVar27;\n  size_t __n;\n  long in_FS_OFFSET;\n  bool bVar28;\n  bool bVar29;\n  char *local_e0;\n  char **local_d8;\n  ulong local_c0;\n  int local_88;\n  int local_84;\n  ulong local_80;\n  byte *local_78;\n  undefined8 local_70;\n  mbstate_t local_68;\n  mbstate_t local_60;\n  undefined local_58 [24];\n  long local_40;\n  \n  iVar26 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_68.__count = 0;\n  local_68.__value = (_union_27)0x0;\n  sVar8 = strlen(param_1);\n  do {\n    local_88 = iVar26;\n    iVar5 = FUN_0018e9b0(param_1,sVar8,&local_88,0x7b);\n    iVar3 = local_88;\n    __n = (size_t)local_88;\n    iVar26 = local_88 + 1;\n    if (iVar5 == 0) {\n      local_e0 = (char *)sh_xmalloc((long)iVar26,\"braces.c\",0x98);\n      if (0 < iVar3) goto LAB_0018f178;\n      local_e0[__n] = '\\0';\n      local_d8 = (char **)sh_xmalloc(0x10,\"braces.c\",0x9d);\n      *local_d8 = local_e0;\n      local_d8[1] = (char *)0x0;\n      goto LAB_0018f115;\n    }\n    local_84 = iVar26;\n    iVar6 = FUN_0018e9b0(param_1,sVar8,&local_84,0x7d);\n  } while (iVar6 == 0);\n  local_e0 = (char *)sh_xmalloc((long)iVar26,\"braces.c\",0x98);\n  if (0 < iVar3) {\nLAB_0018f178:\n    strncpy(local_e0,param_1,__n);\n  }\n  local_e0[__n] = '\\0';\n  ppcVar9 = (char **)sh_xmalloc(0x10,\"braces.c\",0x9d);\n  *ppcVar9 = local_e0;\n  ppcVar9[1] = (char *)0x0;\n  local_d8 = ppcVar9;\n  if (iVar5 != 0x7b) goto LAB_0018f115;\n  local_88 = iVar26;\n  iVar5 = FUN_0018e9b0(param_1,sVar8,&local_88,0x7d);\n  iVar3 = local_88;\n  if (iVar5 == 0) {\n    sh_xfree(local_e0,\"braces.c\",0xc4);\n    sVar8 = strlen(param_1);\n    uVar24 = 0xc5;\n  }\n  else {\n    iVar5 = local_88 - iVar26;\n    __haystack = (byte *)substring(param_1,iVar26,local_88);\n    lVar10 = (long)iVar5;\n    local_68.__count = 0;\n    local_68.__value = (_union_27)0x0;\n    bVar22 = *__haystack;\n    local_84 = 0;\n    if (bVar22 != 0) {\n      lVar11 = 0;\n      pbVar13 = __haystack;\n      do {\n        mVar4 = local_68;\n        iVar26 = local_84;\n        if (bVar22 == 0x5c) {\n          iVar6 = local_84 + 1;\n          if (locale_mb_cur_max < 2) {\n            local_84 = local_84 + 2;\n            local_68 = mVar4;\n          }\n          else {\n            bVar22 = __haystack[iVar6];\n            if ((*(uint *)(is_basic_table + (ulong)(bVar22 >> 5) * 4) >> (bVar22 & 0x1f) & 1) == 0)\n            {\n              if ((locale_utf8locale == 0) || ((char)bVar22 < '\\0')) {\n                local_84 = iVar6;\n                sVar8 = mbrtowc((wchar_t *)0x0,(char *)(__haystack + iVar6),lVar10 - iVar6,&local_68\n                               );\n                if (sVar8 < 0xfffffffffffffffe) {\n                  if (sVar8 == 0) goto LAB_0018f4d6;\n                  goto LAB_0018f4e5;\n                }\n                local_84 = iVar26 + 2;\n                local_68 = mVar4;\n              }\n              else {\n                if (bVar22 != 0) goto LAB_0018f4e0;\nLAB_0018f4d6:\n                local_84 = iVar26 + 2;\n              }\n            }\n            else {\nLAB_0018f4e0:\n              sVar8 = 1;\nLAB_0018f4e5:\n              local_84 = iVar6 + (int)sVar8;\n            }\n          }\n        }\n        else {\n          if (bVar22 == 0x2c) {\n            local_70 = (char *)((ulong)local_70 & 0xffffffff00000000);\n            local_60.__count = 0;\n            local_60.__value = (_union_27)0x0;\n            local_e0._0_4_ = FUN_0018e9b0(__haystack,lVar10,&local_70,0x2c);\n            iVar26 = (int)local_70;\n            uVar24 = substring(__haystack,0,(ulong)local_70 & 0xffffffff);\n            ppcVar20 = (char **)brace_expand(uVar24);\n            goto LAB_0018f5b0;\n          }\n          if (locale_mb_cur_max < 2) {\nLAB_0018f471:\n            local_84 = iVar26 + 1;\n          }\n          else {\n            if ((*(uint *)(is_basic_table + (ulong)(bVar22 >> 5) * 4) >> (bVar22 & 0x1f) & 1) == 0)\n            {\n              if ((locale_utf8locale == 0) || (iVar6 = 1, (char)bVar22 < '\\0')) {\n                sVar8 = mbrtowc((wchar_t *)0x0,(char *)pbVar13,lVar10 - lVar11,&local_68);\n                if (0xfffffffffffffffd < sVar8) {\n                  local_84 = iVar26 + 1;\n                  local_68 = mVar4;\n                  goto LAB_0018f25c;\n                }\n                if (sVar8 == 0) goto LAB_0018f471;\n                iVar6 = (int)sVar8;\n              }\n            }\n            else {\n              iVar6 = 1;\n            }\n            local_84 = iVar26 + iVar6;\n          }\n        }\nLAB_0018f25c:\n        lVar11 = (long)local_84;\n        pbVar13 = __haystack + lVar11;\n        bVar22 = *pbVar13;\n      } while (bVar22 != 0);\n    }\n    pcVar12 = strstr((char *)__haystack,\"..\");\n    if (pcVar12 != (char *)0x0) {\n      iVar26 = (int)((long)pcVar12 - (long)__haystack);\n      pbVar13 = (byte *)substring(__haystack,0,(long)pcVar12 - (long)__haystack & 0xffffffff);\n      __nptr = (byte *)substring(__haystack,iVar26 + 2,iVar5);\n      if ((*pbVar13 == 0) || (*__nptr == 0)) {\n        sh_xfree(pbVar13,\"braces.c\",0x1ec);\n        sh_xfree(__nptr,\"braces.c\",0x1ed);\n      }\n      else {\n        iVar6 = legal_number(pbVar13,&local_80);\n        ppuVar14 = __ctype_b_loc();\n        puVar1 = *ppuVar14;\n        if (iVar6 == 0) {\n          uVar2 = 0;\n          if ((*(byte *)((long)puVar1 + (ulong)*pbVar13 * 2 + 1) & 4) != 0) {\n            uVar2 = (uint)(pbVar13[1] == 0) * 2;\n          }\n        }\n        else {\n          uVar2 = 1;\n        }\n        local_78 = (byte *)0x0;\n        if (((puVar1[*__nptr] & 0x800) == 0) &&\n           (((*__nptr - 0x2b & 0xfd) != 0 ||\n            ((*(byte *)((long)puVar1 + (ulong)__nptr[1] * 2 + 1) & 8) == 0)))) {\n          if (((puVar1[*__nptr] & 0x400) != 0) && ((__nptr[1] == 0 || (__nptr[1] == 0x2e)))) {\n            pbVar21 = __nptr + 1;\n            local_78 = pbVar21;\n            piVar15 = __errno_location();\n            uVar27 = 2;\nLAB_0018f379:\n            *piVar15 = 0;\n            pbVar23 = pbVar21;\n            bVar22 = *pbVar21;\n            if (*pbVar21 == 0x2e) {\n              if ((((pbVar21[1] == 0x2e) && (pbVar21[2] != 0)) &&\n                  (lVar11 = strtoimax((char *)(pbVar21 + 2),(char **)&local_78,10), *local_78 == 0))\n                 && (iVar6 = (int)pbVar21, pbVar21 = local_78, *piVar15 != 0x22)) goto LAB_0018fad5;\n            }\n            else {\nLAB_0018f390:\n              iVar6 = (int)pbVar23;\n              lVar11 = 1;\n              if (bVar22 == 0) {\nLAB_0018fad5:\n                pbVar23 = (byte *)(ulong)uVar2;\n                if ((uVar2 == uVar27) && (uVar2 != 0)) {\n                  if (uVar2 == 2) {\n                    local_80 = (ulong)*pbVar13;\n                    local_c0 = (ulong)*__nptr;\n                    iVar5 = 2;\n                    iVar6 = 1;\n                  }\n                  else {\n                    iVar7 = ((iVar5 - ((int)pbVar21 - iVar6)) - iVar26) + -2;\n                    if ((iVar26 < 2) ||\n                       ((pbVar23 = pbVar13, *pbVar13 != 0x30 &&\n                        (((iVar26 == 2 || (*pbVar13 != 0x2d)) || (pbVar13[1] != 0x30)))))) {\n                      iVar5 = 1;\n                      iVar6 = 0;\n                    }\n                    else {\n                      iVar5 = 3;\n                      iVar6 = iVar26;\n                    }\n                    if (iVar7 < 2) {\n                      bVar28 = iVar5 == 3;\n                      iVar26 = iVar6;\n                    }\n                    else {\n                      bVar22 = *__nptr;\n                      pbVar23 = (byte *)(ulong)bVar22;\n                      bVar28 = bVar22 == 0x30 && iVar6 < iVar7;\n                      if ((bVar22 == 0x30 && iVar6 < iVar7) ||\n                         (((iVar7 != 2 && (bVar22 == 0x2d)) &&\n                          (bVar28 = __nptr[1] == 0x30 && iVar6 < iVar7, bVar28)))) {\n                        iVar5 = 3;\n                        iVar6 = iVar7;\n                        if (iVar26 <= iVar7) goto LAB_0018fb92;\n                      }\n                      else {\n                        bVar29 = iVar5 == 3;\n                        bVar28 = iVar6 < iVar26 && bVar29;\n                        if (iVar6 >= iVar26 || !bVar29) {\n                          iVar26 = iVar6;\n                          bVar28 = bVar29;\n                        }\n                      }\n                    }\n                    iVar6 = iVar26;\n                    if ((iVar26 < iVar7) && (bVar28)) {\n                      iVar5 = 3;\n                      iVar6 = iVar7;\n                    }\n                  }\nLAB_0018fb92:\n                  if (lVar11 == 0) {\n                    lVar11 = (ulong)((long)local_80 <= (long)local_c0) * 2 + -1;\nLAB_0018fbb2:\n                    if ((long)local_80 < 1) {\n                      if ((local_80 == 0) ||\n                         ((long)local_c0 <= (long)(local_80 + 0x7ffffffffffffffd)))\n                      goto LAB_0018fbcf;\n                    }\n                    else if ((long)(local_80 + 0x8000000000000003) <= (long)local_c0) {\nLAB_0018fbcf:\n                      lVar25 = local_c0 - local_80;\n                      lVar19 = -lVar25;\n                      if (0 < lVar25) {\n                        lVar19 = lVar25;\n                      }\n                      lVar25 = -lVar11;\n                      if (0 < lVar11) {\n                        lVar25 = lVar11;\n                      }\n                      if (lVar19 / lVar25 < 0x7ffffffd) {\n                        iVar26 = (int)(lVar19 / lVar25);\n                        ppcVar20 = (char **)strvec_mcreate(iVar26 + 2,pbVar23,lVar19 % lVar25);\n                        if (ppcVar20 != (char **)0x0) {\n                          iVar26 = 0;\n                          do {\n                            ppcVar16 = ppcVar20;\n                            if (interrupt_state != 0) {\n                              ppcVar20[iVar26] = (char *)0x0;\n                              ppcVar16 = (char **)0x0;\n                              strvec_dispose(ppcVar20);\n                            }\n                            if (terminating_signal != 0) {\n                              termsig_handler(terminating_signal);\n                            }\n                            if (interrupt_state != 0) {\n                              throw_to_top_level();\n                            }\n                            iVar7 = iVar26 + 1;\n                            if (iVar5 == 1) {\n                              local_70 = (char *)itos(local_80);\n                            }\n                            else if (iVar5 == 3) {\n                              __asprintf_chk(&local_70,1,&DAT_001ff225,iVar6,local_80 & 0xffffffff);\n                            }\n                            else {\n                              local_70 = (char *)sh_malloc(2,\"braces.c\",0x1b3);\n                              if (local_70 != (char *)0x0) {\n                                *local_70 = (char)local_80;\n                                local_70[1] = '\\0';\n                              }\n                            }\n                            ppcVar16[iVar26] = local_70;\n                            if (local_70 == (char *)0x0) {\n                              uVar24 = inttostr(local_80,local_58,0x16);\n                              internal_error(\"brace expansion: failed to allocate memory for `%s\\'\",\n                                             uVar24);\n                              strvec_dispose(ppcVar16);\n                              goto LAB_0018fbfb;\n                            }\n                            if ((long)local_80 < 1) {\n                              if ((local_80 != 0) &&\n                                 (lVar11 < (long)(-0x8000000000000000 - local_80)))\n                              goto LAB_0018fd2d;\n                            }\n                            else if ((long)(0x7fffffffffffffff - local_80) < lVar11)\n                            goto LAB_0018fd2d;\n                            local_80 = local_80 + lVar11;\n                            if (((lVar11 < 0) && ((long)local_80 < (long)local_c0)) ||\n                               ((ppcVar20 = ppcVar16, iVar26 = iVar7, 0 < lVar11 &&\n                                ((long)local_c0 < (long)local_80)))) goto LAB_0018fd2d;\n                          } while( true );\n                        }\n                        internal_error(\"brace expansion: failed to allocate memory for %u elements\",\n                                       iVar26 + 1);\n                      }\n                    }\n                  }\n                  else {\n                    if (((long)local_c0 < (long)local_80) && (0 < lVar11)) {\nLAB_0018fbaf:\n                      lVar11 = -lVar11;\n                      goto LAB_0018fbb2;\n                    }\n                    if (((long)local_c0 <= (long)local_80) || (-1 < lVar11)) goto LAB_0018fbb2;\n                    if (lVar11 != -0x8000000000000000) goto LAB_0018fbaf;\n                  }\nLAB_0018fbfb:\n                  sh_xfree(pbVar13,\"braces.c\",0x242);\n                  sh_xfree(__nptr,\"braces.c\",0x243);\n                  goto LAB_0018f3cd;\n                }\n              }\n            }\n          }\n        }\n        else {\n          piVar15 = __errno_location();\n          *piVar15 = 0;\n          local_c0 = strtoimax((char *)__nptr,(char **)&local_78,10);\n          if (*piVar15 != 0x22) {\n            if (local_78 == (byte *)0x0) {\n              *piVar15 = 0;\n              pbVar21 = (byte *)0x0;\n              uVar27 = 1;\n              pbVar23 = local_78;\n              bVar22 = DAT_00000000;\n              goto LAB_0018f390;\n            }\n            if ((*local_78 == 0) || (*local_78 == 0x2e)) {\n              uVar27 = 1;\n              pbVar21 = local_78;\n              goto LAB_0018f379;\n            }\n          }\n        }\n        sh_xfree(pbVar13,\"braces.c\",0x21a);\n        sh_xfree(__nptr,\"braces.c\",0x21b);\n      }\n    }\nLAB_0018f3cd:\n    pcVar12 = param_1 + (long)iVar3 + 1;\n    if (*pcVar12 != '\\0') {\n      ppcVar16 = (char **)strvec_create(2);\n      sVar8 = strlen(param_1 + __n);\n      pcVar17 = (char *)sh_xmalloc(sVar8 + 1,\"braces.c\",0xf5);\n      pcVar17 = strcpy(pcVar17,param_1 + __n);\n      *ppcVar16 = pcVar17;\n      pcVar17[lVar10 + 2] = '\\0';\n      ppcVar16[1] = (char *)0x0;\n      goto LAB_0018f7c8;\n    }\n    sh_xfree(__haystack,\"braces.c\",0xfc);\n    sh_xfree(local_e0,\"braces.c\",0xfd);\n    sVar8 = strlen(param_1);\n    uVar24 = 0xfe;\n  }\n  pcVar12 = (char *)sh_xmalloc(sVar8 + 1,\"braces.c\",uVar24);\n  pcVar12 = strcpy(pcVar12,param_1);\n  *ppcVar9 = pcVar12;\n  goto LAB_0018f115;\nLAB_0018fd2d:\n  ppcVar16[iVar7] = (char *)0x0;\n  sh_xfree(pbVar13,\"braces.c\",0x242);\n  sh_xfree(__nptr,\"braces.c\",0x243);\n  pcVar12 = param_1 + (long)iVar3 + 1;\n  if (ppcVar16 == (char **)0x0) goto LAB_0018f3cd;\nLAB_0018f7c8:\n  if (((*ppcVar9 == (char *)0x0) || (**ppcVar9 != '\\0')) || (ppcVar9[1] != (char *)0x0)) {\n    ppcVar9 = (char **)FUN_0018ee60(ppcVar9,ppcVar16);\n    sh_xfree(__haystack,\"braces.c\",0x107);\n    if (ppcVar9 != ppcVar16) {\n      strvec_dispose(ppcVar16);\n      local_d8 = ppcVar9;\n      if ((*pcVar12 == '\\0') || (local_d8 = (char **)brace_expand(pcVar12), ppcVar9 == (char **)0x0)\n         ) goto LAB_0018f115;\n      goto LAB_0018f86c;\n    }\n  }\n  else {\n    strvec_dispose(ppcVar9);\n    sh_xfree(__haystack,\"braces.c\",0x107);\n  }\n  local_d8 = ppcVar16;\n  if (*pcVar12 == '\\0') goto LAB_0018f115;\n  local_d8 = (char **)brace_expand(pcVar12);\n  ppcVar9 = ppcVar16;\n  goto LAB_0018f86c;\nLAB_0018f5b0:\n  ppcVar16 = ppcVar20;\n  sh_xfree(uVar24,\"braces.c\",0x157);\n  mVar4 = local_60;\n  if (locale_mb_cur_max < 2) {\nLAB_0018f610:\n    iVar5 = iVar26 + 1;\n  }\n  else {\n    bVar22 = __haystack[iVar26];\n    if ((*(uint *)(is_basic_table + (ulong)(bVar22 >> 5) * 4) >> (bVar22 & 0x1f) & 1) == 0) {\n      if ((locale_utf8locale != 0) && (-1 < (char)bVar22)) {\n        if (bVar22 == 0) goto LAB_0018f610;\n        goto LAB_0018f700;\n      }\n      sVar8 = mbrtowc((wchar_t *)0x0,(char *)(__haystack + iVar26),lVar10 - iVar26,&local_60);\n      if (0xfffffffffffffffd < sVar8) {\n        iVar5 = iVar26 + 1;\n        local_60 = mVar4;\n        goto LAB_0018f614;\n      }\n      iVar5 = (int)sVar8;\n      if (sVar8 == 0) goto LAB_0018f610;\n    }\n    else {\nLAB_0018f700:\n      iVar5 = 1;\n    }\n    iVar5 = iVar26 + iVar5;\n  }\nLAB_0018f614:\n  local_70 = (char *)CONCAT44(local_70._4_4_,iVar5);\n  if ((int)local_e0 != 0) {\n    local_e0._0_4_ = FUN_0018e9b0(__haystack,lVar10,&local_70,0x2c);\n    iVar26 = (int)local_70;\n    uVar24 = substring(__haystack,iVar5,(ulong)local_70 & 0xffffffff);\n    ppcVar20 = (char **)brace_expand(uVar24);\n    if (ppcVar16 != (char **)0x0) {\n      iVar5 = strvec_len(ppcVar16);\n      lVar11 = (long)iVar5;\n      iVar6 = strvec_len(ppcVar20);\n      iVar7 = iVar5 + iVar6;\n      ppcVar18 = (char **)strvec_mresize(ppcVar16,iVar7 + 1);\n      if (ppcVar18 == (char **)0x0) {\n        internal_error(\"brace expansion: cannot allocate memory for %s\",uVar24);\n        sh_xfree(uVar24,\"braces.c\",0x148);\n        strvec_dispose(ppcVar20);\n        strvec_dispose(ppcVar16);\n        goto LAB_0018f9e5;\n      }\n      if (0 < iVar6) {\n        lVar19 = 0;\n        do {\n          ppcVar18[lVar11 + lVar19] = ppcVar20[lVar19];\n          lVar19 = lVar19 + 1;\n          iVar5 = iVar7;\n        } while (lVar19 != iVar6);\n      }\n      ppcVar18[iVar5] = (char *)0x0;\n      sh_xfree(ppcVar20,\"braces.c\",0x155);\n      ppcVar20 = ppcVar18;\n    }\n    goto LAB_0018f5b0;\n  }\n  pcVar12 = param_1 + (long)iVar3 + 1;\n  if (ppcVar16 != (char **)0x0) goto LAB_0018f7c8;\nLAB_0018f9e5:\n  sh_xfree(__haystack,\"braces.c\",0x107);\n  strvec_dispose(0);\n  if (param_1[(long)iVar3 + 1] == '\\0') goto LAB_0018f115;\n  local_d8 = (char **)brace_expand(param_1 + (long)iVar3 + 1);\nLAB_0018f86c:\n  if (local_d8 != (char **)0x0) {\n    if (((*ppcVar9 != (char *)0x0) && (**ppcVar9 == '\\0')) && (ppcVar9[1] == (char *)0x0)) {\n      strvec_dispose(ppcVar9);\n      goto LAB_0018f115;\n    }\n    ppcVar9 = (char **)FUN_0018ee60(ppcVar9,local_d8);\n    if (ppcVar9 == local_d8) goto LAB_0018f115;\n  }\n  strvec_dispose(local_d8);\n  local_d8 = ppcVar9;\nLAB_0018f115:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_d8;\n}\n\n",
  "FUN_001942c0": "\nvoid FUN_001942c0(char *param_1)\n\n{\n  undefined4 uVar1;\n  char *pcVar2;\n  size_t sVar3;\n  \n  uVar1 = hist_verify;\n  hist_verify = 0;\n  pcVar2 = (char *)pre_process_line(param_1,0,0);\n  hist_verify = uVar1;\n  if (param_1 != pcVar2) {\n    return;\n  }\n  sVar3 = strlen(param_1);\n  pcVar2 = (char *)sh_xmalloc(sVar3 + 1,\"bashline.c\",0xa8c);\n  strcpy(pcVar2,param_1);\n  return;\n}\n\n",
  "restore_default_signal": "\nvoid restore_default_signal(ulong param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  undefined8 uVar4;\n  long lVar5;\n  \n  iVar1 = (int)param_1;\n  if (iVar1 == 0) {\n    if (iVar1 - 0x41U < 3) goto LAB_001829df;\nLAB_001829f1:\n    FUN_00181560();\n    uVar2 = (&DAT_00247e40)[iVar1];\n    (&trap_list)[iVar1] = 0;\n    uVar3 = uVar2 & 0xfffffffe;\n    if ((uVar2 & 0x10) == 0) goto LAB_00182a13;\n  }\n  else {\n    if (2 < iVar1 - 0x41U) {\n      if ((iVar1 < 0x41) &&\n         (lVar5 = (long)iVar1, *(code **)(original_signals + lVar5 * 8) == initialize_traps)) {\n        uVar4 = set_signal_handler(param_1,0);\n        *(undefined8 *)(original_signals + lVar5 * 8) = uVar4;\n        set_signal_handler(param_1 & 0xffffffff,uVar4);\n        if (*(long *)(original_signals + lVar5 * 8) == 1) {\n          (&DAT_00247e40)[lVar5] = (&DAT_00247e40)[lVar5] | 2;\n          return;\n        }\n        param_1 = param_1 & 0xffffffff;\n        uVar2 = (&DAT_00247e40)[lVar5];\n      }\n      else {\n        uVar2 = (&DAT_00247e40)[iVar1];\n      }\n      if (((uVar2 & 2) == 0) &&\n         (((uVar2 & 1) != 0 ||\n          ((((int)param_1 == 0x11 && ((uVar2 & 0x10) != 0)) && (DAT_00247a88 == initialize_traps))))\n         )) {\n        if ((uVar2 & 8) == 0) {\n          set_signal_handler(param_1,*(undefined8 *)(original_signals + (long)iVar1 * 8));\n          param_1 = param_1 & 0xffffffff;\n        }\n        FUN_001815b0(param_1,0);\n        (&DAT_00247e40)[iVar1] = (&DAT_00247e40)[iVar1] & 0xfffffffe;\n        return;\n      }\n      return;\n    }\nLAB_001829df:\n    if (((&DAT_00247e40)[iVar1] & 0x10) == 0) goto LAB_001829f1;\n    uVar3 = (&DAT_00247e40)[iVar1] & 0xfffffffe;\n    (&trap_list)[iVar1] = 0;\n  }\n  uVar3 = uVar3 | 0x20;\nLAB_00182a13:\n  (&DAT_00247e40)[iVar1] = uVar3;\n  return;\n}\n\n",
  "netopen": "\nint netopen(char *param_1)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *__dest;\n  char *pcVar3;\n  int *piVar4;\n  char *pcVar5;\n  addrinfo *paVar6;\n  int unaff_R12D;\n  long in_FS_OFFSET;\n  addrinfo *local_80;\n  undefined local_78 [16];\n  undefined local_68 [16];\n  undefined local_58 [16];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar2 = strlen(param_1);\n  __dest = (char *)sh_xmalloc(sVar2 + 1,\"netopen.c\",299);\n  strcpy(__dest,param_1);\n  pcVar5 = __dest + 9;\n  pcVar3 = strchr(pcVar5,0x2f);\n  if (pcVar3 == (char *)0x0) {\n    unaff_R12D = -1;\n    internal_error(\"%s: bad network path specification\",param_1);\n    sh_xfree(__dest,\"netopen.c\",0x133);\n  }\n  else {\n    *pcVar3 = '\\0';\n    local_68 = (undefined  [16])0x0;\n    local_78 = ZEXT416((param_1[5] != 't') + 1) << 0x40;\n    local_58 = (undefined  [16])0x0;\n    iVar1 = getaddrinfo(pcVar5,pcVar3 + 1,(addrinfo *)local_78,&local_80);\n    paVar6 = local_80;\n    if (iVar1 == 0) {\n      for (; paVar6 != (addrinfo *)0x0; paVar6 = paVar6->ai_next) {\n        while (unaff_R12D = socket(paVar6->ai_family,paVar6->ai_socktype,paVar6->ai_protocol),\n              unaff_R12D < 0) {\n          paVar6 = paVar6->ai_next;\n          if (paVar6 == (addrinfo *)0x0) {\n            sys_error(\"socket\");\n            freeaddrinfo(local_80);\n            unaff_R12D = -1;\n            goto LAB_001c5cb0;\n          }\n        }\n        iVar1 = connect(unaff_R12D,paVar6->ai_addr,paVar6->ai_addrlen);\n        if (-1 < iVar1) {\n          freeaddrinfo(local_80);\n          break;\n        }\n        if (paVar6->ai_next == (addrinfo *)0x0) {\n          piVar4 = __errno_location();\n          iVar1 = *piVar4;\n          sys_error(\"connect\");\n          close(unaff_R12D);\n          freeaddrinfo(local_80);\n          *piVar4 = iVar1;\n          unaff_R12D = -1;\n          break;\n        }\n        close(unaff_R12D);\n      }\n    }\n    else {\n      if (iVar1 == -8) {\n        pcVar5 = gai_strerror(-8);\n        internal_error(\"%s: %s\",pcVar3 + 1,pcVar5);\n      }\n      else {\n        pcVar3 = gai_strerror(iVar1);\n        internal_error(\"%s: %s\",pcVar5,pcVar3);\n      }\n      piVar4 = __errno_location();\n      unaff_R12D = -1;\n      *piVar4 = 0x16;\n    }\nLAB_001c5cb0:\n    sh_xfree(__dest,\"netopen.c\",0x138);\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return unaff_R12D;\n}\n\n",
  "sv_histchars": "\nvoid sv_histchars(void)\n\n{\n  char cVar1;\n  long lVar2;\n  char *pcVar3;\n  \n  lVar2 = find_variable();\n  if (lVar2 != 0) {\n    pcVar3 = (char *)get_variable_value(lVar2);\n    if (pcVar3 != (char *)0x0) {\n      history_expansion_char = *pcVar3;\n      if ((*pcVar3 != '\\0') && (cVar1 = pcVar3[1], cVar1 != '\\0')) {\n        history_subst_char = cVar1;\n        if (pcVar3[2] != '\\0') {\n          history_comment_char = pcVar3[2];\n        }\n      }\n      return;\n    }\n  }\n  history_expansion_char = 0x21;\n  history_subst_char = 0x5e;\n  history_comment_char = 0x23;\n  return;\n}\n\n",
  "bash_default_completion": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nchar ** bash_default_completion(char *param_1,int param_2,int param_3,int param_4,uint param_5)\n\n{\n  char cVar1;\n  char *pcVar2;\n  int iVar3;\n  char **ppcVar4;\n  size_t sVar5;\n  char *pcVar6;\n  long lVar7;\n  undefined8 uVar8;\n  char *pcVar9;\n  long in_FS_OFFSET;\n  char *local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar1 = *param_1;\n  iVar3 = param_2;\n  if (cVar1 == '$') {\n    if ((param_4 == 0x27) || (param_1[1] != '(')) {\n      iVar3 = 0x192980;\n      ppcVar4 = (char **)rl_completion_matches(param_1);\n      if (ppcVar4 != (char **)0x0) {\n        pcVar9 = *ppcVar4;\n        if ((pcVar9 != (char *)0x0) && (ppcVar4[1] == (char *)0x0)) {\n          sVar5 = strlen(pcVar9);\n          pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"bashline.c\",0x71c);\n          local_38 = strcpy(pcVar6,pcVar9);\n          FUN_00191f40(&local_38);\n          pcVar9 = local_38;\n          iVar3 = file_isdir(local_38);\n          if (iVar3 != 0) {\n            rl_completion_append_character = 0x2f;\n          }\n          sh_xfree(pcVar9,\"bashline.c\",0x722);\n        }\n        goto LAB_00198554;\n      }\n    }\n    else {\n      iVar3 = 0x1962d0;\n      ppcVar4 = (char **)rl_completion_matches();\n      if (ppcVar4 != (char **)0x0) goto LAB_00198554;\n    }\n    cVar1 = *param_1;\n  }\n  if (cVar1 == '~') {\n    iVar3 = 0x2f;\n    lVar7 = mbschr(param_1);\n    if (lVar7 == 0) {\n      iVar3 = 0x1da090;\n      ppcVar4 = (char **)rl_completion_matches(param_1);\n      if (ppcVar4 != (char **)0x0) goto LAB_00198554;\n    }\n  }\n  if ((perform_hostname_completion != 0) && (*param_1 == '@')) {\n    iVar3 = 0x192f60;\n    ppcVar4 = (char **)rl_completion_matches(param_1);\n    if (ppcVar4 != (char **)0x0) goto LAB_00198554;\n  }\n  if ((param_5 & 1) == 0) {\nLAB_00198540:\n    iVar3 = glob_pattern_p(param_1,iVar3);\n    if ((iVar3 == 1) &&\n       (ppcVar4 = (char **)rl_completion_matches(param_1,FUN_00192780), ppcVar4 != (char **)0x0)) {\n      if (ppcVar4[1] == (char *)0x0) goto LAB_00198554;\n      if (rl_completion_type != 9) {\n        if (rl_completion_type != 0x21) goto LAB_00198554;\n        goto LAB_00198518;\n      }\n      strvec_dispose(ppcVar4);\n    }\n    ppcVar4 = (char **)0x0;\n  }\n  else {\n    if (((no_empty_command_completion != 0) && (param_3 == param_2)) && (*param_1 == '\\0')) {\n      rl_ignore_some_completions_function = FUN_00191df0;\n      goto LAB_00198540;\n    }\n    iVar3 = 0x196610;\n    _DAT_00248874 = 0;\n    ppcVar4 = (char **)rl_completion_matches(param_1);\n    if (ppcVar4 == (char **)0x0) {\n      rl_ignore_some_completions_function = FUN_00191dd0;\n      goto LAB_00198540;\n    }\n    pcVar6 = ppcVar4[1];\n    pcVar9 = *ppcVar4;\n    pcVar2 = pcVar9;\n    if (pcVar6 == (char *)0x0) {\n      iVar3 = absolute_pathname(pcVar9);\n      if ((iVar3 != 0) || (iVar3 = absolute_program(*ppcVar4), iVar3 != 0)) {\nLAB_0019871c:\n        pcVar9 = *ppcVar4;\n        if (pcVar9 == (char *)0x0) goto LAB_00198554;\nLAB_00198729:\n        pcVar6 = ppcVar4[1];\n        pcVar2 = pcVar6;\n        goto joined_r0x00198731;\n      }\n      pcVar9 = *ppcVar4;\n      if (*pcVar9 == '~') goto LAB_00198729;\n      uVar8 = bash_tilde_expand(pcVar9,0);\n      iVar3 = file_isdir(uVar8);\n      sh_xfree(uVar8,\"bashline.c\",0xc38);\n      if ((iVar3 == 0) || (_DAT_00248874 != 0)) goto LAB_0019871c;\n    }\n    else {\njoined_r0x00198731:\n      if (((((pcVar2 == (char *)0x0) || (*pcVar9 != *pcVar6)) ||\n           (iVar3 = strcmp(pcVar9,pcVar6), iVar3 != 0)) ||\n          ((iVar3 = absolute_pathname(pcVar9), iVar3 != 0 ||\n           (iVar3 = absolute_program(*ppcVar4), iVar3 != 0)))) ||\n         ((**ppcVar4 == '~' || (iVar3 = FUN_00192190(), iVar3 == 0)))) goto LAB_00198554;\n    }\nLAB_00198518:\n    rl_completion_suppress_append = 1;\n    rl_filename_completion_desired = 0;\n  }\nLAB_00198554:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return ppcVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_insert_text": "\nulong rl_insert_text(char *param_1)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  size_t sVar3;\n  long lVar4;\n  long lVar5;\n  ulong uVar6;\n  \n  if (param_1 != (char *)0x0) {\n    uVar6 = 0;\n    if (*param_1 != '\\0') {\n      sVar3 = strlen(param_1);\n      iVar2 = (int)sVar3;\n      uVar6 = sVar3 & 0xffffffff;\n      if (iVar2 != 0) {\n        if (rl_line_buffer_len <= rl_end + iVar2) {\n          rl_extend_line_buffer();\n        }\n        lVar4 = (long)rl_end;\n        if (rl_point <= rl_end) {\n          do {\n            puVar1 = (undefined *)(rl_line_buffer + lVar4);\n            lVar5 = rl_line_buffer + lVar4;\n            lVar4 = lVar4 + -1;\n            *(undefined *)(lVar5 + (int)uVar6) = *puVar1;\n          } while (rl_point <= (int)lVar4);\n        }\n        strncpy((char *)(rl_point + rl_line_buffer),param_1,(long)iVar2);\n        if (_rl_doing_an_undo == 0) {\n          if ((((iVar2 == 1) && (rl_undo_list != 0)) && (*(int *)(rl_undo_list + 0x18) == 1)) &&\n             ((*(int *)(rl_undo_list + 0xc) == rl_point &&\n              (rl_point - *(int *)(rl_undo_list + 8) < 0x14)))) {\n            *(int *)(rl_undo_list + 0xc) = rl_point + 1;\n          }\n          else {\n            rl_add_undo(1,rl_point,rl_point + iVar2,0);\n          }\n        }\n        rl_point = rl_point + iVar2;\n        rl_end = iVar2 + rl_end;\n        *(undefined *)(rl_line_buffer + rl_end) = 0;\n      }\n    }\n    return uVar6;\n  }\n  return 0;\n}\n\n",
  "_rl_find_prev_mbchar_internal": "\nint _rl_find_prev_mbchar_internal(char *param_1,int param_2,int param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  byte bVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  size_t sVar7;\n  int iVar8;\n  long lVar9;\n  int unaff_EBP;\n  int iVar10;\n  int iVar11;\n  long in_FS_OFFSET;\n  wchar_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (_rl_utf8locale == 0) {\n    local_48.__count = 0;\n    local_48.__value = (_union_27)0x0;\n    iVar8 = 0;\n    iVar10 = iVar8;\n    if (-1 < param_2) {\n      sVar7 = strlen(param_1);\n      iVar6 = (int)sVar7;\n      iVar10 = iVar6;\n      if ((param_2 <= iVar6) && (iVar10 = iVar8, 0 < param_2)) {\n        iVar4 = 0;\n        iVar11 = 0;\n        do {\n          iVar2 = iVar11;\n          if ((iVar4 == 0) || (cVar1 = param_1[iVar11], cVar1 < '\\0')) {\n            sVar7 = mbrtowc(&local_4c,param_1 + iVar11,(long)(iVar6 - iVar11),&local_48);\n            if (sVar7 < 0xfffffffffffffffe) {\n              iVar10 = iVar8;\n              if (sVar7 != 0) {\n                iVar10 = (int)sVar7;\n                goto joined_r0x001f6729;\n              }\n              break;\n            }\n            local_48.__count = 0;\n            local_48.__value = (_union_27)0x0;\n            iVar10 = 1;\n            iVar4 = _rl_utf8locale;\n          }\n          else {\n            iVar10 = 1;\n            local_48.__count = 0;\n            local_48.__value = (_union_27)0x0;\n            local_4c = (int)cVar1;\njoined_r0x001f6729:\n            iVar4 = _rl_utf8locale;\n            if (param_3 != 0) {\n              if (local_4c < L'`') {\n                if (local_4c < L'A') {\n                  if (local_4c < L'$') {\n                    if (local_4c < L' ') {\nLAB_001f677a:\n                      iVar5 = wcwidth(local_4c);\n                      iVar2 = iVar8;\n                      iVar4 = _rl_utf8locale;\n                      if (iVar5 != 0) {\n                        iVar2 = iVar11;\n                      }\n                    }\n                  }\n                  else if (0x1a < (uint)(local_4c + L'\\xffffffdb')) goto LAB_001f677a;\n                }\n              }\n              else if (0x1d < (uint)(local_4c + L'\\xffffff9f')) goto LAB_001f677a;\n            }\n          }\n          iVar8 = iVar2;\n          iVar11 = iVar11 + iVar10;\n          iVar10 = iVar8;\n          _rl_utf8locale = iVar4;\n        } while (iVar11 < param_2);\n      }\n    }\n  }\n  else {\n    if ((((param_3 != 0) && (unaff_EBP = 0, param_1 != (char *)0x0)) && (*param_1 != '\\0')) &&\n       ((unaff_EBP = 1, param_1[1] != '\\0' && (unaff_EBP = 2, param_1[2] != '\\0')))) {\n      sVar7 = strlen(param_1);\n      unaff_EBP = (int)sVar7;\n    }\n    iVar10 = param_2 + -1;\n    if (-1 < iVar10) {\n      do {\n        if (-1 < param_1[iVar10]) goto LAB_001f6798;\n        bVar3 = param_1[iVar10] & 0xc0;\n        iVar8 = iVar10;\n        if (bVar3 == 0x80) {\n          lVar9 = (long)(iVar10 + -1);\n          do {\n            if (lVar9 == -1) goto LAB_001f6798;\n            iVar8 = (int)lVar9;\n            if (param_1[lVar9] == 0) goto LAB_001f6798;\n            bVar3 = param_1[lVar9] & 0xc0;\n            lVar9 = lVar9 + -1;\n          } while (bVar3 == 0x80);\n        }\n        if ((bVar3 != 0xc0) || (iVar10 = iVar8, param_3 == 0)) goto LAB_001f6798;\n        local_48.__count = 0;\n        local_48.__value = (_union_27)0x0;\n        sVar7 = mbrtowc(&local_4c,param_1 + iVar8,(long)(unaff_EBP - iVar8),&local_48);\n        if (0xfffffffffffffffc < sVar7 - 1) goto LAB_001f6798;\n        if (local_4c < L'`') {\n          if (L'@' < local_4c) goto LAB_001f6798;\n          if (local_4c < L'$') {\n            if (L'\\x1f' < local_4c) goto LAB_001f6798;\n          }\n          else if ((uint)(local_4c + L'\\xffffffdb') < 0x1b) goto LAB_001f6798;\n        }\n        else if ((uint)(local_4c + L'\\xffffff9f') < 0x1e) goto LAB_001f6798;\n        iVar6 = wcwidth(local_4c);\n        if (0 < iVar6) goto LAB_001f6798;\n        iVar10 = iVar8 + -1;\n      } while (iVar8 != 0);\n    }\n    iVar10 = 0;\n  }\nLAB_001f6798:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar10;\n}\n\n",
  "FUN_001d44a0": "\nint FUN_001d44a0(char *param_1,int param_2,undefined4 param_3,int param_4,int *param_5)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  int iVar3;\n  \n  if (-1 < param_2) {\n    uVar2 = where_history();\n    iVar3 = history_set_pos(param_2);\n    if (iVar3 != 0) {\n      rl_readline_state = rl_readline_state | 0x200;\n      if (param_4 == 0) {\n        if (*param_1 == '^') {\n          iVar3 = history_search_prefix(param_1 + 1,param_3);\n        }\n        else {\n          iVar3 = history_search(param_1,param_3);\n        }\n      }\n      else {\n        cVar1 = *param_1;\n        if (cVar1 == '^') {\n          param_1 = param_1 + 1;\n        }\n        iVar3 = _hs_history_patsearch(param_1,param_3,cVar1 == '^');\n      }\n      rl_readline_state = rl_readline_state & 0xfffffffffffffdff;\n      *param_5 = iVar3;\n      if (iVar3 != -1) {\n        iVar3 = where_history();\n      }\n      history_set_pos(uVar2);\n      return iVar3;\n    }\n  }\n  return -1;\n}\n\n",
  "mkstemp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_mkstemp_00237c30)();\n  return iVar1;\n}\n\n",
  "rl_get_keymap_name_from_edit_mode": "\nchar * rl_get_keymap_name_from_edit_mode(void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = \"emacs\";\n  if ((rl_editing_mode != 1) && (pcVar1 = \"vi\", rl_editing_mode != 0)) {\n    pcVar1 = \"none\";\n  }\n  return pcVar1;\n}\n\n",
  "FUN_00191750": "\nchar * FUN_00191750(char *param_1,char *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  size_t sVar3;\n  char *pcVar4;\n  size_t sVar5;\n  char *pcVar6;\n  size_t sVar7;\n  char *__dest;\n  char *__s;\n  long in_FS_OFFSET;\n  char *local_48;\n  long local_40;\n  \n  pcVar4 = (char *)0x0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar3 = strlen(param_1);\n  if (param_2 != (char *)0x0) {\n    pcVar4 = (char *)FUN_00191560(param_2,0);\n  }\n  sVar5 = strlen(pcVar4);\n  pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"bashline.c\",0xcbf);\n  local_48 = strcpy(pcVar6,pcVar4);\n  if (rl_directory_rewrite_hook == (code *)0x0) {\nLAB_001917dc:\n    if (rl_directory_completion_hook != (code *)0x0) {\n      iVar1 = (*rl_directory_completion_hook)(&local_48);\n      if (iVar1 != 0) {\n        sh_xfree(pcVar4,\"bashline.c\",0xcc8);\n        pcVar6 = local_48;\n        goto LAB_0019181a;\n      }\n    }\n    if (rl_completion_found_quote == 0) {\n      sh_xfree(local_48,\"bashline.c\",0xcd3);\n      pcVar6 = pcVar4;\n    }\n    else {\n      pcVar6 = (char *)FUN_00191560(local_48,rl_completion_quote_character);\n      sh_xfree(pcVar4,\"bashline.c\",0xcce);\n      sh_xfree(local_48,\"bashline.c\",0xccf);\n    }\n  }\n  else {\n    iVar1 = (*rl_directory_rewrite_hook)(&local_48);\n    if (iVar1 == 0) goto LAB_001917dc;\n    sh_xfree(pcVar4,\"bashline.c\",0xcc3);\n    pcVar6 = local_48;\n  }\nLAB_0019181a:\n  sVar5 = strlen(pcVar6);\n  pcVar4 = (char *)bash_tilde_expand(param_2,0);\n  sVar7 = strlen(pcVar4);\n  iVar1 = (int)sVar7;\n  if ((*param_2 == '~') && (*pcVar4 == '~')) {\n    iVar2 = strcmp(param_2,pcVar4);\n    if (iVar2 != 0) goto LAB_00191854;\n    __s = (char *)mbschr(param_1,0x2f);\n    if (__s == (char *)0x0) {\n      __dest = (char *)sh_xmalloc((long)(iVar1 + 2),\"bashline.c\",0xc86);\n      strcpy(__dest,param_2);\n    }\n    else {\n      iVar2 = iVar1;\n      if (((*__s != '\\0') && (iVar2 = iVar1 + 1, __s[1] != '\\0')) &&\n         (iVar2 = iVar1 + 2, __s[2] != '\\0')) {\n        sVar3 = strlen(__s);\n        iVar2 = (int)sVar3 + iVar1;\n      }\n      __dest = (char *)sh_xmalloc((long)(iVar2 + 2),\"bashline.c\",0xc86);\n      strcpy(__dest,param_2);\n      if (*__s != '\\0') {\n        strcpy(__dest + iVar1,__s);\n      }\n    }\n    sh_xfree(pcVar6,\"bashline.c\",0xc8b);\n    sh_xfree(pcVar4,\"bashline.c\",0xc8c);\n  }\n  else {\nLAB_00191854:\n    sh_xfree(pcVar4,\"bashline.c\",0xc90);\n    iVar2 = (int)sVar3 - iVar1;\n    if (iVar2 + 1 < 1) {\n      sh_xfree(pcVar6,\"bashline.c\",0xc9c);\n      sVar3 = strlen(param_1);\n      pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"bashline.c\",0xc9d);\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        pcVar4 = strcpy(pcVar4,param_1);\n        return pcVar4;\n      }\n      goto LAB_00191ad4;\n    }\n    __dest = (char *)sh_xmalloc((long)(iVar2 + 3 + (int)sVar5),\"bashline.c\",0xca0);\n    strcpy(__dest,pcVar6);\n    strcpy(__dest + (int)sVar5,param_1 + iVar1);\n    sh_xfree(pcVar6,\"bashline.c\",0xca4);\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return __dest;\n  }\nLAB_00191ad4:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "utf8_mbscmp": "\nvoid utf8_mbscmp(char *param_1,char *param_2)\n\n{\n  strcmp(param_1,param_2);\n  return;\n}\n\n",
  "FUN_00134320": "\nvoid FUN_00134320(void)\n\n{\n  write(1,&DAT_001fa5e0,0x2a);\n  bash_logout();\n                    /* WARNING: Subroutine does not return */\n  jump_to_top_level(3);\n}\n\n",
  "FUN_00192600": "\nvoid FUN_00192600(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  uVar3 = rl_completion_entry_function;\n  uVar2 = rl_attempted_completion_function;\n  uVar1 = rl_ignore_some_completions_function;\n  rl_completion_entry_function = FUN_00192370;\n  rl_ignore_some_completions_function = FUN_00191d90;\n  rl_attempted_completion_function = 0;\n  if (rl_last_func == FUN_00192600) {\n    rl_complete_internal(0x3f);\n  }\n  else {\n    rl_complete_internal(9);\n  }\n  rl_completion_entry_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar2;\n  rl_ignore_some_completions_function = (code *)uVar1;\n  return;\n}\n\n",
  "bashline_reinitialize": "\nvoid bashline_reinitialize(void)\n\n{\n  bash_readline_initialized = 0;\n  return;\n}\n\n",
  "rl_invoking_keyseqs_in_map": "\nlong rl_invoking_keyseqs_in_map(long param_1,long param_2)\n\n{\n  undefined4 *puVar1;\n  ushort uVar2;\n  ushort *puVar3;\n  char **ppcVar4;\n  ulong uVar5;\n  size_t sVar6;\n  undefined4 *__dest;\n  long lVar7;\n  long lVar8;\n  undefined8 uVar9;\n  ushort **ppuVar10;\n  __int32_t **pp_Var11;\n  __int32_t *p_Var12;\n  undefined4 *puVar13;\n  char **ppcVar14;\n  long lVar15;\n  int iVar16;\n  uint uVar17;\n  char *__s;\n  undefined uVar18;\n  uint uVar19;\n  int iVar20;\n  long *plVar21;\n  bool bVar22;\n  int local_84;\n  \n  lVar8 = 0;\n  iVar20 = 0;\n  plVar21 = (long *)(param_2 + 8);\n  uVar19 = 0;\n  local_84 = 0;\n  do {\n    if (*(byte *)(plVar21 + -1) == 1) {\n      if ((*plVar21 != 0) &&\n         (ppcVar4 = (char **)rl_invoking_keyseqs_in_map(param_1), ppcVar4 != (char **)0x0)) {\n        __s = *ppcVar4;\n        if (__s != (char *)0x0) {\n          uVar5 = (ulong)(uVar19 & 0xff | 0x40);\n          lVar15 = (long)iVar20 << 3;\n          ppcVar14 = ppcVar4;\n          do {\n            sVar6 = strlen(__s);\n            __dest = (undefined4 *)xmalloc(sVar6 + 6);\n            if (uVar19 == 0x1b) {\n              if ((_rl_convert_meta_chars_to_ascii == 0) || (*(char *)(param_2 + 0x1b0) != '\\x01'))\n              {\n                *(undefined *)((long)__dest + 2) = 0;\n                *(undefined2 *)__dest = 0x655c;\n              }\n              else {\n                *__dest = 0x2d4d5c;\n              }\n            }\n            else {\n              if ((uVar19 == 0x7f) || ((int)uVar19 < 0x20)) {\n                *(undefined *)((long)__dest + 2) = 0x2d;\n                puVar13 = (undefined4 *)((long)__dest + 3);\n                *(undefined2 *)__dest = 0x435c;\n                if (uVar19 != 0x7f) {\n                  ppuVar10 = __ctype_b_loc();\n                  puVar3 = *ppuVar10;\n                  uVar2 = puVar3[uVar5];\n                  if ((uVar2 & 0x200) == 0) {\n                    if ((uVar2 & 0x100) == 0) {\n                      lVar7 = 4;\n                      bVar22 = false;\n                      iVar16 = 4;\n                      uVar17 = uVar19 | 0x40;\n                      uVar18 = (char)(uVar19 | 0x40);\n                      goto LAB_001de8dd;\n                    }\n                    pp_Var11 = __ctype_tolower_loc();\n                    p_Var12 = *pp_Var11;\n                    lVar7 = uVar5 * 4;\nLAB_001dea53:\n                    uVar17 = *(uint *)((long)p_Var12 + lVar7);\n                  }\n                  else {\n                    pp_Var11 = __ctype_toupper_loc();\n                    uVar17 = (*pp_Var11)[uVar5];\n                    if ((*(byte *)((long)puVar3 + (ulong)(uVar17 & 0xff) * 2 + 1) & 1) != 0) {\n                      pp_Var11 = __ctype_tolower_loc();\n                      p_Var12 = *pp_Var11;\n                      lVar7 = (ulong)(uVar17 & 0xff) << 2;\n                      goto LAB_001dea53;\n                    }\n                  }\n                  bVar22 = uVar17 == 0x22;\n                  lVar7 = 4;\n                  iVar16 = 4;\n                  uVar18 = (char)uVar17;\n                  goto LAB_001de8dd;\n                }\n                lVar7 = 4;\n                uVar18 = 0x3f;\n              }\n              else {\n                bVar22 = uVar19 == 0x22;\n                lVar7 = 1;\n                iVar16 = 1;\n                puVar13 = __dest;\n                uVar17 = uVar19;\n                uVar18 = (char)uVar19;\nLAB_001de8dd:\n                if ((uVar17 == 0x5c) || (bVar22)) {\n                  puVar1 = (undefined4 *)((long)__dest + lVar7);\n                  *(undefined *)puVar13 = 0x5c;\n                  lVar7 = (long)(iVar16 + 1);\n                  puVar13 = puVar1;\n                }\n              }\n              *(undefined *)puVar13 = uVar18;\n              *(undefined *)((long)__dest + lVar7) = 0;\n            }\n            iVar20 = iVar20 + 1;\n            strcat((char *)__dest,*ppcVar14);\n            xfree(*ppcVar14);\n            if (local_84 <= iVar20) {\n              local_84 = local_84 + 10;\n              lVar8 = xrealloc(lVar8,(long)local_84 << 3);\n            }\n            *(undefined4 **)(lVar8 + lVar15) = __dest;\n            ppcVar14 = ppcVar14 + 1;\n            lVar15 = lVar15 + 8;\n            *(undefined8 *)(lVar8 + lVar15) = 0;\n            __s = *ppcVar14;\n          } while (__s != (char *)0x0);\n        }\n        xfree(ppcVar4);\n      }\n    }\n    else if (((*(byte *)(plVar21 + -1) & 0xfd) == 0) && (*plVar21 == param_1)) {\n      uVar9 = FUN_001da360(uVar19);\n      if (local_84 <= iVar20 + 1) {\n        local_84 = local_84 + 10;\n        lVar8 = xrealloc(lVar8,(long)local_84 << 3);\n      }\n      *(undefined8 *)(lVar8 + (long)iVar20 * 8) = uVar9;\n      *(undefined8 *)(lVar8 + 8 + (long)iVar20 * 8) = 0;\n      iVar20 = iVar20 + 1;\n    }\n    uVar19 = uVar19 + 1;\n    plVar21 = plVar21 + 2;\n    if (uVar19 == 0x101) {\n      return lVar8;\n    }\n  } while( true );\n}\n\n",
  "bash_history_enable": "\nvoid bash_history_enable(void)\n\n{\n  enable_history_list = 1;\n  remember_on_history = 1;\n  history_expansion_inhibited = 0;\n  history_inhibit_expansion_function = FUN_00190570;\n  sv_history_control(\"HISTCONTROL\");\n  sv_histignore(\"HISTIGNORE\");\n  return;\n}\n\n",
  "find_global_variable": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong find_global_variable(undefined8 param_1)\n\n{\n  long *plVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long lVar4;\n  \n  lVar4 = global_variables;\n  if (global_variables != 0) {\n    do {\n      uVar2 = *(undefined8 *)(lVar4 + 0x20);\n      lVar3 = hash_search(param_1,uVar2,0);\n      if ((lVar3 != 0) && (lVar3 = *(long *)(lVar3 + 0x10), _DAT_002422f8 = uVar2, lVar3 != 0)) {\n        if (((*(byte *)(lVar3 + 0x29) & 8) != 0) && (lVar3 = find_variable_nameref(), lVar3 == 0)) {\n          return 0;\n        }\n        if (*(code **)(lVar3 + 0x18) != (code *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00153763. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          lVar4 = (**(code **)(lVar3 + 0x18))();\n          return lVar4;\n        }\n        return lVar3;\n      }\n      plVar1 = (long *)(lVar4 + 0x18);\n      lVar4 = *plVar1;\n    } while (*plVar1 != 0);\n  }\n  return 0;\n}\n\n",
  "pop_args": "\nvoid pop_args(void)\n\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  long local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = find_variable(\"BASH_ARGV\");\n  if (lVar2 != 0) {\n    if ((*(byte *)(lVar2 + 0x28) & 4) == 0) {\n      lVar2 = 0;\n    }\n    else {\n      lVar2 = *(long *)(lVar2 + 8);\n    }\n  }\n  lVar3 = find_variable(\"BASH_ARGC\");\n  if (lVar3 != 0) {\n    if ((*(byte *)(lVar3 + 0x28) & 4) == 0) {\n      lVar3 = 0;\n    }\n    else {\n      lVar3 = *(long *)(lVar3 + 8);\n    }\n  }\n  lVar3 = array_unshift_element(lVar3);\n  if ((lVar3 == 0) || (iVar1 = legal_number(*(undefined8 *)(lVar3 + 8),&local_28), iVar1 == 0)) {\n    local_28 = 0;\n  }\n  else {\n    for (; 0 < local_28; local_28 = local_28 + -1) {\n      array_shift(lVar2,1,1);\n    }\n  }\n  array_dispose_element(lVar3);\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "FUN_001a8700": "\nvoid FUN_001a8700(void)\n\n{\n  remember_on_history = enable_history_list;\n  return;\n}\n\n",
  "skipsubscript": "\nvoid skipsubscript(void)\n\n{\n  FUN_0016af90();\n  return;\n}\n\n",
  "strlist_append": "\nlong * strlist_append(long *param_1,long *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  size_t sVar3;\n  char *__dest;\n  char *__s;\n  long lVar4;\n  long *plVar5;\n  long lVar6;\n  long lVar7;\n  int local_3c;\n  \n  if (param_1 == (long *)0x0) {\n    if (param_2 != (long *)0x0) {\n      plVar5 = (long *)strlist_copy(param_2);\n      return plVar5;\n    }\n  }\n  else if (param_2 != (long *)0x0) {\n    iVar1 = *(int *)((long)param_2 + 0xc);\n    if (iVar1 != 0) {\n      local_3c = *(int *)((long)param_1 + 0xc);\n      iVar2 = local_3c + iVar1;\n      param_1 = (long *)strlist_resize(param_1,iVar2 + 1);\n      if (iVar1 < 1) {\n        lVar4 = *param_1;\n      }\n      else {\n        lVar6 = (long)local_3c;\n        lVar7 = 0;\n        do {\n          __s = *(char **)(*param_2 + lVar7);\n          if (__s != (char *)0x0) {\n            sVar3 = strlen(__s);\n            __dest = (char *)sh_xmalloc(sVar3 + 1,\"stringlist.c\",0xb7);\n            __s = strcpy(__dest,__s);\n          }\n          lVar4 = *param_1;\n          *(char **)(lVar4 + lVar6 * 8 + lVar7) = __s;\n          lVar7 = lVar7 + 8;\n          local_3c = iVar2;\n        } while ((long)iVar1 * 8 != lVar7);\n      }\n      *(undefined8 *)(lVar4 + (long)local_3c * 8) = 0;\n      *(int *)((long)param_1 + 0xc) = local_3c;\n    }\n  }\n  return param_1;\n}\n\n",
  "decode_signal": "\nulong decode_signal(char *param_1,uint param_2)\n\n{\n  char cVar1;\n  char *__s2;\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  long in_FS_OFFSET;\n  ulong local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = legal_number(param_1,&local_48);\n  if (iVar2 != 0) {\n    uVar4 = 0xffffffffffffffff;\n    if (local_48 < 0x41) {\n      uVar4 = local_48;\n    }\n    goto LAB_00181a3a;\n  }\n  cVar1 = *param_1;\n  if (cVar1 == 'S') {\n    iVar2 = strncmp(param_1,\"SIGRTMIN+\",9);\n    if (iVar2 != 0) {\n      if ((param_2 & 2) == 0) goto LAB_00181ad1;\n      iVar2 = strncasecmp(param_1,\"SIGRTMIN+\",9);\n      if (iVar2 != 0) goto LAB_00181bbc;\n    }\nLAB_001819f4:\n    iVar2 = legal_number(param_1 + 9,&local_48);\njoined_r0x00181a03:\n    if ((iVar2 != 0) && (-1 < (long)local_48)) {\n      iVar2 = __libc_current_sigrtmax();\n      iVar3 = __libc_current_sigrtmin();\n      if ((long)local_48 <= (long)(iVar2 - iVar3)) {\n        iVar2 = __libc_current_sigrtmin();\n        uVar4 = (ulong)(uint)(iVar2 + (int)local_48);\n        goto LAB_00181a3a;\n      }\n    }\n  }\n  else {\n    if ((param_2 & 2) != 0) {\n      iVar2 = strncasecmp(param_1,\"SIGRTMIN+\",9);\n      if (iVar2 == 0) goto LAB_001819f4;\n      if ((cVar1 != 'R') || (iVar2 = strncmp(param_1,\"RTMIN+\",6), iVar2 != 0)) {\nLAB_00181bbc:\n        iVar2 = strncasecmp(param_1,\"RTMIN+\",6);\n        if (iVar2 != 0) goto LAB_00181ad1;\n      }\nLAB_00181bd1:\n      iVar2 = legal_number(param_1 + 6,&local_48);\n      goto joined_r0x00181a03;\n    }\n    if ((cVar1 == 'R') && (iVar2 = strncmp(param_1,\"RTMIN+\",6), iVar2 == 0)) goto LAB_00181bd1;\nLAB_00181ad1:\n    local_48 = 0;\nLAB_00181b0e:\n    do {\n      uVar4 = local_48;\n      __s2 = (&signal_names)[local_48];\n      if ((__s2 != (char *)0x0) && (*__s2 != '\\0')) {\n        if ((*__s2 == 'S') && ((__s2[1] == 'I' && (__s2[2] == 'G')))) {\n          if ((param_2 & 2) == 0) {\n            iVar2 = strcmp(param_1,__s2 + 3);\n            if (iVar2 != 0) {\n              if ((param_2 & 1) != 0) {\n                iVar2 = strcmp(param_1,__s2);\n                goto joined_r0x00181ba7;\n              }\n              goto LAB_00181aff;\n            }\n          }\n          else {\n            iVar2 = strcasecmp(param_1,__s2 + 3);\n            if (iVar2 != 0) {\n              if ((param_2 & 1) != 0) goto LAB_00181af0;\n              local_48 = uVar4 + 1;\n              if (local_48 == 0x44) break;\n              goto LAB_00181b0e;\n            }\n          }\n        }\n        else {\n          if ((param_2 & 2) == 0) {\n            iVar2 = strcmp(param_1,__s2);\n          }\n          else {\nLAB_00181af0:\n            iVar2 = strcasecmp(param_1,__s2);\n          }\njoined_r0x00181ba7:\n          if (iVar2 != 0) goto LAB_00181aff;\n        }\n        uVar4 = uVar4 & 0xffffffff;\n        goto LAB_00181a3a;\n      }\nLAB_00181aff:\n      local_48 = uVar4 + 1;\n    } while (local_48 != 0x44);\n  }\n  uVar4 = 0xffffffff;\nLAB_00181a3a:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n",
  "previous_history": "\nundefined8 previous_history(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = 0;\n  if (history_offset != 0) {\n    history_offset = history_offset + -1;\n    uVar1 = *(undefined8 *)(DAT_0024b6e8 + (long)history_offset * 8);\n  }\n  return uVar1;\n}\n\n",
  "split_at_delims": "\nlong * split_at_delims(char *param_1,int param_2,char *param_3,int param_4,uint param_5,int *param_6\n                      ,int *param_7)\n\n{\n  mbstate_t mVar1;\n  int iVar2;\n  mbstate_t mVar3;\n  char cVar4;\n  size_t __n;\n  size_t sVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  long *plVar8;\n  bool bVar9;\n  ulong uVar10;\n  int iVar11;\n  int iVar12;\n  char *pcVar13;\n  long lVar14;\n  undefined *puVar15;\n  char *pcVar16;\n  int iVar17;\n  char *pcVar18;\n  long in_FS_OFFSET;\n  bool bVar19;\n  char *local_b0;\n  long *local_98;\n  int local_8c;\n  int local_88;\n  undefined *local_78;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_1 == (char *)0x0) || (cVar4 = *param_1, cVar4 == '\\0')) {\n    if (param_6 != (int *)0x0) {\n      *param_6 = 0;\n    }\n    if (param_7 != (int *)0x0) {\n      *param_7 = 0;\n    }\n    goto LAB_0016deab;\n  }\n  if (param_3 == (char *)0x0) {\n    local_78 = (undefined *)0x0;\n    pcVar16 = ifs_value;\nLAB_0016db8b:\n    uVar10 = 0;\n    pcVar13 = param_1;\n    do {\n      lVar14 = mbschr(pcVar16,(int)cVar4);\n      cVar4 = *pcVar13;\n      if ((lVar14 == 0) || ((1 < (byte)(cVar4 - 9U) && (cVar4 != ' ')))) {\n        if (cVar4 != '\\0') {\n          local_88 = 0;\n          local_98 = (long *)0x0;\n          local_8c = -1;\n          goto LAB_0016dc20;\n        }\n        break;\n      }\n      cVar4 = pcVar13[1];\n      pcVar13 = pcVar13 + 1;\n      uVar10 = (ulong)((int)uVar10 + 1);\n    } while (cVar4 != '\\0');\n  }\n  else {\n    local_48.__count = 0;\n    local_48.__value = (_union_27)0x0;\n    __n = strlen(param_3);\n    local_78 = (undefined *)sh_xmalloc(__n + 1,\"subst.c\",0xa4d);\n    puVar15 = local_78;\n    if (*param_3 != '\\0') {\n      iVar11 = 0;\n      iVar17 = 0;\n      lVar14 = 0;\n      pcVar16 = param_3;\n      do {\n        mVar1 = local_48;\n        sVar5 = __ctype_get_mb_cur_max();\n        mVar3 = local_48;\n        if (((sVar5 < 2) ||\n            (sVar5 = mbrtowc((wchar_t *)0x0,pcVar16,__n,&local_48), mVar3 = mVar1,\n            0xfffffffffffffffd < sVar5)) || (mVar3 = local_48, sVar5 < 2)) {\n          local_48 = mVar3;\n          cVar4 = *pcVar16;\n          if ((cVar4 != ' ') && (cVar4 != '\\t')) {\n            local_78[lVar14] = cVar4;\n            iVar17 = iVar17 + 1;\n            lVar14 = (long)iVar17;\n          }\n          iVar11 = iVar11 + 1;\n          __n = __n - 1;\n        }\n        else {\n          memcpy(local_78 + lVar14,pcVar16,sVar5);\n          iVar17 = iVar17 + (int)sVar5;\n          iVar11 = iVar11 + (int)sVar5;\n          __n = __n - sVar5;\n          lVar14 = (long)iVar17;\n        }\n        pcVar16 = param_3 + iVar11;\n      } while (*pcVar16 != '\\0');\n      puVar15 = local_78 + lVar14;\n    }\n    *puVar15 = 0;\n    cVar4 = *param_1;\n    pcVar16 = param_3;\n    if (cVar4 != '\\0') goto LAB_0016db8b;\n  }\n  if (local_78 == (undefined *)0x0) {\nLAB_0016deab:\n    local_98 = (long *)0x0;\n  }\n  else {\n    sh_xfree(local_78,\"subst.c\",0xa71);\n    local_98 = (long *)0x0;\n  }\n  goto LAB_0016deb4;\nLAB_0016dc20:\n  iVar17 = (int)uVar10;\n  iVar11 = skip_to_delim(param_1,uVar10 & 0xffffffff,pcVar16,param_5 | 1);\n  if ((iVar17 == iVar11) && (local_78 != (undefined *)0x0)) {\n    if (param_1[iVar17] == '\\0') {\n      local_b0 = param_1 + iVar11;\n    }\n    else {\n      lVar14 = mbschr(local_78,(int)param_1[iVar17]);\n      if (lVar14 == 0) goto LAB_0016de38;\n      iVar11 = iVar17 + 1;\n      local_b0 = param_1 + iVar11;\n      cVar4 = *local_b0;\n      if (param_3 == (char *)0x0) {\n        if (cVar4 != '\\0') {\n          pcVar13 = param_1 + (long)iVar11 + 1;\n          pcVar18 = local_b0;\n          do {\n            local_b0 = pcVar13;\n            lVar14 = mbschr(pcVar16,(int)cVar4);\n            if ((lVar14 == 0) || ((1 < (byte)(*pcVar18 - 9U) && (*pcVar18 != ' ')))) {\n              local_b0 = param_1 + iVar11;\n              uVar10 = uVar10 & 0xffffffff;\n              goto LAB_0016dc6b;\n            }\n            cVar4 = *local_b0;\n            iVar11 = iVar11 + 1;\n            pcVar13 = local_b0 + 1;\n            pcVar18 = local_b0;\n          } while (cVar4 != '\\0');\n          uVar10 = uVar10 & 0xffffffff;\n        }\n      }\n      else if (cVar4 != '\\0') {\n        pcVar13 = param_1 + (long)iVar11 + 1;\n        pcVar18 = local_b0;\n        do {\n          local_b0 = pcVar13;\n          lVar14 = mbschr(local_78,(int)cVar4);\n          if ((lVar14 == 0) || (((param_5 & 4) != 0 && ((*pcVar18 == '\\'' || (*pcVar18 == '\\\"'))))))\n          {\n            uVar10 = uVar10 & 0xffffffff;\n            local_b0 = param_1 + iVar11;\n            goto LAB_0016dc6b;\n          }\n          cVar4 = *local_b0;\n          iVar11 = iVar11 + 1;\n          pcVar13 = local_b0 + 1;\n          pcVar18 = local_b0;\n        } while (cVar4 != '\\0');\n        uVar10 = uVar10 & 0xffffffff;\n      }\n    }\n  }\n  else {\nLAB_0016de38:\n    local_b0 = param_1 + iVar11;\n  }\nLAB_0016dc6b:\n  iVar12 = (int)uVar10;\n  uVar6 = substring(param_1,uVar10 & 0xffffffff,iVar11);\n  uVar7 = make_word(uVar6);\n  local_98 = (long *)make_word_list(uVar7,local_98);\n  sh_xfree(uVar6,\"subst.c\",0xa90);\n  bVar19 = param_7 != (int *)0x0;\n  iVar17 = local_88 + 1;\n  if ((((param_4 < iVar12) || (iVar2 = iVar17, iVar11 < param_4)) &&\n      (bVar9 = local_8c == -1 && bVar19, iVar2 = local_8c, local_8c == -1 && bVar19)) &&\n     (iVar2 = iVar17, bVar19 = bVar9, iVar12 + -1 != param_4)) {\n    if (param_4 < iVar12) {\n      lVar14 = *local_98;\n      uVar6 = make_word(&DAT_00213d70);\n      lVar14 = make_word_list(uVar6,lVar14);\n      *local_98 = lVar14;\n      iVar17 = local_88 + 2;\n    }\n    else {\n      local_8c = -1;\n      iVar2 = local_8c;\n    }\n  }\n  local_88 = iVar17;\n  local_8c = iVar2;\n  cVar4 = *local_b0;\n  if (cVar4 == '\\0') goto LAB_0016dd60;\n  uVar10 = (ulong)iVar11;\n  pcVar13 = local_b0;\n  pcVar18 = param_1 + uVar10 + 1;\n  while (lVar14 = mbschr(pcVar16,(int)cVar4), lVar14 != 0) {\n    if (((param_3 != (char *)0x0) && (cVar4 = *pcVar13, 1 < (byte)(cVar4 - 9U))) && (cVar4 != ' '))\n    goto LAB_0016dd50;\n    if (((param_5 & 4) != 0) && ((*local_b0 == '\\'' || (*local_b0 == '\\\"')))) break;\n    cVar4 = *pcVar18;\n    uVar10 = (ulong)((int)uVar10 + 1);\n    pcVar13 = pcVar18;\n    pcVar18 = pcVar18 + 1;\n    if (cVar4 == '\\0') goto LAB_0016dd60;\n  }\n  cVar4 = *pcVar13;\nLAB_0016dd50:\n  if (cVar4 == '\\0') goto LAB_0016dd60;\n  goto LAB_0016dc20;\nLAB_0016dd60:\n  if ((local_8c == -1) && (bVar19)) {\n    local_8c = -1;\n    if (iVar11 <= param_2) {\n      param_2 = iVar11;\n    }\n    if ((param_2 <= param_4) &&\n       ((param_1[(long)param_4 + -1] == ' ' ||\n        (local_8c = local_88, param_1[(long)param_4 + -1] == '\\t')))) {\n      uVar6 = make_word(&DAT_00213d70);\n      local_98 = (long *)make_word_list(uVar6,local_98);\n      local_8c = local_88 + 1;\n      local_88 = local_8c;\n    }\n  }\n  if (param_6 != (int *)0x0) {\n    *param_6 = local_88;\n  }\n  if (param_7 != (int *)0x0) {\n    *param_7 = local_8c;\n  }\n  if (local_78 != (undefined *)0x0) {\n    sh_xfree(local_78,\"subst.c\",0xac9);\n  }\n  if (local_98 == (long *)0x0) goto LAB_0016deab;\n  if (*local_98 != 0) {\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      plVar8 = (long *)list_reverse(local_98);\n      return plVar8;\n    }\n    goto LAB_0016e122;\n  }\nLAB_0016deb4:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_98;\n  }\nLAB_0016e122:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "getppid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__pid_t getppid(void)\n\n{\n  __pid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_getppid_00237de8)();\n  return _Var1;\n}\n\n",
  "bash_tilde_expand": "\nchar * bash_tilde_expand(char *param_1,int param_2)\n\n{\n  char cVar1;\n  byte bVar2;\n  size_t sVar3;\n  char *pcVar4;\n  \n  if (param_2 == 0) {\n    tilde_additional_prefixes = (undefined *)0x0;\n  }\n  else {\n    if (param_2 != 2) {\n      cVar1 = *param_1;\n      tilde_additional_prefixes = DAT_00240e98;\n      goto joined_r0x00142847;\n    }\n    tilde_additional_prefixes = DAT_00240e90;\n    tilde_additional_suffixes = DAT_00240e88;\n  }\n  cVar1 = *param_1;\njoined_r0x00142847:\n  pcVar4 = param_1;\n  if (cVar1 == '~') {\n    do {\n      bVar2 = pcVar4[1];\n      pcVar4 = pcVar4 + 1;\n      if ((bVar2 < 0x3b) && ((0xfbff7ffffffffffeU >> ((ulong)bVar2 & 0x3f) & 1) == 0))\n      goto LAB_0014284d;\n    } while ((0x3a < (byte)(bVar2 - 0x22)) ||\n            ((0x400000000000021U >> ((ulong)(bVar2 - 0x22) & 0x3f) & 1) == 0));\n    sVar3 = strlen(param_1);\n    pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"general.c\",0x4c4);\n    pcVar4 = strcpy(pcVar4,param_1);\n  }\n  else {\nLAB_0014284d:\n    pcVar4 = (char *)tilde_expand(param_1);\n  }\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state == 0) {\n    return pcVar4;\n  }\n  throw_to_top_level();\n  return pcVar4;\n}\n\n",
  "FUN_001ae4d0": "\nundefined4 FUN_001ae4d0(void)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  uVar2 = make_word();\n  uVar2 = make_word_list(uVar2,0);\n  uVar3 = make_word(\"--\");\n  uVar2 = make_word_list(uVar3,uVar2);\n  uVar1 = cd_builtin(uVar2);\n  dispose_words(uVar2);\n  return uVar1;\n}\n\n",
  "rl_clear_visible_line": "\nundefined8 rl_clear_visible_line(void)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  bool bVar4;\n  \n  _rl_cr();\n  _rl_last_c_pos = 0;\n  _rl_move_vert(_rl_vis_botlin);\n  iVar2 = _rl_last_v_pos;\n  if (_rl_last_v_pos < 0) {\n    return 0;\n  }\n  do {\n    while (_rl_move_vert(iVar2), iVar1 = _rl_screenwidth, _rl_term_clreol == 0) {\n      if (_rl_screenwidth == 0) goto LAB_001e1d91;\n      if (0 < _rl_screenwidth) {\n        iVar3 = 0;\n        do {\n          iVar3 = iVar3 + 1;\n          putc(0x20,rl_outstream);\n        } while (iVar1 != iVar3);\n      }\n      _rl_last_c_pos = _rl_last_c_pos + iVar1;\n      _rl_cr();\n      bVar4 = iVar2 == 0;\n      iVar2 = iVar2 + -1;\n      if (bVar4) {\n        return 0;\n      }\n    }\n    tputs(_rl_term_clreol,1,_rl_output_character_function);\nLAB_001e1d91:\n    _rl_cr();\n    bVar4 = iVar2 == 0;\n    iVar2 = iVar2 + -1;\n    if (bVar4) {\n      return 0;\n    }\n  } while( true );\n}\n\n",
  "shopt_listopt": "\nundefined8 shopt_listopt(char *param_1,int param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  undefined *puVar6;\n  undefined **ppuVar7;\n  int iVar8;\n  char *pcVar9;\n  undefined *puVar10;\n  \n  if (param_1 == (char *)0x0) {\n    piVar5 = &autocd;\n    puVar6 = &DAT_00210a30;\n    ppuVar7 = &PTR_s_assoc_expand_once_00236438;\n    while( true ) {\n      if (param_2 == 0) {\n        pcVar9 = \"off\";\n        if (*piVar5 != 0) {\n          pcVar9 = \"on\";\n        }\n        __printf_chk(1,\"%-15s\\t%s\\n\",puVar6,pcVar9);\n      }\n      else {\n        puVar10 = &DAT_00210a46;\n        if (*piVar5 != 0) {\n          puVar10 = &DAT_00210a43;\n        }\n        __printf_chk(1,\"shopt %s %s\\n\",puVar10,puVar6);\n      }\n      puVar6 = *ppuVar7;\n      if (puVar6 == (undefined *)0x0) break;\n      piVar5 = (int *)ppuVar7[1];\n      ppuVar7 = ppuVar7 + 3;\n    }\nLAB_001b756c:\n    uVar4 = sh_chkwrite(0);\n    return uVar4;\n  }\n  cVar1 = *param_1;\n  ppuVar7 = &PTR_s_assoc_expand_once_00236438;\n  iVar8 = 0;\n  cVar2 = 'a';\n  pcVar9 = \"autocd\";\n  do {\n    if (cVar1 == cVar2) {\n      iVar3 = strcmp(param_1,pcVar9);\n      if (iVar3 == 0) {\n        if (param_2 == 0) {\n          pcVar9 = \"on\";\n          if (*(int *)(&PTR_autocd_00236428)[(long)iVar8 * 3] == 0) {\n            pcVar9 = \"off\";\n          }\n          __printf_chk(1,\"%-15s\\t%s\\n\",param_1,pcVar9);\n        }\n        else {\n          puVar6 = &DAT_00210a43;\n          if (*(int *)(&PTR_autocd_00236428)[(long)iVar8 * 3] == 0) {\n            puVar6 = &DAT_00210a46;\n          }\n          __printf_chk(1,\"shopt %s %s\\n\",puVar6,param_1);\n        }\n        goto LAB_001b756c;\n      }\n    }\n    pcVar9 = *ppuVar7;\n    ppuVar7 = ppuVar7 + 3;\n    iVar8 = iVar8 + 1;\n    if (pcVar9 == (char *)0x0) {\n      builtin_error(\"%s: invalid shell option name\",param_1);\n      return 1;\n    }\n    cVar2 = *pcVar9;\n  } while( true );\n}\n\n",
  "remove_quoted_ifs": "\nundefined * remove_quoted_ifs(char *param_1)\n\n{\n  long lVar1;\n  mbstate_t mVar2;\n  int iVar3;\n  size_t sVar4;\n  undefined *puVar5;\n  size_t sVar6;\n  ulong uVar7;\n  byte bVar8;\n  long lVar9;\n  int iVar10;\n  byte *__s;\n  size_t sVar11;\n  long lVar12;\n  int iVar13;\n  undefined *puVar14;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar4 = strlen(param_1);\n  puVar5 = (undefined *)sh_xmalloc(sVar4 + 1,\"subst.c\",0x138e);\n  puVar14 = puVar5;\n  if (sVar4 != 0) {\n    iVar13 = 0;\n    iVar10 = 0;\n    uVar7 = 0;\n    do {\n      while( true ) {\n        mVar2 = local_48;\n        if (param_1[uVar7] == '\\x01') {\n          iVar10 = iVar10 + 1;\n          sVar11 = (size_t)iVar10;\n          __s = (byte *)(param_1 + sVar11);\n          if ((*__s == 0) || (*(char *)((long)&ifs_cmap + (ulong)*__s) == '\\0')) {\n            lVar9 = (long)iVar13;\n            iVar13 = iVar13 + 1;\n            puVar5[lVar9] = 1;\n          }\n          local_48 = mVar2;\n          if (sVar4 == sVar11) goto LAB_00171130;\n        }\n        else {\n          sVar11 = (size_t)iVar10;\n          __s = (byte *)(param_1 + sVar11);\n        }\n        lVar9 = (long)iVar13;\n        iVar10 = iVar10 + 1;\n        iVar13 = iVar13 + 1;\n        bVar8 = *__s;\n        if (locale_mb_cur_max < 2) break;\n        if ((*(uint *)(is_basic_table + (ulong)(bVar8 >> 5) * 4) >> (bVar8 & 0x1f) & 1) == 0) {\n          if ((locale_utf8locale == 0) || (sVar6 = 1, (char)bVar8 < '\\0')) {\n            sVar6 = mbrtowc((wchar_t *)0x0,(char *)__s,sVar4 - sVar11,&local_48);\n            if (0xfffffffffffffffd < sVar6) {\n              puVar5[lVar9] = *__s;\n              goto LAB_0017108b;\n            }\n            bVar8 = *__s;\n            if (sVar6 == 0) {\n              sVar6 = 1;\n            }\n          }\n        }\n        else {\n          sVar6 = 1;\n        }\n        lVar12 = sVar11 - lVar9;\n        lVar1 = sVar6 + lVar9;\n        while( true ) {\n          puVar5[lVar9] = bVar8;\n          lVar9 = lVar9 + 1;\n          if (lVar1 == lVar9) break;\n          bVar8 = param_1[lVar9 + lVar12];\n        }\n        iVar3 = (int)sVar6 + -1;\n        iVar10 = iVar10 + iVar3;\n        iVar13 = iVar13 + iVar3;\n        uVar7 = (ulong)iVar10;\n        if (sVar4 <= uVar7) goto LAB_00171130;\n      }\n      puVar5[lVar9] = bVar8;\nLAB_0017108b:\n      uVar7 = (ulong)iVar10;\n      local_48 = mVar2;\n    } while (uVar7 < sVar4);\nLAB_00171130:\n    puVar14 = puVar5 + iVar13;\n  }\n  *puVar14 = 0;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar5;\n}\n\n",
  "getc_with_restart": "\nulong getc_with_restart(FILE *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  ssize_t sVar3;\n  int *piVar4;\n  \n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  lVar2 = (long)DAT_00247f74;\n  if ((DAT_00247f74 == DAT_00247f70) || (DAT_00247f70 == 0)) {\n    while( true ) {\n      if (terminating_signal != 0) {\n        termsig_handler(terminating_signal);\n      }\n      if (interrupt_state != 0) {\n        throw_to_top_level();\n      }\n      run_pending_traps();\n      iVar1 = fileno(param_1);\n      sVar3 = read(iVar1,&DAT_00247f80,0x400);\n      DAT_00247f70 = (int)sVar3;\n      if (0 < DAT_00247f70) break;\n      if (DAT_00247f70 == 0) {\n        DAT_00247f74 = 0;\n        return 0xffffffff;\n      }\n      piVar4 = __errno_location();\n      if (*piVar4 == 0xb) {\n        iVar1 = fileno(param_1);\n        iVar1 = sh_unset_nodelay_mode(iVar1);\n        if (iVar1 < 0) {\n          iVar1 = fileno(param_1);\n          sys_error(\"cannot reset nodelay mode for fd %d\",iVar1);\n          DAT_00247f70 = 0;\n          DAT_00247f74 = 0;\n          return 0xffffffff;\n        }\n      }\n      else {\n        if (*piVar4 != 4) {\n          DAT_00247f70 = 0;\n          DAT_00247f74 = 0;\n          return 0xffffffff;\n        }\n        if ((interrupt_state != 0) || (terminating_signal != 0)) {\n          DAT_00247f70 = 0;\n          DAT_00247f74 = 0;\n        }\n      }\n    }\n    DAT_00247f74 = 1;\n    lVar2 = 0;\n  }\n  else {\n    DAT_00247f74 = DAT_00247f74 + 1;\n  }\n  return (ulong)(byte)(&DAT_00247f80)[lVar2];\n}\n\n",
  "unwind_protect_mem": "\nvoid unwind_protect_mem(void *param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  long lVar3;\n  \n  lVar3 = (long)(int)(param_2 + 0x1cU);\n  if (param_2 + 0x1cU < 0x20) {\n    lVar3 = 0x20;\n  }\n  puVar2 = (undefined8 *)sh_xmalloc(lVar3,\"unwind_prot.c\",0x15b);\n  uVar1 = DAT_00248390;\n  puVar2[2] = param_1;\n  *puVar2 = uVar1;\n  *(int *)(puVar2 + 3) = param_2;\n  puVar2[1] = FUN_00183ff0;\n  memcpy((void *)((long)puVar2 + 0x1c),param_1,(long)param_2);\n  DAT_00248390 = puVar2;\n  return;\n}\n\n",
  "_rl_overwrite_rubout": "\nundefined8 _rl_overwrite_rubout(int param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  \n  iVar1 = rl_point;\n  if (rl_point == 0) {\n    rl_ding();\n    return 1;\n  }\n  iVar4 = 0;\n  iVar2 = 0;\n  iVar3 = 0;\n  if (param_1 < 1) {\n    rl_begin_undo_group();\nLAB_001ef72c:\n    if (rl_explicit_arg == 0) {\n      rl_delete_text(iVar1,rl_point);\n      goto LAB_001ef744;\n    }\n  }\n  else {\n    do {\n      iVar3 = iVar3 + 1;\n      rl_backward_char(1,param_2);\n      iVar2 = rl_character_len((int)*(char *)(rl_line_buffer + rl_point),(long)rl_point);\n      iVar4 = iVar4 + iVar2;\n    } while (param_1 != iVar3);\n    rl_begin_undo_group();\n    iVar2 = iVar4;\n    if (param_1 < 2) goto LAB_001ef72c;\n  }\n  rl_kill_text(iVar1,rl_point);\nLAB_001ef744:\n  iVar1 = rl_point;\n  if ((rl_point < rl_end) && (0 < iVar2)) {\n    FUN_001ee210(iVar2,0x20);\n  }\n  rl_point = iVar1;\n  rl_end_undo_group();\n  return 0;\n}\n\n",
  "rl_char_search": "\nundefined8 rl_char_search(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if ((rl_readline_state._2_1_ & 8) == 0) {\n    uVar1 = FUN_001edf90(param_1,2,0xfffffffe);\n    return uVar1;\n  }\n  _rl_callback_data = _rl_callback_data_alloc();\n  *(undefined8 *)(_rl_callback_data + 4) = 0xfffffffe00000002;\n  _rl_callback_func = FUN_001ee020;\n  return 0;\n}\n\n",
  "rl_reset_after_signal": "\nvoid rl_reset_after_signal(void)\n\n{\n  if (rl_prep_term_function != (undefined *)0x0) {\n    (*(code *)rl_prep_term_function)(_rl_meta_flag);\n    rl_set_signals();\n    return;\n  }\n  rl_set_signals();\n  return;\n}\n\n",
  "ttattr": "\nundefined * ttattr(int param_1)\n\n{\n  undefined *puVar1;\n  \n  if (DAT_00249ee0 == 0) {\n    puVar1 = (undefined *)0x0;\n  }\n  else {\n    puVar1 = &DAT_00249f40;\n    if (param_1 != 0) {\n      puVar1 = &DAT_00249f00;\n      if (param_1 != 1) {\n        puVar1 = (undefined *)0x0;\n      }\n      return puVar1;\n    }\n  }\n  return puVar1;\n}\n\n",
  "fd_to_buffered_stream": "\nint * fd_to_buffered_stream(int param_1)\n\n{\n  int iVar1;\n  __off_t _Var2;\n  undefined8 uVar3;\n  int *piVar4;\n  long lVar5;\n  long in_FS_OFFSET;\n  stat sStack_c8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = fstat(param_1,&sStack_c8);\n  if (iVar1 < 0) {\n    piVar4 = (int *)0x0;\n    close(param_1);\n  }\n  else {\n    lVar5 = 1;\n    _Var2 = lseek(param_1,0,1);\n    if (-1 < _Var2) {\n      lVar5 = sStack_c8.st_size;\n      if (0x1fec < sStack_c8.st_size) {\n        lVar5 = 0x1fec;\n      }\n      if (lVar5 == 0) {\n        lVar5 = 1;\n      }\n    }\n    uVar3 = sh_xmalloc(lVar5,\"input.c\",0x195);\n    piVar4 = (int *)sh_xmalloc(0x30,\"input.c\",0xc1);\n    if (DAT_00247f64 <= param_1) {\n      FUN_00183470(param_1);\n    }\n    *(int **)(DAT_00247f68 + (long)param_1 * 8) = piVar4;\n    *piVar4 = param_1;\n    *(undefined8 *)(piVar4 + 2) = uVar3;\n    *(long *)(piVar4 + 4) = lVar5;\n    *(undefined8 *)(piVar4 + 10) = 0;\n    *(undefined8 *)(piVar4 + 6) = 0;\n    piVar4[8] = (uint)(lVar5 == 1) << 2;\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return piVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_downcase_word": "\nvoid rl_downcase_word(undefined8 param_1)\n\n{\n  FUN_001eedd0(param_1,2);\n  return;\n}\n\n",
  "rl_vi_start_inserting": "\nvoid rl_vi_start_inserting(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  DAT_0023b368 = param_3;\n  DAT_0023b36c = param_2;\n  _rl_vi_last_command = param_1;\n  rl_begin_undo_group();\n  DAT_0024a3c8 = param_1;\n  _rl_keymap = &vi_insertion_keymap;\n  if (_rl_show_mode_in_prompt == 0) {\n    return;\n  }\n  _rl_reset_prompt();\n  return;\n}\n\n",
  "duplicate_buffered_stream": "\nint duplicate_buffered_stream(int param_1,int param_2)\n\n{\n  uint *puVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  bool bVar5;\n  long *plVar6;\n  int *piVar7;\n  int **ppiVar8;\n  long lVar9;\n  long lVar10;\n  int iVar11;\n  int **ppiVar12;\n  bool bVar13;\n  long local_48;\n  \n  if (param_1 == param_2) {\n    return 0;\n  }\n  iVar11 = param_2;\n  if (param_2 <= param_1) {\n    iVar11 = param_1;\n  }\n  if (DAT_00247f64 <= iVar11) {\n    FUN_00183470();\n  }\n  lVar9 = DAT_00247f68;\n  bVar13 = bash_input != 4;\n  bVar5 = (int)DAT_00240a70 != param_2;\n  lVar10 = (long)param_2;\n  lVar2 = lVar10 * 8;\n  lVar3 = (long)param_1 * 8;\n  ppiVar8 = (int **)(DAT_00247f68 + lVar2);\n  plVar6 = (long *)(DAT_00247f68 + lVar3);\n  piVar7 = *ppiVar8;\n  if (piVar7 == (int *)0x0) {\nLAB_00183b6e:\n    local_48 = *plVar6;\n    ppiVar12 = ppiVar8;\n    if (local_48 != 0) goto LAB_00183b7f;\nLAB_00183c95:\n    piVar7 = (int *)0x0;\n    ppiVar12 = ppiVar8;\n  }\n  else {\n    if (((*plVar6 != 0) && (lVar4 = *(long *)(*plVar6 + 8), lVar4 != 0)) &&\n       (lVar4 == *(long *)(piVar7 + 2))) {\n      *ppiVar8 = (int *)0x0;\n      goto LAB_00183b6e;\n    }\n    if ((*(byte *)(piVar7 + 8) & 0x20) != 0) {\n      *(undefined8 *)(piVar7 + 2) = 0;\n      iVar11 = *piVar7;\n      sh_xfree(piVar7,\"input.c\",0x1b3);\n      lVar9 = DAT_00247f68;\n      ppiVar8 = (int **)(DAT_00247f68 + lVar2);\n      *(undefined8 *)(DAT_00247f68 + (long)iVar11 * 8) = 0;\n      plVar6 = (long *)(lVar9 + lVar3);\n      goto LAB_00183b6e;\n    }\n    free_buffered_stream();\n    ppiVar8 = (int **)(DAT_00247f68 + lVar2);\n    local_48 = *(long *)(DAT_00247f68 + lVar3);\n    lVar9 = DAT_00247f68;\n    ppiVar12 = ppiVar8;\n    if (local_48 == 0) goto LAB_00183c95;\nLAB_00183b7f:\n    piVar7 = (int *)sh_xmalloc(0x30,\"input.c\",0xd9);\n    xbcopy(local_48,piVar7,0x30);\n    ppiVar8 = (int **)(DAT_00247f68 + lVar2);\n    lVar9 = DAT_00247f68;\n  }\n  *ppiVar12 = piVar7;\n  piVar7 = *ppiVar8;\n  if (piVar7 == (int *)0x0) {\n    if (bVar13 || bVar5) goto LAB_00183bd9;\n    fd_to_buffered_stream(param_2);\n    piVar7 = *(int **)(DAT_00247f68 + lVar10 * 8);\n    lVar9 = DAT_00247f68;\n  }\n  else {\n    *piVar7 = param_2;\n    if (bVar13 || bVar5) goto LAB_00183bd9;\n  }\n  piVar7[8] = piVar7[8] | 8;\nLAB_00183bd9:\n  if ((((bash_input == 4) && (param_1 == (int)DAT_00240a70)) ||\n      ((interactive_shell == 0 && (param_1 == default_buffered_input)))) ||\n     ((lVar2 = *(long *)(lVar9 + (long)param_1 * 8), lVar2 != 0 &&\n      ((*(byte *)(lVar2 + 0x20) & 0x20) != 0)))) {\n    puVar1 = (uint *)(*(long *)(lVar9 + lVar10 * 8) + 0x20);\n    *puVar1 = *puVar1 | 0x20;\n  }\n  return param_2;\n}\n\n",
  "strdup": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strdup(char *__s)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strdup_00237e40)();\n  return pcVar1;\n}\n\n",
  "FUN_0017cc10": "\nundefined8 *\nFUN_0017cc10(char *param_1,long param_2,undefined8 param_3,long param_4,uint param_5,uint param_6,\n            undefined4 param_7)\n\n{\n  char *__s;\n  byte bVar1;\n  undefined8 *puVar2;\n  bool bVar3;\n  mbstate_t mVar4;\n  long *plVar5;\n  uint uVar6;\n  int iVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  size_t sVar10;\n  char *pcVar11;\n  ulong uVar12;\n  long lVar13;\n  undefined8 *puVar14;\n  undefined8 *puVar15;\n  undefined8 uVar16;\n  int iVar17;\n  ulong uVar18;\n  int iVar19;\n  int iVar20;\n  long *plVar21;\n  size_t sVar22;\n  uint uVar23;\n  char *pcVar24;\n  undefined8 *puVar25;\n  long in_FS_OFFSET;\n  size_t local_a0;\n  long local_70;\n  int local_64;\n  long *local_60;\n  long local_58;\n  mbstate_t local_4c;\n  undefined2 local_42;\n  long local_40;\n  \n  uVar16 = this_command_name;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_2 == 0) && (((*param_1 != '@' && (*param_1 != '*')) || (param_1[1] != '\\0'))))\n  goto LAB_0017cdb8;\n  this_command_name = param_1;\n  uVar6 = FUN_0017c800(param_1,param_2,param_3,param_5,param_7,&local_58,&local_60);\n  lVar13 = local_58;\n  plVar5 = local_60;\n  if (uVar6 == 0xffffffff) {\n    puVar15 = (undefined8 *)0x0;\n    this_command_name = (char *)uVar16;\n    goto LAB_0017cdbb;\n  }\n  uVar23 = uVar6 & 0xffffff7f;\n  local_42 = 0x3a;\n  iVar7 = skip_to_delim(param_4,0,&local_42,0x400);\n  pcVar24 = (char *)(param_4 + iVar7);\n  if (*pcVar24 == ':') {\n    *pcVar24 = '\\0';\n  }\n  else {\n    pcVar24 = (char *)0x0;\n  }\n  uVar8 = expand_arith_string(param_4,0x101);\n  bVar3 = shell_compatibility_level < 0x34;\n  uVar9 = evalexp(uVar8,bVar3,&local_64);\n  sh_xfree(uVar8,\"subst.c\",0x1fba);\n  if (local_64 == 0) goto LAB_0017d1c8;\n  if (uVar23 != 2) {\n    if (2 < (int)uVar23) {\n      if (uVar23 != 3) goto LAB_0017cdb8;\nLAB_0017d2f0:\n      sVar22 = __ctype_get_mb_cur_max();\n      if (sVar22 < 2) {\n        sVar22 = 0;\n        if (((plVar5 != (long *)0x0) && (*(byte *)plVar5 != 0)) &&\n           ((sVar22 = 1, *(byte *)((long)plVar5 + 1) != 0 &&\n            (sVar22 = 2, *(byte *)((long)plVar5 + 2) != 0)))) {\n          sVar22 = strlen((char *)plVar5);\n        }\n      }\n      else if ((plVar5 == (long *)0x0) || (*(byte *)plVar5 == 0)) {\n        sVar22 = 0;\n      }\n      else {\n        sVar22 = 1;\n        if (*(byte *)((long)plVar5 + 1) != 0) {\n          sVar22 = mbstrlen(plVar5);\n          goto LAB_0017cd69;\n        }\n      }\n      goto LAB_0017cd6f;\n    }\n    if (uVar23 == 0) goto LAB_0017d2f0;\n    if (uVar23 == 1) {\n      iVar7 = number_of_args();\n      sVar22 = (size_t)(iVar7 + 1);\n      if (uVar9 != 0) goto LAB_0017cd69;\n      sVar22 = sVar22 + 1;\n      if (sVar22 == 0xffffffffffffffff) goto LAB_0017cdb8;\n      if ((long)sVar22 < 0) goto LAB_0017cd89;\n      goto LAB_0017ce48;\n    }\n    goto LAB_0017cdb8;\n  }\n  if ((*(byte *)(lVar13 + 0x28) & 0x40) == 0) {\n    sVar22 = *plVar5 - ((long)uVar9 >> 0x3f);\n  }\n  else {\n    local_70 = *(long *)(lVar13 + 8);\n    sVar22 = (size_t)(*(int *)(local_70 + 0xc) - (int)((long)uVar9 >> 0x3f));\n  }\nLAB_0017cd69:\n  if (sVar22 == 0xffffffffffffffff) {\nLAB_0017cd89:\n    if ((uVar23 == 0) && (local_60 != (long *)0x0)) {\n      this_command_name = (char *)uVar16;\n      sh_xfree(local_60,\"subst.c\",0x2264);\n      uVar16 = this_command_name;\n    }\n  }\n  else {\nLAB_0017cd6f:\n    if (-1 < (long)uVar9) {\n      if ((long)uVar9 <= (long)sVar22) goto LAB_0017d211;\n      goto LAB_0017cd89;\n    }\n    uVar9 = uVar9 + sVar22;\n    if (((long)sVar22 < (long)uVar9) || ((long)uVar9 < 0)) goto LAB_0017cd89;\nLAB_0017d211:\n    if (uVar23 == 2) {\n      if ((*(byte *)(lVar13 + 0x28) & 0x40) == 0) {\n        sVar22 = plVar5[1];\n      }\n      else {\n        sVar22 = (size_t)*(int *)(local_70 + 0xc);\n      }\n    }\nLAB_0017ce48:\n    sVar10 = sVar22;\n    if (pcVar24 != (char *)0x0) {\n      __s = pcVar24 + 1;\n      sVar10 = strlen(__s);\n      pcVar11 = (char *)sh_xmalloc(sVar10 + 1,\"subst.c\",0x1fef);\n      pcVar11 = strcpy(pcVar11,__s);\n      uVar8 = expand_arith_string(pcVar11,0x101);\n      sh_xfree(pcVar11,\"subst.c\",0x1ff1);\n      *pcVar24 = ':';\n      sVar10 = evalexp(uVar8,bVar3,&local_64);\n      sh_xfree(uVar8,\"subst.c\",0x1ff4);\n      if (local_64 == 0) {\nLAB_0017d1c8:\n        this_command_name = (char *)uVar16;\n        if ((uVar23 == 0) && (local_60 != (long *)0x0)) {\n          sh_xfree(local_60,\"subst.c\",0x2264);\n        }\n        puVar15 = (undefined8 *)&DAT_0024784f;\n        goto LAB_0017cdbb;\n      }\n      if (uVar23 - 1 < 2) {\n        if ((long)sVar10 < 0) {\n          internal_error(\"%s: substring expression < 0\",__s);\n          puVar15 = (undefined8 *)&DAT_0024784f;\n          this_command_name = (char *)uVar16;\n          goto LAB_0017cdbb;\n        }\n        if (uVar23 != 2) goto LAB_0017d492;\n      }\n      else if (uVar23 != 2) {\n        if ((long)sVar10 < 0) {\n          uVar12 = sVar10 + sVar22;\n          uVar18 = 0;\n          if (-1 < (long)uVar9) {\n            uVar18 = uVar9;\n          }\n          if ((long)uVar12 < (long)uVar18) {\n            internal_error(\"%s: substring expression < 0\",__s);\n            goto LAB_0017d1c8;\n          }\n        }\n        else {\nLAB_0017d492:\n          uVar12 = uVar9 + sVar10;\n        }\n        sVar10 = sVar22;\n        if ((long)uVar12 < (long)sVar22) {\n          sVar10 = uVar12;\n        }\n        goto LAB_0017cf41;\n      }\nLAB_0017d261:\n      if ((*(byte *)(local_58 + 0x28) & 0x40) == 0) {\n        this_command_name = (char *)uVar16;\n        puVar15 = (undefined8 *)\n                  array_subrange(*(undefined8 *)(local_58 + 8),uVar9,sVar10,uVar6 & 0x80,param_5,\n                                 param_6);\n      }\n      else {\n        this_command_name = (char *)uVar16;\n        puVar15 = (undefined8 *)assoc_subrange();\n      }\nLAB_0017d293:\n      if ((puVar15 == (undefined8 *)0x0) || (param_5 != 0)) {\n        if ((param_5 & 3) != 0) goto LAB_0017cdbb;\n        uVar16 = this_command_name;\n        if (puVar15 == (undefined8 *)0x0) goto LAB_0017cdb8;\n      }\n      else if ((param_6 & 8 | ifs_is_null) != 0) goto LAB_0017cdbb;\n      puVar14 = (undefined8 *)FUN_00167220(puVar15,0);\n      sh_xfree(puVar15,\"subst.c\",0x229a);\n      puVar15 = puVar14;\n      goto LAB_0017cdbb;\n    }\nLAB_0017cf41:\n    iVar17 = (int)uVar9;\n    iVar7 = (int)sVar10;\n    if (2 < (int)uVar23) {\n      puVar15 = (undefined8 *)0x0;\n      this_command_name = (char *)uVar16;\n      if (uVar23 != 3) goto LAB_0017cdbb;\nLAB_0017cf64:\n      this_command_name = (char *)uVar16;\n      sVar22 = __ctype_get_mb_cur_max();\n      plVar5 = local_60;\n      if (sVar22 < 2) {\n        lVar13 = substring(local_60,uVar9 & 0xffffffff,sVar10 & 0xffffffff);\n      }\n      else {\n        local_4c.__count = 0;\n        local_4c.__value = (_union_27)0x0;\n        sVar22 = __ctype_get_mb_cur_max();\n        bVar1 = *(byte *)plVar5;\n        if ((sVar22 < 2) || (plVar5 == (long *)0x0)) {\n          if (bVar1 == 0) goto LAB_0017d5a0;\n          local_a0 = 0;\nLAB_0017cff9:\n          uVar12 = (ulong)bVar1;\n          plVar21 = plVar5;\n          if (iVar17 == 0) {\n            iVar19 = 0;\n            lVar13 = 0;\n          }\n          else {\n            uVar9 = uVar9 & 0xffffffff;\n            lVar13 = 0;\n            iVar19 = 0;\n            do {\n              mVar4 = local_4c;\n              if (locale_mb_cur_max < 2) {\nLAB_0017d180:\n                iVar19 = iVar19 + 1;\n              }\n              else {\n                if ((*(uint *)(is_basic_table + (uVar12 >> 5) * 4) >> ((byte)uVar12 & 0x1f) & 1) ==\n                    0) {\n                  if ((locale_utf8locale == 0) || (iVar20 = 1, (char)(byte)uVar12 < '\\0')) {\n                    sVar22 = mbrtowc((wchar_t *)0x0,(char *)plVar21,local_a0 - lVar13,&local_4c);\n                    if (0xfffffffffffffffd < sVar22) {\n                      iVar19 = iVar19 + 1;\n                      local_4c = mVar4;\n                      goto LAB_0017d071;\n                    }\n                    iVar20 = (int)sVar22;\n                    if (sVar22 == 0) goto LAB_0017d180;\n                  }\n                }\n                else {\n                  iVar20 = 1;\n                }\n                iVar19 = iVar19 + iVar20;\n              }\nLAB_0017d071:\n              lVar13 = (long)iVar19;\n              plVar21 = (long *)((long)plVar5 + lVar13);\n              uVar12 = (ulong)*(byte *)plVar21;\n              iVar20 = iVar19;\n              if (*(byte *)plVar21 == 0) goto LAB_0017d137;\n              uVar23 = (int)uVar9 - 1;\n              uVar9 = (ulong)uVar23;\n            } while (uVar23 != 0);\n          }\n          mVar4 = local_4c;\n          iVar20 = iVar19;\n          for (iVar7 = iVar7 - iVar17; local_4c = mVar4, iVar7 != 0; iVar7 = iVar7 + -1) {\n            if (locale_mb_cur_max < 2) {\nLAB_0017d468:\n              iVar20 = iVar20 + 1;\n            }\n            else {\n              if ((*(uint *)(is_basic_table + (uVar12 >> 5) * 4) >> ((byte)uVar12 & 0x1f) & 1) == 0)\n              {\n                if ((locale_utf8locale == 0) || (iVar17 = 1, (char)(byte)uVar12 < '\\0')) {\n                  sVar22 = mbrtowc((wchar_t *)0x0,(char *)plVar21,local_a0 - lVar13,&local_4c);\n                  if (0xfffffffffffffffd < sVar22) {\n                    iVar20 = iVar20 + 1;\n                    local_4c = mVar4;\n                    goto LAB_0017d112;\n                  }\n                  iVar17 = (int)sVar22;\n                  if (sVar22 == 0) goto LAB_0017d468;\n                }\n              }\n              else {\n                iVar17 = 1;\n              }\n              iVar20 = iVar20 + iVar17;\n            }\nLAB_0017d112:\n            lVar13 = (long)iVar20;\n            plVar21 = (long *)((long)plVar5 + lVar13);\n            uVar12 = (ulong)*(byte *)plVar21;\n            if (*(byte *)plVar21 == 0) break;\n            mVar4 = local_4c;\n          }\n        }\n        else {\n          if (bVar1 != 0) {\n            local_a0 = 1;\n            if ((*(byte *)((long)plVar5 + 1) != 0) &&\n               (local_a0 = 2, *(byte *)((long)plVar5 + 2) != 0)) {\n              local_a0 = strlen((char *)plVar5);\n            }\n            goto LAB_0017cff9;\n          }\nLAB_0017d5a0:\n          iVar19 = 0;\n          iVar20 = iVar19;\n        }\nLAB_0017d137:\n        lVar13 = substring(plVar5,iVar19,iVar20);\n      }\n      if (((uVar6 & 0xffffff7f) == 0) && (local_60 != (long *)0x0)) {\n        sh_xfree(local_60,\"subst.c\",0x2274);\n      }\n      if ((param_5 & 3) == 0) {\n        uVar16 = this_command_name;\n        if (lVar13 == 0) goto LAB_0017cdb8;\n        puVar15 = (undefined8 *)FUN_00167220(lVar13,0);\n      }\n      else {\n        puVar15 = (undefined8 *)quote_string(lVar13);\n        if (lVar13 == 0) goto LAB_0017cdbb;\n      }\n      sh_xfree(lVar13,\"subst.c\",0x2279);\n      goto LAB_0017cdbb;\n    }\n    if (0 < (int)uVar23) {\n      if (uVar23 != 1) goto LAB_0017d261;\n      if ((iVar7 == iVar17) ||\n         ((this_command_name = (char *)uVar16, puVar14 = (undefined8 *)list_rest_of_args(),\n          puVar14 == (undefined8 *)0x0 && (uVar16 = this_command_name, 0 < iVar17))))\n      goto LAB_0017cdb8;\n      if (iVar17 == 0) {\n        iVar20 = 0;\n        uVar16 = make_word(dollar_vars);\n        puVar14 = (undefined8 *)make_word_list(uVar16,puVar14);\n        puVar15 = puVar14;\n      }\n      else {\n        iVar20 = 1;\n        puVar15 = puVar14;\n        if ((1 < iVar17) && (iVar19 = 1, puVar14 != (undefined8 *)0x0)) {\n          do {\n            puVar15 = (undefined8 *)*puVar15;\n            iVar20 = iVar19 + 1;\n            if (puVar15 == (undefined8 *)0x0) goto LAB_0017d591;\n            iVar19 = iVar20;\n          } while (iVar20 < iVar17);\n        }\n      }\n      if (puVar15 == (undefined8 *)0x0) {\nLAB_0017d591:\n        dispose_words(puVar14);\n        goto LAB_0017cdbb;\n      }\n      puVar2 = puVar15;\n      if (iVar20 < iVar7) {\n        do {\n          puVar25 = puVar2;\n          puVar2 = (undefined8 *)*puVar25;\n          iVar20 = iVar20 + 1;\n          if (puVar2 == (undefined8 *)0x0) break;\n        } while (iVar20 < iVar7);\n        *puVar25 = 0;\n        puVar15 = (undefined8 *)string_list_pos_params((int)*param_1,puVar15,param_5,param_6);\n        if (puVar2 != puVar25) {\n          *puVar25 = puVar2;\n        }\n      }\n      else {\n        *puVar15 = 0;\n        puVar15 = (undefined8 *)string_list_pos_params((int)*param_1,puVar15,param_5,param_6);\n      }\n      dispose_words(puVar14);\n      goto LAB_0017d293;\n    }\n    if (uVar23 == 0) goto LAB_0017cf64;\n  }\nLAB_0017cdb8:\n  this_command_name = (char *)uVar16;\n  puVar15 = (undefined8 *)0x0;\nLAB_0017cdbb:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar15;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "sbrk": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * sbrk(intptr_t __delta)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_sbrk_00237ae0)();\n  return pvVar1;\n}\n\n",
  "array_dequote_escapes": "\nlong array_dequote_escapes(long param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long lVar4;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  lVar1 = *(long *)(param_1 + 0x10);\n  lVar3 = lVar1;\n  if (lVar1 != 0) {\n    if (*(long *)(param_1 + 8) == 0) {\n      return 0;\n    }\n    lVar4 = *(long *)(lVar1 + 0x10);\n    lVar3 = param_1;\n    if (lVar1 != lVar4) {\n      do {\n        uVar2 = dequote_escapes(*(undefined8 *)(lVar4 + 8));\n        if (*(long *)(lVar4 + 8) != 0) {\n          sh_xfree(*(long *)(lVar4 + 8),\"array.c\",0x175);\n        }\n        *(undefined8 *)(lVar4 + 8) = uVar2;\n        lVar4 = *(long *)(lVar4 + 0x10);\n      } while (*(long *)(param_1 + 0x10) != lVar4);\n    }\n  }\n  return lVar3;\n}\n\n",
  "expand_and_quote_kvpair_word": "\nundefined8 expand_and_quote_kvpair_word(long param_1)\n\n{\n  char *__s;\n  char *pcVar1;\n  undefined8 uVar2;\n  \n  if ((param_1 == 0) || (__s = (char *)expand_subscript_string(param_1,0), __s == (char *)0x0)) {\n    __s = (char *)0x0;\n    uVar2 = sh_single_quote(&DAT_00213d70);\n  }\n  else {\n    pcVar1 = strchr(__s,1);\n    if (pcVar1 == (char *)0x0) {\n      uVar2 = sh_single_quote(__s);\n    }\n    else {\n      pcVar1 = (char *)quote_escapes();\n      if (pcVar1 == (char *)0x0) {\n        uVar2 = sh_single_quote(&DAT_00213d70);\n      }\n      else {\n        uVar2 = sh_single_quote(pcVar1);\n        if (__s == pcVar1) goto LAB_0018b340;\n      }\n      sh_xfree(pcVar1,\"arrayfunc.c\",0x2ac);\n    }\n  }\nLAB_0018b340:\n  sh_xfree(__s,\"arrayfunc.c\",0x2ad);\n  return uVar2;\n}\n\n",
  "save_pipestatus_array": "\nundefined8 save_pipestatus_array(void)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = find_variable(\"PIPESTATUS\");\n  if (((lVar1 != 0) && ((*(byte *)(lVar1 + 0x28) & 4) != 0)) && (*(long *)(lVar1 + 8) != 0)) {\n    uVar2 = array_copy();\n    return uVar2;\n  }\n  return 0;\n}\n\n",
  "complete_builtin": "\nulong complete_builtin(long param_1)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  long **pplVar5;\n  long lVar6;\n  size_t sVar7;\n  char *pcVar8;\n  long **pplVar9;\n  long **pplVar10;\n  char *pcVar11;\n  long in_FS_OFFSET;\n  bool bVar12;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  int local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) goto LAB_001bc417;\n  local_48 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_50 = 0;\n  local_58 = 0;\n  DAT_00248e20 = (char *)0x0;\n  DAT_00248e28 = (char *)0x0;\n  DAT_00248e30 = (char *)0x0;\n  DAT_00248e38 = (char *)0x0;\n  DAT_00248e40 = (char *)0x0;\n  DAT_00248e48 = (char *)0x0;\n  DAT_00248e50 = (char *)0x0;\n  uVar1 = FUN_001bb8a0(param_1,&local_48,&local_58,&local_50);\n  pplVar9 = loptend;\n  uVar3 = (ulong)uVar1;\n  if (uVar1 != 0x102) {\n    pcVar11 = \"_DefaultCmD_\";\n    iVar2 = (int)local_48;\n    if ((int)local_40 == 0) {\n      if (local_40._4_4_ != 0) {\n        pcVar11 = \"_EmptycmD_\";\n        goto LAB_001bc3df;\n      }\n      if (local_38 != 0) {\n        pcVar11 = \"_InitialWorD_\";\n        goto LAB_001bc3df;\n      }\n      if ((int)local_48 != 0) goto LAB_001bc3a5;\n      if ((uVar1 == 1) && (loptend == (long **)0x0)) goto LAB_001bc417;\n      if (local_48._4_4_ != 0) goto LAB_001bc4e4;\n      bVar12 = true;\n      pplVar5 = (long **)0x0;\nLAB_001bc556:\n      if (((bool)(bVar12 & pplVar9 == (long **)0x0)) && (uVar1 != 1)) {\n        builtin_usage();\n        uVar3 = 0x102;\n      }\n      else {\n        lVar6 = compspec_create();\n        pcVar11 = DAT_00248e50;\n        *(undefined8 *)(lVar6 + 8) = local_58;\n        *(undefined8 *)(lVar6 + 0x10) = local_50;\n        if (pcVar11 != (char *)0x0) {\n          sVar7 = strlen(pcVar11);\n          pcVar8 = (char *)sh_xmalloc(sVar7 + 1,\"./complete.def\",0x1c8);\n          pcVar11 = strcpy(pcVar8,pcVar11);\n        }\n        *(char **)(lVar6 + 0x18) = pcVar11;\n        pcVar11 = DAT_00248e48;\n        if (DAT_00248e48 != (char *)0x0) {\n          sVar7 = strlen(DAT_00248e48);\n          pcVar8 = (char *)sh_xmalloc(sVar7 + 1,\"./complete.def\",0x1c9);\n          pcVar11 = strcpy(pcVar8,pcVar11);\n        }\n        *(char **)(lVar6 + 0x20) = pcVar11;\n        pcVar11 = DAT_00248e40;\n        if (DAT_00248e40 != (char *)0x0) {\n          sVar7 = strlen(DAT_00248e40);\n          pcVar8 = (char *)sh_xmalloc(sVar7 + 1,\"./complete.def\",0x1ca);\n          pcVar11 = strcpy(pcVar8,pcVar11);\n        }\n        *(char **)(lVar6 + 0x28) = pcVar11;\n        pcVar11 = DAT_00248e38;\n        if (DAT_00248e38 != (char *)0x0) {\n          sVar7 = strlen(DAT_00248e38);\n          pcVar8 = (char *)sh_xmalloc(sVar7 + 1,\"./complete.def\",0x1cb);\n          pcVar11 = strcpy(pcVar8,pcVar11);\n        }\n        *(char **)(lVar6 + 0x30) = pcVar11;\n        pcVar11 = DAT_00248e28;\n        if (DAT_00248e28 != (char *)0x0) {\n          sVar7 = strlen(DAT_00248e28);\n          pcVar8 = (char *)sh_xmalloc(sVar7 + 1,\"./complete.def\",0x1cc);\n          pcVar11 = strcpy(pcVar8,pcVar11);\n        }\n        *(char **)(lVar6 + 0x38) = pcVar11;\n        pcVar11 = DAT_00248e20;\n        if (DAT_00248e20 != (char *)0x0) {\n          sVar7 = strlen(DAT_00248e20);\n          pcVar8 = (char *)sh_xmalloc(sVar7 + 1,\"./complete.def\",0x1cd);\n          pcVar11 = strcpy(pcVar8,pcVar11);\n        }\n        *(char **)(lVar6 + 0x40) = pcVar11;\n        pcVar11 = DAT_00248e30;\n        if (DAT_00248e30 != (char *)0x0) {\n          sVar7 = strlen(DAT_00248e30);\n          pcVar8 = (char *)sh_xmalloc(sVar7 + 1,\"./complete.def\",0x1ce);\n          pcVar11 = strcpy(pcVar8,pcVar11);\n        }\n        *(char **)(lVar6 + 0x50) = pcVar11;\n        pplVar10 = pplVar5;\n        if ((pplVar5 != (long **)0x0) || (uVar3 = 0, pplVar10 = pplVar9, pplVar9 != (long **)0x0)) {\n          uVar3 = 0;\n          do {\n            iVar2 = progcomp_insert(*pplVar10[1],lVar6);\n            pplVar10 = (long **)*pplVar10;\n            if (iVar2 == 0) {\n              uVar3 = 1;\n            }\n          } while (pplVar10 != (long **)0x0);\n        }\n        dispose_words(pplVar5);\n      }\n    }\n    else {\nLAB_001bc3df:\n      uVar4 = make_bare_word(pcVar11);\n      pplVar5 = (long **)make_word_list(uVar4,0);\n      if (iVar2 == 0) {\n        if ((uVar1 == 1) && (pplVar9 == (long **)0x0)) {\n          if (pplVar5 != (long **)0x0) goto LAB_001bc467;\n          goto LAB_001bc417;\n        }\n        if (local_48._4_4_ == 0) {\n          bVar12 = pplVar5 == (long **)0x0;\n          goto LAB_001bc556;\n        }\n        if (pplVar5 == (long **)0x0) {\nLAB_001bc4e4:\n          uVar3 = 0;\n          if (pplVar9 == (long **)0x0) {\n            progcomp_flush();\n          }\n          else {\n            do {\n              iVar2 = progcomp_remove(*pplVar9[1]);\n              if (iVar2 == 0) {\n                uVar3 = 1;\n                builtin_error(\"%s: no completion specification\",*pplVar9[1]);\n              }\n              pplVar9 = (long **)*pplVar9;\n            } while (pplVar9 != (long **)0x0);\n          }\n        }\n        else {\n          uVar1 = 0;\n          pplVar9 = pplVar5;\n          do {\n            iVar2 = progcomp_remove(*pplVar9[1]);\n            if (iVar2 == 0) {\n              uVar1 = 1;\n              builtin_error(\"%s: no completion specification\",*pplVar9[1]);\n            }\n            pplVar9 = (long **)*pplVar9;\n          } while (pplVar9 != (long **)0x0);\n          uVar3 = (ulong)uVar1;\n          dispose_words(pplVar5);\n        }\n      }\n      else if (pplVar5 == (long **)0x0) {\nLAB_001bc3a5:\n        if (pplVar9 != (long **)0x0) {\n          if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n            uVar3 = FUN_001bc230(pplVar9);\n            return uVar3;\n          }\n          goto LAB_001bc79a;\n        }\nLAB_001bc417:\n        uVar3 = 0;\n        progcomp_walk(FUN_001bc210);\n      }\n      else {\nLAB_001bc467:\n        uVar1 = FUN_001bc230(pplVar5);\n        uVar3 = (ulong)uVar1;\n        dispose_words(pplVar5);\n      }\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\nLAB_001bc79a:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "coproc_dispose": "\nvoid coproc_dispose(long param_1)\n\n{\n  if (param_1 != 0) {\n    FUN_0014a430();\n    return;\n  }\n  return;\n}\n\n",
  "mkdtemp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * mkdtemp(char *__template)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_mkdtemp_00237cb0)();\n  return pcVar1;\n}\n\n",
  "stream_on_stack": "\nlong stream_on_stack(int param_1)\n\n{\n  long *plVar1;\n  \n  plVar1 = stream_list;\n  if (stream_list == (long *)0x0) {\n    return 0;\n  }\n  do {\n    if (*(int *)(plVar1 + 1) == param_1) {\n      return 1;\n    }\n    plVar1 = (long *)*plVar1;\n  } while (plVar1 != (long *)0x0);\n  return (long)plVar1;\n}\n\n",
  "FUN_00137850": "\nvoid FUN_00137850(void)\n\n{\n  char *pcVar1;\n  \n  if (interactive == 0) {\n    EOF_Reached = 1;\n    return;\n  }\n  if (EOF_Reached != 0) {\n    EOF_Reached = 0;\n  }\n  if ((ignoreeof != 0) && (eof_encountered < eof_encountered_limit)) {\n    pcVar1 = \"logout\";\n    if (login_shell == 0) {\n      pcVar1 = \"exit\";\n    }\n    __fprintf_chk(stderr,1,\"Use \\\"%s\\\" to leave the shell.\\n\",pcVar1);\n    eof_encountered = eof_encountered + 1;\n    current_token = 10;\n    DAT_00240d70 = 10;\n    prompt_string_pointer = 0;\n    if ((interactive != 0) &&\n       ((pushed_string_list == 0 || (*(long *)(pushed_string_list + 0x18) == 0)))) {\n      FUN_001373e0();\n      return;\n    }\n    return;\n  }\n  reset_parser();\n  last_shell_builtin = this_shell_builtin;\n  this_shell_builtin = exit_builtin;\n  exit_builtin(0);\n  return;\n}\n\n",
  "procsub_prune": "\nvoid procsub_prune(void)\n\n{\n  if (DAT_00242520 != 0) {\n    FUN_00160a10();\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00181560": "\nvoid FUN_00181560(int param_1)\n\n{\n  code *pcVar1;\n  \n  if ((((*(byte *)(&DAT_00247e40 + param_1) & 1) != 0) &&\n      (pcVar1 = (code *)(&trap_list)[param_1], (code *)0x1 < pcVar1)) &&\n     (pcVar1 != initialize_traps)) {\n    sh_xfree(pcVar1,\"trap.c\",0x347);\n    return;\n  }\n  return;\n}\n\n",
  "strvec_strcmp": "\nvoid strvec_strcmp(char **param_1,char **param_2)\n\n{\n  strcoll(*param_1,*param_2);\n  return;\n}\n\n",
  "sh_contains_quotes": "\nundefined8 sh_contains_quotes(byte *param_1)\n\n{\n  uint uVar1;\n  \n  if (param_1 != (byte *)0x0) {\n    for (; *param_1 != 0; param_1 = param_1 + 1) {\n      uVar1 = *param_1 - 0x22;\n      if (((byte)uVar1 < 0x3b) && ((0x400000000000021U >> ((ulong)uVar1 & 0x3f) & 1) != 0)) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
  "__getgroups_chk": "\nvoid __getgroups_chk(void)\n\n{\n  (*(code *)PTR___getgroups_chk_00237b90)();\n  return;\n}\n\n",
  "FUN_001a0af0": "\nint * FUN_001a0af0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4,\n                  undefined4 param_5,uint *param_6,uint *param_7,int **param_8)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  long lVar5;\n  \n  piVar4 = (int *)progcomp_search();\n  if (piVar4 != (int *)0x0) {\n    if (*param_8 == piVar4) {\n      piVar4 = (int *)0x0;\n    }\n    else {\n      if (*param_8 != (int *)0x0) {\n        compspec_dispose();\n      }\n      *piVar4 = *piVar4 + 1;\n      *param_8 = piVar4;\n      lVar5 = compspec_copy(piVar4);\n      uVar3 = pcomp_curcs;\n      uVar2 = pcomp_curcmd;\n      uVar1 = pcomp_curtxt;\n      pcomp_curtxt = param_3;\n      pcomp_curcmd = param_2;\n      pcomp_curcs = lVar5;\n      piVar4 = (int *)gen_compspec_completions(lVar5,param_2,param_3,param_4,param_5,param_6);\n      pcomp_curtxt = uVar1;\n      pcomp_curcmd = uVar2;\n      pcomp_curcs = uVar3;\n      *param_7 = *param_6 >> 9 & 1;\n      *param_6 = *param_6 & 0xfffffdff | *(uint *)(lVar5 + 0x10);\n      compspec_dispose();\n    }\n  }\n  return piVar4;\n}\n\n",
  "shtimer_dispose": "\nvoid shtimer_dispose(undefined8 param_1)\n\n{\n  sh_xfree(param_1,\"timers.c\",0x5e);\n  return;\n}\n\n",
  "FUN_001da920": "\nundefined8 FUN_001da920(char *param_1)\n\n{\n  size_t sVar1;\n  char *__dest;\n  \n  if (param_1 == (char *)0x0) {\n    return 1;\n  }\n  if (*param_1 == '\\0') {\n    return 1;\n  }\n  if (_rl_comment_begin != (char *)0x0) {\n    free(_rl_comment_begin);\n  }\n  sVar1 = strlen(param_1);\n  __dest = (char *)xmalloc(sVar1 + 1);\n  _rl_comment_begin = strcpy(__dest,param_1);\n  return 0;\n}\n\n",
  "check_identifier": "\nundefined8 check_identifier(char **param_1,int param_2)\n\n{\n  char cVar1;\n  char *pcVar2;\n  int iVar3;\n  char *pcVar4;\n  \n  if ((*(uint *)(param_1 + 1) & 3) != 0) {\n    internal_error(\"`%s\\': not a valid identifier\",*param_1);\n    return 0;\n  }\n  if (param_2 == 0) {\n    return 1;\n  }\n  pcVar2 = *param_1;\n  cVar1 = *pcVar2;\n  pcVar4 = pcVar2;\n  do {\n    if (cVar1 == '\\0') {\nLAB_00141840:\n      internal_error(\"`%s\\': not a valid identifier\",pcVar2);\n      return 0;\n    }\n    if (9 < (byte)(cVar1 - 0x30U)) {\n      iVar3 = legal_identifier(pcVar2);\n      if (iVar3 != 0) {\n        return 1;\n      }\n      goto LAB_00141840;\n    }\n    cVar1 = pcVar4[1];\n    pcVar4 = pcVar4 + 1;\n  } while( true );\n}\n\n",
  "FUN_00194410": "\nundefined8 FUN_00194410(int param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = rl_point;\n  if (param_1 < 0) {\n    uVar2 = FUN_001943a0(-param_1);\n    return uVar2;\n  }\n  FUN_001936e0();\n  if (rl_point != iVar1) {\n    rl_kill_text(iVar1);\n  }\n  if (rl_editing_mode == 1) {\n    rl_mark = rl_point;\n    return 0;\n  }\n  return 0;\n}\n\n",
  "rl_start_kbd_macro": "\nundefined8 rl_start_kbd_macro(void)\n\n{\n  size_t sVar1;\n  char *__dest;\n  char *pcVar2;\n  \n  pcVar2 = DAT_0024b198;\n  if ((rl_readline_state & 0x1000) != 0) {\n                    /* WARNING: Subroutine does not return */\n    _rl_abort_internal();\n  }\n  if (rl_explicit_arg == 0) {\n    DAT_0024b190 = 0;\n  }\n  else if (DAT_0024b198 != (char *)0x0) {\n    sVar1 = strlen(DAT_0024b198);\n    __dest = (char *)xmalloc(sVar1 + 1);\n    pcVar2 = strcpy(__dest,pcVar2);\n    _rl_with_macro_input(pcVar2);\n    rl_readline_state = rl_readline_state | 0x1000;\n    return 0;\n  }\n  rl_readline_state = rl_readline_state | 0x1000;\n  return 0;\n}\n\n",
  "procsub_add": "\nlong procsub_add(long param_1)\n\n{\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_128);\n  sigaddset(&sStack_128,0x11);\n  sigemptyset(&local_a8);\n  sigprocmask(0,&sStack_128,&local_a8);\n  if (procsubs == 0) {\n    DAT_00242520 = 1;\n    procsubs = param_1;\n  }\n  else {\n    *DAT_00242518 = param_1;\n    DAT_00242520 = DAT_00242520 + 1;\n  }\n  DAT_00242518 = (long *)param_1;\n  sigprocmask(2,&local_a8,(sigset_t *)0x0);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "remove_quoted_nulls": "\nchar * remove_quoted_nulls(char *param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  mbstate_t mVar3;\n  int iVar4;\n  char *pcVar5;\n  size_t sVar6;\n  ulong uVar7;\n  long lVar8;\n  size_t sVar9;\n  int iVar10;\n  int iVar11;\n  int iVar12;\n  long lVar13;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  pcVar5 = strchr(param_1,0x7f);\n  if (pcVar5 != (char *)0x0) {\n    sVar6 = strlen(param_1);\n    pcVar5 = param_1;\n    if (sVar6 != 0) {\n      iVar4 = 0;\n      iVar10 = 0;\n      uVar7 = 0;\nLAB_00171302:\n      do {\n        mVar3 = local_48;\n        if (param_1[uVar7] != '\\x01') {\n          iVar2 = iVar10 + 1;\n          iVar12 = iVar4;\n          iVar11 = iVar10;\n          if (param_1[uVar7] != '\\x7f') goto LAB_001712b1;\n          goto LAB_001712fa;\n        }\n        iVar11 = iVar10 + 1;\n        iVar12 = iVar4 + 1;\n        param_1[iVar4] = '\\x01';\n        if ((long)iVar11 == sVar6) {\n          pcVar5 = param_1 + iVar12;\n          goto LAB_00171380;\n        }\nLAB_001712b1:\n        if (locale_mb_cur_max < 2) goto LAB_001712f4;\n        bVar1 = param_1[iVar11];\n        if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) != 0) {\nLAB_00171330:\n          iVar10 = iVar11 + 1;\nLAB_00171337:\n          iVar2 = iVar10;\n          iVar4 = iVar10;\n          if (iVar11 <= iVar12) goto LAB_001712fa;\nLAB_0017133b:\n          lVar8 = (long)iVar11;\n          lVar13 = iVar12 - lVar8;\n          do {\n            param_1[lVar8 + lVar13] = param_1[lVar8];\n            lVar8 = lVar8 + 1;\n          } while ((int)lVar8 < iVar10);\n          iVar4 = (iVar10 - iVar11) + -1;\n          if (iVar10 <= iVar11) {\n            iVar4 = 0;\n          }\n          iVar4 = iVar12 + 1 + iVar4;\n          uVar7 = (ulong)iVar10;\n          if (sVar6 <= uVar7) break;\n          goto LAB_00171302;\n        }\n        if ((locale_utf8locale == 0) || ((char)bVar1 < '\\0')) {\n          sVar9 = mbrtowc((wchar_t *)0x0,param_1 + iVar11,sVar6 - (long)iVar11,&local_48);\n          if ((sVar9 < 0xfffffffffffffffe) && (mVar3 = local_48, sVar9 != 0)) {\n            iVar10 = (int)sVar9 + iVar11;\n            goto LAB_00171337;\n          }\n        }\n        else if (bVar1 != 0) goto LAB_00171330;\nLAB_001712f4:\n        local_48 = mVar3;\n        iVar10 = iVar11 + 1;\n        iVar2 = iVar10;\n        iVar4 = iVar10;\n        if (iVar12 < iVar11) goto LAB_0017133b;\nLAB_001712fa:\n        iVar10 = iVar2;\n        uVar7 = (ulong)iVar10;\n      } while (uVar7 < sVar6);\n      pcVar5 = param_1 + iVar4;\n    }\nLAB_00171380:\n    *pcVar5 = '\\0';\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return param_1;\n}\n\n",
  "FUN_001b6eb0": "\nvoid FUN_001b6eb0(undefined8 param_1,undefined4 param_2)\n\n{\n  enable_hostname_completion(param_2);\n  return;\n}\n\n",
  "_rl_bracketed_read_mbstring": "\nint _rl_bracketed_read_mbstring(undefined *param_1,int param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  \n  iVar1 = _rl_bracketed_read_key();\n  if (iVar1 < 0) {\n    iVar1 = -1;\n  }\n  else {\n    sVar2 = __ctype_get_mb_cur_max();\n    if ((sVar2 < 2) || (rl_byte_oriented != 0)) {\n      *param_1 = (char)iVar1;\n    }\n    else {\n      iVar1 = _rl_read_mbstring(iVar1,param_1,param_2);\n    }\n    param_1[param_2] = 0;\n  }\n  return iVar1;\n}\n\n",
  "parse_symbolic_mode": "\nuint parse_symbolic_mode(byte *param_1,uint param_2)\n\n{\n  byte bVar1;\n  byte bVar2;\n  long lVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  ulong uVar7;\n  byte *pbVar8;\n  bool local_3d;\n  uint local_3c;\n  \n  local_3c = param_2;\n  do {\n    if (*param_1 == 0) {\nLAB_001b5e7a:\n      iVar5 = 0;\nLAB_001b5e7c:\n      builtin_error(\"`%c\\': invalid symbolic mode operator\",iVar5);\n      return 0xffffffff;\n    }\n    uVar4 = 0;\n    while( true ) {\n      lVar3 = mbschr(&DAT_002109a3);\n      pbVar8 = param_1 + 1;\n      if (lVar3 == 0) break;\n      bVar1 = *param_1;\n      if (bVar1 == 0x6f) {\n        uVar4 = uVar4 | 7;\nLAB_001b5e40:\n        bVar1 = *pbVar8;\n      }\n      else {\n        if ('o' < (char)bVar1) {\n          if (bVar1 == 0x75) {\n            uVar4 = uVar4 | 0x1c0;\n          }\n          goto LAB_001b5e40;\n        }\n        if (bVar1 != 0x61) {\n          if (bVar1 == 0x67) {\n            uVar4 = uVar4 | 0x38;\n          }\n          goto LAB_001b5e40;\n        }\n        bVar1 = *pbVar8;\n        uVar4 = 0x1ff;\n      }\n      param_1 = pbVar8;\n      if (bVar1 == 0) goto LAB_001b5e7a;\n    }\n    bVar1 = *param_1;\n    if ((0x3d < bVar1) ||\n       (uVar7 = 0x2000280000000000 >> (bVar1 & 0x3f), local_3d = (bool)((byte)uVar7 & 1),\n       (uVar7 & 1) == 0)) {\n      iVar5 = (int)(char)bVar1;\n      goto LAB_001b5e7c;\n    }\n    bVar2 = param_1[1];\n    uVar6 = 0;\njoined_r0x001b5ef2:\n    if (bVar2 != 0) {\n      do {\n        lVar3 = mbschr(&DAT_002109a8);\n        if (lVar3 == 0) {\n          bVar2 = *pbVar8;\n          local_3d = bVar2 == 0;\n          if ((bVar2 != 0x2c) && (!local_3d)) {\n            builtin_error(\"`%c\\': invalid symbolic mode character\",(int)(char)bVar2);\n            return 0xffffffff;\n          }\n          break;\n        }\n        bVar2 = *pbVar8;\n        pbVar8 = pbVar8 + 1;\n        if (bVar2 == 0x77) {\n          uVar6 = uVar6 | 0x92;\n        }\n        else {\n          if (bVar2 == 0x78) goto code_r0x001b5f35;\n          if (bVar2 == 0x72) {\n            uVar6 = uVar6 | 0x124;\n          }\n        }\n        if (*pbVar8 == 0) break;\n      } while( true );\n    }\n    if (uVar4 == 0) {\n      if (bVar1 == 0x2d) goto LAB_001b6010;\n      if (bVar1 == 0x3d) {\n        uVar4 = 0xfffffe00;\n        goto LAB_001b5fe1;\n      }\nLAB_001b5f67:\n      if (bVar1 == 0x2b) {\n        local_3c = local_3c | uVar6;\n      }\n    }\n    else {\n      uVar6 = uVar6 & uVar4;\n      if (bVar1 == 0x2d) {\nLAB_001b6010:\n        local_3c = local_3c & ~uVar6;\n      }\n      else {\n        if (bVar1 != 0x3d) goto LAB_001b5f67;\n        uVar4 = ~uVar4;\nLAB_001b5fe1:\n        local_3c = uVar4 & local_3c | uVar6;\n      }\n    }\n    if (local_3d != false) {\n      return local_3c;\n    }\n    param_1 = pbVar8 + 1;\n  } while( true );\ncode_r0x001b5f35:\n  bVar2 = *pbVar8;\n  uVar6 = uVar6 | 0x49;\n  goto joined_r0x001b5ef2;\n}\n\n",
  "num_posix_options": "\nundefined8 num_posix_options(void)\n\n{\n  return 5;\n}\n\n",
  "procsub_waitall": "\nvoid procsub_waitall(void)\n\n{\n  long *plVar1;\n  \n  plVar1 = procsubs;\n  if (procsubs != (long *)0x0) {\n    do {\n      if (*(int *)(plVar1 + 2) != 0) {\n        wait_for(*(undefined4 *)(plVar1 + 1),0);\n      }\n      plVar1 = (long *)*plVar1;\n    } while (plVar1 != (long *)0x0);\n  }\n  return;\n}\n\n",
  "check_unbind_variable": "\nundefined8 check_unbind_variable(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = find_variable();\n  if (lVar1 != 0) {\n    if ((*(uint *)(lVar1 + 0x28) & 2) == 0) {\n      if ((*(uint *)(lVar1 + 0x28) & 0x2000) == 0) goto LAB_00158abe;\n      internal_error(\"%s: cannot unset\",param_1);\n    }\n    else {\n      internal_error(\"%s: cannot unset: readonly %s\",param_1,\"variable\");\n    }\n    return 0xfffffffe;\n  }\nLAB_00158abe:\n  uVar2 = unbind_variable(param_1);\n  return uVar2;\n}\n\n",
  "find_tempenv_variable": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 find_tempenv_variable(undefined8 param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  lVar1 = temporary_env;\n  if (temporary_env != 0) {\n    lVar2 = hash_search(param_1,temporary_env,0);\n    if (lVar2 != 0) {\n      _DAT_002422f8 = lVar1;\n      return *(undefined8 *)(lVar2 + 0x10);\n    }\n  }\n  return 0;\n}\n\n",
  "rl_completion_mode": "\nint rl_completion_mode(long param_1)\n\n{\n  int iVar1;\n  \n  if ((rl_last_func == param_1) && (DAT_0024a730 == 0)) {\n    return 0x3f;\n  }\n  iVar1 = 0x21;\n  if (_rl_complete_show_all == 0) {\n    iVar1 = (-(uint)(_rl_complete_show_unmodified == 0) & 0xffffffc9) + 0x40;\n  }\n  return iVar1;\n}\n\n",
  "rl_callback_handler_install": "\nvoid rl_callback_handler_install(undefined8 param_1,undefined8 param_2)\n\n{\n  rl_set_prompt();\n  rl_readline_state = rl_readline_state | 0x80000;\n  rl_linefunc = param_2;\n  FUN_001ec080();\n  return;\n}\n\n",
  "rl_vi_yank_arg": "\nundefined8 rl_vi_yank_arg(int param_1)\n\n{\n  if (rl_explicit_arg != 0) {\n    rl_yank_nth_arg(param_1 + -1);\n    return 0;\n  }\n  rl_yank_nth_arg(0x24);\n  return 0;\n}\n\n",
  "rl_crlf": "\nundefined8 rl_crlf(void)\n\n{\n  putc(10,_rl_out_stream);\n  return 0;\n}\n\n",
  "FUN_001a2cc0": "\nint FUN_001a2cc0(int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long lVar5;\n  \n  iVar1 = sh_chkwrite(0);\n  if (the_current_working_directory == 0) {\n    lVar5 = get_working_directory(&DAT_00210a34);\n  }\n  else {\n    lVar5 = the_current_working_directory;\n    if (param_1 == 0) goto LAB_001a2cec;\n    lVar5 = sh_physpath(the_current_working_directory,0);\n  }\n  param_1 = 0;\n  if (lVar5 == 0) {\n    param_1 = 1;\n    lVar5 = the_current_working_directory;\n  }\nLAB_001a2cec:\n  iVar2 = array_needs_making;\n  uVar3 = get_string_value(&DAT_001fc3d5);\n  lVar4 = bind_variable(&DAT_001fc3d2,uVar3,0);\n  if ((lVar4 != 0) && ((*(byte *)(lVar4 + 0x28) & 2) != 0)) {\n    iVar1 = 1;\n  }\n  if (((iVar2 == 0) && (array_needs_making != 0)) && ((*(byte *)(lVar4 + 0x28) & 1) != 0)) {\n    update_export_env_inplace(&DAT_0020f214,7,uVar3);\n    array_needs_making = 0;\n  }\n  iVar2 = FUN_001a2c10(lVar5);\n  if (iVar2 == 1) {\n    iVar1 = 1;\n  }\n  if ((param_1 != 0) && (DAT_00248a7c != 0)) {\n    iVar1 = param_1;\n  }\n  if ((lVar5 != 0) && (the_current_working_directory != lVar5)) {\n    sh_xfree(lVar5,\"./cd.def\",0xb2);\n  }\n  return iVar1;\n}\n\n",
  "FUN_001d4610": "\nundefined8 FUN_001d4610(char *param_1,int param_2,int param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined8 uVar3;\n  size_t sVar4;\n  long in_FS_OFFSET;\n  int local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((param_1 != (char *)0x0) && (*param_1 != '\\0')) && (-1 < DAT_0024a478)) {\n    iVar1 = FUN_001d44a0(param_1,DAT_0024a478 + param_2,param_2,param_3,&local_34);\n    if (iVar1 != -1) {\n      DAT_0024a478 = iVar1;\n      uVar2 = where_history();\n      history_set_pos(DAT_0024a478);\n      uVar3 = current_history();\n      if (rl_editing_mode != 0) {\n        history_set_pos(uVar2);\n      }\n      FUN_001d4590(uVar3);\n      iVar1 = rl_end;\n      if (((_rl_enable_active_region == 0) || (param_3 != 0)) ||\n         ((local_34 < 1 || (rl_end <= local_34)))) {\n        rl_point = 0;\n        rl_mark = rl_end;\n      }\n      else {\n        rl_point = local_34;\n        sVar4 = strlen(param_1);\n        rl_mark = local_34 + (int)sVar4;\n        if (iVar1 < rl_mark) {\n          rl_mark = iVar1;\n        }\n        rl_activate_mark();\n      }\n      rl_clear_message();\n      uVar3 = 1;\n      goto LAB_001d471f;\n    }\n    rl_maybe_unsave_line();\n    rl_clear_message();\n    rl_point = 0;\n  }\n  rl_ding();\n  uVar3 = 0;\nLAB_001d471f:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
  "array_patsub": "\nundefined8 array_patsub(long param_1,undefined8 param_2,undefined8 param_3,uint param_4)\n\n{\n  long *plVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  if ((((param_1 == 0) || (*(long *)(param_1 + 0x10) == 0)) || (*(long *)(param_1 + 8) == 0)) ||\n     (plVar1 = (long *)array_to_word_list(), plVar5 = plVar1, plVar1 == (long *)0x0)) {\n    uVar3 = 0;\n  }\n  else {\n    do {\n      lVar2 = pat_subst(*(undefined8 *)plVar5[1],param_2,param_3,param_4);\n      plVar4 = (long *)plVar5[1];\n      if (*plVar4 != 0) {\n        sh_xfree(*plVar4,\"array.c\",0x1cd);\n        plVar4 = (long *)plVar5[1];\n      }\n      plVar5 = (long *)*plVar5;\n      *plVar4 = lVar2;\n    } while (plVar5 != (long *)0x0);\n    uVar3 = string_list_pos_params\n                      ((-((param_4 & 0x80) == 0) & 0x16U) + 0x2a,plVar1,(int)param_4 >> 5 & 1,\n                       (int)param_4 >> 3 & 8);\n    dispose_words(plVar1);\n  }\n  return uVar3;\n}\n\n",
  "pcomp_set_compspec_options": "\nvoid pcomp_set_compspec_options(long param_1,uint param_2,int param_3)\n\n{\n  if ((param_1 == 0) && (param_1 = pcomp_curcs, pcomp_curcs == 0)) {\n    return;\n  }\n  if (param_3 != 0) {\n    *(ulong *)(param_1 + 0x10) = (long)(int)param_2 | *(ulong *)(param_1 + 0x10);\n    return;\n  }\n  *(ulong *)(param_1 + 0x10) = (long)(int)~param_2 & *(ulong *)(param_1 + 0x10);\n  return;\n}\n\n",
  "array_modcase": "\nundefined8 array_modcase(long param_1,undefined8 param_2,undefined4 param_3,uint param_4)\n\n{\n  long *plVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  if ((((param_1 == 0) || (*(long *)(param_1 + 0x10) == 0)) || (*(long *)(param_1 + 8) == 0)) ||\n     (plVar1 = (long *)array_to_word_list(), plVar5 = plVar1, plVar1 == (long *)0x0)) {\n    uVar3 = 0;\n  }\n  else {\n    do {\n      lVar2 = sh_modcase(*(undefined8 *)plVar5[1],param_2,param_3);\n      plVar4 = (long *)plVar5[1];\n      if (*plVar4 != 0) {\n        sh_xfree(*plVar4,\"array.c\",0x1ef);\n        plVar4 = (long *)plVar5[1];\n      }\n      plVar5 = (long *)*plVar5;\n      *plVar4 = lVar2;\n    } while (plVar5 != (long *)0x0);\n    uVar3 = string_list_pos_params\n                      ((-((param_4 & 0x80) == 0) & 0x16U) + 0x2a,plVar1,(int)param_4 >> 5 & 1,\n                       (int)param_4 >> 3 & 8);\n    dispose_words(plVar1);\n  }\n  return uVar3;\n}\n\n",
  "_rl_init_executing_keyseq": "\nvoid _rl_init_executing_keyseq(void)\n\n{\n  rl_key_sequence_length = 0;\n  *rl_executing_keyseq = 0;\n  return;\n}\n\n",
  "find_variable_nameref_for_assignment": "\nundefined1 * find_variable_nameref_for_assignment(undefined8 param_1)\n\n{\n  int iVar1;\n  undefined1 *puVar2;\n  undefined *puVar3;\n  \n  puVar2 = (undefined1 *)find_variable_last_nameref(param_1,1);\n  if (puVar2 != (undefined1 *)0x0) {\n    if ((*(uint *)(puVar2 + 0x28) & 0x1800) == 0x1800) {\n      internal_warning(\"%s: removing nameref attribute\",param_1);\n      *(uint *)(puVar2 + 0x28) = *(uint *)(puVar2 + 0x28) & 0xfffff7ff;\n    }\n    if ((puVar2[0x29] & 8) != 0) {\n      iVar1 = valid_nameref_value(*(undefined8 *)(puVar2 + 8),1);\n      if (iVar1 == 0) {\n        puVar3 = *(undefined **)(puVar2 + 8);\n        puVar2 = nameref_invalid_value;\n        if (puVar3 == (undefined *)0x0) {\n          puVar3 = &DAT_00213d70;\n        }\n        sh_invalidid(puVar3);\n      }\n    }\n  }\n  return puVar2;\n}\n\n",
  "mbsmbchar": "\nbyte * mbsmbchar(byte *param_1)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  int iVar3;\n  size_t sVar4;\n  ulong uVar5;\n  long in_FS_OFFSET;\n  mbstate_t local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28.__count = 0;\n  local_28.__value = (_union_27)0x0;\n  if (locale_utf8locale == 0) {\n    sVar4 = __ctype_get_mb_cur_max();\n    bVar2 = *param_1;\n    while (bVar2 != 0) {\n      if ((*(uint *)(is_basic_table + (ulong)(bVar2 >> 5) * 4) >> (bVar2 & 0x1f) & 1) == 0) {\n        if (locale_utf8locale == 0) {\n          uVar5 = mbrtowc((wchar_t *)0x0,(char *)param_1,(long)(int)sVar4,&local_28);\n        }\n        else {\n          iVar3 = utf8_mblen(param_1,(long)(int)sVar4);\n          uVar5 = (ulong)iVar3;\n        }\n        if (uVar5 == 0) break;\n        if ((uVar5 != 1) && (uVar5 < 0xfffffffffffffffe)) goto LAB_001cc6c2;\n      }\n      pbVar1 = param_1 + 1;\n      param_1 = param_1 + 1;\n      bVar2 = *pbVar1;\n    }\n    param_1 = (byte *)0x0;\n  }\n  else {\n    param_1 = (byte *)utf8_mbsmbchar();\n  }\nLAB_001cc6c2:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0014a430": "\nvoid FUN_0014a430(long *param_1)\n\n{\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_128);\n  sigaddset(&sStack_128,0x11);\n  sigemptyset(&local_a8);\n  sigprocmask(0,&sStack_128,&local_a8);\n  *(undefined4 *)((long)param_1 + 0x24) = 3;\n  coproc_unsetvars(param_1);\n  if (*param_1 != 0) {\n    sh_xfree(*param_1,\"execute_cmd.c\",0x81d);\n  }\n  if (-1 < *(int *)((long)param_1 + 0xc)) {\n    close(*(int *)((long)param_1 + 0xc));\n    *(undefined4 *)((long)param_1 + 0xc) = 0xffffffff;\n  }\n  if (-1 < *(int *)(param_1 + 2)) {\n    close(*(int *)(param_1 + 2));\n  }\n  *param_1 = 0;\n  param_1[1] = -1;\n  param_1[2] = -1;\n  param_1[3] = 0xffffffff;\n  param_1[4] = 0;\n  sigprocmask(2,&local_a8,(sigset_t *)0x0);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "array_rshift": "\nlong array_rshift(undefined8 *param_1,int param_2,long param_3)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  long lVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    return 0;\n  }\n  lVar3 = param_1[1];\n  if (lVar3 == 0) {\n    if (param_3 == 0) {\n      return 0;\n    }\n    if (param_2 < 1) {\n      return 0;\n    }\n    plVar5 = *(long **)(param_1[2] + 0x10);\n  }\n  else {\n    if (param_2 < 1) {\n      return lVar3;\n    }\n    plVar4 = (long *)param_1[2];\n    plVar5 = (long *)plVar4[2];\n    if (param_3 == 0) goto LAB_00188e29;\n  }\n  lVar2 = array_create_element(0,param_3);\n  lVar3 = plVar5[3];\n  *(long *)(lVar3 + 0x10) = lVar2;\n  *(long *)(lVar2 + 0x18) = lVar3;\n  plVar5[3] = lVar2;\n  *(long **)(lVar2 + 0x10) = plVar5;\n  lVar3 = param_1[1] + 1;\n  param_1[1] = lVar3;\n  if (lVar3 == 1) {\n    *param_1 = 0;\n    return 1;\n  }\n  plVar4 = (long *)param_1[2];\nLAB_00188e29:\n  for (; plVar4 != plVar5; plVar5 = (long *)plVar5[2]) {\n    *plVar5 = *plVar5 + (long)param_2;\n  }\n  uVar1 = *(undefined8 *)plVar4[3];\n  param_1[3] = 0;\n  *param_1 = uVar1;\n  return lVar3;\n}\n\n",
  "rl_mark_active_p": "\nundefined4 rl_mark_active_p(void)\n\n{\n  return DAT_0024b688;\n}\n\n",
  "killpg": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint killpg(__pid_t __pgrp,int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_killpg_00237bf8)();\n  return iVar1;\n}\n\n",
  "_rl_read_bracketed_paste_prefix": "\nint _rl_read_bracketed_paste_prefix(ulong param_1)\n\n{\n  char *pcVar1;\n  int iVar2;\n  char cVar3;\n  int iVar4;\n  int unaff_EBX;\n  long lVar5;\n  int iVar6;\n  long in_FS_OFFSET;\n  char local_37 [7];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar6 = 0;\n  if ((int)param_1 == 0x1b) {\n    local_37[0] = '\\x1b';\n    lVar5 = 1;\n    do {\n      iVar2 = (int)lVar5;\n      iVar6 = iVar2 + -1;\n      if (((((rl_readline_state & 0x20800) != 0) ||\n           (iVar4 = _rl_pushed_input_available(param_1), iVar4 != 0)) ||\n          (iVar4 = _rl_input_queued(0), iVar4 == 0)) || (unaff_EBX = rl_read_key(), unaff_EBX < 0))\n      {\n        param_1 = (ulong)(uint)(int)local_37[iVar6];\nLAB_001ea0d8:\n        iVar6 = iVar6 + -1;\n        lVar5 = (long)iVar6;\n        _rl_unget_char(param_1);\n        while (iVar6 != -1) {\n          pcVar1 = local_37 + lVar5;\n          lVar5 = lVar5 + -1;\n          _rl_unget_char((int)*pcVar1);\n          iVar6 = (int)lVar5;\n        }\n        iVar6 = 0;\n        if (unaff_EBX < 1) {\n          iVar6 = unaff_EBX;\n        }\n        goto LAB_001ea0b4;\n      }\n      cVar3 = (char)unaff_EBX;\n      local_37[lVar5] = cVar3;\n      param_1 = (ulong)(uint)(int)cVar3;\n      if (cVar3 != (&DAT_002129fe)[lVar5]) {\n        iVar6 = iVar2;\n        if (iVar2 != 5) goto LAB_001ea0d8;\n        break;\n      }\n      lVar5 = lVar5 + 1;\n    } while (lVar5 != 6);\n    iVar6 = 1;\n  }\nLAB_001ea0b4:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar6;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0016a7c0": "\nulong FUN_0016a7c0(long param_1,ulong param_2,uint param_3,uint param_4)\n\n{\n  byte bVar1;\n  char cVar2;\n  mbstate_t mVar3;\n  uint uVar4;\n  size_t sVar5;\n  ulong uVar6;\n  int iVar7;\n  ulong uVar8;\n  byte *pbVar9;\n  long in_FS_OFFSET;\n  bool bVar10;\n  int local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  uVar6 = (ulong)(int)param_3;\n  pbVar9 = (byte *)(param_1 + uVar6);\n  bVar10 = false;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  bVar1 = *pbVar9;\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  uVar8 = uVar6;\n  mVar3 = local_48;\n  while (local_48 = mVar3, bVar1 != 0) {\n    while( true ) {\n      uVar4 = (uint)(char)bVar1;\n      iVar7 = (int)uVar8;\n      if (uVar4 == 0x5c) break;\n      if (bVar10) {\n        bVar10 = uVar4 != 0x60;\n        goto joined_r0x0016a879;\n      }\n      if (uVar4 != 0x60) {\n        if (uVar4 == 0x24) {\n          cVar2 = *(char *)(param_1 + 1 + uVar6);\n          if ((cVar2 != '(') && (cVar2 != '{')) goto joined_r0x0016a879;\n          local_4c = iVar7 + 2;\n          if (cVar2 == '(') {\n            extract_command_subst(param_1,&local_4c,param_4 | 1);\n          }\n          else {\n            FUN_001691b0(param_1,&local_4c,1,1);\n          }\n          iVar7 = local_4c;\n          if (param_2 <= (ulong)(long)local_4c) {\n            uVar6 = param_2 & 0xffffffff;\n            goto LAB_0016a83f;\n          }\n        }\n        else {\n          if (uVar4 == 0x22) {\n            uVar6 = (ulong)(iVar7 + 1);\n            goto LAB_0016a83f;\n          }\njoined_r0x0016a879:\n          if (1 < locale_mb_cur_max) {\n            if ((*(uint *)(is_basic_table + (ulong)(uVar4 >> 5 & 7) * 4) >> (bVar1 & 0x1f) & 1) != 0\n               ) {\n              uVar8 = (ulong)(iVar7 + 1);\n              goto LAB_0016a8d1;\n            }\n            if ((locale_utf8locale != 0) && (-1 < (char)bVar1)) {\n              uVar8 = (ulong)(iVar7 + 1);\n              goto LAB_0016a8d1;\n            }\n            sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar9,param_2 - uVar6,&local_48);\n            if (0xfffffffffffffffd < sVar5) {\n              uVar8 = (ulong)(iVar7 + 1);\n              local_48 = mVar3;\n              goto LAB_0016a8d1;\n            }\n            if (sVar5 != 0) {\n              uVar8 = (ulong)(uint)(iVar7 + (int)sVar5);\n              goto LAB_0016a8d1;\n            }\n          }\n        }\n        uVar8 = (ulong)(iVar7 + 1);\n        goto LAB_0016a8d1;\n      }\n      param_3 = iVar7 + 1;\n      uVar8 = (ulong)param_3;\n      uVar6 = (ulong)(int)param_3;\n      pbVar9 = (byte *)(param_1 + uVar6);\n      bVar1 = *pbVar9;\n      if (bVar1 == 0) goto LAB_0016a8e6;\n      bVar10 = true;\n    }\n    uVar4 = iVar7 + 1;\n    uVar6 = (ulong)uVar4;\n    pbVar9 = (byte *)(param_1 + (int)uVar4);\n    bVar1 = *pbVar9;\n    if (bVar1 == 0) goto LAB_0016a83f;\n    if (locale_mb_cur_max < 2) {\n      uVar8 = (ulong)(iVar7 + 2);\n      goto LAB_0016a8d1;\n    }\n    if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n      if ((locale_utf8locale != 0) && (sVar5 = 1, -1 < (char)bVar1)) goto LAB_0016a985;\n      sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar9,param_2 - (long)(int)uVar4,&local_48);\n      if (sVar5 < 0xfffffffffffffffe) {\n        uVar8 = (ulong)(iVar7 + 2);\n        if (sVar5 != 0) goto LAB_0016a985;\n      }\n      else {\n        uVar8 = (ulong)(iVar7 + 2);\n        local_48 = mVar3;\n      }\n    }\n    else {\n      sVar5 = 1;\nLAB_0016a985:\n      uVar8 = (ulong)(uVar4 + (int)sVar5);\n    }\nLAB_0016a8d1:\n    param_3 = (uint)uVar8;\n    uVar6 = (ulong)(int)param_3;\n    pbVar9 = (byte *)(param_1 + uVar6);\n    mVar3 = local_48;\n    bVar1 = *pbVar9;\n  }\nLAB_0016a8e6:\n  uVar6 = (ulong)param_3;\nLAB_0016a83f:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar6;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00193570": "\nvoid FUN_00193570(int param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  if ((0 < param_1) && (1 < locale_mb_cur_max)) {\n    param_1 = _rl_find_next_mbchar(rl_line_buffer,0,param_1);\n  }\n  if (*param_2 != param_1) {\n    iVar2 = 0;\n    if (-1 < param_1) {\n      iVar2 = param_1;\n    }\n    iVar1 = rl_end;\n    if (param_1 <= rl_end) {\n      iVar1 = iVar2;\n    }\n    *param_2 = iVar1;\n  }\n  return;\n}\n\n",
  "addtimeval": "\nlong * addtimeval(long *param_1,long *param_2,long *param_3)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  \n  lVar1 = *param_3;\n  lVar2 = *param_2;\n  lVar3 = param_3[1] + param_2[1];\n  *param_1 = lVar1 + lVar2;\n  if (lVar3 < 1000000) {\n    param_1[1] = lVar3;\n    return param_1;\n  }\n  param_1[1] = lVar3 + -1000000;\n  *param_1 = lVar1 + lVar2 + 1;\n  return param_1;\n}\n\n",
  "FUN_001edf90": "\nundefined8 FUN_001edf90(int param_1,int param_2,int param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  undefined auStack_48 [24];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = _rl_read_mbchar(auStack_48,0x10);\n  uVar2 = 1;\n  if (0 < iVar1) {\n    if (param_1 < 0) {\n      if (param_3 != 0) {\n        uVar2 = FUN_001edde0(-param_1,param_3,auStack_48);\n      }\n    }\n    else if (param_2 != 0) {\n      uVar2 = FUN_001edde0(param_1,param_2,auStack_48);\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "sh_getopt_restore_istate": "\nvoid sh_getopt_restore_istate(undefined8 *param_1)\n\n{\n  sh_optarg = *param_1;\n  sh_optind = *(undefined4 *)(param_1 + 1);\n  DAT_00248de0 = *(undefined4 *)((long)param_1 + 0xc);\n  DAT_00248dd8 = param_1[2];\n  DAT_00248dd0 = *(undefined4 *)(param_1 + 3);\n  sh_xfree(param_1,\"getopt.c\",0xef);\n  return;\n}\n\n",
  "list_one_job": "\nvoid list_one_job(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  FUN_0015f5f0(param_4,param_2,stdout);\n  if ((DAT_0023877c != 0) && (DAT_00247660 == 0)) {\n    FUN_001626a0();\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00168d30": "\nundefined8 FUN_00168d30(char *param_1,uint param_2,undefined4 *param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  if (param_1 == (char *)0x0) {\n    if (param_3 != (undefined4 *)0x0) {\n      *param_3 = 0;\n    }\n    if (param_4 == (undefined4 *)0x0) {\n      return 0;\n    }\n    *param_4 = 0;\n    return 0;\n  }\n  if (*param_1 == '@') {\n    if (param_1[1] != '\\0') goto LAB_00168d6c;\nLAB_00168de6:\n    if (((param_2 & 3) != 0) && (param_3 != (undefined4 *)0x0)) {\n      *param_3 = 1;\n    }\n  }\n  else {\n    if (((*param_1 == '*') && (param_1[1] == '\\0')) && (param_2 == 0)) {\n      if (param_4 == (undefined4 *)0x0) {\n        return 1;\n      }\n      if (DAT_00247848 != 0) {\n        return 1;\n      }\n      goto LAB_00168dc5;\n    }\nLAB_00168d6c:\n    iVar1 = valid_array_reference(param_1,0);\n    if ((iVar1 == 0) || (lVar2 = mbschr(param_1,0x5b), lVar2 == 0)) {\n      return 0;\n    }\n    if (*(char *)(lVar2 + 1) == '@') {\n      if (*(char *)(lVar2 + 2) != ']') {\n        return 0;\n      }\n      goto LAB_00168de6;\n    }\n    if (*(char *)(lVar2 + 1) != '*') {\n      return 0;\n    }\n    if (*(char *)(lVar2 + 2) != ']') {\n      return 0;\n    }\n    if (param_2 != 0) {\n      return 0;\n    }\n  }\n  if (param_4 == (undefined4 *)0x0) {\n    return 1;\n  }\nLAB_00168dc5:\n  *param_4 = 1;\n  return 1;\n}\n\n",
  "zwrite": "\nulong zwrite(int param_1,void *param_2,int param_3)\n\n{\n  int iVar1;\n  ssize_t sVar2;\n  int *piVar3;\n  int iVar4;\n  size_t sVar5;\n  size_t __n;\n  int iVar6;\n  \n  iVar6 = 0;\n  sVar5 = (size_t)param_3;\n  __n = sVar5;\n  iVar4 = param_3;\n  do {\n    while( true ) {\n      while( true ) {\n        sVar2 = write(param_1,param_2,__n);\n        iVar1 = (int)sVar2;\n        if (iVar1 < 1) break;\n        iVar4 = iVar4 - iVar1;\n        if (iVar4 < 1) goto LAB_001cd9cc;\n        __n = (size_t)iVar4;\n        param_2 = (void *)((long)param_2 + (long)iVar1);\n      }\n      if (iVar1 == 0) break;\n      piVar3 = __errno_location();\n      if (*piVar3 != 4) {\n        sVar5 = 0xffffffff;\nLAB_001cd9cc:\n        return sVar5 & 0xffffffff;\n      }\n    }\n    iVar6 = iVar6 + 1;\n  } while (iVar6 < 4);\n  sVar5 = (size_t)(uint)(param_3 - iVar4);\n  goto LAB_001cd9cc;\n}\n\n",
  "tgetflag": "\nvoid tgetflag(void)\n\n{\n  (*(code *)PTR_tgetflag_00237c48)();\n  return;\n}\n\n",
  "FUN_0014fdd0": "\nuint FUN_0014fdd0(int *param_1,uint param_2,uint param_3,int param_4,int *param_5)\n\n{\n  long lVar1;\n  bool bVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  int iVar5;\n  int iVar6;\n  uint uVar7;\n  long lVar8;\n  size_t sVar9;\n  char *__dest;\n  char *pcVar10;\n  ulong uVar11;\n  long in_FS_OFFSET;\n  byte local_170;\n  int local_168;\n  undefined4 local_164;\n  int local_160;\n  undefined4 local_15c;\n  uint local_150;\n  int local_14c;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  uVar11 = (ulong)param_3;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_148);\n  sigaddset(&local_148,0x11);\n  sigemptyset(&local_c8);\n  sigprocmask(0,&local_148,&local_c8);\n  uVar4 = param_1[1] & 8;\n  iVar5 = sh_validfd(0);\n  do {\n    if (((*param_1 != 6) || (*(long *)(param_1 + 6) == 0)) ||\n       (*(int *)(*(long *)(param_1 + 6) + 0x18) != 0x7c)) {\n      local_164 = last_made_pid;\n      if (uVar4 != 0) {\n        param_1[1] = param_1[1] | 8;\n      }\n      goto LAB_00150096;\n    }\n    iVar6 = pipe((int *)&local_150);\n    if (iVar6 < 0) {\n      uVar4 = 1;\n      sys_error(\"pipe error\");\n      terminate_current_pipeline();\n      kill_current_pipeline();\n      sigprocmask(2,&local_c8,(sigset_t *)0x0);\n      last_command_exit_value = 1;\n      throw_to_top_level();\n      goto LAB_00150191;\n    }\n    iVar6 = *param_5;\n    if (*param_5 <= (int)local_150) {\n      iVar6 = local_150 + 8;\n    }\n    lVar8 = new_fd_bitmap(iVar6);\n    xbcopy(*(undefined8 *)(param_5 + 2),*(undefined8 *)(lVar8 + 8),*param_5);\n    *(undefined *)(*(long *)(lVar8 + 8) + (long)(int)local_150) = 1;\n    begin_unwind_frame(\"pipe-file-descriptors\");\n    add_unwind_protect(dispose_fd_bitmap,lVar8);\n    add_unwind_protect(close_fd_bitmap,lVar8);\n    if ((int)uVar11 < 0) {\n      add_unwind_protect(PTR_close_00237f50,local_14c);\n      add_unwind_protect(FUN_00147c90,&local_c8);\n      if (uVar4 == 0) {\n        execute_command_internal\n                  (*(undefined8 *)(*(long *)(param_1 + 6) + 8),param_2,uVar11,local_14c,lVar8);\n      }\n      else {\n        lVar1 = *(long *)(*(long *)(param_1 + 6) + 8);\n        if (lVar1 == 0) {\n          execute_command_internal(0,param_2,uVar11,local_14c,lVar8);\n        }\n        else {\n          *(uint *)(lVar1 + 4) = *(uint *)(lVar1 + 4) | 8;\n          execute_command_internal(lVar1,param_2,uVar11,local_14c,lVar8);\n        }\n      }\n    }\n    else {\n      add_unwind_protect(PTR_close_00237f50,uVar11);\n      add_unwind_protect(PTR_close_00237f50,local_14c);\n      add_unwind_protect(FUN_00147c90,&local_c8);\n      if (uVar4 == 0) {\n        execute_command_internal\n                  (*(undefined8 *)(*(long *)(param_1 + 6) + 8),param_2,uVar11,local_14c,lVar8);\n      }\n      else {\n        lVar1 = *(long *)(*(long *)(param_1 + 6) + 8);\n        if (lVar1 == 0) {\n          execute_command_internal(0,param_2,uVar11,local_14c,lVar8);\n        }\n        else {\n          *(uint *)(lVar1 + 4) = *(uint *)(lVar1 + 4) | 8;\n          execute_command_internal(lVar1,param_2,uVar11,local_14c,lVar8);\n        }\n      }\n      close((int)uVar11);\n    }\n    uVar11 = (ulong)local_150;\n    close(local_14c);\n    if (*(long *)(lVar8 + 8) != 0) {\n      sh_xfree(*(long *)(lVar8 + 8),\"execute_cmd.c\",0x159);\n    }\n    sh_xfree(lVar8,\"execute_cmd.c\",0x15a);\n    discard_unwind_frame(\"pipe-file-descriptors\");\n    param_1 = *(int **)(*(long *)(param_1 + 6) + 0x10);\n  } while (param_1 != (int *)0x0);\n  local_164 = last_made_pid;\nLAB_00150096:\n  begin_unwind_frame(\"lastpipe-exec\");\n  if (lastpipe_opt == 0) {\n    local_170 = 0;\n    local_168 = -2;\n    bVar2 = false;\nLAB_001500c0:\n    if (-1 < (int)uVar11) goto LAB_00150318;\nLAB_001500c9:\n    uVar4 = execute_command_internal(param_1,param_2,uVar11,param_4,param_5);\n  }\n  else {\n    if ((param_2 | job_control) != 0) {\n      local_170 = 0;\n      bVar2 = false;\n      local_168 = -2;\n      goto LAB_001500c0;\n    }\n    iVar6 = (int)uVar11;\n    local_170 = param_4 == -1 & (byte)~(byte)(uVar11 >> 0x18) >> 7;\n    bVar2 = false;\n    if (local_170 == 0) {\n      local_168 = -2;\n      goto LAB_001500c0;\n    }\n    if ((iVar6 < 1) || (iVar5 == 0)) {\n      iVar5 = dup2(iVar6,0);\n      local_168 = -1;\n      if (iVar5 < 0) {\nLAB_001504b3:\n        sys_error(\"cannot duplicate fd %d to fd %d\",uVar11,0);\n      }\n      if (iVar6 != 0) {\nLAB_001504a6:\n        close(iVar6);\n      }\n      uVar11 = 0xffffffff;\n      add_unwind_protect(FUN_00149790,local_168);\n      local_15c = freeze_jobs_list();\n      local_160 = stop_pipeline(0,0);\n      bVar2 = true;\n      add_unwind_protect(set_jobs_list_frozen,local_15c);\n      sigprocmask(2,&local_c8,(sigset_t *)0x0);\n      if (param_1 != (int *)0x0) {\nLAB_0015029d:\n        param_1[1] = param_1[1] | 0x2000;\n        goto LAB_001500c0;\n      }\n      goto LAB_001500c9;\n    }\n    local_168 = move_to_high_fd(0,1,0xffffffff);\n    if (0 < local_168 || local_168 == -1) {\n      iVar5 = dup2(iVar6,0);\n      if (iVar5 < 0) goto LAB_001504b3;\n      goto LAB_001504a6;\n    }\n    local_170 = 0;\n    if (param_1 != (int *)0x0) goto LAB_0015029d;\nLAB_00150318:\n    add_unwind_protect(PTR_close_00237f50,uVar11);\n    uVar4 = execute_command_internal(param_1,param_2,uVar11,param_4,param_5);\n    close((int)uVar11);\n  }\n  if (local_170 != 0) {\n    if (local_168 == -1) {\n      close(0);\n    }\n    else {\n      dup2(local_168,0);\n      close(local_168);\n    }\n  }\n  sigprocmask(2,&local_c8,(sigset_t *)0x0);\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n  }\n  uVar3 = dollar_dollar_pid;\n  pcVar10 = the_printed_command_except_trap;\n  if (!bVar2) goto LAB_00150189;\n  if (local_160 < 0) {\n    uVar7 = wait_for_single_pid(local_164,0);\n    if (0x100 < (int)uVar7) {\n      uVar7 = 0x7f;\n    }\nLAB_001502c8:\n    if (pipefail_opt != 0) {\n      uVar4 = uVar4 | uVar7;\n    }\n  }\n  else {\n    if ((local_160 < DAT_0023877c) && (*(long *)(jobs + (long)local_160 * 8) != 0)) {\n      sVar9 = strlen(the_printed_command_except_trap);\n      __dest = (char *)sh_xmalloc(sVar9 + 1,\"execute_cmd.c\",0xa5e);\n      pcVar10 = strcpy(__dest,pcVar10);\n      append_process(pcVar10,uVar3,uVar4,local_160);\n      uVar7 = wait_for(local_164,0);\n    }\n    else {\n      uVar7 = wait_for_single_pid(local_164,0);\n      if (0x100 < (int)uVar7) {\n        uVar7 = 0x7f;\n      }\n    }\n    if ((DAT_0023877c <= local_160) || (*(long *)(jobs + (long)local_160 * 8) == 0))\n    goto LAB_001502c8;\n    uVar4 = job_exit_status();\n  }\n  set_jobs_list_frozen(local_15c);\nLAB_00150189:\n  discard_unwind_frame(\"lastpipe-exec\");\nLAB_00150191:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n",
  "getpgrp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__pid_t getpgrp(void)\n\n{\n  __pid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_getpgrp_00237d28)();\n  return _Var1;\n}\n\n",
  "_rl_untranslate_macro_value": "\nundefined2 * _rl_untranslate_macro_value(byte *param_1,int param_2)\n\n{\n  undefined2 *puVar1;\n  byte bVar2;\n  ushort uVar3;\n  ushort *puVar4;\n  size_t sVar5;\n  undefined2 *puVar6;\n  undefined2 *puVar7;\n  ushort **ppuVar8;\n  __int32_t **pp_Var9;\n  __int32_t *p_Var10;\n  uint uVar11;\n  undefined uVar12;\n  uint uVar13;\n  ulong uVar14;\n  bool bVar15;\n  \n  sVar5 = strlen((char *)param_1);\n  puVar6 = (undefined2 *)xmalloc(sVar5 * 7 + 1);\n  bVar2 = *param_1;\n  puVar1 = puVar6;\n  do {\n    if (bVar2 == 0) {\n      *(undefined *)puVar1 = 0;\n      return puVar6;\n    }\n    uVar11 = (uint)(char)bVar2;\n    if (bVar2 == 0x1b) {\n      *(undefined *)puVar1 = 0x5c;\n      uVar12 = 0x65;\n      puVar7 = (undefined2 *)((long)puVar1 + 1);\n    }\n    else if (bVar2 < 0x20) {\n      *(undefined *)puVar1 = 0x5c;\n      if ((param_2 == 0) || (6 < uVar11 - 7)) {\n        puVar7 = (undefined2 *)((long)puVar1 + 3);\n        uVar13 = bVar2 | 0x40;\n        *(undefined2 *)((long)puVar1 + 1) = 0x2d43;\n        uVar14 = (ulong)(char)uVar13;\n        ppuVar8 = __ctype_b_loc();\n        puVar4 = *ppuVar8;\n        uVar3 = puVar4[uVar14];\n        if ((uVar3 & 0x200) == 0) {\n          if ((uVar3 & 0x100) == 0) {\n            uVar11 = (uint)(char)uVar13;\n            bVar15 = false;\n            goto LAB_001dc17d;\n          }\n          pp_Var9 = __ctype_tolower_loc();\n          p_Var10 = *pp_Var9;\n        }\n        else {\n          pp_Var9 = __ctype_toupper_loc();\n          uVar11 = (*pp_Var9)[uVar14];\n          uVar14 = (ulong)(uVar11 & 0xff);\n          if ((*(byte *)((long)puVar4 + uVar14 * 2 + 1) & 1) == 0) goto LAB_001dc21e;\n          pp_Var9 = __ctype_tolower_loc();\n          p_Var10 = *pp_Var9;\n        }\n        uVar11 = p_Var10[uVar14];\n      }\n      else {\n        puVar7 = (undefined2 *)((long)puVar1 + 1);\n        uVar11 = *(uint *)(&DAT_00213c50 + (ulong)(uVar11 - 7) * 4);\n      }\nLAB_001dc21e:\n      if (uVar11 != 0x1b) {\n        bVar15 = uVar11 == 0x22;\n        uVar13 = uVar11;\n        goto LAB_001dc17d;\n      }\n      *(undefined *)puVar7 = 0x5c;\n      uVar12 = 0x65;\n      puVar7 = (undefined2 *)((long)puVar7 + 1);\n    }\n    else {\n      bVar15 = uVar11 == 0x22;\n      puVar7 = puVar1;\n      uVar13 = (uint)bVar2;\n      if (uVar11 == 0x7f) {\n        *(undefined *)(puVar1 + 1) = 0x2d;\n        uVar12 = 0x3f;\n        *puVar1 = 0x435c;\n        puVar7 = (undefined2 *)((long)puVar1 + 3);\n      }\n      else {\nLAB_001dc17d:\n        uVar12 = (undefined)uVar13;\n        if ((uVar11 == 0x5c) || (bVar15)) {\n          *(undefined *)puVar7 = 0x5c;\n          puVar7 = (undefined2 *)((long)puVar7 + 1);\n        }\n      }\n    }\n    param_1 = param_1 + 1;\n    *(undefined *)puVar7 = uVar12;\n    puVar1 = (undefined2 *)((long)puVar7 + 1);\n    bVar2 = *param_1;\n  } while( true );\n}\n\n",
  "FUN_001ee680": "\nvoid FUN_001ee680(int *param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = *param_1;\n  if (iVar1 < 0) {\n    *param_1 = iVar1 + 1;\n    iVar1 = FUN_001ee5e0(1);\n    _rl_want_redisplay = 1;\n    if ((-1 < *param_1) || (iVar1 != 0)) {\n      _rl_callback_func = 0;\n    }\n    return;\n  }\n  _rl_callback_func = 0;\n  _rl_want_redisplay = 1;\n  if (iVar1 == 0) {\n    return;\n  }\n  FUN_001ee5e0(iVar1);\n  return;\n}\n\n",
  "umatchlen": "\nint umatchlen(char *param_1)\n\n{\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  char cVar4;\n  char cVar5;\n  char *pcVar6;\n  char *pcVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  \n  cVar4 = *param_1;\n  iVar10 = 0;\n  if (cVar4 == '\\0') {\n    return 0;\n  }\n  bVar3 = false;\n  bVar1 = false;\n  bVar2 = false;\n  pcVar6 = param_1 + 1;\nLAB_001c40b0:\n  if (cVar4 < 'A') {\n    if (' ' < cVar4) {\n      switch(cVar4) {\n      case '!':\n      case '+':\n      case '?':\n      case '@':\n        if (param_1[1] == '(') {\n          return -1;\n        }\n        break;\n      case '*':\n        return -1;\n      }\n    }\nswitchD_001c40c9_caseD_22:\n    cVar4 = *pcVar6;\n    iVar10 = iVar10 + 1;\n    pcVar7 = pcVar6 + 1;\n    param_1 = pcVar6;\n  }\n  else {\n    if (cVar4 == '[') {\n      pcVar6 = param_1 + 2;\n      cVar4 = param_1[1];\n      iVar8 = 1;\nLAB_001c415e:\n      iVar9 = iVar8;\n      pcVar7 = pcVar6;\n      if (cVar4 == '\\0') {\n        cVar4 = pcVar7[-1];\n        param_1 = pcVar7 + -1;\n        iVar10 = iVar10 + iVar9;\n        goto LAB_001c40e8;\n      }\n      pcVar6 = pcVar7 + 1;\n      cVar5 = *pcVar7;\n      iVar8 = iVar9 + 1;\n      if (cVar4 == '\\\\') {\n        if ((cVar5 == '\\0') || (cVar5 = pcVar7[1], pcVar7 = pcVar6, cVar5 == '\\0')) {\n          return iVar10 + iVar8;\n        }\n      }\n      else {\n        if (cVar4 == '[') {\n          if (cVar5 == ':') {\n            cVar5 = pcVar7[1];\n            bVar1 = true;\n            pcVar7 = pcVar6;\n            goto LAB_001c4153;\n          }\n          if (cVar5 == '.') {\n            cVar4 = pcVar7[1];\n            bVar2 = true;\n            pcVar6 = pcVar7 + 2;\n            if (cVar4 != ']') goto LAB_001c415e;\n            cVar5 = pcVar7[2];\n          }\n          else {\n            if (cVar5 != '=') goto LAB_001c4153;\n            cVar4 = pcVar7[1];\n            bVar3 = true;\n            pcVar6 = pcVar7 + 2;\n            if (cVar4 != ']') goto LAB_001c415e;\n            cVar5 = pcVar7[2];\n          }\n          iVar8 = iVar9 + 2;\n          param_1 = pcVar7 + 3;\n          pcVar7 = pcVar7 + 2;\n          goto joined_r0x001c41d0;\n        }\n        if ((cVar4 == ':') && (bVar1)) {\n          if (cVar5 == ']') {\n            cVar5 = pcVar7[1];\n            bVar1 = false;\n            pcVar7 = pcVar6;\n          }\n          goto LAB_001c4153;\n        }\n        if ((cVar4 == '.') && (bVar2)) {\n          cVar4 = cVar5;\n          if (cVar5 != ']') goto LAB_001c415e;\n          cVar5 = pcVar7[1];\n          bVar2 = false;\n          pcVar7 = pcVar6;\n        }\n        else if ((cVar4 == '=') && (bVar3)) {\n          cVar4 = cVar5;\n          if (cVar5 != ']') goto LAB_001c415e;\n          cVar5 = pcVar7[1];\n          bVar3 = false;\n          pcVar7 = pcVar6;\n        }\n      }\nLAB_001c4153:\n      param_1 = pcVar7 + 1;\njoined_r0x001c41d0:\n      pcVar6 = param_1;\n      cVar4 = cVar5;\n      if (cVar5 == ']') goto LAB_001c41d8;\n      goto LAB_001c415e;\n    }\n    if (cVar4 != '\\\\') goto switchD_001c40c9_caseD_22;\n    iVar10 = iVar10 + 1;\n    if (param_1[1] == '\\0') {\n      return iVar10;\n    }\n    cVar4 = param_1[2];\n    pcVar7 = param_1 + 3;\n    param_1 = param_1 + 2;\n  }\n  goto LAB_001c40e8;\nLAB_001c41d8:\n  cVar4 = pcVar7[1];\n  iVar10 = iVar10 + 1;\n  pcVar7 = pcVar7 + 2;\nLAB_001c40e8:\n  pcVar6 = pcVar7;\n  if (cVar4 == '\\0') {\n    return iVar10;\n  }\n  goto LAB_001c40b0;\n}\n\n",
  "printf_builtin": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nuint printf_builtin(undefined8 param_1)\n\n{\n  byte bVar1;\n  undefined uVar2;\n  char cVar3;\n  undefined2 *puVar4;\n  undefined auVar5 [16];\n  undefined auVar6 [16];\n  undefined auVar7 [16];\n  bool bVar8;\n  bool bVar9;\n  bool bVar10;\n  undefined8 *puVar11;\n  char cVar12;\n  int iVar13;\n  uint uVar14;\n  char *pcVar15;\n  int *piVar16;\n  uintmax_t uVar17;\n  undefined8 uVar18;\n  undefined2 *puVar19;\n  size_t sVar20;\n  tm *__tp;\n  long lVar21;\n  undefined2 *puVar22;\n  char *pcVar23;\n  undefined8 *puVar24;\n  char *pcVar25;\n  ulong uVar26;\n  char cVar27;\n  char *pcVar28;\n  undefined4 uVar29;\n  undefined *puVar30;\n  undefined2 *puVar31;\n  undefined2 *puVar32;\n  undefined2 *puVar33;\n  long in_FS_OFFSET;\n  bool bVar34;\n  double dVar35;\n  undefined2 *local_140;\n  int local_118;\n  int local_100;\n  int local_f8;\n  int local_f4;\n  char *local_f0;\n  undefined local_e8 [16];\n  undefined8 local_d8;\n  undefined local_d0;\n  undefined local_c8 [2];\n  undefined auStack_c6 [14];\n  undefined8 local_b8;\n  undefined local_b0;\n  undefined local_49;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  _DAT_00248db0 = 0;\n  DAT_00248dac = 0;\n  reset_internal_getopt();\n  while (iVar13 = internal_getopt(param_1,&DAT_00210dfd), puVar11 = loptend, iVar13 != -1) {\n    if (iVar13 == -99) {\n      builtin_help();\n      uVar14 = 0x102;\n      goto LAB_001b8eaa;\n    }\n    if (iVar13 != 0x76) goto LAB_001b8ea0;\n    DAT_00248d98 = list_optarg;\n    if (assoc_expand_once == 0) {\n      DAT_00248da8 = 0;\n      uVar29 = 0;\nLAB_001b8ddc:\n      iVar13 = legal_identifier();\n    }\n    else {\n      DAT_00248da8 = 0x80;\n      uVar29 = 1;\n      if ((list_optflags._1_1_ & 2) == 0) goto LAB_001b8ddc;\n      DAT_00248da8 = 0x1080;\n      uVar29 = 3;\n      iVar13 = legal_identifier();\n    }\n    if ((iVar13 == 0) && (iVar13 = valid_array_reference(DAT_00248d98,uVar29), iVar13 == 0)) {\n      DAT_00248db4 = 0;\n      sh_invalidid(DAT_00248d98);\n      uVar14 = 0x102;\n      goto LAB_001b8eaa;\n    }\n    DAT_00248db4 = 1;\n    DAT_00248dac = 1;\n    if (DAT_00248d90 == 0) {\n      DAT_00248d90 = 0x10;\n      DAT_00248da0 = (undefined *)sh_xmalloc(0x10,\"./printf.def\",0x11c);\n    }\n    DAT_00248d88 = 0;\n    if (DAT_00248da0 != (undefined *)0x0) {\n      *DAT_00248da0 = 0;\n    }\n  }\n  if (loptend == (undefined8 *)0x0) {\nLAB_001b8ea0:\n    builtin_usage();\n    uVar14 = 0x102;\n    goto LAB_001b8eaa;\n  }\n  puVar4 = *(undefined2 **)loptend[1];\n  if (DAT_00248dac == 0) {\n    uVar14 = 0;\n    if ((puVar4 != (undefined2 *)0x0) && (bVar1 = *(byte *)puVar4, bVar1 != 0)) {\nLAB_001b8f62:\n      DAT_00248db4 = 0;\n      DAT_00248db8 = (undefined8 *)*loptend;\n      do {\n        DAT_00248d80 = 0;\n        puVar31 = puVar4;\n        while (bVar1 != 0) {\n          local_140 = (undefined2 *)((long)puVar31 + 1);\n          if (bVar1 == 0x5c) {\n            pcVar15 = local_e8;\n            local_d0 = 0;\n            local_d8 = 0;\n            local_e8 = (undefined  [16])0x0;\n            iVar13 = FUN_001b8070(local_140,pcVar15,&local_f8,0);\n            if (0 < local_f8) {\n              uVar14 = local_f8 - 1;\n              do {\n                auVar6._14_2_ = 0;\n                auVar6._0_14_ = auStack_c6;\n                _local_c8 = auVar6 << 0x10;\n                DAT_00248d80 = DAT_00248d80 + 1;\n                local_c8[0] = *pcVar15;\n                if (DAT_00248dac == 0) {\n                  putc((int)*pcVar15,stdout);\n                }\n                else {\n                  FUN_001b86c0(local_c8);\n                }\n                if (terminating_signal != 0) {\n                  termsig_handler(terminating_signal);\n                }\n                if (interrupt_state != 0) {\n                  throw_to_top_level();\n                }\n                pcVar15 = pcVar15 + 1;\n              } while (pcVar15 != local_e8 + (ulong)uVar14 + 1);\n            }\n            local_140 = (undefined2 *)((long)(undefined2 *)((long)iVar13 + (long)puVar31) + 1);\n            puVar31 = (undefined2 *)((long)iVar13 + (long)puVar31);\n            goto LAB_001b9001;\n          }\n          if (bVar1 != 0x25) {\n            DAT_00248d80 = DAT_00248d80 + 1;\n            local_c8[1] = 0;\n            local_c8[0] = bVar1;\n            if (DAT_00248dac == 0) {\n              putc((int)(char)bVar1,stdout);\n            }\n            else {\nLAB_001b97d0:\n              FUN_001b86c0(local_c8);\n            }\nLAB_001b8fd6:\n            if (terminating_signal != 0) {\n              termsig_handler(terminating_signal);\n            }\n            if (interrupt_state != 0) {\n              throw_to_top_level();\n            }\n            goto LAB_001b9001;\n          }\n          cVar27 = *(char *)((long)puVar31 + 1);\n          puVar33 = local_140;\n          if (cVar27 == '%') {\n            DAT_00248d80 = DAT_00248d80 + 1;\n            local_c8 = (undefined  [2])0x25;\n            if (DAT_00248dac == 0) {\n              putc(0x25,stdout);\n            }\n            else {\n              FUN_001b86c0(local_c8);\n            }\n            if (terminating_signal != 0) {\n              termsig_handler(terminating_signal);\n            }\n            if (interrupt_state != 0) {\n              throw_to_top_level();\n            }\n            puVar33 = puVar31 + 1;\n            puVar31 = local_140;\n            local_140 = puVar33;\n            goto LAB_001b9001;\n          }\n          while( true ) {\n            if (cVar27 == '\\0') goto LAB_001ba2d8;\n            pcVar15 = strchr(\"#\\'-+ 0\",(int)cVar27);\n            if (pcVar15 == (char *)0x0) break;\n            cVar27 = *(char *)((long)puVar33 + 1);\n            puVar33 = (undefined2 *)((long)puVar33 + 1);\n          }\n          if (cVar27 == '*') {\n            local_100 = FUN_001b8cb0();\n            puVar32 = (undefined2 *)((long)puVar33 + 1);\n            cVar27 = *(char *)((long)puVar33 + 1);\n            bVar9 = true;\n          }\n          else {\n            cVar27 = *(char *)puVar33;\n            puVar32 = puVar33;\n            while ((byte)(cVar27 - 0x30U) < 10) {\n              pcVar15 = (char *)((long)puVar32 + 1);\n              puVar32 = (undefined2 *)((long)puVar32 + 1);\n              cVar27 = *pcVar15;\n            }\n            bVar9 = false;\n            local_100 = 0;\n          }\n          bVar8 = false;\n          local_118 = 0;\n          puVar19 = (undefined2 *)0x0;\n          puVar33 = puVar32;\n          if (cVar27 == '.') {\n            cVar27 = *(char *)((long)puVar32 + 1);\n            if (cVar27 == '*') {\n              local_118 = FUN_001b8cb0();\n              puVar33 = puVar32 + 1;\n              cVar27 = *(char *)(puVar32 + 1);\n              bVar8 = true;\n            }\n            else {\n              puVar22 = (undefined2 *)((long)puVar32 + 1);\n              if (cVar27 == '-') {\n                cVar27 = *(char *)(puVar32 + 1);\n                puVar22 = puVar32 + 1;\n              }\n              puVar33 = puVar22;\n              if ((byte)(cVar27 - 0x30U) < 10) {\n                do {\n                  cVar27 = *(char *)((long)puVar33 + 1);\n                  puVar33 = (undefined2 *)((long)puVar33 + 1);\n                } while ((byte)(cVar27 - 0x30U) < 10);\n                bVar8 = false;\n                local_118 = 0;\n                puVar19 = puVar22;\n              }\n              else {\n                bVar8 = false;\n                local_118 = 0;\n              }\n            }\n          }\n          if (cVar27 == '\\0') {\nLAB_001ba2d8:\n            builtin_error(\"`%s\\': missing format character\",puVar31);\n            if (terminating_signal != 0) {\n              termsig_handler(terminating_signal);\n            }\n            if (interrupt_state != 0) {\n              throw_to_top_level();\n            }\n            if (DAT_00248dac != 0) {\n              lVar21 = builtin_bind_variable(DAT_00248d98,DAT_00248da0,DAT_00248da8);\n              stupidly_hack_special_variables(DAT_00248d98);\n              if ((lVar21 == 0) || ((*(uint *)(lVar21 + 0x28) & 0x4002) != 0)) goto LAB_001b9228;\n            }\n            if (0x1000 < _DAT_00248d70) {\n              sh_xfree(DAT_00248d78,\"./printf.def\",0x1b8);\n              _DAT_00248d70 = 0;\n              DAT_00248d78 = 0;\n            }\n            if (DAT_00248d90 < 0x1001) goto LAB_001b91dc;\n            sh_xfree(DAT_00248da0,\"./printf.def\",0x1b8);\n            DAT_00248d90 = 0;\n            DAT_00248da0 = (undefined *)0x0;\n            goto LAB_001b91e4;\n          }\n          bVar10 = false;\n          puVar32 = puVar33;\n          cVar12 = cVar27;\n          while( true ) {\n            pcVar15 = strchr(\"hjlLtz\",(int)cVar12);\n            if (pcVar15 == (char *)0x0) break;\n            bVar34 = cVar12 == 'L';\n            cVar12 = *(char *)((long)puVar32 + 1);\n            puVar32 = (undefined2 *)((long)puVar32 + 1);\n            bVar10 = (bool)(bVar10 | bVar34);\n            if (cVar12 == '\\0') goto LAB_001ba2d8;\n          }\n          uVar2 = *(undefined *)((long)puVar33 + 1);\n          *(char *)puVar33 = cVar12;\n          *(undefined *)((long)puVar33 + 1) = 0;\n          if (terminating_signal != 0) {\n            termsig_handler(terminating_signal);\n          }\n          if (interrupt_state != 0) {\n            throw_to_top_level();\n          }\n          puVar24 = DAT_00248db8;\n          switch(cVar12) {\n          case '(':\n            pcVar15 = (char *)((long)puVar32 + 1);\n            *(undefined *)((long)puVar33 + 1) = uVar2;\n            sVar20 = strlen((char *)puVar32);\n            puVar19 = (undefined2 *)sh_xmalloc(sVar20 + 3,\"./printf.def\",0x1df);\n            cVar12 = *(char *)((long)puVar32 + 1);\n            puVar32 = puVar19;\n            if (cVar12 != '\\0') {\n              iVar13 = 1;\n              do {\n                if (cVar12 == '(') {\n                  iVar13 = iVar13 + 1;\n                }\n                else if ((cVar12 == ')') && (iVar13 = iVar13 + -1, iVar13 == 0)) break;\n                pcVar15 = pcVar15 + 1;\n                *(char *)puVar32 = cVar12;\n                puVar32 = (undefined2 *)((long)puVar32 + 1);\n                cVar12 = *pcVar15;\n              } while (cVar12 != '\\0');\n            }\n            *(undefined *)puVar32 = 0;\n            if (pcVar15[1] != 'T') {\n              builtin_warning(\"`%c\\': invalid time format specification\",(int)pcVar15[1]);\n              sh_xfree(puVar19,\"./printf.def\",0x1f0);\n              DAT_00248d80 = DAT_00248d80 + 1;\n              auVar7._14_2_ = 0;\n              auVar7._0_14_ = auStack_c6;\n              _local_c8 = auVar7 << 0x10;\n              local_c8[0] = *(char *)puVar31;\n              if (DAT_00248dac != 0) goto LAB_001b97d0;\n              putc((int)*(char *)puVar31,stdout);\n              goto LAB_001b8fd6;\n            }\n            if (*(char *)puVar19 == '\\0') {\n              *(undefined *)(puVar19 + 1) = 0;\n              *puVar19 = 0x5825;\n            }\n            if ((DAT_00248db8 == (undefined8 *)0x0) ||\n               (pcVar23 = (char *)FUN_001b8b90(), pcVar23 == &DAT_ffffffffffffffff)) {\n              local_f0 = (char *)time((time_t *)0x0);\n            }\n            else {\n              local_f0 = pcVar23;\n              if (pcVar23 == (char *)0xfffffffffffffffe) {\n                local_f0 = shell_start_time;\n              }\n            }\n            sv_tz(&DAT_001faa61);\n            __tp = localtime((time_t *)&local_f0);\n            if (__tp == (tm *)0x0) {\n              local_f0 = (char *)0x0;\n              __tp = localtime((time_t *)&local_f0);\n              if (__tp != (tm *)0x0) goto LAB_001b99dd;\n              sh_xfree(puVar19,\"./printf.def\",0x20d);\nLAB_001b9efc:\n              auVar5[15] = 0;\n              auVar5._0_15_ = stack0xffffffffffffff39;\n              _local_c8 = auVar5 << 8;\n            }\n            else {\nLAB_001b99dd:\n              sVar20 = strftime(local_c8,0x80,(char *)puVar19,__tp);\n              sh_xfree(puVar19,\"./printf.def\",0x20d);\n              if ((int)sVar20 == 0) goto LAB_001b9efc;\n              local_49 = 0;\n            }\n            *puVar33 = 0x73;\n            sVar20 = strlen(local_c8);\n            iVar13 = FUN_001b8740(puVar31,local_c8,sVar20 & 0xffffffff,local_100,local_118);\n            if (iVar13 < 0) {\n              iVar13 = ferror(stdout);\n              if (iVar13 == 0) {\n                sh_wrerror();\n                clearerr(stdout);\n              }\n              if (terminating_signal != 0) {\n                termsig_handler(terminating_signal);\n              }\n              if (interrupt_state != 0) {\n                throw_to_top_level();\n              }\n              if (DAT_00248dac != 0) {\n                lVar21 = builtin_bind_variable(DAT_00248d98,DAT_00248da0,DAT_00248da8);\n                stupidly_hack_special_variables(DAT_00248d98);\n                if ((lVar21 == 0) || ((*(uint *)(lVar21 + 0x28) & 0x4002) != 0)) goto LAB_001b9228;\n              }\n              if (0x1000 < _DAT_00248d70) {\n                sh_xfree(DAT_00248d78,\"./printf.def\",0x21d);\n                _DAT_00248d70 = 0;\n                DAT_00248d78 = 0;\n              }\n              if (DAT_00248d90 < 0x1001) goto LAB_001b91dc;\n              sh_xfree(DAT_00248da0,\"./printf.def\",0x21d);\n              DAT_00248d90 = 0;\n              DAT_00248da0 = (undefined *)0x0;\n              goto LAB_001b91e4;\n            }\n            puVar32 = (undefined2 *)(pcVar15 + 1);\n            break;\n          default:\n            builtin_error(\"`%c\\': invalid format character\",(int)cVar12);\n            if (terminating_signal != 0) {\n              termsig_handler(terminating_signal);\n            }\n            if (interrupt_state != 0) {\n              throw_to_top_level();\n            }\n            if (DAT_00248dac != 0) {\n              lVar21 = builtin_bind_variable(DAT_00248d98,DAT_00248da0,DAT_00248da8);\n              stupidly_hack_special_variables(DAT_00248d98);\n              if ((lVar21 == 0) || ((*(uint *)(lVar21 + 0x28) & 0x4002) != 0)) goto LAB_001b9228;\n            }\n            if (0x1000 < _DAT_00248d70) {\n              sh_xfree(DAT_00248d78,\"./printf.def\",0x2db);\n              _DAT_00248d70 = 0;\n              DAT_00248d78 = 0;\n            }\n            if (DAT_00248d90 < 0x1001) goto LAB_001b91dc;\n            sh_xfree(DAT_00248da0,\"./printf.def\",0x2db);\n            DAT_00248d90 = 0;\n            DAT_00248da0 = (undefined *)0x0;\n            goto LAB_001b91e4;\n          case 'A':\n          case 'E':\n          case 'F':\n          case 'G':\n          case 'a':\n          case 'e':\n          case 'f':\n          case 'g':\n            if ((bVar10) || (posixly_correct == 0)) {\n              if (DAT_00248db8 != (undefined8 *)0x0) {\n                pcVar15 = *(char **)DAT_00248db8[1];\n                cVar12 = *pcVar15;\n                if ((cVar12 == '\\'') || (cVar12 == '\\\"')) {\n                  FUN_001b8480();\n                }\n                else {\n                  piVar16 = __errno_location();\n                  *piVar16 = 0;\n                  strtold(pcVar15,&local_f0);\n                  if (*local_f0 == '\\0') {\n                    if (*piVar16 == 0x22) {\n                      uVar18 = *(undefined8 *)puVar24[1];\n                      pcVar15 = strerror(0x22);\n                      builtin_error(\"warning: %s: %s\",uVar18,pcVar15);\n                      puVar24 = DAT_00248db8;\n                    }\n                  }\n                  else {\n                    sh_invalidnum(*(undefined8 *)puVar24[1]);\n                    _DAT_00248db0 = 1;\n                    puVar24 = DAT_00248db8;\n                  }\n                  DAT_00248db8 = (undefined8 *)*puVar24;\n                }\n              }\n              uVar18 = FUN_001b83b0(puVar31,&DAT_0021171a,1);\n              clearerr(stdout);\n              if ((bool)(bVar9 & bVar8)) {\n                if (DAT_00248dac == 0) {\n                  iVar13 = __printf_chk(1,uVar18,local_100);\n                }\n                else {\n                  iVar13 = FUN_001b8510(uVar18,local_100,local_118);\n                }\n              }\n              else if (bVar9) {\n                local_118 = local_100;\n                if (DAT_00248dac == 0) {\nLAB_001ba5ca:\n                  iVar13 = __printf_chk(1,uVar18,local_118);\n                }\n                else {\n                  iVar13 = FUN_001b8510(uVar18,local_100);\n                }\n              }\n              else if (bVar8) {\n                if (DAT_00248dac == 0) goto LAB_001ba5ca;\n                iVar13 = FUN_001b8510(uVar18,local_118);\n              }\n              else if (DAT_00248dac == 0) {\n                iVar13 = __printf_chk(1,uVar18);\n              }\n              else {\n                iVar13 = FUN_001b8510(uVar18);\n              }\n            }\n            else {\n              if (DAT_00248db8 == (undefined8 *)0x0) {\n                dVar35 = 0.0;\n              }\n              else {\n                pcVar15 = *(char **)DAT_00248db8[1];\n                cVar12 = *pcVar15;\n                if ((cVar12 == '\\'') || (cVar12 == '\\\"')) {\n                  lVar21 = FUN_001b8480();\n                  dVar35 = (double)lVar21;\n                }\n                else {\n                  piVar16 = __errno_location();\n                  *piVar16 = 0;\n                  dVar35 = strtod(pcVar15,&local_f0);\n                  if (*local_f0 == '\\0') {\n                    if (*piVar16 == 0x22) {\n                      uVar18 = *(undefined8 *)puVar24[1];\n                      pcVar15 = strerror(0x22);\n                      builtin_error(\"warning: %s: %s\",uVar18,pcVar15);\n                    }\n                  }\n                  else {\n                    sh_invalidnum(*(undefined8 *)puVar24[1]);\n                    _DAT_00248db0 = 1;\n                  }\n                  DAT_00248db8 = (undefined8 *)*DAT_00248db8;\n                }\n              }\n              uVar18 = FUN_001b83b0(puVar31,&DAT_00213d70,0);\n              clearerr(stdout);\n              if ((bool)(bVar9 & bVar8)) {\n                if (DAT_00248dac == 0) {\n                  iVar13 = __printf_chk(1,uVar18,local_100);\n                }\n                else {\n                  iVar13 = FUN_001b8510(dVar35,uVar18,local_100,local_118);\n                }\n              }\n              else if (bVar9) {\n                if (DAT_00248dac == 0) {\n                  iVar13 = __printf_chk(1,uVar18,local_100);\n                }\n                else {\n                  iVar13 = FUN_001b8510(uVar18,local_100);\n                }\n              }\n              else if (bVar8) {\n                if (DAT_00248dac == 0) {\n                  iVar13 = __printf_chk(1,uVar18,local_118);\n                }\n                else {\n                  iVar13 = FUN_001b8510(uVar18,local_118);\n                }\n              }\n              else if (DAT_00248dac == 0) {\n                iVar13 = __printf_chk(1,uVar18);\n              }\n              else {\n                iVar13 = FUN_001b8510(uVar18);\n              }\n            }\n            goto LAB_001b9320;\n          case 'Q':\n          case 'q':\n            if (DAT_00248db8 == (undefined8 *)0x0) {\n              if (cVar12 == 'Q' && puVar19 != (undefined2 *)0x0) {\n                pcVar15 = \"\";\n                goto LAB_001ba073;\n              }\nLAB_001ba036:\n              puVar19 = (undefined2 *)sh_xmalloc(3,\"./printf.def\",0x26a);\n              *puVar19 = 0x2727;\n              *(undefined *)(puVar19 + 1) = 0;\n            }\n            else {\n              puVar24 = DAT_00248db8 + 1;\n              DAT_00248db8 = (undefined8 *)*DAT_00248db8;\n              pcVar15 = *(char **)*puVar24;\n              if (cVar12 == 'Q' && puVar19 != (undefined2 *)0x0) {\nLAB_001ba073:\n                pcVar23 = (char *)((long)puVar19 + 1);\n                local_118 = *(char *)puVar19 + -0x30;\n                cVar3 = *(char *)((long)puVar19 + 1);\n                while ((byte)(cVar3 - 0x30U) < 10) {\n                  pcVar23 = pcVar23 + 1;\n                  local_118 = (int)(char)(cVar3 + -0x30) + local_118 * 10;\n                  cVar3 = *pcVar23;\n                }\n                uVar26 = (ulong)local_118;\n                if (local_118 < 0) {\n                  local_118 = 0x7fffffff;\n                  uVar26 = 0x7fffffff;\n                }\n                sVar20 = strlen(pcVar15);\n                if (uVar26 < sVar20) {\n                  pcVar15[uVar26] = '\\0';\n                }\nLAB_001b947a:\n                if (*pcVar15 == '\\0') goto LAB_001ba036;\n              }\n              else if (pcVar15 != (char *)0x0) goto LAB_001b947a;\n              iVar13 = ansic_shouldquote(pcVar15);\n              if (iVar13 == 0) {\n                puVar19 = (undefined2 *)sh_backslash_quote(pcVar15,0,3);\n              }\n              else {\n                puVar19 = (undefined2 *)ansic_quote(pcVar15,0,0);\n              }\n              if (puVar19 == (undefined2 *)0x0) break;\n            }\n            sVar20 = strlen((char *)puVar19);\n            iVar13 = local_118;\n            if ((cVar12 == 'Q') && (iVar13 = (int)sVar20, sVar20 <= (ulong)(long)local_118)) {\n              iVar13 = local_118;\n            }\n            local_118 = iVar13;\n            iVar13 = FUN_001b8740(puVar31,puVar19,sVar20 & 0xffffffff,local_100,local_118);\n            if (iVar13 < 0) {\n              sh_wrerror();\n              clearerr(stdout);\n              sh_xfree(puVar19,\"./printf.def\",0x27e);\n              if (terminating_signal != 0) {\n                termsig_handler(terminating_signal);\n              }\n              if (interrupt_state != 0) {\n                throw_to_top_level();\n              }\n              if (DAT_00248dac != 0) {\n                lVar21 = builtin_bind_variable(DAT_00248d98,DAT_00248da0,DAT_00248da8);\n                stupidly_hack_special_variables(DAT_00248d98);\n                if ((lVar21 == 0) || ((*(uint *)(lVar21 + 0x28) & 0x4002) != 0)) goto LAB_001b9228;\n              }\n              if (0x1000 < _DAT_00248d70) {\n                sh_xfree(DAT_00248d78,\"./printf.def\",0x282);\n                _DAT_00248d70 = 0;\n                DAT_00248d78 = 0;\n              }\n              if (DAT_00248d90 < 0x1001) goto LAB_001b91dc;\n              sh_xfree(DAT_00248da0,\"./printf.def\",0x282);\n              DAT_00248d90 = 0;\n              DAT_00248da0 = (undefined *)0x0;\n              goto LAB_001b91e4;\n            }\n            sh_xfree(puVar19,\"./printf.def\",0x27e);\n            break;\n          case 'X':\n          case 'o':\n          case 'u':\n          case 'x':\n            if (DAT_00248db8 == (undefined8 *)0x0) {\n              uVar17 = 0;\n            }\n            else {\n              pcVar15 = *(char **)DAT_00248db8[1];\n              cVar12 = *pcVar15;\n              if ((cVar12 == '\\'') || (cVar12 == '\\\"')) {\n                uVar17 = FUN_001b8480();\n              }\n              else {\n                piVar16 = __errno_location();\n                *piVar16 = 0;\n                uVar17 = strtoumax(pcVar15,&local_f0,0);\n                if (*local_f0 == '\\0') {\n                  if (*piVar16 == 0x22) {\n                    uVar18 = *(undefined8 *)puVar24[1];\n                    pcVar15 = strerror(0x22);\n                    builtin_error(\"warning: %s: %s\",uVar18,pcVar15);\n                    puVar24 = DAT_00248db8;\n                  }\n                }\n                else {\n                  sh_invalidnum(*(undefined8 *)puVar24[1]);\n                  _DAT_00248db0 = 1;\n                  puVar24 = DAT_00248db8;\n                }\n                DAT_00248db8 = (undefined8 *)*puVar24;\n              }\n            }\n            goto LAB_001b93e1;\n          case 'b':\n            if (DAT_00248db8 == (undefined8 *)0x0) {\nLAB_001b9c21:\n              pcVar23 = (char *)sh_xmalloc(1,\"./printf.def\",0x3fd);\n              *pcVar23 = '\\0';\nLAB_001b9c45:\n              iVar13 = 0;\n            }\n            else {\n              puVar24 = DAT_00248db8 + 1;\n              DAT_00248db8 = (undefined8 *)*DAT_00248db8;\n              pcVar15 = *(char **)*puVar24;\n              sVar20 = strlen(pcVar15);\n              if ((int)sVar20 == 0) goto LAB_001b9c21;\n              pcVar23 = (char *)sh_xmalloc((long)((int)sVar20 + 1),\"./printf.def\",0x402);\n              cVar12 = *pcVar15;\n              if (cVar12 == '\\0') {\n                *pcVar23 = '\\0';\n                goto LAB_001b9c45;\n              }\n              pcVar25 = pcVar23;\n              do {\n                pcVar28 = pcVar15 + 1;\n                if ((cVar12 == '\\\\') && (pcVar15[1] != '\\0')) {\n                  local_b0 = 0;\n                  _local_c8 = (undefined  [16])0x0;\n                  local_b8 = 0;\n                  local_f4 = 0;\n                  iVar13 = FUN_001b8070(pcVar28,local_c8,&local_f0,&local_f4);\n                  pcVar28 = pcVar28 + iVar13;\n                  if (local_f4 != 0) {\n                    *pcVar25 = '\\0';\n                    if (pcVar23 == (char *)0x0) goto LAB_001b9ddf;\n                    iVar13 = FUN_001b8740(puVar31,pcVar23,(int)pcVar25 - (int)pcVar23,local_100,\n                                          local_118);\n                    if (-1 < iVar13) goto LAB_001b9dcd;\n                    goto LAB_001b9da5;\n                  }\n                  if (0 < (int)local_f0) {\n                    lVar21 = 0;\n                    do {\n                      pcVar25[lVar21] = local_c8[lVar21];\n                      lVar21 = lVar21 + 1;\n                    } while ((int)local_f0 != lVar21);\n                    pcVar25 = pcVar25 + (int)local_f0;\n                  }\n                }\n                else {\n                  *pcVar25 = cVar12;\n                  pcVar25 = pcVar25 + 1;\n                }\n                cVar12 = *pcVar28;\n                pcVar15 = pcVar28;\n              } while (cVar12 != '\\0');\n              *pcVar25 = '\\0';\n              if (pcVar23 == (char *)0x0) break;\n              iVar13 = (int)pcVar25 - (int)pcVar23;\n            }\n            iVar13 = FUN_001b8740(puVar31,pcVar23,iVar13,local_100,local_118);\n            if (iVar13 < 0) {\nLAB_001b9da5:\n              iVar13 = ferror(stdout);\n              if (iVar13 == 0) {\n                sh_wrerror();\n                clearerr(stdout);\n              }\n              DAT_00248db4 = 1;\nLAB_001b9dcd:\n              sh_xfree(pcVar23,\"./printf.def\",0x24b);\nLAB_001b9ddf:\n              if (terminating_signal != 0) {\n                termsig_handler(terminating_signal);\n              }\n              if (interrupt_state != 0) {\n                throw_to_top_level();\n              }\n              if (DAT_00248dac != 0) {\n                lVar21 = builtin_bind_variable(DAT_00248d98,DAT_00248da0,DAT_00248da8);\n                stupidly_hack_special_variables(DAT_00248d98);\n                if ((lVar21 == 0) || ((*(uint *)(lVar21 + 0x28) & 0x4002) != 0)) goto LAB_001b9228;\n              }\n              if (0x1000 < _DAT_00248d70) {\n                sh_xfree(DAT_00248d78,\"./printf.def\",0x24f);\n                _DAT_00248d70 = 0;\n                DAT_00248d78 = 0;\n              }\n              if (DAT_00248d90 < 0x1001) goto LAB_001b9e31;\n              sh_xfree(DAT_00248da0,\"./printf.def\",0x24f);\n              DAT_00248d90 = 0;\n              DAT_00248da0 = (undefined *)0x0;\n              goto LAB_001b9e39;\n            }\n            sh_xfree(pcVar23,\"./printf.def\",0x24b);\n            break;\n          case 'c':\n            if (DAT_00248db8 == (undefined8 *)0x0) {\n              iVar13 = 0;\n            }\n            else {\n              puVar24 = DAT_00248db8 + 1;\n              DAT_00248db8 = (undefined8 *)*DAT_00248db8;\n              iVar13 = (int)**(char **)*puVar24;\n            }\n            clearerr(stdout);\n            if ((bool)(bVar9 & bVar8)) {\n              if (DAT_00248dac == 0) {\n                iVar13 = __printf_chk(1,puVar31,local_100,local_118,iVar13);\n              }\n              else {\n                iVar13 = FUN_001b8510(puVar31,local_100,local_118);\n              }\n            }\n            else if (bVar9) {\n              if (DAT_00248dac == 0) {\n                iVar13 = __printf_chk(1,puVar31,local_100);\n              }\n              else {\n                iVar13 = FUN_001b8510(puVar31,local_100,iVar13);\n              }\n            }\n            else if (bVar8) {\n              if (DAT_00248dac == 0) {\n                iVar13 = __printf_chk(1,puVar31,local_118);\n              }\n              else {\n                iVar13 = FUN_001b8510(puVar31,local_118,iVar13);\n              }\n            }\n            else if (DAT_00248dac == 0) {\n              iVar13 = __printf_chk(1,puVar31,iVar13);\n            }\n            else {\n              iVar13 = FUN_001b8510(puVar31,iVar13);\n            }\n            goto LAB_001b9320;\n          case 'd':\n          case 'i':\n            uVar17 = FUN_001b8b90();\nLAB_001b93e1:\n            uVar18 = FUN_001b83b0(puVar31,\"l\",1);\n            clearerr(stdout);\n            if ((bool)(bVar9 & bVar8)) {\n              if (DAT_00248dac == 0) {\n                iVar13 = __printf_chk(1,uVar18,local_100,local_118,uVar17);\n              }\n              else {\n                iVar13 = FUN_001b8510(uVar18,local_100,local_118);\n              }\n            }\n            else if (bVar9) {\n              if (DAT_00248dac == 0) {\n                iVar13 = __printf_chk(1,uVar18,local_100);\n              }\n              else {\n                iVar13 = FUN_001b8510(uVar18,local_100,uVar17);\n              }\n            }\n            else if (bVar8) {\n              if (DAT_00248dac == 0) {\n                iVar13 = __printf_chk(1,uVar18,local_118);\n              }\n              else {\n                iVar13 = FUN_001b8510(uVar18,local_118,uVar17);\n              }\n            }\n            else if (DAT_00248dac == 0) {\n              iVar13 = __printf_chk(1,uVar18,uVar17);\n            }\n            else {\n              iVar13 = FUN_001b8510(uVar18,uVar17);\n            }\n            goto LAB_001b9320;\n          case 'n':\n            if (DAT_00248db8 != (undefined8 *)0x0) {\n              puVar24 = DAT_00248db8 + 1;\n              DAT_00248db8 = (undefined8 *)*DAT_00248db8;\n              pcVar15 = *(char **)*puVar24;\n              if ((pcVar15 != (char *)0x0) && (*pcVar15 != '\\0')) {\n                iVar13 = legal_identifier(pcVar15);\n                if (iVar13 == 0) {\n                  sh_invalidid(pcVar15);\n                  if (terminating_signal != 0) {\n                    termsig_handler(terminating_signal);\n                  }\n                  if (interrupt_state != 0) {\n                    throw_to_top_level();\n                  }\n                  if (DAT_00248dac != 0) {\n                    lVar21 = builtin_bind_variable(DAT_00248d98,DAT_00248da0,DAT_00248da8);\n                    stupidly_hack_special_variables(DAT_00248d98);\n                    if ((lVar21 == 0) || ((*(uint *)(lVar21 + 0x28) & 0x4002) != 0))\n                    goto LAB_001b9228;\n                  }\n                  if (0x1000 < _DAT_00248d70) {\n                    sh_xfree(DAT_00248d78,\"./printf.def\",0x22e);\n                    _DAT_00248d70 = 0;\n                    DAT_00248d78 = 0;\n                  }\n                  if (DAT_00248d90 < 0x1001) goto LAB_001b91dc;\n                  sh_xfree(DAT_00248da0,\"./printf.def\",0x22e);\n                  DAT_00248d90 = 0;\n                  DAT_00248da0 = (undefined *)0x0;\n                  goto LAB_001b91e4;\n                }\n                bind_var_to_int(pcVar15,DAT_00248d80,0);\n              }\n            }\n            break;\n          case 's':\n            puVar30 = &DAT_00213d70;\n            if (DAT_00248db8 != (undefined8 *)0x0) {\n              puVar24 = DAT_00248db8 + 1;\n              DAT_00248db8 = (undefined8 *)*DAT_00248db8;\n              puVar30 = *(undefined **)*puVar24;\n            }\n            clearerr(stdout);\n            if ((bool)(bVar9 & bVar8)) {\n              if (DAT_00248dac == 0) {\n                iVar13 = __printf_chk(1,puVar31,local_100,local_118,puVar30);\n              }\n              else {\n                iVar13 = FUN_001b8510(puVar31,local_100,local_118);\n              }\n            }\n            else if (bVar9) {\n              if (DAT_00248dac == 0) {\n                iVar13 = __printf_chk(1,puVar31,local_100);\n              }\n              else {\n                iVar13 = FUN_001b8510(puVar31,local_100,puVar30);\n              }\n            }\n            else if (bVar8) {\n              if (DAT_00248dac == 0) {\n                iVar13 = __printf_chk(1,puVar31,local_118);\n              }\n              else {\n                iVar13 = FUN_001b8510(puVar31,local_118,puVar30);\n              }\n            }\n            else if (DAT_00248dac == 0) {\n              iVar13 = __printf_chk(1,puVar31,puVar30);\n            }\n            else {\n              iVar13 = FUN_001b8510(puVar31,puVar30);\n            }\nLAB_001b9320:\n            DAT_00248d80 = DAT_00248d80 + iVar13;\n            if (terminating_signal != 0) {\n              termsig_handler(terminating_signal);\n            }\n            if (interrupt_state != 0) {\n              throw_to_top_level();\n            }\n            iVar13 = ferror(stdout);\n            if (iVar13 != 0) goto LAB_001b9e87;\n          }\n          *(char *)puVar33 = cVar27;\n          *(undefined *)((long)puVar33 + 1) = uVar2;\n          local_140 = (undefined2 *)((long)puVar32 + 1);\n          puVar31 = puVar32;\nLAB_001b9001:\n          bVar1 = *(byte *)((long)puVar31 + 1);\n          puVar31 = local_140;\n        }\n        iVar13 = ferror(stdout);\n        if (iVar13 != 0) {\n          if (terminating_signal != 0) {\n            termsig_handler(terminating_signal);\n          }\n          if (interrupt_state != 0) {\n            throw_to_top_level();\n          }\n          if (DAT_00248dac != 0) {\n            lVar21 = builtin_bind_variable(DAT_00248d98,DAT_00248da0,DAT_00248da8);\n            stupidly_hack_special_variables(DAT_00248d98);\n            if ((lVar21 == 0) || ((*(uint *)(lVar21 + 0x28) & 0x4002) != 0)) goto LAB_001b9228;\n          }\n          if (0x1000 < _DAT_00248d70) {\n            sh_xfree(DAT_00248d78,\"./printf.def\",0x2e5);\n            _DAT_00248d70 = 0;\n            DAT_00248d78 = 0;\n          }\n          if (DAT_00248d90 < 0x1001) {\nLAB_001b91dc:\n            if (DAT_00248da0 != (undefined *)0x0) {\n              *DAT_00248da0 = 0;\n            }\n          }\n          else {\n            sh_xfree(DAT_00248da0,\"./printf.def\",0x2e5);\n            DAT_00248d90 = 0;\n            DAT_00248da0 = (undefined *)0x0;\n          }\nLAB_001b91e4:\n          iVar13 = ferror(stdout);\n          if (iVar13 == 0) {\n            fflush(stdout);\n          }\n          if (terminating_signal != 0) {\n            termsig_handler(terminating_signal);\n          }\n          if (interrupt_state != 0) {\n            throw_to_top_level();\n          }\n          iVar13 = ferror(stdout);\n          if (iVar13 == 0) goto LAB_001b9228;\n          goto LAB_001b9e87;\n        }\n        if ((DAT_00248db8 == (undefined8 *)0x0) || (DAT_00248db8 == (undefined8 *)*puVar11))\n        goto LAB_001ba897;\n        bVar1 = *(byte *)puVar4;\n      } while( true );\n    }\n    goto LAB_001b8eaa;\n  }\n  uVar14 = 0;\n  if (puVar4 == (undefined2 *)0x0) goto LAB_001b8eaa;\n  bVar1 = *(byte *)puVar4;\n  if (bVar1 != 0) goto LAB_001b8f62;\n  lVar21 = builtin_bind_variable(DAT_00248d98,&DAT_00213d70,0);\n  stupidly_hack_special_variables(DAT_00248d98);\n  if (lVar21 != 0) {\n    uVar14 = (uint)((*(uint *)(lVar21 + 0x28) & 0x4002) != 0);\n    goto LAB_001b8eaa;\n  }\nLAB_001b9228:\n  uVar14 = 1;\nLAB_001b8eaa:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar14;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\nLAB_001ba897:\n  if (_DAT_00248db0 != 0) {\n    DAT_00248db4 = 1;\n  }\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n  }\n  if (DAT_00248dac != 0) {\n    lVar21 = builtin_bind_variable(DAT_00248d98,DAT_00248da0,DAT_00248da8);\n    stupidly_hack_special_variables(DAT_00248d98);\n    if ((lVar21 == 0) || ((*(uint *)(lVar21 + 0x28) & 0x4002) != 0)) goto LAB_001b9228;\n  }\n  if (0x1000 < _DAT_00248d70) {\n    sh_xfree(DAT_00248d78,\"./printf.def\",0x2ed);\n    _DAT_00248d70 = 0;\n    DAT_00248d78 = 0;\n  }\n  if (DAT_00248d90 < 0x1001) {\nLAB_001b9e31:\n    if (DAT_00248da0 != (undefined *)0x0) {\n      *DAT_00248da0 = 0;\n    }\n  }\n  else {\n    sh_xfree(DAT_00248da0,\"./printf.def\",0x2ed);\n    DAT_00248d90 = 0;\n    DAT_00248da0 = (undefined *)0x0;\n  }\nLAB_001b9e39:\n  iVar13 = ferror(stdout);\n  if (iVar13 == 0) {\n    fflush(stdout);\n  }\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n  }\n  iVar13 = ferror(stdout);\n  uVar14 = DAT_00248db4;\n  if (iVar13 == 0) goto LAB_001b8eaa;\nLAB_001b9e87:\n  sh_wrerror();\n  clearerr(stdout);\n  goto LAB_001b9228;\n}\n\n",
  "_rl_sigwinch_resize_terminal": "\nvoid _rl_sigwinch_resize_terminal(void)\n\n{\n  int iVar1;\n  \n  iVar1 = fileno(rl_instream);\n  _rl_get_screen_size(iVar1,1);\n  return;\n}\n\n",
  "tilde_initialize": "\nvoid tilde_initialize(void)\n\n{\n  int iVar1;\n  \n  iVar1 = DAT_00240e70;\n  tilde_expansion_preexpansion_hook = FUN_00140fd0;\n  DAT_00240e70 = DAT_00240e70 + 1;\n  if (iVar1 != 0) {\n    return;\n  }\n  DAT_00240e98 = (undefined8 *)strvec_create(3);\n  *DAT_00240e98 = &DAT_001fc418;\n  DAT_00240e98[1] = &DAT_001fc41b;\n  DAT_00240e98[2] = 0;\n  DAT_00240e90 = (undefined8 *)strvec_create(2);\n  *DAT_00240e90 = &DAT_001fc41b;\n  DAT_00240e90[1] = 0;\n  tilde_additional_prefixes = (undefined *)DAT_00240e98;\n  tilde_additional_suffixes = (undefined *)strvec_create(3);\n  *(char **)tilde_additional_suffixes = \":\";\n  *(char **)((long)tilde_additional_suffixes + 8) = \"=~\";\n  *(char **)((long)tilde_additional_suffixes + 0x10) = (char *)0x0;\n  DAT_00240e88 = (char **)strvec_create(2);\n  *DAT_00240e88 = \":\";\n  DAT_00240e88[1] = (char *)0x0;\n  return;\n}\n\n",
  "FUN_001cfd10": "\nundefined8 FUN_001cfd10(undefined4 *param_1)\n\n{\n  undefined8 uVar1;\n  \n  DAT_0024a3e4 = _rl_read_mbchar(&DAT_0024a3f0,0x10);\n  if (0 < DAT_0024a3e4) {\n    rl_readline_state = rl_readline_state & 0xffffffffff7fffff;\n    _rl_callback_func = 0;\n    _rl_want_redisplay = 1;\n    uVar1 = _rl_char_search_internal(*param_1,DAT_0024a354,&DAT_0024a3f0,DAT_0024a3e4);\n    return uVar1;\n  }\n  rl_readline_state = rl_readline_state & 0xffffffffff7fffff;\n  return 0xffffffff;\n}\n\n",
  "rl_forward_word": "\nvoid rl_forward_word(int param_1)\n\n{\n  if (-1 < param_1) {\n    FUN_001edc60();\n    return;\n  }\n  FUN_001edaf0(-param_1);\n  return;\n}\n\n",
  "setup_exec_ignore": "\nvoid setup_exec_ignore(void)\n\n{\n  setup_ignore_patterns(&PTR_s_EXECIGNORE_00238da0);\n  return;\n}\n\n",
  "FUN_001cdb30": "\nvoid FUN_001cdb30(undefined *param_1)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = _rl_keymap;\n  _rl_keymap = param_1;\n  rl_bind_keyseq_if_unbound(&DAT_002129a9,rl_get_previous_history);\n  rl_bind_keyseq_if_unbound(&DAT_002129ad,rl_get_next_history);\n  rl_bind_keyseq_if_unbound(&DAT_002129b1,rl_forward_char);\n  rl_bind_keyseq_if_unbound(&DAT_002129b5,rl_backward_char);\n  rl_bind_keyseq_if_unbound(&DAT_002129b9,rl_beg_of_line);\n  rl_bind_keyseq_if_unbound(&DAT_002129bd,rl_end_of_line);\n  rl_bind_keyseq_if_unbound(&DAT_002129c1,rl_get_previous_history);\n  rl_bind_keyseq_if_unbound(&DAT_002129c5,rl_get_next_history);\n  rl_bind_keyseq_if_unbound(&DAT_002129c9,rl_forward_char);\n  rl_bind_keyseq_if_unbound(&DAT_002129cd,rl_backward_char);\n  rl_bind_keyseq_if_unbound(&DAT_002129d1,rl_beg_of_line);\n  rl_bind_keyseq_if_unbound(&DAT_002129d5,rl_end_of_line);\n  rl_bind_keyseq_if_unbound(&DAT_002129d9,rl_forward_word);\n  rl_bind_keyseq_if_unbound(&DAT_002129e0,rl_backward_word);\n  rl_bind_keyseq_if_unbound(&DAT_002129e7,rl_kill_word);\n  rl_bind_keyseq_if_unbound(&DAT_002129ee,rl_forward_word);\n  rl_bind_keyseq_if_unbound(&DAT_002129f5,rl_backward_word);\n  _rl_keymap = puVar1;\n  return;\n}\n\n",
  "FUN_001840b0": "\nvoid FUN_001840b0(char *param_1)\n\n{\n  code *pcVar1;\n  int iVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  undefined8 *puVar6;\n  \n  puVar6 = DAT_00248390;\n  if (DAT_00248390 != (undefined8 *)0x0) {\n    do {\n      while( true ) {\n        DAT_00248390 = (undefined8 *)*puVar6;\n        pcVar1 = (code *)puVar6[1];\n        if (pcVar1 == (code *)0x0) {\n          if (((param_1 != (char *)0x0) && (*(char *)puVar6[2] == *param_1)) &&\n             (iVar2 = strcmp((char *)puVar6[2],param_1), iVar2 == 0)) {\n            if (DAT_0024838c < DAT_00248388) {\n              *puVar6 = 0xdfdfdfdfdfdfdfdf;\n              puVar5 = puVar6 + 1;\n              do {\n                *(undefined *)puVar5 = 0xdf;\n                puVar3 = puVar5 + 1;\n                *(undefined *)((long)puVar5 + 1) = 0xdf;\n                *(undefined *)((long)puVar5 + 2) = 0xdf;\n                *(undefined *)((long)puVar5 + 3) = 0xdf;\n                *(undefined *)((long)puVar5 + 4) = 0xdf;\n                *(undefined *)((long)puVar5 + 5) = 0xdf;\n                *(undefined *)((long)puVar5 + 6) = 0xdf;\n                *(undefined *)((long)puVar5 + 7) = 0xdf;\n                puVar5 = puVar3;\n              } while (puVar6 + 4 != puVar3);\n              lVar4 = (long)DAT_0024838c;\n              DAT_0024838c = DAT_0024838c + 1;\n              *(undefined8 **)(uwcache + lVar4 * 8) = puVar6;\n              return;\n            }\n            sh_xfree(puVar6,\"unwind_prot.c\",0x13c);\n            return;\n          }\n        }\n        else if (pcVar1 == FUN_00183ff0) {\n          memcpy((void *)puVar6[2],(void *)((long)puVar6 + 0x1c),(long)*(int *)(puVar6 + 3));\n        }\n        else {\n          (*pcVar1)();\n        }\n        if (DAT_00248388 <= DAT_0024838c) break;\n        *puVar6 = 0xdfdfdfdfdfdfdfdf;\n        puVar5 = puVar6 + 1;\n        do {\n          *(undefined *)puVar5 = 0xdf;\n          puVar3 = puVar5 + 1;\n          *(undefined *)((long)puVar5 + 1) = 0xdf;\n          *(undefined *)((long)puVar5 + 2) = 0xdf;\n          *(undefined *)((long)puVar5 + 3) = 0xdf;\n          *(undefined *)((long)puVar5 + 4) = 0xdf;\n          *(undefined *)((long)puVar5 + 5) = 0xdf;\n          *(undefined *)((long)puVar5 + 6) = 0xdf;\n          *(undefined *)((long)puVar5 + 7) = 0xdf;\n          puVar5 = puVar3;\n        } while (puVar3 != puVar6 + 4);\n        lVar4 = (long)DAT_0024838c;\n        DAT_0024838c = DAT_0024838c + 1;\n        *(undefined8 **)(uwcache + lVar4 * 8) = puVar6;\n        puVar6 = DAT_00248390;\n        if (DAT_00248390 == (undefined8 *)0x0) goto LAB_0018419e;\n      }\n      sh_xfree(puVar6,\"unwind_prot.c\",0x149);\n      puVar6 = DAT_00248390;\n    } while (DAT_00248390 != (undefined8 *)0x0);\n  }\nLAB_0018419e:\n  if (param_1 == (char *)0x0) {\n    return;\n  }\n  internal_warning(\"unwind_frame_run: %s: frame not found\",param_1);\n  return;\n}\n\n",
  "begin_unwind_frame": "\nvoid begin_unwind_frame(undefined8 param_1)\n\n{\n  undefined8 *puVar1;\n  \n  if (DAT_0024838c < 1) {\n    puVar1 = (undefined8 *)sh_xmalloc(0x20,\"unwind_prot.c\",0xe0);\n  }\n  else {\n    DAT_0024838c = DAT_0024838c + -1;\n    puVar1 = *(undefined8 **)(uwcache + (long)DAT_0024838c * 8);\n  }\n  puVar1[1] = 0;\n  puVar1[2] = param_1;\n  *puVar1 = DAT_00248390;\n  DAT_00248390 = puVar1;\n  return;\n}\n\n",
  "rl_vi_delete": "\nundefined8 rl_vi_delete(int param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  undefined8 uVar3;\n  \n  if (param_1 < 0) {\n    uVar3 = rl_vi_rubout(-param_1);\n    return uVar3;\n  }\n  if (rl_end != 0) {\n    sVar2 = __ctype_get_mb_cur_max();\n    if ((sVar2 < 2) || (rl_byte_oriented != 0)) {\n      param_1 = param_1 + rl_point;\n    }\n    else {\n      param_1 = _rl_find_next_mbchar(rl_line_buffer,rl_point,param_1,1);\n    }\n    iVar1 = rl_end;\n    if (param_1 <= rl_end) {\n      iVar1 = param_1;\n    }\n    rl_kill_text(rl_point,iVar1);\n    if ((0 < rl_point) && (rl_point == rl_end)) {\n      rl_backward_char(1,param_2);\n    }\n    return 0;\n  }\n  rl_ding();\n  return 1;\n}\n\n",
  "initialize_signals": "\nvoid initialize_signals(void)\n\n{\n  int iVar1;\n  \n  if ((interactive != 0) && (DAT_0024853c == 0)) {\n    FUN_00185700();\n  }\n  sigemptyset((sigset_t *)top_level_mask);\n  sigprocmask(0,(sigset_t *)0x0,(sigset_t *)top_level_mask);\n  iVar1 = sigismember((sigset_t *)top_level_mask,0x11);\n  if (iVar1 != 0) {\n    sigdelset((sigset_t *)top_level_mask,0x11);\n    sigprocmask(2,(sigset_t *)top_level_mask,(sigset_t *)0x0);\n  }\n  set_signal_handler(3,1);\n  if (interactive == 0) {\n    initialize_job_signals();\n    return;\n  }\n  set_signal_handler(2,sigint_sighandler);\n  get_original_signal(0xf);\n  set_signal_handler(0xf,1);\n  DAT_00248540 = set_signal_handler(0x1c,sigwinch_sighandler);\n  initialize_job_signals();\n  return;\n}\n\n",
  "bashline_reset_event_hook": "\nvoid bashline_reset_event_hook(void)\n\n{\n  rl_signal_event_hook = 0;\n  return;\n}\n\n",
  "xtrace_set": "\nvoid xtrace_set(int param_1,FILE *param_2)\n\n{\n  int iVar1;\n  \n  if (param_1 < 0) {\n    if (param_2 == (FILE *)0x0) {\nLAB_001454a0:\n      internal_error(\"xtrace_set: NULL file pointer\");\n      return;\n    }\n  }\n  else {\n    iVar1 = sh_validfd();\n    if (iVar1 == 0) {\n      internal_error(\"xtrace_set: %d: invalid file descriptor\",param_1);\n      return;\n    }\n    if (param_2 == (FILE *)0x0) goto LAB_001454a0;\n    iVar1 = fileno(param_2);\n    if (iVar1 != param_1) {\n      iVar1 = fileno(param_2);\n      internal_warning(\"xtrace fd (%d) != fileno xtrace fp (%d)\",param_1,iVar1);\n    }\n  }\n  xtrace_fd = param_1;\n  xtrace_fp = param_2;\n  return;\n}\n\n",
  "strvec_resize": "\nvoid strvec_resize(undefined8 param_1,int param_2)\n\n{\n  sh_xrealloc(param_1,(long)param_2 << 3,\"stringvec.c\",0x38);\n  return;\n}\n\n",
  "dispose_function_def": "\nvoid dispose_function_def(long param_1)\n\n{\n  dispose_word(*(undefined8 *)(param_1 + 8));\n  dispose_command(*(undefined8 *)(param_1 + 0x10));\n  if (*(long *)(param_1 + 0x18) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x18),\"dispose_cmd.c\",0xe9);\n  }\n  sh_xfree(param_1,\"dispose_cmd.c\",0xf1);\n  return;\n}\n\n",
  "getcoprocbypid": "\nundefined8 * getcoprocbypid(int param_1)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = &sh_coproc;\n  if (DAT_00238428 != param_1) {\n    puVar1 = (undefined8 *)0x0;\n  }\n  return puVar1;\n}\n\n",
  "dispose_fd_bitmap": "\nvoid dispose_fd_bitmap(long param_1)\n\n{\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"execute_cmd.c\",0x159);\n  }\n  sh_xfree(param_1,\"execute_cmd.c\",0x15a);\n  return;\n}\n\n",
  "strlist_dispose": "\nvoid strlist_dispose(long *param_1)\n\n{\n  if (param_1 != (long *)0x0) {\n    if (*param_1 != 0) {\n      strvec_dispose();\n    }\n    sh_xfree(param_1,\"stringlist.c\",0x65);\n    return;\n  }\n  return;\n}\n\n",
  "list_string": "\nlong * list_string(byte *param_1,byte *param_2,uint param_3)\n\n{\n  char cVar1;\n  byte bVar2;\n  bool bVar3;\n  byte bVar4;\n  ushort uVar5;\n  uint uVar6;\n  ulong uVar7;\n  ushort **ppuVar8;\n  char *pcVar9;\n  char **ppcVar10;\n  undefined8 *puVar11;\n  undefined2 *puVar12;\n  size_t sVar13;\n  byte bVar14;\n  long lVar15;\n  ulong uVar16;\n  ulong unaff_RBP;\n  int iVar17;\n  int iVar18;\n  ulong uVar19;\n  long in_FS_OFFSET;\n  bool bVar20;\n  bool bVar21;\n  long *local_88;\n  size_t local_80;\n  uint local_70;\n  int local_5c;\n  int local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_1 != (byte *)0x0) && (bVar14 = *param_1, bVar14 != 0)) {\n    bVar21 = false;\n    if ((param_2 != (byte *)0x0) &&\n       (((*param_2 == 0x20 && (param_2[1] == 9)) && (param_2[2] == 10)))) {\n      bVar21 = param_2[3] == 0;\n    }\n    local_70 = 0;\n    uVar6 = 0;\n    pcVar9 = ifs_value;\n    if (ifs_value != (char *)0x0) {\n      for (; cVar1 = *pcVar9, local_70 = uVar6, cVar1 != '\\0'; pcVar9 = pcVar9 + 1) {\n        if (cVar1 == '\\x01') {\n          uVar6 = uVar6 | 0x10;\n        }\n        else if (cVar1 == '\\x7f') {\n          uVar6 = uVar6 | 0x20;\n        }\n      }\n    }\n    if (((param_3 != 0) || (param_2 == (byte *)0x0)) || (bVar4 = *param_2, bVar4 == 0)) {\nLAB_0017150f:\n      local_80 = 1;\n      if ((param_1[1] != 0) && (local_80 = 2, param_1[2] != 0)) {\n        local_80 = strlen((char *)param_1);\n      }\n      local_4c = 0;\n      local_88 = (long *)0x0;\n      uVar7 = unaff_RBP & 0xffffffff;\nLAB_0017154a:\n      pcVar9 = (char *)FUN_00167770(param_1,local_80,&local_4c,param_2,local_70);\n      iVar18 = local_4c;\n      if (pcVar9 != (char *)0x0) {\n        if (*pcVar9 == '\\x7f') {\n          if (pcVar9[1] != '\\0') goto LAB_0017183c;\nLAB_001718f0:\n          puVar11 = (undefined8 *)alloc_word_desc();\n          puVar12 = (undefined2 *)sh_xmalloc(3,\"subst.c\",0x12cd);\n          *puVar12 = 0x7f;\n          *(uint *)(puVar11 + 1) = *(uint *)(puVar11 + 1) | 0x40002;\n          *puVar11 = puVar12;\n          local_88 = (long *)make_word_list(puVar11,local_88);\nLAB_001715a6:\n          sh_xfree(pcVar9,\"subst.c\",0xc9d);\n        }\n        else {\n          if (*pcVar9 == '\\0') {\n            if ((!bVar21) &&\n               (ppuVar8 = __ctype_b_loc(),\n               (*(byte *)((long)*ppuVar8 + (ulong)param_1[local_4c] * 2 + 1) & 0x20) == 0))\n            goto LAB_001718f0;\n            goto LAB_001715a6;\n          }\nLAB_0017183c:\n          remove_quoted_nulls(pcVar9);\n          ppcVar10 = (char **)alloc_word_desc();\n          *ppcVar10 = pcVar9;\n          local_88 = (long *)make_word_list(ppcVar10,local_88);\n          lVar15 = local_88[1];\n          uVar6 = *(uint *)(lVar15 + 8) & 0xfffbffff;\n          if ((param_3 & 3) != 0) {\n            uVar6 = uVar6 | 2;\n          }\n          *(uint *)(lVar15 + 8) = uVar6;\n          if (*pcVar9 == '\\0') {\n            *(uint *)(lVar15 + 8) = *(uint *)(lVar15 + 8) | 0x200000;\n          }\n        }\n        iVar17 = local_4c;\n        lVar15 = (long)local_4c;\n        bVar14 = param_1[lVar15];\n        iVar18 = local_4c;\n        if (bVar14 != 0) {\n          bVar20 = (bool)(param_2 == (byte *)0x0 | bVar21);\n          if (bVar20) {\n            if ((char)bVar14 < '\\v') {\n              uVar5 = (ushort)('\\b' < (char)bVar14);\n            }\n            else {\n              uVar5 = (ushort)(bVar14 == 0x20);\n            }\n          }\n          else {\n            ppuVar8 = __ctype_b_loc();\n            uVar5 = (*ppuVar8)[bVar14] >> 0xd & 1;\n          }\n          iVar18 = iVar17 + 1;\n          local_48.__count = 0;\n          local_48.__value = (_union_27)0x0;\n          if (locale_mb_cur_max < 2) goto LAB_001716a1;\n          if ((*(uint *)(is_basic_table + (ulong)(bVar14 >> 5) * 4) >> (bVar14 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale != 0) && (iVar18 = 1, -1 < (char)bVar14)) goto LAB_0017169e;\n            sVar13 = mbrtowc((wchar_t *)0x0,(char *)(param_1 + lVar15),local_80 - lVar15,&local_48);\n            iVar18 = (int)sVar13;\n            if (sVar13 < 0xfffffffffffffffe) {\n              iVar17 = local_4c;\n              if (sVar13 != 0) goto LAB_0017169e;\n              iVar18 = local_4c + 1;\n            }\n            else {\n              iVar18 = local_4c + 1;\n            }\n          }\n          else {\n            iVar18 = 1;\nLAB_0017169e:\n            iVar18 = iVar18 + iVar17;\n          }\nLAB_001716a1:\n          bVar14 = param_1[iVar18];\n          if (bVar14 != 0) {\n            bVar3 = false;\n            uVar19 = (long)(iVar18 + 1);\n            local_4c = iVar18;\n            do {\n              uVar16 = (ulong)bVar14;\n              iVar18 = (int)uVar19;\n              iVar17 = (int)uVar7;\n              if (bVar20) {\n                if ((char)bVar14 < '\\v') {\n                  if ('\\b' < (char)bVar14) goto LAB_001717ab;\n                }\n                else if (bVar14 == 0x20) {\n                  bVar4 = *param_2;\n                  goto joined_r0x0017180f;\n                }\nLAB_001716f0:\n                if (bVar3) {\n                  local_4c = iVar17;\n                }\n                if ((uVar5 == 0) || (bVar4 = *param_2, bVar4 == 0)) goto LAB_0017176e;\n                if (param_2[1] != 0) goto LAB_00171952;\nLAB_00171745:\n                bVar20 = bVar14 == bVar4;\n                goto LAB_0017174b;\n              }\n              ppuVar8 = __ctype_b_loc();\n              if ((*(byte *)((long)*ppuVar8 + uVar16 * 2 + 1) & 0x20) == 0) goto LAB_001716f0;\nLAB_001717ab:\n              bVar4 = *param_2;\njoined_r0x0017180f:\n              if (bVar4 == 0) {\n                if (!bVar3) goto LAB_0017154a;\n                bVar14 = param_1[iVar17];\n                local_4c = iVar17;\n                goto LAB_00171778;\n              }\n              if (param_2[1] == 0) {\n                if (bVar4 == bVar14) goto LAB_001717d4;\n                if (bVar3) {\n                  local_4c = iVar17;\n                }\n                if (uVar5 != 0) goto LAB_00171745;\n                goto LAB_0017176e;\n              }\n              if (*(char *)((long)&ifs_cmap + uVar16) == '\\0') goto LAB_00171939;\nLAB_001717d4:\n              uVar7 = uVar19 & 0xffffffff;\n              bVar3 = true;\n              bVar14 = param_1[uVar19];\n              uVar19 = uVar19 + 1;\n              if (bVar14 == 0) {\n                iVar18 = (int)uVar7;\n                break;\n              }\n            } while( true );\n          }\n        }\n      }\n      goto LAB_001715cd;\n    }\n    bVar2 = param_2[1];\n    do {\n      if (bVar2 != 0) {\n        uVar7 = (ulong)bVar14;\n        if (*(char *)((long)&ifs_cmap + uVar7) != '\\0') goto LAB_001714d3;\nLAB_00171505:\n        if (*param_1 != 0) goto LAB_0017150f;\n        break;\n      }\n      if (bVar4 != bVar14) goto LAB_00171505;\n      uVar7 = (ulong)bVar4;\nLAB_001714d3:\n      ppuVar8 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar8 + uVar7 * 2 + 1) & 0x20) == 0) goto LAB_00171505;\n      bVar14 = param_1[1];\n      param_1 = param_1 + 1;\n    } while (bVar14 != 0);\n  }\nLAB_0017196a:\n  local_88 = (long *)0x0;\nLAB_001715f0:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_88;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\nLAB_00171939:\n  if (bVar3) {\n    local_4c = iVar17;\n  }\n  if (uVar5 != 0) {\nLAB_00171952:\n    bVar20 = *(char *)((long)&ifs_cmap + uVar16) != '\\0';\nLAB_0017174b:\n    if (bVar20) {\n      if (bVar21) {\n        if ((1 < (byte)(bVar14 - 9)) && (bVar14 != 0x20)) {\nLAB_001719cc:\n          bVar14 = param_1[iVar18];\n          if (bVar14 != 0) {\n            lVar15 = (long)(iVar18 + 1);\n            local_4c = iVar18;\n            bVar3 = false;\n            do {\n              if (bVar21) {\n                if ((char)bVar14 < '\\v') {\n                  if ((char)bVar14 < '\\t') goto LAB_00171a20;\n                }\n                else if (bVar14 != 0x20) goto LAB_00171a20;\n              }\n              else {\n                ppuVar8 = __ctype_b_loc();\n                if ((*(byte *)((long)*ppuVar8 + (ulong)bVar14 * 2 + 1) & 0x20) == 0)\n                goto LAB_00171a20;\n              }\n              if (*(char *)((long)&ifs_cmap + (ulong)bVar14) == '\\0') goto LAB_00171a20;\n              local_5c = (int)lVar15;\n              bVar14 = param_1[lVar15];\n              lVar15 = lVar15 + 1;\n              iVar18 = local_5c;\n              bVar3 = bVar20;\n              if (bVar14 == 0) break;\n            } while( true );\n          }\n          goto LAB_001715cd;\n        }\n      }\n      else {\n        ppuVar8 = __ctype_b_loc();\n        if ((*(byte *)((long)*ppuVar8 + uVar16 * 2 + 1) & 0x20) == 0) goto LAB_001719cc;\n      }\n    }\n  }\nLAB_0017176e:\n  bVar14 = param_1[local_4c];\n  goto LAB_00171778;\nLAB_00171a20:\n  if (!bVar3) goto LAB_0017154a;\n  bVar14 = param_1[local_5c];\n  local_4c = local_5c;\nLAB_00171778:\n  iVar18 = local_4c;\n  if (bVar14 == 0) goto LAB_001715cd;\n  goto LAB_0017154a;\nLAB_001715cd:\n  local_4c = iVar18;\n  if (local_88 != (long *)0x0) {\n    if (*local_88 != 0) {\n      local_88 = (long *)list_reverse(local_88);\n    }\n    goto LAB_001715f0;\n  }\n  goto LAB_0017196a;\n}\n\n",
  "FUN_0014eab0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nuint FUN_0014eab0(uint *param_1,int param_2,uint param_3,uint param_4,int *param_5)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  long lVar4;\n  uint uVar5;\n  bool bVar6;\n  bool bVar7;\n  uint *local_40;\n  uint local_2c;\n  \n  bVar7 = false;\n  subshell_level = subshell_level + 1;\n  uVar5 = param_1[1];\n  if (param_2 != 0) {\n    if (((uVar5 & 0x400) == 0) || (param_3 != 0xffffffff)) {\n      bVar7 = false;\n    }\n    else {\n      iVar1 = stdin_redirects(*(undefined8 *)(param_1 + 4));\n      bVar7 = iVar1 == 0;\n      uVar5 = param_1[1];\n    }\n  }\n  uVar3 = uVar5 & 1;\n  if (*param_1 == 0xd) {\n    uVar3 = 1;\n  }\n  bVar6 = *param_1 == 0xe;\n  param_1[1] = uVar5 & 0xfffffff8;\n  iVar1 = interactive_shell;\n  if (param_2 != 0) {\n    original_pgrp = 0xffffffff;\n    interactive_shell = 0;\n    if (iVar1 != 0) {\n      expand_aliases = 0;\n    }\n  }\n  interactive = 0;\n  login_shell = 0;\n  if (0x2c < shell_compatibility_level) {\n    loop_level = 0;\n  }\n  if (uVar3 == 0) {\n    subshell_environment = (uint)(param_2 != 0);\n    if ((param_3 & param_4) != 0xffffffff) {\n      subshell_environment = subshell_environment | 0x10;\n    }\n    if (bVar6) {\n      subshell_environment = subshell_environment | 0x40;\n    }\n  }\n  else {\n    subshell_environment = 3 - (param_2 == 0);\n  }\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n  }\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  reset_terminating_signals();\n  clear_pending_traps();\n  reset_signal_handlers();\n  subshell_environment = subshell_environment & 0xfffffeff | 0x80;\n  if (0 < running_trap) {\n    run_trap_cleanup(running_trap + -1);\n    running_trap = 0;\n  }\n  if (param_2 == 0) {\n    set_sigint_handler();\n  }\n  else if (job_control == 0) {\n    get_original_signal(2);\n    set_signal_handler(2,1);\n    get_original_signal(3);\n    set_signal_handler(3,1);\n  }\n  set_sigchld_handler();\n  without_job_control();\n  if ((param_5 != (int *)0x0) && (0 < *param_5)) {\n    lVar4 = 0;\n    do {\n      while (*(char *)(*(long *)(param_5 + 2) + lVar4) != '\\0') {\n        close((int)lVar4);\n        *(undefined *)(*(long *)(param_5 + 2) + lVar4) = 0;\n        lVar4 = lVar4 + 1;\n        if (*param_5 == (int)lVar4 || *param_5 < (int)lVar4) goto LAB_0014ecb5;\n      }\n      lVar4 = lVar4 + 1;\n    } while (*param_5 != (int)lVar4 && (int)lVar4 <= *param_5);\n  }\nLAB_0014ecb5:\n  FUN_001497c0(param_3,param_4);\n  if (-1 < DAT_0023842c) {\n    close(DAT_0023842c);\n    DAT_0023842c = -1;\n  }\n  if (-1 < DAT_00238430) {\n    close(DAT_00238430);\n    DAT_00238430 = -1;\n  }\n  _DAT_00238434 = 0xffffffffffffffff;\n  clear_fifo_list();\n  if (uVar3 == 0) {\n    if (((0xc < *param_1) || ((0x1fafUL >> ((ulong)*param_1 & 0x3f) & 1) == 0)) ||\n       (param_3 == 0xffffffff)) goto LAB_0014efd4;\n    stdin_redir = 1;\n  }\n  else {\n    iVar1 = stdin_redirects(*(undefined8 *)(param_1 + 4));\n    stdin_redir = (uint)(param_3 != 0xffffffff || iVar1 != 0);\nLAB_0014efd4:\n    if ((bVar7) && (stdin_redir == 0)) {\n      async_redirect_stdin();\n    }\n  }\n  default_buffered_input = 0xffffffff;\n  if (uVar3 == 0) {\nLAB_0014f010:\n    lVar4 = *(long *)(param_1 + 4);\n    if (lVar4 == 0) {\n      uVar5 = *param_1;\n    }\n    else {\nLAB_0014ed67:\n      iVar1 = do_redirections(lVar4,1);\n      if (iVar1 != 0) {\n                    /* WARNING: Subroutine does not return */\n        exit((uint)((uVar5 >> 2 & 1) == 0));\n      }\n      dispose_redirects(*(undefined8 *)(param_1 + 4));\n      uVar5 = *param_1;\n      *(undefined8 *)(param_1 + 4) = 0;\n    }\n    if (uVar5 == 0xd) {\n      local_40 = *(uint **)(*(long *)(param_1 + 6) + 8);\n      bVar7 = local_40 != param_1;\n      goto LAB_0014edb7;\n    }\n  }\n  else {\n    if (*param_1 == 0xd) {\n      optimize_subshell_command(*(undefined8 *)(*(long *)(param_1 + 6) + 8));\n      goto LAB_0014f010;\n    }\n    lVar4 = *(long *)(param_1 + 4);\n    if (lVar4 != 0) goto LAB_0014ed67;\n  }\n  if (bVar6) {\n    local_40 = *(uint **)(*(long *)(param_1 + 6) + 0x10);\n    bVar7 = local_40 != param_1;\n  }\n  else {\n    bVar7 = false;\n    local_40 = param_1;\n  }\nLAB_0014edb7:\n  uVar5 = param_1[1];\n  if ((uVar5 & 0x80) != 0) {\n    local_40[1] = local_40[1] | 0x80;\n    uVar5 = param_1[1];\n  }\n  if ((uVar5 & 0x100) != 0) {\n    local_40[1] = local_40[1] | 0x100;\n    uVar5 = param_1[1];\n  }\n  if (((uVar5 & 8) != 0) && (bVar7)) {\n    local_40[1] = local_40[1] | 8;\n  }\n  if ((((uVar3 != 0) || (bVar6)) && ((*local_40 == 4 || (*local_40 == 0xd)))) &&\n     ((((local_40[1] & 0x80) == 0 && ((local_40[1] & 4) == 0)) &&\n      (local_40[1] = local_40[1] | 0x40, *local_40 == 4)))) {\n    **(uint **)(local_40 + 6) = **(uint **)(local_40 + 6) | 0x40;\n  }\n  local_2c = local_40[1] >> 2 & 1;\n  local_40[1] = local_40[1] & 0xfffffffb;\n  iVar2 = __sigsetjmp(top_level,0);\n  iVar1 = return_catch_flag;\n  if (return_catch_flag != 0) {\n    iVar1 = __sigsetjmp(return_catch,0);\n  }\n  if ((iVar2 == 3) || (iVar2 == 6)) {\n    local_2c = 0;\n    uVar5 = last_command_exit_value;\n  }\n  else if (iVar2 == 0) {\n    uVar5 = return_catch_value;\n    if (iVar1 == 0) {\n      uVar5 = execute_command_internal(local_40,0,0xffffffff,0xffffffff,param_5);\n    }\n  }\n  else {\n    uVar5 = 1;\n    if (last_command_exit_value != 0) {\n      uVar5 = last_command_exit_value;\n    }\n  }\n  if (local_2c != 0) {\n    uVar5 = (uint)(uVar5 == 0);\n  }\n  if ((uVar3 != 0) && (iVar1 = signal_is_trapped(0), iVar1 != 0)) {\n    last_command_exit_value = uVar5;\n    uVar5 = run_exit_trap();\n    return uVar5;\n  }\n  return uVar5;\n}\n\n",
  "_rl_qsort_string_compare": "\nvoid _rl_qsort_string_compare(char **param_1,char **param_2)\n\n{\n  strcoll(*param_1,*param_2);\n  return;\n}\n\n",
  "FUN_00134b10": "\nulong FUN_00134b10(void)\n\n{\n  byte bVar1;\n  \n  if ((DAT_00240a70 != (byte *)0x0) && (bVar1 = *DAT_00240a70, bVar1 != 0)) {\n    DAT_00240a70 = DAT_00240a70 + 1;\n    return (ulong)bVar1;\n  }\n  return 0xffffffff;\n}\n\n",
  "parse_bashopts": "\nvoid parse_bashopts(undefined8 param_1)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  char *__s1;\n  long lVar4;\n  char *__s2;\n  int iVar5;\n  undefined **ppuVar6;\n  long in_FS_OFFSET;\n  undefined4 local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_44 = 0;\n  do {\n    __s1 = (char *)extract_colon_unit(param_1,&local_44);\n    if (__s1 == (char *)0x0) {\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    cVar1 = *__s1;\n    ppuVar6 = &PTR_s_assoc_expand_once_00236438;\n    cVar2 = 'a';\n    iVar5 = 0;\n    __s2 = \"autocd\";\nLAB_001b7f53:\n    if (cVar1 != cVar2) {\nLAB_001b7f40:\n      __s2 = *ppuVar6;\n      ppuVar6 = ppuVar6 + 3;\n      iVar5 = iVar5 + 1;\n      if (__s2 == (char *)0x0) goto LAB_001b7f93;\n      cVar2 = *__s2;\n      goto LAB_001b7f53;\n    }\n    iVar3 = strcmp(__s1,__s2);\n    if (iVar3 != 0) goto LAB_001b7f40;\n    lVar4 = (long)iVar5;\n    *(undefined4 *)(&PTR_autocd_00236428)[lVar4 * 3] = 1;\n    if ((code *)(&DAT_00236430)[lVar4 * 3] != (code *)0x0) {\n      (*(code *)(&DAT_00236430)[lVar4 * 3])((&PTR_DAT_00236420)[lVar4 * 3],1);\n    }\nLAB_001b7f93:\n    sh_xfree(__s1,\"./shopt.def\",0x380);\n  } while( true );\n}\n\n",
  "find_shell_variable": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong find_shell_variable(undefined8 param_1)\n\n{\n  long *plVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long lVar4;\n  \n  lVar4 = shell_variables;\n  if (shell_variables != 0) {\n    do {\n      uVar2 = *(undefined8 *)(lVar4 + 0x20);\n      lVar3 = hash_search(param_1,uVar2,0);\n      if ((lVar3 != 0) && (lVar3 = *(long *)(lVar3 + 0x10), _DAT_002422f8 = uVar2, lVar3 != 0)) {\n        if (((*(byte *)(lVar3 + 0x29) & 8) != 0) && (lVar3 = find_variable_nameref(), lVar3 == 0)) {\n          return 0;\n        }\n        if (*(code **)(lVar3 + 0x18) != (code *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x001537f3. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          lVar4 = (**(code **)(lVar3 + 0x18))();\n          return lVar4;\n        }\n        return lVar3;\n      }\n      plVar1 = (long *)(lVar4 + 0x18);\n      lVar4 = *plVar1;\n    } while (*plVar1 != 0);\n  }\n  return 0;\n}\n\n",
  "FUN_00193990": "\nundefined8 FUN_00193990(int param_1)\n\n{\n  mbstate_t mVar1;\n  int iVar2;\n  int iVar3;\n  size_t sVar4;\n  undefined8 uVar5;\n  byte bVar6;\n  long lVar7;\n  long lVar8;\n  int iVar9;\n  byte *pbVar10;\n  long lVar11;\n  long in_FS_OFFSET;\n  int local_5c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  if (param_1 < 0) {\n    uVar5 = FUN_001936e0(-param_1);\n  }\n  else {\n    lVar8 = (long)rl_end;\n    iVar9 = rl_point;\n    if ((param_1 != 0) && (local_5c = param_1 + -1, rl_point != rl_end)) {\n      do {\n        iVar2 = char_is_quoted(rl_line_buffer,iVar9);\n        lVar7 = (long)iVar9;\n        if ((iVar2 == 0) || ((iVar9 < 1 || (*(char *)(rl_line_buffer + -1 + lVar7) == '\\\\')))) {\n          lVar11 = rl_line_buffer;\n          iVar2 = rl_end;\n          if (iVar9 < rl_end) {\n            do {\n              mVar1 = local_48;\n              pbVar10 = (byte *)(lVar11 + lVar7);\n              bVar6 = *pbVar10;\n              if (bVar6 == 0) goto LAB_00193b39;\n              if (((&sh_syntaxtab)[bVar6] & 0x2001) == 0) goto LAB_00193ca0;\n              if (bVar6 == 0x27) {\n                iVar9 = skip_to_delim(lVar11,iVar9 + 1,&DAT_001ff32d,1);\n                lVar11 = rl_line_buffer;\n                iVar2 = rl_end;\nLAB_00193b20:\n                if (iVar2 <= iVar9) {\n                  lVar7 = (long)iVar9;\n                  goto LAB_00193b2b;\n                }\nLAB_00193c20:\n                iVar9 = iVar9 + 1;\n              }\n              else {\n                if (bVar6 == 0x5c) {\n                  if (locale_mb_cur_max < 2) {\n                    iVar9 = iVar9 + 1;\n                    local_48 = mVar1;\n                  }\n                  else {\n                    iVar3 = 1;\n                    if (((uint)is_basic_table._8_4_ >> 0x1c & 1 | locale_utf8locale) == 0) {\n                      sVar4 = mbrtowc((wchar_t *)0x0,(char *)pbVar10,lVar8 - lVar7,&local_48);\n                      lVar11 = rl_line_buffer;\n                      iVar2 = rl_end;\n                      if (sVar4 < 0xfffffffffffffffe) {\n                        if (sVar4 != 0) {\n                          iVar3 = (int)sVar4;\n                          goto LAB_00193b15;\n                        }\n                        iVar9 = iVar9 + 1;\n                      }\n                      else {\n                        iVar9 = iVar9 + 1;\n                        local_48 = mVar1;\n                      }\n                    }\n                    else {\nLAB_00193b15:\n                      iVar9 = iVar9 + iVar3;\n                    }\n                  }\n                  goto LAB_00193b20;\n                }\n                if (bVar6 == 0x22) {\n                  iVar9 = skip_to_delim(lVar11,iVar9 + 1,&DAT_001ff6b5,1);\n                  lVar11 = rl_line_buffer;\n                  iVar2 = rl_end;\n                  goto LAB_00193b20;\n                }\n                if (locale_mb_cur_max < 2) goto LAB_00193c20;\n                if ((*(uint *)(is_basic_table + (ulong)(bVar6 >> 5) * 4) >> (bVar6 & 0x1f) & 1) == 0\n                   ) {\n                  if ((locale_utf8locale != 0) && (iVar3 = 1, -1 < (char)bVar6)) goto LAB_00193aa8;\n                  sVar4 = mbrtowc((wchar_t *)0x0,(char *)pbVar10,lVar8 - lVar7,&local_48);\n                  lVar11 = rl_line_buffer;\n                  iVar2 = rl_end;\n                  if (sVar4 < 0xfffffffffffffffe) {\n                    if (sVar4 != 0) {\n                      iVar3 = (int)sVar4;\n                      goto LAB_00193aa8;\n                    }\n                    iVar9 = iVar9 + 1;\n                  }\n                  else {\n                    iVar9 = iVar9 + 1;\n                    local_48 = mVar1;\n                  }\n                }\n                else {\n                  iVar3 = 1;\nLAB_00193aa8:\n                  iVar9 = iVar9 + iVar3;\n                }\n              }\n              lVar7 = (long)iVar9;\n            } while (iVar9 < iVar2);\n            if ((*(char *)(lVar11 + lVar7) != '\\0') && (iVar9 != iVar2)) {\nLAB_00193ca0:\n              if (iVar2 <= iVar9) goto LAB_00193dc4;\n              pbVar10 = (byte *)(lVar11 + lVar7);\n              bVar6 = *pbVar10;\n              if (bVar6 != 0) {\n                while (mVar1 = local_48, ((&sh_syntaxtab)[bVar6] & 0x2001) == 0) {\n                  if (bVar6 == 0x27) {\n                    iVar9 = skip_to_delim(lVar11,iVar9 + 1,&DAT_001ff32d,1);\n                    iVar2 = rl_end;\nLAB_00193dc0:\n                    if (iVar2 <= iVar9) goto LAB_00193dc4;\nLAB_00193da0:\n                    iVar9 = iVar9 + 1;\n                  }\n                  else {\n                    if (bVar6 == 0x5c) {\n                      if (locale_mb_cur_max < 2) {\n                        iVar9 = iVar9 + 1;\n                        local_48 = mVar1;\n                      }\n                      else if (((uint)is_basic_table._8_4_ >> 0x1c & 1 | locale_utf8locale) == 0) {\n                        sVar4 = mbrtowc((wchar_t *)0x0,(char *)pbVar10,lVar8 - lVar7,&local_48);\n                        iVar2 = rl_end;\n                        if (sVar4 < 0xfffffffffffffffe) {\n                          if (sVar4 == 0) {\n                            iVar9 = iVar9 + 1;\n                          }\n                          else {\n                            iVar9 = iVar9 + (int)sVar4;\n                          }\n                        }\n                        else {\n                          iVar9 = iVar9 + 1;\n                          local_48 = mVar1;\n                        }\n                      }\n                      else {\n                        iVar9 = iVar9 + 1;\n                        local_48 = mVar1;\n                      }\n                      goto LAB_00193dc0;\n                    }\n                    if (bVar6 == 0x22) {\n                      iVar9 = skip_to_delim(lVar11,iVar9 + 1,&DAT_001ff6b5,1);\n                      iVar2 = rl_end;\n                      goto LAB_00193dc0;\n                    }\n                    if (locale_mb_cur_max < 2) goto LAB_00193da0;\n                    if ((*(uint *)(is_basic_table + (ulong)(bVar6 >> 5) * 4) >> (bVar6 & 0x1f) & 1)\n                        == 0) {\n                      if ((locale_utf8locale != 0) && (iVar3 = 1, -1 < (char)bVar6))\n                      goto LAB_00193d2d;\n                      sVar4 = mbrtowc((wchar_t *)0x0,(char *)pbVar10,lVar8 - lVar7,&local_48);\n                      iVar2 = rl_end;\n                      if (sVar4 < 0xfffffffffffffffe) {\n                        if (sVar4 != 0) {\n                          iVar3 = (int)sVar4;\n                          goto LAB_00193d2d;\n                        }\n                        iVar9 = iVar9 + 1;\n                      }\n                      else {\n                        iVar9 = iVar9 + 1;\n                        local_48 = mVar1;\n                      }\n                    }\n                    else {\n                      iVar3 = 1;\nLAB_00193d2d:\n                      iVar9 = iVar9 + iVar3;\n                    }\n                  }\n                  if (iVar2 <= iVar9) goto LAB_00193dc4;\n                  lVar7 = (long)iVar9;\n                  pbVar10 = (byte *)(rl_line_buffer + lVar7);\n                  bVar6 = *pbVar10;\n                  lVar11 = rl_line_buffer;\n                  if (bVar6 == 0) goto LAB_00193d51;\n                }\n                goto LAB_00193bf0;\n              }\nLAB_00193d51:\n              uVar5 = 0;\n              rl_point = iVar2;\n              goto LAB_00193b46;\n            }\n          }\n          else {\nLAB_00193b2b:\n            if ((*(char *)(lVar11 + lVar7) != '\\0') && (iVar9 != iVar2)) {\nLAB_00193dc4:\n              if ((iVar2 == iVar9) || (*(char *)(rl_line_buffer + iVar9) == '\\0'))\n              goto LAB_00193d51;\n              goto LAB_00193bf0;\n            }\n          }\nLAB_00193b39:\n          rl_point = iVar2;\n          rl_ding();\n          uVar5 = 0;\n          goto LAB_00193b46;\n        }\n        do {\n          mVar1 = local_48;\n          if (locale_mb_cur_max < 2) goto LAB_00193b93;\n          pbVar10 = (byte *)(rl_line_buffer + iVar9);\n          bVar6 = *pbVar10;\n          if ((*(uint *)(is_basic_table + (ulong)(bVar6 >> 5) * 4) >> (bVar6 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale != 0) && (-1 < (char)bVar6)) {\n              if (bVar6 == 0) goto LAB_00193b93;\n              goto LAB_00193bd8;\n            }\n            sVar4 = mbrtowc((wchar_t *)0x0,(char *)pbVar10,lVar8 - iVar9,&local_48);\n            if ((sVar4 < 0xfffffffffffffffe) && (mVar1 = local_48, sVar4 != 0)) {\n              iVar9 = iVar9 + (int)sVar4;\n              goto LAB_00193bdf;\n            }\nLAB_00193b93:\n            local_48 = mVar1;\n            iVar9 = iVar9 + 1;\n            if (rl_end <= iVar9) break;\n          }\n          else {\nLAB_00193bd8:\n            iVar9 = iVar9 + 1;\nLAB_00193bdf:\n            if (rl_end <= iVar9) break;\n          }\n          iVar2 = char_is_quoted(rl_line_buffer,iVar9);\n        } while (iVar2 != 0);\nLAB_00193bf0:\n      } while ((local_5c != 0) && (local_5c = local_5c + -1, iVar9 != rl_end));\n    }\n    uVar5 = 0;\n    rl_point = iVar9;\n  }\nLAB_00193b46:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar5;\n}\n\n",
  "set_var_read_only": "\nvoid set_var_read_only(undefined8 param_1)\n\n{\n  uint uVar1;\n  long lVar2;\n  \n  lVar2 = find_variable();\n  if (lVar2 != 0) {\n    *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) | 2;\n    return;\n  }\n  lVar2 = bind_variable(param_1,&DAT_00213d70,0);\n  if (lVar2 == 0) {\n    do {\n      invalidInstructionException();\n    } while( true );\n  }\n  uVar1 = *(uint *)(lVar2 + 0x28);\n  *(uint *)(lVar2 + 0x28) = uVar1 | 0x1000;\n  *(uint *)(lVar2 + 0x28) = uVar1 | 0x1002;\n  return;\n}\n\n",
  "FUN_001f0a70": "\nundefined8 FUN_001f0a70(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  do {\n    if (1000000 < rl_numeric_arg) {\n      _rl_argcxt = 0;\n      rl_numeric_arg = 0;\n      rl_explicit_arg = 0;\n      rl_ding();\n      rl_restore_prompt();\n      rl_clear_message();\n      rl_readline_state = rl_readline_state & 0xfffffffffffffbff;\n      return 1;\n    }\n    rl_message(\"(arg: %d) \",rl_numeric_arg * rl_arg_sign);\n    rl_readline_state = rl_readline_state | 0x40;\n    iVar1 = rl_read_key();\n    rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n    if (iVar1 < 0) {\n                    /* WARNING: Subroutine does not return */\n      _rl_abort_internal();\n    }\n    uVar2 = _rl_arg_dispatch(_rl_argcxt);\n    if ((int)uVar2 < 1) {\n      return uVar2;\n    }\n  } while ((rl_readline_state & 0x400) != 0);\n  return uVar2;\n}\n\n",
  "array_dispose_element": "\nvoid array_dispose_element(long param_1)\n\n{\n  if (param_1 != 0) {\n    if (*(long *)(param_1 + 8) != 0) {\n      sh_xfree(*(long *)(param_1 + 8),\"array.c\",0x21e);\n    }\n    sh_xfree(param_1,\"array.c\",0x21f);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001ee210": "\nundefined4 FUN_001ee210(int param_1,uint param_2)\n\n{\n  uint uVar1;\n  undefined8 uVar2;\n  int iVar3;\n  size_t sVar4;\n  undefined *puVar5;\n  long lVar6;\n  size_t __n;\n  char cVar7;\n  undefined *puVar8;\n  long lVar9;\n  undefined4 uVar10;\n  int iVar11;\n  int iVar12;\n  long in_FS_OFFSET;\n  wchar_t local_60;\n  char local_5a;\n  undefined local_59;\n  char local_58 [24];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar4 = __ctype_get_mb_cur_max();\n  iVar3 = DAT_0024b698;\n  uVar2 = DAT_0024b690;\n  cVar7 = (char)param_2;\n  if (((sVar4 == 1) || (rl_byte_oriented != 0)) ||\n     ((_rl_utf8locale != 0 && ((param_2 & 0x80) == 0)))) {\n    uVar1 = param_1 - 2;\n    iVar11 = 1;\n    local_58[1] = 0;\n    local_58[0] = cVar7;\n  }\n  else {\n    if (DAT_0024b684 < 1) {\n      DAT_0024b684 = param_1;\n    }\n    param_1 = DAT_0024b684;\n    lVar6 = (long)DAT_0024b698;\n    (&DAT_0024b6a0)[lVar6] = cVar7;\n    iVar11 = DAT_0024b698 + 1;\n    __n = (size_t)iVar11;\n    DAT_0024b698 = iVar11;\n    sVar4 = mbrtowc(&local_60,&DAT_0024b6a0,__n,(mbstate_t *)&DAT_0024b690);\n    if (sVar4 == 0xfffffffffffffffe) {\n      uVar10 = 1;\n      DAT_0024b690 = uVar2;\n      goto LAB_001ee4a8;\n    }\n    if (sVar4 == 0xffffffffffffffff) {\n      local_58[1] = 0;\n      local_58[0] = DAT_0024b6a0;\n      iVar11 = 1;\n      DAT_0024b698 = iVar3;\n      __memmove_chk(&DAT_0024b6a0,&DAT_0024b6a1,lVar6,0x10);\n      DAT_0024b690 = 0;\n    }\n    else if (sVar4 == 0) {\n      local_58[0] = '\\0';\n      DAT_0024b690 = 0;\n      iVar11 = 0;\n      DAT_0024b698 = iVar3;\n    }\n    else if (sVar4 == 1) {\n      local_58[0] = DAT_0024b6a0;\n      local_58[1] = 0;\n      iVar11 = 1;\n      DAT_0024b698 = 0;\n    }\n    else {\n      __memcpy_chk(local_58,&DAT_0024b6a0,__n,0x11);\n      DAT_0024b698 = 0;\n      local_58[__n] = '\\0';\n    }\n    uVar1 = param_1 - 2;\n  }\n  if (uVar1 < 0x3ff) {\n    param_1 = param_1 * iVar11;\n    puVar5 = (undefined *)xmalloc((long)(param_1 + 1));\n    puVar8 = puVar5;\n    if (0 < param_1) {\n      iVar3 = 0;\n      do {\n        while (lVar6 = (long)iVar3, iVar11 != 1) {\n          iVar3 = iVar3 + iVar11;\n          strncpy(puVar5 + lVar6,local_58,(long)iVar11);\n          if (param_1 <= iVar3) goto LAB_001ee3e6;\n        }\n        iVar3 = iVar3 + 1;\n        puVar5[lVar6] = local_58[0];\n      } while (iVar3 < param_1);\nLAB_001ee3e6:\n      puVar8 = puVar5 + iVar3;\n    }\n    *puVar8 = 0;\n    uVar10 = 0;\n    DAT_0024b684 = 0;\n    rl_insert_text(puVar5);\n    xfree(puVar5);\n  }\n  else if (param_1 < 0x401) {\n    sVar4 = __ctype_get_mb_cur_max();\n    if ((sVar4 == 1) || (rl_byte_oriented != 0)) {\n      if (((rl_readline_state._1_1_ & 8) == 0) && (iVar3 = _rl_pushed_input_available(), iVar3 != 0)\n         ) {\n        uVar10 = 0;\n        _rl_insert_typein(param_2);\n      }\n      else {\n        local_59 = 0;\n        uVar10 = 0;\n        local_5a = cVar7;\n        rl_insert_text(&local_5a);\n      }\n    }\n    else {\n      rl_insert_text(local_58);\n      DAT_0024b684 = 0;\n      uVar10 = 0;\n    }\n  }\n  else {\n    iVar3 = 0;\n    iVar12 = iVar11 * 0x400;\n    lVar6 = xmalloc((long)(iVar12 + 1));\n    if (0 < iVar12) {\n      do {\n        while (lVar9 = (long)iVar3, iVar11 != 1) {\n          iVar3 = iVar3 + iVar11;\n          strncpy((char *)(lVar9 + lVar6),local_58,(long)iVar11);\n          if (iVar12 <= iVar3) goto LAB_001ee470;\n        }\n        iVar3 = iVar3 + 1;\n        *(char *)(lVar9 + lVar6) = local_58[0];\n      } while (iVar3 < iVar12);\n    }\nLAB_001ee470:\n    do {\n      iVar3 = 0x400;\n      if (param_1 < 0x401) {\n        iVar3 = param_1;\n      }\n      *(undefined *)(lVar6 + iVar11 * iVar3) = 0;\n      rl_insert_text(lVar6);\n      param_1 = param_1 - iVar3;\n    } while (param_1 != 0);\n    uVar10 = 0;\n    xfree(lVar6);\n    DAT_0024b684 = 0;\n  }\nLAB_001ee4a8:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar10;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "strlist_print": "\nvoid strlist_print(long *param_1,undefined *param_2)\n\n{\n  long lVar1;\n  undefined *puVar2;\n  long lVar3;\n  \n  if (param_1 != (long *)0x0) {\n    if (0 < *(int *)((long)param_1 + 0xc)) {\n      puVar2 = &DAT_00213d70;\n      if (param_2 != (undefined *)0x0) {\n        puVar2 = param_2;\n      }\n      lVar3 = 0;\n      do {\n        lVar1 = lVar3 * 8;\n        lVar3 = lVar3 + 1;\n        __printf_chk(1,\"%s%s\\n\",puVar2,*(undefined8 *)(*param_1 + lVar1));\n      } while (*(int *)((long)param_1 + 0xc) != (int)lVar3 &&\n               (int)lVar3 <= *(int *)((long)param_1 + 0xc));\n    }\n    return;\n  }\n  return;\n}\n\n",
  "main": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid main(int param_1,char **param_2,undefined8 param_3)\n\n{\n  byte bVar1;\n  char cVar2;\n  int iVar3;\n  __uid_t _Var4;\n  int iVar5;\n  uint uVar6;\n  undefined4 uVar7;\n  int iVar8;\n  char *pcVar9;\n  size_t sVar10;\n  char *pcVar11;\n  char **ppcVar12;\n  undefined8 *puVar13;\n  long lVar14;\n  long lVar15;\n  undefined8 uVar16;\n  __off_t _Var17;\n  ssize_t sVar18;\n  int *piVar19;\n  uint uVar20;\n  long lVar21;\n  char cVar22;\n  uint uVar23;\n  char *pcVar24;\n  undefined **ppuVar25;\n  long in_FS_OFFSET;\n  bool bVar26;\n  char **local_168;\n  int local_160;\n  int local_15c;\n  undefined8 local_150;\n  char *local_140;\n  uint local_134;\n  int local_130;\n  stat local_128;\n  undefined local_98 [88];\n  undefined8 local_40;\n  \n  local_40 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  iVar3 = __sigsetjmp(top_level,0);\n  if (iVar3 != 0) goto LAB_00131cfd;\n  xtrace_init();\n  check_dev_tty();\n  while (debugging_login_shell != 0) {\n    sleep(3);\n  }\n  set_default_locale();\n  _Var4 = getuid();\n  if (_Var4 != current_user) {\n    if (DAT_00238050 != 0) {\n      sh_xfree(DAT_00238050,\"shell.c\",0x52b);\n    }\n    if (DAT_00238058 != 0) {\n      sh_xfree(DAT_00238058,\"shell.c\",0x52c);\n    }\n    if (DAT_00238060 != 0) {\n      sh_xfree(DAT_00238060,\"shell.c\",0x52d);\n    }\n    DAT_00238060 = 0;\n    DAT_00238058 = 0;\n    DAT_00238050 = 0;\n  }\n  current_user = _Var4;\n  DAT_00238048 = getgid();\n  DAT_00238044 = geteuid();\n  DAT_0023804c = getegid();\n  _DAT_002409d4 = 1;\n  if (current_user == DAT_00238044) {\n    _DAT_002409d4 = (uint)(DAT_00238048 != DAT_0023804c);\n  }\n  pcVar9 = getenv(\"POSIXLY_CORRECT\");\n  if ((pcVar9 != (char *)0x0) || (pcVar9 = getenv(\"POSIX_PEDANTIC\"), pcVar9 != (char *)0x0)) {\n    posixly_correct = 1;\n  }\n  iVar3 = __sigsetjmp(subshell_top_level,1);\n  local_168 = param_2;\n  local_15c = param_1;\n  local_150 = param_3;\n  if (iVar3 != 0) {\n    DAT_002409d8 = 0;\n    local_15c = subshell_argc;\n    local_168 = subshell_argv;\n    local_150 = subshell_envp;\n  }\n  local_130 = 1;\n  _DAT_002409b8 = 0;\n  if (local_15c < 1) {\n    local_130 = local_15c;\n  }\n  shell_script_filename = (char *)0x0;\n  command_execution_string = (char *)0x0;\n  DAT_002409b0 = stdin;\n  read_from_stdin = 0;\n  local_134 = 0;\n  want_pending_command = 0;\n  default_buffered_input = -1;\n  _DAT_002409c0 = 0;\n  login_shell = 0;\n  if ((shell_initialized != 0) || (shell_name != (char *)0x0)) {\n    if (*shell_name == '-') {\n      shell_name = shell_name + 1;\n    }\n    current_command_number = 1;\n    primary_prompt = s__s__v___001fa0db;\n    secondary_prompt = &DAT_001fa0e4;\n    _DAT_002409c8 = 1;\n    DAT_002409cc = 1;\n    executing = 0;\n    interactive = 0;\n    last_command_exit_value = 0;\n    line_number = 0;\n    _DAT_002409c4 = 0;\n    DAT_002409d0 = 0;\n    interactive_shell = 0;\n    forced_interactive = 0;\n    running_in_background = 0;\n    subshell_environment = 0;\n    expand_aliases = 0;\n    bash_argv_initialized = 0;\n    enable_history_list = 0;\n    bash_history_reinit(0);\n    restricted = 0;\n    PTR_s____bashrc_00238068 = s____bashrc_001fa0e7;\n    delete_all_contexts(shell_variables);\n    delete_all_variables(shell_functions);\n    reinit_special_variables();\n    bashline_reinitialize();\n    _DAT_002409b8 = 1;\n    iVar3 = __sigsetjmp(top_level,0);\n    if (iVar3 != 0) goto LAB_00131cfd;\n  }\n  shell_environment = local_150;\n  pcVar9 = *local_168;\n  if (pcVar9 == (char *)0x0) {\n    pcVar9 = \"bash\";\n  }\n  else {\n    shell_name = (char *)base_pathname(pcVar9);\n    if (*pcVar9 == '-') {\n      if (*shell_name == '-') {\n        shell_name = shell_name + 1;\n      }\n      login_shell = 1;\n    }\n    if (*shell_name == 's') {\n      if (shell_name[1] == 'h') {\n        if (shell_name[2] == '\\0') {\n          _DAT_002409e0 = _DAT_002409e0 + 1;\n        }\n      }\n      else if ((shell_name[1] == 'u') && (shell_name[2] == '\\0')) {\n        _DAT_002409dc = _DAT_002409dc + 1;\n      }\n    }\n  }\n  shell_name = pcVar9;\n  if (dollar_vars != (char *)0x0) {\n    sh_xfree(dollar_vars,\"shell.c\",0x715);\n  }\n  pcVar9 = shell_name;\n  sVar10 = strlen(shell_name);\n  pcVar11 = (char *)sh_xmalloc(sVar10 + 1,\"shell.c\",0x716);\n  dollar_vars = strcpy(pcVar11,pcVar9);\n  if (((shell_name == (char *)0x0) || (*shell_name == '\\0')) ||\n     ((*shell_name == '-' && (shell_name[1] == '\\0')))) {\n    shell_name = \"bash\";\n  }\n  gettimeofday((timeval *)&shellstart,(__timezone_ptr_t)0x0);\n  shell_start_time = shellstart;\n  for (local_160 = local_130; local_15c != local_160; local_160 = local_160 + 1) {\n    pcVar9 = local_168[local_160];\n    if ((pcVar9 == (char *)0x0) || (*pcVar9 != '-')) break;\n    cVar22 = pcVar9[1];\n    bVar26 = false;\n    pcVar11 = pcVar9;\n    if ((cVar22 == '-') && (pcVar9[2] != '\\0')) {\n      bVar26 = true;\n      pcVar11 = pcVar9 + 1;\n      cVar22 = pcVar9[2];\n    }\n    ppuVar25 = &PTR_s_debugger_00235d80;\n    cVar2 = 'd';\n    iVar3 = 0;\n    pcVar24 = \"debug\";\n    while ((cVar2 != cVar22 || (iVar5 = strcmp(pcVar11 + 1,pcVar24), iVar5 != 0))) {\n      pcVar24 = *ppuVar25;\n      ppuVar25 = ppuVar25 + 4;\n      iVar3 = iVar3 + 1;\n      if (pcVar24 == (char *)0x0) {\n        if (!bVar26) goto LAB_00132206;\n        report_error(\"%s: invalid option\",pcVar9);\n        FUN_001336b0(stderr,0);\n        goto LAB_00131cfd;\n      }\n      cVar2 = *pcVar24;\n    }\n    lVar21 = (long)iVar3;\n    if ((&DAT_00235d68)[lVar21 * 8] == 1) {\n      *(undefined4 *)(&PTR_DAT_00235d70)[lVar21 * 4] = 1;\n    }\n    else {\n      if (local_168[(long)local_160 + 1] == (char *)0x0) {\n        report_error(\"%s: option requires an argument\",pcVar24);\n        goto LAB_00131cfd;\n      }\n      *(char **)(&DAT_00235d78)[lVar21 * 4] = local_168[(long)local_160 + 1];\n      local_160 = local_160 + 1;\n    }\n  }\nLAB_00132206:\n  if (_DAT_002409bc != 0) {\n    FUN_001336b0(stdout,1);\nLAB_0013222e:\n                    /* WARNING: Subroutine does not return */\n    exit(0);\n  }\n  if (_DAT_002409c4 != 0) {\n    show_shell_version();\n    goto LAB_0013222e;\n  }\n  echo_input_at_read = verbose_flag;\n  this_command_name = shell_name;\nLAB_001322b6:\n  if ((local_15c != local_160) && (pcVar9 = local_168[local_160], pcVar9 != (char *)0x0)) {\n    iVar3 = (int)*pcVar9;\n    if ((iVar3 - 0x2bU & 0xfd) == 0) {\n      bVar1 = pcVar9[1];\n      local_160 = local_160 + 1;\n      if (*pcVar9 != '-') goto LAB_001322f5;\n      if (bVar1 != 0) {\n        if (bVar1 != 0x2d) goto LAB_001322f5;\n        if (pcVar9[2] != '\\0') {\n          uVar23 = 0x2d;\n          iVar3 = 0x2d;\n          goto LAB_001322fe;\n        }\n      }\n    }\n  }\n  if (_DAT_002409c0 != 0) {\n    login_shell = ~login_shell;\n  }\n  set_login_shell(\"login_shell\",login_shell != 0);\n  if (dump_po_strings == 0) {\n    if (dump_translatable_strings != 0) goto LAB_001324f2;\n  }\n  else {\n    dump_translatable_strings = 1;\nLAB_001324f2:\n    read_but_dont_execute = 1;\n  }\n  if ((_DAT_002409d4 != 0) && (privileged_mode == 0)) {\n    disable_priv_mode();\n  }\n  local_130 = local_160;\n  if (want_pending_command != 0) {\n    command_execution_string = local_168[local_160];\n    if (command_execution_string == (char *)0x0) {\n      report_error(\"%s: option requires an argument\",&DAT_001fa0a7);\n      goto LAB_00131cfd;\n    }\n    local_130 = local_160 + 1;\n  }\n  this_command_name = (char *)0x0;\n  if (forced_interactive == 0) {\n    if (((command_execution_string == (char *)0x0) && (wordexp_only == 0)) &&\n       ((local_130 == local_15c || (read_from_stdin != 0)))) {\n      iVar3 = fileno(stdin);\n      iVar3 = isatty(iVar3);\n      if (iVar3 != 0) {\n        iVar3 = fileno(stderr);\n        iVar3 = isatty(iVar3);\n        if (iVar3 != 0) goto LAB_001329e5;\n      }\n    }\n    FUN_00133640();\n    uVar23 = interactive_shell;\n    if (login_shell != 0) goto joined_r0x00132a3f;\n  }\n  else {\nLAB_001329e5:\n    startup_state = 1;\n    interactive_shell = 1;\n    expand_aliases = 1;\n    interactive = 1;\n    remember_on_history = enable_history_list;\n    histexp_flag = history_expansion;\n    uVar23 = login_shell;\n    if (enable_history_list == -1) {\n      enable_history_list = 1;\n      remember_on_history = enable_history_list;\n    }\njoined_r0x00132a3f:\n    if (uVar23 != 0) {\n      iVar3 = 3;\n      do {\n        fcntl(iVar3,2,1);\n        iVar3 = iVar3 + 1;\n      } while (iVar3 != 0x14);\n    }\n  }\n  if (posixly_correct != 0) {\n    bind_variable(\"POSIXLY_CORRECT\",\"y\",0);\n    sv_strict_posix(\"POSIXLY_CORRECT\");\n  }\n  lVar21 = 0;\n  if (DAT_002409a8 != 0) {\n    do {\n      if (DAT_002409a4 <= (int)lVar21) {\n        sh_xfree(DAT_002409a8,\"shell.c\",0x855);\n        DAT_002409a8 = 0;\n        DAT_002409a0 = 0;\n        DAT_002409a4 = 0;\n        goto LAB_00132606;\n      }\n      puVar13 = (undefined8 *)(lVar21 * 0x10 + DAT_002409a8);\n      lVar21 = lVar21 + 1;\n      iVar3 = shopt_setopt(*puVar13,*(int *)(puVar13 + 1) == 0x2d);\n    } while (iVar3 == 0);\nLAB_00131cfd:\n                    /* WARNING: Subroutine does not return */\n    exit(2);\n  }\nLAB_00132606:\n  FUN_00133d60();\n  set_default_lang();\n  set_default_locale_vars();\n  if (interactive_shell != 0) {\n    pcVar9 = (char *)get_string_value(\"TERM\");\n    pcVar11 = (char *)get_string_value(\"EMACS\");\n    pcVar24 = (char *)get_string_value(\"INSIDE_EMACS\");\n    if (pcVar24 == (char *)0x0) {\n      if (pcVar11 != (char *)0x0) {\n        uVar23 = 1;\n        pcVar24 = strstr(pcVar11,\" (term:\");\n        if ((pcVar24 != (char *)0x0) ||\n           ((*pcVar11 == 't' && (uVar23 = strcmp(pcVar11,\"t\"), uVar23 == 0)))) goto LAB_00133204;\n      }\n      uVar23 = no_line_editing;\n      if (*pcVar9 == 'e') {\n        iVar3 = strcmp(pcVar9,\"emacs\");\n        no_line_editing = uVar23 | iVar3 == 0;\n      }\n      if ((*pcVar9 != 'e') || (iVar3 = strncmp(pcVar9,\"emacs\",5), iVar3 != 0)) {\n        running_under_emacs = 0;\n        goto LAB_00132622;\n      }\n      running_under_emacs = 1;\n    }\n    else {\n      pcVar11 = strstr(pcVar24,\",term:\");\n      uVar23 = (uint)(pcVar11 != (char *)0x0);\nLAB_00133204:\n      uVar6 = no_line_editing;\n      if (*pcVar9 == 'e') {\n        iVar3 = strcmp(pcVar9,\"emacs\");\n        no_line_editing = uVar6 | iVar3 == 0;\n      }\n      uVar6 = no_line_editing;\n      no_line_editing = uVar6;\n      if ((*pcVar9 == 'd') && (iVar3 = strcmp(pcVar9,\"dumb\"), no_line_editing = uVar6, iVar3 == 0))\n      {\n        no_line_editing = uVar6 | 1;\n      }\n      running_under_emacs = 1;\n      if (((uVar23 != 0) && (*pcVar9 == 'e')) && (iVar3 = strncmp(pcVar9,\"eterm\",5), iVar3 == 0)) {\n        running_under_emacs = 2;\n      }\n    }\n    gnu_error_format = 1;\n  }\nLAB_00132622:\n  iVar3 = exit_immediately_on_error;\n  iVar5 = __sigsetjmp(top_level,1);\n  if (iVar5 != 0) {\n    if ((iVar5 - 3U < 2) || (iVar5 == 6)) goto LAB_001328bb;\n    set_job_control(interactive_shell);\n    exit_immediately_on_error = exit_immediately_on_error + iVar3;\n    local_134 = 1;\n  }\n  bVar26 = interactive_shell != 0;\n  if (bVar26) {\n    change_flag(0x69,0x2d);\n  }\n  else {\n    unbind_variable(&DAT_001fa152);\n    unbind_variable(&DAT_001fa156);\n  }\n  interactive = (uint)bVar26;\n  uVar7 = 1;\n  if (restricted == 0) {\n    uVar7 = FUN_00133b90();\n  }\n  uVar23 = restricted;\n  restricted = 0;\n  restricted_shell = uVar7;\n  if (wordexp_only == 0) {\n    if (command_execution_string == (char *)0x0) {\n      if ((local_130 == local_15c) || (read_from_stdin != 0)) {\n        FUN_00133930(local_168,local_130,local_15c,1);\n      }\n      else {\n        shell_script_filename = local_168[local_130];\n        FUN_00133930(local_168,local_130 + 1,local_15c,1);\n      }\n    }\n    else {\n      FUN_00133930(local_168,local_130,local_15c,0);\n    }\n  }\n  iVar3 = exit_immediately_on_error;\n  pcVar11 = exec_argv0;\n  pcVar9 = shell_script_filename;\n  if ((local_134 | _DAT_002409d4) == 0) {\n    exit_immediately_on_error = 0;\n    if (shell_script_filename != (char *)0x0) {\n      local_140 = dollar_vars;\n      if (exec_argv0 == (char *)0x0) {\n        sVar10 = strlen(shell_script_filename);\n        pcVar11 = (char *)sh_xmalloc(sVar10 + 1,\"shell.c\",0x2cb);\n        dollar_vars = strcpy(pcVar11,pcVar9);\n      }\n      else {\n        sVar10 = strlen(exec_argv0);\n        pcVar9 = (char *)sh_xmalloc(sVar10 + 1,\"shell.c\",0x2cb);\n        dollar_vars = strcpy(pcVar9,pcVar11);\n      }\n    }\n    uVar6 = interactive_shell;\n    if (interactive_shell == 0) {\n      uVar7 = 0;\n      if ((DAT_002409cc | login_shell | _DAT_002409e0) == 0) {\n        uVar20 = 0;\n        if (command_execution_string == (char *)0x0) goto LAB_00132b4b;\n        iVar5 = fileno(stdin);\n        iVar5 = isnetconn(iVar5);\n        if ((iVar5 == 0) || (1 < shell_level)) {\n          if (interactive_shell != 0) goto LAB_001327a0;\n          goto LAB_00132b0d;\n        }\n        maybe_execute_file(PTR_s____bashrc_00238068,1);\n      }\n      else {\nLAB_00132b0d:\n        uVar20 = uVar6;\n        if ((int)login_shell < 0) goto LAB_00132b18;\nLAB_00132b4b:\n        if ((_DAT_002409dc != 0) && (login_shell != 0)) {\n          if (posixly_correct == 0) goto LAB_001327d4;\n          goto LAB_00132800;\n        }\n        if (((posixly_correct | _DAT_002409e0 | privileged_mode) == 0) &&\n           (iVar5 = DAT_002409d8 + 1, bVar26 = DAT_002409d8 == 0, DAT_002409d8 = iVar5, bVar26)) {\n          uVar16 = get_string_value(\"BASH_ENV\");\n          FUN_00133b40(uVar16);\n        }\n      }\n    }\n    else {\nLAB_001327a0:\n      uVar7 = set_job_control(0);\n      uVar20 = 0;\n      if ((int)login_shell < 0) {\nLAB_00132b18:\n        if (posixly_correct == 0) {\n          DAT_002409cc = DAT_002409cc + 1;\n          if (_DAT_002409c8 == 0) {\n            maybe_execute_file(\"/etc/profile\",1);\n            if (_DAT_002409e0 == 0) {\n              uVar20 = 1;\n              iVar5 = maybe_execute_file(\"~/.bash_profile\",1);\n              if ((iVar5 == 0) && (iVar5 = maybe_execute_file(\"~/.bash_login\",1), iVar5 == 0)) {\n                maybe_execute_file(\"~/.profile\",1);\n              }\n            }\n            else {\n              uVar20 = 1;\n              maybe_execute_file(\"~/.profile\",1);\n            }\n            goto LAB_001327b9;\n          }\n          if (interactive_shell == 0) {\n            uVar20 = 1;\n            goto LAB_00132b4b;\n          }\n          goto LAB_001327e6;\n        }\n        uVar20 = interactive_shell;\n        if (interactive_shell == 0) goto LAB_00132b4b;\nLAB_00132c4e:\n        if ((privileged_mode == 0) &&\n           (iVar5 = DAT_002409d8 + 1, bVar26 = DAT_002409d8 == 0, DAT_002409d8 = iVar5, bVar26)) {\n          uVar16 = get_string_value(\"ENV\");\n          FUN_00133b40(uVar16);\n        }\n      }\n      else {\nLAB_001327b9:\n        if (interactive_shell == 0) goto LAB_00132b4b;\n        if (posixly_correct != 0) goto LAB_00132c4e;\nLAB_001327d4:\n        if ((((login_shell != 0) && ((uVar20 & 1) == 0)) &&\n            (DAT_002409cc = DAT_002409cc + 1, _DAT_002409c8 == 0)) &&\n           ((maybe_execute_file(\"/etc/profile\",1), _DAT_002409e0 != 0 ||\n            ((iVar5 = maybe_execute_file(\"~/.bash_profile\",1), iVar5 == 0 &&\n             (iVar5 = maybe_execute_file(\"~/.bash_login\",1), iVar5 == 0)))))) {\n          maybe_execute_file(\"~/.profile\",1);\n        }\nLAB_001327e6:\n        if (_DAT_002409e0 != 0) goto LAB_00132c4e;\n        if (DAT_002409cc == 0) {\n          maybe_execute_file(PTR_s____bashrc_00238068,1);\n        }\n      }\nLAB_00132800:\n      set_job_control(uVar7);\n    }\n    if (shell_script_filename != (char *)0x0) {\n      sh_xfree(dollar_vars,\"shell.c\",0x2d0);\n      dollar_vars = local_140;\n    }\n    exit_immediately_on_error = exit_immediately_on_error + iVar3;\n  }\n  if (_DAT_002409e0 != 0) {\n    bind_variable(\"POSIXLY_CORRECT\",\"y\",0);\n    sv_strict_posix(\"POSIXLY_CORRECT\");\n  }\n  restricted = (uint)((uVar23 | restricted) != 0);\n  if (_DAT_002409b8 == 0) {\n    maybe_make_restricted(shell_name);\n  }\n  cmd_init();\n  uwp_init();\n  pcVar9 = shell_script_filename;\n  if (command_execution_string != (char *)0x0) {\n    startup_state = 2;\n    if (debugging_mode != 0) {\n      FUN_00133ad0();\n    }\n    executing = 1;\n    FUN_00133f20(command_execution_string);\nLAB_001328bb:\n                    /* WARNING: Subroutine does not return */\n    exit_shell(last_command_exit_value);\n  }\n  if (shell_script_filename == (char *)0x0) {\n    if (interactive == 0) {\n      default_buffered_input = fileno(stdin);\n      read_from_stdin = 1;\n      goto LAB_00133052;\n    }\n    if (local_130 == local_15c) {\n      read_from_stdin = 1;\n    }\nLAB_0013313b:\n    iVar3 = fileno(stdin);\n    sh_unset_nodelay_mode(iVar3);\n  }\n  else {\n    sVar10 = strlen(shell_script_filename);\n    pcVar11 = (char *)sh_xmalloc(sVar10 + 1,\"shell.c\",0x629);\n    pcVar24 = strcpy(pcVar11,pcVar9);\n    iVar3 = open(pcVar24,0);\n    pcVar11 = pcVar24;\n    if (iVar3 < 0) {\n      piVar19 = __errno_location();\n      if (*piVar19 != 2) {\nLAB_00133197:\n        iVar3 = *piVar19;\n        file_error(pcVar11);\n        end_job_control();\n                    /* WARNING: Subroutine does not return */\n        exit((iVar3 == 2) + 0x7e);\n      }\n      iVar5 = absolute_program(pcVar24);\n      iVar3 = *piVar19;\n      if (iVar5 != 0) goto LAB_00133197;\n      pcVar11 = (char *)find_path_file(pcVar9);\n      if (pcVar11 == (char *)0x0) {\n        *piVar19 = iVar3;\n        pcVar11 = pcVar24;\n        goto LAB_00133197;\n      }\n      sh_xfree(pcVar24,\"shell.c\",0x634);\n      iVar3 = open(pcVar11,0);\n      if (iVar3 < 0) goto LAB_00133197;\n    }\n    sh_xfree(dollar_vars,\"shell.c\",0x646);\n    pcVar24 = exec_argv0;\n    if (exec_argv0 == (char *)0x0) {\n      sVar10 = strlen(pcVar9);\n      pcVar24 = (char *)sh_xmalloc(sVar10 + 1,\"shell.c\",0x647);\n      dollar_vars = strcpy(pcVar24,pcVar9);\n    }\n    else {\n      sVar10 = strlen(exec_argv0);\n      pcVar9 = (char *)sh_xmalloc(sVar10 + 1,\"shell.c\",0x647);\n      dollar_vars = strcpy(pcVar9,pcVar24);\n    }\n    if (exec_argv0 != (char *)0x0) {\n      sh_xfree(exec_argv0,\"shell.c\",0x64a);\n      exec_argv0 = (char *)0x0;\n    }\n    iVar5 = file_isdir(pcVar11);\n    if (iVar5 != 0) {\n      piVar19 = __errno_location();\n      *piVar19 = 0x15;\n      file_error(pcVar11);\nLAB_001333de:\n      end_job_control();\nLAB_001333e3:\n                    /* WARNING: Subroutine does not return */\n      exit(0x7e);\n    }\n    lVar21 = find_variable(\"FUNCNAME\");\n    if (lVar21 != 0) {\n      if ((*(byte *)(lVar21 + 0x28) & 4) == 0) {\n        lVar21 = 0;\n      }\n      else {\n        lVar21 = *(long *)(lVar21 + 8);\n      }\n    }\n    lVar14 = find_variable(\"BASH_SOURCE\");\n    if (lVar14 != 0) {\n      if ((*(byte *)(lVar14 + 0x28) & 4) == 0) {\n        lVar14 = 0;\n      }\n      else {\n        lVar14 = *(long *)(lVar14 + 8);\n      }\n    }\n    lVar15 = find_variable(\"BASH_LINENO\");\n    if (lVar15 != 0) {\n      if ((*(byte *)(lVar15 + 0x28) & 4) == 0) {\n        lVar15 = 0;\n      }\n      else {\n        lVar15 = *(long *)(lVar15 + 8);\n      }\n    }\n    array_rshift(lVar14,1,pcVar11);\n    if (lVar15 != 0) {\n      iVar5 = executing_line_number();\n      uVar16 = itos((long)iVar5);\n      array_rshift(lVar15,1,uVar16);\n      sh_xfree(uVar16,\"shell.c\",0x666);\n    }\n    array_rshift(lVar21,1,&DAT_001fa1b1);\n    iVar5 = isatty(iVar3);\n    if ((iVar5 == 0) && (_Var17 = lseek(iVar3,0,1), _Var17 != -1)) {\n      sVar18 = read(iVar3,local_98,0x50);\n      if ((int)sVar18 < 0) {\n        piVar19 = __errno_location();\n        iVar5 = *piVar19;\n        iVar3 = fstat(iVar3,&local_128);\n        if ((iVar3 == 0) && ((local_128.st_mode & 0xf000) == 0x4000)) {\n          *piVar19 = 0x15;\n          file_error(pcVar11);\n        }\n        else {\n          *piVar19 = iVar5;\n          file_error(pcVar11);\n        }\n        goto LAB_001333de;\n      }\n      if (((int)sVar18 != 0) && (iVar8 = check_binary_file(local_98), iVar8 != 0)) {\n        internal_error(\"%s: cannot execute binary file\",pcVar11);\n        end_job_control();\n        goto LAB_001333e3;\n      }\n      lseek(iVar3,0,0);\n    }\n    iVar3 = move_to_high_fd(iVar3,1,0xffffffff);\n    default_buffered_input = iVar3;\n    fcntl(iVar3,2,1);\n    if (interactive_shell == 0) {\n      if ((forced_interactive != 0) && (iVar5 == 0)) {\nLAB_0013341a:\n        if (enable_history_list == -1) {\n          enable_history_list = 1;\n        }\n        FUN_00133640();\n        remember_on_history = enable_history_list;\n        startup_state = 1;\n        interactive_shell = 1;\n        expand_aliases = 1;\n      }\n    }\n    else if (iVar5 == 0) {\n      if (forced_interactive != 0) goto LAB_0013341a;\n    }\n    else {\n      dup2(iVar3,0);\n      close(iVar3);\n      default_buffered_input = 0;\n    }\n    sh_xfree(pcVar11,\"shell.c\",0x6c4);\n    reading_shell_script = 1;\nLAB_00133052:\n    if (interactive != 0) goto LAB_0013313b;\n    sh_unset_nodelay_mode(default_buffered_input);\n  }\n  if (interactive == 0) {\n    with_input_from_buffered_stream(default_buffered_input,dollar_vars);\n  }\n  else if (no_line_editing == 0) {\n    with_input_from_stdin();\n  }\n  else {\n    with_input_from_stream(DAT_002409b0,dollar_vars);\n  }\n  if ((debugging_mode == 0) || ((local_134 | _DAT_002409d4) != 0)) {\nLAB_001330b5:\n    if (interactive_shell == 0) goto LAB_001330c2;\n  }\n  else if ((reading_shell_script != 0) || (interactive_shell == 0)) {\n    FUN_00133ad0();\n    goto LAB_001330b5;\n  }\n  reset_mail_timer();\n  init_mail_dates();\n  bash_initialize_history();\n  if ((shell_initialized | history_lines_this_session) == 0) {\n    load_history();\n  }\n  get_tty_state();\nLAB_001330c2:\n  shell_initialized = 1;\n  if (pretty_print_mode != 0) {\n    if (interactive_shell == 0) {\n      uVar7 = pretty_print_loop();\n                    /* WARNING: Subroutine does not return */\n      exit_shell(uVar7);\n    }\n    internal_warning(\"pretty-printing mode ignored in interactive shells\");\n    pretty_print_mode = 0;\n  }\n  reader_loop();\n                    /* WARNING: Subroutine does not return */\n  exit_shell(last_command_exit_value);\nLAB_001322f5:\n  uVar23 = (uint)(char)bVar1;\n  if (bVar1 != 0) {\nLAB_001322fe:\n    pcVar9 = pcVar9 + 2;\n    uVar6 = (uint)bVar1;\n    do {\n      switch(uVar6 - 0x44 & 0xff) {\n      case 0:\n        dump_translatable_strings = 1;\n        break;\n      default:\n        iVar5 = change_flag(uVar23,iVar3);\n        if (iVar5 == -1) {\n          report_error(\"%c%c: invalid option\",iVar3,uVar23);\n          FUN_001336b0(stderr,0);\n          goto LAB_00131cfd;\n        }\n        break;\n      case 0xb:\n        pcVar11 = local_168[local_160];\n        if (pcVar11 == (char *)0x0) {\n          shopt_listopt(0,iVar3 != 0x2d);\n        }\n        else {\n          if (DAT_002409a0 <= DAT_002409a4) {\n            DAT_002409a0 = DAT_002409a0 + 8;\n            DAT_002409a8 = sh_xrealloc(DAT_002409a8,(long)DAT_002409a0 << 4,\"shell.c\");\n          }\n          lVar21 = (long)DAT_002409a4;\n          DAT_002409a4 = DAT_002409a4 + 1;\n          ppcVar12 = (char **)(lVar21 * 0x10 + DAT_002409a8);\n          *ppcVar12 = pcVar11;\n          *(int *)(ppcVar12 + 1) = iVar3;\nLAB_001323c8:\n          local_160 = local_160 + 1;\n        }\n        break;\n      case 0x1f:\n        want_pending_command = 1;\n        break;\n      case 0x28:\n        _DAT_002409c0 = 1;\n        break;\n      case 0x2b:\n        if (local_168[local_160] != (char *)0x0) {\n          iVar5 = set_minus_o_option();\n          if (iVar5 == 0) goto LAB_001323c8;\n          goto LAB_00131cfd;\n        }\n        enable_history_list = 0;\n        list_minus_o_opts(0xffffffff,iVar3 != 0x2d);\n        enable_history_list = -1;\n        break;\n      case 0x2f:\n        read_from_stdin = 1;\n      }\n      cVar22 = *pcVar9;\n      uVar23 = (uint)cVar22;\n      pcVar9 = pcVar9 + 1;\n      uVar6 = uVar23;\n    } while (cVar22 != '\\0');\n  }\n  goto LAB_001322b6;\n}\n\n",
  "ifs_firstchar": "\nchar * ifs_firstchar(uint *param_1)\n\n{\n  char cVar1;\n  uint uVar2;\n  char *__dest;\n  \n  __dest = (char *)sh_xmalloc(0x11,\"subst.c\",0xb30);\n  cVar1 = ifs_firstc;\n  if (ifs_firstc_len == 1) {\n    __dest[1] = '\\0';\n    *__dest = cVar1;\n    uVar2 = (uint)(cVar1 != '\\0');\n  }\n  else {\n    __dest = (char *)memcpy(__dest,&ifs_firstc,ifs_firstc_len);\n    uVar2 = (uint)ifs_firstc_len;\n    __dest[(int)uVar2] = '\\0';\n  }\n  if (param_1 != (uint *)0x0) {\n    *param_1 = uVar2;\n  }\n  return __dest;\n}\n\n",
  "FUN_00190000": "\nundefined2 * FUN_00190000(long *param_1,int param_2,int param_3,int param_4)\n\n{\n  char **ppcVar1;\n  char cVar2;\n  char cVar3;\n  undefined2 *puVar4;\n  size_t sVar5;\n  ulong uVar6;\n  char *pcVar7;\n  char *pcVar8;\n  undefined2 *puVar9;\n  long lVar10;\n  int iVar11;\n  ulong uVar12;\n  int iVar13;\n  ulong uVar14;\n  int iVar15;\n  int local_70;\n  int local_68;\n  int local_3c;\n  \n  if (param_2 == param_3) {\n    if (param_1[param_2] == 0) {\n      lVar10 = *param_1;\n    }\n    else {\n      lVar10 = param_1[param_2] + (long)param_4;\n    }\n    puVar4 = (undefined2 *)sh_backslash_quote(lVar10,0,0);\n    return puVar4;\n  }\n  puVar4 = (undefined2 *)sh_xmalloc(0x10,\"bracecomp.c\",0x53);\n  *(undefined *)puVar4 = 0;\n  if (param_2 < param_3) {\n    local_3c = 0;\n    local_70 = 0x10;\n    local_68 = param_2;\n    do {\n      ppcVar1 = (char **)(param_1 + local_68);\n      pcVar7 = *ppcVar1;\n      sVar5 = strlen(pcVar7);\n      iVar11 = local_68 + 1;\n      if (iVar11 < param_3) {\n        lVar10 = (long)iVar11;\n        uVar12 = sVar5 & 0xffffffff;\n        do {\n          iVar15 = (int)lVar10;\n          uVar14 = 0;\n          if (param_1[lVar10] != 0) {\n            uVar6 = 0;\n            cVar2 = *pcVar7;\n            while (cVar2 != '\\0') {\n              cVar3 = *(char *)(param_1[lVar10] + uVar6);\n              iVar11 = (int)uVar6;\n              uVar14 = uVar6 & 0xffffffff;\n              if ((cVar3 != cVar2) || (cVar3 == '\\0')) break;\n              uVar6 = uVar6 + 1;\n              uVar14 = (ulong)(iVar11 + 1);\n              cVar2 = pcVar7[uVar6];\n            }\n          }\n          iVar13 = (int)uVar14;\n          if (iVar13 <= param_4) {\n            iVar13 = (int)uVar12;\n            iVar11 = iVar15;\n            iVar15 = iVar15 + -1;\n            break;\n          }\n          lVar10 = lVar10 + 1;\n          uVar12 = uVar14;\n          iVar11 = iVar15 + 1;\n        } while ((int)lVar10 < param_3);\n      }\n      else {\n        iVar13 = (int)sVar5;\n        iVar15 = local_68;\n      }\n      if ((param_4 == 0 && param_2 == local_68) && (param_3 != iVar11)) {\n        local_70 = local_70 + 1;\n        puVar4 = (undefined2 *)sh_xrealloc(puVar4,(long)local_70,\"bracecomp.c\",0x6b);\n        local_3c = local_3c + 1;\n        *puVar4 = 0x7b;\n      }\n      if (local_68 == iVar15) {\n        pcVar7 = *ppcVar1;\n        sVar5 = strlen(pcVar7 + param_4);\n        pcVar8 = (char *)sh_xmalloc(sVar5 + 1,\"bracecomp.c\",0x75);\n        pcVar8 = strcpy(pcVar8,pcVar7 + param_4);\n        pcVar7 = (char *)sh_backslash_quote(pcVar8,0,0);\n        sh_xfree(pcVar8,\"bracecomp.c\",0x77);\n      }\n      else {\n        iVar15 = iVar13 - param_4;\n        pcVar7 = (char *)sh_xmalloc((long)(iVar15 + 1),\"bracecomp.c\",0x7e);\n        pcVar7 = strncpy(pcVar7,*ppcVar1 + param_4,(long)iVar15);\n        pcVar7[iVar15] = '\\0';\n        pcVar8 = (char *)sh_backslash_quote(pcVar7,0,0);\n        sh_xfree(pcVar7,\"bracecomp.c\",0x82);\n        sVar5 = strlen(pcVar8);\n        local_70 = local_70 + 1 + (int)sVar5;\n        puVar4 = (undefined2 *)sh_xrealloc(puVar4,(long)local_70,\"bracecomp.c\",0x84);\n        strcat((char *)puVar4,pcVar8);\n        sh_xfree(pcVar8,\"bracecomp.c\",0x86);\n        sVar5 = strlen((char *)puVar4);\n        *(undefined2 *)((long)puVar4 + sVar5) = 0x7b;\n        pcVar7 = (char *)FUN_00190000(param_1,local_68,iVar11,iVar13);\n        sVar5 = strlen(pcVar7);\n        pcVar7[sVar5 - 1] = '}';\n      }\n      sVar5 = strlen(pcVar7);\n      local_70 = local_70 + 1 + (int)sVar5;\n      puVar4 = (undefined2 *)sh_xrealloc(puVar4,(long)local_70,\"bracecomp.c\",0x8d);\n      sVar5 = strlen((char *)puVar4);\n      puVar9 = (undefined2 *)stpcpy((char *)((long)puVar4 + sVar5),pcVar7);\n      *puVar9 = 0x2c;\n      sh_xfree(pcVar7,\"bracecomp.c\",0x90);\n      local_68 = iVar11;\n    } while (iVar11 < param_3);\n    if (param_4 != 0) {\n      return puVar4;\n    }\n    if (local_3c != 0) {\n      sVar5 = strlen((char *)puVar4);\n      *(undefined *)((long)puVar4 + (sVar5 - 1)) = 0x7d;\n      return puVar4;\n    }\n  }\n  else if (param_4 != 0) {\n    return puVar4;\n  }\n  sVar5 = strlen((char *)puVar4);\n  *(undefined *)((long)puVar4 + (sVar5 - 1)) = 0;\n  return puVar4;\n}\n\n",
  "FUN_001951e0": "\nvoid FUN_001951e0(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined4 uVar4;\n  \n  uVar4 = rl_completion_mode(FUN_001951e0);\n  uVar3 = rl_completion_entry_function;\n  uVar2 = rl_attempted_completion_function;\n  uVar1 = rl_ignore_some_completions_function;\n  rl_attempted_completion_function = 0;\n  rl_completion_entry_function = FUN_00192980;\n  rl_complete_internal(uVar4);\n  rl_completion_entry_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar2;\n  rl_ignore_some_completions_function = uVar1;\n  return;\n}\n\n",
  "sh_cfree": "\nvoid sh_cfree(void)\n\n{\n  FUN_001f8ee0();\n  return;\n}\n\n",
  "named_function_string": "\nchar * named_function_string(char *param_1,undefined8 param_2,ulong param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int *piVar5;\n  char *pcVar6;\n  size_t sVar7;\n  undefined *puVar8;\n  \n  iVar3 = DAT_00241f34;\n  iVar2 = DAT_00238404;\n  DAT_00241f28 = 0;\n  command_string_index = 0;\n  DAT_00241f18 = 0;\n  DAT_00241f20 = 0;\n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    iVar4 = find_reserved_word();\n    if (-1 < iVar4) {\n      FUN_001446d0(\"function \");\n    }\n    FUN_001446d0(&DAT_002111d0,param_1);\n  }\n  FUN_001446d0(&DAT_001fc7cc);\n  if ((param_3 & 1) == 0) {\n    puVar8 = &DAT_001fc7a1;\n    DAT_00241f34 = 1;\n    DAT_00238404 = 0;\n  }\n  else {\n    FUN_001446d0(&DAT_001ff6d2);\n    DAT_00241f34 = DAT_00241f34 + DAT_00238404;\n    puVar8 = &DAT_001fc79a;\n  }\n  DAT_00241f30 = DAT_00241f30 + 1;\n  FUN_001446d0(puVar8);\n  piVar5 = (int *)copy_command(param_2);\n  if (*piVar5 == 9) {\n    lVar1 = *(long *)(piVar5 + 4);\n    *(undefined8 *)(piVar5 + 4) = 0;\n    FUN_00146230(*(undefined8 *)(*(long *)(piVar5 + 6) + 8));\n    if (DAT_00241f18 != 0) {\n      FUN_001452c0(&DAT_00213d70);\n    }\n    DAT_00241f30 = DAT_00241f30 + -1;\n    if (lVar1 != 0) {\n      DAT_00238404 = iVar2;\n      DAT_00241f34 = iVar3;\n      FUN_001446d0(&DAT_001ff6d2);\n      FUN_001449a0(DAT_00241f34);\n      FUN_001446d0(&DAT_002102da,&DAT_001fc79e);\n      FUN_00144c70(lVar1);\n      *(long *)(piVar5 + 4) = lVar1;\n      goto LAB_001473b5;\n    }\n  }\n  else {\n    FUN_00146230(piVar5);\n    if (DAT_00241f18 != 0) {\n      FUN_001452c0(&DAT_00213d70);\n    }\n    DAT_00241f30 = DAT_00241f30 + -1;\n  }\n  DAT_00238404 = iVar2;\n  DAT_00241f34 = iVar3;\n  FUN_001446d0(&DAT_001ff6d2);\n  FUN_001449a0(DAT_00241f34);\n  FUN_001446d0(&DAT_002102da,&DAT_0020ef45);\nLAB_001473b5:\n  pcVar6 = the_printed_command;\n  if (((param_3 & 1) == 0) && (the_printed_command[2] == '\\n')) {\n    sVar7 = strlen(the_printed_command);\n    memmove(pcVar6 + 2,pcVar6 + 3,sVar7 - 2);\n  }\n  dispose_command(piVar5);\n  if ((param_3 & 2) == 0) {\n    return pcVar6;\n  }\n  pcVar6 = (char *)remove_quoted_escapes(pcVar6);\n  return pcVar6;\n}\n\n",
  "hangup_all_jobs": "\nvoid hangup_all_jobs(void)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  if (0 < DAT_0023877c) {\n    lVar2 = 0;\n    do {\n      lVar1 = *(long *)(jobs + lVar2 * 8);\n      if ((lVar1 != 0) && ((*(byte *)(lVar1 + 0x18) & 8) == 0)) {\n        killpg(*(__pid_t *)(lVar1 + 0x10),1);\n        lVar1 = *(long *)(jobs + lVar2 * 8);\n        if (*(int *)(lVar1 + 0x14) == 2) {\n          killpg(*(__pid_t *)(lVar1 + 0x10),0x12);\n        }\n      }\n      lVar2 = lVar2 + 1;\n    } while ((int)lVar2 < DAT_0023877c);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_0015f990": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0015f990(int param_1,uint param_2)\n\n{\n  uint uVar1;\n  long *plVar2;\n  bool bVar3;\n  int iVar4;\n  uint uVar5;\n  long *plVar6;\n  long *plVar7;\n  int iVar8;\n  undefined8 *puVar9;\n  \n  puVar9 = (undefined8 *)jobs[param_1];\n  if (((param_2 & 1) == 0) || (subshell_environment != 0)) {\nLAB_0015f9c5:\n    puVar9 = (undefined8 *)jobs[param_1];\n    if (puVar9 == (undefined8 *)0x0) {\n      return;\n    }\n  }\n  else if (*(int *)((long)puVar9 + 0x14) == 2) {\n    internal_warning(\"deleting stopped job %d with process group %ld\",param_1 + 1,\n                     (long)*(int *)(puVar9 + 2));\n    goto LAB_0015f9c5;\n  }\n  if (((param_2 & 2) == 0) && ((*(uint *)(puVar9 + 3) & 0x21) == 0x20)) {\n    plVar7 = (long *)puVar9[1];\n    do {\n      plVar6 = plVar7;\n      if (plVar6 == (long *)0x0) goto LAB_0015f9db;\n      plVar7 = (long *)*plVar6;\n    } while ((long *)puVar9[1] != (long *)*plVar6);\n    uVar1 = *(uint *)((long)plVar6 + 0xc);\n    if ((char)(((byte)uVar1 & 0x7f) + 1) < '\\x02') {\n      uVar5 = 0;\n      if ((byte)uVar1 != 0x7f) {\n        uVar5 = uVar1 >> 8 & 0xff;\n      }\n    }\n    else {\n      uVar5 = (uVar1 & 0x7f) + 0x80;\n    }\n    FUN_0015ed20(*(undefined4 *)(plVar6 + 1),uVar5);\n  }\nLAB_0015f9db:\n  jobs[param_1] = 0;\n  if (_DAT_00238798 == puVar9) {\n    _DAT_00238798 = (undefined8 *)0x0;\n  }\n  else if (_DAT_002387a0 == puVar9) {\n    _DAT_002387a0 = (undefined8 *)0x0;\n  }\n  iVar8 = 0;\n  sh_xfree(*puVar9,\"jobs.c\",0x587);\n  plVar7 = (long *)puVar9[1];\n  plVar6 = plVar7;\n  do {\n    plVar2 = (long *)*plVar6;\n    if (plVar6[3] != 0) {\n      sh_xfree(plVar6[3],\"jobs.c\",0x5c2);\n    }\n    iVar8 = iVar8 + 1;\n    sh_xfree(plVar6,\"jobs.c\",0x5c3);\n    plVar6 = plVar2;\n  } while (plVar7 != plVar2);\n  _DAT_00238770 = _DAT_00238770 - iVar8;\n  if (*(int *)((long)puVar9 + 0x14) == 4) {\n    _DAT_0023878c = _DAT_0023878c + -1;\n    _DAT_0023876c = _DAT_0023876c - iVar8;\n    if (_DAT_0023876c < 0) {\n      _DAT_0023876c = 0;\n    }\n  }\n  if (puVar9[4] != 0) {\n    dispose_command();\n  }\n  sh_xfree(puVar9,\"jobs.c\",0x59b);\n  DAT_00238788 = DAT_00238788 + -1;\n  if (DAT_00238788 == 0) {\n    _DAT_00238780 = 0;\n    goto LAB_0015fad8;\n  }\n  iVar8 = _DAT_00238784;\n  if (jobs[_DAT_00238784] == 0) {\n    iVar4 = _DAT_00238784 + 1;\n    _DAT_00238780 = CONCAT44(iVar4,DAT_00238780);\n    if (DAT_0023877c <= iVar8) {\n      iVar8 = DAT_0023877c + -1;\n    }\n    bVar3 = false;\n    for (; iVar4 != iVar8; iVar4 = iVar4 + 1) {\n      if (iVar4 < DAT_0023877c) {\n        plVar7 = jobs + iVar4;\n      }\n      else {\n        bVar3 = true;\n        iVar4 = 0;\n        plVar7 = jobs;\n      }\n      if ((*plVar7 != 0) || (iVar8 == iVar4)) {\n        if ((!bVar3) || (_DAT_00238780 = CONCAT44(iVar4,DAT_00238780), iVar8 != iVar4))\n        goto LAB_0015fac3;\n        break;\n      }\n      bVar3 = true;\n    }\n    _DAT_00238780 = 0;\n    DAT_00238788 = 0;\n    if (*jobs != 0) goto LAB_0015fad8;\n    _DAT_00238780 = 0xffffffff;\n    iVar4 = 0;\n    iVar8 = -1;\nLAB_0015fbca:\n    bVar3 = false;\n    do {\n      if (iVar8 < 0) {\n        bVar3 = true;\n        iVar8 = DAT_0023877c + -1;\n      }\n      if ((jobs[iVar8] != 0) || (iVar8 == iVar4)) {\n        if (!bVar3) goto LAB_0015fad8;\n        _DAT_00238780 = CONCAT44(_DAT_00238784,iVar8);\n        if (iVar8 != iVar4) goto LAB_0015fad8;\n        break;\n      }\n      iVar8 = iVar8 + -1;\n      bVar3 = true;\n    } while (iVar8 != iVar4);\n  }\n  else {\nLAB_0015fac3:\n    if (jobs[DAT_00238780] != 0) goto LAB_0015fad8;\n    iVar8 = DAT_00238780 + -1;\n    iVar4 = DAT_00238780;\n    if (DAT_00238780 < 0) {\n      iVar4 = 0;\n    }\n    _DAT_00238780 = CONCAT44(_DAT_00238784,iVar8);\n    if (iVar8 != iVar4) goto LAB_0015fbca;\n  }\n  _DAT_00238780 = 0;\n  DAT_00238788 = 0;\nLAB_0015fad8:\n  if ((param_1 != DAT_00238790) && (param_1 != DAT_00238794)) {\n    return;\n  }\n  FUN_0015e940();\n  return;\n}\n\n",
  "_rl_vi_motion_command": "\nuint _rl_vi_motion_command(uint param_1)\n\n{\n  char *pcVar1;\n  \n  if (param_1 != 0) {\n    pcVar1 = strchr(\" hl^$0ftFT;,%wbeWBE|`\",param_1);\n    return (uint)(pcVar1 != (char *)0x0);\n  }\n  return param_1;\n}\n\n",
  "__mbsrtowcs_chk": "\nvoid __mbsrtowcs_chk(void)\n\n{\n  (*(code *)PTR___mbsrtowcs_chk_00237910)();\n  return;\n}\n\n",
  "FUN_0015d330": "\nvoid FUN_0015d330(void)\n\n{\n  byte bVar1;\n  ushort uVar2;\n  ushort *puVar3;\n  undefined8 uVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  ushort **ppuVar9;\n  size_t sVar10;\n  char *pcVar11;\n  char *pcVar12;\n  long lVar13;\n  ulong uVar14;\n  byte *pbVar15;\n  ulong uVar16;\n  ulong uVar17;\n  uint uVar18;\n  byte *pbVar19;\n  ulong uVar20;\n  byte *pbVar21;\n  byte bVar22;\n  long in_FS_OFFSET;\n  bool bVar23;\n  int local_a8;\n  undefined local_68 [8];\n  undefined8 local_60;\n  long local_40;\n  \n  iVar7 = DAT_00242448;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00242458 == (byte *)0x0) {\nLAB_0015d380:\n    DAT_00242448 = 0;\n    DAT_00242444 = iVar7;\n    pbVar21 = DAT_00242458;\n    iVar7 = DAT_00242444;\n    uVar18 = DAT_00242448;\n    goto LAB_0015d396;\n  }\n  do {\n    pbVar15 = DAT_00242458;\n    bVar22 = *pbVar15;\n    uVar20 = (ulong)(uint)bVar22;\n    DAT_00242458 = pbVar15;\n    if (bVar22 == 0) goto LAB_0015d380;\n    pbVar19 = pbVar15 + 1;\n    DAT_00242458 = pbVar19;\n  } while (((byte)(bVar22 - 9) < 2) || (bVar22 == 0x20));\n  DAT_00242450 = pbVar15;\n  DAT_00242458 = pbVar15;\n  ppuVar9 = __ctype_b_loc();\n  puVar3 = *ppuVar9;\n  uVar2 = puVar3[bVar22];\n  if ((uVar2 & 0x400) == 0) {\n    if (bVar22 == 0x5f) goto LAB_0015d520;\n    pbVar21 = pbVar19;\n    if (9 < (byte)(bVar22 - 0x30)) {\n      bVar1 = pbVar15[1];\n      pbVar21 = pbVar15 + 2;\n      bVar23 = bVar1 != 0x3d;\n      if (((((bVar22 != 0x3d) || (iVar7 = DAT_00242448, uVar18 = 1, bVar23)) &&\n           ((bVar22 != 0x21 || (iVar7 = DAT_00242448, uVar18 = 2, bVar23)))) &&\n          ((bVar23 || (iVar7 = DAT_00242448, uVar18 = 4, bVar22 != 0x3e)))) &&\n         ((bVar23 || (iVar7 = DAT_00242448, uVar18 = 3, bVar22 != 0x3c)))) {\n        if ((bVar1 != 0x3c) || (bVar22 != 0x3c)) {\n          if ((bVar1 != 0x3e) || (bVar22 != 0x3e)) {\n            if ((bVar22 != 0x26) || (iVar7 = DAT_00242448, uVar18 = 7, bVar1 != 0x26)) {\n              if ((bVar22 == 0x7c) && (bVar1 == 0x7c)) {\n                iVar7 = DAT_00242448;\n                uVar18 = 8;\n              }\n              else if ((bVar22 == 0x2a) && (bVar1 == 0x2a)) {\n                iVar7 = DAT_00242448;\n                uVar18 = 0xd;\n              }\n              else if (((bVar22 - 0x2b & 0xfd) == 0) && (bVar22 == bVar1)) {\n                if (DAT_00242448 == 5) {\n                  iVar7 = DAT_00242448;\n                  uVar18 = (bVar22 == 0x2d) + 0x10;\n                }\n                else {\n                  pbVar15 = pbVar21;\n                  if ((DAT_00242448 == 6) && (DAT_00242444 - 0xeU < 2)) {\n                    if (bVar22 == 0x2d) {\n                    /* WARNING: Subroutine does not return */\n                      FUN_0015bcf0(\"--: assignment requires lvalue\");\n                    }\n                    /* WARNING: Subroutine does not return */\n                    FUN_0015bcf0(\"++: assignment requires lvalue\");\n                  }\n                  for (; bVar1 = *pbVar15, bVar1 != 0; pbVar15 = pbVar15 + 1) {\n                    if ((1 < (byte)(bVar1 - 9)) && (bVar1 != 0x20)) {\n                      if (((*(byte *)((long)puVar3 + (ulong)bVar1 * 2 + 1) & 4) != 0) ||\n                         (bVar1 == 0x5f)) goto LAB_0015de25;\n                      goto LAB_0015ddec;\n                    }\n                  }\n                  if ((*puVar3 & 0x400) == 0) {\nLAB_0015ddec:\n                    pbVar21 = pbVar19;\n                    iVar7 = DAT_00242448;\n                    uVar18 = (uint)bVar22;\n                  }\n                  else {\nLAB_0015de25:\n                    iVar7 = DAT_00242448;\n                    uVar18 = (bVar22 == 0x2d) + 0xe;\n                  }\n                }\n              }\n              else {\n                if (bVar1 == 0x3d) {\n                  lVar13 = mbschr(\"*/%+-&^|\",bVar22);\n                  if (lVar13 != 0) {\n                    DAT_00242440 = (uint)bVar22;\n                    iVar7 = DAT_00242448;\n                    uVar18 = 0xb;\n                    goto LAB_0015d396;\n                  }\n                }\n                iVar8 = FUN_0015bbc0(bVar22);\n                pbVar21 = pbVar19;\n                iVar7 = DAT_00242448;\n                uVar18 = (uint)bVar22;\n                if (iVar8 == 0) {\n                  if ((DAT_00242448 != 0) &&\n                     (iVar7 = DAT_00242448, iVar8 = FUN_0015bbc0(DAT_00242448), iVar8 == 0)) {\n                    if (iVar7 < 5) {\n                      if (iVar7 < 1) {\nLAB_0015dda7:\n                    /* WARNING: Subroutine does not return */\n                        FUN_0015bcf0(\"syntax error: invalid arithmetic operator\");\n                      }\n                    }\n                    else if (10 < iVar7 - 7U) goto LAB_0015dda7;\n                  }\n                    /* WARNING: Subroutine does not return */\n                  FUN_0015bcf0(\"syntax error: operand expected\");\n                }\n              }\n            }\n          }\n          else {\n            iVar7 = DAT_00242448;\n            uVar18 = 10;\n            if (pbVar15[2] == 0x3d) {\n              DAT_00242440 = 10;\n              pbVar21 = pbVar15 + 3;\n              iVar7 = DAT_00242448;\n              uVar18 = 0xb;\n            }\n          }\n        }\n        else {\n          iVar7 = DAT_00242448;\n          uVar18 = 9;\n          if (pbVar15[2] == 0x3d) {\n            DAT_00242440 = 9;\n            pbVar21 = pbVar15 + 3;\n            iVar7 = DAT_00242448;\n            uVar18 = 0xb;\n          }\n        }\n      }\n      goto LAB_0015d396;\n    }\n    while (((uVar2 & 8) != 0 ||\n           ((uVar18 = (int)uVar20 - 0x23, (byte)uVar18 < 0x3d &&\n            ((0x1000000020000001U >> ((ulong)uVar18 & 0x3f) & 1) != 0))))) {\n      uVar20 = (ulong)*pbVar21;\n      uVar2 = puVar3[uVar20];\n      pbVar21 = pbVar21 + 1;\n    }\n    bVar22 = pbVar21[-1];\n    pbVar21[-1] = 0;\n    bVar23 = false;\n    bVar1 = *pbVar15;\n    uVar20 = 10;\n    if (bVar1 == 0x30) {\n      bVar1 = pbVar15[1];\n      if (bVar1 != 0) {\n        if ((bVar1 & 0xdf) == 0x58) {\n          bVar1 = pbVar15[2];\n          pbVar19 = pbVar15 + 3;\n          bVar23 = true;\n          uVar20 = 0x10;\n          goto LAB_0015d44b;\n        }\n        pbVar19 = pbVar15 + 2;\n        uVar20 = 8;\n        bVar23 = true;\n        goto LAB_0015d453;\n      }\nLAB_0015dc1c:\n      uVar16 = 0;\n    }\n    else {\nLAB_0015d44b:\n      if (bVar1 == 0) goto LAB_0015dc1c;\nLAB_0015d453:\n      uVar16 = 0;\n      do {\n        uVar14 = (ulong)bVar1;\n        if (bVar1 == 0x23) {\n          if (bVar23) {\n                    /* WARNING: Subroutine does not return */\n            FUN_0015bcf0(\"invalid number\");\n          }\n          if (0x3e < uVar16 - 2) {\n                    /* WARNING: Subroutine does not return */\n            FUN_0015bcf0(\"invalid arithmetic base\");\n          }\n          bVar1 = *pbVar19;\n          uVar20 = uVar16 & 0xffffffff;\n          if (((*(byte *)(*ppuVar9 + bVar1) & 8) == 0) && (bVar1 != 0x5f && bVar1 != 0x40)) {\n                    /* WARNING: Subroutine does not return */\n            FUN_0015bcf0(\"invalid integer constant\");\n          }\n          uVar16 = 0;\n          bVar23 = true;\n        }\n        else {\n          if ((((*(byte *)(*ppuVar9 + uVar14) & 8) == 0) && (bVar1 != 0x5f)) && (bVar1 != 0x40))\n          break;\n          uVar18 = bVar1 - 0x30;\n          iVar7 = (int)uVar20;\n          if ((byte)uVar18 < 10) {\nLAB_0015d49f:\n            uVar14 = (ulong)uVar18;\n            uVar17 = uVar14 & 0xff;\n          }\n          else {\n            if ((byte)(bVar1 + 0x9f) < 0x1a) {\n              uVar18 = bVar1 - 0x57;\n              goto LAB_0015d49f;\n            }\n            if ((byte)(bVar1 + 0xbf) < 0x1a) {\n              iVar8 = 0x1d;\n              if (iVar7 < 0x25) {\n                iVar8 = 0x37;\n              }\n              uVar14 = (ulong)((uint)bVar1 - iVar8 & 0xff);\n              uVar17 = uVar14;\n            }\n            else if (bVar1 == 0x40) {\n              uVar14 = 0x3e;\n              uVar17 = 0x3e;\n            }\n            else {\n              uVar17 = uVar14;\n              if (bVar1 == 0x5f) {\n                uVar14 = 0x3f;\n                uVar17 = 0x3f;\n              }\n            }\n          }\n          if (iVar7 <= (int)uVar17) {\n                    /* WARNING: Subroutine does not return */\n            FUN_0015bcf0(\"value too great for base\");\n          }\n          uVar16 = (uVar14 & 0xff) + (long)iVar7 * uVar16;\n        }\n        bVar1 = *pbVar19;\n        pbVar19 = pbVar19 + 1;\n      } while (bVar1 != 0);\n    }\n    DAT_00242430 = uVar16;\n    pbVar21[-1] = bVar22;\n    pbVar21 = pbVar21 + -1;\n    iVar7 = DAT_00242448;\n    uVar18 = 6;\n    goto LAB_0015d396;\n  }\n  pbVar21 = pbVar15;\n  if ((uVar2 & 8) != 0) goto LAB_0015d520;\n  while (bVar22 == 0x5f) {\nLAB_0015d520:\n    do {\n      pbVar21 = pbVar19;\n      bVar22 = *pbVar21;\n      pbVar19 = pbVar21 + 1;\n    } while ((*(byte *)(puVar3 + bVar22) & 8) != 0);\n  }\n  local_a8 = 0;\n  if (bVar22 == 0x5b) {\n    if ((assoc_expand_once & DAT_00242350) == 0) {\nLAB_0015da08:\n      uVar18 = 0;\n    }\n    else {\n      pbVar19[-1] = 0;\n      iVar7 = legal_identifier(pbVar15);\n      if (iVar7 == 0) {\n        pbVar19[-1] = 0x5b;\n        uVar18 = 0;\n      }\n      else {\n        lVar13 = find_variable(pbVar15);\n        if (lVar13 == 0) {\n          pbVar19[-1] = 0x5b;\n          goto LAB_0015da08;\n        }\n        uVar18 = *(uint *)(lVar13 + 0x28);\n        pbVar19[-1] = 0x5b;\n        uVar18 = uVar18 & 0x40;\n        if (uVar18 != 0) {\n          if (assoc_expand_once == 0) goto LAB_0015da08;\n          uVar18 = (uint)(DAT_00242350 != 0);\n        }\n      }\n    }\n    iVar7 = skipsubscript(pbVar21,0,uVar18);\n    if (pbVar21[iVar7] != 0x5d) {\n                    /* WARNING: Subroutine does not return */\n      FUN_0015bcf0(bash_badsub_errmsg);\n    }\n    pbVar21 = pbVar19 + iVar7;\n    local_a8 = 0x5d;\n    bVar22 = *pbVar21;\n  }\n  *pbVar21 = 0;\n  if ((DAT_002386c0 == (char *)0x0) || (DAT_002386c0 != DAT_00242438)) {\n    if (DAT_00242438 != (char *)0x0) goto LAB_0015d894;\n  }\n  else {\n    DAT_002386c0 = (char *)0x0;\n    DAT_002386d0 = 0;\n    DAT_002386d8 = 0xffffffffffffffff;\n    DAT_002386c8 = 0xffffffffffffffff;\nLAB_0015d894:\n    sh_xfree(DAT_00242438,\"expr.c\",0x556);\n  }\n  pbVar15 = DAT_00242458;\n  sVar10 = strlen((char *)DAT_00242458);\n  pcVar11 = (char *)sh_xmalloc(sVar10 + 1,\"expr.c\",0x557);\n  pcVar12 = strcpy(pcVar11,(char *)pbVar15);\n  *pbVar21 = bVar22;\n  pbVar19 = DAT_00242458;\n  pbVar15 = DAT_00242450;\n  iVar6 = DAT_00242448;\n  iVar8 = DAT_00242444;\n  uVar16 = DAT_00242430;\n  iVar7 = DAT_00242428;\n  uVar4 = DAT_002386d8;\n  lVar13 = DAT_002386d0;\n  uVar20 = DAT_002386c8;\n  pcVar11 = DAT_002386c0;\n  DAT_00242438 = (char *)0x0;\n  DAT_00242428 = 1;\n  DAT_00242448 = 5;\n  DAT_00242458 = pbVar21;\n  FUN_0015d330();\n  if (DAT_00242448 == 5) {\n    if (DAT_00242438 != (char *)0x0) {\n      sh_xfree(DAT_00242438,\"expr.c\",0x563);\n    }\nLAB_0015d77e:\n    iVar5 = DAT_00242344;\n    DAT_002386c0 = pcVar11;\n    DAT_002386c8 = uVar20;\n    DAT_002386d0 = lVar13;\n    DAT_002386d8 = uVar4;\n    DAT_00242428 = iVar7;\n    DAT_00242438 = pcVar12;\n    DAT_00242448 = iVar6;\n    DAT_00242450 = pbVar15;\n    if (iVar7 == 0) {\n      uVar18 = assoc_expand_once;\n      if (assoc_expand_once != 0) {\n        uVar18 = (uint)(DAT_00242350 != 0) << 5;\n      }\n      DAT_00242458 = pbVar19;\n      DAT_00242430 = uVar16;\n      DAT_00242444 = iVar8;\n      if (local_a8 == 0x5d) {\n        lVar13 = array_variable_part(pcVar12,uVar18,0,0);\nLAB_0015d7d8:\n        if (((lVar13 == 0) || ((*(byte *)(lVar13 + 0x29) & 0x10) != 0)) &&\n           (unbound_vars_is_error != 0)) {\n          if (local_a8 == 0x5d) {\n            lVar13 = array_variable_name(pcVar12,uVar18,0,0);\n            set_exit_status(1);\n            err_unboundvar(lVar13);\n            if (lVar13 != 0) {\n              sh_xfree(lVar13,\"expr.c\",0x4a7);\n            }\n          }\n          else {\nLAB_0015d927:\n            set_exit_status(1);\n            err_unboundvar(pcVar12);\n          }\n          if (no_longjmp_on_fatal_error == 0) {\n            if (interactive_shell != 0) {\n              FUN_0015bc10();\n              top_level_cleanup();\n                    /* WARNING: Subroutine does not return */\n              jump_to_top_level(2);\n            }\nLAB_0015d955:\n                    /* WARNING: Subroutine does not return */\n            jump_to_top_level(1);\n          }\n          if (interactive_shell == 0) goto LAB_0015d955;\n          goto LAB_0015d850;\n        }\nLAB_0015d7ec:\n        init_eltstate(local_68);\n        local_60 = 0xffffffffffffffff;\n        if (local_a8 != 0x5d) goto LAB_0015d80c;\n        pcVar11 = (char *)get_array_value(pcVar12,uVar18,local_68);\n      }\n      else {\n        lVar13 = find_variable(pcVar12);\n        if (lVar13 == 0) {\n          lVar13 = find_variable_last_nameref(pcVar12,0);\n          goto LAB_0015d7d8;\n        }\n        if ((*(byte *)(lVar13 + 0x29) & 0x10) != 0) {\n          if (unbound_vars_is_error != 0) goto LAB_0015d927;\n          goto LAB_0015d7ec;\n        }\n        init_eltstate(local_68);\nLAB_0015d80c:\n        local_60 = 0xffffffffffffffff;\n        pcVar11 = (char *)get_variable_value(lVar13);\n      }\n      uVar4 = local_60;\n      flush_eltstate(local_68);\n      if (iVar5 <= DAT_00242344) {\n        uVar20 = 0;\n        if ((pcVar11 != (char *)0x0) && (*pcVar11 != '\\0')) {\n          uVar20 = FUN_0015d040(pcVar11);\n        }\n        DAT_002386d8 = uVar4;\n        DAT_002386c0 = pcVar12;\n        DAT_002386c8 = uVar20;\n        DAT_002386d0 = lVar13;\n        DAT_00242430 = uVar20;\n        goto LAB_0015d6d9;\n      }\n      if ((no_longjmp_on_fatal_error != 0) && (interactive_shell != 0)) {\nLAB_0015d850:\n                    /* WARNING: Subroutine does not return */\n        __longjmp_chk(&DAT_00242360,1);\n      }\n    }\n    DAT_00242430 = 0;\n  }\n  else {\n    if ((iVar8 - 0xeU < 2) || (DAT_00242448 != 0x3d)) goto LAB_0015d77e;\n    DAT_00242430 = 0;\n    DAT_00242448 = iVar6;\n    DAT_002386c0 = pcVar11;\n    DAT_002386c8 = uVar20;\n    DAT_002386d0 = lVar13;\n    DAT_002386d8 = uVar4;\n    DAT_00242428 = iVar7;\n    DAT_00242438 = pcVar12;\n    DAT_00242450 = pbVar15;\n  }\nLAB_0015d6d9:\n  iVar7 = DAT_00242448;\n  uVar18 = 5;\nLAB_0015d396:\n  DAT_00242448 = uVar18;\n  DAT_00242444 = iVar7;\n  DAT_00242458 = pbVar21;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "getcoprocbyname": "\nundefined8 * getcoprocbyname(char *param_1)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  \n  if (sh_coproc == (char *)0x0) {\n    return (undefined8 *)0x0;\n  }\n  if (*sh_coproc == *param_1) {\n    iVar1 = strcmp(sh_coproc,param_1);\n    puVar2 = &sh_coproc;\n    if (iVar1 != 0) {\n      puVar2 = (undefined8 *)0x0;\n    }\n    return puVar2;\n  }\n  return (undefined8 *)0x0;\n}\n\n",
  "FUN_00134b40": "\nundefined4 FUN_00134b40(undefined4 param_1)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = (undefined *)(DAT_00240a70 + -1);\n  DAT_00240a70 = DAT_00240a70 + -1;\n  *puVar1 = (char)param_1;\n  return param_1;\n}\n\n",
  "_rl_vi_domove_callback": "\nbool _rl_vi_domove_callback(long param_1)\n\n{\n  int iVar1;\n  bool bVar2;\n  \n  iVar1 = _rl_bracketed_read_key();\n  bVar2 = true;\n  *(int *)(param_1 + 0x20) = iVar1;\n  if (-1 < iVar1) {\n    iVar1 = FUN_001d2470(param_1);\n    bVar2 = iVar1 != 0;\n  }\n  return bVar2;\n}\n\n",
  "bash_servicename_completion_function": "\nchar * bash_servicename_completion_function(char *param_1,int param_2)\n\n{\n  char **ppcVar1;\n  char cVar2;\n  int iVar3;\n  size_t sVar4;\n  char *pcVar5;\n  servent *psVar6;\n  char **ppcVar7;\n  char *__s2;\n  \n  if (param_2 == 0) {\n    if (DAT_00248710 != (char *)0x0) {\n      sh_xfree(DAT_00248710,\"bashline.c\",0xa2a);\n    }\n    sVar4 = strlen(param_1);\n    pcVar5 = (char *)sh_xmalloc(sVar4 + 1,\"bashline.c\",0xa2c);\n    DAT_00248710 = strcpy(pcVar5,param_1);\n    sVar4 = strlen(DAT_00248710);\n    DAT_00248708 = (int)sVar4;\n    setservent(0);\n  }\n  while( true ) {\n    psVar6 = getservent();\n    pcVar5 = DAT_00248710;\n    if (psVar6 == (servent *)0x0) {\n      endservent();\n      return (char *)0x0;\n    }\n    sVar4 = (size_t)DAT_00248708;\n    __s2 = psVar6->s_name;\n    if ((DAT_00248708 == 0) ||\n       ((cVar2 = *DAT_00248710, cVar2 == *__s2 &&\n        (iVar3 = strncmp(DAT_00248710,__s2,(long)DAT_00248708), iVar3 == 0)))) break;\n    ppcVar7 = psVar6->s_aliases;\n    __s2 = *ppcVar7;\n    while (__s2 != (char *)0x0) {\n      if ((cVar2 == *__s2) && (iVar3 = strncmp(pcVar5,__s2,sVar4), iVar3 == 0)) goto LAB_00199695;\n      ppcVar1 = ppcVar7 + 1;\n      ppcVar7 = ppcVar7 + 1;\n      __s2 = *ppcVar1;\n    }\n  }\nLAB_00199695:\n  sVar4 = strlen(__s2);\n  pcVar5 = (char *)sh_xmalloc(sVar4 + 1,\"bashline.c\",0xa4b);\n  pcVar5 = strcpy(pcVar5,__s2);\n  return pcVar5;\n}\n\n",
  "utf8_mbschr": "\nvoid utf8_mbschr(char *param_1,int param_2)\n\n{\n  strchr(param_1,param_2);\n  return;\n}\n\n",
  "xtrace_print_arith_cmd": "\nvoid xtrace_print_arith_cmd(long *param_1)\n\n{\n  char *__s;\n  undefined *puVar1;\n  \n  if (xtrace_fp == (FILE *)0x0) {\n    xtrace_fp = stderr;\n  }\n  __s = (char *)indirection_level_string();\n  fputs(__s,xtrace_fp);\n  fwrite(&DAT_001fc75a,1,3,xtrace_fp);\n  if (param_1 != (long *)0x0) {\n    do {\n      puVar1 = &DAT_00213d70;\n      if (*param_1 != 0) {\n        puVar1 = &DAT_001fdb1c;\n      }\n      __fprintf_chk(xtrace_fp,1,&DAT_001fc632,*(undefined8 *)param_1[1],puVar1);\n      param_1 = (long *)*param_1;\n    } while (param_1 != (long *)0x0);\n  }\n  fwrite(&DAT_001fc75e,1,4,xtrace_fp);\n  fflush(xtrace_fp);\n  return;\n}\n\n",
  "strlist_sort": "\nvoid strlist_sort(long *param_1)\n\n{\n  if (((param_1 != (long *)0x0) && (*(int *)((long)param_1 + 0xc) != 0)) && (*param_1 != 0)) {\n    strvec_sort(*param_1,0);\n    return;\n  }\n  return;\n}\n\n",
  "signal_is_trapped": "\nuint signal_is_trapped(int param_1)\n\n{\n  return (&DAT_00247e40)[param_1] & 1;\n}\n\n",
  "bash_initialize_history": "\nvoid bash_initialize_history(void)\n\n{\n  history_quotes_inhibit_expansion = 1;\n  history_search_delimiter_chars = \";&()|<>\";\n  history_inhibit_expansion_function = FUN_00190570;\n  sv_histchars(\"histchars\");\n  return;\n}\n\n",
  "sh_xmalloc": "\nlong sh_xmalloc(undefined8 param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  void *pvVar1;\n  long lVar2;\n  void *pvVar3;\n  \n  if (DAT_00248a48 == 0) {\n    DAT_00248a50 = sbrk(0);\n    DAT_00248a48 = 1;\n  }\n  lVar2 = sh_malloc(param_1,param_2,param_3);\n  if (lVar2 != 0) {\n    return lVar2;\n  }\n  if (DAT_00248a48 == 0) {\n    DAT_00248a50 = sbrk(0);\n    DAT_00248a48 = 1;\n  }\n  pvVar1 = DAT_00248a50;\n  pvVar3 = sbrk(0);\n  fatal_error(\"%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)\",\"xmalloc\",param_2,param_3\n              ,param_1,(long)pvVar3 - (long)pvVar1);\n  return 0;\n}\n\n",
  "FUN_001bc230": "\nvoid FUN_001bc230(long **param_1)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  undefined4 uVar3;\n  \n  if (param_1 == (long **)0x0) {\n    sh_chkwrite(0);\n    return;\n  }\n  uVar1 = 0;\n  do {\n    while( true ) {\n      uVar3 = uVar1;\n      lVar2 = progcomp_search(*param_1[1]);\n      if (lVar2 != 0) break;\n      uVar3 = 1;\n      builtin_error(\"%s: no completion specification\",*param_1[1]);\n      param_1 = (long **)*param_1;\n      uVar1 = 1;\n      if (param_1 == (long **)0x0) goto LAB_001bc292;\n    }\n    FUN_001bbe90(*param_1[1]);\n    param_1 = (long **)*param_1;\n    uVar1 = uVar3;\n  } while (param_1 != (long **)0x0);\nLAB_001bc292:\n  sh_chkwrite(uVar3);\n  return;\n}\n\n",
  "setresuid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint setresuid(__uid_t __ruid,__uid_t __euid,__uid_t __suid)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_setresuid_00237958)();\n  return iVar1;\n}\n\n",
  "parse_string_to_word_list": "\nlong * parse_string_to_word_list(undefined8 param_1,ulong param_2,undefined8 param_3)\n\n{\n  bool bVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined4 uVar4;\n  int iVar5;\n  long *plVar6;\n  long in_FS_OFFSET;\n  uint local_14c;\n  undefined local_148 [264];\n  long local_40;\n  \n  iVar2 = line_number;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  save_parser_state(local_148);\n  bash_history_disable();\n  push_stream(1);\n  bVar1 = false;\n  if ((pushed_string_list != 0) && (bVar1 = false, *(long *)(pushed_string_list + 0x18) != 0)) {\n    bVar1 = true;\n    FUN_001357c0(0,0,0);\n    *(undefined4 *)(pushed_string_list + 0x3c) = 4;\n  }\n  DAT_00240d70 = 0x119;\n  current_command_line_count = 0;\n  expand_aliases = 0;\n  echo_input_at_read = 0;\n  init_yy_io(FUN_00134b10,FUN_00134b40,3,param_3,param_1);\n  if ((param_2 & 1) != 0) {\n    local_14c = parser_state;\n    parser_state = parser_state & 0xffbfffff | 0x42000;\n  }\n  plVar6 = (long *)0x0;\nLAB_0013d530:\n  iVar5 = DAT_00240b58;\n  if (DAT_00240b58 != 0) goto LAB_0013d57a;\nLAB_0013d53a:\n  iVar5 = FUN_0013a230();\n  uVar4 = current_token;\n  current_token = iVar5;\n  do {\n    if (current_token == 0x131) {\nLAB_0013d5b6:\n      current_token = uVar4;\n      DAT_00240d70 = 10;\n      pop_stream();\n      if ((bVar1) && (pushed_string_list != 0)) {\n        FUN_001358d0();\n      }\n      restore_parser_state(local_148);\n      if ((param_2 & 1) != 0) {\n        parser_state = local_14c;\n      }\n      if (plVar6 == (long *)&DAT_00240b00) {\n        set_exit_status(1);\n        if ((interactive_shell == 0) && (posixly_correct != 0)) {\n                    /* WARNING: Subroutine does not return */\n          jump_to_top_level(1);\n        }\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level(2);\n      }\n      if ((plVar6 != (long *)0x0) && (*plVar6 != 0)) {\n        plVar6 = (long *)list_reverse(plVar6);\n      }\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return plVar6;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (current_token == 10) {\n      current_token = uVar4;\n      if (*DAT_00240a70 == '\\0') goto LAB_0013d5b6;\n      goto LAB_0013d530;\n    }\n    if (1 < current_token - 0x119U) {\n      line_number = iVar2 + line_number + -1;\n      if ((parser_state & 0x800000) == 0) {\n        FUN_00135180(0);\n      }\n      reset_parser();\n      if (plVar6 == (long *)0x0) {\n        plVar6 = (long *)&DAT_00240b00;\n      }\n      else {\n        current_token = uVar4;\n        dispose_words(plVar6);\n        plVar6 = (long *)&DAT_00240b00;\n        uVar4 = current_token;\n      }\n      goto LAB_0013d5b6;\n    }\n    current_token = uVar4;\n    plVar6 = (long *)make_word_list(yylval,plVar6);\n    iVar5 = DAT_00240b58;\n    if (DAT_00240b58 == 0) goto LAB_0013d53a;\nLAB_0013d57a:\n    uVar3 = DAT_00240b50;\n    if (iVar5 - 0x119U < 2) {\n      DAT_00240b50 = 0;\n      yylval = uVar3;\n    }\n    DAT_00240b58 = 0;\n    uVar4 = current_token;\n    current_token = iVar5;\n  } while( true );\n}\n\n",
  "memset": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memset_00237a60)();\n  return pvVar1;\n}\n\n",
  "FUN_00195700": "\nchar * FUN_00195700(char *param_1,int param_2,char *param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  long lVar4;\n  char *__s;\n  char *pcVar5;\n  char *pcVar6;\n  size_t sVar7;\n  char *pcVar8;\n  undefined8 *puVar9;\n  char *pcVar10;\n  long in_FS_OFFSET;\n  bool bVar11;\n  undefined4 local_48;\n  undefined4 local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar1 = *param_3;\n  local_48 = 0;\n  local_44 = 0;\n  pcVar5 = param_1;\n  if (cVar1 == '\\0') {\n    if (dircomplete_expand == 0) {\n      iVar2 = FUN_00194bb0(param_1,0,&local_48,&local_44);\n      if ((iVar2 == 0) || (iVar3 = file_exists(param_1), iVar3 != 0)) {\n        cVar1 = *param_3;\n        if (cVar1 != '\\0') goto LAB_001957e8;\n        goto LAB_00195753;\n      }\n      if (rl_filename_quote_characters != DAT_00248980) {\n        FUN_00195620(iVar2,local_48,local_44);\n      }\n      complete_fullquote = 0;\n      goto LAB_00195804;\n    }\nLAB_00195753:\n    lVar4 = mbschr(param_1,10);\n    if (lVar4 == 0) {\n      cVar1 = *param_3;\n      goto LAB_001957e8;\n    }\nLAB_00195765:\n    if ((*param_1 == '~') && (param_2 == 1)) {\n      pcVar5 = (char *)bash_tilde_expand(param_1,0);\n    }\n    __s = (char *)sh_single_quote(pcVar5);\nLAB_0019577e:\n    bVar11 = param_2 == 2;\n    if (param_1 != pcVar5) {\n      sh_xfree(pcVar5,\"bashline.c\",0x10f3);\n    }\njoined_r0x001958a4:\n    if (__s != (char *)0x0) {\nLAB_001958aa:\n      sVar7 = strlen(__s);\n      lVar4 = (long)(int)sVar7;\n      pcVar5 = (char *)sh_xmalloc((long)((int)sVar7 + 1),\"bashline.c\",0x1104);\n      strcpy(pcVar5,__s);\n      goto LAB_001958d6;\n    }\n  }\n  else {\nLAB_001957e8:\n    if (cVar1 == '\\\"') {\n      if (((history_expansion == 0) || (history_expansion_inhibited != 0)) ||\n         (lVar4 = mbschr(param_1,0x21), lVar4 == 0)) {\n        if ((*param_1 == '~') && (param_2 == 1)) {\n          pcVar5 = (char *)bash_tilde_expand(param_1,0);\n        }\n        __s = (char *)sh_double_quote(pcVar5);\n        goto LAB_0019577e;\n      }\n      *param_3 = '\\0';\n    }\n    else if (cVar1 == '\\'') goto LAB_00195765;\n    puVar9 = (undefined8 *)0x0;\n    if (complete_fullquote == 0) {\nLAB_00195804:\n      puVar9 = &DAT_00248880;\n    }\n    __s = (char *)sh_backslash_quote(param_1,puVar9,0);\n    if (__s != (char *)0x0) {\n      sVar7 = strlen(__s);\n      if (rl_completer_word_break_characters != 0) {\n        pcVar6 = (char *)sh_xmalloc((long)((int)sVar7 * 2 + 1),\"bashline.c\",0x1021);\n        cVar1 = *__s;\n        pcVar5 = __s;\n        pcVar10 = pcVar6;\n        while (cVar1 != '\\0') {\n          if (cVar1 == '\\\\') {\n            *pcVar10 = '\\\\';\n            cVar1 = pcVar5[1];\n            pcVar8 = pcVar10 + 2;\n            pcVar10[1] = cVar1;\n            pcVar10 = pcVar8;\n            if (cVar1 == '\\0') break;\n            pcVar5 = pcVar5 + 1;\n          }\n          else {\n            lVar4 = mbschr(rl_completer_word_break_characters);\n            if (lVar4 != 0) {\n              *pcVar10 = '\\\\';\n              pcVar10 = pcVar10 + 1;\n            }\n            cVar1 = *pcVar5;\n            if ((__s == pcVar5) && (cVar1 == '~')) {\n              iVar2 = file_exists(__s);\n              if (iVar2 == 0) {\n                cVar1 = *__s;\n              }\n              else {\n                *pcVar10 = '\\\\';\n                pcVar10 = pcVar10 + 1;\n                cVar1 = *__s;\n              }\n            }\n            *pcVar10 = cVar1;\n            pcVar8 = pcVar10 + 1;\n          }\n          pcVar10 = pcVar5 + 1;\n          pcVar5 = pcVar5 + 1;\n          cVar1 = *pcVar10;\n          pcVar10 = pcVar8;\n        }\n        *pcVar10 = '\\0';\n        bVar11 = false;\n        sh_xfree(__s,\"bashline.c\",0x10fb);\n        __s = pcVar6;\n        goto joined_r0x001958a4;\n      }\n      bVar11 = false;\n      goto LAB_001958aa;\n    }\n    bVar11 = false;\n  }\n  lVar4 = 1;\n  pcVar5 = (char *)sh_xmalloc(1,\"bashline.c\",0x1109);\n  *pcVar5 = '\\0';\nLAB_001958d6:\n  if (bVar11) {\n    pcVar5[lVar4 + -1] = '\\0';\n  }\n  sh_xfree(__s,\"bashline.c\",0x1110);\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar5;\n}\n\n",
  "FUN_001a8750": "\nvoid FUN_001a8750(long param_1,uint param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  char *__dest;\n  char *pcVar4;\n  \n  begin_unwind_frame(param_3);\n  unwind_protect_mem(&parse_and_execute_level,4);\n  unwind_protect_mem(top_level,200);\n  unwind_protect_mem(&indirection_level,4);\n  unwind_protect_mem(&line_number,4);\n  unwind_protect_mem(&line_number_for_err_trap,4);\n  unwind_protect_mem(&loop_level,4);\n  unwind_protect_mem(&executing_list,4);\n  unwind_protect_mem(&comsub_ignore_return,4);\n  if ((param_2 & 3) != 0) {\n    unwind_protect_mem(&interactive,4);\n  }\n  if (parse_and_execute_level == 0) {\n    add_unwind_protect(FUN_001a8700,0);\n  }\n  else {\n    unwind_protect_mem(&remember_on_history,4);\n  }\n  unwind_protect_mem(&history_expansion_inhibited,4);\n  if (interactive_shell != 0) {\n    uVar2 = get_current_prompt_level();\n    add_unwind_protect(set_current_prompt_level,uVar2);\n  }\n  pcVar4 = the_printed_command_except_trap;\n  if (the_printed_command_except_trap != (char *)0x0) {\n    sVar3 = strlen(the_printed_command_except_trap);\n    __dest = (char *)sh_xmalloc(sVar3 + 1,\"evalstring.c\",0x102);\n    pcVar4 = strcpy(__dest,pcVar4);\n    add_unwind_protect(FUN_001a8720,pcVar4);\n  }\n  add_unwind_protect(pop_stream,0);\n  iVar1 = parser_expanding_alias();\n  if (iVar1 != 0) {\n    add_unwind_protect(parser_restore_alias,0);\n  }\n  if ((param_1 != 0) && ((param_2 & 8) == 0)) {\n    add_unwind_protect(xfree,param_1);\n  }\n  if ((param_2 & 3) != 0) {\n    interactive = ~param_2 & 1;\n  }\n  if ((param_2 & 4) != 0) {\n    bash_history_disable();\n  }\n  if ((param_2 & 0x200) != 0) {\n    history_expansion_inhibited = 1;\n  }\n  return;\n}\n\n",
  "FUN_001c1f10": "\n/* WARNING: Type propagation algorithm not settling */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nulong FUN_001c1f10(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,wchar_t *param_4,\n                  wchar_t **param_5,uint param_6)\n\n{\n  byte bVar1;\n  byte bVar2;\n  uint uVar3;\n  int iVar4;\n  wchar_t wVar5;\n  wchar_t wVar6;\n  int iVar7;\n  wchar_t wVar8;\n  wchar_t wVar9;\n  wchar_t *pwVar10;\n  wctype_t wVar11;\n  wchar_t *pwVar12;\n  wchar_t *pwVar13;\n  wchar_t *pwVar14;\n  size_t sVar15;\n  size_t sVar16;\n  char *__dst;\n  uint uVar17;\n  long lVar18;\n  ulong uVar19;\n  wchar_t *pwVar20;\n  uint uVar21;\n  long in_FS_OFFSET;\n  bool bVar22;\n  bool bVar23;\n  wchar_t local_e8;\n  wchar_t local_d8;\n  wchar_t *local_d0;\n  wchar_t *local_c8;\n  uint local_b0;\n  wchar_t local_9c;\n  wchar_t *local_98;\n  wchar_t *local_90;\n  mbstate_t local_80;\n  char local_78 [32];\n  undefined2 local_58;\n  undefined local_56;\n  char local_55 [21];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_d0 = param_1;\n  if (param_4 <= param_3) {\nLAB_001c2069:\n    if (param_2 == local_d0) {\nLAB_001c20e7:\n      uVar19 = 0;\n    }\n    else if ((param_6 & 8) == 0) {\nLAB_001c2080:\n      uVar19 = 1;\n    }\n    else {\n      uVar19 = (ulong)(*local_d0 != L'/');\n    }\nLAB_001c2086:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return uVar19;\n    }\nLAB_001c31fe:\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  uVar3 = param_6 >> 1;\n  uVar17 = param_6 & 0x10;\n  bVar1 = ((byte)uVar3 ^ 1) & 1;\nLAB_001c1f74:\n  pwVar14 = param_3 + 1;\n  wVar5 = *param_3;\n  if ((uVar17 != 0) && (iVar4 = iswupper(wVar5), iVar4 != 0)) {\n    wVar5 = towlower(wVar5);\n  }\n  wVar9 = L'\\0';\n  if (local_d0 < param_2) {\n    wVar9 = *local_d0;\n  }\n  if ((interrupt_state | terminating_signal) != 0) goto LAB_001c2080;\n  uVar21 = param_6 & 0x20;\n  if (((uVar21 == 0) || (param_3[1] != L'(')) || (0x1f < (uint)(wVar5 + L'\\xffffffdf'))) {\n    if (wVar5 == L'[') {\n      if ((wVar9 == L'\\0') || (param_2 == local_d0)) goto LAB_001c2080;\n      if (((param_6 & 4) == 0) || (wVar9 != L'.')) {\n        if ((param_6 & 0x80) == 0) goto LAB_001c212e;\n        if (((param_1 == local_d0) && (*param_1 == L'.')) &&\n           ((param_1[1] == L'\\0' || ((param_1[1] == L'.' && (param_1[2] == L'\\0'))))))\n        goto LAB_001c2080;\n        uVar21 = param_6 & 1;\n      }\n      else {\n        if (param_1 == local_d0) goto LAB_001c2080;\n        if ((param_6 & 1) == 0) goto LAB_001c212e;\n        if (local_d0[-1] == L'/') goto LAB_001c2080;\n        uVar21 = param_6 & 0x80;\n      }\n      if ((((uVar21 == 0) || (local_d0[-1] != L'/')) || (*local_d0 != L'.')) ||\n         (((wVar5 = local_d0[1], wVar5 != L'/' && (wVar5 != L'\\0')) &&\n          ((wVar5 != L'.' || ((local_d0[2] != L'/' && (local_d0[2] != L'\\0')))))))) {\nLAB_001c212e:\n        local_d8 = wVar9;\n        if ((uVar17 != 0) && (iVar4 = iswupper(wVar9), iVar4 != 0)) {\n          local_d8 = towlower(wVar9);\n        }\n        wVar5 = param_3[1];\n        bVar22 = wVar5 == L'!';\n        bVar23 = wVar5 == L'^';\n        pwVar12 = pwVar14;\n        if (bVar22 || bVar23) {\n          wVar5 = param_3[2];\n          pwVar12 = param_3 + 2;\n        }\n        pwVar12 = pwVar12 + 1;\nLAB_001c2190:\n        do {\n          if (wVar5 != L'[') {\n            bVar2 = wVar5 == L'\\\\' & bVar1;\n            wVar6 = wVar5;\n            if (bVar2 == 0) goto LAB_001c21b4;\n            wVar6 = *pwVar12;\n            if (wVar6 != L'\\0') {\n              pwVar12 = pwVar12 + 1;\n              local_b0 = (uint)bVar2;\n              wVar5 = L'\\\\';\n              if (uVar17 == 0) goto LAB_001c21ca;\n              goto LAB_001c22bf;\n            }\n            break;\n          }\n          wVar8 = *pwVar12;\n          if (wVar8 == L'=') {\n            iVar4 = 0;\n            wVar6 = L'[';\n            if ((pwVar12[2] != L'=') || (pwVar12[3] != L']')) goto LAB_001c2247;\n            wVar5 = pwVar12[1];\n            if ((uVar17 != 0) && (iVar4 = iswupper(wVar5), iVar4 != 0)) {\n              wVar5 = towlower(wVar5);\n            }\n            local_9c = wVar5;\n            if (wVar5 != local_d8) {\n              _DAT_0023a6d8 = local_d8;\n              _DAT_0023a6d0 = wVar5;\n              iVar4 = wcscoll((wchar_t *)&DAT_0023a6d8,(wchar_t *)&DAT_0023a6d0);\n              if (iVar4 != 0) {\n                iVar4 = wctomb(local_78,local_d8);\n                if (iVar4 != -1) {\n                  local_58 = 0x5b5b;\n                  local_78[iVar4] = '\\0';\n                  local_56 = 0x3d;\n                  iVar4 = wctomb(local_55,wVar5);\n                  if (iVar4 != -1) {\n                    *(undefined *)((long)&local_58 + (long)(iVar4 + 3)) = 0x3d;\n                    *(undefined *)((long)&local_58 + (long)(iVar4 + 5)) = 0x5d;\n                    *(undefined *)((long)&local_58 + (long)(iVar4 + 4)) = 0x5d;\n                    *(undefined *)((long)&local_58 + (long)(iVar4 + 6)) = 0;\n                    iVar4 = fnmatch((char *)&local_58,local_78,0);\n                    if (iVar4 == 0) goto LAB_001c3028;\n                  }\n                }\n                wVar5 = pwVar12[4];\n                pwVar12 = pwVar12 + 5;\n                if (wVar5 != L'\\0') goto joined_r0x001c239d;\n                goto LAB_001c22e8;\n              }\n            }\nLAB_001c3028:\n            local_c8 = pwVar12 + 4;\n            pwVar12 = pwVar12 + 5;\nLAB_001c2637:\n            wVar5 = pwVar12[-1];\n            if (wVar5 == L'\\0') goto LAB_001c22e8;\n            iVar4 = 1;\n            pwVar12 = (wchar_t *)0x0;\n            wVar9 = wVar5;\n            goto LAB_001c2658;\n          }\n          if (wVar8 != L':') {\n            iVar4 = 0;\n            wVar6 = L'[';\n            if (wVar8 == L'.') {\n              iVar4 = 1;\n              pwVar12 = (wchar_t *)FUN_001bf9c0(pwVar12,&local_9c);\n              wVar6 = local_9c;\n              if (local_9c == L'\\xffffffff') {\n                wVar6 = local_d8 + L'\\x01';\n              }\n            }\nLAB_001c2247:\n            local_b0 = (uVar3 & 0xff ^ 1) & 0xffffff01;\n            pwVar13 = pwVar12;\n            if (uVar17 == 0) goto LAB_001c21d0;\n            iVar7 = iswupper(wVar6);\n            if (iVar7 != 0) goto LAB_001c22d3;\nLAB_001c2270:\n            wVar5 = *pwVar13;\n            pwVar12 = pwVar13 + 1;\n            iVar7 = iswupper(wVar5);\n            if (iVar7 != 0) {\n              wVar5 = towlower(wVar5);\n            }\n            do {\n              if (wVar5 == L'\\0') goto LAB_001c22e8;\n              if ((wVar5 == L'/') && ((param_6 & 1) != 0)) goto LAB_001c2080;\n              if (wVar5 != L'-') {\n                if (local_d8 == wVar6) {\nLAB_001c2630:\n                  local_c8 = pwVar12 + -1;\n                  goto LAB_001c2637;\n                }\nLAB_001c2202:\n                if (wVar5 == L']') goto LAB_001c220a;\n                goto LAB_001c2190;\n              }\n              wVar8 = pwVar13[1];\n              if (wVar8 != L']') {\n                local_c8 = pwVar13 + 2;\n                if ((wVar8 == L'\\\\') && ((char)local_b0 != '\\0')) {\n                  local_c8 = pwVar13 + 3;\n                  wVar8 = pwVar13[2];\n                }\n                if (wVar8 == L'\\0') goto LAB_001c2080;\n                if ((wVar8 == L'[') && (*local_c8 == L'.')) {\n                  iVar4 = 1;\n                  local_c8 = (wchar_t *)FUN_001bf9c0(local_c8,&local_9c);\n                  wVar8 = local_9c;\n                  if (local_9c == L'\\xffffffff') {\n                    wVar8 = local_d8 + L'\\xffffffff';\n                  }\n                }\n                if ((uVar17 != 0) && (iVar7 = iswupper(wVar8), iVar7 != 0)) {\n                  wVar8 = towlower(wVar8);\n                }\n                wVar5 = *local_c8;\n                pwVar12 = local_c8 + 1;\n                iVar7 = FUN_001bf950(wVar6,wVar8,iVar4);\n                if (0 < iVar7) goto joined_r0x001c2391;\n                iVar7 = FUN_001bf950(local_d8,wVar6,iVar4);\n                if ((iVar7 < 0) || (iVar4 = FUN_001bf950(local_d8,wVar8,iVar4), 0 < iVar4))\n                goto LAB_001c2202;\n                goto LAB_001c2637;\n              }\n              if (local_d8 == wVar6) goto LAB_001c2630;\n              wVar6 = L'-';\nLAB_001c21b4:\n              local_b0 = (uVar3 & 0xff ^ 1) & 0xffffff01;\n              if (uVar17 != 0) goto LAB_001c22bf;\n              if (wVar5 == L'\\0') goto LAB_001c22e8;\nLAB_001c21ca:\n              iVar4 = 0;\n              pwVar13 = pwVar12;\nLAB_001c21d0:\n              wVar5 = *pwVar13;\n              pwVar12 = pwVar13 + 1;\n            } while( true );\n          }\n          local_9c = L'\\0';\n          pwVar13 = pwVar12 + 1;\n          wVar5 = pwVar12[1];\n          pwVar20 = pwVar13;\n          while (local_c8 = pwVar12, wVar5 != L'\\0') {\n            pwVar10 = pwVar20 + 1;\n            if ((wVar5 == L':') && (*pwVar10 == L']')) {\n              lVar18 = (long)pwVar20 - (long)pwVar12;\n              pwVar10 = (wchar_t *)sh_malloc(lVar18,\"sm_loop.c\",0x1e4);\n              if (pwVar10 == (wchar_t *)0x0) {\n                local_9c = L'\\0';\n              }\n              else {\n                memmove(pwVar10,pwVar13,lVar18 - 4);\n                *(undefined4 *)((long)pwVar10 + lVar18 + -4) = 0;\n                wcdequote_pathname(pwVar10);\n                local_98 = pwVar10;\n                wVar11 = wctype(\"ascii\");\n                pwVar12 = local_98;\n                if ((wVar11 == 0) && (iVar4 = wcscmp(local_98,L\"ascii\"), iVar4 == 0)) {\n                  iVar4 = wctob(wVar9);\n                  if (iVar4 == -1) {\n                    local_9c = L'\\0';\n                  }\n                  else {\n                    local_9c = (wchar_t)(iVar4 < 0x80);\n                  }\n                }\n                else {\n                  iVar4 = wcscmp(pwVar12,L\"word\");\n                  if (iVar4 == 0) {\n                    pwVar12 = L\"alnum\";\n                    local_98 = L\"alnum\";\n                  }\n                  local_80.__count = 0;\n                  local_80.__value = (_union_27)0x0;\n                  sVar15 = wcslen(pwVar12);\n                  sVar16 = __ctype_get_mb_cur_max();\n                  __dst = (char *)sh_malloc(sVar15 * sVar16 + 1,\"smatch.c\",0x1f2);\n                  if (__dst != (char *)0x0) {\n                    sVar15 = wcslen(local_98);\n                    sVar16 = __ctype_get_mb_cur_max();\n                    sVar15 = wcsrtombs(__dst,&local_98,sVar15 * sVar16 + 1,&local_80);\n                    if (sVar15 < 0xfffffffffffffffe) {\n                      wVar11 = wctype(__dst);\n                      sh_xfree(__dst,\"smatch.c\",0x1fd);\n                      if (wVar11 != 0) {\n                        if (iVar4 == 0) {\n                          iVar4 = iswctype(wVar9,wVar11);\n                          local_9c = (wchar_t)(wVar9 == L'_' || iVar4 != 0);\n                        }\n                        else {\n                          local_9c = iswctype(wVar9,wVar11);\n                          if (local_9c == L'\\xffffffff') goto LAB_001c313d;\n                        }\n                        goto LAB_001c2a85;\n                      }\n                    }\n                    else {\n                      sh_xfree(__dst,\"smatch.c\",0x1f9);\n                    }\n                  }\nLAB_001c313d:\n                  local_9c = L'\\0';\n                }\n              }\nLAB_001c2a85:\n              local_c8 = pwVar20 + 2;\n              pwVar12 = pwVar20 + 3;\n              sh_xfree(pwVar10,\"sm_loop.c\",0x200);\n              pwVar13 = pwVar12;\n              if (local_9c != L'\\0') goto LAB_001c2637;\n              break;\n            }\n            pwVar20 = pwVar20 + 1;\n            wVar5 = *pwVar10;\n          }\n          wVar5 = *local_c8;\n          pwVar12 = pwVar13;\n          if (wVar5 == L'\\0') goto LAB_001c22e8;\njoined_r0x001c2391:\n          if (wVar5 == L']') goto LAB_001c220a;\njoined_r0x001c239d:\n          if ((uVar17 != 0) && (iVar4 = iswupper(wVar5), iVar4 != 0)) {\n            wVar5 = towlower(wVar5);\n          }\n        } while( true );\n      }\n      goto LAB_001c2080;\n    }\n    if ((uint)wVar5 < 0x5c) goto LAB_001c1fe8;\n    if (wVar5 != L'\\\\') goto LAB_001c2410;\n    if (pwVar14 == param_4) {\n      if (wVar9 == L'\\\\') {\n        if (param_2 == local_d0 + 1) goto LAB_001c20e7;\n        goto LAB_001c2080;\n      }\n      if (pwVar14 == param_4) goto LAB_001c2080;\n    }\n    if ((param_6 & 2) == 0) {\n      wVar5 = param_3[1];\n      pwVar14 = param_3 + 2;\n      if (param_4 < pwVar14) goto LAB_001c2080;\n      if (uVar17 != 0) {\n        iVar4 = iswupper(wVar5);\n        if (iVar4 != 0) {\n          wVar5 = towlower(wVar5);\n        }\n        iVar4 = iswupper(wVar9);\njoined_r0x001c28fb:\n        if (iVar4 != 0) {\n          wVar9 = towlower(wVar9);\n        }\n      }\n    }\n    else {\n      wVar5 = L'\\\\';\n      if (uVar17 != 0) {\n        iVar4 = iswupper(wVar9);\n        goto joined_r0x001c28fb;\n      }\n    }\n    if (wVar9 == wVar5) goto LAB_001c2215;\n    goto LAB_001c2080;\n  }\n  if ((0xc0000601UL >> ((ulong)(uint)(wVar5 + L'\\xffffffdf') & 0x3f) & 1) != 0) {\n    uVar3 = param_6 & 0xffffff7b;\n    if (param_1 == local_d0) {\n      uVar3 = param_6;\n    }\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar19 = FUN_001c1950(wVar5,local_d0,param_2,pwVar14,param_4,uVar3);\n      return uVar19;\n    }\n    goto LAB_001c31fe;\n  }\nLAB_001c1fe8:\n  if (wVar5 == L'*') {\n    if (param_5 == (wchar_t **)0x0) {\n      if (((param_6 & 4) == 0) || (wVar9 != L'.')) {\n        if (((param_6 & 0x80) != 0) &&\n           ((((param_1 == local_d0 && (*param_1 == L'.')) &&\n             ((param_1[1] == L'\\0' || ((param_1[1] == L'.' && (param_1[2] == L'\\0')))))) ||\n            ((((param_6 & 1) != 0 && ((local_d0[-1] == L'/' && (*local_d0 == L'.')))) &&\n             (((wVar5 = local_d0[1], wVar5 == L'/' || (wVar5 == L'\\0')) ||\n              ((wVar5 == L'.' && ((local_d0[2] == L'/' || (local_d0[2] == L'\\0'))))))))))))\n        goto LAB_001c2080;\n      }\n      else if ((param_1 == local_d0) || (((param_6 & 1) != 0 && (local_d0[-1] == L'/'))))\n      goto LAB_001c2080;\n      if (pwVar14 == param_4) {\nLAB_001c2622:\n        uVar19 = 0;\n      }\n      else {\n        pwVar14 = param_3 + 2;\n        wVar5 = param_3[1];\n        pwVar12 = local_d0;\n        if ((wVar5 == L'*') || (wVar5 == L'?')) {\n          do {\n            if ((wVar9 == L'/') && ((param_6 & 1) != 0)) goto LAB_001c2080;\n            local_d0 = pwVar12;\n            if (uVar21 == 0) {\n              if (wVar5 == L'?') {\nLAB_001c2542:\n                if (wVar9 == L'\\0') goto LAB_001c2080;\n                local_d0 = (wchar_t *)((long)pwVar12 + 4);\n                wVar9 = L'\\0';\n                if (local_d0 < param_2) {\n                  wVar9 = *(wchar_t *)((long)pwVar12 + 4);\n                }\n              }\n            }\n            else if (wVar5 == L'?') {\n              if (*pwVar14 != L'(') goto LAB_001c2542;\n              iVar4 = FUN_001c1950(0x3f,pwVar12,param_2,pwVar14,param_4,param_6);\n              if (iVar4 == 0) goto LAB_001c2622;\n              if (param_4 == (wchar_t *)((long)pwVar14 + 4U)) goto LAB_001c20e7;\n              pwVar14 = (wchar_t *)FUN_001bfc60((wchar_t *)((long)pwVar14 + 4U),param_4,0);\n              if (pwVar14 == (wchar_t *)0x0) {\n                uVar19 = 0;\n                goto LAB_001c2086;\n              }\n            }\n            else if ((wVar5 == L'*') && (*pwVar14 == L'(')) {\n              for (; pwVar12 < param_2; pwVar12 = pwVar12 + 1) {\n                iVar4 = FUN_001c1950(0x2a,pwVar12,param_2,pwVar14,param_4,param_6);\n                if (iVar4 == 0) goto LAB_001c2622;\n              }\n              if ((param_4 == (wchar_t *)((long)pwVar14 + 4U)) ||\n                 (pwVar14 = (wchar_t *)FUN_001bfc60((wchar_t *)((long)pwVar14 + 4U),param_4,0),\n                 pwVar14 == (wchar_t *)0x0)) goto LAB_001c2622;\n            }\n            if (param_4 == pwVar14) {\n              if (wVar5 == L'\\0') goto LAB_001c2e2d;\n              goto LAB_001c20e7;\n            }\n            wVar5 = *pwVar14;\n            pwVar14 = pwVar14 + 1;\n            pwVar12 = local_d0;\n          } while ((wVar5 == L'?') || (wVar5 == L'*'));\n        }\n        if (wVar5 != L'\\0') {\n          if (((param_2 == local_d0) && (uVar21 != 0)) && (wVar5 == L'!')) {\n            if (*pwVar14 == L'(') {\n              iVar4 = FUN_001c1950(0x21,local_d0,param_2,pwVar14 + -1,param_4,param_6);\n              uVar19 = (ulong)(iVar4 == 0);\n              goto LAB_001c2086;\n            }\nLAB_001c2b02:\n            wVar9 = param_6 & 1;\n            local_98 = (wchar_t *)0x0;\n            if (wVar9 != L'\\0') {\n              wVar9 = L'/';\n            }\n            pwVar12 = wmemchr(local_d0,wVar9,(long)param_2 - (long)local_d0 >> 2);\n            if (pwVar12 == (wchar_t *)0x0) {\n              pwVar12 = param_2;\n            }\n            local_e8 = wVar5;\n            if ((bVar1 != 0) && (wVar5 == L'\\\\')) {\n              local_e8 = *pwVar14;\n            }\n          }\n          else {\n            if (wVar5 != L'/') goto LAB_001c2b02;\n            if ((param_6 & 1) != 0) goto joined_r0x001c317b;\n            local_98 = (wchar_t *)0x0;\n            pwVar12 = wmemchr(local_d0,L'\\0',(long)param_2 - (long)local_d0 >> 2);\n            local_e8 = L'/';\n            if (pwVar12 == (wchar_t *)0x0) {\n              pwVar12 = param_2;\n            }\n          }\n          if ((uVar17 != 0) && (iVar4 = iswupper(local_e8), iVar4 != 0)) {\n            local_e8 = towlower(local_e8);\n          }\n          if (local_d0 < pwVar12) {\n            do {\n              if (((uVar21 == 0) ||\n                  ((*pwVar14 != L'(' &&\n                   (pwVar13 = wcschr(L\"?*+@!\",pwVar14[-1]), pwVar13 == (wchar_t *)0x0)))) &&\n                 (wVar5 != L'[')) {\n                wVar9 = *local_d0;\n                if ((uVar17 != 0) && (iVar4 = iswupper(wVar9), iVar4 != 0)) {\n                  wVar9 = towlower(wVar9);\n                }\n                if (wVar9 == local_e8) {\nLAB_001c2ba9:\n                  iVar4 = FUN_001c1f10(local_d0,param_2,pwVar14 + -1,param_4,&local_98,\n                                       param_6 & 0xffffff7b);\n                  if (iVar4 == 0) {\n                    param_3 = local_98;\n                    local_d0 = local_90;\n                    if (local_98 != (wchar_t *)0x0) goto LAB_001c2059;\n                    uVar19 = 0;\n                    goto LAB_001c2086;\n                  }\n                }\n              }\n              else if (local_d0 != (wchar_t *)0x0) goto LAB_001c2ba9;\n              local_d0 = local_d0 + 1;\n            } while (local_d0 < pwVar12);\n            param_3 = local_98;\n            local_d0 = local_90;\n            if (local_98 != (wchar_t *)0x0) goto LAB_001c2059;\n          }\n          goto LAB_001c2080;\n        }\nLAB_001c2e2d:\n        local_b0 = param_6 & 1;\n        uVar19 = 0;\n        if ((local_b0 != 0) && ((param_6 & 8) == 0)) {\n          pwVar14 = wmemchr(local_d0,L'/',(long)param_2 - (long)local_d0 >> 2);\n          uVar19 = (ulong)(pwVar14 != (wchar_t *)0x0);\n        }\n      }\n    }\n    else {\n      uVar19 = 0;\n      *param_5 = param_3;\n      param_5[1] = local_d0;\n    }\n    goto LAB_001c2086;\n  }\n  if (wVar5 == L'?') {\n    if (wVar9 == L'\\0') goto LAB_001c2080;\n    if ((wVar9 == L'/') && ((param_6 & 1) != 0)) goto LAB_001c2080;\n    if (((param_6 & 4) == 0) || (wVar9 != L'.')) {\n      if (((param_6 & 0x80) != 0) &&\n         ((((param_1 == local_d0 && (*param_1 == L'.')) &&\n           ((param_1[1] == L'\\0' || ((param_1[1] == L'.' && (param_1[2] == L'\\0')))))) ||\n          ((((param_6 & 1) != 0 && ((local_d0[-1] == L'/' && (*local_d0 == L'.')))) &&\n           (((wVar5 = local_d0[1], wVar5 == L'/' || (wVar5 == L'\\0')) ||\n            ((wVar5 == L'.' && ((local_d0[2] == L'/' || (local_d0[2] == L'\\0'))))))))))))\n      goto LAB_001c2080;\n    }\n    else if ((param_1 == local_d0) || (((param_6 & 1) != 0 && (local_d0[-1] == L'/'))))\n    goto LAB_001c2080;\n  }\n  else {\nLAB_001c2410:\n    if ((uVar17 != 0) && (iVar4 = iswupper(wVar9), iVar4 != 0)) {\n      wVar9 = towlower(wVar9);\n    }\n    if (wVar5 != wVar9) goto LAB_001c2080;\n  }\n  param_3 = pwVar14;\n  local_d0 = local_d0 + 1;\n  goto LAB_001c2059;\nLAB_001c22bf:\n  iVar4 = iswupper(wVar6);\n  if (iVar4 != 0) {\n    iVar4 = 0;\nLAB_001c22d3:\n    wVar6 = towlower(wVar6);\n  }\n  pwVar13 = pwVar12;\n  if (wVar5 == L'\\0') goto LAB_001c22e8;\n  goto LAB_001c2270;\n  while( true ) {\n    wVar5 = pwVar13[2];\n    iVar4 = iVar4 + 1;\n    pwVar12 = local_c8;\n    local_c8 = pwVar13 + 2;\n    wVar9 = wVar5;\n    if (wVar5 == L'\\0') break;\nLAB_001c2658:\n    do {\n      wVar6 = wVar9;\n      pwVar13 = local_c8;\n      local_c8 = pwVar13 + 1;\n      if (wVar6 != L'[') {\n        if (wVar6 == L']') {\n          if (iVar4 < 2) {\n            if (pwVar12 != (wchar_t *)0x0) {\n              wVar9 = *pwVar12;\nLAB_001c2686:\n              if (wVar9 == L'.') goto LAB_001c2d99;\n            }\n          }\n          else if (pwVar12 != (wchar_t *)0x0) {\n            wVar9 = *pwVar12;\n            if (wVar9 != wVar5) goto LAB_001c2686;\n            iVar4 = iVar4 + -1;\n            pwVar12 = (wchar_t *)0x0;\n            wVar5 = L']';\n            goto LAB_001c2f85;\n          }\n          pwVar14 = local_c8;\n          if (bVar22 || bVar23) goto LAB_001c2080;\n          goto LAB_001c2215;\n        }\nLAB_001c2d99:\n        if ((bVar1 == 0) || (wVar6 != L'\\\\')) {\n          if (wVar6 == L'\\0') goto LAB_001c22e8;\n          wVar5 = wVar6;\n          wVar9 = pwVar13[1];\n        }\n        else {\n          if (pwVar13[1] == L'\\0') goto LAB_001c2080;\n          local_c8 = pwVar13 + 2;\n          wVar5 = L'\\\\';\nLAB_001c2f85:\n          wVar9 = *local_c8;\n        }\n        goto LAB_001c2658;\n      }\n      wVar9 = pwVar13[1];\n      wVar5 = wVar6;\n    } while ((0x3d < (uint)wVar9) || ((0xdbffbfffffffffffU >> ((ulong)(uint)wVar9 & 0x3f) & 1) != 0)\n            );\n  }\nLAB_001c22e8:\n  if (local_d8 != L'[') goto LAB_001c2080;\nLAB_001c2215:\n  param_3 = pwVar14;\n  local_d0 = local_d0 + 1;\nLAB_001c2059:\n  if (param_4 <= param_3) goto LAB_001c2069;\n  goto LAB_001c1f74;\nLAB_001c220a:\n  pwVar14 = pwVar12;\n  if (!bVar22 && !bVar23) goto LAB_001c2080;\n  goto LAB_001c2215;\njoined_r0x001c317b:\n  if (param_2 <= local_d0) goto LAB_001c2080;\n  if (*local_d0 == L'/') {\n    if (local_d0 < param_2) {\n      iVar4 = FUN_001c1f10(local_d0 + 1,param_2,pwVar14,param_4,0,param_6);\n      uVar19 = (ulong)(iVar4 != 0);\n      goto LAB_001c2086;\n    }\n    goto LAB_001c2080;\n  }\n  local_d0 = local_d0 + 1;\n  goto joined_r0x001c317b;\n}\n\n",
  "undo_partial_redirects": "\nvoid undo_partial_redirects(void)\n\n{\n  long lVar1;\n  \n  lVar1 = redirection_undo_list;\n  if (redirection_undo_list != 0) {\n    do_redirections(redirection_undo_list,1);\n    dispose_redirects(lVar1);\n    redirection_undo_list = 0;\n  }\n  return;\n}\n\n",
  "pop_stream": "\nvoid pop_stream(void)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  int __fd;\n  undefined8 *puVar6;\n  int *piVar7;\n  \n  puVar6 = stream_list;\n  if (stream_list != (undefined8 *)0x0) {\n    puVar1 = stream_list + 2;\n    EOF_Reached = 0;\n    puVar2 = stream_list + 1;\n    puVar3 = stream_list + 5;\n    puVar4 = stream_list + 4;\n    puVar5 = stream_list + 3;\n    stream_list = (undefined8 *)*stream_list;\n    init_yy_io(*puVar4,*puVar3,*(undefined4 *)puVar2,*puVar1,*puVar5);\n    __fd = default_buffered_input;\n    if ((bash_input == 4) && (-1 < (int)DAT_00240a70)) {\n      piVar7 = (int *)puVar6[7];\n      if (bash_input_fd_changed != 0) {\n        bash_input_fd_changed = 0;\n        if (-1 < default_buffered_input) {\n          DAT_00240a70._0_4_ = default_buffered_input;\n          *piVar7 = default_buffered_input;\n          fcntl(__fd,2,1);\n          piVar7 = (int *)puVar6[7];\n        }\n      }\n      set_buffered_stream((int)DAT_00240a70,piVar7);\n    }\n    line_number = *(undefined4 *)(puVar6 + 6);\n    if (puVar6[2] != 0) {\n      sh_xfree(puVar6[2],\"/usr/local/src/chet/src/bash/src/parse.y\",0x715);\n    }\n    sh_xfree(puVar6,\"/usr/local/src/chet/src/bash/src/parse.y\",0x716);\n    return;\n  }\n  EOF_Reached = 1;\n  return;\n}\n\n",
  "make_absolute": "\nvoid make_absolute(char *param_1,long param_2)\n\n{\n  size_t sVar1;\n  char *__dest;\n  \n  if ((param_2 != 0) && (*param_1 != '/')) {\n    sh_makepath(param_2,param_1,0);\n    return;\n  }\n  sVar1 = strlen(param_1);\n  __dest = (char *)sh_xmalloc(sVar1 + 1,\"general.c\",0x34e);\n  strcpy(__dest,param_1);\n  return;\n}\n\n",
  "_rl_ttymsg": "\nvoid _rl_ttymsg(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n               undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n               undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_d0 = &stack0x00000008;\n  local_d8 = 8;\n  local_c8 = local_b8;\n  local_d4 = 0x30;\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  fwrite(\"readline: \",1,10,stderr);\n  __vfprintf_chk(stderr,1,param_9,&local_d8);\n  fputc(10,stderr);\n  fflush(stderr);\n  rl_forced_update_display();\n  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "bind_var_to_int": "\nvoid bind_var_to_int(undefined8 param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  undefined auStack_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = fmtulong(param_2,10,auStack_38,0x16,0);\n  bind_int_variable(param_1,uVar1,param_3);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "regfree": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid regfree(regex_t *__preg)\n\n{\n  (*(code *)PTR_regfree_002379a8)();\n  return;\n}\n\n",
  "FUN_001b44d0": "\nvoid FUN_001b44d0(int param_1,int param_2)\n\n{\n  long lVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *pcVar5;\n  bool bVar6;\n  \n  lVar1 = (&trap_list)[param_1];\n  if ((lVar1 == 0) && (iVar2 = signal_is_hard_ignored(param_1), iVar2 == 0)) {\n    bVar6 = false;\n    pcVar4 = \"-\";\n    if (param_2 == 0) {\n      return;\n    }\n  }\n  else {\n    iVar2 = signal_is_hard_ignored(param_1);\n    pcVar4 = (char *)0x0;\n    bVar6 = iVar2 == 0 && lVar1 != 1;\n    if (bVar6) {\n      pcVar4 = (char *)sh_single_quote(lVar1);\n      bVar6 = pcVar4 != (char *)0x0;\n    }\n  }\n  pcVar3 = (char *)signal_name(param_1);\n  if (*pcVar3 == 'S') {\n    iVar2 = strncmp(pcVar3,\"SIGJUNK\",7);\n    if (iVar2 != 0) {\n      if (((posixly_correct != 0) && (pcVar3[1] == 'I')) && (pcVar3[2] == 'G')) {\n        pcVar5 = \"\\'\\'\";\n        if (pcVar4 != (char *)0x0) {\n          pcVar5 = pcVar4;\n        }\n        __printf_chk(1,\"trap -- %s %s\\n\",pcVar5,pcVar3 + 3);\n        goto joined_r0x001b459e;\n      }\n      goto LAB_001b452c;\n    }\n  }\n  else if ((*pcVar3 != 'u') || (iVar2 = strncmp(pcVar3,\"unknown\",7), iVar2 != 0)) {\nLAB_001b452c:\n    pcVar5 = \"\\'\\'\";\n    if (pcVar4 != (char *)0x0) {\n      pcVar5 = pcVar4;\n    }\n    __printf_chk(1,\"trap -- %s %s\\n\",pcVar5,pcVar3);\n    goto joined_r0x001b459e;\n  }\n  pcVar3 = \"\\'\\'\";\n  if (pcVar4 != (char *)0x0) {\n    pcVar3 = pcVar4;\n  }\n  __printf_chk(1,\"trap -- %s %d\\n\",pcVar3,param_1);\njoined_r0x001b459e:\n  if (!bVar6) {\n    return;\n  }\n  sh_xfree(pcVar4,\"./trap.def\",0x11e);\n  return;\n}\n\n",
  "initialize_bashopts": "\nvoid initialize_bashopts(int param_1)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *__dest;\n  char *pcVar3;\n  \n  if (param_1 != 0) {\n    set_bashopts();\n    return;\n  }\n  lVar1 = find_variable(\"BASHOPTS\");\n  if (lVar1 != 0) {\n    if (((*(uint *)(lVar1 + 0x28) & 0x8000) != 0) && ((*(uint *)(lVar1 + 0x28) & 0x44) == 0)) {\n      pcVar3 = *(char **)(lVar1 + 8);\n      sVar2 = strlen(pcVar3);\n      __dest = (char *)sh_xmalloc(sVar2 + 1,\"./shopt.def\",0x391);\n      pcVar3 = strcpy(__dest,pcVar3);\n      parse_bashopts(pcVar3);\n      sh_xfree(pcVar3,\"./shopt.def\",0x395);\n    }\n  }\n  set_bashopts();\n  return;\n}\n\n",
  "glob_patscan": "\nundefined8 glob_patscan(long param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (param_1 != param_2) {\n    uVar1 = FUN_001bfab0();\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "FUN_0015bd90": "\nvoid FUN_0015bd90(undefined8 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  int iVar2;\n  \n  iVar2 = 0x800;\n  if (assoc_expand_once != 0) {\n    iVar2 = (-(uint)(DAT_00242350 == 0) & 0xffffff80) + 0x880;\n  }\n  lVar1 = bind_int_variable(param_1,param_2,iVar2);\n  if ((lVar1 != 0) && ((*(uint *)(lVar1 + 0x28) & 0x4002) != 0)) {\n                    /* WARNING: Subroutine does not return */\n    __longjmp_chk(&DAT_00242360,1);\n  }\n  stupidly_hack_special_variables(param_1);\n  return;\n}\n\n",
  "make_word": "\nvoid make_word(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = make_bare_word();\n  make_word_flags(uVar1,param_1);\n  return;\n}\n\n",
  "wcsdup": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nwchar_t * wcsdup(wchar_t *__s)\n\n{\n  wchar_t *pwVar1;\n  \n  pwVar1 = (wchar_t *)(*(code *)PTR_wcsdup_00237c58)();\n  return pwVar1;\n}\n\n",
  "rl_set_keymap": "\nvoid rl_set_keymap(undefined *param_1)\n\n{\n  if (param_1 != (undefined *)0x0) {\n    _rl_keymap = param_1;\n  }\n  return;\n}\n\n",
  "FUN_0019ea60": "\nvoid FUN_0019ea60(int param_1)\n\n{\n  unbind_variable_noref(\"COMP_LINE\");\n  unbind_variable_noref(\"COMP_POINT\");\n  unbind_variable_noref(\"COMP_TYPE\");\n  unbind_variable_noref(\"COMP_KEY\");\n  unbind_variable_noref(\"COMP_WORDS\");\n  unbind_variable_noref(\"COMP_CWORD\");\n  if (param_1 != 0) {\n    array_needs_making = 1;\n  }\n  return;\n}\n\n",
  "xtrace_print_assignment": "\nvoid xtrace_print_assignment(undefined8 param_1,char *param_2,int param_3,int param_4)\n\n{\n  int iVar1;\n  char *pcVar2;\n  \n  if (xtrace_fp == (FILE *)0x0) {\n    xtrace_fp = stderr;\n  }\n  if (param_4 != 0) {\n    pcVar2 = (char *)indirection_level_string();\n    fputs(pcVar2,xtrace_fp);\n  }\n  if (*param_2 == '\\0') {\n    if (param_3 == 0) {\nLAB_001458f4:\n      __fprintf_chk(xtrace_fp,1,\"%s=%s\\n\",param_1,param_2);\n      fflush(xtrace_fp);\n      return;\n    }\n  }\n  else if (param_3 == 0) {\n    iVar1 = sh_contains_shell_metas(param_2);\n    if (iVar1 == 0) {\n      iVar1 = ansic_shouldquote(param_2);\n      if (iVar1 == 0) goto LAB_001458f4;\n      pcVar2 = (char *)ansic_quote(param_2,0,0);\n    }\n    else {\n      pcVar2 = (char *)sh_single_quote();\n    }\n    __fprintf_chk(xtrace_fp,1,\"%s=%s\\n\",param_1,pcVar2);\n    if (pcVar2 != (char *)0x0 && param_2 != pcVar2) {\n      sh_xfree(pcVar2,\"print_cmd.c\",0x21e);\n      fflush(xtrace_fp);\n      return;\n    }\n    goto LAB_001458da;\n  }\n  __fprintf_chk(xtrace_fp,1,\"%s=(%s)\\n\",param_1,param_2);\nLAB_001458da:\n  fflush(xtrace_fp);\n  return;\n}\n\n",
  "strvec_len": "\nulong strvec_len(long *param_1)\n\n{\n  long *plVar1;\n  ulong uVar2;\n  ulong uVar3;\n  \n  if (*param_1 != 0) {\n    uVar2 = 1;\n    do {\n      uVar3 = uVar2 & 0xffffffff;\n      plVar1 = param_1 + uVar2;\n      uVar2 = uVar2 + 1;\n    } while (*plVar1 != 0);\n    return uVar3;\n  }\n  return 0;\n}\n\n",
  "print_assignment": "\nvoid print_assignment(undefined8 *param_1)\n\n{\n  uint uVar1;\n  undefined8 uVar2;\n  \n  if (param_1[1] == 0) {\n    return;\n  }\n  uVar1 = *(uint *)(param_1 + 5);\n  if ((uVar1 & 8) == 0) {\n    if ((uVar1 & 4) != 0) {\n      print_array_assignment(param_1,0);\n      return;\n    }\n    if ((uVar1 & 0x40) != 0) {\n      print_assoc_assignment(param_1,0);\n      return;\n    }\n    __printf_chk(1,&DAT_001fce4e,*param_1);\n    print_var_value(param_1,1);\n  }\n  else {\n    __printf_chk(1,&DAT_002102da,*param_1);\n    if (((*(byte *)(param_1 + 5) & 8) != 0) && (param_1[1] != 0)) {\n      uVar2 = named_function_string(0,param_1[1],3);\n      __printf_chk(1,&DAT_002102da,uVar2);\n    }\n  }\n  putchar(10);\n  return;\n}\n\n",
  "source_file": "\nundefined4 source_file(undefined8 param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  uint uVar2;\n  \n  uVar2 = (-(uint)(param_2 == 0) & 0xffffff00) + 0x10e;\n  if (posixly_correct != 0) {\n    if ((interactive_shell | executing_command_builtin) == 0) {\n      uVar2 = uVar2 | 0x10;\n    }\n  }\n  uVar1 = FUN_001a7e10(param_1,uVar2);\n  run_return_trap();\n  return uVar1;\n}\n\n",
  "freeze_jobs_list": "\nundefined4 freeze_jobs_list(void)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = DAT_00247660;\n  DAT_00247660 = 1;\n  return uVar1;\n}\n\n",
  "FUN_0017e240": "\nlong FUN_0017e240(char *param_1,long param_2,undefined8 param_3,char *param_4,int param_5,\n                 uint param_6)\n\n{\n  char cVar1;\n  long lVar2;\n  undefined8 uVar3;\n  uint uVar4;\n  size_t sVar5;\n  char *pcVar6;\n  long lVar7;\n  long lVar8;\n  long lVar9;\n  uint uVar10;\n  undefined8 uVar11;\n  long in_FS_OFFSET;\n  long local_50;\n  long local_48;\n  \n  uVar3 = this_command_name;\n  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 0) {\n    lVar9 = 0;\n    this_command_name = (char *)uVar3;\n    goto LAB_0017e3ef;\n  }\n  this_command_name = param_1;\n  uVar4 = FUN_0017c800();\n  if (uVar4 == 0xffffffff) {\n    lVar9 = 0;\n    this_command_name = (char *)uVar3;\n    goto LAB_0017e3ef;\n  }\n  uVar10 = uVar4 & 0xffffff7f;\n  if (param_5 == 0x23) {\n    uVar11 = 2;\n    if (*param_4 == '#') {\n      uVar11 = 1;\n      goto LAB_0017e486;\n    }\n  }\n  else if (*param_4 == '%') {\n    uVar11 = 3;\nLAB_0017e486:\n    param_4 = param_4 + 1;\n  }\n  else {\n    uVar11 = 4;\n  }\n  sVar5 = strlen(param_4);\n  pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"subst.c\",0x16fb);\n  pcVar6 = strcpy(pcVar6,param_4);\n  lVar7 = FUN_0017b240(pcVar6,param_6);\n  sh_xfree(pcVar6,\"subst.c\",0x16fd);\n  if (uVar10 == 2) {\n    if (local_48 != 0) {\n      if ((*(uint *)(local_48 + 0x28) & 4) == 0) {\n        if (((*(uint *)(local_48 + 0x28) & 0x40) != 0) && (*(long *)(local_48 + 8) != 0)) {\n          lVar9 = assoc_to_word_list();\n          goto LAB_0017e4d3;\n        }\n      }\n      else if (*(long *)(local_48 + 8) != 0) {\n        lVar9 = array_to_word_list();\nLAB_0017e4d3:\n        if (lVar9 != 0) {\n          lVar8 = FUN_00172120(lVar9,lVar7,uVar11,(-((uVar4 & 0x80) == 0) & 0x16U) + 0x2a,param_6);\n          dispose_words(lVar9);\n          if (lVar8 != 0) {\n            lVar9 = lVar8;\n            if ((param_6 & 3) == 0) {\n              lVar9 = FUN_00167220(lVar8,0);\n              sh_xfree(lVar8,\"subst.c\",0x1716);\n            }\n            goto LAB_0017e3d3;\n          }\n        }\n      }\n    }\n    goto LAB_0017e3d0;\n  }\n  if ((int)uVar10 < 3) {\n    if (uVar10 == 0) {\n      lVar8 = FUN_00167b60(local_50,lVar7,uVar11);\n      if (local_50 != 0) {\n        sh_xfree(local_50,\"subst.c\",0x1706);\n      }\n      goto LAB_0017e431;\n    }\n    if (uVar10 != 1) goto LAB_0017e3d0;\n    cVar1 = *param_1;\n    lVar8 = list_rest_of_args();\n    if (lVar8 == 0) goto LAB_0017e3d0;\n    lVar9 = FUN_00172120(lVar8,lVar7,uVar11,(int)cVar1,param_6);\n    dispose_words(lVar8);\n    if (lVar9 == 0) goto LAB_0017e3d0;\n    uVar4 = ifs_is_null;\n    if (param_6 != 0) {\n      if (lVar9 == 0) goto LAB_0017e3d0;\n      uVar4 = param_6 & 3;\n    }\n    if (uVar4 == 0) {\n      lVar8 = FUN_00167220(lVar9,0);\n      sh_xfree(lVar9,\"subst.c\",0x1724);\n      lVar9 = lVar8;\n    }\n  }\n  else {\n    if (uVar10 != 3) goto LAB_0017e3d0;\n    lVar8 = FUN_00167b60(local_50,lVar7,uVar11);\nLAB_0017e431:\n    if (lVar8 == 0) {\nLAB_0017e3d0:\n      lVar9 = 0;\n    }\n    else {\n      if ((param_6 & 3) == 0) {\n        lVar9 = FUN_00167220(lVar8,0);\n      }\n      else {\n        lVar9 = quote_string(lVar8);\n      }\n      sh_xfree(lVar8,\"subst.c\",0x170c);\n    }\n  }\nLAB_0017e3d3:\n  this_command_name = (char *)uVar3;\n  if (lVar7 != 0) {\n    sh_xfree(lVar7,\"subst.c\",0x172c);\n  }\nLAB_0017e3ef:\n  if (lVar2 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return lVar9;\n}\n\n",
  "FUN_0015e640": "\nvoid FUN_0015e640(int param_1)\n\n{\n  uint uVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  \n  lVar3 = bgpids;\n  puVar4 = (undefined8 *)((long)param_1 * 0x10 + bgpids);\n  uVar1 = *(uint *)(puVar4 + 1);\n  if (uVar1 != 0xffffffff) {\n    iVar2 = *(int *)puVar4;\n    if (iVar2 != -1) {\n      *(undefined4 *)(bgpids + 4 + (long)iVar2 * 0x10) = *(undefined4 *)((long)puVar4 + 4);\n    }\n    if (*(int *)((long)puVar4 + 4) == -1) {\n      *(int *)(pidstat_table + (ulong)(uVar1 & 0xfff) * 4) = iVar2;\n    }\n    else {\n      *(int *)(lVar3 + (long)*(int *)((long)puVar4 + 4) * 0x10) = iVar2;\n    }\n    *puVar4 = 0xffffffffffffffff;\n    *(undefined4 *)(puVar4 + 1) = 0xffffffff;\n  }\n  return;\n}\n\n",
  "FUN_0013d700": "\nchar * FUN_0013d700(undefined4 *param_1)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  long *plVar4;\n  char *__s;\n  size_t sVar5;\n  uint uVar6;\n  long in_FS_OFFSET;\n  undefined auStack_138 [264];\n  long local_30;\n  \n  uVar3 = line_number;\n  plVar4 = (long *)0x0;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  save_parser_state(auStack_138);\n  DAT_00240d70 = 0x119;\n  DAT_00240b28 = 0;\n  DAT_00240b20 = 0;\n  uVar6 = parser_state & 0x4000;\n  DAT_00240b18 = 0;\n  DAT_00240b1c = 0;\n  parser_state = parser_state & 0xffbeecff | 0x2000;\nLAB_0013d78c:\n  iVar2 = DAT_00240b58;\n  if (DAT_00240b58 != 0) goto LAB_0013d7d4;\nLAB_0013d796:\n  iVar2 = FUN_0013a230();\n  do {\n    if (iVar2 == 0x29) {\n      restore_parser_state(auStack_138);\n      if (plVar4 == (long *)&DAT_00240b00) {\nLAB_0013d920:\n        set_exit_status(1);\n        DAT_00240d70 = 10;\n        if ((interactive_shell == 0) && (posixly_correct != 0)) {\n                    /* WARNING: Subroutine does not return */\n          jump_to_top_level(1);\n        }\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level(2);\n      }\n      if (plVar4 != (long *)0x0) {\n        if (*plVar4 != 0) {\n          plVar4 = (long *)list_reverse(plVar4);\n        }\n        __s = (char *)string_list(plVar4);\n        dispose_words(plVar4);\n        if (__s != (char *)0x0) {\n          uVar3 = 0;\n          if (*__s != '\\0') {\n            sVar5 = strlen(__s);\n            uVar3 = (undefined4)sVar5;\n          }\n          goto LAB_0013d868;\n        }\n      }\n      __s = (char *)0x0;\n      uVar3 = 0;\nLAB_0013d868:\n      *param_1 = uVar3;\n      if (uVar6 != 0) {\n        parser_state = parser_state | 0x4000;\n      }\n      if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return __s;\n    }\n    if (iVar2 == 10) {\n      if (((interactive != 0) && (bash_input - 1U < 2)) &&\n         ((pushed_string_list == 0 || (*(long *)(pushed_string_list + 0x18) == 0)))) {\n        FUN_001373e0();\n      }\n      goto LAB_0013d78c;\n    }\n    if (1 < iVar2 - 0x119U) {\n      current_token = iVar2;\n      if (iVar2 == 0x131) {\n        parser_error(uVar3,\"unexpected EOF while looking for matching `)\\'\");\n      }\n      else {\n        if ((parser_state & 0x800000) == 0) {\n          FUN_00135180(0);\n        }\n        reset_parser();\n      }\n      if (plVar4 != (long *)0x0) {\n        dispose_words(plVar4);\n      }\n      restore_parser_state(auStack_138);\n      goto LAB_0013d920;\n    }\n    plVar4 = (long *)make_word_list(yylval,plVar4);\n    iVar2 = DAT_00240b58;\n    if (DAT_00240b58 == 0) goto LAB_0013d796;\nLAB_0013d7d4:\n    uVar1 = DAT_00240b50;\n    if (iVar2 - 0x119U < 2) {\n      DAT_00240b50 = 0;\n      yylval = uVar1;\n    }\n    DAT_00240b58 = 0;\n  } while( true );\n}\n\n",
  "write_history": "\nvoid write_history(undefined8 param_1)\n\n{\n  FUN_001f5220(param_1,history_length,1);\n  return;\n}\n\n",
  "_rl_adjust_point": "\nint _rl_adjust_point(char *param_1,int param_2,mbstate_t *param_3)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  int iVar3;\n  char *__s;\n  \n  sVar1 = strlen(param_1);\n  if ((param_2 < 0) || ((int)sVar1 < param_2)) {\n    iVar3 = -1;\n  }\n  else {\n    if (param_2 == 0) {\n      iVar3 = 0;\n    }\n    else {\n      iVar3 = 0;\n      do {\n        __s = param_1 + iVar3;\n        if ((_rl_utf8locale == 0) || (sVar2 = 1, *__s < '\\0')) {\n          sVar2 = (size_t)((int)sVar1 - iVar3);\n          if (param_3 == (mbstate_t *)0x0) {\n            sVar2 = __mbrlen(__s,sVar2,(mbstate_t *)0x0);\n            if (sVar2 < 0xfffffffffffffffe) goto LAB_001f6bb4;\n          }\n          else {\n            sVar2 = mbrtowc((wchar_t *)0x0,__s,sVar2,param_3);\n            if (0xfffffffffffffffd < sVar2) {\n              param_3->__count = 0;\n              param_3->__value = (_union_27)0x0;\n              iVar3 = iVar3 + 1;\n              goto LAB_001f6b7d;\n            }\nLAB_001f6bb4:\n            if (sVar2 != 0) goto LAB_001f6b7b;\n          }\n          iVar3 = iVar3 + 1;\n        }\n        else {\nLAB_001f6b7b:\n          iVar3 = iVar3 + (int)sVar2;\n        }\nLAB_001f6b7d:\n      } while (iVar3 < param_2);\n    }\n    iVar3 = iVar3 - param_2;\n  }\n  return iVar3;\n}\n\n",
  "uwp_init": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid uwp_init(void)\n\n{\n  uwcache = sh_xmalloc(0x400,\"unwind_prot.c\",0x6c);\n  _DAT_00248388 = 0x80;\n  return;\n}\n\n",
  "mbstowcs": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbstowcs(wchar_t *__pwcs,char *__s,size_t __n)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_mbstowcs_00237928)();\n  return sVar1;\n}\n\n",
  "signal_name": "\nchar * signal_name(uint param_1)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = \"invalid signal number\";\n  if ((param_1 < 0x44) && (pcVar1 = (&signal_names)[(int)param_1], pcVar1 == (char *)0x0)) {\n    pcVar1 = \"invalid signal number\";\n  }\n  return pcVar1;\n}\n\n",
  "FUN_00134b60": "\nuint FUN_00134b60(void)\n\n{\n  char cVar1;\n  ulong uVar2;\n  \n  if ((posixly_correct != 0) && (0x29 < shell_compatibility_level)) {\n    for (uVar2 = (ulong)(int)DAT_00240da0; uVar2 < DAT_00240d90; uVar2 = uVar2 + 1) {\n      cVar1 = *(char *)(DAT_00240da8 + uVar2);\n      if ((cVar1 != ' ') && (cVar1 != '\\t')) goto joined_r0x00134bb8;\n    }\n    cVar1 = *(char *)(DAT_00240da8 + uVar2);\njoined_r0x00134bb8:\n    if (cVar1 == '-') {\n      return 0;\n    }\n  }\n  if (DAT_00240d70 < 0x3c) {\n    if (-1 < DAT_00240d70) {\n      uVar2 = 1L << ((byte)DAT_00240d70 & 0x3f);\n      if ((uVar2 & 0x34000000000) != 0) {\n        return 1;\n      }\n      if ((uVar2 & 0x800000000000401) != 0) {\n        return (uint)(DAT_00240d6c != 0x7c);\n      }\n    }\n  }\n  else {\n    if (DAT_00240d70 == 0x7b) {\n      return 1;\n    }\n    if (DAT_00240d70 - 0x102U < 0x20) {\n      return (uint)(0xc0780e0fL >> ((byte)(DAT_00240d70 - 0x102U) & 0x3f)) & 1;\n    }\n  }\n  return 0;\n}\n\n",
  "FUN_0013e0a0": "\nundefined8 FUN_0013e0a0(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  uVar1 = FUN_0013d9a0();\n  if (DAT_00240b38 == 0x120) {\n    uVar2 = FUN_0013d9a0();\n    if (DAT_00240b38 == 0x120) {\n      uVar3 = FUN_0013e020();\n      uVar2 = make_cond_node(1,0,uVar2,uVar3);\n    }\n    uVar1 = make_cond_node(1,0,uVar1,uVar2);\n  }\n  if (DAT_00240b38 == 0x121) {\n    uVar2 = FUN_0013e0a0();\n    uVar1 = make_cond_node(2,0,uVar1,uVar2);\n    return uVar1;\n  }\n  return uVar1;\n}\n\n",
  "umask_builtin": "\nundefined8 umask_builtin(undefined8 param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  __mode_t _Var3;\n  uint uVar4;\n  undefined8 uVar5;\n  undefined *puVar6;\n  int iVar7;\n  int iVar8;\n  \n  iVar8 = 0;\n  iVar7 = 0;\n  reset_internal_getopt();\n  while (iVar2 = internal_getopt(param_1,&DAT_002109b0), lVar1 = loptend, iVar2 != -1) {\n    if (iVar2 == 0x53) {\n      iVar7 = iVar7 + 1;\n    }\n    else {\n      if (iVar2 != 0x70) {\n        if (iVar2 != -99) {\n          builtin_usage();\n          return 0x102;\n        }\n        builtin_help();\n        return 0x102;\n      }\n      iVar8 = iVar8 + 1;\n    }\n  }\n  if (loptend == 0) {\n    _Var3 = umask(0x12);\n    umask(_Var3);\n    if (iVar8 != 0) {\n      puVar6 = &DAT_002109ac;\n      if (iVar7 == 0) {\n        puVar6 = &DAT_00213d70;\n      }\n      __printf_chk(1,\"umask%s \",puVar6);\n    }\n    if (iVar7 == 0) {\n      __printf_chk(1,\"%04lo\\n\",_Var3);\n      goto LAB_001b612b;\n    }\n  }\n  else {\n    if ((byte)(***(char ***)(loptend + 8) - 0x30U) < 10) {\n      _Var3 = read_octal();\n      if (_Var3 == 0xffffffff) {\n        sh_erange(**(undefined8 **)(lVar1 + 8),\"octal number\");\n        return 1;\n      }\n    }\n    else {\n      _Var3 = umask(0x12);\n      umask(_Var3);\n      uVar4 = parse_symbolic_mode(**(undefined8 **)(lVar1 + 8),~_Var3 & 0x1ff);\n      if (uVar4 == 0xffffffff) {\n        return 1;\n      }\n      _Var3 = ~uVar4 & 0x1ff;\n    }\n    umask(_Var3);\n    if (iVar7 == 0) goto LAB_001b612b;\n  }\n  FUN_001b5cf0(_Var3);\nLAB_001b612b:\n  uVar5 = sh_chkwrite(0);\n  return uVar5;\n}\n\n",
  "bashline_set_event_hook": "\nvoid bashline_set_event_hook(void)\n\n{\n  rl_signal_event_hook = FUN_00194a70;\n  return;\n}\n\n",
  "rl_bind_keyseq_if_unbound_in_map": "\nundefined8 rl_bind_keyseq_if_unbound_in_map(long param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (param_1 != 0) {\n    uVar1 = FUN_001dbd80();\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "FUN_00192690": "\nvoid FUN_00192690(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  \n  uVar5 = rl_directory_completion_hook;\n  uVar6 = rl_directory_rewrite_hook;\n  uVar4 = rl_completion_entry_function;\n  uVar3 = rl_attempted_completion_function;\n  uVar2 = rl_completer_word_break_characters;\n  uVar1 = rl_ignore_some_completions_function;\n  if (dircomplete_expand == 0) {\n    rl_directory_rewrite_hook = 0;\n  }\n  else {\n    rl_directory_completion_hook = 0;\n    uVar6 = uVar5;\n  }\n  rl_attempted_completion_function = 0;\n  rl_completion_entry_function = rl_filename_completion_function;\n  rl_ignore_some_completions_function = FUN_00191d90;\n  rl_completer_word_break_characters = &DAT_001ff329;\n  rl_complete_internal();\n  rl_completion_entry_function = (code *)uVar4;\n  rl_attempted_completion_function = uVar3;\n  rl_ignore_some_completions_function = (code *)uVar1;\n  rl_completer_word_break_characters = (undefined *)uVar2;\n  if (dircomplete_expand != 0) {\n    rl_directory_completion_hook = uVar6;\n    return;\n  }\n  rl_directory_rewrite_hook = uVar6;\n  return;\n}\n\n",
  "rl_vi_rubout": "\nundefined8 rl_vi_rubout(int param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  undefined8 uVar3;\n  \n  iVar1 = rl_point;\n  if (param_1 < 0) {\n    uVar3 = rl_vi_delete(-param_1);\n    return uVar3;\n  }\n  if (rl_point == 0) {\n    rl_ding();\n    return 1;\n  }\n  if (1 < param_1) {\n    sVar2 = __ctype_get_mb_cur_max();\n    if ((1 < sVar2) && (rl_byte_oriented == 0)) {\n      rl_backward_char(param_1,param_2);\n      goto LAB_001d330f;\n    }\n  }\n  sVar2 = __ctype_get_mb_cur_max();\n  if ((sVar2 < 2) || (rl_byte_oriented != 0)) {\n    rl_point = rl_point - param_1;\n  }\n  else {\n    rl_point = _rl_find_prev_mbchar(rl_line_buffer,rl_point,1);\n  }\nLAB_001d330f:\n  if (rl_point < 0) {\n    rl_point = 0;\n  }\n  rl_kill_text(rl_point,iVar1);\n  return 0;\n}\n\n",
  "move_to_high_fd": "\nint move_to_high_fd(int param_1,int param_2,int param_3)\n\n{\n  bool bVar1;\n  bool bVar2;\n  int iVar3;\n  int iVar4;\n  long in_FS_OFFSET;\n  undefined local_34 [4];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_3 < 0x14) {\n    param_3 = getdtablesize();\n    if (param_3 < 1) {\n      bVar1 = true;\n      param_3 = 0x13;\n    }\n    else {\n      if (0x100 < param_3) {\n        param_3 = 0x100;\n      }\n      param_3 = param_3 + -1;\n      bVar1 = 3 < param_3;\n    }\n  }\n  else {\n    param_3 = param_3 + -1;\n    bVar1 = true;\n  }\n  bVar2 = (bool)(param_2 != 0 & bVar1);\n  iVar4 = param_1;\n  if (bVar2) {\n    do {\n      iVar3 = fcntl(param_3,1,local_34);\n      bVar1 = bVar2;\n      if (iVar3 == -1) goto LAB_00141d6e;\n      param_3 = param_3 + -1;\n    } while (param_3 != 3);\n  }\n  else {\nLAB_00141d6e:\n    if ((((param_1 != param_3) && (bVar1)) && (iVar3 = dup2(param_1,param_3), iVar3 != -1)) &&\n       ((iVar4 = iVar3, param_2 == 0 || (iVar3 = fileno(stderr), iVar3 != param_1)))) {\n      close(param_1);\n    }\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar4;\n}\n\n",
  "file_isdir": "\nbool file_isdir(char *param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  bool bVar2;\n  stat sStack_a8;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = stat(param_1,&sStack_a8);\n  bVar2 = false;\n  if (iVar1 == 0) {\n    bVar2 = (sStack_a8.st_mode & 0xf000) == 0x4000;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001bc210": "\nvoid FUN_001bc210(long param_1)\n\n{\n  FUN_001bbe90(*(undefined8 *)(param_1 + 8),*(undefined8 *)(param_1 + 0x10));\n  return;\n}\n\n",
  "optimize_connection_fork": "\nvoid optimize_connection_fork(int *param_1)\n\n{\n  uint *puVar1;\n  long lVar2;\n  int iVar3;\n  \n  if (*param_1 != 6) {\n    return;\n  }\n  iVar3 = *(int *)(*(long *)(param_1 + 6) + 0x18);\n  if ((((iVar3 - 0x120U < 2) || (iVar3 == 0x3b)) &&\n      ((*(byte *)(*(long *)(*(long *)(param_1 + 6) + 0x10) + 5) & 0x80) != 0)) &&\n     (((startup_state == 2 && (iVar3 = should_suppress_fork(), iVar3 != 0)) ||\n      ((((byte)subshell_environment & 2) != 0 &&\n       (iVar3 = should_optimize_fork(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10),0), iVar3 != 0))\n      )))) {\n    lVar2 = *(long *)(*(long *)(param_1 + 6) + 0x10);\n    puVar1 = (uint *)(lVar2 + 4);\n    *puVar1 = *puVar1 | 0x40;\n    puVar1 = *(uint **)(lVar2 + 0x18);\n    *puVar1 = *puVar1 | 0x40;\n    return;\n  }\n  return;\n}\n\n",
  "var_attribute_string": "\nuint var_attribute_string(long param_1,int param_2,undefined *param_3)\n\n{\n  undefined *puVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  uVar2 = *(uint *)(param_1 + 0x28);\n  uVar3 = uVar2 & 4;\n  puVar1 = param_3;\n  if ((param_2 == 0) || (posixly_correct == 0)) {\n    if (uVar3 != 0) {\n      *param_3 = 0x61;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + 1;\n      uVar3 = 1;\n    }\n    if ((uVar2 & 0x40) != 0) {\n      uVar3 = uVar3 + 1;\n      *puVar1 = 0x41;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + (int)uVar3;\n    }\n    if ((uVar2 & 8) != 0) {\n      uVar3 = uVar3 + 1;\n      *puVar1 = 0x66;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + (int)uVar3;\n    }\n    if ((uVar2 & 0x10) != 0) {\n      uVar3 = uVar3 + 1;\n      *puVar1 = 0x69;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + (int)uVar3;\n    }\n    if ((uVar2 & 0x800) != 0) {\n      uVar3 = uVar3 + 1;\n      *puVar1 = 0x6e;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + (int)uVar3;\n    }\n    if ((uVar2 & 2) != 0) {\n      uVar3 = uVar3 + 1;\n      *puVar1 = 0x72;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + (int)uVar3;\n    }\n    if ((uVar2 & 0x80) != 0) {\n      uVar3 = uVar3 + 1;\n      *puVar1 = 0x74;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + (int)uVar3;\n    }\n    if ((uVar2 & 1) != 0) {\n      uVar3 = uVar3 + 1;\n      *puVar1 = 0x78;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + (int)uVar3;\n    }\n    if ((uVar2 & 0x400) != 0) {\n      uVar3 = uVar3 + 1;\n      *puVar1 = 99;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + (int)uVar3;\n    }\n    if ((uVar2 & 0x200) != 0) {\n      uVar3 = uVar3 + 1;\n      *puVar1 = 0x6c;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + (int)uVar3;\n    }\n    if ((uVar2 & 0x100) != 0) {\n      uVar3 = uVar3 + 1;\n      *puVar1 = 0x75;\n      puVar1 = param_3 + (int)uVar3;\n    }\n  }\n  else {\n    if (uVar3 != 0) {\n      *param_3 = 0x61;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + 1;\n      uVar3 = 1;\n    }\n    if ((uVar2 & 0x40) != 0) {\n      uVar3 = uVar3 + 1;\n      *puVar1 = 0x41;\n      uVar2 = *(uint *)(param_1 + 0x28);\n      puVar1 = param_3 + (int)uVar3;\n    }\n    if ((uVar2 & 8) != 0) {\n      *puVar1 = 0x66;\n      param_3[(int)(uVar3 + 1)] = 0;\n      return uVar3 + 1;\n    }\n  }\n  *puVar1 = 0;\n  return uVar3;\n}\n\n",
  "xtrace_print_cond_term": "\nvoid xtrace_print_cond_term(int param_1,int param_2,undefined8 *param_3,char *param_4,char *param_5)\n\n{\n  char *__s;\n  \n  if (xtrace_fp == (FILE *)0x0) {\n    xtrace_fp = stderr;\n  }\n  command_string_index = 0;\n  __s = (char *)indirection_level_string();\n  fputs(__s,xtrace_fp);\n  fwrite(&DAT_001fc74e,1,3,xtrace_fp);\n  if (param_2 != 0) {\n    fwrite(&DAT_001fc61b,1,2,xtrace_fp);\n  }\n  if (param_1 == 3) {\n    __fprintf_chk(xtrace_fp,1,&DAT_002111d0,*param_3);\n    if (param_4 == (char *)0x0) {\n      param_4 = \"\\'\\'\";\n    }\n    else if (*param_4 == '\\0') {\n      param_4 = \"\\'\\'\";\n    }\n    fputs(param_4,xtrace_fp);\n  }\n  else if (param_1 == 4) {\n    if (param_4 == (char *)0x0) {\n      param_4 = \"\\'\\'\";\n    }\n    else if (*param_4 == '\\0') {\n      param_4 = \"\\'\\'\";\n    }\n    fputs(param_4,xtrace_fp);\n    __fprintf_chk(xtrace_fp,1,&DAT_002111cf,*param_3);\n    if (param_5 == (char *)0x0) {\n      param_5 = \"\\'\\'\";\n    }\n    else if (*param_5 == '\\0') {\n      param_5 = \"\\'\\'\";\n    }\n    fputs(param_5,xtrace_fp);\n  }\n  fwrite(&DAT_001fc755,1,4,xtrace_fp);\n  fflush(xtrace_fp);\n  return;\n}\n\n",
  "shell_version_string": "\nundefined * shell_version_string(void)\n\n{\n  if (DAT_00248660 != '\\0') {\n    return &DAT_00248660;\n  }\n  __snprintf_chk(&DAT_00248660,0x20,1,0x20,\"%s.%d(%d)-%s\",&DAT_001fefc0,0,1,\"release\");\n  return &DAT_00248660;\n}\n\n",
  "xtrace_print_for_command_head": "\nvoid xtrace_print_for_command_head(long param_1)\n\n{\n  char *__s;\n  \n  if (xtrace_fp == (FILE *)0x0) {\n    xtrace_fp = stderr;\n  }\n  __s = (char *)indirection_level_string();\n  fputs(__s,xtrace_fp);\n  __fprintf_chk(xtrace_fp,1,\"for %s in \",**(undefined8 **)(param_1 + 8));\n  xtrace_print_word_list(*(undefined8 *)(param_1 + 0x10),2);\n  return;\n}\n\n",
  "rl_invoking_keyseqs": "\nvoid rl_invoking_keyseqs(undefined8 param_1)\n\n{\n  rl_invoking_keyseqs_in_map(param_1,_rl_keymap);\n  return;\n}\n\n",
  "sh_getopt_alloc_istate": "\nvoid sh_getopt_alloc_istate(void)\n\n{\n  sh_xmalloc(0x20,\"getopt.c\",0xe7);\n  return;\n}\n\n",
  "rl_yank": "\nundefined8 rl_yank(void)\n\n{\n  if (DAT_0024b160 != 0) {\n    _rl_set_mark_at_pos(rl_point);\n    rl_insert_text(*(undefined8 *)(DAT_0024b160 + (long)DAT_0024b158 * 8));\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  _rl_abort_internal();\n}\n\n",
  "builtin_bind_var_to_int": "\nvoid builtin_bind_var_to_int(void)\n\n{\n  bind_var_to_int();\n  return;\n}\n\n",
  "sh_setlinebuf": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid sh_setlinebuf(FILE *param_1)\n\n{\n  char *__buf;\n  \n  if ((stdout == param_1) && (_DAT_00248ea0 == (char *)0x0)) {\n    __buf = (char *)sh_xmalloc(0x7e0,\"setlinebuf.c\",0x32);\n    _DAT_00248ea0 = __buf;\n  }\n  else {\n    __buf = (char *)0x0;\n    if ((stderr == param_1) && (_DAT_00248e98 == (char *)0x0)) {\n      __buf = (char *)sh_xmalloc(0x7e0,\"setlinebuf.c\",0x34);\n      _DAT_00248e98 = __buf;\n    }\n  }\n  setvbuf(param_1,__buf,1,0x7e0);\n  return;\n}\n\n",
  "FUN_001b1930": "\nundefined8 FUN_001b1930(int param_1)\n\n{\n  ignoreeof = (uint)(param_1 == 0x2d);\n  unbind_variable_noref(\"ignoreeof\");\n  if (ignoreeof != 0) {\n    bind_variable(\"IGNOREEOF\",&DAT_001feab5,0);\n    sv_ignoreeof(\"IGNOREEOF\");\n    return 0;\n  }\n  unbind_variable_noref(\"IGNOREEOF\");\n  sv_ignoreeof(\"IGNOREEOF\");\n  return 0;\n}\n\n",
  "coproc_active": "\nundefined4 coproc_active(void)\n\n{\n  if (((byte)DAT_0023843c & 2) == 0) {\n    return DAT_00238428;\n  }\n  return 0xffffffff;\n}\n\n",
  "FUN_001ccc42": "\nbyte * FUN_001ccc42(byte *param_1)\n\n{\n  while( true ) {\n    if (*param_1 == 0) {\n      return (byte *)0x0;\n    }\n    if ((*param_1 & 0xc0) == 0x80) break;\n    param_1 = param_1 + 1;\n  }\n  return param_1;\n}\n\n",
  "socket": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint socket(int __domain,int __type,int __protocol)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_socket_00237ed8)();\n  return iVar1;\n}\n\n",
  "FUN_001e1320": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_001e1320(int param_1,void *param_2,long param_3)\n\n{\n  void *pvVar1;\n  bool bVar2;\n  int iVar3;\n  size_t sVar4;\n  size_t sVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  \n  sVar4 = __ctype_get_mb_cur_max();\n  iVar6 = DAT_0024a894;\n  iVar7 = _rl_last_c_pos;\n  if (_rl_last_v_pos == 0) {\n    iVar8 = DAT_0024a884;\n    if ((DAT_0024a884 != 0) && (_rl_screenwidth < DAT_0024a870)) {\n      iVar8 = DAT_0024a878;\n    }\n  }\n  else {\n    iVar8 = 0;\n    if (_rl_last_v_pos == _DAT_0024a874) {\n      iVar8 = DAT_0024a884 - DAT_0024a878;\n    }\n  }\n  if ((_rl_last_c_pos == 0) && (param_1 == 0)) {\n    return;\n  }\n  iVar9 = param_1;\n  if (((int)sVar4 < 2) || (rl_byte_oriented != 0)) {\n    if (_rl_last_c_pos == param_1) {\n      return;\n    }\n  }\n  else {\n    if (DAT_0024a894 == param_1) {\n      iVar6 = memcmp(param_2,DAT_0024a8a0,(long)param_1);\n      if (iVar6 != 0) goto LAB_001e13df;\n      DAT_0024a8d4 = 1;\n      bVar2 = false;\n      iVar9 = DAT_0024a870;\n    }\n    else if (((DAT_0024a894 < param_1) && (DAT_0024a8a0 != (void *)0x0)) &&\n            (iVar3 = memcmp(param_2,DAT_0024a8a0,(long)DAT_0024a894), iVar3 == 0)) {\n      sVar5 = __ctype_get_mb_cur_max();\n      if ((sVar5 == 1) || (rl_byte_oriented != 0)) {\n        iVar9 = param_1 - iVar6;\n      }\n      else {\n        iVar9 = FUN_001e08f0(param_2,iVar6,param_1,1);\n      }\n      DAT_0024a8d4 = 1;\n      iVar9 = iVar9 + DAT_0024a870;\n      bVar2 = false;\n    }\n    else {\nLAB_001e13df:\n      if (param_1 < 1) {\n        iVar9 = 0;\n        bVar2 = true;\n      }\n      else {\n        sVar5 = __ctype_get_mb_cur_max();\n        if ((sVar5 == 1) || (rl_byte_oriented != 0)) {\n          bVar2 = true;\n        }\n        else {\n          iVar9 = FUN_001e08f0(param_2,0,param_1,1);\n          bVar2 = true;\n        }\n      }\n    }\n    pvVar1 = *(void **)PTR_DAT_00240518;\n    if (DAT_0024a8cc == 0) {\n      if ((pvVar1 < param_2) &&\n         (param_2 < (void *)((long)*(int *)(*(long *)(PTR_DAT_00240518 + 0x10) + 4 +\n                                           (long)DAT_0024a8c4 * 4) + (long)pvVar1))) {\n        bVar2 = false;\n        goto LAB_001e1688;\n      }\n    }\n    else {\n      iVar6 = 0;\n      if ((pvVar1 < param_2) &&\n         (param_2 < (void *)((long)*(int *)(*(long *)(PTR_DAT_00240518 + 0x10) + 4 +\n                                           (long)DAT_0024a8c4 * 4) + (long)pvVar1))) {\nLAB_001e1688:\n        iVar6 = (int)param_2 - (int)pvVar1;\n      }\n      if (bVar2) {\n        if ((DAT_0024a880 < param_1) || (DAT_0024a880 < iVar6 + param_1)) {\nLAB_001e1630:\n          DAT_0024a8d4 = 1;\n          iVar9 = iVar9 - iVar8;\n        }\n        else if ((_rl_screenwidth <= DAT_0024a870) && (_rl_last_v_pos == _DAT_0024a874)) {\n          iVar6 = iVar9;\n          if (DAT_0024a884 <= iVar9) {\n            iVar6 = DAT_0024a884;\n          }\n          if ((iVar8 <= iVar6) &&\n             ((DAT_0024a880 -\n              *(int *)(*(long *)(PTR_DAT_00240520 + 0x10) + (long)_rl_last_v_pos * 4)) -\n              DAT_0024a884 < param_1)) goto LAB_001e1630;\n        }\n      }\n    }\n    if (iVar7 == iVar9) {\n      return;\n    }\n    iVar6 = _rl_last_c_pos;\n    if (rl_byte_oriented == 0) goto LAB_001e1439;\n  }\n  iVar6 = _rl_last_c_pos - iVar8;\nLAB_001e1439:\n  if (((iVar9 == 0) || (iVar9 + 1 < _rl_last_c_pos - iVar9)) ||\n     ((_rl_term_autowrap != 0 && (_rl_screenwidth == iVar6)))) {\n    _rl_cr();\n    iVar7 = 0;\n    _rl_last_c_pos = 0;\n  }\n  if (iVar7 < iVar9) {\n    if (((int)sVar4 < 2) || (rl_byte_oriented != 0)) {\n      FUN_001e0800((long)iVar7 + (long)param_2,param_3 + iVar7,param_1 - iVar7);\n    }\n    else if (_rl_term_forward_char == 0) {\n      _rl_cr();\n      FUN_001e0800(param_2,param_3,param_1);\n    }\n    else {\n      do {\n        iVar7 = iVar7 + 1;\n        tputs(_rl_term_forward_char,1,_rl_output_character_function);\n      } while (iVar7 != iVar9);\n    }\n  }\n  else if (iVar9 < iVar7) {\n    _rl_backspace(iVar7 - iVar9);\n  }\n  _rl_last_c_pos = iVar9;\n  return;\n}\n\n",
  "dup": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_dup_00237a38)();\n  return iVar1;\n}\n\n",
  "rl_bind_key": "\nuint rl_bind_key(uint param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  undefined *puVar4;\n  char cVar5;\n  int iVar6;\n  char *pcVar7;\n  long in_FS_OFFSET;\n  undefined local_14 [4];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (0xff < param_1) goto LAB_001db6bc;\n  if (param_1 - 0x80 < 0x80) {\n    lVar2 = (long)_rl_convert_meta_chars_to_ascii;\n    if (_rl_convert_meta_chars_to_ascii != 0) {\n      param_1 = param_1 & 0xffffff7f;\n      if (_rl_keymap[0x1b0] == '\\x01') {\n        lVar2 = (long)(int)param_1;\n        param_1 = 0;\n        puVar4 = (undefined *)(lVar2 * 0x10 + *(long *)(_rl_keymap + 0x1b8));\n        *puVar4 = 0;\n        *(undefined8 *)(puVar4 + 8) = param_2;\n        goto LAB_001db6bc;\n      }\n      local_14[0] = 0x1b;\n      lVar3 = 2;\n      lVar2 = 1;\n      goto LAB_001db70a;\n    }\n    lVar3 = (long)(int)param_1 * 0x10;\n    pcVar7 = _rl_keymap + lVar3;\n    cVar5 = *pcVar7;\n    if (cVar5 != '\\x01') goto LAB_001db69e;\n    iVar6 = 1;\nLAB_001db74e:\n    local_14[lVar2] = (char)param_1;\nLAB_001db752:\n    local_14[iVar6] = 0;\n    rl_generic_bind(0,local_14,param_2);\n    rl_binding_keymap = _rl_keymap;\n  }\n  else {\n    lVar3 = (long)(int)param_1 * 0x10;\n    pcVar7 = _rl_keymap + lVar3;\n    cVar5 = *pcVar7;\n    if (cVar5 == '\\x01') {\n      lVar3 = 1;\n      lVar2 = 0;\nLAB_001db70a:\n      iVar1 = (int)lVar2;\n      if (param_1 == 0x5c) {\n        iVar6 = iVar1 + 2;\n        local_14[iVar1] = 0x5c;\n        local_14[lVar3] = 0x5c;\n      }\n      else {\n        if (param_1 != 0) {\n          iVar6 = (int)lVar3;\n          goto LAB_001db74e;\n        }\n        iVar6 = iVar1 + 2;\n        local_14[iVar1] = 0x5c;\n        local_14[lVar3] = 0x30;\n      }\n      goto LAB_001db752;\n    }\nLAB_001db69e:\n    if (cVar5 == '\\x02') {\n      xfree(*(undefined8 *)(pcVar7 + 8));\n    }\n    rl_binding_keymap = _rl_keymap;\n    puVar4 = _rl_keymap + lVar3;\n    *puVar4 = 0;\n    *(undefined8 *)(puVar4 + 8) = param_2;\n  }\n  param_1 = 0;\nLAB_001db6bc:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_vi_search_again": "\nundefined8 rl_vi_search_again(undefined8 param_1,int param_2)\n\n{\n  if (param_2 != 0x4e) {\n    if (param_2 == 0x6e) {\n      rl_noninc_reverse_search_again();\n    }\n    return 0;\n  }\n  rl_noninc_forward_search_again(param_1,0x4e);\n  return 0;\n}\n\n",
  "FUN_001358d0": "\nvoid FUN_001358d0(void)\n\n{\n  long *plVar1;\n  byte *pbVar2;\n  undefined8 uVar3;\n  undefined8 *puVar4;\n  uint uVar5;\n  \n  if (DAT_00240da8 != 0) {\n    sh_xfree(DAT_00240da8,\"/usr/local/src/chet/src/bash/src/parse.y\",0x7a2);\n  }\n  puVar4 = pushed_string_list;\n  DAT_00240da8 = pushed_string_list[2];\n  DAT_00240da0 = pushed_string_list[5];\n  DAT_00240d98 = pushed_string_list[4];\n  DAT_00240d90 = pushed_string_list[6];\n  DAT_00240d8c = *(undefined4 *)(pushed_string_list + 7);\n  uVar5 = parser_state & 0xfffffffd;\n  if (*(int *)(pushed_string_list + 1) != 0) {\n    uVar5 = parser_state | 2;\n  }\n  uVar3 = *pushed_string_list;\n  plVar1 = pushed_string_list + 3;\n  pushed_string_list = (undefined8 *)uVar3;\n  parser_state = uVar5;\n  if (*plVar1 != 0) {\n    pbVar2 = (byte *)(*plVar1 + 0x10);\n    *pbVar2 = *pbVar2 & 0xfd;\n  }\n  sh_xfree(puVar4,\"/usr/local/src/chet/src/bash/src/parse.y\",0x7b8);\n  FUN_001354e0();\n  return;\n}\n\n",
  "rl_resize_terminal": "\nvoid rl_resize_terminal(void)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  \n  iVar2 = _rl_screenwidth;\n  iVar1 = _rl_screenheight;\n  iVar3 = fileno(rl_instream);\n  _rl_get_screen_size(iVar3,1);\n  if ((_rl_echoing_p != 0) && ((_rl_screenwidth != iVar2 || (_rl_screenheight != iVar1)))) {\n    if ((code *)rl_redisplay_function != rl_redisplay) {\n      rl_forced_update_display();\n      return;\n    }\n    if ((rl_readline_state._3_1_ & 1) == 0) {\n      _rl_redisplay_after_sigwinch();\n      return;\n    }\n  }\n  return;\n}\n\n",
  "FUN_001d5d10": "\nundefined8 FUN_001d5d10(char *param_1)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  char *local_c0;\n  stat local_b8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_c0 = (char *)0x0;\n  pcVar3 = param_1;\n  if (rl_filename_stat_hook != (code *)0x0) {\n    sVar2 = strlen(param_1);\n    pcVar3 = (char *)xmalloc(sVar2 + 1);\n    local_c0 = strcpy(pcVar3,param_1);\n    (*rl_filename_stat_hook)(&local_c0);\n    pcVar3 = local_c0;\n  }\n  iVar1 = lstat(pcVar3,&local_b8);\n  if (iVar1 == -1) {\n    uVar4 = 0;\n    xfree(local_c0);\n    goto LAB_001d5df2;\n  }\n  uVar4 = 0x2f;\n  local_b8.st_mode = local_b8.st_mode & 0xf000;\n  if ((((local_b8.st_mode != 0x4000) && (uVar4 = 0x25, local_b8.st_mode != 0x2000)) &&\n      (uVar4 = 0x23, local_b8.st_mode != 0x6000)) &&\n     (((uVar4 = 0x40, local_b8.st_mode != 0xa000 && (uVar4 = 0x3d, local_b8.st_mode != 0xc000)) &&\n      (uVar4 = 0x7c, local_b8.st_mode != 0x1000)))) {\n    if (local_b8.st_mode == 0x8000) {\n      iVar1 = access(param_1,1);\n      if (iVar1 == 0) {\n        uVar4 = 0x2a;\n        goto LAB_001d5de8;\n      }\n    }\n    uVar4 = 0;\n  }\nLAB_001d5de8:\n  xfree(local_c0);\nLAB_001d5df2:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "executing_line_number": "\nundefined4 executing_line_number(void)\n\n{\n  int iVar1;\n  \n  if (((((executing != 0) && (DAT_0024216c == 0)) &&\n       ((variable_context == 0 || (interactive_shell == 0)))) && (DAT_00242178 != (int *)0x0)) &&\n     (((iVar1 = *DAT_00242178, iVar1 == 0xb || (iVar1 == 10)) || (iVar1 == 0xc)))) {\n    return *(undefined4 *)(*(long *)(DAT_00242178 + 6) + 4);\n  }\n  return line_number;\n}\n\n",
  "FUN_001a51a0": "\nulong FUN_001a51a0(undefined8 param_1,int param_2)\n\n{\n  char cVar1;\n  uint uVar2;\n  bool bVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  uint uVar9;\n  ulong uVar10;\n  size_t sVar11;\n  char *pcVar12;\n  char *pcVar13;\n  undefined8 *puVar14;\n  uint *puVar15;\n  size_t sVar16;\n  size_t sVar17;\n  char *__dest;\n  char **ppcVar18;\n  undefined8 uVar19;\n  long lVar20;\n  char *pcVar21;\n  undefined2 *puVar22;\n  uint uVar23;\n  uint uVar24;\n  uint uVar25;\n  uint uVar26;\n  undefined *puVar27;\n  undefined8 *puVar28;\n  uint uVar29;\n  long in_FS_OFFSET;\n  bool bVar30;\n  bool bVar31;\n  char *local_c0;\n  int local_a4;\n  uint local_a0;\n  int local_98;\n  uint local_90;\n  uint local_88;\n  undefined8 *local_80;\n  uint local_74;\n  int local_60;\n  uint local_48;\n  uint local_44;\n  long local_40;\n  \n  iVar8 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_44 = 0;\n  local_48 = 0;\n  reset_internal_getopt();\n  bVar31 = false;\n  local_a4 = 0;\n  bVar30 = false;\nswitchD_001a5289_caseD_47:\n  bVar3 = bVar30;\n  iVar5 = internal_getopt(param_1,\"+acfgilnprtuxAFGI\");\n  if (iVar5 != -1) {\n    do {\n      bVar30 = bVar3;\n      if (list_opttype == 0x2b) {\n        if (iVar5 == -99) {\nLAB_001a57f0:\n          builtin_help();\n          uVar10 = 0x102;\n        }\n        else {\n          switch(iVar5) {\n          case 0x41:\n            puVar15 = &local_44;\n            goto LAB_001a592b;\n          default:\nswitchD_001a5266_caseD_42:\n            builtin_usage();\n            uVar10 = 0x102;\n            break;\n          case 0x46:\n            puVar15 = &local_44;\n            goto LAB_001a593b;\n          case 0x47:\n            goto switchD_001a5289_caseD_47;\n          case 0x61:\n            puVar15 = &local_44;\n            goto LAB_001a58c3;\n          case 99:\n            puVar15 = &local_44;\n            goto LAB_001a58d3;\n          case 0x66:\n            puVar15 = &local_44;\n            goto LAB_001a58fb;\n          case 0x67:\n            puVar15 = &local_44;\n            goto LAB_001a590b;\n          case 0x69:\n            puVar15 = &local_44;\n            goto LAB_001a5873;\n          case 0x6c:\n            puVar15 = &local_44;\n            goto LAB_001a5883;\n          case 0x6e:\n            puVar15 = &local_44;\n            goto LAB_001a58ab;\n          case 0x70:\n            goto switchD_001a5266_caseD_70;\n          case 0x72:\n            puVar15 = &local_44;\n            goto LAB_001a5813;\n          case 0x74:\n            puVar15 = &local_44;\n            goto LAB_001a5823;\n          case 0x75:\n            puVar15 = &local_44;\n            goto LAB_001a5833;\n          case 0x78:\n            puVar15 = &local_44;\n            goto LAB_001a585b;\n          }\n        }\n        goto LAB_001a529a;\n      }\n      if (iVar5 == -99) goto LAB_001a57f0;\n      switch(iVar5) {\n      case 0x41:\n        goto switchD_001a5266_caseD_41;\n      default:\n        goto switchD_001a5266_caseD_42;\n      case 0x46:\n        puVar15 = &local_48;\nLAB_001a593b:\n        local_a4 = local_a4 + 1;\n        *puVar15 = *puVar15 | 8;\n        goto switchD_001a5289_caseD_47;\n      case 0x47:\n        bVar31 = true;\n        bVar30 = true;\n      case 0x49:\n        goto switchD_001a5289_caseD_47;\n      case 0x61:\n        puVar15 = &local_48;\nLAB_001a58c3:\n        *puVar15 = *puVar15 | 4;\n        goto switchD_001a5289_caseD_47;\n      case 99:\n        puVar15 = &local_48;\nLAB_001a58d3:\n        *puVar15 = *puVar15 | 0x400;\n        if (puVar15 == &local_48) {\n          local_44 = local_44 | 0x300;\n        }\n        goto switchD_001a5289_caseD_47;\n      case 0x66:\n        puVar15 = &local_48;\nLAB_001a58fb:\n        *puVar15 = *puVar15 | 8;\n        goto switchD_001a5289_caseD_47;\n      case 0x67:\n        puVar15 = &local_48;\nLAB_001a590b:\n        bVar30 = true;\n        if (puVar15 != &local_48) {\n          bVar30 = bVar3;\n        }\n        goto switchD_001a5289_caseD_47;\n      case 0x69:\n        puVar15 = &local_48;\nLAB_001a5873:\n        *puVar15 = *puVar15 | 0x10;\n        goto switchD_001a5289_caseD_47;\n      case 0x6c:\n        puVar15 = &local_48;\nLAB_001a5883:\n        *puVar15 = *puVar15 | 0x200;\n        if (puVar15 == &local_48) {\n          local_44 = local_44 | 0x500;\n        }\n        goto switchD_001a5289_caseD_47;\n      case 0x6e:\n        puVar15 = &local_48;\nLAB_001a58ab:\n        *puVar15 = *puVar15 | 0x800;\n        goto switchD_001a5289_caseD_47;\n      case 0x70:\nswitchD_001a5266_caseD_70:\n        iVar8 = iVar8 + 1;\n        iVar5 = internal_getopt(param_1,\"+acfgilnprtuxAFGI\");\n        if (iVar5 == -1) goto LAB_001a52e0;\n        break;\n      case 0x72:\n        puVar15 = &local_48;\nLAB_001a5813:\n        *puVar15 = *puVar15 | 2;\n        goto switchD_001a5289_caseD_47;\n      case 0x74:\n        puVar15 = &local_48;\nLAB_001a5823:\n        *puVar15 = *puVar15 | 0x80;\n        goto switchD_001a5289_caseD_47;\n      case 0x75:\n        puVar15 = &local_48;\nLAB_001a5833:\n        *puVar15 = *puVar15 | 0x100;\n        if (puVar15 == &local_48) {\n          local_44 = local_44 | 0x600;\n        }\n        goto switchD_001a5289_caseD_47;\n      case 0x78:\n        puVar15 = &local_48;\nLAB_001a585b:\n        *puVar15 = *puVar15 | 1;\n        array_needs_making = 1;\n        goto switchD_001a5289_caseD_47;\n      }\n    } while( true );\n  }\nLAB_001a52e0:\n  if (loptend == (undefined8 *)0x0) {\n    if (param_2 == 0) {\n      if (iVar8 == 0) {\n        if (local_48 == 0) {\n          if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n            uVar10 = set_builtin(0);\n            return uVar10;\n          }\n          goto LAB_001a6cb5;\n        }\n      }\n      else if ((local_48 & 0xfffffff7) == 0) {\n        show_all_var_attributes(local_48 == 0,local_a4);\n        goto LAB_001a599d;\n      }\n      set_or_show_attributes(0,local_48,local_a4);\n    }\n    else {\n      show_local_var_attributes(0,local_a4);\n    }\nLAB_001a599d:\n    if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) goto LAB_001a6cb5;\n    bVar31 = false;\n    goto LAB_001a6296;\n  }\n  local_74 = local_48 & 8;\n  if (iVar8 != 0) {\n    iVar8 = 0;\n    puVar28 = loptend;\n    do {\n      if (local_74 == 0) {\n        if (param_2 == 0) {\n          iVar5 = show_name_attributes();\n        }\n        else {\n          iVar5 = show_localname_attributes();\n        }\n      }\n      else {\n        iVar5 = show_func_attributes(*(undefined8 *)puVar28[1],local_a4);\n      }\n      if (iVar5 != 0) {\n        iVar8 = iVar8 + 1;\n        sh_notfound(*(undefined8 *)puVar28[1]);\n      }\n      puVar28 = (undefined8 *)*puVar28;\n    } while (puVar28 != (undefined8 *)0x0);\n    if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) goto LAB_001a6cb5;\n    bVar31 = iVar8 != 0;\nLAB_001a6296:\n    uVar10 = sh_chkwrite(bVar31);\n    return uVar10;\n  }\n  local_60 = 0;\n  puVar28 = loptend;\n  if ((local_74 == 0) || (local_74 = local_48 & 0x854, local_74 == 0)) goto LAB_001a5338;\n  puVar27 = &DAT_001faae2;\n  if (((local_48 & 0x800) == 0) && (puVar27 = &DAT_0020f488, (local_48 & 0x10) == 0)) {\n    if ((local_48 & 0x40) == 0) {\n      if ((local_48 & 4) != 0) {\n        puVar27 = &DAT_0020f48e;\n      }\n    }\n    else {\n      puVar27 = &DAT_0020f48b;\n    }\n  }\n  sh_invalidopt(puVar27);\n  uVar10 = 1;\n  goto LAB_001a529a;\nswitchD_001a5266_caseD_41:\n  puVar15 = &local_48;\nLAB_001a592b:\n  *puVar15 = *puVar15 | 0x40;\n  goto switchD_001a5289_caseD_47;\nLAB_001a5338:\n  pcVar13 = *(char **)puVar28[1];\n  sVar11 = strlen(pcVar13);\n  pcVar12 = (char *)sh_xmalloc(sVar11 + 1,\"./declare.def\",0x194);\n  pcVar13 = strcpy(pcVar12,pcVar13);\n  local_98 = 0;\n  uVar9 = *(uint *)(puVar28[1] + 8);\n  uVar6 = assoc_expand_once;\n  if ((assoc_expand_once != 0) && (uVar6 = uVar9 & 4, uVar6 != 0)) {\n    local_98 = 1;\n    uVar6 = 2;\n  }\n  uVar7 = assignment(pcVar13,uVar6);\n  uVar6 = local_48;\n  if ((((param_2 != 0) && (variable_context != 0)) && (*pcVar13 == '-')) && (pcVar13[1] == '\\0')) {\n    lVar20 = make_local_variable(\"-\",0);\n    if (*(long *)(lVar20 + 8) != 0) {\n      sh_xfree(*(long *)(lVar20 + 8),\"./declare.def\",0x1a8);\n    }\n    uVar19 = get_current_options();\n    *(uint *)(lVar20 + 0x28) = *(uint *)(lVar20 + 0x28) | 0x1000;\n    *(undefined8 *)(lVar20 + 8) = uVar19;\n    sh_xfree(pcVar13,\"./declare.def\",0x1ac);\n    puVar28 = (undefined8 *)*puVar28;\n    goto LAB_001a5bb1;\n  }\n  uVar25 = local_48 & 8;\n  if (uVar7 != 0) {\n    if ((local_48 & 8) == 0) {\n      pcVar13[(int)uVar7] = '\\0';\n      local_c0 = pcVar13 + (long)(int)uVar7 + 1;\n      if (pcVar13[(long)(int)uVar7 + -1] == '+') {\n        pcVar13[(long)(int)uVar7 + -1] = '\\0';\n        uVar25 = 1;\n      }\nLAB_001a540a:\n      local_90 = local_48 & 0x800;\n      if (local_90 == 0) goto LAB_001a5485;\n      iVar8 = valid_array_reference(pcVar13,0);\n      if (iVar8 == 0) {\n        iVar8 = check_selfref(pcVar13,local_c0,0);\n        if (iVar8 != 0) {\n          if (variable_context == 0) {\n            builtin_error(\"%s: nameref variable self references not allowed\",pcVar13);\n            local_60 = local_60 + 1;\n            sh_xfree(pcVar13,\"./declare.def\",0x216);\n            puVar28 = (undefined8 *)*puVar28;\n            goto LAB_001a5bb1;\n          }\n          builtin_warning(\"%s: circular name reference\");\n        }\n        if (((*local_c0 == '\\0') || ((uVar25 & 1) != 0)) ||\n           (iVar8 = valid_nameref_value(local_c0,1), iVar8 != 0)) {\nLAB_001a5485:\n          pcVar12 = strchr(pcVar13,0x5b);\n          if (pcVar12 == (char *)0x0) {\n            uVar2 = 0;\n            local_a0 = 0;\n          }\n          else {\n            if ((uVar7 == 0) && (iVar8 = valid_array_reference(pcVar13), iVar8 == 0)) {\n              sh_invalidid(pcVar13);\n              local_60 = local_60 + 1;\n              sh_xfree(pcVar13,\"./declare.def\",0x236);\n              puVar28 = (undefined8 *)*puVar28;\n              goto LAB_001a5bb1;\n            }\n            *pcVar12 = '\\0';\n            uVar2 = 1;\n            local_a0 = (uint)(uVar7 != 0);\n          }\n          iVar8 = legal_identifier(pcVar13);\n          uVar29 = local_44;\n          if (iVar8 == 0) {\n            sh_invalidid(pcVar13);\n            local_60 = local_60 + 1;\n            sh_xfree(pcVar13,\"./declare.def\",0x246);\n            puVar28 = (undefined8 *)*puVar28;\n            goto LAB_001a5bb1;\n          }\n          if (variable_context == 0) {\n            if (local_90 != 0) {\n              if (bVar3) goto LAB_001a5a68;\n              puVar14 = (undefined8 *)find_variable_noref(pcVar13);\n              if (puVar14 == (undefined8 *)0x0) {\nLAB_001a5cd6:\n                local_80 = (undefined8 *)find_variable_last_nameref(pcVar13);\n                goto LAB_001a5a9e;\n              }\n              if ((*(byte *)((long)puVar14 + 0x29) & 8) != 0) goto LAB_001a5c18;\nLAB_001a5cc0:\n              local_80 = (undefined8 *)0x0;\nLAB_001a5cc3:\n              if ((uVar6 | local_44 | uVar7) != 0) goto LAB_001a5cd6;\n              uVar7 = 0;\nLAB_001a63eb:\n              puVar14 = (undefined8 *)find_variable(pcVar13);\n              goto LAB_001a63f9;\n            }\n            if ((local_44 & 0x800) != 0) {\n              if (bVar3) goto LAB_001a6576;\n              local_80 = (undefined8 *)find_variable_last_nameref(pcVar13);\n              if ((local_80 == (undefined8 *)0x0) ||\n                 (uVar23 = *(uint *)(local_80 + 5), (uVar23 & 0x800) == 0)) goto LAB_001a5cc0;\nLAB_001a5f18:\n              if ((local_80[1] == 0) || ((uVar23 & 2) == 0)) {\n                if (((uVar6 | uVar7) != 0) || (uVar29 != 0x800)) {\n                  if (bVar3) {\n                    puVar14 = (undefined8 *)find_global_variable();\n                    if (puVar14 == (undefined8 *)0x0) goto LAB_001a5a91;\n                  }\n                  else {\n                    puVar14 = (undefined8 *)find_variable();\n                    if (puVar14 == (undefined8 *)0x0) goto LAB_001a5cc3;\n                  }\n                  goto LAB_001a604c;\n                }\n                *(uint *)(local_80 + 5) = uVar23 & 0xfffff7ff;\n                sh_xfree(pcVar13,\"./declare.def\",0x2b6);\n                puVar28 = (undefined8 *)*puVar28;\n              }\n              else {\n                sh_readonly(pcVar13);\n                local_74 = local_74 + 1;\n                sh_xfree(pcVar13,\"./declare.def\",0x2ad);\n                puVar28 = (undefined8 *)*puVar28;\n              }\n              goto LAB_001a5bb1;\n            }\n            if ((uVar7 == 0) || (local_a0 == 0)) {\nLAB_001a5a83:\n              if (bVar3) goto LAB_001a5a91;\n              goto LAB_001a5cc0;\n            }\n            if (bVar3) {\nLAB_001a5513:\n              puVar14 = (undefined8 *)find_global_variable_noref(pcVar13);\n              if (puVar14 == (undefined8 *)0x0) goto LAB_001a5a91;\n            }\n            else {\n              puVar14 = (undefined8 *)find_variable_noref(pcVar13);\n              if (puVar14 == (undefined8 *)0x0) goto LAB_001a5cd6;\n            }\n            uVar29 = *(uint *)(puVar14 + 5);\n            if ((uVar29 & 0x800) != 0) {\n              internal_warning(\"%s: removing nameref attribute\");\n              if (puVar14[1] != 0) {\n                sh_xfree(puVar14[1],\"./declare.def\",0x2c6);\n              }\n              *(uint *)(puVar14 + 5) = *(uint *)(puVar14 + 5) & 0xfffff7ff;\n              puVar14[1] = 0;\n              local_a0 = 1;\n              local_80 = (undefined8 *)0x0;\n              goto LAB_001a604c;\n            }\n            local_a0 = 1;\n            local_80 = (undefined8 *)0x0;\n            if ((uVar29 & 0x44) == 0) goto LAB_001a5559;\nLAB_001a5c4c:\n            uVar23 = 1;\n            uVar4 = uVar29 & 0x800;\n            if ((uVar29 & 0x800) != 0) {\nLAB_001a5c64:\n              if (((local_44 & 0x800) == 0) && (uVar7 != 0)) {\n                iVar8 = valid_nameref_value(local_c0);\n                if (iVar8 == 0) {\n                  builtin_error(\"`%s\\': invalid variable name for name reference\",local_c0);\n                  local_74 = local_74 + 1;\n                  sh_xfree(pcVar13,\"./declare.def\",0x32d);\n                  puVar28 = (undefined8 *)*puVar28;\n                  goto LAB_001a5bb1;\n                }\n                uVar29 = *(uint *)(puVar14 + 5);\n              }\nLAB_001a555c:\n              uVar4 = 0;\n            }\nLAB_001a5564:\n            uVar24 = uVar29;\n            if ((uVar29 & 2) == 0) {\nLAB_001a609a:\n              bVar30 = uVar7 != 0;\n              uVar24 = uVar29;\n              if (((uVar29 & 0x4002) == 0) || (!bVar30)) goto LAB_001a5596;\n            }\n            else {\nLAB_001a556c:\n              if ((local_44 & 2) != 0) {\n                sh_readonly(*puVar14);\n                local_74 = local_74 + 1;\n                sh_xfree(pcVar13,\"./declare.def\",0x347);\n                puVar28 = (undefined8 *)*puVar28;\n                goto LAB_001a5bb1;\n              }\n              bVar30 = uVar7 != 0;\n              if (((uVar24 & 0x4002) == 0) || (!bVar30)) goto LAB_001a5596;\n              sh_readonly(pcVar13);\n            }\n            local_60 = local_60 + 1;\n            sh_xfree(pcVar13,\"./declare.def\",0x34f);\n            puVar28 = (undefined8 *)*puVar28;\n            goto LAB_001a5bb1;\n          }\n          if (!bVar3) {\n            ppcVar18 = (char **)find_variable(pcVar13);\n            pcVar21 = pcVar13;\n            if (ppcVar18 == (char **)0x0) {\n              pcVar21 = (char *)nameref_transform_name(pcVar13,2);\n            }\n            else if ((((uVar6 | uVar29) & 0x800) == 0) &&\n                    ((lVar20 = find_variable_last_nameref(pcVar13,1), lVar20 == 0 ||\n                     (*(int *)(lVar20 + 0x2c) == variable_context)))) {\n              pcVar21 = *ppcVar18;\n            }\n            if ((uVar6 & 0x40) == 0) {\n              if ((uVar6 & 4 | uVar2) != 0) {\n                puVar14 = (undefined8 *)make_local_array_variable(pcVar21);\n                goto LAB_001a6026;\n              }\n              if (uVar7 != 0) {\n                if (local_90 != 0) {\n                  pcVar21 = pcVar13;\n                }\nLAB_001a6017:\n                puVar14 = (undefined8 *)make_local_variable(pcVar21);\n                goto LAB_001a6026;\n              }\n              if (local_90 == 0) goto LAB_001a6017;\n              local_80 = (undefined8 *)find_variable_last_nameref(pcVar13);\n              if (local_80 == (undefined8 *)0x0) {\n                puVar14 = (undefined8 *)find_variable(pcVar13);\n                if ((puVar14 == (undefined8 *)0x0) ||\n                   (*(int *)((long)puVar14 + 0x2c) != variable_context)) goto LAB_001a638a;\n              }\n              else {\n                puVar14 = local_80;\n                if (*(int *)((long)local_80 + 0x2c) != variable_context) {\nLAB_001a638a:\n                  puVar14 = (undefined8 *)make_local_variable(pcVar13);\n                  goto LAB_001a6026;\n                }\n              }\n            }\n            else {\n              puVar14 = (undefined8 *)make_local_assoc_variable(pcVar21);\nLAB_001a6026:\n              local_80 = (undefined8 *)0x0;\n              if (puVar14 == (undefined8 *)0x0) {\n                local_74 = local_74 + 1;\n                sh_xfree(pcVar13,\"./declare.def\",0x27d);\n                puVar28 = (undefined8 *)*puVar28;\n                goto LAB_001a5bb1;\n              }\n            }\n            if ((((*(uint *)(puVar14 + 5) & 0x802) == 0x802) && (puVar14[1] != 0)) &&\n               ((uVar29 & 0x800) != 0)) {\n              sh_readonly(pcVar13);\n              local_74 = local_74 + 1;\n              sh_xfree(pcVar13,\"./declare.def\",0x283);\n              puVar28 = (undefined8 *)*puVar28;\n              goto LAB_001a5bb1;\n            }\nLAB_001a604c:\n            uVar29 = *(uint *)(puVar14 + 5);\n            if ((uVar29 & 0x44) != 0) {\nLAB_001a5c3e:\n              if (local_90 == 0) goto LAB_001a5c4c;\n              builtin_error(\"%s: reference variable cannot be an array\",pcVar13);\n              local_74 = local_74 + 1;\n              sh_xfree(pcVar13,\"./declare.def\",0x326);\n              puVar28 = (undefined8 *)*puVar28;\n              goto LAB_001a5bb1;\n            }\n            if ((uVar29 & 0x800) != 0) {\nLAB_001a6788:\n              if (local_90 == 0) {\n                uVar23 = 0;\n                goto LAB_001a5c64;\n              }\nLAB_001a6085:\n              if ((uVar29 & 2) == 0) {\n                uVar4 = 0;\n                uVar23 = 0;\n                goto LAB_001a609a;\n              }\nLAB_001a69fa:\n              sh_readonly(pcVar13);\n              local_74 = local_74 + 1;\n              sh_xfree(pcVar13,\"./declare.def\",0x33d);\n              puVar28 = (undefined8 *)*puVar28;\n              goto LAB_001a5bb1;\n            }\n            if (local_90 == 0) {\nLAB_001a5559:\n              uVar23 = 0;\n              goto LAB_001a555c;\n            }\n            if ((uVar7 != 0) || (puVar14[1] == 0)) goto LAB_001a6085;\n            iVar8 = valid_nameref_value();\n            if (iVar8 == 0) {\n              builtin_error(\"`%s\\': invalid variable name for name reference\",puVar14[1]);\n              local_74 = local_74 + 1;\n              sh_xfree(pcVar13,\"./declare.def\",0x336);\n              puVar28 = (undefined8 *)*puVar28;\n              goto LAB_001a5bb1;\n            }\n            uVar24 = *(uint *)(puVar14 + 5);\n            if ((uVar24 & 2) != 0) goto LAB_001a69fa;\n            uVar4 = 0;\n            bVar30 = false;\n            uVar23 = 0;\nLAB_001a5596:\n            local_88 = local_44;\n            iVar8 = shell_compatibility_level;\n            uVar7 = uVar6 & 0x44;\n            if (((local_44 & 4) != 0) && ((uVar24 & 4) != 0)) {\nLAB_001a673c:\n              builtin_error(\"%s: cannot destroy array variables in this way\",pcVar13);\n              local_74 = local_74 + 1;\n              sh_xfree(pcVar13,\"./declare.def\",0x35a);\n              puVar28 = (undefined8 *)*puVar28;\n              goto LAB_001a5bb1;\n            }\n            if ((local_44 & 0x40) == 0) {\n              if (((uVar6 & 4) != 0) && ((uVar24 & 0x40) != 0)) {\n                builtin_error(\"%s: cannot convert associative to indexed array\",pcVar13);\n                local_74 = local_74 + 1;\n                sh_xfree(pcVar13,\"./declare.def\",0x360);\n                puVar28 = (undefined8 *)*puVar28;\n                goto LAB_001a5bb1;\n              }\n            }\n            else if ((uVar24 & 0x40) != 0) goto LAB_001a673c;\n            if (((uVar6 & 0x40) != 0) && ((uVar24 & 4) != 0)) {\n              builtin_error(\"%s: cannot convert indexed to associative array\",pcVar13);\n              local_74 = local_74 + 1;\n              sh_xfree(pcVar13,\"./declare.def\",0x366);\n              puVar28 = (undefined8 *)*puVar28;\n              goto LAB_001a5bb1;\n            }\n            uVar29 = local_a0 & uVar23;\n            if (uVar29 == 0) {\n              uVar29 = uVar2 | uVar7 | uVar23;\n              if (uVar29 != 0) goto LAB_001a55f1;\nLAB_001a67eb:\n              uVar24 = 0;\n              uVar7 = 0;\n            }\n            else {\n              uVar24 = uVar29;\n              if (uVar7 == 0) goto LAB_001a569e;\nLAB_001a55f1:\n              if (!bVar30) {\n                uVar29 = 0;\n                goto LAB_001a67eb;\n              }\n              cVar1 = *local_c0;\n              if (cVar1 == '\\0') {\nLAB_001a5691:\n                uVar7 = 0;\n                uVar29 = 1;\n                uVar24 = 1;\n              }\n              else {\n                iVar5 = 1;\n                if ((local_c0[1] != '\\0') && (iVar5 = 2, local_c0[2] != '\\0')) {\n                  sVar11 = strlen(local_c0);\n                  iVar5 = (int)sVar11;\n                }\n                if ((iVar8 < 0x2c) || ((uVar9 & 0x8000) != 0)) {\n                  if ((cVar1 != '(') || (local_c0[(long)iVar5 + -1] != ')')) goto LAB_001a5691;\n                  if ((iVar8 < 0x2c) || ((uVar9 & 0x8000) != 0)) {\n                    uVar24 = 0;\n                    uVar29 = 1;\n                    uVar7 = 1;\n                  }\n                  else {\n                    uVar29 = 1;\n                    uVar24 = 1;\n                    uVar7 = 0;\n                  }\n                }\n                else {\n                  if ((cVar1 != '(') || (local_c0[(long)iVar5 + -1] != ')')) goto LAB_001a5691;\n                  uVar23 = uVar7 | uVar23;\n                  if (uVar23 == 0) {\n                    internal_warning(\"%s: quoted compound array assignment deprecated\",\n                                     *(undefined8 *)puVar28[1]);\n                  }\n                  uVar7 = (uint)(uVar23 != 0);\n                  uVar29 = uVar2 | uVar23 != 0;\n                  uVar24 = uVar2;\n                }\n              }\n            }\nLAB_001a569e:\n            uVar9 = *(uint *)(puVar14 + 5);\n            if ((uVar6 & 0x40) == 0) {\n              if (((uVar2 | uVar6 & 4) != 0) && ((uVar9 & 0x44) == 0)) {\n                puVar14 = (undefined8 *)convert_var_to_array(puVar14);\n                uVar9 = *(uint *)(puVar14 + 5);\n              }\n            }\n            else if ((uVar9 & 0x40) == 0) {\n              puVar14 = (undefined8 *)convert_var_to_assoc(puVar14);\n              uVar9 = *(uint *)(puVar14 + 5);\n            }\n            if (local_90 != 0) {\n              uVar9 = uVar9 & 0xfffff8ef;\n              *(uint *)(puVar14 + 5) = uVar9;\n            }\n            local_44 = local_88 & 0xfffff7ff;\n            local_48 = uVar6 & 0xfffff7ff;\n            uVar2 = uVar6 & 0xfffff7ff;\n            local_a0 = local_88 & 0x800;\n            uVar26 = (local_48 | uVar9) & ~local_44;\n            *(uint *)(puVar14 + 5) = uVar26;\n            uVar23 = uVar6;\n            if ((uVar9 & 0x44 | uVar29) == 0) {\nLAB_001a5722:\n              uVar2 = uVar23;\n              if ((pcVar12 == (char *)0x0) || (uVar24 == 0)) {\n                if (uVar24 == 0) {\n                  if (bVar30) {\n                    if (local_90 == 0) {\n                      if ((uVar26 & 0x800) != 0) {\n                        uVar25 = uVar25 | 0x10;\n                      }\n                      lVar20 = bind_variable_value(puVar14,local_c0,uVar25);\n                      if ((lVar20 == 0) &&\n                         (local_90 = *(uint *)(puVar14 + 5) & 0x800, local_90 != 0)) {\nLAB_001a6891:\n                        iVar8 = valid_nameref_value(local_c0,1);\n                        if (iVar8 == 0) {\n                          sh_invalidid(local_c0);\n                        }\n                        local_60 = local_60 + 1;\n                        if (uVar4 != 0) {\n                          uVar19 = shell_variables;\n                          if (bVar3) {\n                            uVar19 = global_variables;\n                          }\n                          delete_var(*puVar14,uVar19);\n                        }\n                        local_48 = uVar23;\n                        local_44 = local_88;\n                        sh_xfree(pcVar13,\"./declare.def\",0x3dd);\n                        puVar28 = (undefined8 *)*puVar28;\n                        goto LAB_001a5bb1;\n                      }\n                    }\n                    else {\n                      lVar20 = bind_variable_value(puVar14,local_c0,uVar25 | 0x10);\n                      if (lVar20 == 0) goto LAB_001a6891;\n                    }\n                  }\n                }\n                else if ((uVar26 & 0x40) == 0) {\n                  bind_array_variable(pcVar13,0,local_c0,uVar25 | 0x20);\n                }\n                else {\n                  puVar22 = (undefined2 *)sh_xmalloc(2,\"./declare.def\",0x3c6);\n                  *puVar22 = 0x30;\n                  bind_assoc_variable(puVar14,pcVar13,puVar22,local_c0);\n                }\n              }\n              else {\n                *pcVar12 = '[';\n                puVar14 = (undefined8 *)\n                          assign_array_element(pcVar13,local_c0,local_98 << 7 | uVar25 | 0x800,0);\n                *pcVar12 = '\\0';\n                if (puVar14 == (undefined8 *)0x0) {\n                  local_60 = local_60 + 1;\n                  local_48 = uVar23;\n                  local_44 = local_88;\n                  sh_xfree(pcVar13,\"./declare.def\",0x3bf);\n                  puVar28 = (undefined8 *)*puVar28;\n                  goto LAB_001a5bb1;\n                }\n              }\n            }\n            else {\n              if (((uVar7 & 1) == 0) || (!bVar30)) {\n                local_90 = 0;\n                uVar23 = uVar2;\n                goto LAB_001a5722;\n              }\n              assign_array_var_from_string(puVar14,local_c0,uVar25 | 0x20);\n              local_90 = 0;\n            }\n            uVar9 = *(uint *)(puVar14 + 5);\n            if (((uVar6 & 3) != 0) && ((uVar9 & 0x100000) != 0)) {\n              lVar20 = find_tempenv_variable(*puVar14);\n              if (lVar20 != 0) {\n                pcVar12 = (char *)puVar14[1];\n                if (pcVar12 == (char *)0x0) {\n                  pcVar12 = (char *)sh_xmalloc(1,\"./declare.def\",0x3f2);\n                  *pcVar12 = '\\0';\n                }\n                else {\n                  sVar11 = strlen(pcVar12);\n                  pcVar21 = (char *)sh_xmalloc(sVar11 + 1,\"./declare.def\",0x3f2);\n                  pcVar12 = strcpy(pcVar21,pcVar12);\n                }\n                lVar20 = bind_variable(*puVar14,pcVar12,0);\n                if (lVar20 != 0) {\n                  uVar9 = *(uint *)(puVar14 + 5) & 0xffefffff | *(uint *)(lVar20 + 0x28);\n                  *(uint *)(lVar20 + 0x28) = uVar9;\n                  if (0 < *(int *)(lVar20 + 0x2c)) {\n                    *(uint *)(lVar20 + 0x28) = uVar9 | 0x200000;\n                  }\n                }\n                sh_xfree(pcVar12,\"./declare.def\",0x3fa);\n              }\n              uVar9 = *(uint *)(puVar14 + 5) | 0x200000;\n            }\n            *(uint *)(puVar14 + 5) = (uVar9 | local_90) & ~local_a0;\n            local_44 = local_88;\n            if (local_80 != (undefined8 *)0x0) {\n              if ((local_88 & 2) != 0) {\n                local_88 = local_88 & 0xfffffffd;\n              }\n              *(uint *)(local_80 + 5) = *(uint *)(local_80 + 5) & ~local_88;\n              local_44 = local_88;\n            }\n            local_48 = uVar2;\n            stupidly_hack_special_variables(pcVar13);\n            sh_xfree(pcVar13,\"./declare.def\",0x412);\n            puVar28 = (undefined8 *)*puVar28;\n            goto LAB_001a5bb1;\n          }\n          if (local_90 != 0) {\nLAB_001a5a68:\n            puVar14 = (undefined8 *)find_global_variable_noref(pcVar13);\n            if (puVar14 == (undefined8 *)0x0) goto LAB_001a5a91;\n            if ((*(byte *)((long)puVar14 + 0x29) & 8) == 0) goto LAB_001a5a83;\nLAB_001a5c18:\n            uVar29 = *(uint *)(puVar14 + 5);\n            local_80 = (undefined8 *)0x0;\n            if ((uVar29 & 0x44) == 0) goto LAB_001a6788;\n            goto LAB_001a5c3e;\n          }\n          if ((local_44 & 0x800) == 0) {\n            if (uVar7 != 0) {\n              if (local_a0 != 0) goto LAB_001a5513;\n              goto LAB_001a5a83;\n            }\n          }\n          else {\nLAB_001a6576:\n            local_80 = (undefined8 *)find_global_variable_last_nameref(pcVar13);\n            if (local_80 != (undefined8 *)0x0) {\n              uVar23 = *(uint *)(local_80 + 5);\n              if ((uVar23 & 0x800) == 0) goto LAB_001a5a83;\n              goto LAB_001a5f18;\n            }\n          }\nLAB_001a5a91:\n          local_80 = (undefined8 *)find_global_variable_last_nameref(pcVar13);\nLAB_001a5a9e:\n          if ((local_80 == (undefined8 *)0x0) || ((*(byte *)((long)local_80 + 0x29) & 8) == 0)) {\n            if (!bVar3) {\n              local_80 = (undefined8 *)0x0;\n              goto LAB_001a63eb;\n            }\n            if (bVar31) {\n              puVar14 = (undefined8 *)find_variable();\n              if (((puVar14 != (undefined8 *)0x0) && ((*(byte *)(puVar14 + 5) & 0x20) != 0)) &&\n                 (*(int *)((long)puVar14 + 0x2c) == variable_context)) {\n                local_80 = (undefined8 *)0x0;\n                goto LAB_001a604c;\n              }\n              puVar14 = (undefined8 *)find_global_variable(pcVar13);\n              local_80 = (undefined8 *)0x0;\n            }\n            else {\n              puVar14 = (undefined8 *)find_global_variable(pcVar13);\n              local_80 = (undefined8 *)0x0;\n            }\nLAB_001a63f9:\n            if (puVar14 != (undefined8 *)0x0) goto LAB_001a604c;\n            if ((uVar6 & 0x40) == 0) {\n              if ((uVar6 & 4 | uVar2) == 0) {\n                if (bVar3) {\n                  puVar14 = (undefined8 *)bind_global_variable();\n                }\n                else {\n                  puVar14 = (undefined8 *)bind_variable(pcVar13,0,0x20);\n                }\n              }\n              else {\n                puVar14 = (undefined8 *)make_new_array_variable(pcVar13);\n              }\n            }\n            else {\n              puVar14 = (undefined8 *)make_new_assoc_variable(pcVar13);\n            }\n            if (puVar14 != (undefined8 *)0x0) {\n              uVar29 = *(uint *)(puVar14 + 5);\n              if (uVar7 != 0) {\n                uVar4 = 1;\n                uVar23 = 0;\n                goto LAB_001a5564;\n              }\n              uVar24 = uVar29 | 0x1000;\n              *(uint *)(puVar14 + 5) = uVar24;\n              if ((uVar29 & 2) == 0) {\n                uVar4 = 1;\n                bVar30 = false;\n                uVar23 = 0;\n                goto LAB_001a5596;\n              }\n              uVar4 = 1;\n              uVar23 = 0;\n              goto LAB_001a556c;\n            }\n            sh_xfree(pcVar13,\"./declare.def\",0x318);\n            puVar28 = (undefined8 *)*puVar28;\n            goto LAB_001a5bb1;\n          }\n          if (bVar3) {\n            puVar14 = (undefined8 *)find_global_variable();\n          }\n          else {\n            puVar14 = (undefined8 *)find_variable(local_80[1]);\n          }\n          if (puVar14 != (undefined8 *)0x0) goto LAB_001a604c;\n          pcVar21 = (char *)local_80[1];\n          sVar11 = strlen(pcVar21);\n          if (pcVar12 == (char *)0x0) {\n            sVar16 = strlen(local_c0);\n            __dest = (char *)sh_xmalloc(sVar11 + 3 + sVar16,\"./declare.def\",0xbb);\n            strcpy(__dest,pcVar21);\n          }\n          else {\n            *pcVar12 = '[';\n            sVar16 = strlen(pcVar12);\n            sVar17 = strlen(local_c0);\n            __dest = (char *)sh_xmalloc(sVar11 + sVar16 + 3 + sVar17,\"./declare.def\",0xbb);\n            strcpy(__dest,pcVar21);\n            strcpy(__dest + sVar11,pcVar12);\n            sVar11 = sVar11 + sVar16;\n          }\n          if (uVar7 == 0) {\n            sh_xfree(pcVar13,\"./declare.def\",0x2e2);\n          }\n          else {\n            if (uVar25 != 0) {\n              __dest[sVar11] = '+';\n              sVar11 = sVar11 + 1;\n            }\n            __dest[sVar11] = '=';\n            if (*local_c0 == '\\0') {\n              __dest[sVar11 + 1] = '\\0';\n            }\n            else {\n              strcpy(__dest + sVar11 + 1,local_c0);\n            }\n            sh_xfree(pcVar13,\"./declare.def\",0x2e2);\n            uVar7 = assignment(__dest,0);\n            if (uVar7 == 0) goto LAB_001a6110;\n            lVar20 = (long)(int)(uVar7 - 1);\n            if (uVar25 == 0) {\n              lVar20 = (long)(int)uVar7;\n            }\n            __dest[lVar20] = '\\0';\n            local_c0 = __dest + (long)(int)uVar7 + 1;\n          }\n          pcVar13 = __dest;\n          if ((local_44 & 0x800) != 0) {\n            *(uint *)(local_80 + 5) = *(uint *)(local_80 + 5) & 0xfffff7ff;\n          }\n          goto LAB_001a5485;\n        }\n        builtin_error(\"`%s\\': invalid variable name for name reference\",local_c0);\n        local_60 = local_60 + 1;\n        sh_xfree(pcVar13,\"./declare.def\",0x21f);\n        puVar28 = (undefined8 *)*puVar28;\n      }\n      else {\n        builtin_error(\"%s: reference variable cannot be an array\",pcVar13);\n        local_74 = local_74 + 1;\n        sh_xfree(pcVar13,\"./declare.def\",0x20b);\n        puVar28 = (undefined8 *)*puVar28;\n      }\n      goto LAB_001a5bb1;\n    }\n    builtin_error(\"cannot use `-f\\' to make functions\");\n    sh_xfree(pcVar13,\"./declare.def\",0x1b6);\n    uVar10 = 1;\n    goto LAB_001a529a;\n  }\n  if (uVar25 == 0) {\n    local_c0 = \"\";\n    goto LAB_001a540a;\n  }\n  if ((posixly_correct == 0) || (iVar8 = legal_identifier(pcVar13), iVar8 != 0)) {\n    ppcVar18 = (char **)find_function(pcVar13);\n    if (ppcVar18 == (char **)0x0) {\n      local_74 = local_74 + 1;\n    }\n    else {\n      if (((*(uint *)(ppcVar18 + 5) & 2) != 0) && ((local_44 & 2) != 0)) {\n        builtin_error(\"%s: readonly function\",pcVar13);\n        local_74 = local_74 + 1;\n        sh_xfree(pcVar13,\"./declare.def\",0x1d2);\n        puVar28 = (undefined8 *)*puVar28;\n        goto LAB_001a5bb1;\n      }\n      if ((uVar6 == 8) && (local_44 == 0)) {\n        if (local_a4 == 0) {\n          pcVar12 = (char *)named_function_string(pcVar13,ppcVar18[1],3);\n        }\n        else {\n          pcVar12 = *ppcVar18;\n          if (debugging_mode != 0) {\n            lVar20 = find_function_def();\n            if (lVar20 == 0) {\n              puts(*ppcVar18);\n            }\n            else {\n              __printf_chk(1,\"%s %d %s\\n\",*ppcVar18,*(undefined4 *)(lVar20 + 4));\n            }\n            goto LAB_001a5b9d;\n          }\n        }\n        puts(pcVar12);\n        local_74 = sh_chkwrite(local_74);\n      }\n      else {\n        local_44 = local_44 & 0xfffffff7;\n        *(uint *)(ppcVar18 + 5) = (*(uint *)(ppcVar18 + 5) | uVar6) & ~local_44;\n      }\n    }\nLAB_001a5b9d:\n    sh_xfree(pcVar13,\"./declare.def\",0x1f2);\n    puVar28 = (undefined8 *)*puVar28;\n  }\n  else {\n    sh_invalidid(pcVar13);\n    local_60 = local_60 + 1;\n    sh_xfree(pcVar13,\"./declare.def\",0x1c7);\n    puVar28 = (undefined8 *)*puVar28;\n  }\nLAB_001a5bb1:\n  if (puVar28 == (undefined8 *)0x0) {\n    uVar10 = 0x104;\n    if (local_60 == 0) {\n      uVar10 = (ulong)(local_74 != 0);\n    }\nLAB_001a529a:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return uVar10;\n    }\nLAB_001a6cb5:\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  goto LAB_001a5338;\nLAB_001a6110:\n  sh_invalidid(__dest);\n  local_60 = local_60 + 1;\n  sh_xfree(__dest,\"./declare.def\",0x2ef);\n  puVar28 = (undefined8 *)*puVar28;\n  goto LAB_001a5bb1;\n}\n\n",
  "eval_builtin": "\nundefined8 eval_builtin(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = no_options();\n  if ((int)uVar1 == 0) {\n    if (loptend != 0) {\n      uVar1 = string_list();\n      uVar1 = evalstring(uVar1,&DAT_001faacc,4);\n      return uVar1;\n    }\n  }\n  else {\n    uVar1 = 0x102;\n  }\n  return uVar1;\n}\n\n",
  "print_func_list": "\nvoid print_func_list(undefined8 *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    return;\n  }\n  for (; puVar1 = (undefined8 *)*param_1, puVar1 != (undefined8 *)0x0; param_1 = param_1 + 1) {\n    __printf_chk(1,&DAT_002111d0,*puVar1);\n    if (((*(byte *)(puVar1 + 5) & 8) != 0) && (puVar1[1] != 0)) {\n      uVar2 = named_function_string(0,puVar1[1],3);\n      __printf_chk(1,&DAT_002102da,uVar2);\n    }\n    putchar(10);\n  }\n  return;\n}\n\n",
  "_rl_vi_textmod_command": "\nuint _rl_vi_textmod_command(uint param_1)\n\n{\n  char *pcVar1;\n  \n  if (param_1 != 0) {\n    pcVar1 = strchr(\"_*\\\\AaIiCcDdPpYyRrSsXx~\",param_1);\n    return (uint)(pcVar1 != (char *)0x0);\n  }\n  return param_1;\n}\n\n",
  "rl_clear_screen": "\nundefined8 rl_clear_screen(void)\n\n{\n  if (rl_explicit_arg == 0) {\n    _rl_clear_screen(0);\n    _rl_keep_mark_active = _rl_keep_mark_active + 1;\n    rl_forced_update_display();\n  }\n  else {\n    _rl_refresh_line();\n  }\n  rl_display_fixed = 1;\n  return 0;\n}\n\n",
  "maybe_set_error_trap": "\nvoid maybe_set_error_trap(char *param_1)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  \n  if ((DAT_00247f48 & 1) != 0) {\n    return;\n  }\n  sVar1 = strlen(param_1);\n  pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"trap.c\",0x31a);\n  pcVar2 = strcpy(pcVar2,param_1);\n  FUN_001815b0(0x42,pcVar2);\n  return;\n}\n\n",
  "builtin_bind_variable": "\nvoid builtin_bind_variable(undefined8 param_1,undefined8 param_2,uint param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  uVar4 = assoc_expand_once;\n  uVar3 = param_3;\n  if (assoc_expand_once != 0) {\n    uVar3 = param_3 | 0x80;\n    uVar4 = 3;\n  }\n  if ((param_3 & 0x80) != 0) {\n    uVar4 = uVar4 | 1;\n  }\n  if ((param_3 & 0x1000) != 0) {\n    uVar4 = uVar4 | 2;\n  }\n  iVar1 = valid_array_reference(param_1,uVar4);\n  if (iVar1 == 0) {\n    lVar2 = bind_variable(param_1,param_2,param_3);\n  }\n  else {\n    lVar2 = assign_array_element(param_1,param_2,uVar3 | 0x800,0);\n  }\n  if ((lVar2 != 0) && ((*(uint *)(lVar2 + 0x28) & 0x4002) == 0)) {\n    *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) & 0xffffefff;\n  }\n  return;\n}\n\n",
  "find_variable_notempenv": "\nvoid find_variable_notempenv(undefined8 param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = FUN_00152c60(param_1,0);\n  if ((lVar1 != 0) && ((*(byte *)(lVar1 + 0x29) & 8) != 0)) {\n    find_variable_nameref(lVar1);\n    return;\n  }\n  return;\n}\n\n",
  "_rl_peek_macro_key": "\nint _rl_peek_macro_key(void)\n\n{\n  if (rl_executing_macro != 0) {\n    if (*(char *)(rl_executing_macro + DAT_0024b1a0) != '\\0') {\n      return (int)*(char *)(rl_executing_macro + DAT_0024b1a0);\n    }\n    if ((DAT_0024b188 != 0) && (*(char **)(DAT_0024b188 + 8) != (char *)0x0)) {\n      return (int)**(char **)(DAT_0024b188 + 8);\n    }\n  }\n  return 0;\n}\n\n",
  "make_word_flags": "\nlong make_word_flags(long param_1,char *param_2)\n\n{\n  byte *__s;\n  byte bVar1;\n  mbstate_t mVar2;\n  size_t sVar3;\n  size_t sVar4;\n  ulong uVar5;\n  int iVar6;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar3 = strlen(param_2);\n  if (sVar3 != 0) {\n    iVar6 = 0;\n    uVar5 = 0;\nLAB_00142f13:\n    do {\n      mVar2 = local_48;\n      __s = (byte *)(param_2 + uVar5);\n      bVar1 = *__s;\n      if (bVar1 == 0x24) {\n        *(uint *)(param_1 + 8) = *(uint *)(param_1 + 8) | 1;\n      }\n      else if ((char)bVar1 < '%') {\n        if (bVar1 == 0x22) {\nLAB_00142ed0:\n          *(uint *)(param_1 + 8) = *(uint *)(param_1 + 8) | 2;\n        }\n      }\n      else if ((bVar1 == 0x27) || (bVar1 == 0x60)) goto LAB_00142ed0;\n      if (locale_mb_cur_max < 2) goto LAB_00142f0b;\n      bVar1 = *__s;\n      if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) != 0) {\nLAB_00142f40:\n        iVar6 = iVar6 + 1;\nLAB_00142f47:\n        uVar5 = (ulong)iVar6;\n        if (sVar3 <= uVar5) break;\n        goto LAB_00142f13;\n      }\n      if ((locale_utf8locale == 0) || ((char)bVar1 < '\\0')) {\n        sVar4 = mbrtowc((wchar_t *)0x0,(char *)__s,sVar3 - uVar5,&local_48);\n        if ((sVar4 < 0xfffffffffffffffe) && (mVar2 = local_48, sVar4 != 0)) {\n          iVar6 = iVar6 + (int)sVar4;\n          goto LAB_00142f47;\n        }\n      }\n      else if (bVar1 != 0) goto LAB_00142f40;\nLAB_00142f0b:\n      local_48 = mVar2;\n      iVar6 = iVar6 + 1;\n      uVar5 = (ulong)iVar6;\n    } while (uVar5 < sVar3);\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return param_1;\n}\n\n",
  "FUN_00192190": "\nundefined4 FUN_00192190(undefined8 param_1)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  \n  uVar2 = bash_tilde_expand(param_1,0);\n  uVar1 = file_isdir(uVar2);\n  sh_xfree(uVar2,\"bashline.c\",0xc38);\n  return uVar1;\n}\n\n",
  "getegid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__gid_t getegid(void)\n\n{\n  __gid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_getegid_00237c20)();\n  return _Var1;\n}\n\n",
  "show_all_var_attributes": "\nundefined8 show_all_var_attributes(int param_1,undefined4 param_2)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  undefined8 uVar5;\n  \n  if (param_1 == 0) {\n    puVar3 = (undefined8 *)all_shell_functions();\n  }\n  else {\n    puVar3 = (undefined8 *)all_shell_variables();\n  }\n  if (puVar3 == (undefined8 *)0x0) {\n    uVar5 = 0;\n  }\n  else {\n    ppcVar1 = (char **)*puVar3;\n    puVar4 = puVar3;\n    while (ppcVar1 != (char **)0x0) {\n      puVar4 = puVar4 + 1;\n      if ((((variable_context == 0) || (variable_context != *(int *)((long)ppcVar1 + 0x2c))) ||\n          (**ppcVar1 != '-')) || ((*ppcVar1)[1] != '\\0')) {\n        show_var_attributes(ppcVar1,this_shell_builtin == readonly_builtin ||\n                                    this_shell_builtin == export_builtin,param_2);\n        iVar2 = sh_chkwrite(0);\n      }\n      else {\n        puts(\"local -\");\n        iVar2 = sh_chkwrite(0);\n      }\n      if (iVar2 != 0) {\n        uVar5 = 1;\n        goto LAB_001b32a3;\n      }\n      ppcVar1 = (char **)*puVar4;\n    }\n    uVar5 = 0;\nLAB_001b32a3:\n    sh_xfree(puVar3,\"./setattr.def\",0x176);\n  }\n  return uVar5;\n}\n\n",
  "FUN_001d4e70": "\nbool FUN_001d4e70(int param_1,uint param_2)\n\n{\n  ulong uVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 uVar4;\n  ulong uVar5;\n  \n  lVar3 = _rl_scxt_alloc(2,0);\n  if (param_1 == -1) {\n    *(uint *)(lVar3 + 4) = *(uint *)(lVar3 + 4) | 1;\n  }\n  if (((rl_editing_mode == 0) && (_rl_keymap == vi_movement_keymap)) &&\n     ((param_2 & 0xffffffef) == 0x2f)) {\n    *(uint *)(lVar3 + 4) = *(uint *)(lVar3 + 4) | 0x10;\n    *(int *)(lVar3 + 100) = param_1;\n    *(undefined4 *)(lVar3 + 0x60) = *(undefined4 *)(lVar3 + 0x38);\n    rl_maybe_save_line();\n    rl_undo_list = 0;\n    *rl_line_buffer = 0;\n  }\n  else {\n    *(int *)(lVar3 + 100) = param_1;\n    *(undefined4 *)(lVar3 + 0x60) = *(undefined4 *)(lVar3 + 0x38);\n    rl_maybe_save_line();\n    rl_undo_list = 0;\n    *rl_line_buffer = 0;\n    if (param_2 == 0) {\n      param_2 = 0x3a;\n    }\n  }\n  rl_point = 0;\n  rl_end = 0;\n  uVar4 = _rl_make_prompt_for_search(param_2);\n  rl_message(&DAT_002102da,uVar4);\n  xfree(uVar4);\n  uVar5 = rl_readline_state | 0x100;\n  uVar1 = rl_readline_state & 0x80000;\n  rl_readline_state = uVar5;\n  _rl_nscxt = lVar3;\n  if (uVar1 != 0) {\n    return false;\n  }\n  do {\n    iVar2 = _rl_search_getchar(lVar3);\n    if (iVar2 < 0) {\n      rl_maybe_unsave_line();\n      rl_point = *(undefined4 *)(lVar3 + 0x30);\n      rl_mark = *(undefined4 *)(lVar3 + 0x34);\n      rl_restore_prompt();\n      rl_clear_message();\n      _rl_fix_point(1);\n      rl_readline_state = rl_readline_state & 0xfffffffffffffeff;\n      return true;\n    }\n    if (iVar2 == 0) break;\n    iVar2 = FUN_001d4cd0(lVar3,iVar2);\n    if (iVar2 < 0) {\n      return true;\n    }\n  } while (iVar2 != 0);\n  iVar2 = FUN_001d4780(lVar3);\n  if (iVar2 < 0) {\n    return true;\n  }\n  _rl_scxt_dispose(lVar3,0);\n  rl_readline_state = rl_readline_state & 0xfffffffffffffeff;\n  _rl_nscxt = 0;\n  return iVar2 != 1;\n}\n\n",
  "get_current_flags": "\nvoid get_current_flags(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  long lVar4;\n  undefined4 *puVar5;\n  char cVar6;\n  \n  lVar1 = sh_xmalloc(0x17,\"flags.c\",0x142);\n  lVar4 = 1;\n  puVar2 = (undefined8 *)(shell_flags + 0x18);\n  cVar6 = 'b';\n  puVar5 = &mark_modified_vars;\n  while( true ) {\n    *(char *)(lVar1 + -1 + lVar4) = (char)*puVar5;\n    iVar3 = (int)lVar4;\n    lVar4 = lVar4 + 1;\n    if (cVar6 == '\\0') break;\n    puVar5 = (undefined4 *)*puVar2;\n    cVar6 = *(char *)(puVar2 + 1);\n    puVar2 = puVar2 + 2;\n  }\n  *(undefined *)(lVar1 + iVar3) = 0;\n  return;\n}\n\n",
  "FUN_00168fd0": "\nvoid FUN_00168fd0(void)\n\n{\n  long lVar1;\n  int __fd;\n  long lVar2;\n  \n  if (DAT_00247834 == 0) {\n    DAT_00247834 = 0;\n    return;\n  }\n  __fd = DAT_00247830 + -1;\n  if (-1 < __fd) {\n    lVar2 = (long)__fd << 2;\n    lVar1 = DAT_00247838;\n    do {\n      if (*(int *)(lVar1 + lVar2) != 0) {\n        close(__fd);\n        lVar1 = DAT_00247838;\n        DAT_00247834 = DAT_00247834 + -1;\n        *(undefined4 *)(DAT_00247838 + lVar2) = 0;\n      }\n      if (__fd + -1 < 0) {\n        DAT_00247834 = 0;\n        return;\n      }\n      __fd = __fd + -1;\n      lVar2 = lVar2 + -4;\n    } while (DAT_00247834 != 0);\n  }\n  DAT_00247834 = 0;\n  return;\n}\n\n",
  "getaddrinfo": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint getaddrinfo(char *__name,char *__service,addrinfo *__req,addrinfo **__pai)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_getaddrinfo_00237e38)();\n  return iVar1;\n}\n\n",
  "rl_vi_fword": "\nundefined8 rl_vi_fword(int param_1)\n\n{\n  char cVar1;\n  uint uVar2;\n  byte bVar3;\n  ushort **ppuVar4;\n  ulong uVar5;\n  size_t sVar6;\n  ulong uVar7;\n  uint uVar8;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\nLAB_001d0f00:\n  uVar2 = rl_point;\n  uVar8 = rl_end;\n  uVar7 = (ulong)rl_point;\n  if ((int)(rl_end - 1) <= (int)rl_point) {\n    return 0;\n  }\n  ppuVar4 = __ctype_b_loc();\n  uVar5 = (ulong)*(byte *)(rl_line_buffer + (int)uVar2);\n  if (((*(byte *)(*ppuVar4 + uVar5) & 8) == 0) && (*(byte *)(rl_line_buffer + (int)uVar2) != 0x5f))\n  {\n    do {\n      if (((char)uVar5 == ' ') || (((char)uVar5 == '\\t' || ((int)rl_end <= (int)uVar7))))\n      goto LAB_001d1078;\n      sVar6 = __ctype_get_mb_cur_max();\n      uVar8 = rl_point;\n      if ((sVar6 == 1) || (rl_byte_oriented != 0)) {\n        rl_point = rl_point + 1;\n        uVar7 = (ulong)rl_point;\n      }\n      else {\n        rl_point = _rl_forward_char_internal(1);\n        uVar7 = (ulong)rl_end;\n        if ((rl_point == uVar8) || ((int)rl_end < (int)rl_point)) {\n          rl_point = rl_end;\n        }\n        else {\n          uVar7 = (ulong)rl_point;\n        }\n      }\n      bVar3 = *(byte *)(rl_line_buffer + (int)uVar7);\n      uVar5 = (ulong)bVar3;\n    } while (((*(byte *)(*ppuVar4 + uVar5) & 8) == 0) && (bVar3 != 0x5f));\n  }\n  else {\n    do {\n      if ((int)uVar8 <= (int)uVar7) goto LAB_001d1078;\n      sVar6 = __ctype_get_mb_cur_max();\n      uVar8 = rl_point;\n      if ((sVar6 == 1) || (rl_byte_oriented != 0)) {\n        rl_point = rl_point + 1;\n        uVar7 = (ulong)rl_point;\n      }\n      else {\n        rl_point = _rl_forward_char_internal(1);\n        uVar7 = (ulong)rl_end;\n        if ((rl_point == uVar8) || ((int)rl_end < (int)rl_point)) {\n          rl_point = rl_end;\n        }\n        else {\n          uVar7 = (ulong)rl_point;\n        }\n      }\n      bVar3 = *(byte *)(rl_line_buffer + (int)uVar7);\n      uVar8 = rl_end;\n    } while (((*(byte *)(*ppuVar4 + bVar3) & 8) != 0) || (bVar3 == 0x5f));\n  }\n  goto LAB_001d1086;\nLAB_001d1078:\n  uVar7 = (ulong)(int)rl_point;\n  bVar3 = *(byte *)(rl_line_buffer + uVar7);\nLAB_001d1086:\n  if ((bVar3 == 9) || (bVar3 == 0x20)) {\n    do {\n      if ((int)rl_end <= (int)uVar7) break;\n      sVar6 = __ctype_get_mb_cur_max();\n      uVar8 = rl_point;\n      if ((sVar6 == 1) || (rl_byte_oriented != 0)) {\n        rl_point = rl_point + 1;\n        uVar7 = (ulong)rl_point;\n      }\n      else {\n        rl_point = _rl_forward_char_internal(1);\n        uVar7 = (ulong)rl_end;\n        if ((rl_point == uVar8) || ((int)rl_end < (int)rl_point)) {\n          rl_point = rl_end;\n        }\n        else {\n          uVar7 = (ulong)rl_point;\n        }\n      }\n      cVar1 = *(char *)(rl_line_buffer + (int)uVar7);\n    } while ((cVar1 == ' ') || (cVar1 == '\\t'));\n  }\n  param_1 = param_1 + -1;\n  if (param_1 == 0) {\n    return 0;\n  }\n  goto LAB_001d0f00;\n}\n\n",
  "parser_restore_alias": "\nvoid parser_restore_alias(void)\n\n{\n  if (pushed_string_list != 0) {\n    FUN_001358d0();\n    return;\n  }\n  return;\n}\n\n",
  "make_local_variable": "\n/* WARNING: Type propagation algorithm not settling */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong make_local_variable(char *param_1,uint param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  long lVar3;\n  size_t sVar4;\n  char *__dest;\n  char *pcVar5;\n  uint uVar6;\n  long lVar7;\n  undefined8 uVar8;\n  long lVar9;\n  uint uVar10;\n  bool bVar11;\n  \n  bVar11 = false;\n  if (expanding_redir == 0) {\n    bVar11 = (assigning_in_environment | executing_builtin) != 0;\n  }\n  lVar3 = FUN_00152c60(param_1,bVar11);\n  if ((lVar3 == 0) || ((*(byte *)(lVar3 + 0x29) & 8) == 0)) {\n    lVar3 = find_variable(param_1);\n    lVar7 = shell_variables;\n    if (lVar3 != 0) {\n      uVar10 = *(uint *)(lVar3 + 0x28);\n      iVar1 = variable_context;\n      goto joined_r0x001543da;\n    }\n    pcVar5 = (char *)0x0;\n    uVar10 = 0;\n    lVar9 = lVar3;\njoined_r0x001544cc:\n    while( true ) {\n      if (lVar7 == 0) {\n        internal_error(\"make_local_variable: no function context at current scope\");\n        return 0;\n      }\n      if (((*(byte *)(lVar7 + 0xc) & 4) != 0) && (*(int *)(lVar7 + 8) == variable_context)) break;\n      lVar7 = *(long *)(lVar7 + 0x18);\n    }\n    if (*(long *)(lVar7 + 0x20) == 0) {\n      uVar8 = hash_create(4);\n      *(undefined8 *)(lVar7 + 0x20) = uVar8;\n    }\n    if (lVar9 == 0) {\n      lVar3 = FUN_00152bf0(param_1,*(undefined8 *)(lVar7 + 0x20));\n      uVar2 = *(uint *)(lVar3 + 0x28);\n    }\n    else {\n      uVar6 = *(uint *)(lVar9 + 0x28);\n      if ((uVar6 & 0x4000) != 0) {\n        if ((uVar6 & 2) == 0) {\n          builtin_error(\"%s: variable may not be assigned value\",param_1);\n          return 0;\n        }\nLAB_00154708:\n        sh_readonly(param_1);\n        return 0;\n      }\n      if ((*(ulong *)(lVar9 + 0x28) & 0xffffffff00000002) == 2) {\n        if ((uVar6 & 2) == 0) {\n          return 0;\n        }\n        goto LAB_00154708;\n      }\n      lVar3 = FUN_00152bf0(param_1,*(undefined8 *)(lVar7 + 0x20));\n      uVar6 = localvar_inherit;\n      if (uVar10 == 0) {\n        uVar2 = *(uint *)(lVar9 + 0x28);\n        if ((param_2 & 4 | localvar_inherit) != 0) {\n          if ((uVar2 & 0x40) == 0) {\n            if ((uVar2 & 4) == 0) {\n              pcVar5 = *(char **)(lVar9 + 8);\n              if (pcVar5 != (char *)0x0) {\n                sVar4 = strlen(pcVar5);\n                uVar8 = 0xaa8;\n                goto LAB_001545a6;\n              }\n              *(undefined8 *)(lVar3 + 8) = 0;\n            }\n            else {\n              uVar8 = array_copy(*(undefined8 *)(lVar9 + 8));\n              uVar6 = localvar_inherit;\n              *(undefined8 *)(lVar3 + 8) = uVar8;\n              uVar2 = *(uint *)(lVar9 + 0x28);\n            }\n          }\n          else {\n            uVar8 = hash_copy(*(undefined8 *)(lVar9 + 8),0);\n            uVar6 = localvar_inherit;\n            *(undefined8 *)(lVar3 + 8) = uVar8;\n            uVar2 = *(uint *)(lVar9 + 0x28);\n          }\n          goto LAB_001545cb;\n        }\n      }\n      else {\n        sVar4 = strlen(pcVar5);\n        uVar8 = 0xa9a;\nLAB_001545a6:\n        __dest = (char *)sh_xmalloc(sVar4 + 1,\"variables.c\",uVar8);\n        pcVar5 = strcpy(__dest,pcVar5);\n        uVar6 = localvar_inherit;\n        *(char **)(lVar3 + 8) = pcVar5;\n        uVar2 = *(uint *)(lVar9 + 0x28);\nLAB_001545cb:\n        if ((uVar6 != 0) || ((param_2 & 4) != 0)) {\n          uVar8 = *(undefined8 *)(lVar9 + 0x18);\n          uVar2 = uVar2 & 0xfffff7ff;\n          *(uint *)(lVar3 + 0x28) = uVar2;\n          *(undefined8 *)(lVar3 + 0x18) = uVar8;\n          *(undefined8 *)(lVar3 + 0x20) = *(undefined8 *)(lVar9 + 0x20);\n          goto LAB_001545e9;\n        }\n      }\n      uVar2 = uVar2 & 1;\n      *(uint *)(lVar3 + 0x28) = uVar2;\n    }\nLAB_001545e9:\n    iVar1 = variable_context;\n    *(uint *)(lVar7 + 0xc) = *(uint *)(lVar7 + 0xc) | 1;\n    *(uint *)(lVar3 + 0x28) = uVar2 | 0x20;\n    *(int *)(lVar3 + 0x2c) = iVar1;\n    if ((((*param_1 != 'I') || (param_1[1] != 'F')) || (param_1[2] != 'S')) || (param_1[3] != '\\0'))\n    goto LAB_00154607;\n  }\n  else {\n    find_variable(param_1);\n    uVar10 = *(uint *)(lVar3 + 0x28);\n    iVar1 = variable_context;\n    lVar7 = shell_variables;\njoined_r0x001543da:\n    variable_context = iVar1;\n    shell_variables = lVar7;\n    lVar9 = lVar3;\n    if ((uVar10 & 0x20) != 0) {\n      if (*(int *)(lVar3 + 0x2c) == iVar1) {\n        return lVar3;\n      }\n      if ((uVar10 & 0x100000) == 0) {\nLAB_001544bf:\n        uVar10 = uVar10 & 0x100000;\n        pcVar5 = (char *)0x0;\n      }\n      else {\nLAB_00154630:\n        pcVar5 = *(char **)(lVar3 + 8);\n        uVar10 = 1;\n      }\n      goto joined_r0x001544cc;\n    }\n    if ((uVar10 & 0x100000) == 0) goto LAB_001544bf;\n    if ((*(int *)(lVar3 + 0x2c) != iVar1) || (_DAT_002422f8 == temporary_env)) goto LAB_00154630;\n    *(uint *)(lVar3 + 0x28) = uVar10 & 0xffffefff;\n    if (lVar7 == 0) {\n      lVar3 = FUN_00131c12();\n      return lVar3;\n    }\n    while (((*(uint *)(lVar7 + 0xc) & 4) == 0 || (iVar1 != *(int *)(lVar7 + 8)))) {\n      lVar7 = *(long *)(lVar7 + 0x18);\n      if (lVar7 == 0) {\n        lVar3 = FUN_00131c12();\n        return lVar3;\n      }\n    }\n    *(uint *)(lVar7 + 0xc) = *(uint *)(lVar7 + 0xc) | 1;\n    *(int *)(lVar3 + 0x2c) = iVar1;\n    *(uint *)(lVar3 + 0x28) = uVar10 & 0xffffefff | 0x20;\n    if (*param_1 != 'I') {\n      return lVar3;\n    }\n    if (param_1[1] != 'F') {\n      return lVar3;\n    }\n    if (param_1[2] != 'S') {\n      return lVar3;\n    }\n    if (param_1[3] != '\\0') {\n      return lVar3;\n    }\n    uVar10 = 1;\n  }\n  setifs(lVar3);\nLAB_00154607:\n  if (uVar10 != 0) {\n    return lVar3;\n  }\n  if (*(long *)(lVar3 + 8) == 0) {\n    *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | 0x1000;\n    return lVar3;\n  }\n  return lVar3;\n}\n\n",
  "push_var_context": "\nlong push_var_context(undefined8 param_1,undefined8 param_2,long param_3)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  \n  lVar3 = new_var_context();\n  if (param_3 != 0) {\n    *(long *)(lVar3 + 0x20) = param_3;\n    FUN_00152050(param_3,FUN_00151390,0);\n    *(uint *)(lVar3 + 0xc) = *(uint *)(lVar3 + 0xc) | 2;\n  }\n  lVar1 = shell_variables;\n  lVar2 = lVar3;\n  *(long *)(lVar3 + 0x18) = shell_variables;\n  shell_variables = lVar2;\n  *(long *)(lVar1 + 0x10) = lVar3;\n  return lVar3;\n}\n\n",
  "adjust_shell_level": "\nvoid adjust_shell_level(int param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  char *pcVar4;\n  long in_FS_OFFSET;\n  int local_30;\n  char local_25;\n  char local_24;\n  char local_23;\n  undefined local_22;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar3 = find_variable(\"SHLVL\");\n  if ((((lVar3 == 0) || (pcVar4 = (char *)get_variable_value(lVar3), pcVar4 == (char *)0x0)) ||\n      (*pcVar4 == '\\0')) || (iVar2 = legal_number(pcVar4), iVar2 == 0)) {\n    shell_level = param_1;\n    if (param_1 < 0) goto LAB_00155980;\nLAB_001558cf:\n    if (shell_level < 1000) {\n      if (9 < shell_level) {\n        if (shell_level < 100) {\n          local_23 = '\\0';\n          cVar1 = (char)(shell_level / 10);\n          local_25 = cVar1 + '0';\n          local_24 = (char)shell_level + cVar1 * -10 + '0';\n        }\n        else {\n          local_22 = 0;\n          local_25 = (char)(shell_level / 100) + '0';\n          cVar1 = (char)((ulong)(long)(shell_level % 100) / 10);\n          local_24 = cVar1 + '0';\n          local_23 = (char)(shell_level % 100) + cVar1 * -10 + '0';\n        }\n        goto LAB_0015591d;\n      }\n      local_25 = (char)shell_level + '0';\n    }\n    else {\n      internal_warning(\"shell level (%d) too high, resetting to 1\");\n      shell_level = 1;\n      local_25 = '1';\n    }\n  }\n  else {\n    shell_level = local_30 + param_1;\n    if (-1 < shell_level) goto LAB_001558cf;\nLAB_00155980:\n    shell_level = 0;\n    local_25 = '0';\n  }\n  local_24 = '\\0';\nLAB_0015591d:\n  lVar3 = bind_variable(\"SHLVL\",&local_25,0);\n  array_needs_making = 1;\n  *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | 1;\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "close_fd_bitmap": "\nvoid close_fd_bitmap(int *param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 == (int *)0x0) {\n    return;\n  }\n  if (0 < *param_1) {\n    lVar1 = 0;\n    do {\n      while (*(char *)(*(long *)(param_1 + 2) + lVar1) != '\\0') {\n        close((int)lVar1);\n        *(undefined *)(*(long *)(param_1 + 2) + lVar1) = 0;\n        lVar1 = lVar1 + 1;\n        if (*param_1 == (int)lVar1 || *param_1 < (int)lVar1) {\n          return;\n        }\n      }\n      lVar1 = lVar1 + 1;\n    } while (*param_1 != (int)lVar1 && (int)lVar1 <= *param_1);\n  }\n  return;\n}\n\n",
  "FUN_00152970": "\nlong FUN_00152970(long param_1)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  undefined4 local_68;\n  __suseconds_t local_60;\n  char local_58 [40];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  gettimeofday((timeval *)&local_68,(__timezone_ptr_t)0x0);\n  uVar1 = locale_decpoint();\n  __snprintf_chk(local_58,0x20,1,0x20,\"%u%c%06u\",local_68,uVar1,local_60);\n  if (local_58[0] == '\\0') {\n    pcVar2 = (char *)sh_xmalloc(1,\"variables.c\",0x537);\n    *pcVar2 = '\\0';\n  }\n  else {\n    sVar3 = strlen(local_58);\n    pcVar2 = (char *)sh_xmalloc(sVar3 + 1,\"variables.c\",0x534);\n    pcVar2 = strcpy(pcVar2,local_58);\n  }\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x53a);\n  }\n  *(char **)(param_1 + 8) = pcVar2;\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "nohup_job": "\nvoid nohup_job(int param_1)\n\n{\n  uint *puVar1;\n  long lVar2;\n  \n  if ((DAT_0023877c != 0) && (lVar2 = *(long *)(jobs + (long)param_1 * 8), lVar2 != 0)) {\n    puVar1 = (uint *)(lVar2 + 0x18);\n    *puVar1 = *puVar1 | 8;\n  }\n  return;\n}\n\n",
  "set_posix_options": "\nvoid set_posix_options(long param_1)\n\n{\n  char *pcVar1;\n  long lVar2;\n  int *piVar3;\n  int *piVar4;\n  \n  lVar2 = 0;\n  piVar3 = &interactive_comments;\n  piVar4 = &source_uses_path;\n  while( true ) {\n    pcVar1 = (char *)(param_1 + lVar2);\n    lVar2 = lVar2 + 1;\n    *piVar3 = (int)*pcVar1;\n    if (piVar4 == (int *)0x0) break;\n    piVar3 = piVar4;\n    piVar4 = (int *)(&PTR_source_uses_path_00235f88)[lVar2];\n  }\n  return;\n}\n\n",
  "exportable_function_name": "\nbool exportable_function_name(undefined8 param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = mbschr(param_1,0x2f);\n  if (lVar1 != 0) {\n    return false;\n  }\n  lVar1 = mbschr(param_1,0x3d);\n  return lVar1 == 0;\n}\n\n",
  "stupidly_hack_special_variables": "\nvoid stupidly_hack_special_variables(char *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined **ppuVar3;\n  int iVar4;\n  char *__s1;\n  \n  if (DAT_002422b8 == 0) {\n    qsort(&PTR_s_BASH_COMPAT_00238460,0x25,0x10,FUN_001513d0);\n    DAT_002422b8 = 1;\n  }\n  if (PTR_s_BASH_COMPAT_00238460 != (undefined *)0x0) {\n    cVar1 = *param_1;\n    ppuVar3 = &PTR_s_BASH_XTRACEFD_00238470;\n    iVar4 = 0;\n    __s1 = PTR_s_BASH_COMPAT_00238460;\n    do {\n      iVar2 = (int)*__s1 - (int)cVar1;\n      if ((iVar2 == 0) && (iVar2 = strcmp(__s1,param_1), iVar2 == 0)) {\n                    /* WARNING: Could not recover jumptable at 0x001582f7. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        (*(code *)(&PTR_sv_shcompat_00238468)[(long)iVar4 * 2])(param_1);\n        return;\n      }\n      if (0 < iVar2) {\n        return;\n      }\n      __s1 = *ppuVar3;\n      ppuVar3 = ppuVar3 + 2;\n      iVar4 = iVar4 + 1;\n    } while (__s1 != (char *)0x0);\n  }\n  return;\n}\n\n",
  "FUN_001da990": "\nint FUN_001da990(char *param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = strncasecmp(param_1,\"vi\",2);\n  if (iVar1 == 0) {\n    rl_editing_mode = 0;\n    _rl_keymap = &vi_insertion_keymap;\n    return iVar1;\n  }\n  iVar1 = strncasecmp(param_1,\"emacs\",5);\n  if (iVar1 != 0) {\n    return 1;\n  }\n  rl_editing_mode = 1;\n  _rl_keymap = emacs_standard_keymap;\n  return iVar1;\n}\n\n",
  "find_global_variable_noref": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong find_global_variable_noref(undefined8 param_1)\n\n{\n  long *plVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long lVar4;\n  \n  lVar4 = global_variables;\n  if (global_variables != 0) {\n    do {\n      uVar2 = *(undefined8 *)(lVar4 + 0x20);\n      lVar3 = hash_search(param_1,uVar2,0);\n      if ((lVar3 != 0) && (lVar3 = *(long *)(lVar3 + 0x10), _DAT_002422f8 = uVar2, lVar3 != 0)) {\n        if (*(code **)(lVar3 + 0x18) == (code *)0x0) {\n          return lVar3;\n        }\n                    /* WARNING: Could not recover jumptable at 0x001535bd. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        lVar4 = (**(code **)(lVar3 + 0x18))();\n        return lVar4;\n      }\n      plVar1 = (long *)(lVar4 + 0x18);\n      lVar4 = *plVar1;\n    } while (*plVar1 != 0);\n  }\n  return 0;\n}\n\n",
  "_rl_scxt_dispose": "\nvoid _rl_scxt_dispose(long param_1)\n\n{\n  if (*(void **)(param_1 + 8) != (void *)0x0) {\n    free(*(void **)(param_1 + 8));\n  }\n  if (*(void **)(param_1 + 0x20) != (void *)0x0) {\n    free(*(void **)(param_1 + 0x20));\n  }\n  if (*(void **)(param_1 + 0x18) != (void *)0x0) {\n    free(*(void **)(param_1 + 0x18));\n  }\n  xfree(param_1);\n  return;\n}\n\n",
  "rl_replace_from_history": "\nvoid rl_replace_from_history(undefined8 *param_1)\n\n{\n  rl_replace_line(*param_1,0);\n  rl_mark = 0;\n  rl_undo_list = param_1[2];\n  rl_point = rl_end;\n  if (rl_editing_mode == 0) {\n    rl_point = 0;\n    rl_mark = rl_end;\n  }\n  return;\n}\n\n",
  "zreadretry": "\nssize_t zreadretry(int param_1,void *param_2,size_t param_3)\n\n{\n  ssize_t sVar1;\n  int *piVar2;\n  int iVar3;\n  \n  iVar3 = 3;\n  while( true ) {\n    sVar1 = read(param_1,param_2,param_3);\n    if (sVar1 != -1) {\n      return sVar1;\n    }\n    piVar2 = __errno_location();\n    if (*piVar2 != 4) break;\n    iVar3 = iVar3 + -1;\n    if (iVar3 == 0) {\n      return -1;\n    }\n  }\n  return -1;\n}\n\n",
  "load_history": "\nvoid load_history(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  set_if_not(\"HISTSIZE\",&DAT_001ff2e5);\n  sv_histsize(\"HISTSIZE\");\n  uVar2 = get_string_value(\"HISTSIZE\");\n  set_if_not(\"HISTFILESIZE\",uVar2);\n  sv_histsize(\"HISTFILESIZE\");\n  pcVar3 = (char *)get_string_value(\"HISTFILE\");\n  if ((pcVar3 != (char *)0x0) && (*pcVar3 != '\\0')) {\n    iVar1 = file_exists(pcVar3);\n    if (iVar1 != 0) {\n      read_history(pcVar3);\n      history_lines_in_file = history_lines_read_from_file;\n      using_history();\n      return;\n    }\n  }\n  return;\n}\n\n",
  "FUN_0015ed20": "\nvoid FUN_0015ed20(uint param_1,undefined2 param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  int iVar3;\n  int *piVar4;\n  ulong uVar5;\n  \n  uVar5 = (ulong)(param_1 & 0xfff);\n  iVar3 = FUN_0015e9f0();\n  if (iVar3 == *(int *)(pidstat_table + uVar5 * 4)) {\n    internal_debug(\"hashed pid %d (pid %d) collides with bgpids.head, skipping\",iVar3,param_1);\n    *(undefined4 *)((long)iVar3 * 0x10 + bgpids + 8) = 0xffffffff;\n    iVar3 = FUN_0015e9f0();\n  }\n  lVar2 = bgpids;\n  piVar4 = (int *)((long)iVar3 * 0x10 + bgpids);\n  piVar4[2] = param_1;\n  iVar1 = *(int *)(pidstat_table + uVar5 * 4);\n  *(undefined2 *)(piVar4 + 3) = param_2;\n  *piVar4 = iVar1;\n  piVar4[1] = -1;\n  DAT_00242540 = DAT_00242540 + 1;\n  if (iVar1 != -1) {\n    *(int *)(lVar2 + 4 + (long)iVar1 * 0x10) = iVar3;\n  }\n  *(int *)(pidstat_table + uVar5 * 4) = iVar3;\n  return;\n}\n\n",
  "endpwent": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid endpwent(void)\n\n{\n  (*(code *)PTR_endpwent_00237c10)();\n  return;\n}\n\n",
  "read_builtin": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nsigset_t * read_builtin(undefined8 param_1)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  char cVar5;\n  uint uVar6;\n  byte *pbVar7;\n  mbstate_t mVar8;\n  byte bVar9;\n  int iVar10;\n  uint uVar11;\n  int iVar12;\n  int iVar13;\n  size_t sVar14;\n  long lVar15;\n  undefined *puVar16;\n  long lVar17;\n  ulong *puVar18;\n  code *pcVar19;\n  byte *pbVar20;\n  size_t sVar21;\n  ulong uVar22;\n  int *piVar23;\n  char *pcVar24;\n  __off_t _Var25;\n  byte *pbVar26;\n  undefined8 uVar27;\n  byte *pbVar28;\n  char *pcVar29;\n  sigset_t *__set;\n  undefined *puVar30;\n  sigset_t *psVar31;\n  sigset_t *psVar32;\n  uint uVar33;\n  int iVar34;\n  bool bVar35;\n  long in_FS_OFFSET;\n  char cVar36;\n  long **local_390;\n  uint local_384;\n  uint local_380;\n  int local_37c;\n  uint local_374;\n  int local_370;\n  int local_36c;\n  uint local_364;\n  uint local_360;\n  byte *local_358;\n  byte *local_350;\n  byte *local_348;\n  uint local_340;\n  uint local_33c;\n  sigset_t *local_338;\n  char *local_320;\n  int local_318;\n  byte *local_310;\n  FILE *local_2d8;\n  uint local_2b4;\n  byte local_2a2;\n  byte local_2a1;\n  int local_2a0;\n  wchar_t local_29c;\n  long local_298;\n  long local_290;\n  ulong local_288;\n  byte *local_280;\n  char *local_278;\n  mbstate_t local_270;\n  undefined local_268 [50];\n  cc_t cStack_236;\n  cc_t cStack_235;\n  cc_t cStack_234;\n  cc_t cStack_233;\n  cc_t cStack_232;\n  cc_t cStack_231;\n  speed_t local_230;\n  undefined8 local_228;\n  undefined8 uStack_220;\n  undefined8 local_218;\n  undefined8 uStack_210;\n  undefined8 local_208;\n  undefined8 uStack_200;\n  undefined8 local_1f8;\n  speed_t local_1f0;\n  sigset_t local_1e8;\n  sigset_t local_168;\n  stat local_e8;\n  byte local_58 [24];\n  long local_40;\n  \n  bVar35 = false;\n  pcVar24 = (char *)0x0;\n  psVar31 = (sigset_t *)0x1;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_374 = 0;\n  DAT_00248c04 = 0;\n  read_timeout = (ulong *)0x0;\n  local_2a0 = 0;\n  local_340 = 0;\n  local_33c = 0;\n  local_350 = (byte *)0x0;\n  local_348 = (byte *)0x0;\n  local_360 = 0;\n  local_358 = (byte *)0x0;\n  local_338 = (sigset_t *)0x0;\n  sVar14 = __ctype_get_mb_cur_max();\n  local_384 = 0;\n  iVar34 = (int)sVar14;\n  local_380 = 0;\n  local_36c = 0;\n  local_37c = 0;\n  DAT_00248c00 = 10;\n  bVar4 = false;\n  reset_internal_getopt();\nLAB_001af900:\n  while (iVar10 = internal_getopt(param_1), local_390 = loptend, iVar10 != -1) {\n    if (iVar10 == -99) {\n      builtin_help();\nLAB_001af98d:\n      psVar32 = (sigset_t *)0x102;\n      goto LAB_001af993;\n    }\n    switch(iVar10) {\n    case 0x4e:\n      DAT_00248c00 = 0xff;\n      bVar4 = true;\n    case 0x6e:\n      iVar10 = legal_number(list_optarg,&local_288);\n      if (((iVar10 == 0) || ((long)local_288 < 0)) ||\n         (local_36c = (int)local_288, local_288 != (long)local_36c)) {\n        sh_invalidnum(list_optarg);\n        goto LAB_001b0480;\n      }\n      pcVar24 = (char *)0x1;\n      break;\n    default:\n      builtin_usage();\n      goto LAB_001af98d;\n    case 0x61:\n      local_348 = list_optarg;\n      break;\n    case 100:\n      DAT_00248c00 = *list_optarg;\n      break;\n    case 0x65:\n      local_374 = 1;\n      break;\n    case 0x69:\n      local_358 = list_optarg;\n      break;\n    case 0x70:\n      local_350 = list_optarg;\n      break;\n    case 0x72:\n      local_340 = 1;\n      break;\n    case 0x73:\n      local_33c = 1;\n      break;\n    case 0x74:\n      iVar10 = uconvert(list_optarg,&local_298,&local_290);\n      if (((iVar10 == 0) || (local_298 < 0)) || (local_290 < 0)) {\n        builtin_error(\"%s: invalid timeout specification\",list_optarg);\n        goto LAB_001b0480;\n      }\n      local_380 = (uint)local_298;\n      bVar35 = true;\n      local_384 = (uint)local_290;\n      break;\n    case 0x75:\n      iVar10 = legal_number(list_optarg,&local_288);\n      uVar22 = local_288;\n      if (((iVar10 != 0) && (-1 < (long)local_288)) &&\n         (local_360 = (uint)local_288, local_288 == (long)(int)local_360)) goto code_r0x001af9f4;\n      builtin_error(\"%s: invalid file descriptor specification\",list_optarg);\n      goto LAB_001b0480;\n    }\n  }\n  if ((bVar35) && ((local_380 | local_384) == 0)) {\n    iVar34 = input_avail(local_360);\n    psVar32 = (sigset_t *)(ulong)(iVar34 == 0);\n    goto LAB_001af993;\n  }\n  if (((loptend != (long **)0x0) && (iVar10 = legal_identifier(*loptend[1]), iVar10 == 0)) &&\n     (iVar10 = valid_array_reference(*local_390[1]), iVar10 == 0)) {\n    sh_invalidid(*local_390[1]);\n    goto LAB_001b0480;\n  }\n  if (bVar4) {\n    DAT_00248c00 = 0xff;\n  }\n  local_320 = (char *)getifs();\n  if ((local_320 == (char *)0x0) || (bVar4)) {\n    bVar2 = false;\n    local_278 = \"\";\n    local_320 = \"\";\n    bVar3 = false;\n  }\n  else {\n    cVar36 = *local_320;\n    local_278 = local_320;\n    if (cVar36 == '\\0') {\n      bVar3 = false;\n      bVar2 = false;\n    }\n    else {\n      bVar3 = false;\n      bVar2 = false;\n      do {\n        local_278 = local_278 + 1;\n        bVar2 = (bool)(bVar2 | cVar36 == '\\x01');\n        bVar3 = (bool)(bVar3 | cVar36 == '\\x7f');\n        cVar36 = *local_278;\n      } while (cVar36 != '\\0');\n    }\n  }\n  local_370 = 0x70;\n  local_280 = (byte *)sh_xmalloc(0x70,\"./read.def\",0x188);\n  *local_280 = 0;\n  if (((int)pcVar24 != 1) || (local_36c != 0)) {\n    if ((!bVar35) && (local_278 = (char *)get_string_value(\"TMOUT\"), local_278 != (char *)0x0)) {\n      iVar10 = uconvert(local_278,&local_298,&local_290,0);\n      if ((iVar10 == 0) || (local_298 < 0)) {\n        local_384 = 0;\n        local_380 = 0;\n      }\n      else {\n        local_380 = (uint)local_298;\n        if (local_290 < 0) {\n          local_384 = 0;\n          local_380 = 0;\n        }\n        else {\n          local_384 = (uint)local_290;\n        }\n      }\n    }\n    __set = &local_1e8;\n    sigemptyset(__set);\n    sigprocmask(0,(sigset_t *)0x0,__set);\n    sigaddset(__set,0x11);\n    begin_unwind_frame(\"read_builtin\");\n    if (((interactive == 0) && (-1 < default_buffered_input)) &&\n       (iVar10 = fd_is_bash_input(local_360), iVar10 != 0)) {\n      sync_buffered_stream(default_buffered_input);\n    }\n    uVar11 = isatty(local_360);\n    if (uVar11 == 0) {\n      _Var25 = lseek(local_360,0,1);\n      cVar36 = false;\n      if (_Var25 < 0) {\n        piVar23 = __errno_location();\n        cVar36 = *piVar23 == 0x1d;\n      }\n      if (local_350 == (byte *)0x0) {\n        if ((local_374 | local_33c) != 0) {\n          local_358 = (byte *)0x0;\n          local_33c = 0;\n          local_374 = 0;\n        }\n      }\n      else {\n        local_358 = (byte *)0x0;\n        local_350 = (byte *)0x0;\n        local_33c = 0;\n        local_374 = 0;\n      }\n    }\n    else {\n      cVar36 = false;\n      if (local_374 != 0) {\n        add_unwind_protect(xfree,0);\n      }\n    }\n    pcVar19 = (code *)(ulong)local_380;\n    local_364 = 0;\n    local_318 = 0;\n    if ((local_380 | local_384) == 0) {\n      local_384 = 0;\n      local_380 = 0;\n      uVar33 = 0;\nLAB_001afd83:\n      if (uVar33 == 0) goto LAB_001b03f3;\n      iVar10 = __sigsetjmp(read_timeout + 6,0);\n      if (iVar10 != 0) {\n        if (read_timeout != (ulong *)0x0) {\n          shtimer_clear();\n        }\n        read_timeout = (ulong *)0x0;\n        sigprocmask(2,&local_168,(sigset_t *)0x0);\n        pbVar20 = local_280;\n        local_280[local_2a0] = 0;\n        if (local_2a0 == 0) {\n          pbVar20 = (byte *)sh_xmalloc(1,\"./read.def\",499);\n          *pbVar20 = 0;\n        }\n        else {\n          sVar14 = strlen((char *)local_280);\n          pcVar24 = (char *)sh_xmalloc(sVar14 + 1,\"./read.def\",0x1f7);\n          pbVar20 = (byte *)strcpy(pcVar24,(char *)pbVar20);\n        }\n        psVar32 = (sigset_t *)0x8e;\n        run_unwind_frame(\"read_builtin\");\n        local_280 = pbVar20;\n        goto LAB_001b02c3;\n      }\n      if (interactive_shell == 0) {\n        initialize_terminating_signals();\n      }\n      add_unwind_protect(FUN_001af6d0,0);\n      if (local_374 == 0) {\n        shtimer_set(read_timeout,local_380,local_384);\n      }\n      else {\n        add_unwind_protect(FUN_001af740,0);\n        add_unwind_protect(bashline_reset_event_hook,0);\n        puVar18 = read_timeout;\n        *read_timeout = (ulong)local_380;\n        pcVar19 = (code *)(ulong)local_384;\n        puVar18[1] = (ulong)pcVar19;\n        rl_set_timeout((ulong)local_380,pcVar19);\n      }\n    }\n    else {\n      iVar10 = fstat(local_360,&local_e8);\n      if ((-1 < iVar10) && ((local_e8.st_mode & 0xf000) != 0x8000)) {\n        if ((local_380 == 0) && (local_384 == 0)) {\n          uVar33 = 0;\n        }\n        else {\n          puVar18 = (ulong *)shtimer_alloc();\n          uVar33 = local_374 | posixly_correct;\n          read_timeout = puVar18;\n          *(uint *)(puVar18 + 2) = local_360;\n          pcVar19 = FUN_001af600;\n          puVar18[4] = (ulong)FUN_001af600;\n          *(uint *)((long)puVar18 + 0x14) = (uVar33 == 0) + 5;\n          uVar33 = local_380 | local_384;\n        }\n        goto LAB_001afd83;\n      }\nLAB_001b03f3:\n      local_384 = 0;\n      local_380 = 0;\n    }\n    if ((local_36c < 1) && (DAT_00248c00 == 10)) {\n      if (local_33c != 0) {\n        DAT_00248bc0 = local_360;\n        ttgetattr(local_360,(termios *)local_268);\n        DAT_00248bf4 = local_268[48];\n        DAT_00248bf4_1._0_1_ = local_268[49];\n        DAT_00248bf4_1._1_1_ = cStack_236;\n        DAT_00248bf4_1._2_1_ = cStack_235;\n        DAT_00248bf4_1._3_1_ = cStack_234;\n        DAT_00248bf4_1._4_1_ = cStack_233;\n        DAT_00248bf4_1._5_1_ = cStack_232;\n        DAT_00248bf4_1._6_1_ = cStack_231;\n        local_1f8._0_1_ = local_268[48];\n        local_1f8._1_1_ = local_268[49];\n        local_1f8._2_1_ = cStack_236;\n        local_1f8._3_1_ = cStack_235;\n        local_1f8._4_1_ = cStack_234;\n        local_1f8._5_1_ = cStack_233;\n        local_1f8._6_1_ = cStack_232;\n        local_1f8._7_1_ = cStack_231;\n        local_1f0 = local_230;\n        _DAT_00248bc4 = local_268._0_4_;\n        DAT_00248bc4_4 = local_268._4_4_;\n        uRam0000000000248bcc._0_4_ = local_268._8_4_;\n        uRam0000000000248bcc._4_4_ = local_268._12_4_;\n        DAT_00248bd4 = local_268[16];\n        DAT_00248bd4_1._0_1_ = local_268[17];\n        DAT_00248bd4_1._1_1_ = local_268[18];\n        DAT_00248bd4_1._2_1_ = local_268[19];\n        DAT_00248bd4_1._3_1_ = local_268[20];\n        DAT_00248bd4_1._4_1_ = local_268[21];\n        DAT_00248bd4_1._5_1_ = local_268[22];\n        DAT_00248bd4_1._6_1_ = local_268[23];\n        uRam0000000000248bdc._0_1_ = local_268[24];\n        uRam0000000000248bdc._1_1_ = local_268[25];\n        uRam0000000000248bdc._2_1_ = local_268[26];\n        uRam0000000000248bdc._3_1_ = local_268[27];\n        uRam0000000000248bdc._4_1_ = local_268[28];\n        uRam0000000000248bdc._5_1_ = local_268[29];\n        uRam0000000000248bdc._6_1_ = local_268[30];\n        uRam0000000000248bdc._7_1_ = local_268[31];\n        DAT_00248be4 = local_268[32];\n        DAT_00248be4_1._0_1_ = local_268[33];\n        DAT_00248be4_1._1_1_ = local_268[34];\n        DAT_00248be4_1._2_1_ = local_268[35];\n        DAT_00248be4_1._3_1_ = local_268[36];\n        DAT_00248be4_1._4_1_ = local_268[37];\n        DAT_00248be4_1._5_1_ = local_268[38];\n        DAT_00248be4_1._6_1_ = local_268[39];\n        uRam0000000000248bec._0_1_ = local_268[40];\n        uRam0000000000248bec._1_1_ = local_268[41];\n        uRam0000000000248bec._2_1_ = local_268[42];\n        uRam0000000000248bec._3_1_ = local_268[43];\n        uRam0000000000248bec._4_1_ = local_268[44];\n        uRam0000000000248bec._5_1_ = local_268[45];\n        uRam0000000000248bec._6_1_ = local_268[46];\n        uRam0000000000248bec._7_1_ = local_268[47];\n        local_228._0_4_ = local_268._0_4_;\n        local_228._4_4_ = local_268._4_4_;\n        uStack_220._0_4_ = local_268._8_4_;\n        uStack_220._4_4_ = local_268._12_4_;\n        local_218._0_1_ = local_268[16];\n        local_218._1_1_ = local_268[17];\n        local_218._2_1_ = local_268[18];\n        local_218._3_1_ = local_268[19];\n        local_218._4_1_ = local_268[20];\n        local_218._5_1_ = local_268[21];\n        local_218._6_1_ = local_268[22];\n        local_218._7_1_ = local_268[23];\n        uStack_210._0_1_ = local_268[24];\n        uStack_210._1_1_ = local_268[25];\n        uStack_210._2_1_ = local_268[26];\n        uStack_210._3_1_ = local_268[27];\n        uStack_210._4_1_ = local_268[28];\n        uStack_210._5_1_ = local_268[29];\n        uStack_210._6_1_ = local_268[30];\n        uStack_210._7_1_ = local_268[31];\n        local_208._0_1_ = local_268[32];\n        local_208._1_1_ = local_268[33];\n        local_208._2_1_ = local_268[34];\n        local_208._3_1_ = local_268[35];\n        local_208._4_1_ = local_268[36];\n        local_208._5_1_ = local_268[37];\n        local_208._6_1_ = local_268[38];\n        local_208._7_1_ = local_268[39];\n        uStack_200._0_1_ = local_268[40];\n        uStack_200._1_1_ = local_268[41];\n        uStack_200._2_1_ = local_268[42];\n        uStack_200._3_1_ = local_268[43];\n        uStack_200._4_1_ = local_268[44];\n        uStack_200._5_1_ = local_268[45];\n        uStack_200._6_1_ = local_268[46];\n        uStack_200._7_1_ = local_268[47];\n        _DAT_00248bfc = local_230;\n        local_2a0 = ttfd_noecho(local_360,&local_228);\nLAB_001b0f5a:\n        pcVar19 = (code *)(ulong)local_360;\n        if (local_2a0 < 0) {\n          sh_ttyerror(1);\n        }\n        DAT_00248c04 = 1;\n        add_unwind_protect(FUN_001af710,&DAT_00248bc0);\n        if (interactive_shell == 0) {\n          initialize_terminating_signals();\n        }\n      }\n    }\n    else {\n      pcVar24 = (char *)(ulong)local_374;\n      if (local_374 == 0) {\n        if (uVar11 != 0) {\n          DAT_00248bc0 = local_360;\n          ttgetattr(local_360,(termios *)local_268);\n          DAT_00248bf4 = local_268[48];\n          DAT_00248bf4_1._0_1_ = local_268[49];\n          DAT_00248bf4_1._1_1_ = cStack_236;\n          DAT_00248bf4_1._2_1_ = cStack_235;\n          DAT_00248bf4_1._3_1_ = cStack_234;\n          DAT_00248bf4_1._4_1_ = cStack_233;\n          DAT_00248bf4_1._5_1_ = cStack_232;\n          DAT_00248bf4_1._6_1_ = cStack_231;\n          _DAT_00248bfc = local_230;\n          local_1f8._0_1_ = local_268[48];\n          local_1f8._1_1_ = local_268[49];\n          local_1f8._2_1_ = cStack_236;\n          local_1f8._3_1_ = cStack_235;\n          local_1f8._4_1_ = cStack_234;\n          local_1f8._5_1_ = cStack_233;\n          local_1f8._6_1_ = cStack_232;\n          local_1f8._7_1_ = cStack_231;\n          local_1f0 = local_230;\n          _DAT_00248bc4 = local_268._0_4_;\n          DAT_00248bc4_4 = local_268._4_4_;\n          uRam0000000000248bcc._0_4_ = local_268._8_4_;\n          uRam0000000000248bcc._4_4_ = local_268._12_4_;\n          DAT_00248bd4 = local_268[16];\n          DAT_00248bd4_1._0_1_ = local_268[17];\n          DAT_00248bd4_1._1_1_ = local_268[18];\n          DAT_00248bd4_1._2_1_ = local_268[19];\n          DAT_00248bd4_1._3_1_ = local_268[20];\n          DAT_00248bd4_1._4_1_ = local_268[21];\n          DAT_00248bd4_1._5_1_ = local_268[22];\n          DAT_00248bd4_1._6_1_ = local_268[23];\n          uRam0000000000248bdc._0_1_ = local_268[24];\n          uRam0000000000248bdc._1_1_ = local_268[25];\n          uRam0000000000248bdc._2_1_ = local_268[26];\n          uRam0000000000248bdc._3_1_ = local_268[27];\n          uRam0000000000248bdc._4_1_ = local_268[28];\n          uRam0000000000248bdc._5_1_ = local_268[29];\n          uRam0000000000248bdc._6_1_ = local_268[30];\n          uRam0000000000248bdc._7_1_ = local_268[31];\n          DAT_00248be4 = local_268[32];\n          DAT_00248be4_1._0_1_ = local_268[33];\n          DAT_00248be4_1._1_1_ = local_268[34];\n          DAT_00248be4_1._2_1_ = local_268[35];\n          DAT_00248be4_1._3_1_ = local_268[36];\n          DAT_00248be4_1._4_1_ = local_268[37];\n          DAT_00248be4_1._5_1_ = local_268[38];\n          DAT_00248be4_1._6_1_ = local_268[39];\n          uRam0000000000248bec._0_1_ = local_268[40];\n          uRam0000000000248bec._1_1_ = local_268[41];\n          uRam0000000000248bec._2_1_ = local_268[42];\n          uRam0000000000248bec._3_1_ = local_268[43];\n          uRam0000000000248bec._4_1_ = local_268[44];\n          uRam0000000000248bec._5_1_ = local_268[45];\n          uRam0000000000248bec._6_1_ = local_268[46];\n          uRam0000000000248bec._7_1_ = local_268[47];\n          local_228._0_4_ = local_268._0_4_;\n          local_228._4_4_ = local_268._4_4_;\n          uStack_220._0_4_ = local_268._8_4_;\n          uStack_220._4_4_ = local_268._12_4_;\n          local_218._0_1_ = local_268[16];\n          local_218._1_1_ = local_268[17];\n          local_218._2_1_ = local_268[18];\n          local_218._3_1_ = local_268[19];\n          local_218._4_1_ = local_268[20];\n          local_218._5_1_ = local_268[21];\n          local_218._6_1_ = local_268[22];\n          local_218._7_1_ = local_268[23];\n          uStack_210._0_1_ = local_268[24];\n          uStack_210._1_1_ = local_268[25];\n          uStack_210._2_1_ = local_268[26];\n          uStack_210._3_1_ = local_268[27];\n          uStack_210._4_1_ = local_268[28];\n          uStack_210._5_1_ = local_268[29];\n          uStack_210._6_1_ = local_268[30];\n          uStack_210._7_1_ = local_268[31];\n          local_208._0_1_ = local_268[32];\n          local_208._1_1_ = local_268[33];\n          local_208._2_1_ = local_268[34];\n          local_208._3_1_ = local_268[35];\n          local_208._4_1_ = local_268[36];\n          local_208._5_1_ = local_268[37];\n          local_208._6_1_ = local_268[38];\n          local_208._7_1_ = local_268[39];\n          uStack_200._0_1_ = local_268[40];\n          uStack_200._1_1_ = local_268[41];\n          uStack_200._2_1_ = local_268[42];\n          uStack_200._3_1_ = local_268[43];\n          uStack_200._4_1_ = local_268[44];\n          uStack_200._5_1_ = local_268[45];\n          uStack_200._6_1_ = local_268[46];\n          uStack_200._7_1_ = local_268[47];\n          if (local_33c == 0) {\n            local_2a0 = ttfd_onechar(local_360,&local_228);\n          }\n          else {\n            local_2a0 = ttfd_cbreak(local_360);\n          }\n          goto LAB_001b0f5a;\n        }\n      }\n      else {\n        if (0 < local_36c) {\n          unwind_protect_mem(&rl_num_chars_to_read,4);\n          rl_num_chars_to_read = local_36c;\n        }\n        bVar9 = DAT_00248c00;\n        pcVar19 = (code *)(ulong)DAT_00248c00;\n        if (DAT_00248c00 != 10) {\n          __set = (sigset_t *)(ulong)bash_readline_initialized;\n          if (bash_readline_initialized == 0) {\n            initialize_readline();\n          }\n          lVar15 = rl_get_keymap();\n          DAT_00248b68 = bVar9;\n          DAT_00248b78 = (int)*(char *)(lVar15 + 0xd0);\n          DAT_00248b70 = *(undefined8 *)(lVar15 + 0xd8);\n          pcVar29 = (char *)((long)pcVar19 * 0x10 + lVar15);\n          DAT_00248b88 = (int)*pcVar29;\n          DAT_00248b80 = *(undefined8 *)(pcVar29 + 8);\n          *(undefined *)(lVar15 + 0xd0) = 0;\n          *(code **)(lVar15 + 0xd8) = rl_insert;\n          *pcVar29 = '\\0';\n          *(code **)(pcVar29 + 8) = rl_newline;\n          add_unwind_protect(FUN_001af620,0);\n        }\n      }\n    }\n    if ((local_360 == 0) || (psVar31 = (sigset_t *)(ulong)local_374, local_374 == 0)) {\n      local_2d8 = (FILE *)0x0;\n    }\n    else {\n      if (bash_readline_initialized == 0) {\n        initialize_readline();\n      }\n      unwind_protect_mem(&rl_instream,8);\n      local_2d8 = rl_instream;\n      rl_instream = fdopen(local_360,\"r\");\n    }\n    add_unwind_protect(xfree,local_280);\n    if ((read_timeout != (ulong *)0x0) &&\n       (iVar12 = shtimer_chktimeout(), uVar33 = local_360, iVar10 = local_36c, cVar5 = '\\0',\n       iVar12 != 0)) goto LAB_001b05bd;\n    if (local_36c < 1) {\nLAB_001b12a4:\n      if (DAT_00248c00 != 10) {\nLAB_001b128c:\n        if (uVar11 != 0) {\n          cVar36 = '\\x01';\n          goto LAB_001affa5;\n        }\n      }\n      if ((bool)cVar36 == false) {\n        cVar36 = '\\0';\n      }\n    }\n    else {\n      if ((uVar11 != 0) || (!bVar4)) {\n        if (local_36c < 1) goto LAB_001b12a4;\n        goto LAB_001b128c;\n      }\n      cVar36 = '\\x02';\n    }\nLAB_001affa5:\n    if ((local_350 != (byte *)0x0) && (local_374 == 0)) {\n      fputs((char *)local_350,stderr);\n      fflush(stderr);\n    }\n    __set = (sigset_t *)0x0;\n    local_310 = &DAT_00213d70;\n    if (local_350 != (byte *)0x0) {\n      local_310 = local_350;\n    }\n    pcVar24 = (char *)0x0;\n    iVar10 = 0;\n    uVar33 = local_340 ^ 1;\n    pcVar19 = (code *)0x0;\n    psVar31 = local_338;\nLAB_001afff0:\n    do {\n      cVar5 = cVar36;\n      if ((read_timeout != (ulong *)0x0) && (iVar12 = shtimer_chktimeout(), iVar12 != 0))\n      goto LAB_001b05bd;\n      local_338 = psVar31;\n      if (local_374 == 0) {\n        if ((int)pcVar19 != 0) {\n          pcVar29 = pcVar24;\n          if (pcVar24 == (char *)0x0) {\n            pcVar24 = (char *)get_string_value(&DAT_001fa156);\n            pcVar29 = \"\";\n            if (pcVar24 != (char *)0x0) {\n              pcVar29 = pcVar24;\n            }\n          }\n          fputs(pcVar29,stderr);\n          fflush(stderr);\n        }\n        if ((read_timeout != (ulong *)0x0) && (iVar12 = shtimer_chktimeout(), iVar12 != 0))\n        goto LAB_001b05bd;\n        pcVar19 = (code *)__errno_location();\n        *(uint *)pcVar19 = 0;\n        if ((local_380 | local_384) != 0) {\n          sigprocmask(2,&local_1e8,&local_168);\n        }\n        if (cVar36 == '\\x02') {\n          if (posixly_correct == 0) {\n            iVar10 = zreadn(local_360,&local_2a2,(long)(local_36c - local_37c));\n          }\n          else {\n            iVar10 = zreadintr(local_360,&local_2a2,1);\n          }\n        }\n        else if (cVar36 == '\\0') {\n          if (posixly_correct == 0) {\n            iVar10 = zreadc(local_360,&local_2a2);\n          }\n          else {\n            iVar10 = zreadcintr();\n          }\n        }\n        else if (posixly_correct == 0) {\n          iVar10 = zread(local_360,&local_2a2,1);\n        }\n        else {\n          iVar10 = zreadintr();\n        }\n        if ((local_380 | local_384) != 0) {\n          sigprocmask(2,&local_168,(sigset_t *)0x0);\n        }\n        if (iVar10 < 1) {\n          uVar1 = *(uint *)pcVar19;\n          __set = (sigset_t *)(ulong)uVar1;\n          if ((uVar1 == 4) && (iVar10 != 0)) {\n            check_signals();\n            local_2b4 = terminating_signal;\n            uVar6 = terminating_signal;\n            if (terminating_signal == 0) {\n              local_2b4 = 2;\n              uVar6 = interrupt_state;\n            }\n            if (uVar6 == 0) {\n              local_2b4 = trapped_signal_received;\n            }\n          }\n          else {\n            local_2b4 = local_374;\n          }\n          if ((terminating_signal != 0) && (DAT_00248c04 != 0)) {\n            ttsetattr(DAT_00248bc0,&DAT_00248bc4);\n            DAT_00248c04 = 0;\n          }\n          if (terminating_signal != 0) {\n            termsig_handler(terminating_signal);\n          }\n          *(uint *)pcVar19 = uVar1;\n          psVar32 = (sigset_t *)0x1;\n          goto LAB_001b01b0;\n        }\n        if (terminating_signal != 0) {\n          termsig_handler(terminating_signal);\n        }\n        pcVar19 = (code *)(ulong)interrupt_state;\n        if (interrupt_state != 0) {\n          throw_to_top_level();\n          pcVar19 = (code *)0x0;\n          goto joined_r0x001b0597;\n        }\n      }\n      else {\n        if (((psVar31 != (sigset_t *)0x0) &&\n            (*(char *)((long)psVar31->__val + (long)(int)__set) == '\\0')) && (DAT_00248c00 != 0)) {\n          local_338 = (sigset_t *)0x0;\n          sh_xfree(psVar31,\"./read.def\",0x275);\n        }\n        if ((local_380 | local_384) != 0) {\n          sigprocmask(2,&local_1e8,&local_168);\n        }\n        if (local_338 == (sigset_t *)0x0) {\n          if (bash_readline_initialized == 0) {\n            initialize_readline();\n          }\n          DAT_00248ba0 = rl_attempted_completion_function;\n          rl_attempted_completion_function = 0;\n          bashline_set_event_hook();\n          if (local_358 != (byte *)0x0) {\n            DAT_00248b98 = rl_startup_hook;\n            rl_startup_hook = FUN_001af670;\n            DAT_00248b90 = local_358;\n          }\n          pcVar29 = (char *)readline(local_310);\n          rl_attempted_completion_function = DAT_00248ba0;\n          DAT_00248ba0 = 0;\n          bashline_reset_event_hook();\n          if (pcVar29 == (char *)0x0) {\n            __set = (sigset_t *)0x0;\n            if (((rl_readline_state._3_1_ & 4) != 0) && (read_timeout != (ulong *)0x0)) {\n              *(undefined4 *)(read_timeout + 3) = 1;\n              iVar12 = shtimer_chktimeout();\n              psVar31 = local_338;\n              if (iVar12 != 0) goto LAB_001b05bd;\n            }\n            local_338 = __set;\n            if ((local_380 | local_384) != 0) {\n              sigprocmask(2,&local_168,(sigset_t *)0x0);\n              psVar32 = (sigset_t *)(ulong)local_374;\n              goto LAB_001b01b0;\n            }\n            psVar32 = (sigset_t *)(ulong)local_374;\n            goto LAB_001b01b0;\n          }\n          sVar14 = strlen(pcVar29);\n          iVar12 = (int)sVar14;\n          __set = (sigset_t *)0x0;\n          local_338 = (sigset_t *)sh_xrealloc(pcVar29,(long)(iVar12 + 2),\"./read.def\",0x4b5);\n          *(byte *)((long)local_338->__val + (long)iVar12) = DAT_00248c00;\n          *(undefined *)((long)local_338->__val + (long)(iVar12 + 1)) = 0;\n        }\n        if ((local_380 | local_384) != 0) {\n          sigprocmask(2,&local_168,(sigset_t *)0x0);\n        }\n        if (local_338 == (sigset_t *)0x0) {\n          psVar32 = (sigset_t *)(ulong)local_374;\n          goto LAB_001b01b0;\n        }\n        iVar12 = (int)__set;\n        __set = (sigset_t *)(ulong)(iVar12 + 1);\n        local_2a2 = *(byte *)((long)local_338->__val + (long)iVar12);\n        psVar31 = local_338;\njoined_r0x001b0597:\n        if (((iVar10 == 0) && (read_timeout != (ulong *)0x0)) &&\n           (iVar10 = shtimer_chktimeout(), iVar10 != 0)) goto LAB_001b05bd;\n      }\n      iVar12 = 4;\n      if (3 < iVar34) {\n        iVar12 = iVar34;\n      }\n      if (local_370 <= iVar12 + local_2a0) {\n        local_370 = local_370 + 0x80;\n        pbVar20 = (byte *)sh_xrealloc(local_280,(long)local_370,\"./read.def\",0x2d5);\n        if (local_280 != pbVar20) {\n          local_280 = pbVar20;\n          remove_unwind_protect();\n          add_unwind_protect(xfree,local_280);\n        }\n      }\n      bVar9 = local_2a2;\n      if (local_364 == 0) goto LAB_001b05c8;\n      if (local_2a2 == 10) {\n        if ((!bVar2) && (0 < local_2a0)) {\n          local_2a0 = local_2a0 + -1;\n        }\n        if (((interactive == 0) || (uVar11 == 0)) || ((char)uVar33 == '\\0')) {\n          local_364 = 0;\n        }\n        else {\n          pcVar19 = (code *)(ulong)local_364;\n          local_364 = 0;\n        }\n      }\n      else {\n        local_364 = 0;\nLAB_001b00e7:\n        do {\n          lVar15 = (long)local_2a0;\n          local_2a0 = local_2a0 + 1;\n          local_280[lVar15] = bVar9;\n          if ((read_timeout != (ulong *)0x0) &&\n             (iVar12 = shtimer_chktimeout(), cVar5 = cVar36, iVar12 != 0)) goto LAB_001b05bd;\n          pbVar20 = local_280;\n          iVar12 = local_2a0;\n          if ((1 < iVar34) &&\n             ((*(uint *)(is_basic_table + (ulong)(local_2a2 >> 5) * 4) >> (local_2a2 & 0x1f) & 1) ==\n              0)) {\n            local_280[local_2a0] = 0;\n            iVar13 = (int)__set;\n            if (local_374 == 0) {\n              if ((locale_utf8locale == 0) || ((char)local_2a2 < '\\0')) {\n                local_58[0] = local_2a2;\n                local_270.__count = 0;\n                local_270.__value = (_union_27)0x0;\n                sVar14 = 1;\n                while( true ) {\n                  mVar8 = local_270;\n                  sVar21 = mbrtowc(&local_29c,(char *)local_58,sVar14,&local_270);\n                  if (sVar21 != 0xfffffffffffffffe) break;\n                  local_270 = mVar8;\n                  if (cVar36 == '\\x02') {\n                    iVar13 = zreadn(local_360,&local_2a1,1);\n                  }\n                  else if (cVar36 == '\\0') {\n                    iVar13 = zreadc(local_360);\n                  }\n                  else {\n                    iVar13 = zread(local_360,&local_2a1,1);\n                  }\n                  if (iVar13 < 1) break;\n                  local_58[sVar14] = local_2a1;\n                  sVar14 = sVar14 + 1;\n                }\n                sVar21 = 1;\n                pcVar19 = (code *)((ulong)pcVar19 & 0xffffffff);\n                __set = (sigset_t *)((ulong)__set & 0xffffffff);\n                if ((int)sVar14 != 1) {\n                  do {\n                    pbVar20[sVar21 + (long)iVar12 + -1] = local_58[sVar21];\n                    sVar21 = sVar21 + 1;\n                  } while (sVar14 != sVar21);\n                }\n                local_2a0 = local_2a0 + -1 + (int)sVar14;\n              }\n            }\n            else {\n              sVar14 = __mbrlen((char *)((long)psVar31->__val + (long)iVar13 + -1),(long)iVar34,\n                                (mbstate_t *)0x0);\n              iVar12 = (int)sVar14;\n              if (1 < iVar12) {\n                memcpy(local_280 + local_2a0,(void *)((long)psVar31->__val + (long)iVar13),\n                       sVar14 - 1);\n                local_2a0 = local_2a0 + -1 + iVar12;\n                __set = (sigset_t *)(ulong)(uint)(iVar13 + -1 + iVar12);\n              }\n            }\n          }\n          local_37c = local_37c + 1;\n          if ((local_36c < 1) || (local_37c < local_36c)) break;\n          psVar32 = (sigset_t *)0x0;\n          local_338 = psVar31;\nLAB_001b01b0:\n          while( true ) {\n            local_280[local_2a0] = 0;\n            if ((read_timeout == (ulong *)0x0) ||\n               (iVar12 = shtimer_chktimeout(), psVar31 = psVar32, cVar5 = cVar36, iVar12 == 0)) {\n              if (local_374 != 0) {\n                sh_xfree(local_338,\"./read.def\",0x334);\n              }\n              if (iVar10 < 0) {\n                piVar23 = __errno_location();\n                iVar34 = *piVar23;\n                if (iVar34 != 4) {\n                  pcVar24 = strerror(iVar34);\n                  builtin_error(\"read error: %d: %s\",local_360,pcVar24);\n                }\n                run_unwind_frame(\"read_builtin\");\n                if (iVar34 != 4) goto LAB_001b0480;\n                psVar32 = (sigset_t *)(ulong)(local_2b4 + 0x80);\n                goto LAB_001af993;\n              }\n              if ((local_380 | local_384) != 0) {\n                if (read_timeout != (ulong *)0x0) {\n                  shtimer_clear();\n                }\n                read_timeout = (ulong *)0x0;\n              }\n              if (((local_36c < 1) && (DAT_00248c00 == 10)) || (local_33c = uVar11, local_374 == 0))\n              {\n                if (local_33c != 0) {\n                  ttsetattr(DAT_00248bc0,&DAT_00248bc4);\n                  DAT_00248c04 = 0;\n                }\n              }\n              else {\n                if (0 < local_36c) {\n                  rl_num_chars_to_read = 0;\n                }\n                if (DAT_00248c00 != 10) {\n                  lVar15 = rl_get_keymap();\n                  *(char *)(lVar15 + 0xd0) = (char)DAT_00248b78;\n                  *(undefined8 *)(lVar15 + 0xd8) = DAT_00248b70;\n                  puVar16 = (undefined *)(lVar15 + (ulong)DAT_00248b68 * 0x10);\n                  *puVar16 = (char)DAT_00248b88;\n                  *(undefined8 *)(puVar16 + 8) = DAT_00248b80;\n                }\n              }\n              if (cVar36 == '\\0') {\n                zsyncfd(local_360);\n              }\n              if (local_2d8 != (FILE *)0x0) {\n                rl_instream = local_2d8;\n              }\n              discard_unwind_frame(\"read_builtin\");\n              goto LAB_001b02c3;\n            }\nLAB_001b05bd:\n            bVar9 = FUN_001af770();\n            cVar36 = cVar5;\nLAB_001b05c8:\n            if (((char)uVar33 != '\\0') && (bVar9 == 0x5c)) {\n              local_364 = 1;\n              if (!bVar2) {\n                lVar15 = (long)local_2a0;\n                local_318 = local_318 + 1;\n                local_2a0 = local_2a0 + 1;\n                local_280[lVar15] = 1;\n              }\n              goto LAB_001afff0;\n            }\n            if ((bVar4) || (bVar9 != DAT_00248c00)) break;\n            psVar32 = (sigset_t *)(ulong)local_364;\n            local_338 = psVar31;\n          }\n          if (bVar9 != 0) {\n            if (((bVar9 == 1) && (!bVar2)) || ((!bVar3 && (bVar9 == 0x7f)))) {\n              lVar15 = (long)local_2a0;\n              local_318 = local_318 + 1;\n              local_2a0 = local_2a0 + 1;\n              local_280[lVar15] = 1;\n              bVar9 = local_2a2;\n            }\n            goto LAB_001b00e7;\n          }\n        } while (DAT_00248c00 == 0);\n      }\n    } while( true );\n  }\n  uVar22 = read(local_360,&local_2a2,0);\n  psVar32 = (sigset_t *)((uVar22 & 0xffffffff) >> 0x1f);\nLAB_001b02c3:\n  pbVar20 = local_280;\n  if (local_348 == (byte *)0x0) {\n    if (local_390 == (long **)0x0) {\n      if (local_318 == 0) {\n        lVar15 = bind_variable(\"REPLY\",local_280,0);\n      }\n      else {\n        uVar27 = dequote_string(local_280);\n        lVar15 = bind_variable(\"REPLY\",uVar27,0);\n        sh_xfree(uVar27,\"./read.def\",0x396);\n      }\n      if ((lVar15 == 0) || ((*(uint *)(lVar15 + 0x28) & 0x4002) != 0)) {\n        psVar32 = (sigset_t *)0x1;\n      }\n      else {\n        *(uint *)(lVar15 + 0x28) = *(uint *)(lVar15 + 0x28) & 0xffffefff;\n      }\n      sh_xfree(local_280,\"./read.def\",0x39f);\n      goto LAB_001af993;\n    }\n    if (*local_320 != '\\0') {\n      while( true ) {\n        bVar9 = *local_280;\n        if ((1 < (byte)(bVar9 - 9)) && (bVar9 != 0x20)) break;\n        if ((*(char *)((long)&ifs_cmap + (ulong)bVar9) == '\\0') ||\n           (local_280 = local_280 + 1, *local_320 == '\\0')) break;\n      }\n    }\n    if (*local_390 != (long *)0x0) {\n      do {\n        lVar15 = *local_390[1];\n        if (assoc_expand_once == 0) {\n          iVar10 = 0;\n          iVar12 = legal_identifier(lVar15);\n          iVar34 = 0;\n        }\n        else {\n          uVar11 = *(uint *)(local_390[1] + 1) & 0x200;\n          iVar10 = (-(uint)(uVar11 == 0) & 0xfffffffe) + 3;\n          iVar34 = (-(uint)(uVar11 == 0) & 0xfffff000) + 0x1080;\n          iVar12 = legal_identifier(lVar15);\n        }\n        if ((iVar12 == 0) && (iVar10 = valid_array_reference(lVar15,iVar10), iVar10 == 0)) {\n          sh_invalidid(lVar15);\n          sh_xfree(pbVar20,\"./read.def\",0x3b7);\n          goto LAB_001b0480;\n        }\n        if (*local_280 == 0) {\n          lVar17 = builtin_bind_variable(lVar15,&DAT_00213d70,iVar34);\n          if ((lVar17 == 0) || ((*(uint *)(lVar17 + 0x28) & 0x4002) != 0)) {\nLAB_001b0dcb:\n            sh_xfree(pbVar20,\"./read.def\",0x3d7);\n            goto LAB_001b0480;\n          }\n        }\n        else {\n          puVar16 = (undefined *)get_word_from_string(&local_280,local_320,&local_278);\n          if (puVar16 == (undefined *)0x0) {\n            puVar30 = &DAT_00213d70;\nLAB_001b0cba:\n            lVar17 = builtin_bind_variable(lVar15,puVar30,iVar34);\n            if ((lVar17 == 0) || ((*(uint *)(lVar17 + 0x28) & 0x4002) != 0)) {\n              if (puVar16 != (undefined *)0x0) goto LAB_001b0df5;\n              goto LAB_001b0dcb;\n            }\n            if (puVar16 != (undefined *)0x0) goto LAB_001b0ce3;\n          }\n          else {\n            *local_278 = '\\0';\n            puVar30 = puVar16;\n            if (local_318 == 0) goto LAB_001b0cba;\n            uVar27 = dequote_string(puVar16,puVar16);\n            lVar17 = builtin_bind_variable(lVar15,uVar27,iVar34);\n            if ((lVar17 == 0) || ((*(uint *)(lVar17 + 0x28) & 0x4002) != 0)) {\n              sh_xfree(uVar27,\"./read.def\",0x3c9);\nLAB_001b0df5:\n              sh_xfree(puVar16,\"./read.def\",0x3d4);\n              goto LAB_001b0dcb;\n            }\n            sh_xfree(uVar27,\"./read.def\",0x3c9);\nLAB_001b0ce3:\n            sh_xfree(puVar16,\"./read.def\",0x3d4);\n          }\n        }\n        stupidly_hack_special_variables(lVar15);\n        local_390 = (long **)*local_390;\n        *(uint *)(lVar17 + 0x28) = *(uint *)(lVar17 + 0x28) & 0xffffefff;\n      } while (*local_390 != (long *)0x0);\n    }\n    if (assoc_expand_once == 0) {\n      iVar10 = 0;\n      iVar34 = 0;\n    }\n    else {\n      iVar10 = (-(uint)((*(uint *)(local_390[1] + 1) & 0x200) == 0) & 0xfffffffe) + 3;\n      iVar34 = (-(uint)((*(uint *)(local_390[1] + 1) & 0x200) == 0) & 0xfffff000) + 0x1080;\n    }\n    iVar12 = legal_identifier(*local_390[1]);\n    if ((iVar12 != 0) || (iVar10 = valid_array_reference(*local_390[1],iVar10), iVar10 != 0)) {\n      pbVar7 = local_280;\n      if (*local_280 == 0) {\n        pbVar26 = (byte *)0x0;\n        pbVar28 = local_280;\nLAB_001b14ac:\n        lVar15 = builtin_bind_variable(*local_390[1],pbVar28,iVar34);\n        if ((lVar15 == 0) || ((*(uint *)(lVar15 + 0x28) & 0x4002) != 0)) {\n          psVar32 = (sigset_t *)0x1;\n        }\n        else {\nLAB_001b14dc:\n          stupidly_hack_special_variables(*local_390[1]);\n          *(uint *)(lVar15 + 0x28) = *(uint *)(lVar15 + 0x28) & 0xffffefff;\n        }\n      }\n      else {\n        pbVar26 = (byte *)get_word_from_string(&local_280,local_320,&local_278);\n        pbVar28 = pbVar26;\n        if (*local_280 != 0) {\n          pbVar28 = (byte *)strip_trailing_ifs_whitespace(pbVar7,local_320,local_318);\n        }\n        local_280 = pbVar28;\n        if (local_318 == 0) {\n          if (pbVar28 == (byte *)0x0) {\n            pbVar28 = &DAT_00213d70;\n          }\n          goto LAB_001b14ac;\n        }\n        if (pbVar28 == (byte *)0x0) {\n          pbVar28 = &DAT_00213d70;\n          goto LAB_001b14ac;\n        }\n        if (*pbVar28 == 0) goto LAB_001b14ac;\n        uVar27 = dequote_string(pbVar28);\n        lVar15 = builtin_bind_variable(*local_390[1],uVar27,iVar34);\n        if ((lVar15 != 0) && ((*(uint *)(lVar15 + 0x28) & 0x4002) == 0)) {\n          sh_xfree(uVar27,\"./read.def\",0x407);\n          goto LAB_001b14dc;\n        }\n        sh_xfree(uVar27,\"./read.def\",0x407);\n        psVar32 = (sigset_t *)0x1;\n      }\n      if (pbVar26 != (byte *)0x0) {\n        sh_xfree(pbVar26,\"./read.def\",0x414);\n      }\n      sh_xfree(pbVar20,\"./read.def\",0x415);\n      goto LAB_001af993;\n    }\n    sh_invalidid(*local_390[1]);\n    sh_xfree(pbVar20,\"./read.def\",1000);\n    goto LAB_001b0480;\n  }\n  lVar15 = builtin_find_indexed_array(local_348,3);\n  if (lVar15 != 0) {\n    lVar17 = list_string(local_280,local_320,0);\n    if (lVar17 != 0) {\n      if (local_318 == 0) {\n        word_list_remove_quoted_nulls(lVar17);\n      }\n      else {\n        dequote_list();\n      }\n      assign_array_var_from_word_list(lVar15,lVar17,0);\n      dispose_words(lVar17);\n    }\n    sh_xfree(local_280,\"./read.def\",0x37b);\n    goto LAB_001af993;\n  }\n  sh_xfree(local_280,\"./read.def\",0x36d);\nLAB_001b0480:\n  psVar32 = (sigset_t *)0x1;\nLAB_001af993:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return psVar32;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\ncode_r0x001af9f4:\n  iVar10 = sh_validfd(local_288 & 0xffffffff);\n  if (iVar10 == 0) goto code_r0x001afa0f;\n  goto LAB_001af900;\ncode_r0x001afa0f:\n  piVar23 = __errno_location();\n  pcVar24 = strerror(*piVar23);\n  builtin_error(\"%d: invalid file descriptor: %s\",uVar22 & 0xffffffff,pcVar24);\n  goto LAB_001b0480;\n}\n\n",
  "_rl_forward_char_internal": "\nint _rl_forward_char_internal(undefined4 param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = _rl_find_next_mbchar(rl_line_buffer,rl_point,param_1,1);\n  if (((rl_end <= iVar1) && (rl_editing_mode == 0)) && (_rl_keymap == vi_movement_keymap)) {\n    iVar1 = _rl_find_prev_mbchar(rl_line_buffer,rl_end,1);\n  }\n  if (rl_end < 0) {\n    rl_end = 0;\n  }\n  if (rl_end < iVar1) {\n    iVar1 = rl_end;\n  }\n  return iVar1;\n}\n\n",
  "array_to_argv": "\nundefined8 * array_to_argv(long param_1,undefined4 *param_2)\n\n{\n  undefined8 *puVar1;\n  size_t sVar2;\n  char *__dest;\n  char *pcVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  long lVar6;\n  \n  if ((param_1 == 0) || (*(long *)(param_1 + 8) == 0)) {\n    puVar1 = (undefined8 *)0x0;\n    if (param_2 != (undefined4 *)0x0) {\n      *param_2 = 0;\n    }\n  }\n  else {\n    puVar1 = (undefined8 *)strvec_create((int)*(long *)(param_1 + 8) + 1);\n    lVar5 = *(long *)(*(long *)(param_1 + 0x10) + 0x10);\n    if (*(long *)(param_1 + 0x10) == lVar5) {\n      lVar6 = 0;\n      puVar4 = puVar1;\n    }\n    else {\n      lVar6 = 0;\n      do {\n        pcVar3 = *(char **)(lVar5 + 8);\n        if (pcVar3 != (char *)0x0) {\n          sVar2 = strlen(pcVar3);\n          __dest = (char *)sh_xmalloc(sVar2 + 1,\"array.c\",0x351);\n          pcVar3 = strcpy(__dest,pcVar3);\n          puVar1[lVar6] = pcVar3;\n          lVar6 = (long)((int)lVar6 + 1);\n        }\n        lVar5 = *(long *)(lVar5 + 0x10);\n      } while (*(long *)(param_1 + 0x10) != lVar5);\n      puVar4 = puVar1 + (int)lVar6;\n    }\n    *puVar4 = 0;\n    if (param_2 != (undefined4 *)0x0) {\n      *param_2 = (int)lVar6;\n    }\n  }\n  return puVar1;\n}\n\n",
  "rl_vi_change_char": "\nundefined4 rl_vi_change_char(undefined4 param_1)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  char acStack_38 [16];\n  undefined local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (_rl_vi_redoing == 0) {\n    if ((rl_readline_state._2_1_ & 8) != 0) {\n      _rl_callback_data = _rl_callback_data_alloc();\n      _rl_callback_func = FUN_001d34a0;\n      uVar2 = 0;\n      goto LAB_001d3d32;\n    }\n    uVar1 = _rl_bracketed_read_mbstring(acStack_38,0x10);\n    if (-1 < (int)uVar1) {\n      sVar3 = __ctype_get_mb_cur_max();\n      if ((sVar3 < 2) || (rl_byte_oriented != 0)) {\n        DAT_0024a3d0 = (byte)uVar1;\n      }\n      else {\n        strncpy((char *)&DAT_0024a3d0,acStack_38,0x10);\n      }\n      DAT_0024a3e0 = 0;\n      goto LAB_001d3cea;\n    }\n  }\n  else {\n    strncpy(acStack_38,(char *)&DAT_0024a3d0,0x10);\n    local_28 = 0;\n    uVar1 = (uint)DAT_0024a3d0;\nLAB_001d3cea:\n    if ((uVar1 != 0x1b) && (uVar1 != 3)) {\n      rl_begin_undo_group();\n      uVar2 = FUN_001d33a0(param_1,uVar1,acStack_38);\n      goto LAB_001d3d32;\n    }\n  }\n  uVar2 = 0xffffffff;\nLAB_001d3d32:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "get_posix_options": "\nvoid get_posix_options(long param_1)\n\n{\n  undefined4 *puVar1;\n  undefined4 *puVar2;\n  long lVar3;\n  undefined4 *puVar4;\n  \n  if (param_1 == 0) {\n    param_1 = sh_xmalloc(5,\"general.c\",0x8f);\n  }\n  lVar3 = 0;\n  puVar1 = &source_uses_path;\n  puVar4 = &interactive_comments;\n  while( true ) {\n    puVar2 = puVar1;\n    *(char *)(param_1 + lVar3) = (char)*puVar4;\n    lVar3 = lVar3 + 1;\n    if (puVar2 == (undefined4 *)0x0) break;\n    puVar1 = (undefined4 *)(&PTR_source_uses_path_00235f88)[lVar3];\n    puVar4 = puVar2;\n  }\n  return;\n}\n\n",
  "unbind_global_variable_noref": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 unbind_global_variable_noref(undefined8 param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long lVar4;\n  \n  lVar4 = global_variables;\n  if (global_variables != 0) {\n    do {\n      uVar3 = *(undefined8 *)(lVar4 + 0x20);\n      lVar2 = hash_search(param_1,uVar3,0);\n      if ((lVar2 != 0) && (_DAT_002422f8 = uVar3, *(long *)(lVar2 + 0x10) != 0)) {\n        uVar3 = makunbound(param_1,global_variables);\n        return uVar3;\n      }\n      plVar1 = (long *)(lVar4 + 0x18);\n      lVar4 = *plVar1;\n    } while (*plVar1 != 0);\n  }\n  return 0;\n}\n\n",
  "copy_function_def_contents": "\nundefined4 * copy_function_def_contents(undefined4 *param_1,undefined4 *param_2)\n\n{\n  undefined4 uVar1;\n  undefined8 *puVar2;\n  long lVar3;\n  long lVar4;\n  size_t sVar5;\n  char *__dest;\n  char *__s;\n  \n  puVar2 = *(undefined8 **)(param_1 + 2);\n  lVar3 = make_bare_word(*puVar2);\n  lVar4 = *(long *)(param_1 + 4);\n  *(undefined4 *)(lVar3 + 8) = *(undefined4 *)(puVar2 + 1);\n  *(long *)(param_2 + 2) = lVar3;\n  if (lVar4 != 0) {\n    lVar4 = copy_command();\n  }\n  uVar1 = *param_1;\n  __s = *(char **)(param_1 + 6);\n  *(long *)(param_2 + 4) = lVar4;\n  *param_2 = uVar1;\n  param_2[1] = param_1[1];\n  if (__s != (char *)0x0) {\n    sVar5 = strlen(__s);\n    __dest = (char *)sh_xmalloc(sVar5 + 1,\"copy_cmd.c\",0x15b);\n    __s = strcpy(__dest,__s);\n  }\n  *(char **)(param_2 + 6) = __s;\n  return param_2;\n}\n\n",
  "add_alias": "\nvoid add_alias(char *param_1,char *param_2)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *pcVar3;\n  char **ppcVar4;\n  byte bVar5;\n  \n  if (aliases == 0) {\n    aliases = hash_create(0x40);\n  }\n  else {\n    lVar1 = hash_search(param_1,aliases,0);\n    if ((lVar1 != 0) && (lVar1 = *(long *)(lVar1 + 0x10), lVar1 != 0)) {\n      sh_xfree(*(undefined8 *)(lVar1 + 8),\"alias.c\",0x7f);\n      sVar2 = strlen(param_2);\n      pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"alias.c\",0x80);\n      pcVar3 = strcpy(pcVar3,param_2);\n      *(char **)(lVar1 + 8) = pcVar3;\n      bVar5 = *(byte *)(lVar1 + 0x10) & 0xfe;\n      *(byte *)(lVar1 + 0x10) = bVar5;\n      if (*param_2 != '\\0') {\n        sVar2 = strlen(param_2);\n        if ((param_2[sVar2 - 1] == ' ') || (param_2[sVar2 - 1] == '\\t')) {\n          *(byte *)(lVar1 + 0x10) = bVar5 | 1;\n        }\n      }\n      return;\n    }\n  }\n  ppcVar4 = (char **)sh_xmalloc(0x18,\"alias.c\",0x8b);\n  sVar2 = strlen(param_1);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"alias.c\",0x8c);\n  pcVar3 = strcpy(pcVar3,param_1);\n  *ppcVar4 = pcVar3;\n  sVar2 = strlen(param_2);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"alias.c\",0x8d);\n  pcVar3 = strcpy(pcVar3,param_2);\n  *(undefined *)(ppcVar4 + 2) = 0;\n  ppcVar4[1] = pcVar3;\n  if (*param_2 != '\\0') {\n    sVar2 = strlen(param_2);\n    if ((param_2[sVar2 - 1] == ' ') || (param_2[sVar2 - 1] == '\\t')) {\n      *(undefined *)(ppcVar4 + 2) = 1;\n    }\n  }\n  lVar1 = aliases;\n  sVar2 = strlen(param_1);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"alias.c\",0x97);\n  pcVar3 = strcpy(pcVar3,param_1);\n  lVar1 = hash_insert(pcVar3,lVar1,1);\n  *(char ***)(lVar1 + 0x10) = ppcVar4;\n  set_itemlist_dirty(it_aliases);\n  return;\n}\n\n",
  "expand_string_unsplit": "\nlong expand_string_unsplit(char *param_1)\n\n{\n  uint *puVar1;\n  long lVar2;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    DAT_00247848 = 1;\n    lVar2 = FUN_0017aeb0();\n    DAT_00247848 = 0;\n    if (lVar2 != 0) {\n      if (*(undefined8 **)(lVar2 + 8) != (undefined8 *)0x0) {\n        remove_quoted_nulls(**(undefined8 **)(lVar2 + 8));\n        puVar1 = (uint *)(*(long *)(lVar2 + 8) + 8);\n        *puVar1 = *puVar1 & 0xfffbffff;\n      }\n      dequote_list(lVar2);\n      return lVar2;\n    }\n  }\n  return 0;\n}\n\n",
  "FUN_001674a0": "\nvoid FUN_001674a0(long param_1,int *param_2,uint param_3)\n\n{\n  byte bVar1;\n  bool bVar2;\n  mbstate_t mVar3;\n  size_t sVar4;\n  ulong uVar5;\n  ulong uVar6;\n  int iVar7;\n  uint uVar8;\n  ulong uVar9;\n  byte *__s;\n  long in_FS_OFFSET;\n  long local_60;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar4 = __ctype_get_mb_cur_max();\n  iVar7 = *param_2;\n  uVar6 = (ulong)iVar7;\n  __s = (byte *)(param_1 + uVar6);\n  if (sVar4 < 2) {\n    local_60 = 0;\n  }\n  else {\n    sVar4 = strlen((char *)__s);\n    local_60 = sVar4 + uVar6;\n  }\n  bVar1 = *__s;\n  if (bVar1 != 0) {\n    bVar2 = false;\n    uVar9 = uVar6;\n    do {\n      mVar3 = local_48;\n      if (bVar2) {\n        iVar7 = (int)uVar9;\n        if (1 < locale_mb_cur_max) {\n          if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale != 0) && (sVar4 = 1, -1 < (char)bVar1)) goto LAB_00167563;\n            sVar4 = mbrtowc((wchar_t *)0x0,(char *)__s,local_60 - uVar6,&local_48);\n            if (sVar4 < 0xfffffffffffffffe) {\n              if (sVar4 != 0) goto LAB_00167563;\n              uVar9 = (ulong)(iVar7 + 1);\n            }\n            else {\n              uVar9 = (ulong)(iVar7 + 1);\n              local_48 = mVar3;\n            }\n          }\n          else {\n            sVar4 = 1;\nLAB_00167563:\n            uVar9 = (ulong)(uint)(iVar7 + (int)sVar4);\n          }\n          uVar6 = (ulong)(int)uVar9;\n          __s = (byte *)(param_1 + uVar6);\n          bVar1 = *__s;\n          if (bVar1 != 0) goto LAB_00167574;\n          break;\n        }\n        uVar8 = iVar7 + 1;\n        uVar9 = (ulong)uVar8;\n        __s = (byte *)((int)uVar8 + param_1);\n        bVar1 = *__s;\n        if (bVar1 == 0) break;\n        if ((bVar1 != 0x5c) || ((param_3 & 1) == 0)) {\n          if (bVar1 == 0x27) break;\n          bVar2 = false;\n        }\nLAB_00167660:\n        uVar9 = (ulong)(uVar8 + 1);\n      }\n      else {\nLAB_00167574:\n        mVar3 = local_48;\n        uVar5 = (ulong)bVar1;\n        uVar8 = (uint)uVar9;\n        if ((bVar1 == 0x5c) && ((param_3 & 1) != 0)) {\n          uVar5 = 0x5c;\n          bVar2 = true;\n        }\n        else {\n          if (bVar1 == 0x27) break;\n          bVar2 = false;\n        }\n        if (locale_mb_cur_max < 2) goto LAB_00167660;\n        if ((*(uint *)(is_basic_table + (uVar5 >> 5) * 4) >> ((byte)uVar5 & 0x1f) & 1) == 0) {\n          if ((locale_utf8locale != 0) && (sVar4 = 1, -1 < (char)(byte)uVar5)) goto LAB_001675c1;\n          sVar4 = mbrtowc((wchar_t *)0x0,(char *)__s,local_60 - uVar6,&local_48);\n          if (sVar4 < 0xfffffffffffffffe) {\n            if (sVar4 == 0) goto LAB_00167660;\n            goto LAB_001675c1;\n          }\n          uVar9 = (ulong)(uVar8 + 1);\n          local_48 = mVar3;\n        }\n        else {\n          sVar4 = 1;\nLAB_001675c1:\n          uVar9 = (ulong)(uVar8 + (int)sVar4);\n        }\n      }\n      uVar6 = (ulong)(int)uVar9;\n      __s = (byte *)(param_1 + uVar6);\n      bVar1 = *__s;\n    } while (bVar1 != 0);\n    iVar7 = *param_2;\n    uVar6 = uVar9;\n  }\n  substring(param_1,iVar7,uVar6 & 0xffffffff);\n  *param_2 = ((int)uVar6 + 1) - (uint)(*__s == 0);\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "save_input_line_state": "\nundefined8 * save_input_line_state(undefined8 *param_1)\n\n{\n  undefined8 uVar1;\n  \n  if ((param_1 == (undefined8 *)0x0) &&\n     (param_1 = (undefined8 *)sh_xmalloc(0x30,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1a12),\n     param_1 == (undefined8 *)0x0)) {\n    return (undefined8 *)0x0;\n  }\n  uVar1 = DAT_00240da8;\n  DAT_00240da8 = 0;\n  *param_1 = uVar1;\n  uVar1 = DAT_00240d98;\n  DAT_00240d98 = 0;\n  param_1[2] = uVar1;\n  uVar1 = DAT_00240d90;\n  DAT_00240d90 = 0;\n  param_1[3] = uVar1;\n  uVar1 = DAT_00240da0;\n  DAT_00240da0 = 0;\n  param_1[1] = uVar1;\n  uVar1 = DAT_00240e48;\n  DAT_00240e48 = 0;\n  param_1[4] = uVar1;\n  uVar1 = DAT_00240e40;\n  DAT_00240e40 = 0;\n  param_1[5] = uVar1;\n  return param_1;\n}\n\n",
  "set_var_attribute": "\nvoid set_var_attribute(undefined8 param_1,uint param_2,int param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  size_t sVar4;\n  char *__dest;\n  char *pcVar5;\n  undefined1 *puVar6;\n  long lVar7;\n  uint uVar8;\n  \n  if (param_3 == 0) {\n    puVar3 = (undefined8 *)find_tempenv_variable();\n    if ((puVar3 == (undefined8 *)0x0) || ((*(byte *)((long)puVar3 + 0x2a) & 0x10) == 0)) {\n      lVar2 = find_variable_notempenv(param_1);\n      if (lVar2 == 0) {\n        puVar6 = (undefined1 *)find_variable_nameref_for_create(param_1,0);\n        if (puVar6 == nameref_invalid_value) {\n          return;\n        }\n        lVar2 = bind_variable(param_1,0,0);\n        if (lVar2 == 0) {\n          return;\n        }\n        uVar8 = *(uint *)(lVar2 + 0x28) | 0x1000;\n        *(uint *)(lVar2 + 0x28) = uVar8;\n      }\n      else {\n        uVar8 = *(uint *)(lVar2 + 0x28);\n        if (*(int *)(lVar2 + 0x2c) != 0) {\n          *(uint *)(lVar2 + 0x28) = uVar8 | 0x200000;\n          uVar8 = uVar8 | 0x200000 | param_2;\n          *(uint *)(lVar2 + 0x28) = uVar8;\n          goto LAB_001b3606;\n        }\n      }\n    }\n    else {\n      pcVar5 = (char *)puVar3[1];\n      if (pcVar5 == (char *)0x0) {\n        pcVar5 = (char *)sh_xmalloc(1,\"./setattr.def\",0x25f);\n        *pcVar5 = '\\0';\n      }\n      else {\n        sVar4 = strlen(pcVar5);\n        __dest = (char *)sh_xmalloc(sVar4 + 1,\"./setattr.def\",0x25f);\n        pcVar5 = strcpy(__dest,pcVar5);\n      }\n      lVar2 = bind_variable(*puVar3,pcVar5,0);\n      iVar1 = posixly_correct;\n      if (lVar2 == 0) {\n        sh_xfree(pcVar5,\"./setattr.def\",0x264);\n        return;\n      }\n      *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) | *(uint *)(puVar3 + 5) & 0xffefffff;\n      if ((iVar1 != 0) || (shell_compatibility_level < 0x2d)) {\n        iVar1 = *(int *)(lVar2 + 0x2c);\n        if ((iVar1 == 0) && ((param_2 & 2) != 0)) {\n          lVar7 = find_global_variable(*puVar3);\n          if (lVar2 != lVar7) {\n            *(uint *)(puVar3 + 5) = *(uint *)(puVar3 + 5) | 0x200000;\n          }\n          iVar1 = *(int *)(lVar2 + 0x2c);\n        }\n        else {\n          *(uint *)(puVar3 + 5) = *(uint *)(puVar3 + 5) | 0x200000;\n        }\n        if (iVar1 != 0) {\n          *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) | 0x200000;\n        }\n      }\n      *(uint *)(puVar3 + 5) = *(uint *)(puVar3 + 5) | param_2;\n      stupidly_hack_special_variables(*puVar3);\n      sh_xfree(pcVar5,\"./setattr.def\",0x27f);\n      uVar8 = *(uint *)(lVar2 + 0x28);\n    }\n    uVar8 = uVar8 | param_2;\n    *(uint *)(lVar2 + 0x28) = uVar8;\n  }\n  else {\n    lVar2 = find_variable();\n    if (lVar2 == 0) {\n      return;\n    }\n    uVar8 = *(uint *)(lVar2 + 0x28) | param_2;\n    *(uint *)(lVar2 + 0x28) = ~param_2 & *(uint *)(lVar2 + 0x28);\n  }\nLAB_001b3606:\n  if ((uVar8 & 1) == 0) {\n    return;\n  }\n  array_needs_making = array_needs_making + 1;\n  return;\n}\n\n",
  "mblen": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mblen(char *__s,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_mblen_00237860)();\n  return iVar1;\n}\n\n",
  "command_connect": "\nvoid command_connect(undefined8 param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  undefined4 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x20,\"make_cmd.c\",0xc0);\n  puVar1[6] = param_3;\n  *(undefined8 *)(puVar1 + 2) = param_1;\n  *(undefined8 *)(puVar1 + 4) = param_2;\n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar2[3] = puVar1;\n  *puVar2 = 6;\n  *puVar1 = 0;\n  puVar2[2] = 0;\n  return;\n}\n\n",
  "get_all_original_signals": "\nvoid get_all_original_signals(void)\n\n{\n  code *pcVar1;\n  ulong uVar2;\n  code **ppcVar3;\n  \n  ppcVar3 = (code **)(original_signals + 8);\n  uVar2 = 1;\n  do {\n    if (*ppcVar3 == initialize_traps) {\n      pcVar1 = (code *)set_signal_handler(uVar2 & 0xffffffff,0);\n      *ppcVar3 = pcVar1;\n      set_signal_handler(uVar2 & 0xffffffff);\n      if (*ppcVar3 == (code *)0x1) {\n        (&DAT_00247e40)[uVar2] = (&DAT_00247e40)[uVar2] | 2;\n      }\n    }\n    ppcVar3 = ppcVar3 + 1;\n    uVar2 = uVar2 + 1;\n  } while (uVar2 != 0x41);\n  return;\n}\n\n",
  "rl_variable_bind": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint rl_variable_bind(char *param_1,char *param_2)\n\n{\n  char cVar1;\n  uint *puVar2;\n  int iVar3;\n  int iVar4;\n  uint uVar5;\n  undefined **ppuVar6;\n  char *pcVar7;\n  long lVar8;\n  \n  pcVar7 = \"bind-tty-special-chars\";\n  iVar4 = 0;\n  ppuVar6 = &PTR_s_blink_matching_paren_002372b8;\n  while (iVar3 = strcasecmp(param_1,pcVar7), iVar3 != 0) {\n    pcVar7 = *ppuVar6;\n    ppuVar6 = ppuVar6 + 3;\n    iVar4 = iVar4 + 1;\n    if (pcVar7 == (char *)0x0) {\n      ppuVar6 = &PTR_s_active_region_start_color_00235858;\n      iVar4 = 0;\n      pcVar7 = \"active-region-end-color\";\n      while (iVar3 = strcasecmp(param_1,pcVar7), iVar3 != 0) {\n        pcVar7 = *ppuVar6;\n        ppuVar6 = ppuVar6 + 3;\n        iVar4 = iVar4 + 1;\n        if (pcVar7 == (char *)0x0) {\n          FUN_001da6e0(\"%s: unknown variable name\",param_1);\n          return 0;\n        }\n      }\n      if ((code *)(&PTR_FUN_00235850)[(long)iVar4 * 3] == (code *)0x0) {\n        return 0;\n      }\n      iVar4 = (*(code *)(&PTR_FUN_00235850)[(long)iVar4 * 3])(param_2);\n      if (iVar4 != 0) {\n        FUN_001da6e0(\"%s: could not set value to `%s\\'\",param_1,param_2);\n        return iVar4;\n      }\n      return 0;\n    }\n  }\n  lVar8 = (long)iVar4;\n  puVar2 = (uint *)(&PTR__rl_bind_stty_chars_002372a8)[lVar8 * 3];\n  if (((param_2 == (char *)0x0) || (cVar1 = *param_2, cVar1 == '\\0')) ||\n     (iVar4 = strcasecmp(param_2,\"on\"), iVar4 == 0)) {\n    uVar5 = 1;\n  }\n  else {\n    uVar5 = 0;\n    if (cVar1 == '1') {\n      uVar5 = (uint)(param_2[1] == '\\0');\n    }\n  }\n  *puVar2 = uVar5;\n  if (((&DAT_002372b0)[lVar8 * 0x18] & 1) == 0) {\n    return 0;\n  }\n  pcVar7 = (&PTR_s_bind_tty_special_chars_002372a0)[lVar8 * 3];\n  iVar4 = strcasecmp(pcVar7,\"blink-matching-paren\");\n  if (iVar4 == 0) {\n    _rl_enable_paren_matching(rl_blink_matching_paren);\n    return 0;\n  }\n  iVar4 = strcasecmp(pcVar7,\"prefer-visible-bell\");\n  if (iVar4 != 0) {\n    iVar4 = strcasecmp(pcVar7,\"show-mode-in-prompt\");\n    if (iVar4 == 0) {\n      _rl_reset_prompt();\n      return 0;\n    }\n    iVar4 = strcasecmp(pcVar7,\"enable-bracketed-paste\");\n    if (iVar4 != 0) {\n      return 0;\n    }\n    _rl_enable_active_region = _rl_enable_bracketed_paste;\n    return 0;\n  }\n  _rl_bell_preference = 2 - (uint)(_DAT_00240460 == 0);\n  return 0;\n}\n\n",
  "FUN_0015cb50": "\nulong FUN_0015cb50(void)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  \n  uVar1 = FUN_0015cad0();\n  while (DAT_00242448 == 8) {\n    if (uVar1 == 0) {\n      FUN_0015d330();\n      uVar2 = FUN_0015cad0();\n    }\n    else {\n      DAT_00242428 = DAT_00242428 + 1;\n      FUN_0015d330();\n      uVar2 = FUN_0015cad0();\n      DAT_00242428 = DAT_00242428 + -1;\n    }\n    DAT_00242444 = 8;\n    uVar1 = (ulong)((uVar1 | uVar2) != 0);\n  }\n  if (DAT_00242448 == 0x3f) {\n    if (uVar1 == 0) {\n      DAT_00242428 = DAT_00242428 + 1;\n    }\n    FUN_0015d330();\n    if ((DAT_00242448 != 0) && (DAT_00242448 != 0x3a)) {\n      while (uVar2 = FUN_0015ccc0(), DAT_00242448 == 0x2c) {\n        FUN_0015d330();\n      }\n      if (uVar1 == 0) {\n        DAT_00242428 = DAT_00242428 + -1;\n      }\n      if (DAT_00242448 != 0x3a) {\n                    /* WARNING: Subroutine does not return */\n        FUN_0015bcf0(\"`:\\' expected for conditional expression\");\n      }\n      if (uVar1 == 0) {\n        FUN_0015d330();\n        if (DAT_00242448 != 0) {\n          uVar1 = FUN_0015cb50();\n          DAT_00242444 = 0xc;\n          return uVar1;\n        }\n      }\n      else {\n        DAT_00242428 = DAT_00242428 + 1;\n        FUN_0015d330();\n        if (DAT_00242448 != 0) {\n          FUN_0015cb50();\n          DAT_00242428 = DAT_00242428 + -1;\n          DAT_00242444 = 0xc;\n          return uVar2;\n        }\n      }\n    }\n                    /* WARNING: Subroutine does not return */\n    FUN_0015bcf0(\"expression expected\");\n  }\n  return uVar1;\n}\n\n",
  "free": "\nvoid free(void *__ptr)\n\n{\n  FUN_001f8ee0(__ptr,0,0);\n  return;\n}\n\n",
  "set_signal_ignored": "\nvoid set_signal_ignored(int param_1)\n\n{\n  *(undefined8 *)(original_signals + (long)param_1 * 8) = 1;\n  return;\n}\n\n",
  "save_parser_state": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 * save_parser_state(undefined4 *param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 *puVar5;\n  undefined8 uVar6;\n  \n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)sh_xmalloc(0x100,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1991);\n    if (param_1 == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  *param_1 = parser_state;\n  puVar5 = (undefined4 *)sh_xmalloc(0x10,\"/usr/local/src/chet/src/bash/src/parse.y\",0x72d);\n  *puVar5 = DAT_00240d70;\n  puVar5[1] = DAT_00240d6c;\n  puVar5[2] = DAT_00240d68;\n  puVar5[3] = current_token;\n  *(undefined4 **)(param_1 + 2) = puVar5;\n  param_1[9] = DAT_00240d8c;\n  param_1[10] = eof_encountered;\n  param_1[0xb] = DAT_00240b34;\n  *(undefined8 *)(param_1 + 0xc) = prompt_string_pointer;\n  param_1[0xe] = current_command_line_count;\n  param_1[0xf] = remember_on_history;\n  param_1[0x10] = history_expansion_inhibited;\n  param_1[0x11] = last_command_exit_value;\n  uVar6 = save_pipestatus_array();\n  uVar2 = here_doc_first_line;\n  *(undefined8 *)(param_1 + 0x12) = uVar6;\n  uVar6 = last_shell_builtin;\n  param_1[0x1b] = uVar2;\n  uVar2 = DAT_00240b1c;\n  *(undefined8 *)(param_1 + 0x14) = uVar6;\n  uVar6 = this_shell_builtin;\n  param_1[0x1c] = uVar2;\n  uVar3 = DAT_00240b18;\n  *(undefined8 *)(param_1 + 0x16) = uVar6;\n  uVar2 = expand_aliases;\n  param_1[0x1d] = uVar3;\n  param_1[0x18] = uVar2;\n  param_1[0x19] = echo_input_at_read;\n  iVar1 = need_here_doc;\n  param_1[0x1a] = need_here_doc;\n  uVar4 = DAT_00240dc8._4_4_;\n  uVar3 = (undefined4)DAT_00240dc8;\n  uVar2 = DAT_00240dc0._4_4_;\n  if (iVar1 == 0) {\n    *(undefined8 *)(param_1 + 0x20) = 0;\n  }\n  else {\n    param_1[0x20] = (undefined4)DAT_00240dc0;\n    param_1[0x21] = uVar2;\n    param_1[0x22] = uVar3;\n    param_1[0x23] = uVar4;\n    uVar4 = uRam0000000000240ddc;\n    uVar3 = uRam0000000000240dd8;\n    uVar2 = uRam0000000000240dd4;\n    param_1[0x24] = _DAT_00240dd0;\n    param_1[0x25] = uVar2;\n    param_1[0x26] = uVar3;\n    param_1[0x27] = uVar4;\n    uVar4 = uRam0000000000240dec;\n    uVar3 = uRam0000000000240de8;\n    uVar2 = uRam0000000000240de4;\n    param_1[0x28] = _DAT_00240de0;\n    param_1[0x29] = uVar2;\n    param_1[0x2a] = uVar3;\n    param_1[0x2b] = uVar4;\n    uVar4 = uRam0000000000240dfc;\n    uVar3 = uRam0000000000240df8;\n    uVar2 = uRam0000000000240df4;\n    param_1[0x2c] = _DAT_00240df0;\n    param_1[0x2d] = uVar2;\n    param_1[0x2e] = uVar3;\n    param_1[0x2f] = uVar4;\n    uVar4 = uRam0000000000240e0c;\n    uVar3 = uRam0000000000240e08;\n    uVar2 = uRam0000000000240e04;\n    param_1[0x30] = _DAT_00240e00;\n    param_1[0x31] = uVar2;\n    param_1[0x32] = uVar3;\n    param_1[0x33] = uVar4;\n    uVar4 = uRam0000000000240e1c;\n    uVar3 = uRam0000000000240e18;\n    uVar2 = uRam0000000000240e14;\n    param_1[0x34] = _DAT_00240e10;\n    param_1[0x35] = uVar2;\n    param_1[0x36] = uVar3;\n    param_1[0x37] = uVar4;\n    uVar4 = uRam0000000000240e2c;\n    uVar3 = uRam0000000000240e28;\n    uVar2 = uRam0000000000240e24;\n    param_1[0x38] = _DAT_00240e20;\n    param_1[0x39] = uVar2;\n    param_1[0x3a] = uVar3;\n    param_1[0x3b] = uVar4;\n    uVar4 = uRam0000000000240e3c;\n    uVar3 = uRam0000000000240e38;\n    uVar2 = uRam0000000000240e34;\n    param_1[0x3c] = _DAT_00240e30;\n    param_1[0x3d] = uVar2;\n    param_1[0x3e] = uVar3;\n    param_1[0x3f] = uVar4;\n  }\n  *(undefined8 *)(param_1 + 0x1e) = pushed_string_list;\n  param_1[8] = shell_eof_token;\n  uVar6 = DAT_00240b28;\n  DAT_00240b28 = 0;\n  *(undefined8 *)(param_1 + 4) = uVar6;\n  uVar6 = DAT_00240b20;\n  DAT_00240b20 = 0;\n  *(undefined8 *)(param_1 + 6) = uVar6;\n  return param_1;\n}\n\n",
  "rl_vi_prev_word": "\nundefined8 rl_vi_prev_word(int param_1,ulong param_2)\n\n{\n  ushort **ppuVar1;\n  undefined8 uVar2;\n  \n  if (param_1 < 0) {\n    uVar2 = rl_vi_next_word(-param_1);\n    return uVar2;\n  }\n  if (rl_point != 0) {\n    ppuVar1 = __ctype_b_loc();\n    if ((*(byte *)((long)*ppuVar1 + (param_2 & 0xff) * 2 + 1) & 1) == 0) {\n      rl_vi_bword();\n      return 0;\n    }\n    rl_vi_bWord(param_1,param_2 & 0xffffffff);\n    return 0;\n  }\n  rl_ding();\n  return 0;\n}\n\n",
  "bash_tilde_find_word": "\nchar * bash_tilde_find_word(byte *param_1,int param_2,int *param_3)\n\n{\n  byte bVar1;\n  size_t sVar2;\n  char *pcVar3;\n  byte *pbVar4;\n  long lVar5;\n  int iVar6;\n  \n  bVar1 = *param_1;\n  if ((bVar1 != 0) && (pbVar4 = param_1, bVar1 != 0x2f)) {\n    do {\n      if ((byte)(bVar1 - 0x22) < 0x3b) {\n        if ((0x400000000000021U >> ((ulong)(bVar1 - 0x22) & 0x3f) & 1) != 0) {\n          sVar2 = strlen((char *)param_1);\n          pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"general.c\",0x4a0);\n          pcVar3 = strcpy(pcVar3,(char *)param_1);\n          if (param_3 == (int *)0x0) {\n            return pcVar3;\n          }\n          *param_3 = 0;\n          return pcVar3;\n        }\n        if ((bVar1 == 0x3a) && (param_2 != 0)) goto LAB_00142700;\n      }\n      bVar1 = pbVar4[1];\n      pbVar4 = pbVar4 + 1;\n      if ((bVar1 == 0) || (bVar1 == 0x2f)) goto LAB_00142700;\n    } while( true );\n  }\n  sVar2 = 0;\n  lVar5 = 1;\n  iVar6 = 0;\nLAB_0014270f:\n  pcVar3 = (char *)sh_xmalloc(lVar5,\"general.c\",0x4a9);\n  pcVar3 = strncpy(pcVar3,(char *)param_1,sVar2);\n  pcVar3[sVar2] = '\\0';\n  if (param_3 == (int *)0x0) {\n    return pcVar3;\n  }\n  *param_3 = iVar6;\n  return pcVar3;\nLAB_00142700:\n  iVar6 = (int)pbVar4 - (int)param_1;\n  sVar2 = (size_t)iVar6;\n  lVar5 = (long)(iVar6 + 1);\n  goto LAB_0014270f;\n}\n\n",
  "have_unwind_protects": "\nbool have_unwind_protects(void)\n\n{\n  return DAT_00248390 != 0;\n}\n\n",
  "bashline_reset": "\nvoid bashline_reset(void)\n\n{\n  ulong uVar1;\n  long lVar2;\n  ulong uVar3;\n  undefined *puVar4;\n  undefined8 *puVar5;\n  byte bVar6;\n  \n  bVar6 = 0;\n  tilde_initialize();\n  rl_attempted_completion_function = FUN_001987b0;\n  rl_ignore_some_completions_function = FUN_00191d90;\n  puVar5 = &DAT_00248880;\n  for (lVar2 = 0x20; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar5 = 0;\n    puVar5 = puVar5 + (ulong)bVar6 * -2 + 1;\n  }\n  rl_filename_quote_characters = &DAT_001ff3ee;\n  rl_completion_entry_function = 0;\n  complete_fullquote = 1;\n  uVar1 = 0x20;\n  uVar3 = 9;\n  puVar4 = &DAT_001ff3ee;\n  while( true ) {\n    *(undefined *)((long)&DAT_00248880 + uVar1) = 1;\n    if ((char)uVar3 == '\\0') break;\n    uVar1 = uVar3;\n    uVar3 = (ulong)(byte)puVar4[2];\n    puVar4 = puVar4 + 1;\n  }\n  if (dircomplete_expand == 0) {\n    rl_directory_rewrite_hook = FUN_00195b80;\n    rl_directory_completion_hook = (code *)0x0;\n  }\n  else {\n    rl_directory_completion_hook = FUN_00195b80;\n    rl_directory_rewrite_hook = (code *)0x0;\n  }\n  rl_signal_event_hook = 0;\n  rl_filename_stat_hook = FUN_00191f40;\n  rl_sort_completion_matches = 1;\n  return;\n}\n\n",
  "fopen": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = (FILE *)(*(code *)PTR_fopen_00237d50)();\n  return pFVar1;\n}\n\n",
  "stat": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_stat_00237b48)();\n  return iVar1;\n}\n\n",
  "rl_function_of_keyseq": "\nvoid rl_function_of_keyseq(char *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  FUN_001da1c0(param_1,sVar1,param_2,param_3);\n  return;\n}\n\n",
  "FUN_00191dd0": "\nundefined8 FUN_00191dd0(undefined8 param_1)\n\n{\n  FUN_00191ae0(param_1,FUN_00192190);\n  return 0;\n}\n\n",
  "run_sigchld_trap": "\nvoid run_sigchld_trap(int param_1)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  char *pcVar3;\n  int iVar4;\n  \n  pcVar3 = DAT_00247a88;\n  sVar1 = strlen(DAT_00247a88);\n  pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"jobs.c\",0x1063);\n  pcVar3 = strcpy(pcVar2,pcVar3);\n  begin_unwind_frame(\"SIGCHLD trap\");\n  unwind_protect_mem(&last_command_exit_value,4);\n  unwind_protect_mem(&last_command_exit_signal,4);\n  unwind_protect_mem(&last_made_pid,4);\n  unwind_protect_mem(&DAT_00247660,4);\n  unwind_protect_mem(&the_pipeline,8);\n  unwind_protect_mem(&subst_assign_varlist,8);\n  unwind_protect_mem(&this_shell_builtin,8);\n  unwind_protect_mem(&temporary_env,8);\n  add_unwind_protect(xfree,pcVar3);\n  add_unwind_protect(maybe_set_sigchld_trap,pcVar3);\n  subst_assign_varlist = 0;\n  the_pipeline = 0;\n  temporary_env = 0;\n  running_trap = 0x12;\n  set_impossible_sigchld_trap();\n  DAT_00247660 = 1;\n  if (0 < param_1) {\n    iVar4 = 0;\n    do {\n      iVar4 = iVar4 + 1;\n      sVar1 = strlen(pcVar3);\n      pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"jobs.c\",0x107f);\n      pcVar2 = strcpy(pcVar2,pcVar3);\n      parse_and_execute(pcVar2,\"trap\",0x14);\n    } while (param_1 != iVar4);\n  }\n  run_unwind_frame(\"SIGCHLD trap\");\n  running_trap = 0;\n  return;\n}\n\n",
  "xdupmbstowcs": "\nlong xdupmbstowcs(void **param_1,void **param_2,char *param_3)\n\n{\n  int *piVar1;\n  long lVar2;\n  char cVar3;\n  int iVar4;\n  void *pvVar5;\n  void *__ptr;\n  void *pvVar6;\n  void *pvVar7;\n  char *pcVar8;\n  long lVar9;\n  size_t sVar10;\n  ulong uVar11;\n  long lVar12;\n  long in_FS_OFFSET;\n  void *local_90;\n  char *local_60;\n  undefined8 local_58;\n  mbstate_t local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_3 == (char *)0x0) {\n    if (param_1 != (void **)0x0) {\n      *param_1 = (void *)0x0;\n    }\n  }\n  else if (param_1 != (void **)0x0) {\n    if (param_2 == (void **)0x0) {\n      uVar11 = 0;\n      local_50.__count = 0;\n      local_50.__value = (_union_27)0x0;\n      local_90 = (void *)0x0;\n      lVar12 = 0;\n      local_60 = param_3;\nLAB_001c3a38:\n      do {\n        pcVar8 = strchrnul(param_3,0x5c);\n        pcVar8 = pcVar8 + ((ulong)(*pcVar8 == '\\0') - (long)param_3);\n        local_48 = local_50;\n        local_58 = param_3;\n        if ((pcVar8 != (char *)0x0) || (*param_3 != '\\\\')) {\n          sVar10 = mbsnrtowcs((wchar_t *)0x0,(char **)&local_58,(size_t)pcVar8,0,&local_48);\n          if (sVar10 == 0) {\n            sVar10 = 1;\n            local_58 = local_60;\n            local_48 = local_50;\n            goto LAB_001c3ab1;\n          }\n          if (sVar10 != 0xffffffffffffffff) goto LAB_001c3ab1;\nLAB_001c3baa:\n          free(local_90);\n          local_90 = (void *)0x0;\n          lVar12 = -1;\n          break;\n        }\n        pcVar8 = (char *)0x1;\n        sVar10 = 1;\nLAB_001c3ab1:\n        lVar2 = lVar12 + sVar10;\n        pvVar5 = local_90;\n        if (uVar11 < lVar2 + 1U) {\n          do {\n            uVar11 = uVar11 + 0x20;\n          } while (uVar11 < lVar2 + 1U);\n          pvVar5 = realloc(local_90,uVar11 * 4);\n          if (pvVar5 == (void *)0x0) goto LAB_001c3baa;\n        }\n        local_90 = pvVar5;\n        piVar1 = (int *)((long)local_90 + lVar12 * 4);\n        lVar9 = __mbsnrtowcs_chk(piVar1,&local_60,pcVar8,uVar11 - lVar12,&local_50,\n                                 0x3fffffffffffffff);\n        param_3 = local_60;\n        if (lVar9 == 0) {\n          if (local_60 == (char *)0x0) {\n            *piVar1 = 0;\n            break;\n          }\n          if (sVar10 == 1) {\nLAB_001c3c00:\n            local_60 = local_58;\n            local_50 = local_48;\n            *piVar1 = (int)*local_58;\n            if (*local_58 == '\\0') break;\n            param_3 = local_58 + 1;\n            lVar12 = lVar12 + 1;\n            local_60 = param_3;\n            iVar4 = mbsinit(&local_50);\n            if (iVar4 != 0) {\n              cVar3 = *param_3;\n              pcVar8 = param_3;\n              param_3 = local_60;\njoined_r0x001c3c45:\n              local_60 = param_3;\n              if (cVar3 == '\\\\') {\n                param_3 = pcVar8 + 1;\n                *(undefined4 *)((long)local_90 + lVar12 * 4) = 0x5c;\n                lVar12 = lVar12 + 1;\n                local_60 = param_3;\n              }\n            }\n          }\n          else {\n            iVar4 = mbsinit(&local_50);\n            lVar12 = lVar2;\n            if (iVar4 != 0) goto LAB_001c3b1c;\n          }\n          goto LAB_001c3a38;\n        }\n        if ((sVar10 == 1) && (lVar9 == -1)) goto LAB_001c3c00;\n        iVar4 = mbsinit(&local_50);\n        if (iVar4 != 0) {\n          lVar12 = lVar2;\n          if (param_3 != (char *)0x0) {\nLAB_001c3b1c:\n            cVar3 = *param_3;\n            pcVar8 = param_3;\n            lVar12 = lVar2;\n            param_3 = local_60;\n            goto joined_r0x001c3c45;\n          }\n          break;\n        }\n        lVar12 = lVar2;\n      } while (param_3 != (char *)0x0);\n      *param_1 = local_90;\n    }\n    else {\n      local_48.__count = 0;\n      local_48.__value = (_union_27)0x0;\n      pvVar5 = malloc(0x80);\n      if (pvVar5 != (void *)0x0) {\n        __ptr = malloc(0x100);\n        if (__ptr != (void *)0x0) {\n          lVar12 = 0;\n          uVar11 = 0x20;\nLAB_001c38e1:\n          iVar4 = mbsinit(&local_48);\n          pvVar7 = __ptr;\n          pvVar6 = pvVar5;\n          if (iVar4 == 0) {\nLAB_001c3930:\n            sVar10 = mbrtowc((wchar_t *)&local_58,param_3,0x10,&local_48);\n            if (0xfffffffffffffffd < sVar10) {\nLAB_001c39b3:\n              free(pvVar5);\n              pvVar5 = __ptr;\n              goto LAB_001c39bb;\n            }\n            if (uVar11 < lVar12 + 1U) goto LAB_001c385b;\nLAB_001c38c5:\n            *(char **)((long)pvVar7 + lVar12 * 8) = param_3;\n            param_3 = param_3 + sVar10;\n            *(int *)((long)pvVar6 + lVar12 * 4) = (int)local_58;\n            __ptr = pvVar7;\n            pvVar5 = pvVar6;\n            if ((int)local_58 == 0) goto LAB_001c3976;\n          }\n          else {\n            if (*param_3 == '\\0') {\n              local_58 = (char *)((ulong)local_58._4_4_ << 0x20);\n              if (uVar11 < lVar12 + 1U) {\nLAB_001c3856:\n                sVar10 = 1;\nLAB_001c385b:\n                uVar11 = uVar11 + 0x20;\n                pvVar6 = realloc(pvVar5,uVar11 * 4);\n                if ((pvVar6 != (void *)0x0) &&\n                   (pvVar7 = realloc(__ptr,uVar11 * 8), pvVar5 = pvVar6, pvVar7 != (void *)0x0))\n                goto LAB_001c38c5;\n                goto LAB_001c39b3;\n              }\n              *(undefined4 *)((long)pvVar5 + lVar12 * 4) = 0;\n              *(char **)((long)__ptr + lVar12 * 8) = param_3;\nLAB_001c3976:\n              *param_1 = pvVar5;\n              *param_2 = __ptr;\n              goto LAB_001c3986;\n            }\n            if (*param_3 != '\\\\') goto LAB_001c3930;\n            local_58 = (char *)CONCAT44(local_58._4_4_,0x5c);\n            if (uVar11 < lVar12 + 1U) goto LAB_001c3856;\n            *(char **)((long)__ptr + lVar12 * 8) = param_3;\n            param_3 = param_3 + 1;\n            *(undefined4 *)((long)pvVar5 + lVar12 * 4) = 0x5c;\n          }\n          lVar12 = lVar12 + 1;\n          __ptr = pvVar7;\n          pvVar5 = pvVar6;\n          goto LAB_001c38e1;\n        }\nLAB_001c39bb:\n        free(pvVar5);\n      }\n      lVar12 = -1;\n      *param_1 = (void *)0x0;\n      *param_2 = (void *)0x0;\n    }\n    goto LAB_001c3986;\n  }\n  lVar12 = -1;\n  if (param_2 != (void **)0x0) {\n    *param_2 = (void *)0x0;\n  }\nLAB_001c3986:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar12;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "glob_filename": "\nvoid ** glob_filename(char *param_1,uint param_2)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  char cVar4;\n  int iVar5;\n  uint uVar6;\n  void **__pattern;\n  size_t sVar7;\n  void **ppvVar8;\n  char **ppcVar9;\n  char **ppcVar10;\n  char **ppcVar11;\n  ulong uVar12;\n  ulong uVar13;\n  size_t sVar14;\n  void *pvVar15;\n  char *pcVar16;\n  uint uVar17;\n  long lVar18;\n  char **ppcVar19;\n  uint uVar20;\n  char *pcVar21;\n  void **ppvVar22;\n  uint uVar23;\n  void **ppvVar24;\n  long in_FS_OFFSET;\n  char *local_118;\n  ulong local_108;\n  void **local_f0;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_f0 = (void **)sh_malloc(8,\"glob.c\",0x48a);\n  if (local_f0 == (void **)0x0) {\nLAB_001bf02d:\n    ppvVar8 = (void **)0x0;\n  }\n  else {\n    *local_f0 = (void *)0x0;\n    local_118 = strrchr(param_1,0x2f);\n    if ((local_118 == (char *)0x0) ||\n       ((extended_glob != 0 &&\n        (local_118 = (char *)glob_dirscan(param_1,0x2f), local_118 == (char *)0x0)))) {\n      cVar4 = *param_1;\n      bVar3 = false;\n      __pattern = (void **)&DAT_00213d70;\n      pcVar21 = param_1;\njoined_r0x001bec13:\n      if (cVar4 == '\\0') {\n        ppvVar8 = (void **)realloc(local_f0,0x10);\n        if (ppvVar8 != (void **)0x0) goto LAB_001beccb;\n        if (bVar3) goto LAB_001bf766;\n        goto LAB_001bf02d;\n      }\nLAB_001bec19:\n      sh_xfree(local_f0,\"glob.c\",0x5f5);\n      uVar23 = param_2 & 0xfffffffe | 0x100;\n      uVar6 = uVar23;\n      if ((((param_2 & 0x400) == 0) || (*pcVar21 != '*')) || (uVar20 = 0, pcVar21[1] != '*')) {\nLAB_001bec44:\n        ppvVar8 = (void **)0x1fd5a3;\n      }\n      else {\nLAB_001bed36:\n        if (pcVar21[2] == '\\0') {\n          uVar6 = uVar23 | 0x210;\n          ppvVar8 = __pattern;\n          if (uVar20 == 0) {\n            if ((param_2 & 0x10) != 0) goto LAB_001bec44;\n            ppvVar8 = (void **)0x1fd5a3;\n            uVar6 = uVar23 & 0xfffffdff | 0x10;\n          }\n        }\n        else {\n          ppvVar8 = (void **)0x1fd5a3;\n          uVar6 = uVar23;\n          if (uVar20 != 0) {\n            ppvVar8 = __pattern;\n          }\n        }\n      }\nLAB_001bec4b:\n      ppvVar8 = (void **)glob_vector(pcVar21,ppvVar8,uVar6);\n      if ((ppvVar8 == (void **)0x0) || (ppvVar8 == (void **)&glob_error_return)) {\n        if (bVar3) {\nLAB_001bf008:\n          sh_xfree(__pattern,\"glob.c\",0x612);\n        }\n        if (terminating_signal != 0) {\n          termsig_handler(terminating_signal);\n        }\n        if (interrupt_state != 0) {\n          throw_to_top_level();\n        }\n        run_pending_traps();\n        goto LAB_001bebaa;\n      }\nLAB_001beb80:\n      ppvVar22 = (void **)&DAT_00213d70;\n      if ((uVar6 & 0x10) == 0) {\n        ppvVar22 = __pattern;\n      }\nLAB_001beb8f:\n      ppvVar8 = (void **)FUN_001bd0d0(ppvVar22,ppvVar8,param_2);\n      if (!bVar3) goto LAB_001bebaa;\n    }\n    else {\n      uVar20 = (int)local_118 - (int)param_1;\n      sVar7 = (size_t)(uVar20 + 2);\n      local_108 = (ulong)uVar20;\n      uVar20 = uVar20 + 1;\n      __pattern = (void **)sh_malloc(sVar7,\"glob.c\",0x4ab);\n      if (__pattern == (void **)0x0) {\n        sh_xfree(local_f0,\"glob.c\",0x4af);\n        goto LAB_001bf02d;\n      }\n      memmove(__pattern,param_1,(ulong)uVar20);\n      *(undefined *)((long)__pattern + (ulong)uVar20) = 0;\n      pcVar21 = local_118 + 1;\n      if (uVar20 == 0) {\n        cVar4 = *pcVar21;\n        bVar3 = true;\n        goto joined_r0x001bec13;\n      }\n      iVar5 = glob_pattern_p((char *)__pattern,(int)param_1);\n      if (iVar5 == 1) {\n        uVar6 = param_2 & 0xfffffffe;\n        ppvVar8 = __pattern;\n        if ((param_2 & 0x400) != 0) {\n          if (((*(char *)__pattern == '*') && (*(char *)((long)__pattern + 1) == '*')) &&\n             ((cVar4 = *(char *)((long)__pattern + 2), ppvVar22 = __pattern, cVar4 == '/' ||\n              (cVar4 == '\\0')))) {\n            do {\n              if (cVar4 == '/') {\n                ppvVar24 = (void **)((long)ppvVar22 + 3);\n                cVar4 = *(char *)((long)ppvVar22 + 3);\n                while (cVar4 == '/') {\n                  pcVar16 = (char *)((long)ppvVar24 + 1);\n                  ppvVar24 = (void **)((long)ppvVar24 + 1);\n                  cVar4 = *pcVar16;\n                }\n                ppvVar8 = ppvVar22;\n                if (cVar4 == '\\0') goto LAB_001bf579;\n              }\n              else {\n                ppvVar24 = ppvVar22;\n                if (cVar4 != '\\0') goto LAB_001bf579;\n                cVar4 = *(char *)ppvVar22;\n              }\n              ppvVar8 = ppvVar22;\n              if ((cVar4 != '*') || (*(char *)((long)ppvVar24 + 1) != '*')) goto LAB_001bf579;\n              cVar4 = *(char *)((long)ppvVar24 + 2);\n              ppvVar22 = ppvVar24;\n            } while( true );\n          }\n          goto LAB_001bf1c9;\n        }\n        bVar3 = false;\n        goto LAB_001bed9b;\n      }\n      if (local_118[1] == '\\0') {\n        ppvVar8 = (void **)realloc(local_f0,0x10);\n        if (ppvVar8 == (void **)0x0) goto LAB_001bf766;\n        if (iVar5 != 2) {\n          pvVar15 = (void *)sh_malloc(sVar7,\"glob.c\",0x5e0);\n          *ppvVar8 = pvVar15;\n          if (pvVar15 == (void *)0x0) goto LAB_001bf14f;\n          bVar3 = true;\n          goto LAB_001becf3;\n        }\n        if ((param_2 & 0x800) == 0) {\n          sVar14 = __ctype_get_mb_cur_max();\n          if (sVar14 < 2) {\n            udequote_pathname(__pattern);\n          }\n          else {\n            FUN_001bdca0();\n          }\n          iVar5 = stat((char *)__pattern,&local_d8);\n          if ((iVar5 < 0) || ((local_d8.st_mode & 0xf000) != 0x4000)) {\n            sh_xfree(__pattern,\"glob.c\",0x5d9);\n            sh_xfree(ppvVar8,\"glob.c\",0x5da);\n            ppvVar8 = (void **)&glob_error_return;\n            goto LAB_001bebaa;\n          }\n        }\n        else {\n          sVar7 = __ctype_get_mb_cur_max();\n          if (sVar7 < 2) {\n            udequote_pathname(__pattern);\n          }\n          else {\n            FUN_001bdca0();\n          }\n          sVar7 = strlen((char *)__pattern);\n          sVar7 = (size_t)((int)sVar7 + 1);\n        }\n        pvVar15 = (void *)sh_malloc(sVar7,\"glob.c\",0x5e0);\n        *ppvVar8 = pvVar15;\n        if (pvVar15 == (void *)0x0) {\nLAB_001bf14f:\n          sh_xfree(ppvVar8,\"glob.c\",0x627);\n          goto LAB_001bf15f;\n        }\n        memmove(pvVar15,__pattern,sVar7);\n        goto LAB_001bf1a6;\n      }\n      sVar7 = __ctype_get_mb_cur_max();\n      if (sVar7 < 2) {\n        udequote_pathname(__pattern);\n      }\n      else {\n        FUN_001bdca0();\n      }\n      sh_xfree(local_f0,\"glob.c\",0x5f5);\n      uVar23 = param_2 & 0xfffffffe;\n      if ((param_2 & 0x400) != 0) {\n        uVar6 = uVar23;\n        if (local_118[1] == '*') {\n          if (local_118[2] == '*') {\n            bVar3 = true;\n            goto LAB_001bed36;\n          }\n          bVar3 = true;\n          ppvVar8 = __pattern;\n          goto LAB_001bec4b;\n        }\n        ppvVar8 = (void **)glob_vector(pcVar21,__pattern,uVar23);\n        if ((ppvVar8 == (void **)0x0) || (ppvVar8 == (void **)&glob_error_return))\n        goto LAB_001bf008;\n        bVar3 = true;\n        goto LAB_001beb80;\n      }\n      ppvVar8 = (void **)glob_vector(pcVar21,__pattern,uVar23);\n      if ((ppvVar8 == (void **)&glob_error_return) || (ppvVar8 == (void **)0x0)) goto LAB_001bf008;\n      if ((param_2 & 0x10) != 0) {\n        bVar3 = true;\n        ppvVar22 = (void **)&DAT_00213d70;\n        goto LAB_001beb8f;\n      }\n      ppvVar8 = (void **)FUN_001bd0d0(__pattern,ppvVar8,param_2);\n    }\n    sh_xfree(__pattern,\"glob.c\",0x61b);\n  }\nLAB_001bebaa:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return ppvVar8;\nLAB_001bf579:\n  uVar6 = uVar6 | 0x210;\n  sVar7 = strlen((char *)ppvVar8);\n  uVar20 = (uint)sVar7;\n  if (*(char *)ppvVar24 == '\\0') {\n    bVar3 = true;\n    local_108 = (ulong)(uVar20 - 1);\n  }\n  else {\nLAB_001bf1c9:\n    uVar17 = uVar20;\n    uVar23 = uVar20;\n    if (3 < (int)uVar20) {\n      pcVar16 = (char *)((long)ppvVar8 + (long)(int)uVar20 + -4);\n      do {\n        uVar1 = uVar17;\n        uVar17 = uVar1;\n        if ((((pcVar16[3] != '/') || (pcVar16[2] != '*')) || (pcVar16[1] != '*')) ||\n           (*pcVar16 != '/')) break;\n        uVar17 = uVar1 - 3;\n        pcVar16 = pcVar16 + -3;\n        uVar23 = uVar1;\n      } while (3 < (int)uVar17);\n    }\n    if (((uVar17 == uVar20) || (uVar23 < 5)) ||\n       ((local_118[1] != '*' || ((local_118[2] != '*' || (local_118[3] != '\\0')))))) {\n      bVar3 = false;\n      local_108 = (ulong)(uVar23 - 1);\n    }\n    else {\n      bVar3 = false;\n      local_108 = (ulong)(uVar23 - 4);\n    }\n  }\nLAB_001bed9b:\n  if (*(char *)(local_108 + (long)ppvVar8) == '/') {\n    *(char *)(local_108 + (long)ppvVar8) = '\\0';\n  }\n  ppcVar9 = (char **)glob_filename(ppvVar8,uVar6 | 0x800);\n  sh_xfree(__pattern,\"glob.c\",0x501);\n  if (ppcVar9 == (char **)0x0) {\nLAB_001bf44f:\n    pvVar15 = *local_f0;\n    if (pvVar15 != (void *)0x0) {\n      uVar13 = 0;\n      do {\n        sh_xfree(pvVar15,\"glob.c\",0x626);\n        uVar13 = (ulong)((int)uVar13 + 1);\n        pvVar15 = local_f0[uVar13];\n      } while (pvVar15 != (void *)0x0);\n    }\n    sh_xfree(local_f0,\"glob.c\",0x627);\n  }\n  else {\n    if (ppcVar9 == (char **)&glob_error_return) {\n      sh_xfree(local_f0,\"glob.c\",0x509);\n      ppvVar8 = (void **)&glob_error_return;\n      goto LAB_001bebaa;\n    }\n    pcVar16 = *ppcVar9;\n    if (pcVar16 == (char *)0x0) {\n      sh_xfree(ppcVar9,\"glob.c\",0x50e);\n      sh_xfree(local_f0,\"glob.c\",0x50f);\n      ppvVar8 = (void **)&glob_error_return;\n      goto LAB_001bebaa;\n    }\n    if ((((!bVar3) || (local_118[1] != '*')) || (local_118[2] != '*')) || (local_118[3] != '\\0')) {\n      uVar13 = 0;\n      uVar6 = param_2 & 0xfffffdee;\n      uVar20 = 1;\n      ppcVar11 = ppcVar9;\nLAB_001bee40:\n      uVar23 = uVar6;\n      if (((param_2 & 0x400) == 0) || (local_118[1] != '*')) {\n        if (*pcVar16 == '\\0') {\n          cVar4 = local_118[1];\n          goto joined_r0x001bee6a;\n        }\nLAB_001bee70:\n        if ((((!bVar3) || ((uVar23 & 0x100) != 0)) ||\n            (iVar5 = FUN_001bd040(pcVar16,param_2 | 0x10), iVar5 != -2)) ||\n           ((iVar5 = stat(pcVar16,&local_d8), iVar5 < 0 || ((local_d8.st_mode & 0xf000) != 0x4000)))\n           ) goto LAB_001bee84;\n        if (local_118[1] != '\\0') goto LAB_001bef95;\n        ppcVar10 = (char **)sh_malloc(0x10,\"glob.c\",0x54a);\n        if (ppcVar10 != (char **)0x0) {\n          pcVar16 = (char *)sh_malloc(1,\"glob.c\",0x54d);\n          *ppcVar10 = pcVar16;\n          if (pcVar16 != (char *)0x0) {\n            *pcVar16 = '\\0';\n            ppcVar10[1] = (char *)0x0;\n            goto LAB_001bee9f;\n          }\n          sh_xfree(ppcVar10,\"glob.c\",0x550);\n        }\n        goto LAB_001bf44f;\n      }\n      if ((local_118[2] == '*') && (local_118[3] == '\\0')) {\n        uVar23 = uVar6 | 0x210;\n      }\n      cVar4 = *pcVar16;\njoined_r0x001bee6a:\n      if (cVar4 == '\\0') goto LAB_001bee70;\n      uVar23 = uVar23 | 0x100;\n      pcVar16 = \".\";\nLAB_001bee84:\n      ppcVar10 = (char **)glob_vector(pcVar21,pcVar16,uVar23);\n      if (ppcVar10 == (char **)0x0) goto LAB_001bf44f;\nLAB_001bee9f:\n      if (ppcVar10 == (char **)&glob_error_return) goto LAB_001bef95;\n      if ((((uVar23 & 0x10) == 0) || (local_118[1] != '*')) ||\n         ((local_118[2] != '*' || ((local_118[3] != '\\0' && (local_118[3] != '/')))))) {\n        bVar2 = false;\n        ppcVar11 = (char **)FUN_001bd0d0(*ppcVar11,ppcVar10,param_2);\nLAB_001beedd:\n        uVar12 = (ulong)uVar20;\n        if (*ppcVar11 != (char *)0x0) {\nLAB_001beee6:\n          uVar12 = 0;\n          do {\n            uVar17 = (int)uVar12 + 1;\n            uVar12 = (ulong)uVar17;\n          } while (ppcVar11[uVar12] != (char *)0x0);\n          uVar12 = (ulong)(uVar17 + uVar20);\n        }\n      }\n      else {\n        ppcVar11 = ppcVar10;\n        if ((uVar23 & 0x100) == 0) {\n          bVar2 = false;\n          goto LAB_001beedd;\n        }\n        if ((param_2 & 0x100) != 0) {\n          bVar2 = false;\n          goto LAB_001beedd;\n        }\n        bVar2 = false;\n        if (*ppcVar10 != (char *)0x0) {\n          if (**ppcVar10 == '\\0') {\n            lVar18 = 1;\n            do {\n              ppcVar19 = ppcVar10 + lVar18;\n              iVar5 = (int)lVar18;\n              if (*ppcVar19 == (char *)0x0) {\n                *ppcVar10 = (char *)0x0;\n                uVar12 = (ulong)uVar20;\n                bVar2 = true;\n                goto LAB_001bef00;\n              }\n              lVar18 = lVar18 + 1;\n            } while (**ppcVar19 == '\\0');\n            ppcVar19 = ppcVar10 + iVar5;\n            do {\n              pcVar16 = *ppcVar19;\n              ppcVar19[-(long)iVar5] = pcVar16;\n              ppcVar19 = ppcVar19 + 1;\n            } while (pcVar16 != (char *)0x0);\n            bVar2 = true;\n            goto LAB_001beedd;\n          }\n          goto LAB_001beee6;\n        }\n        uVar12 = (ulong)uVar20;\n      }\nLAB_001bef00:\n      ppvVar8 = (void **)realloc(local_f0,uVar12 * 8);\n      if (ppvVar8 == (void **)0x0) {\n        uVar13 = 0;\n        pcVar21 = *ppcVar11;\n        while (pcVar21 != (char *)0x0) {\n          sh_xfree(pcVar21,\"glob.c\",0x599);\n          uVar13 = (ulong)((int)uVar13 + 1);\n          pcVar21 = ppcVar11[uVar13];\n        }\n        sh_xfree(ppcVar11,\"glob.c\",0x59a);\n        goto LAB_001bf44f;\n      }\n      pcVar16 = *ppcVar11;\n      uVar12 = 0;\n      if (pcVar16 == (char *)0x0) {\n        uVar17 = uVar20 - 1;\n      }\n      else {\n        do {\n          uVar17 = uVar20;\n          uVar20 = uVar17 + 1;\n          ppvVar8[uVar17 - 1] = pcVar16;\n          uVar12 = (ulong)((int)uVar12 + 1);\n          pcVar16 = ppcVar11[uVar12];\n        } while (pcVar16 != (char *)0x0);\n      }\n      ppvVar8[uVar17] = (void *)0x0;\n      if (ppcVar11 == ppcVar10) {\n        if (((((uVar23 & 0x10) != 0) && (local_118[1] == '*')) && (local_118[2] == '*')) &&\n           (local_118[3] == '\\0')) {\n          sh_xfree(ppcVar11,\"glob.c\",0x5a8);\n        }\n      }\n      else {\n        sh_xfree(ppcVar11,\"glob.c\",0x5a6);\n      }\n      local_f0 = ppvVar8;\n      if (!bVar2) goto LAB_001bef95;\n      goto LAB_001befb7;\n    }\n    sh_xfree(ppcVar9,\"glob.c\",0x517);\n    sh_xfree(0,\"glob.c\",0x518);\n    if (local_118[1] != '\\0') {\n      __pattern = (void **)0x0;\n      goto LAB_001bec19;\n    }\n    __pattern = (void **)realloc(local_f0,0x10);\n    if (__pattern == (void **)0x0) {\nLAB_001bf766:\n      ppvVar8 = (void **)0x0;\n      sh_xfree(__pattern,\"glob.c\",0x5bf);\n      goto LAB_001bebaa;\n    }\n    ppvVar8 = __pattern;\n    __pattern = (void **)0x0;\nLAB_001beccb:\n    pvVar15 = (void *)sh_malloc(1,\"glob.c\",0x5e0);\n    *ppvVar8 = pvVar15;\n    if (pvVar15 != (void *)0x0) {\n      sVar7 = 1;\nLAB_001becf3:\n      memmove(pvVar15,__pattern,sVar7);\n      if (bVar3) {\nLAB_001bf1a6:\n        sh_xfree(__pattern,\"glob.c\",0x5e5);\n      }\n      ppvVar8[1] = (void *)0x0;\n      goto LAB_001bebaa;\n    }\n    sh_xfree(ppvVar8,\"glob.c\",0x627);\n    if ((bool)(__pattern != (void **)0x0 & bVar3)) {\nLAB_001bf15f:\n      sh_xfree(__pattern,\"glob.c\",0x62b);\n    }\n  }\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n  }\n  run_pending_traps();\n  ppvVar8 = (void **)0x0;\n  goto LAB_001bebaa;\nLAB_001bef95:\n  uVar13 = (ulong)((int)uVar13 + 1);\n  ppcVar11 = ppcVar9 + uVar13;\n  pcVar16 = *ppcVar11;\n  ppvVar8 = local_f0;\n  if (pcVar16 == (char *)0x0) goto LAB_001befb7;\n  goto LAB_001bee40;\nLAB_001befb7:\n  uVar13 = 0;\n  pcVar21 = *ppcVar9;\n  while (pcVar21 != (char *)0x0) {\n    sh_xfree(pcVar21,\"glob.c\",0x5b0);\n    uVar13 = (ulong)((int)uVar13 + 1);\n    pcVar21 = ppcVar9[uVar13];\n  }\n  sh_xfree(ppcVar9,\"glob.c\",0x5b2);\n  goto LAB_001bebaa;\n}\n\n",
  "_rl_abort_internal": "\nvoid _rl_abort_internal_noreturn_(void)\n\n{\n  if ((rl_readline_state & 0x4000000) == 0) {\n    rl_ding();\n  }\n  rl_clear_message();\n  _rl_reset_argument();\n  rl_clear_pending_input();\n  rl_deactivate_mark();\n  while (rl_executing_macro != 0) {\n    _rl_pop_executing_macro();\n  }\n  _rl_kill_kbd_macro();\n  rl_readline_state = rl_readline_state & 0xffffffffffdfffff;\n  rl_last_func = 0;\n                    /* WARNING: Subroutine does not return */\n  __longjmp_chk(_rl_top_level,1);\n}\n\n",
  "_rl_arg_callback": "\nbool _rl_arg_callback(undefined4 param_1)\n\n{\n  int iVar1;\n  bool bVar2;\n  \n  rl_message(\"(arg: %d) \",rl_arg_sign * rl_numeric_arg);\n  rl_readline_state = rl_readline_state | 0x40;\n  iVar1 = rl_read_key();\n  rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n  bVar2 = true;\n  if (-1 < iVar1) {\n    if ((_rl_argcxt & 4) != 0) {\n      _rl_argcxt = _rl_argcxt & 0xfffffffb;\n      rl_restore_prompt();\n      rl_clear_message();\n      rl_readline_state = rl_readline_state & 0xfffffffffffffbff;\n      rl_execute_next(iVar1);\n      return false;\n    }\n    iVar1 = _rl_arg_dispatch(param_1,iVar1);\n    if (0 < iVar1) {\n      rl_message(\"(arg: %d) \",rl_arg_sign * rl_numeric_arg);\n    }\n    bVar2 = iVar1 != 1;\n  }\n  return bVar2;\n}\n\n",
  "fstat": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fstat(int __fd,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fstat_00237e88)();\n  return iVar1;\n}\n\n",
  "reset_readahead_token": "\nvoid reset_readahead_token(void)\n\n{\n  if (DAT_00240b58 != 10) {\n    return;\n  }\n  DAT_00240b58 = 0;\n  return;\n}\n\n",
  "run_unwind_frame": "\nvoid run_unwind_frame(void)\n\n{\n  if (DAT_00248390 != 0) {\n    FUN_001840b0();\n    return;\n  }\n  return;\n}\n\n",
  "FUN_0016fe40": "\nundefined8 * FUN_0016fe40(char *param_1,uint param_2)\n\n{\n  uint __fd;\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  undefined4 uVar5;\n  undefined8 *puVar6;\n  char *__src;\n  long lVar7;\n  undefined8 *puVar8;\n  long lVar9;\n  long in_FS_OFFSET;\n  int local_74;\n  uint local_54 [2];\n  undefined local_4c [12];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((param_1 != (char *)0x0) && (*param_1 != '\\0')) && (wordexp_only == 0)) {\n    iVar2 = pipe((int *)local_54);\n    if (iVar2 < 0) {\n      sys_error(&DAT_002102da,\"cannot make pipe for process substitution\");\n    }\n    else {\n      __fd = local_54[(int)(1 - param_2)];\n      iVar2 = move_to_high_fd(local_54[(int)param_2],1,0x40);\n      puVar6 = (undefined8 *)sh_xmalloc(0x11,\"subst.c\",0x192f);\n      *puVar6 = 0x2f64662f7665642f;\n      *(undefined *)(puVar6 + 1) = 0;\n      __src = (char *)inttostr((long)iVar2,local_4c,0xc);\n      strcpy((char *)(puVar6 + 1),__src);\n      lVar7 = DAT_00247838;\n      uVar1 = DAT_00247830;\n      lVar9 = (long)(int)DAT_00247830;\n      if ((DAT_00247838 == 0) || ((int)DAT_00247830 <= iVar2)) {\n        DAT_00247830 = getdtablesize();\n        if (0x100 < DAT_00247830) {\n          DAT_00247830 = 0x100;\n        }\n        if ((int)DAT_00247830 <= iVar2) {\n          DAT_00247830 = iVar2 + 2;\n        }\n        lVar7 = sh_xrealloc(lVar7,(long)(int)DAT_00247830 * 4,\"subst.c\",0x1888);\n        DAT_00247838 = lVar7;\n        memset((void *)(lVar7 + lVar9 * 4),0,(long)(int)(DAT_00247830 - uVar1) << 2);\n      }\n      lVar9 = (long)iVar2;\n      DAT_00247834 = DAT_00247834 + 1;\n      *(undefined4 *)(lVar7 + lVar9 * 4) = 1;\n      iVar4 = pipeline_pgrp;\n      uVar5 = last_made_pid;\n      if ((pipeline_pgrp == 0) || ((subshell_environment & 0x19) == 0)) {\n        pipeline_pgrp = shell_pgrp;\n      }\n      save_pipeline(1);\n      iVar3 = make_child(0,1);\n      if (iVar3 == 0) {\n        interactive = 0;\n        reset_terminating_signals();\n        free_pushed_string_input();\n        restore_original_signals();\n        subshell_environment = subshell_environment & 0xfffffeff;\n        if (terminating_signal != 0) {\n          termsig_handler(terminating_signal);\n        }\n        if (interrupt_state != 0) {\n          throw_to_top_level();\n        }\n        setup_async_signals();\n        subshell_environment = subshell_environment | 0x25;\n        change_flag(0x76,0x2b);\n        if (expanding_redir != 0) {\n          flush_temporary_env();\n        }\n      }\n      set_sigchld_handler();\n      stop_making_children();\n      pipeline_pgrp = iVar4;\n      if (-1 < iVar3) {\n        if (iVar3 != 0) {\n          puVar8 = (undefined8 *)restore_pipeline(0);\n          last_procsub_child = puVar8;\n          *puVar8 = 0;\n          procsub_add(puVar8);\n          *(int *)(DAT_00247838 + lVar9 * 4) = iVar3;\n          last_made_pid = uVar5;\n          close_pgrp_pipe();\n          close(__fd);\n          goto LAB_001700d0;\n        }\n        set_sigint_handler();\n        set_job_control(0);\n        procsub_clear();\n        if (pipeline_pgrp != shell_pgrp) {\n          pipeline_pgrp = getpid();\n        }\n        if (param_2 == 0) {\n          fpurge(stdout);\n        }\n        param_2 = param_2 ^ 1;\n        iVar4 = dup2(__fd,param_2);\n        if (iVar4 < 0) {\n          sys_error(\"cannot duplicate named pipe %s as fd %d\",puVar6,param_2);\n                    /* WARNING: Subroutine does not return */\n          exit(0x7f);\n        }\n        if (__fd != param_2) {\n          close(__fd);\n        }\n        if (current_fds_to_close != 0) {\n          close_fd_bitmap();\n          current_fds_to_close = 0;\n        }\n        close(iVar2);\n        *(undefined4 *)(DAT_00247838 + lVar9 * 4) = 0;\n        expanding_redir = 0;\n        FUN_0016fe00(param_1);\n        startup_state = 2;\n        parse_and_execute_level = 0;\n        local_74 = __sigsetjmp(top_level,0);\n        if (local_74 == 0) {\n          if (return_catch_flag != 0) {\n            local_74 = 0;\n            iVar2 = __sigsetjmp(return_catch,0);\n            goto LAB_001702fa;\n          }\n        }\n        else {\n          iVar2 = 0;\nLAB_001702fa:\n          uVar5 = last_command_exit_value;\n          if ((((local_74 == 4) || (local_74 == 3)) || (local_74 == 6)) ||\n             ((uVar5 = 1, local_74 != 0 || (uVar5 = return_catch_value, iVar2 != 0))))\n          goto LAB_001702e0;\n        }\n        subshell_level = subshell_level + 1;\n        uVar5 = parse_and_execute(param_1,\"process substitution\",5);\nLAB_001702e0:\n        last_command_exit_value = uVar5;\n        iVar2 = run_exit_trap();\n                    /* WARNING: Subroutine does not return */\n        exit(iVar2);\n      }\n      sys_error(&DAT_002102da,\"cannot make child for process substitution\");\n      sh_xfree(puVar6,\"subst.c\",0x19ac);\n      close(iVar2);\n      close(__fd);\n      restore_pipeline(1);\n    }\n  }\n  puVar6 = (undefined8 *)0x0;\nLAB_001700d0:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar6;\n}\n\n",
  "glob_patscan_wc": "\nundefined8 glob_patscan_wc(long param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (param_1 != param_2) {\n    uVar1 = FUN_001bfc60();\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "FUN_00149790": "\nvoid FUN_00149790(int param_1)\n\n{\n  if (param_1 != -1) {\n    dup2(param_1,0);\n    close(param_1);\n    return;\n  }\n  close(0);\n  return;\n}\n\n",
  "sh_invalidid": "\nvoid sh_invalidid(undefined8 param_1)\n\n{\n  builtin_error(\"`%s\\': not a valid identifier\",param_1);\n  return;\n}\n\n",
  "ttrestore": "\nvoid ttrestore(void)\n\n{\n  if (DAT_00249ee0 == 0) {\n    return;\n  }\n  tcsetattr(0,1,(termios *)&DAT_00249f40);\n  tcsetattr(1,1,(termios *)&DAT_00249f00);\n  DAT_00249ee0 = 0;\n  return;\n}\n\n",
  "FUN_001cf8d0": "\nundefined8 FUN_001cf8d0(uint param_1)\n\n{\n  uint uVar1;\n  \n  if (((-1 < (int)param_1) && (_rl_keymap[(long)(int)param_1 * 0x10] == '\\0')) &&\n     (*(code **)(_rl_keymap + (long)(int)param_1 * 0x10 + 8) == rl_universal_argument)) {\n    rl_numeric_arg = rl_numeric_arg << 2;\n    return 1;\n  }\n  uVar1 = (param_1 & 0xffffff7f) - 0x30;\n  if (uVar1 < 10) {\n    if (rl_explicit_arg != 0) {\n      uVar1 = uVar1 + rl_numeric_arg * 10;\n    }\n    rl_numeric_arg = uVar1;\n    rl_explicit_arg = 1;\n    return 1;\n  }\n  rl_clear_message();\n  rl_stuff_char(param_1);\n  return 0;\n}\n\n",
  "open": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_open_00237d40)();\n  return iVar1;\n}\n\n",
  "array_to_word_list": "\nlong * array_to_word_list(long param_1)\n\n{\n  undefined8 uVar1;\n  long *plVar2;\n  long lVar3;\n  \n  if (((param_1 != 0) && (*(long *)(param_1 + 8) != 0)) &&\n     (lVar3 = *(long *)(*(long *)(param_1 + 0x10) + 0x10), *(long *)(param_1 + 0x10) != lVar3)) {\n    plVar2 = (long *)0x0;\n    do {\n      uVar1 = make_bare_word(*(undefined8 *)(lVar3 + 8));\n      plVar2 = (long *)make_word_list(uVar1,plVar2);\n      lVar3 = *(long *)(lVar3 + 0x10);\n    } while (*(long *)(param_1 + 0x10) != lVar3);\n    if (plVar2 != (long *)0x0) {\n      if (*plVar2 == 0) {\n        return plVar2;\n      }\n      plVar2 = (long *)list_reverse(plVar2);\n      return plVar2;\n    }\n  }\n  return (long *)0x0;\n}\n\n",
  "rl_print_last_kbd_macro": "\nundefined8 rl_print_last_kbd_macro(void)\n\n{\n  void *__ptr;\n  \n  if (DAT_0024b198 != 0) {\n    __ptr = (void *)_rl_untranslate_macro_value(DAT_0024b198,1);\n    rl_crlf();\n    __printf_chk(1,&DAT_002102da,__ptr);\n    fflush(stdout);\n    rl_crlf();\n    if (__ptr != (void *)0x0) {\n      free(__ptr);\n    }\n    rl_forced_update_display();\n    rl_display_fixed = 1;\n    return 0;\n  }\n  rl_ding();\n  return 0;\n}\n\n",
  "err_readonly": "\nvoid err_readonly(undefined8 param_1)\n\n{\n  report_error(\"%s: readonly variable\",param_1);\n  return;\n}\n\n",
  "FUN_0017c800": "\nint FUN_0017c800(char *param_1,long param_2,long param_3,uint param_4,int param_5,long *param_6,\n                long *param_7)\n\n{\n  byte bVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  long lVar6;\n  ushort **ppuVar7;\n  uint uVar8;\n  bool bVar9;\n  long in_FS_OFFSET;\n  long local_58;\n  char *local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar2 = *param_1;\n  bVar9 = false;\n  if (cVar2 == '!') {\n    ppuVar7 = __ctype_b_loc();\n    bVar1 = param_1[1];\n    if ((*(byte *)((long)*ppuVar7 + (ulong)bVar1 * 2 + 1) & 4) != 0) goto LAB_0017ca90;\n    if (bVar1 == 0x5f) {\nLAB_0017cad8:\n      bVar9 = false;\n      if (param_1[2] == '\\0') {\n        if ((posixly_correct == 0) && ((bVar1 == 0x23 || (bVar1 == 0x3f)))) {\n          bVar9 = true;\n        }\n        else {\n          bVar9 = bVar1 == 0x40 || bVar1 == 0x2a;\n        }\n      }\nLAB_0017caa2:\n      param_1 = (char *)FUN_0017c6a0(param_1 + 1,bVar9,param_4,1);\n      if (param_1 == (char *)0x0) {\n        *param_6 = 0;\n        iVar4 = 0;\n        *param_7 = 0;\n        goto LAB_0017c9e5;\n      }\n      bVar9 = true;\n      cVar2 = *param_1;\n      goto LAB_0017c84a;\n    }\n    if (((byte)(bVar1 - 0x30) < 10) ||\n       (((posixly_correct == 0 && ((bVar1 == 0x23 || (bVar1 == 0x3f)))) || (bVar1 == 0x2a)))) {\nLAB_0017ca90:\n      if ((bVar1 != 0) || (bVar9 = true, (DAT_002394a4._1_1_ & 8) == 0)) goto LAB_0017cad8;\n      goto LAB_0017caa2;\n    }\n    bVar9 = false;\n    iVar4 = 0;\n    if (bVar1 == 0x40) goto LAB_0017ca90;\n  }\n  else {\nLAB_0017c84a:\n    if ((((cVar2 == '@') || (iVar4 = 0, cVar2 == '*')) && (iVar4 = 0, param_1[1] == '\\0')) &&\n       (iVar4 = 0x81, cVar2 != '*')) {\n      iVar4 = 1;\n    }\n  }\n  *param_6 = 0;\n  iVar3 = valid_array_reference(param_1,0);\n  local_58 = param_2;\n  if (iVar3 == 0) {\n    lVar5 = find_variable(param_1);\n    if (((lVar5 == 0) || (uVar8 = *(uint *)(lVar5 + 0x28), (uVar8 & 0x1000) != 0)) ||\n       ((uVar8 & 0x44) == 0)) {\n      if ((param_2 == 0) || (iVar4 != 0)) {\nLAB_0017c9d2:\n        *param_7 = local_58;\n      }\n      else {\n        lVar5 = find_variable(param_1);\n        *param_6 = lVar5;\n        if ((param_4 & 3) == 0) {\n          lVar5 = dequote_escapes(param_2);\n          *param_7 = lVar5;\n          iVar4 = 0;\n        }\n        else {\n          iVar4 = 0;\n          lVar5 = dequote_string(param_2);\n          *param_7 = lVar5;\n        }\n      }\n    }\n    else {\n      *param_6 = lVar5;\n      if ((uVar8 & 0x40) == 0) {\n        lVar5 = array_reference(*(undefined8 *)(lVar5 + 8),0);\n      }\n      else {\n        lVar5 = assoc_reference(*(undefined8 *)(lVar5 + 8),&DAT_00210deb);\n      }\n      *param_7 = lVar5;\n      iVar4 = 3;\n    }\n  }\n  else {\n    lVar5 = array_variable_part(param_1,0,&local_48,0);\n    if ((param_5 == 0) && (param_3 != 0)) {\n      *(undefined8 *)(param_3 + 8) = 0x8000000000000000;\n    }\n    if (lVar5 == 0) {\nLAB_0017ca1e:\n      *param_6 = lVar5;\n      iVar4 = 3;\n      lVar5 = array_value(param_1,1,param_5,param_3);\n      *param_7 = lVar5;\n    }\n    else {\n      uVar8 = *(uint *)(lVar5 + 0x28);\n      if ((uVar8 & 0x1000) != 0) {\n        *param_6 = 0;\n        *param_7 = 0;\n        uVar8 = *(uint *)(lVar5 + 0x28);\n      }\n      cVar2 = *local_48;\n      if ((uVar8 & 0x44) == 0) {\n        if ((cVar2 != '*' && cVar2 != '@') || (local_48[1] != ']')) goto LAB_0017ca1e;\n        *param_6 = lVar5;\n        if ((param_4 & 3) == 0) {\n          iVar4 = 0;\n          if (param_2 != 0) {\n            local_58 = dequote_escapes(param_2);\n          }\n          goto LAB_0017c9d2;\n        }\n        if (param_2 != 0) {\n          local_58 = dequote_string(param_2);\n        }\n        iVar4 = 0;\n        *param_7 = local_58;\n      }\n      else {\n        if ((cVar2 != '*' && cVar2 != '@') || (local_48[1] != ']')) {\n          iVar4 = 3;\n          lVar6 = array_value(param_1,1,param_5,param_3);\n        }\n        else {\n          iVar4 = 0x82;\n          if (cVar2 != '*') {\n            iVar4 = 2;\n          }\n          lVar6 = *(long *)(lVar5 + 8);\n        }\n        *param_7 = lVar6;\n        *param_6 = lVar5;\n      }\n    }\n  }\n  if (bVar9) {\n    sh_xfree(param_1,\"subst.c\",0x2093);\n  }\nLAB_0017c9e5:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar4;\n}\n\n",
  "rltty_set_default_bindings": "\nvoid rltty_set_default_bindings(undefined8 param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  undefined local_70 [8];\n  undefined local_68 [19];\n  undefined local_55;\n  undefined local_54;\n  undefined local_49;\n  undefined local_48;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = fileno(rl_instream);\n  iVar2 = ioctl(iVar1,0x5413,local_70);\n  if (iVar2 == 0) {\n    ioctl(iVar1,0x5414,local_70);\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  iVar1 = FUN_001d5280(iVar1,local_68);\n  if (-1 < iVar1) {\n    FUN_001d52f0(param_1,local_55,local_54,local_49,local_48);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_isearch_callback": "\nundefined8 _rl_isearch_callback(long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  _rl_search_getchar();\n  if (*(int *)(param_1 + 0x6c) < 0) {\n    *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 4;\n    iVar1 = -1;\n    *(undefined4 *)(param_1 + 0x60) = *(undefined4 *)(param_1 + 0x3c);\n  }\n  else {\n    iVar1 = FUN_001df160(param_1);\n    if (0 < iVar1) {\n      return 0;\n    }\n  }\n  uVar2 = _rl_isearch_cleanup(param_1,iVar1);\n  return uVar2;\n}\n\n",
  "sh_backslash_quote": "\nbyte * sh_backslash_quote(byte *param_1,undefined *param_2,uint param_3)\n\n{\n  byte *pbVar1;\n  mbstate_t mVar2;\n  uint uVar3;\n  size_t sVar4;\n  byte *pbVar5;\n  size_t sVar6;\n  size_t sVar7;\n  byte bVar8;\n  size_t sVar9;\n  byte *pbVar10;\n  byte *__s;\n  byte *pbVar11;\n  byte *pbVar12;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar4 = strlen((char *)param_1);\n  pbVar5 = (byte *)sh_xmalloc(sVar4 * 2 + 1,\"shquote.c\",0x112);\n  if (param_2 == (undefined *)0x0) {\n    param_2 = &DAT_002125e0;\n  }\n  sVar6 = __ctype_get_mb_cur_max();\n  uVar3 = (uint)(char)*param_1;\n  pbVar11 = pbVar5;\n  if (*param_1 != 0) {\n    pbVar10 = pbVar5;\n    __s = param_1;\n    do {\n      while( true ) {\n        mVar2 = local_48;\n        pbVar12 = __s + 1;\n        bVar8 = (byte)uVar3;\n        if ((0x7f < uVar3) || (param_2[uVar3 & 0xff] != '\\x01')) break;\n        *pbVar10 = 0x5c;\n        pbVar11 = pbVar10 + 2;\n        pbVar10[1] = bVar8;\n        local_48 = mVar2;\nLAB_001c8edc:\n        pbVar1 = __s + 1;\n        uVar3 = (uint)(char)*pbVar1;\n        pbVar10 = pbVar11;\n        __s = pbVar12;\n        if (*pbVar1 == 0) goto LAB_001c8f30;\n      }\n      if (locale_utf8locale == 0) {\n        if (((int)sVar6 < 2) ||\n           ((*(uint *)(is_basic_table + (ulong)(bVar8 >> 5) * 4) >> (bVar8 & 0x1f) & 1) != 0))\n        goto LAB_001c8ead;\n        if (locale_mb_cur_max < 2) goto LAB_001c8f18;\nLAB_001c8fb5:\n        sVar7 = mbrtowc((wchar_t *)0x0,(char *)__s,(size_t)(param_1 + (sVar4 - (long)__s)),&local_48\n                       );\n        if (sVar7 < 0xfffffffffffffffe) {\n          sVar9 = 1;\n          if (sVar7 != 0) {\n            sVar9 = sVar7;\n          }\n          sVar7 = 0;\n          do {\n            pbVar10[sVar7] = __s[sVar7];\n            sVar7 = sVar7 + 1;\n          } while (sVar7 != sVar9);\n          goto LAB_001c9050;\n        }\n        pbVar11 = pbVar10 + 1;\n        *pbVar10 = *__s;\n        local_48 = mVar2;\n        goto LAB_001c8edc;\n      }\n      if (-1 < (char)bVar8) {\nLAB_001c8ead:\n        if ((((param_2[uVar3 & 0xff] == '\\x01') || ((uVar3 == 0x23 && (param_1 == __s)))) ||\n            ((uVar3 == 0x7e &&\n             (((param_3 & 1) != 0 && (((param_1 == __s || (__s[-1] == 0x3a)) || (__s[-1] == 0x3d))))\n             )))) || (((param_3 & 2) != 0 &&\n                      ((*(byte *)((long)&sh_syntaxtab + (ulong)(uVar3 & 0xff) * 4 + 1) & 0x20) != 0)\n                      ))) {\n          *pbVar10 = 0x5c;\n          pbVar10 = pbVar10 + 1;\n        }\n        *pbVar10 = bVar8;\n        pbVar11 = pbVar10 + 1;\n        local_48 = mVar2;\n        goto LAB_001c8edc;\n      }\n      if (1 < locale_mb_cur_max) {\n        if ((*(uint *)(is_basic_table + (ulong)(bVar8 >> 5) * 4) >> (bVar8 & 0x1f) & 1) == 0)\n        goto LAB_001c8fb5;\n        *pbVar10 = *__s;\n        sVar7 = 1;\nLAB_001c9050:\n        pbVar11 = pbVar10 + sVar7;\n        pbVar12 = __s + sVar7;\n        __s = __s + (sVar7 - 1);\n        goto LAB_001c8edc;\n      }\nLAB_001c8f18:\n      *pbVar10 = bVar8;\n      pbVar1 = __s + 1;\n      uVar3 = (uint)(char)*pbVar1;\n      pbVar11 = pbVar10 + 1;\n      pbVar10 = pbVar10 + 1;\n      __s = pbVar12;\n    } while (*pbVar1 != 0);\n  }\nLAB_001c8f30:\n  *pbVar11 = 0;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pbVar5;\n}\n\n",
  "fmtumax": "\nchar * fmtumax(ulong param_1,uint param_2,char *param_3,long param_4,uint param_5)\n\n{\n  undefined auVar1 [16];\n  undefined auVar2 [16];\n  byte bVar3;\n  uint uVar4;\n  int *piVar5;\n  ulong uVar6;\n  char cVar7;\n  ulong uVar8;\n  char *pcVar9;\n  char *pcVar10;\n  int iVar11;\n  \n  if (param_2 == 0) {\n    if ((param_5 & 8) == 0) {\n      if ((long)param_1 < 0) {\n        param_3 = param_3 + param_4 + -2;\n        param_1 = -param_1;\n        iVar11 = 0x2d;\n        param_3[1] = '\\0';\n      }\n      else {\n        param_3 = param_3 + param_4 + -2;\n        param_3[1] = '\\0';\n        iVar11 = 0;\n      }\n    }\n    else {\n      param_3 = param_3 + param_4 + -2;\n      iVar11 = 0;\n      param_3[1] = '\\0';\n    }\nLAB_001caaa0:\n    pcVar9 = param_3 + -1;\n    cVar7 = (char)param_1;\n    if (param_1 < 10) {\n      *param_3 = cVar7 + '0';\n    }\n    else {\n      if ((long)param_1 < 0) {\n        pcVar9 = param_3 + -2;\n        param_1 = param_1 / 10;\n        *param_3 = cVar7 + (char)param_1 * -10 + '0';\n      }\n      while( true ) {\n        uVar6 = param_1 / 10;\n        pcVar9[1] = (char)param_1 + (char)uVar6 * -10 + '0';\n        if (uVar6 == 0) break;\n        pcVar9 = pcVar9 + -1;\n        param_1 = uVar6;\n      }\n    }\n    goto LAB_001caa68;\n  }\n  if (0x3e < param_2 - 2) {\n    strncpy(param_3,\"invalid base\",param_4 - 1);\n    param_3[param_4 + -1] = '\\0';\n    piVar5 = __errno_location();\n    *piVar5 = 0x16;\n    return param_3;\n  }\n  if ((param_5 & 8) == 0) {\n    iVar11 = 0;\n    if ((long)param_1 < 0) {\n      param_1 = -param_1;\n      iVar11 = 0x2d;\n    }\n  }\n  else {\n    iVar11 = 0;\n  }\n  param_3 = param_3 + param_4 + -2;\n  param_3[1] = '\\0';\n  if (param_2 == 8) {\n    do {\n      pcVar9 = param_3 + -1;\n      cVar7 = ((byte)param_1 & 7) + 0x30;\n      param_1 = param_1 >> 3;\n      *param_3 = cVar7;\n      param_3 = pcVar9;\n    } while (param_1 != 0);\n    if ((param_5 & 1) != 0) goto LAB_001caa58;\n  }\n  else {\n    if (8 < (int)param_2) {\n      if (param_2 != 10) {\n        if (param_2 != 0x10) goto LAB_001cac50;\n        do {\n          while (pcVar10 = param_3, uVar4 = (uint)param_1 & 0xf, (param_5 & 4) == 0) {\n            param_1 = param_1 >> 4;\n            *pcVar10 = \"0123456789abcdef\"[uVar4];\n            param_3 = pcVar10 + -1;\n            if (param_1 == 0) goto LAB_001cabaf;\n          }\n          param_1 = param_1 >> 4;\n          *pcVar10 = \"0123456789ABCDEF\"[uVar4];\n          param_3 = pcVar10 + -1;\n        } while (param_1 != 0);\nLAB_001cabaf:\n        pcVar9 = pcVar10 + -1;\n        if ((param_5 & 1) == 0) {\n          if ((param_5 & 2) == 0) goto LAB_001caa68;\n          *pcVar9 = '#';\n          pcVar10[-2] = '6';\n          pcVar10 = pcVar9;\n          goto LAB_001cad41;\n        }\n        goto LAB_001cacb8;\n      }\n      goto LAB_001caaa0;\n    }\n    if (param_2 != 2) {\nLAB_001cac50:\n      uVar6 = (ulong)(int)param_2;\n      do {\n        auVar1._8_8_ = 0;\n        auVar1._0_8_ = uVar6;\n        auVar2._8_8_ = 0;\n        auVar2._0_8_ = param_1;\n        uVar8 = SUB168(auVar2 % auVar1,0);\n        cVar7 = SUB161(auVar2 % auVar1,0);\n        if (uVar8 < 10) {\n          cVar7 = cVar7 + '0';\nLAB_001cac63:\n          *param_3 = cVar7;\n        }\n        else {\n          if (0x23 < uVar8) {\n            if (uVar8 < 0x3e) {\n              cVar7 = cVar7 + '\\x1d';\n            }\n            else {\n              cVar7 = '_';\n              if (uVar8 == 0x3e) {\n                cVar7 = '@';\n              }\n            }\n            goto LAB_001cac63;\n          }\n          cVar7 = cVar7 + 'W';\n          *param_3 = cVar7;\n        }\n        if (param_1 < uVar6) goto LAB_001cac97;\n        param_3 = param_3 + -1;\n        param_1 = param_1 / uVar6;\n      } while( true );\n    }\n    do {\n      pcVar9 = param_3 + -1;\n      bVar3 = (byte)param_1;\n      param_1 = param_1 >> 1;\n      *param_3 = (bVar3 & 1) + 0x30;\n      param_3 = pcVar9;\n    } while (param_1 != 0);\n  }\n  if ((param_5 >> 1 & 1) == 0) goto LAB_001caa68;\n  *pcVar9 = '#';\n  pcVar9[-1] = (char)param_2 + (char)(param_2 / 10) * -10 + '0';\n  goto LAB_001cab41;\nLAB_001cac97:\n  pcVar9 = param_3 + -1;\n  if (((param_5 & 1) != 0) && ((param_2 - 8 & 0xfffffff7) == 0)) {\n    if (param_2 == 0x10) {\nLAB_001cacb8:\n      pcVar9[-1] = '0';\n      *pcVar9 = (-((param_5 & 4) == 0) & 0x20U) + 0x58;\n      pcVar9 = pcVar9 + -2;\n      goto LAB_001caa68;\n    }\nLAB_001caa58:\n    if (cVar7 != '0') {\n      *pcVar9 = '0';\n      pcVar9 = pcVar9 + -1;\n    }\n    goto LAB_001caa68;\n  }\n  if (((byte)(param_5 >> 1) & param_2 != 10) == 0) goto LAB_001caa68;\n  *pcVar9 = '#';\n  param_3[-2] = (char)param_2 + (char)(param_2 / 10) * -10 + '0';\n  pcVar10 = pcVar9;\n  if (10 < (int)param_2) {\nLAB_001cad41:\n    pcVar9 = pcVar10 + -3;\n    pcVar10[-2] = (char)((ulong)param_2 / 10) + '0';\n    goto LAB_001caa68;\n  }\nLAB_001cab41:\n  pcVar9 = pcVar9 + -2;\nLAB_001caa68:\n  if (iVar11 == 0) {\n    return pcVar9 + 1;\n  }\n  *pcVar9 = '-';\n  return pcVar9;\n}\n\n",
  "__fprintf_chk": "\nvoid __fprintf_chk(void)\n\n{\n  (*(code *)PTR___fprintf_chk_00237e10)();\n  return;\n}\n\n",
  "valid_nameref_value": "\nulong valid_nameref_value(char *param_1,int param_2)\n\n{\n  int iVar1;\n  ulong uVar2;\n  \n  if (param_1 == (char *)0x0) {\n    return 0;\n  }\n  uVar2 = 0;\n  if (*param_1 != '\\0') {\n    uVar2 = legal_identifier();\n    if ((int)uVar2 != 0) {\n      return 1;\n    }\n    if (param_2 != 2) {\n      iVar1 = valid_array_reference(param_1,0);\n      return (ulong)(iVar1 != 0);\n    }\n  }\n  return uVar2;\n}\n\n",
  "FUN_0016fa40": "\nchar * FUN_0016fa40(uint param_1,char **param_2,char *param_3)\n\n{\n  int iVar1;\n  char *pcVar2;\n  size_t sVar3;\n  char *__s;\n  size_t sVar4;\n  undefined8 uVar5;\n  long lVar6;\n  long in_FS_OFFSET;\n  bool bVar7;\n  char local_58 [24];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((param_2 == (char **)0x0) && ((param_1 & 0xffffffdf) == 0x41)) ||\n     ((param_3 == (char *)0x0 && ((param_1 & 0xffffffdf) != 0x41)))) {\nswitchD_0016fa91_caseD_42:\n    pcVar2 = (char *)0x0;\n    goto LAB_0016fa9b;\n  }\n  switch(param_1) {\n  case 0x41:\n    if ((param_2 == (char **)0x0) ||\n       (((*(byte *)((long)param_2 + 0x29) & 0x10) == 0 && (param_2[1] != (char *)0x0)))) {\n      __s = (char *)sh_quote_reusable(param_3,0);\n      iVar1 = var_attribute_string(param_2,0,local_58);\n      bVar7 = __s == (char *)0x0;\n      if ((iVar1 == 0) && (bVar7)) goto switchD_0016fa91_caseD_42;\n      lVar6 = (long)iVar1;\n      if (__s == (char *)0x0) goto LAB_0016fd54;\n      sVar3 = 0;\n      if (((*__s != '\\0') && (sVar3 = 1, __s[1] != '\\0')) && (sVar3 = 2, __s[2] != '\\0')) {\n        sVar3 = strlen(__s);\n      }\n      sVar4 = strlen(*param_2);\n      pcVar2 = (char *)sh_xmalloc(sVar3 + 0x20 + lVar6 + sVar4,\"subst.c\",0x20ab);\nLAB_0016fc88:\n      if (iVar1 < 1) {\n        __sprintf_chk(pcVar2,1,0xffffffffffffffff,\"%s=%s\",*param_2,__s);\n      }\n      else {\n        __sprintf_chk(pcVar2,1,0xffffffffffffffff,\"declare -%s %s=%s\",local_58,*param_2,__s);\n      }\n    }\n    else {\n      iVar1 = var_attribute_string(param_2,0,local_58);\n      if (iVar1 == 0) goto switchD_0016fa91_caseD_42;\n      lVar6 = (long)iVar1;\n      bVar7 = true;\nLAB_0016fd54:\n      sVar3 = strlen(*param_2);\n      pcVar2 = (char *)sh_xmalloc(lVar6 + 0x20 + sVar3,\"subst.c\",0x20ab);\n      if ((iVar1 < 1) || (!bVar7)) {\n        __s = (char *)0x0;\n        goto LAB_0016fc88;\n      }\n      __s = (char *)0x0;\n      __sprintf_chk(pcVar2,1,0xffffffffffffffff,\"declare -%s %s\",local_58,*param_2);\n    }\n    sh_xfree(__s,\"subst.c\",0x20b2);\n    goto LAB_0016fa9b;\n  default:\n    goto switchD_0016fa91_caseD_42;\n  case 0x45:\n    sVar3 = strlen(param_3);\n    uVar5 = ansiexpand(param_3,0,sVar3 & 0xffffffff,0);\n    pcVar2 = (char *)dequote_escapes(uVar5);\n    sh_xfree(uVar5,\"subst.c\",0x2117);\n    goto LAB_0016fa9b;\n  case 0x4b:\n  case 0x51:\n  case 0x6b:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      pcVar2 = (char *)sh_quote_reusable(param_3,0);\n      return pcVar2;\n    }\n    break;\n  case 0x4c:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar5 = 1;\nLAB_0016fb41:\n      pcVar2 = (char *)sh_modcase(param_3,0,uVar5);\n      return pcVar2;\n    }\n    break;\n  case 0x50:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      pcVar2 = (char *)decode_prompt_string(param_3);\n      return pcVar2;\n    }\n    break;\n  case 0x55:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar5 = 2;\n      goto LAB_0016fb41;\n    }\n    break;\n  case 0x61:\n    iVar1 = var_attribute_string(param_2,0,local_58);\n    if (iVar1 < 1) goto switchD_0016fa91_caseD_42;\n    sVar3 = strlen(local_58);\n    pcVar2 = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",0x210a);\n    pcVar2 = strcpy(pcVar2,local_58);\nLAB_0016fa9b:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return pcVar2;\n    }\n    break;\n  case 0x75:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar5 = 0x40;\n      goto LAB_0016fb41;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "array_to_kvpair_list": "\nlong * array_to_kvpair_list(long param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  long *plVar4;\n  undefined8 *puVar5;\n  \n  if (((param_1 != 0) && (*(long *)(param_1 + 8) != 0)) &&\n     (puVar5 = (undefined8 *)(*(undefined8 **)(param_1 + 0x10))[2],\n     *(undefined8 **)(param_1 + 0x10) != puVar5)) {\n    plVar4 = (long *)0x0;\n    do {\n      uVar1 = itos(*puVar5);\n      uVar3 = puVar5[1];\n      uVar2 = make_bare_word(uVar1);\n      uVar2 = make_word_list(uVar2,plVar4);\n      uVar3 = make_bare_word(uVar3);\n      plVar4 = (long *)make_word_list(uVar3,uVar2);\n      sh_xfree(uVar1,\"array.c\",0x32c);\n      puVar5 = (undefined8 *)puVar5[2];\n    } while (*(undefined8 **)(param_1 + 0x10) != puVar5);\n    if (plVar4 != (long *)0x0) {\n      if (*plVar4 == 0) {\n        return plVar4;\n      }\n      plVar4 = (long *)list_reverse(plVar4);\n      return plVar4;\n    }\n  }\n  return (long *)0x0;\n}\n\n",
  "nl_langinfo": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_nl_langinfo_00237c00)();\n  return pcVar1;\n}\n\n",
  "chkexport": "\nuint chkexport(void)\n\n{\n  uint uVar1;\n  long lVar2;\n  \n  lVar2 = find_variable();\n  uVar1 = 0;\n  if (lVar2 != 0) {\n    uVar1 = *(uint *)(lVar2 + 0x28) & 1;\n    if (uVar1 != 0) {\n      array_needs_making = 1;\n      FUN_00156bc0();\n      return uVar1;\n    }\n  }\n  return uVar1;\n}\n\n",
  "rl_getc": "\nulong rl_getc(FILE *param_1)\n\n{\n  int __fd;\n  int iVar1;\n  int *piVar2;\n  ssize_t sVar3;\n  ulong uVar4;\n  long lVar5;\n  ulong *puVar6;\n  long in_FS_OFFSET;\n  byte bVar7;\n  byte local_c9;\n  ulong local_c8 [17];\n  long local_40;\n  \n  bVar7 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  __fd = fileno(param_1);\n  do {\n    while( true ) {\n      if (_rl_caught_signal != 0) {\n        _rl_signal_handler(_rl_caught_signal);\n      }\n      puVar6 = local_c8;\n      for (lVar5 = 0x10; lVar5 != 0; lVar5 = lVar5 + -1) {\n        *puVar6 = 0;\n        puVar6 = puVar6 + (ulong)bVar7 * -2 + 1;\n      }\n      lVar5 = __fdelt_chk((long)__fd);\n      local_c8[lVar5] = local_c8[lVar5] | 1L << ((byte)__fd & 0x3f);\n      iVar1 = _rl_timeout_select(__fd + 1,local_c8,0,0,0,_rl_orig_sigset);\n      if (iVar1 == 0) {\n        if (rl_timeout_event_hook != (code *)0x0) {\n          (*rl_timeout_event_hook)();\n        }\n        rl_readline_state = rl_readline_state | 0x4000000;\n                    /* WARNING: Subroutine does not return */\n        _rl_abort_internal();\n      }\n      if (-1 < iVar1) {\n        sVar3 = read(__fd,&local_c9,1);\n        if ((int)sVar3 == 1) {\n          uVar4 = (ulong)local_c9;\n          goto LAB_001ebc92;\n        }\n        if ((int)sVar3 == 0) goto LAB_001ebc8d;\n      }\n      piVar2 = __errno_location();\n      if (*piVar2 != 0xb) break;\n      iVar1 = sh_unset_nodelay_mode(__fd);\n      if (iVar1 < 0) {\nLAB_001ebc8d:\n        uVar4 = 0xffffffff;\nLAB_001ebc92:\n        if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n          return uVar4;\n        }\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n    }\n    if (((*piVar2 != 4) || (_rl_caught_signal == 1)) || (_rl_caught_signal == 0xf)) {\n      uVar4 = 0xfffffffe;\n      if ((rl_readline_state & 8) != 0) goto LAB_001ebc92;\n      goto LAB_001ebc8d;\n    }\n    if (((((_rl_caught_signal == 2) || (_rl_caught_signal == 3)) ||\n         ((_rl_caught_signal == 0x14 || ((_rl_caught_signal == 0x1c || (_rl_caught_signal == 0xe))))\n         )) || (_rl_caught_signal == 0x1a)) && (_rl_caught_signal != 0)) {\n      _rl_signal_handler(_rl_caught_signal);\n    }\n    if (rl_signal_event_hook != (code *)0x0) {\n      (*rl_signal_event_hook)();\n    }\n  } while( true );\n}\n\n",
  "exit_shell": "\nvoid exit_shell\n     _noreturn_\n               (int param_1)\n\n{\n  int iVar1;\n  \n  fflush(stdout);\n  fflush(stderr);\n  if ((((byte)rl_readline_state & 4) != 0) && (rl_deprep_term_function != (undefined *)0x0)) {\n    (*(code *)rl_deprep_term_function)();\n  }\n  iVar1 = read_tty_modified();\n  if (iVar1 != 0) {\n    read_tty_cleanup();\n  }\n  iVar1 = signal_is_trapped(0);\n  if (iVar1 != 0) {\n    param_1 = run_exit_trap();\n  }\n  unlink_all_fifos();\n  if (remember_on_history != 0) {\n    maybe_save_shell_history();\n  }\n  coproc_flush();\n  if (((interactive_shell != 0) && (login_shell != 0)) && (hup_on_exit != 0)) {\n    hangup_all_jobs();\n  }\n  if (subshell_environment == 0) {\n    end_job_control();\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n",
  "tgetent": "\nvoid tgetent(void)\n\n{\n  (*(code *)PTR_tgetent_00237e60)();\n  return;\n}\n\n",
  "pre_process_line": "\nchar * pre_process_line(char *param_1,int param_2,int param_3)\n\n{\n  char *pcVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  char *pcVar5;\n  char *pcVar6;\n  long in_FS_OFFSET;\n  char *local_38;\n  long local_30;\n  \n  iVar3 = history_length;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar6 = param_1;\n  if ((history_expansion_inhibited == 0) && (history_expansion != 0)) {\n    cVar2 = *param_1;\n    pcVar5 = param_1;\n    while (cVar2 != '\\0') {\n      if ((history_expansion_char == cVar2) || (history_subst_char == cVar2)) {\n        if ((0 < history_length) &&\n           (((command_oriented_history != 0 && (current_command_first_line_saved != 0)) &&\n            (1 < current_command_line_count)))) {\n          history_length = history_length + -1;\n        }\n        iVar4 = history_expand(param_1,&local_38);\n        if (((-1 < history_length) && (command_oriented_history != 0)) &&\n           ((current_command_first_line_saved != 0 && (1 < current_command_line_count)))) {\n          history_length = iVar3;\n        }\n        pcVar6 = local_38;\n        if (iVar4 != 0) {\n          if (param_2 == 0) {\nLAB_00191335:\n            if ((iVar4 < 0) || (iVar4 == 2)) {\n              if (iVar4 == 2) {\n                if ((rl_dispatching == 0) && (*local_38 != '\\0')) {\n                  maybe_add_history(local_38);\n                }\n                pcVar6 = (char *)0x0;\n                sh_xfree(local_38,\"bashhist.c\",0x260);\n              }\n              else {\nLAB_001913f4:\n                sh_xfree(local_38,\"bashhist.c\",0x260);\n                if ((((history_reediting == 0) || (-1 < iVar4)) || (rl_done == 0)) ||\n                   (bash_input != 1)) {\n                  pcVar6 = (char *)0x0;\n                }\n                else {\n                  pcVar6 = (char *)0x0;\n                  bash_re_edit(param_1);\n                }\n              }\n              goto LAB_00191248;\n            }\n          }\n          else {\n            if (iVar4 < 0) {\n              internal_error(&DAT_002102da,local_38);\n              goto LAB_001913f4;\n            }\n            if ((hist_verify == 0) || (iVar4 == 2)) {\n              __fprintf_chk(stderr,1,&DAT_0020fbe7);\n              goto LAB_00191335;\n            }\n          }\n          pcVar6 = local_38;\n          if ((iVar4 == 1) && (hist_verify != 0)) {\n            if (bash_input == 1) {\n              bash_re_edit(local_38);\n            }\n            pcVar6 = (char *)0x0;\n            sh_xfree(local_38,\"bashhist.c\",0x26f);\n            goto LAB_00191248;\n          }\n        }\n        break;\n      }\n      pcVar1 = pcVar5 + 1;\n      pcVar5 = pcVar5 + 1;\n      cVar2 = *pcVar1;\n    }\n  }\n  if (((param_3 != 0) && (remember_on_history != 0)) && (*pcVar6 != '\\0')) {\n    maybe_add_history(pcVar6);\n  }\nLAB_00191248:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pcVar6;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "list_reverse": "\nvoid list_reverse(long **param_1)\n\n{\n  long **pplVar1;\n  long **pplVar2;\n  \n  if (param_1 != (long **)0x0) {\n    pplVar2 = (long **)0x0;\n    do {\n      pplVar1 = param_1;\n      param_1 = (long **)*pplVar1;\n      *pplVar1 = (long *)pplVar2;\n      pplVar2 = pplVar1;\n    } while (param_1 != (long **)0x0);\n  }\n  return;\n}\n\n",
  "find_function_def": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong find_function_def(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  \n  uVar1 = shell_function_defs;\n  lVar2 = hash_search(param_1,shell_function_defs,0);\n  if (lVar2 != 0) {\n    _DAT_002422f8 = uVar1;\n    lVar2 = *(long *)(lVar2 + 0x10);\n  }\n  return lVar2;\n}\n\n",
  "FUN_00194330": "\nvoid FUN_00194330(undefined8 param_1)\n\n{\n  rl_point = rl_end;\n  rl_add_undo(2,0,0,0);\n  rl_delete_text(0,rl_point);\n  rl_mark = 0;\n  rl_end = 0;\n  rl_point = 0;\n  rl_insert_text(param_1);\n  rl_add_undo(3,0,0,0);\n  return;\n}\n\n",
  "rl_stuff_char": "\nint rl_stuff_char(int param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  lVar2 = (long)DAT_0024b3e0;\n  if (DAT_0024b3e0 < DAT_0024b3e4) {\n    iVar1 = (DAT_0024b3e4 - DAT_0024b3e0) + -1;\n  }\n  else {\n    iVar1 = (DAT_0024b3e4 - DAT_0024b3e0) + 0x1ff;\n  }\n  if (iVar1 != 0) {\n    if (param_1 == -1) {\n      rl_readline_state = rl_readline_state | 0x20000;\n      param_1 = 10;\n      rl_pending_input = 0xffffffff;\n    }\n    DAT_0024b3e0 = DAT_0024b3e0 + 1;\n    (&DAT_0024b1e0)[lVar2] = (char)param_1;\n    iVar1 = 1;\n    if (0x1ff < DAT_0024b3e0) {\n      DAT_0024b3e0 = 0;\n    }\n  }\n  return iVar1;\n}\n\n",
  "FUN_00172120": "\nundefined8\nFUN_00172120(long *param_1,undefined8 param_2,undefined4 param_3,undefined4 param_4,\n            undefined4 param_5)\n\n{\n  long *plVar1;\n  undefined *puVar2;\n  undefined8 *puVar3;\n  undefined8 uVar4;\n  \n  if (param_1 != (long *)0x0) {\n    plVar1 = (long *)0x0;\n    do {\n      puVar2 = (undefined *)FUN_00167b60(*(undefined8 *)param_1[1],param_2,param_3);\n      puVar3 = (undefined8 *)alloc_word_desc();\n      if (puVar2 == (undefined *)0x0) {\n        puVar2 = (undefined *)sh_xmalloc(1,\"subst.c\",0x169d);\n        *puVar2 = 0;\n      }\n      *puVar3 = puVar2;\n      plVar1 = (long *)make_word_list(puVar3,plVar1);\n      param_1 = (long *)*param_1;\n    } while (param_1 != (long *)0x0);\n    if (plVar1 != (long *)0x0) {\n      if (*plVar1 != 0) {\n        plVar1 = (long *)list_reverse(plVar1);\n      }\n      goto LAB_001721d0;\n    }\n  }\n  plVar1 = (long *)0x0;\nLAB_001721d0:\n  uVar4 = string_list_pos_params(param_4,plVar1,param_5,0);\n  dispose_words(plVar1);\n  return uVar4;\n}\n\n",
  "bash_history_reinit": "\nvoid bash_history_reinit(int param_1)\n\n{\n  if (param_1 == 0) {\n    history_expansion_inhibited = 1 - histexp_flag;\n    history_expansion = histexp_flag;\n  }\n  else {\n    history_expansion = 1;\n    history_expansion_inhibited = 0;\n  }\n  history_inhibit_expansion_function = FUN_00190570;\n  remember_on_history = enable_history_list;\n  return;\n}\n\n",
  "FUN_00135180": "\nvoid FUN_00135180(long param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  char *pcVar4;\n  char cVar5;\n  char *pcVar6;\n  undefined8 uVar7;\n  char cVar8;\n  int iVar9;\n  \n  if (param_1 == 0) {\n    if (current_token == 0) {\nLAB_00135210:\n      if ((DAT_00240da8 != (char *)0x0) && (cVar5 = *DAT_00240da8, cVar5 != '\\0')) {\nLAB_001352d8:\n        pcVar6 = DAT_00240da8;\n        iVar1 = (int)DAT_00240da0;\n        lVar2 = (long)iVar1;\n        if (iVar1 != 0) {\n          cVar8 = DAT_00240da8[iVar1];\n          if (cVar8 == '\\0') {\n            if (iVar1 + -1 == 0) goto LAB_001353e0;\n            lVar2 = (long)(iVar1 + -1);\n            cVar8 = DAT_00240da8[lVar2];\n          }\n          while( true ) {\n            if ((1 < (byte)(cVar8 - 9U)) && (cVar8 != ' ')) {\n              iVar1 = (int)lVar2;\n              iVar9 = iVar1 + 1;\n              if (iVar1 == 0) {\n                iVar9 = 1;\n                lVar2 = 0;\n                goto LAB_00135395;\n              }\n              lVar2 = (long)iVar1;\n              goto LAB_00135363;\n            }\n            lVar2 = lVar2 + -1;\n            if ((int)lVar2 == 0) break;\n            cVar8 = DAT_00240da8[lVar2];\n          }\n        }\n        goto LAB_001353e0;\n      }\n      pcVar6 = \"syntax error\";\n      if (EOF_Reached != 0) goto LAB_001351c0;\nLAB_00135246:\n      parser_error(line_number,&DAT_002102da,pcVar6);\n    }\n    else {\n      if (EOF_Reached == 0) {\n        pcVar6 = (char *)FUN_00135070();\n        if (pcVar6 == (char *)0x0) goto LAB_00135210;\n        iVar1 = ansic_shouldquote(pcVar6);\n        pcVar4 = pcVar6;\n        if (iVar1 != 0) {\n          pcVar4 = (char *)ansic_quote(pcVar6,0,0);\n          sh_xfree(pcVar6,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1851);\n        }\n        parser_error(line_number,\"syntax error near unexpected token `%s\\'\",pcVar4);\n        uVar7 = 0x1855;\n        goto LAB_00135424;\n      }\n      if ((DAT_00240da8 != (char *)0x0) && (cVar5 = *DAT_00240da8, cVar5 != '\\0'))\n      goto LAB_001352d8;\nLAB_001351c0:\n      pcVar6 = \"syntax error: unexpected end of file\";\n      if ((shell_eof_token == 0) || (shell_eof_token == current_token)) goto LAB_00135246;\n      parser_error(line_number,\"unexpected EOF while looking for matching `%c\\'\",shell_eof_token);\n    }\n  }\n  else {\n    parser_error(line_number,&DAT_002102da,param_1);\n  }\n  if ((interactive != 0) && (EOF_Reached != 0)) {\n    EOF_Reached = 0;\n  }\n  goto LAB_00135272;\nLAB_00135363:\n  iVar1 = (int)lVar2;\n  if ((cVar8 != '\\0') && (lVar3 = mbschr(\" \\n\\t;|&\"), lVar3 != 0)) {\n    if (iVar9 == iVar1) goto LAB_001353b0;\n    goto LAB_0013537c;\n  }\n  lVar2 = lVar2 + -1;\n  if ((int)lVar2 == 0) goto LAB_00135488;\n  cVar8 = pcVar6[lVar2];\n  goto LAB_00135363;\nLAB_00135488:\n  iVar1 = 0;\n  if (iVar9 == 0) {\nLAB_001353e0:\n    pcVar4 = (char *)sh_xmalloc(2,\"/usr/local/src/chet/src/bash/src/parse.y\",0x181d);\n    cVar5 = *pcVar6;\n    pcVar4[1] = '\\0';\n    *pcVar4 = cVar5;\nLAB_00135408:\n    parser_error(line_number,\"syntax error near `%s\\'\",pcVar4);\n    uVar7 = 0x1868;\nLAB_00135424:\n    sh_xfree(pcVar4,\"/usr/local/src/chet/src/bash/src/parse.y\",uVar7);\n  }\n  else {\nLAB_0013537c:\n    lVar2 = (long)iVar1;\n    cVar5 = pcVar6[lVar2];\nLAB_00135395:\n    while ((((byte)(cVar5 - 9U) < 2 || (iVar1 = (int)lVar2, cVar5 == ' ')) &&\n           (lVar2 = lVar2 + 1, iVar1 = iVar9, iVar9 != (int)lVar2))) {\n      cVar5 = pcVar6[lVar2];\n    }\nLAB_001353b0:\n    if (iVar9 == 0) {\n      if (iVar1 == 0) goto LAB_001353e0;\n    }\n    else {\n      pcVar4 = (char *)substring(pcVar6,iVar1,iVar9);\n      if (pcVar4 != (char *)0x0) goto LAB_00135408;\n    }\n  }\n  if (interactive == 0) {\n    FUN_00134d70();\n  }\nLAB_00135272:\n  last_command_exit_value = 2;\n  if (executing_builtin != 0) {\n    last_command_exit_value = (-(uint)(parse_and_execute_level == 0) & 0xffffff01) + 0x101;\n  }\n  set_pipestatus_from_exit(last_command_exit_value);\n  return;\n}\n\n",
  "rl_clear_display": "\nundefined8 rl_clear_display(void)\n\n{\n  _rl_clear_screen(1);\n  rl_forced_update_display();\n  rl_display_fixed = 1;\n  return 0;\n}\n\n",
  "_rl_dispatch_callback": "\nint _rl_dispatch_callback(uint *param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  \n  if ((*(byte *)param_1 & 1) == 0) {\n    if (param_1[3] == 0x1b) {\n      rl_readline_state = rl_readline_state | 0x50;\n      iVar1 = rl_read_key();\n      rl_readline_state = rl_readline_state & 0xffffffffffffffaf;\n    }\n    else {\n      rl_readline_state = rl_readline_state | 0x40;\n      iVar1 = rl_read_key();\n      rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n    }\n    if (iVar1 < 0) {\n                    /* WARNING: Subroutine does not return */\n      _rl_abort_internal();\n    }\n    uVar2 = _rl_dispatch_subseq(iVar1,*(undefined8 *)(param_1 + 4),param_1[1]);\n    *param_1 = *param_1 | 1;\n  }\n  else {\n    uVar2 = param_1[10];\n  }\n  if (uVar2 == 0xfffffffd) {\n    if (_rl_caught_signal != 0) {\n      _rl_signal_handler(_rl_caught_signal);\n    }\njoined_r0x001cee87:\n    if (_rl_kscxt != 0) {\n      *(undefined4 *)(_rl_kscxt + 0x28) = 0xfffffffd;\n    }\n    return -3;\n  }\n  iVar1 = FUN_001cec90(uVar2,*(undefined8 *)(param_1 + 6),param_1[3],*param_1 & 2);\n  if (_rl_caught_signal != 0) {\n    _rl_signal_handler(_rl_caught_signal);\n  }\n  if (iVar1 < 0) {\n    if (iVar1 == -1) {\n      if ((*(byte *)param_1 & 2) == 0) goto LAB_001ceee8;\n      _rl_kscxt = *(long *)(param_1 + 8);\n      if (_rl_kscxt != 0) {\n        *(undefined4 *)(_rl_kscxt + 0x28) = 0xffffffff;\n      }\n    }\n    else {\n      if (iVar1 == -3) goto joined_r0x001cee87;\n      _rl_kscxt = *(long *)(param_1 + 8);\n      if (_rl_kscxt != 0) {\n        *(int *)(_rl_kscxt + 0x28) = iVar1;\n      }\n    }\n    xfree(param_1);\n    return iVar1;\n  }\nLAB_001ceee8:\n  while (_rl_kscxt != 0) {\n    _rl_kscxt = *(long *)(_rl_kscxt + 0x20);\n    xfree();\n  }\n  rl_readline_state = rl_readline_state & 0xffffffffffdfffff;\n  return iVar1;\n}\n\n",
  "sh_badjob": "\nvoid sh_badjob(undefined8 param_1)\n\n{\n  builtin_error(\"%s: no such job\",param_1);\n  return;\n}\n\n",
  "rl_modifying": "\nundefined8 rl_modifying(int param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  int iVar4;\n  \n  iVar4 = param_2;\n  iVar3 = param_1;\n  if ((param_1 <= param_2) && (iVar4 = param_1, iVar3 = param_2, param_1 == param_2)) {\n    return 0;\n  }\n  uVar1 = rl_copy_text(iVar4,iVar3);\n  puVar2 = (undefined8 *)xmalloc(0x20);\n  puVar2[1] = 0;\n  *puVar2 = rl_undo_list;\n  puVar2[2] = 0;\n  *(undefined4 *)(puVar2 + 3) = 2;\n  _rl_undo_group_level = _rl_undo_group_level + 1;\n  rl_undo_list = puVar2;\n  puVar2 = (undefined8 *)xmalloc(0x20);\n  *(int *)(puVar2 + 1) = iVar4;\n  *puVar2 = rl_undo_list;\n  *(int *)((long)puVar2 + 0xc) = iVar3;\n  puVar2[2] = uVar1;\n  *(undefined4 *)(puVar2 + 3) = 0;\n  rl_undo_list = puVar2;\n  puVar2 = (undefined8 *)xmalloc(0x20);\n  *(int *)(puVar2 + 1) = iVar4;\n  *puVar2 = rl_undo_list;\n  *(int *)((long)puVar2 + 0xc) = iVar3;\n  *(undefined4 *)(puVar2 + 3) = 1;\n  puVar2[2] = 0;\n  rl_undo_list = puVar2;\n  puVar2 = (undefined8 *)xmalloc(0x20);\n  puVar2[1] = 0;\n  *puVar2 = rl_undo_list;\n  puVar2[2] = 0;\n  *(undefined4 *)(puVar2 + 3) = 3;\n  rl_undo_list = puVar2;\n  _rl_undo_group_level = _rl_undo_group_level + -1;\n  return 0;\n}\n\n",
  "posix_initialize": "\nvoid posix_initialize(int param_1)\n\n{\n  char *pcVar1;\n  long lVar2;\n  long lVar3;\n  int *piVar4;\n  int *piVar5;\n  \n  lVar2 = DAT_00241ea0;\n  if (param_1 != 0) {\n    expand_aliases = 1;\n    source_uses_path = 1;\n    interactive_comments = 1;\n    inherit_errexit = 1;\n    source_searches_cwd = 0;\n    print_shift_error = 1;\n    return;\n  }\n  if (DAT_00241ea0 != 0) {\n    lVar3 = 0;\n    piVar4 = &interactive_comments;\n    piVar5 = &source_uses_path;\n    while( true ) {\n      pcVar1 = (char *)(lVar2 + lVar3);\n      lVar3 = lVar3 + 1;\n      *piVar4 = (int)*pcVar1;\n      if (piVar5 == (int *)0x0) break;\n      piVar4 = piVar5;\n      piVar5 = (int *)(&PTR_source_uses_path_00235f88)[lVar3];\n    }\n    sh_xfree(lVar2,\"general.c\",0x77);\n    DAT_00241ea0 = 0;\n    return;\n  }\n  source_searches_cwd = 1;\n  print_shift_error = 0;\n  expand_aliases = interactive_shell;\n  return;\n}\n\n",
  "FUN_001d2470": "\nundefined8 FUN_001d2470(long param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  uint uVar6;\n  \n  iVar3 = *(int *)(param_1 + 0x20);\n  if (iVar3 == 0) {\n    if (*(int *)(param_1 + 0x1c) != 0) goto LAB_001d24cf;\n  }\n  else {\n    pcVar4 = strchr(\" hl^$0ftFT;,%wbeWBE|`\",iVar3);\n    if (pcVar4 != (char *)0x0) {\n      if (((uint)rl_readline_state & 0x180400) == 0x180400) {\n        rl_readline_state = rl_readline_state & 0xfffffffffffffbff;\n      }\n      uVar5 = FUN_001d23d0(param_1);\n      return uVar5;\n    }\n    if ((*(int *)(param_1 + 0x1c) == iVar3) && ((iVar3 - 99U < 2 || (iVar3 == 0x79)))) {\n      rl_mark = rl_end;\n      rl_beg_of_line(1,iVar3);\n      rl_readline_state = rl_readline_state & 0xffffffffffefffff;\n      DAT_0024a400 = iVar3;\n      uVar5 = FUN_001cff80(param_1);\n      return uVar5;\n    }\n  }\n  iVar1 = rl_numeric_arg;\n  if (iVar3 - 0x30U < 10) {\n    uVar6 = (uint)rl_readline_state & 0x180400;\n    if ((uVar6 == 0x180400) || (rl_readline_state = rl_readline_state | 0x400, uVar6 == 0x180000)) {\n      uVar5 = FUN_001cf8d0(iVar3);\n      return uVar5;\n    }\n    rl_explicit_arg = 1;\n    rl_numeric_arg = iVar3 - 0x30U;\n    do {\n      iVar3 = _rl_arg_overflow();\n      if (iVar3 != 0) goto LAB_001d2575;\n      uVar2 = _rl_arg_getchar();\n      iVar3 = FUN_001cf8d0(uVar2);\n    } while (0 < iVar3);\n    rl_readline_state = rl_readline_state & 0xfffffffffffffbff;\nLAB_001d2575:\n    rl_numeric_arg = iVar1 * rl_numeric_arg;\n    iVar3 = _rl_bracketed_read_key();\n    if (iVar3 < 0) {\n      *(undefined4 *)(param_1 + 0x20) = 0;\n      return 0xffffffff;\n    }\n    *(int *)(param_1 + 0x20) = iVar3;\n    uVar5 = FUN_001d23d0(param_1);\n    return uVar5;\n  }\nLAB_001d24cf:\n  rl_readline_state = rl_readline_state & 0xffffffffffeffbff;\n  return 1;\n}\n\n",
  "history_arg_extract": "\nundefined * history_arg_extract(uint param_1,int param_2,undefined8 param_3)\n\n{\n  bool bVar1;\n  uint uVar2;\n  long *plVar3;\n  long lVar4;\n  size_t sVar5;\n  undefined *puVar6;\n  int iVar7;\n  long *plVar8;\n  long lVar9;\n  int iVar10;\n  int iVar11;\n  uint uVar12;\n  uint uVar13;\n  \n  plVar3 = (long *)FUN_001f2720(param_3,0xffffffff,0);\n  if (plVar3 == (long *)0x0) {\n    puVar6 = (undefined *)0x0;\n  }\n  else {\n    if (*plVar3 == 0) {\n      uVar13 = 0;\n    }\n    else {\n      lVar4 = 1;\n      do {\n        uVar13 = (uint)lVar4;\n        plVar8 = plVar3 + lVar4;\n        lVar4 = lVar4 + 1;\n      } while (*plVar8 != 0);\n    }\n    if (param_2 < 0) {\n      param_2 = (uVar13 - 1) + param_2;\n    }\n    if ((int)param_1 < 0) {\n      param_1 = (uVar13 - 1) + param_1;\n    }\n    if (param_2 == 0x24) {\n      param_2 = uVar13 - 1;\n      bVar1 = false;\n      uVar12 = uVar13;\n    }\n    else {\n      bVar1 = (int)uVar13 < (int)(param_2 + 1U);\n      uVar12 = param_2 + 1U;\n    }\n    if (param_1 == 0x24) {\n      param_1 = uVar13 - 1;\n    }\n    if ((uVar13 <= param_1) || (bVar1)) {\n      puVar6 = (undefined *)0x0;\n    }\n    else {\n      uVar2 = 0;\n      if (-1 < (int)param_1) {\n        uVar2 = param_1;\n      }\n      puVar6 = (undefined *)0x0;\n      if ((int)uVar2 <= (int)uVar12) {\n        if ((int)param_1 < (int)uVar12) {\n          lVar9 = (long)(int)param_1;\n          lVar4 = lVar9;\n          do {\n            sVar5 = strlen((char *)plVar3[lVar4]);\n            uVar12 = (int)puVar6 + 1 + (int)sVar5;\n            puVar6 = (undefined *)(ulong)uVar12;\n            iVar10 = (int)lVar4;\n            lVar4 = lVar4 + 1;\n          } while (iVar10 < param_2);\n          iVar10 = 0;\n          puVar6 = (undefined *)xmalloc((long)(int)(uVar12 + 1));\n          *puVar6 = 0;\n          do {\n            strcpy(puVar6 + iVar10,(char *)plVar3[lVar9]);\n            sVar5 = strlen((char *)plVar3[lVar9]);\n            iVar11 = iVar10 + (int)sVar5;\n            iVar7 = (int)lVar9;\n            iVar10 = iVar11;\n            if (iVar7 < param_2) {\n              iVar10 = iVar11 + 1;\n              puVar6[iVar11] = 0x20;\n              puVar6[iVar10] = 0;\n            }\n            lVar9 = lVar9 + 1;\n          } while (iVar7 < param_2);\n        }\n        else {\n          puVar6 = (undefined *)xmalloc(1);\n          *puVar6 = 0;\n        }\n      }\n    }\n    if (uVar13 != 0) {\n      plVar8 = plVar3;\n      do {\n        lVar4 = *plVar8;\n        plVar8 = plVar8 + 1;\n        xfree(lVar4);\n      } while (plVar3 + (ulong)(uVar13 - 1) + 1 != plVar8);\n    }\n    xfree(plVar3);\n  }\n  return puVar6;\n}\n\n",
  "abort": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort\n     _noreturn_\n               (void)\n\n{\n  (*(code *)PTR_abort_00237870)();\n  return;\n}\n\n",
  "sv_path": "\nvoid sv_path(void)\n\n{\n  phash_flush();\n  return;\n}\n\n",
  "opendir": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nDIR * opendir(char *__name)\n\n{\n  DIR *pDVar1;\n  \n  pDVar1 = (DIR *)(*(code *)PTR_opendir_00237988)();\n  return pDVar1;\n}\n\n",
  "xwcsrtombs": "\n/* WARNING: Restarted to delay deadcode elimination for space: stack */\n\nlong xwcsrtombs(undefined8 *param_1,wchar_t **param_2,ulong param_3,mbstate_t *param_4)\n\n{\n  wchar_t wVar1;\n  size_t sVar2;\n  ulong uVar3;\n  int *piVar4;\n  uint uVar5;\n  ulong uVar6;\n  undefined8 *__s;\n  uint uVar7;\n  long lVar8;\n  wchar_t *pwVar9;\n  long in_FS_OFFSET;\n  undefined8 local_90;\n  undefined4 uStack_88;\n  undefined4 uStack_84;\n  long local_40;\n  \n  lVar8 = -1;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar2 = __ctype_get_mb_cur_max();\n  if (sVar2 < 0x41) {\n    pwVar9 = *param_2;\n    if (param_1 == (undefined8 *)0x0) {\n      local_90 = *param_4;\n      lVar8 = 0;\n      while( true ) {\n        wVar1 = *pwVar9;\n        sVar2 = wcrtomb((char *)&uStack_88,wVar1,(mbstate_t *)&local_90);\n        if (sVar2 == 0xffffffffffffffff) break;\n        if (wVar1 == L'\\0') goto LAB_001c3df0;\n        lVar8 = lVar8 + sVar2;\n        pwVar9 = pwVar9 + 1;\n      }\nLAB_001c3ee7:\n      piVar4 = __errno_location();\n      lVar8 = -1;\n      *piVar4 = 0x54;\n    }\n    else {\n      if (param_3 == 0) {\n        lVar8 = 0;\n      }\n      else {\n        __s = param_1;\n        do {\n          wVar1 = *pwVar9;\n          if (sVar2 <= param_3) {\n            uVar3 = wcrtomb((char *)__s,wVar1,param_4);\n            if (uVar3 == 0xffffffffffffffff) {\n              *(byte *)__s = (byte)wVar1;\n              goto LAB_001c3d82;\n            }\nLAB_001c3d32:\n            if (sVar2 < uVar3) {\nLAB_001c3f00:\n              *param_2 = pwVar9;\n              goto LAB_001c3ee7;\n            }\n            if (uVar3 <= param_3) {\n              if (param_3 < sVar2) goto LAB_001c3da1;\n              goto LAB_001c3d49;\n            }\n            break;\n          }\n          uVar3 = wcrtomb((char *)&uStack_88,wVar1,param_4);\n          if (uVar3 != 0xffffffffffffffff) goto LAB_001c3d32;\n          uStack_88 = CONCAT31(uStack_88._1_3_,(byte)wVar1);\nLAB_001c3d82:\n          if (param_4 != (mbstate_t *)0x0) {\n            param_4->__count = 0;\n            param_4->__value = (_union_27)0x0;\n          }\n          if (sVar2 == 0) goto LAB_001c3f00;\n          uVar3 = 1;\n          if (param_3 < sVar2) {\nLAB_001c3da1:\n            uVar6 = uVar3 & 0xffffffff;\n            if ((uint)uVar3 < 8) {\n              if ((uVar3 & 4) == 0) {\n                if (((int)uVar6 != 0) && (*(byte *)__s = (byte)uStack_88, (uVar3 & 2) != 0)) {\n                  *(undefined2 *)((long)__s + (uVar6 - 2)) =\n                       *(undefined2 *)((long)&local_90 + uVar6 + 6);\n                }\n              }\n              else {\n                *(uint *)__s = uStack_88;\n                *(undefined4 *)((long)__s + (uVar6 - 4)) =\n                     *(undefined4 *)((long)&local_90 + uVar6 + 4);\n              }\n              goto LAB_001c3d49;\n            }\n            *__s = CONCAT44(uStack_84,uStack_88);\n            *(undefined8 *)((long)__s + ((uVar3 & 0xffffffff) - 8)) =\n                 *(undefined8 *)((long)&local_90 + (uVar3 & 0xffffffff));\n            lVar8 = (long)__s - ((ulong)(__s + 1) & 0xfffffffffffffff8);\n            uVar5 = (int)lVar8 + (uint)uVar3 & 0xfffffff8;\n            if (uVar5 < 8) goto LAB_001c3d49;\n            uVar6 = 0;\n            do {\n              uVar7 = (int)uVar6 + 8;\n              *(undefined8 *)(((ulong)(__s + 1) & 0xfffffffffffffff8) + uVar6) =\n                   *(undefined8 *)((long)&uStack_88 + (uVar6 - lVar8));\n              uVar6 = (ulong)uVar7;\n            } while (uVar7 < uVar5);\n          }\n          else {\nLAB_001c3d49:\n          }\n          if (wVar1 == L'\\0') {\n            uStack_88 = (uint)(byte)uStack_88;\n            lVar8 = (long)__s - (long)param_1;\n            pwVar9 = (wchar_t *)0x0;\n            goto LAB_001c3de8;\n          }\n          __s = (undefined8 *)((long)__s + uVar3);\n          pwVar9 = pwVar9 + 1;\n          param_3 = param_3 - uVar3;\n        } while (param_3 != 0);\n        lVar8 = (long)__s - (long)param_1;\n      }\nLAB_001c3de8:\n      *param_2 = pwVar9;\n    }\n  }\nLAB_001c3df0:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar8;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "__fdelt_chk": "\nvoid __fdelt_chk(void)\n\n{\n  (*(code *)PTR___fdelt_chk_00237a20)();\n  return;\n}\n\n",
  "readline_internal_char": "\nundefined8 readline_internal_char(void)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar1 = _rl_last_command_was_kill;\n  DAT_0024a31c = -1;\n  iVar2 = __sigsetjmp(_rl_top_level,0);\n  if (iVar2 != 0) {\n    (*(code *)rl_redisplay_function)();\n    _rl_want_redisplay = 0;\n    if ((rl_readline_state & 0x4000000) != 0) {\n      rl_done = 1;\n      rl_readline_state = rl_readline_state | 0x2000000;\n      return 1;\n    }\n    if ((rl_readline_state & 0x80000) != 0) {\n      _rl_want_redisplay = 0;\n      return 0;\n    }\n  }\n  if (rl_pending_input == 0) {\n    _rl_reset_argument();\n    rl_key_sequence_length = 0;\n    *rl_executing_keyseq = 0;\n  }\n  rl_readline_state = rl_readline_state | 8;\n  iVar2 = rl_read_key();\n  rl_readline_state = rl_readline_state & 0xfffffffffffffff7;\n  if (iVar2 == -2) {\n    rl_done = 1;\n    rl_readline_state = rl_readline_state | 0x2000000;\n    return 1;\n  }\n  if (iVar2 == -1) {\n    if (rl_end == 0) {\nLAB_001cec46:\n      if (_rl_eof_char != -1) goto LAB_001cec08;\n      iVar2 = -1;\n    }\n    else {\n      if (_rl_caught_signal != 0) {\n        if (_rl_caught_signal != 0) {\n          _rl_signal_handler(_rl_caught_signal);\n        }\n        if (rl_signal_event_hook != (code *)0x0) {\n          (*rl_signal_event_hook)();\n        }\n      }\n      iVar2 = _rl_eof_char;\n      if ((rl_readline_state & 4) == 0) {\n        if (_rl_eof_char != 10) {\n          iVar2 = 10;\n          goto LAB_001cea0a;\n        }\n        if (DAT_0024a31c == 10) goto LAB_001cea0a;\n      }\n      else if ((DAT_0024a31c == -1) || (DAT_0024a31c == _rl_eof_char)) {\n        rl_end = 0;\n        goto LAB_001cec46;\n      }\n    }\n  }\n  else if ((iVar2 != _rl_eof_char) || (iVar2 == DAT_0024a31c)) goto LAB_001cea0a;\n  if (rl_end != 0) {\nLAB_001cea0a:\n    _rl_dispatching_keymap = _rl_keymap;\n    DAT_0024a31c = iVar2;\n    _rl_dispatch_subseq((char)iVar2,_rl_keymap,0);\n    if (_rl_caught_signal != 0) {\n      _rl_signal_handler(_rl_caught_signal);\n    }\n    if (_rl_command_to_execute != (undefined8 *)0x0) {\n      (*(code *)rl_redisplay_function)();\n      rl_executing_keymap = *_rl_command_to_execute;\n      rl_executing_key = *(undefined4 *)((long)_rl_command_to_execute + 0xc);\n      rl_dispatching = 1;\n      rl_readline_state = rl_readline_state | 0x20;\n      _rl_executing_func = (code *)_rl_command_to_execute[2];\n      (*_rl_executing_func)(*(undefined4 *)(_rl_command_to_execute + 1));\n      rl_readline_state = rl_readline_state & 0xffffffffffffffdf;\n      _rl_command_to_execute = (undefined8 *)0x0;\n      rl_dispatching = 0;\n      if (_rl_caught_signal != 0) {\n        _rl_signal_handler(_rl_caught_signal);\n      }\n    }\n    if ((rl_pending_input == 0) && (_rl_last_command_was_kill == iVar1)) {\n      _rl_last_command_was_kill = 0;\n    }\n    _rl_internal_char_cleanup();\n    return 0;\n  }\nLAB_001cec08:\n  rl_readline_state = rl_readline_state | 0x2000000;\n  rl_done = 1;\n  return 1;\n}\n\n",
  "timeval_to_cpu": "\nlong timeval_to_cpu(long *param_1,long *param_2,long *param_3)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  int iVar5;\n  \n  lVar1 = param_3[1] + param_2[1];\n  lVar3 = *param_3 + *param_2;\n  if (999999 < lVar1) {\n    lVar1 = lVar1 + -1000000;\n    lVar3 = lVar3 + 1;\n  }\n  lVar4 = *param_1;\n  lVar2 = param_1[1];\n  iVar5 = 6;\n  do {\n    if ((99999999 < lVar4) || (99999999 < lVar3)) break;\n    lVar3 = lVar1 / 100000 + lVar3 * 10;\n    lVar1 = (lVar1 * 10) % 1000000;\n    lVar4 = lVar2 / 100000 + lVar4 * 10;\n    lVar2 = (lVar2 * 10) % 1000000;\n    iVar5 = iVar5 + -1;\n  } while (iVar5 != 0);\n  iVar5 = 4;\n  do {\n    if (lVar3 < 100000000) {\n      lVar3 = lVar3 * 10;\n    }\n    else {\n      lVar4 = lVar4 / 10;\n    }\n    iVar5 = iVar5 + -1;\n  } while (iVar5 != 0);\n  lVar1 = 0;\n  if (lVar4 != 0) {\n    lVar1 = lVar3 / lVar4;\n  }\n  return lVar1;\n}\n\n",
  "read_secondary_line": "\nlong read_secondary_line(int param_1)\n\n{\n  bool bVar1;\n  int iVar2;\n  long lVar3;\n  int iVar4;\n  int iVar5;\n  \n  prompt_string_pointer = &ps2_prompt;\n  if ((interactive != 0) && (bash_input - 1U < 2)) {\n    if ((pushed_string_list == 0) || (*(long *)(pushed_string_list + 0x18) == 0)) {\n      FUN_001373e0();\n      if (((no_line_editing == 0) || (interactive == 0)) || (1 < bash_input - 1U))\n      goto LAB_00137541;\n    }\n    else if (no_line_editing == 0) goto LAB_00137541;\n    fputs(DAT_00240d78,stderr);\n    fflush(stderr);\n  }\nLAB_00137541:\n  bVar1 = false;\n  iVar5 = 0;\njoined_r0x00137558:\n  do {\n    do {\n      if (terminating_signal != 0) {\n        termsig_handler(terminating_signal);\n      }\n      if (interrupt_state != 0) {\n        throw_to_top_level();\n      }\n      iVar2 = (*DAT_00240a78)();\n    } while (iVar2 == 0);\n    if (iVar2 == -1) {\n      if ((interactive != 0) && (bash_input == 2)) {\n        clearerr(stdin);\n      }\n      if (iVar5 == 0) {\n        return 0;\n      }\n      iVar2 = 10;\n    }\n    if (DAT_00240af8 <= iVar5 + 2) {\n      DAT_00240af8 = DAT_00240af8 + 0x80 + ((iVar5 - DAT_00240af8) + 2U & 0xffffff80);\n      DAT_00240af0 = sh_xrealloc(DAT_00240af0,(long)DAT_00240af8,\n                                 \"/usr/local/src/chet/src/bash/src/parse.y\",0x837);\n    }\n    lVar3 = DAT_00240af0;\n    if (bVar1) {\n      iVar4 = iVar5 + 1;\n      *(char *)(DAT_00240af0 + iVar5) = (char)iVar2;\n    }\n    else {\n      if ((iVar2 == 0x5c) && (param_1 != 0)) {\n        if (terminating_signal != 0) {\n          termsig_handler(terminating_signal);\n        }\n        if (interrupt_state == 0) {\n          iVar2 = (*DAT_00240a78)();\n        }\n        else {\n          throw_to_top_level();\n          iVar2 = (*DAT_00240a78)();\n        }\n        if (iVar2 == 10) {\n          line_number = line_number + 1;\n        }\n        else {\n          (*DAT_00240a80)(iVar2);\n          lVar3 = (long)iVar5;\n          bVar1 = true;\n          iVar5 = iVar5 + 1;\n          *(undefined *)(DAT_00240af0 + lVar3) = 0x5c;\n        }\n        goto joined_r0x00137558;\n      }\n      iVar4 = iVar5 + 1;\n      if ((param_1 != 0) && ((iVar2 == 1 || (iVar2 == 0x7f)))) {\n        *(undefined *)(DAT_00240af0 + iVar5) = 1;\n        iVar5 = iVar4;\n        iVar4 = iVar5 + 2;\n      }\n      *(char *)(lVar3 + iVar5) = (char)iVar2;\n    }\n    if (iVar2 == 10) {\n      *(undefined *)(lVar3 + iVar4) = 0;\n      if (lVar3 == 0) {\n        return 0;\n      }\n      if ((remember_on_history != 0) && ((parser_state._2_1_ & 2) != 0)) {\n        current_command_line_count = current_command_line_count + 1;\n        maybe_add_history(lVar3);\n        return lVar3;\n      }\n      return lVar3;\n    }\n    bVar1 = false;\n    iVar5 = iVar4;\n  } while( true );\n}\n\n",
  "FUN_00193490": "\nundefined8 FUN_00193490(void)\n\n{\n  if (DAT_00248868 != 0) {\n    rl_insert_text();\n    sh_xfree(DAT_00248868,\"bashline.c\",0x2c2);\n    DAT_00248868 = 0;\n    rl_startup_hook = DAT_00248878;\n    return 0;\n  }\n  return 0;\n}\n\n",
  "FUN_001b6ec0": "\nundefined8 FUN_001b6ec0(void)\n\n{\n  function_trace_mode = debugging_mode;\n  error_trace_mode = debugging_mode;\n  set_shellopts();\n  if (debugging_mode == 0) {\n    return 0;\n  }\n  init_bash_argv();\n  return 0;\n}\n\n",
  "FUN_001a1750": "\nvoid FUN_001a1750(undefined8 param_1,undefined8 param_2)\n\n{\n  void *pvVar1;\n  void *pvVar2;\n  \n  if (DAT_00248a48 == 0) {\n    DAT_00248a50 = sbrk(0);\n    DAT_00248a48 = 1;\n  }\n  pvVar1 = DAT_00248a50;\n  pvVar2 = sbrk(0);\n  fatal_error(\"%s: cannot allocate %lu bytes (%lu bytes allocated)\",param_1,param_2,\n              (long)pvVar2 - (long)pvVar1);\n  return;\n}\n\n",
  "__printf_chk": "\nvoid __printf_chk(void)\n\n{\n  (*(code *)PTR___printf_chk_00237cc8)();\n  return;\n}\n\n",
  "sh_getopt_restore_state": "\nvoid sh_getopt_restore_state(long param_1)\n\n{\n  if (DAT_00248dd8 != 0) {\n    DAT_00248dd8 = (long)DAT_00248dd0 + *(long *)(param_1 + (long)DAT_00248de0 * 8);\n  }\n  return;\n}\n\n",
  "calloc": "\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *__s;\n  \n  __s = (void *)FUN_001f85f0(__nmemb * __size,0,0);\n  if (__s != (void *)0x0) {\n    __s = memset(__s,0,__nmemb * __size);\n  }\n  return __s;\n}\n\n",
  "FUN_00161c20": "\n/* WARNING: Type propagation algorithm not settling */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint FUN_00161c20(int param_1)\n\n{\n  uint uVar1;\n  char cVar2;\n  bool bVar3;\n  bool bVar4;\n  undefined4 uVar5;\n  __pid_t _Var6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  undefined8 *puVar10;\n  long lVar11;\n  int *piVar12;\n  long lVar13;\n  code *pcVar14;\n  long lVar15;\n  uint uVar16;\n  bool bVar17;\n  byte bVar18;\n  long in_FS_OFFSET;\n  int local_58;\n  int local_54;\n  int local_50;\n  uint local_48;\n  int local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_58 = 0;\n  local_54 = -1;\n  local_50 = 0;\n  bVar18 = ((byte)param_1 ^ 1) & 1;\nLAB_00161c70:\n  do {\n    uVar16 = job_control;\n    if ((job_control != 0) && (uVar16 = 0, subshell_environment == 0)) {\n      uVar16 = DAT_00238724 | 2;\n    }\n    if ((DAT_00247694 != 0) || (bVar18 != 0)) {\n      uVar16 = uVar16 | 1;\n    }\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    if ((((wait_intr_flag != 0) && (wait_signal_received != 0)) &&\n        (this_shell_builtin == (code *)PTR_wait_builtin_00237f70)) &&\n       (this_shell_builtin != (code *)0x0)) goto LAB_00162080;\n    if ((param_1 == 1) && ((uVar16 & 1 | DAT_00247690) == 0)) {\n      uVar16 = uVar16 | 1;\n      internal_warning(\"waitchld: turning on WNOHANG to avoid indefinite block\");\n    }\n    _Var6 = waitpid(-1,(int *)&local_48,uVar16);\n    iVar7 = DAT_00247694;\n    if (DAT_00238724 == 0) {\n      if ((0 < DAT_00247694) && ((uVar16 & 1) != 0)) goto LAB_00161d25;\njoined_r0x00161fb5:\n      if (_Var6 < 0) {\n        piVar12 = __errno_location();\n        iVar8 = *piVar12;\nLAB_00161fc2:\n        if (iVar8 == 10) {\n          if (local_58 == 0) {\n            local_58 = -1;\n            goto LAB_00161f6f;\n          }\n          if (local_50 == 0) goto LAB_00162001;\n          goto LAB_00161fe1;\n        }\n      }\n    }\n    else {\n      if (_Var6 < 0) {\n        piVar12 = __errno_location();\n        iVar8 = *piVar12;\n        if (iVar8 != 0x16) {\n          if ((0 < iVar7) && ((uVar16 & 1) != 0)) goto LAB_00161d25;\n          goto LAB_00161fc2;\n        }\n        DAT_00238724 = 0;\n        goto joined_r0x00162341;\n      }\n      if ((0 < DAT_00247694) && ((uVar16 & 1) != 0)) {\nLAB_00161d25:\n        DAT_00247694 = iVar7 + -1;\n        goto joined_r0x00161fb5;\n      }\n    }\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    if ((((wait_intr_flag != 0) && (wait_signal_received != 0)) &&\n        (this_shell_builtin == (code *)PTR_wait_builtin_00237f70)) &&\n       (this_shell_builtin != (code *)0x0)) goto LAB_00162080;\n    if (_Var6 < 0) {\n      piVar12 = __errno_location();\n      if ((*piVar12 == 4) && (DAT_002475c4 != 0)) {\n        DAT_002475c0 = 1;\n      }\nLAB_001620a6:\n      if ((DAT_00247694 != 0) || ((bVar18 == 0 || (_Var6 < 1)))) goto joined_r0x00162341;\n      goto LAB_00161c70;\n    }\n    if (_Var6 == 0) goto LAB_001620a6;\n    cVar2 = (char)(((byte)local_48 & 0x7f) + 1) >> 1;\n    if (DAT_002475c4 == 0) {\nLAB_00161dc3:\n      if (('\\0' < cVar2) && ((local_48 & 0x7f) == 2)) goto LAB_001622a0;\n    }\n    else {\n      if ((cVar2 < '\\x01') || ((local_48 & 0x7f) != 2)) {\n        DAT_002475c0 = 1;\n        goto LAB_00161dc3;\n      }\nLAB_001622a0:\n      DAT_002475c0 = 0;\n    }\n    if (local_48 != 0xffff) {\n      local_58 = local_58 + 1;\n      _DAT_00238768 = _DAT_00238768 + -1;\n    }\n    puVar10 = (undefined8 *)FUN_00160ba0(_Var6,1,&local_44);\njoined_r0x00161dff:\n    iVar7 = local_54;\n    if (puVar10 != (undefined8 *)0x0) {\n      if (_Var6 != *(int *)(puVar10 + 1)) break;\n      coproc_pidchk(_Var6,local_48);\n      iVar8 = find_procsub_child();\n      if (-1 < iVar8) {\n        set_procsub_status(iVar8,_Var6,local_48);\n      }\n      iVar8 = local_44;\n      *(uint *)((long)puVar10 + 0xc) = local_48;\n      *(uint *)(puVar10 + 2) = (uint)(local_48 == 0xffff);\n      lVar15 = jobs;\n      uVar16 = job_control;\n      if (local_48 == 0xffff) {\n        if (local_44 == -1) goto joined_r0x00162182;\n      }\n      else {\n        _DAT_00238778 = _DAT_00238778 + 1;\n        if (local_44 == -1) goto joined_r0x00162182;\n        _DAT_0023876c = _DAT_0023876c + 1;\n      }\n      lVar11 = (long)local_44;\n      bVar4 = false;\n      bVar17 = false;\n      bVar3 = false;\n      lVar13 = *(long *)(jobs + lVar11 * 8);\n      uVar1 = *(uint *)(lVar13 + 0x18);\n      *(uint *)(lVar13 + 0x18) = uVar1 & 0xfffffffd;\n      puVar10 = *(undefined8 **)(lVar13 + 8);\n      do {\n        bVar3 = (bool)(bVar3 | *(int *)(puVar10 + 2) == 1);\n        if ((char)*(uint *)((long)puVar10 + 0xc) == '\\x7f') {\n          if ((uVar16 != 0) && ((*(uint *)((long)puVar10 + 0xc) >> 8 & 0xff) == 0x14)) {\n            bVar4 = true;\n          }\n          puVar10 = (undefined8 *)*puVar10;\n          bVar17 = true;\n        }\n        else {\n          puVar10 = (undefined8 *)*puVar10;\n        }\n      } while (*(undefined8 **)(lVar13 + 8) != puVar10);\n      if (bVar3) {\n        iVar9 = *(int *)(lVar13 + 0x14);\n        if (iVar9 == 2) {\n          if (bVar17) goto LAB_00162259;\n          local_50 = local_50 + 1;\n          *(undefined4 *)(lVar13 + 0x14) = 1;\n          goto joined_r0x00162182;\n        }\nLAB_00162220:\n        iVar7 = local_54;\n        if ((local_54 == iVar8) && (iVar7 = -1, iVar9 != 4)) {\n          iVar7 = local_54;\n        }\n      }\n      else if (bVar17) {\nLAB_00162259:\n        *(undefined4 *)(lVar13 + 0x14) = 2;\n        *(uint *)(lVar13 + 0x18) = uVar1 & 0xfffffffc;\n        if ((bVar4) && (loop_level != 0)) {\n          local_50 = local_50 + 1;\n          breaking = loop_level;\n          iVar7 = iVar8;\n        }\n        else {\n          local_50 = local_50 + 1;\n          iVar7 = iVar8;\n        }\n      }\n      else {\n        *(undefined4 *)(lVar13 + 0x14) = 4;\n        _DAT_0023878c = _DAT_0023878c + 1;\n        if (*(code **)(lVar13 + 0x28) == (code *)0x0) {\nLAB_001621fd:\n          if (DAT_002475c4 == 0) {\n            iVar9 = *(int *)(*(long *)(lVar15 + lVar11 * 8) + 0x14);\n          }\n          else if (interactive_shell == 0) {\n            if (DAT_002475c0 == 0) {\n              lVar15 = *(long *)(lVar15 + lVar11 * 8);\n              if ((*(uint *)(lVar15 + 0x18) & 5) == 1) goto LAB_001623a2;\n            }\n            else {\n              if ((*(byte *)(lVar13 + 0x18) & 1) != 0) {\n                iVar7 = signal_is_trapped(2);\n                uVar5 = DAT_00247660;\n                if (iVar7 != 0) {\n                  DAT_002475c4 = 0;\n                  uVar16 = *(uint *)((long)puVar10 + 0xc);\n                  if ((char)(((byte)uVar16 & 0x7f) + 1) < '\\x02') {\n                    last_command_exit_value = 0;\n                    if ((byte)uVar16 != 0x7f) {\n                      last_command_exit_value = uVar16 >> 8 & 0xff;\n                    }\n                  }\n                  else {\n                    last_command_exit_value = (uVar16 & 0x7f) + 0x80;\n                  }\n                  DAT_00247660 = 1;\n                  maybe_call_trap_handler(2);\n                  iVar9 = *(int *)(*(long *)(jobs + lVar11 * 8) + 0x14);\n                  DAT_00247660 = uVar5;\n                  goto LAB_00162217;\n                }\n                lVar13 = *(long *)(jobs + lVar11 * 8);\n                lVar15 = jobs;\n                if (DAT_002475c4 != 0) goto LAB_0016238a;\n                goto LAB_0016246d;\n              }\n              lVar15 = *(long *)(lVar15 + lVar11 * 8);\n            }\nLAB_00162327:\n            iVar9 = *(int *)(lVar15 + 0x14);\n          }\n          else {\nLAB_0016238a:\n            lVar15 = *(long *)(lVar15 + lVar11 * 8);\n            if ((DAT_002475c0 != 0) || ((*(uint *)(lVar15 + 0x18) & 5) != 1)) goto LAB_00162327;\nLAB_001623a2:\n            DAT_002475c4 = 0;\n            iVar7 = signal_is_trapped(2);\n            uVar5 = DAT_00247660;\n            if (iVar7 != 0) {\n              uVar16 = *(uint *)((long)puVar10 + 0xc);\n              if ((char)(((byte)uVar16 & 0x7f) + 1) < '\\x02') {\n                last_command_exit_value = 0;\n                if ((byte)uVar16 != 0x7f) {\n                  last_command_exit_value = uVar16 >> 8 & 0xff;\n                }\n              }\n              else {\n                last_command_exit_value = (uVar16 & 0x7f) + 0x80;\n              }\n            }\n            DAT_00247660 = 1;\n            iVar7 = maybe_call_trap_handler(2);\n            pcVar14 = (code *)PTR_wait_for_background_pids_002387a8;\n            DAT_00247660 = uVar5;\n            if ((iVar7 == 0) &&\n               ((code *)PTR_wait_for_background_pids_002387a8 != wait_for_background_pids)) {\n              if (PTR_wait_for_background_pids_002387a8 == PTR_trap_handler_00237fd8) {\n                iVar7 = signal_is_trapped(2,PTR_wait_for_background_pids_002387a8);\n                if (iVar7 == 0) {\n                  pcVar14 = (code *)trap_to_sighandler(2);\n                  if ((code *)PTR_wait_for_background_pids_002387a8 != wait_for_background_pids)\n                  goto LAB_00162425;\n                  goto LAB_00162447;\n                }\n                if ((code *)PTR_wait_for_background_pids_002387a8 != wait_for_background_pids)\n                goto LAB_00162425;\n              }\n              else {\nLAB_00162425:\n                set_signal_handler(2);\n                waiting_for_child = 0;\n                PTR_wait_for_background_pids_002387a8 = wait_for_background_pids;\nLAB_00162447:\n                if (pcVar14 == (code *)0x0) {\n                  termsig_handler(2);\n                  iVar9 = *(int *)(*(long *)(jobs + lVar11 * 8) + 0x14);\n                  goto LAB_00162217;\n                }\n              }\n              if (pcVar14 != (code *)0x1) {\n                (*pcVar14)(2);\n              }\n            }\n            lVar13 = *(long *)(jobs + lVar11 * 8);\nLAB_0016246d:\n            iVar9 = *(int *)(lVar13 + 0x14);\n          }\n        }\n        else {\n          (**(code **)(lVar13 + 0x28))(*(undefined8 *)(lVar13 + 0x30));\n          lVar15 = jobs;\n          lVar13 = *(long *)(jobs + lVar11 * 8);\n          iVar9 = *(int *)(lVar13 + 0x14);\n          *(undefined8 *)(lVar13 + 0x28) = 0;\n          if (iVar9 == 4) goto LAB_001621fd;\n        }\nLAB_00162217:\n        iVar7 = iVar8;\n        if (iVar9 != 2) goto LAB_00162220;\n      }\n      goto joined_r0x00162182;\n    }\n    coproc_pidchk(_Var6,local_48);\n    iVar8 = find_procsub_child(_Var6);\n    if (-1 < iVar8) {\n      set_procsub_status(iVar8,_Var6,local_48);\n    }\n    if (((local_48 & 0x7f) == 0) || ('\\x01' < (char)((char)(local_48 & 0x7f) + '\\x01'))) {\n      _DAT_0023876c = _DAT_0023876c + 1;\n    }\njoined_r0x00162182:\n    local_54 = iVar7;\n    if ((DAT_00247694 == 0) && (bVar18 == 0)) {\njoined_r0x00162341:\n      if (local_50 != 0) {\nLAB_00161fe1:\n        if (local_54 == -1) {\n          FUN_0015e940();\n        }\n        else {\n          FUN_0015e860();\n        }\n      }\n      if (local_58 != 0) {\nLAB_00162001:\n        iVar7 = signal_is_trapped(0x11);\n        if (((iVar7 != 0) || (DAT_00247a88 == (code *)PTR_initialize_traps_00237fc0)) &&\n           (DAT_00247a88 != (code *)0x1)) {\n          if (((posixly_correct == 0) || (this_shell_builtin == (code *)0x0)) ||\n             (this_shell_builtin != (code *)PTR_wait_builtin_00237f70)) {\n            if (((DAT_00247694 == 0) && (iVar7 = signal_in_progress(0x11), iVar7 == 0)) &&\n               ((DAT_00247a88 != initialize_traps && (running_trap == 0)))) {\n              if (this_shell_builtin == wait_builtin) {\n                run_sigchld_trap(local_58);\n              }\n              else {\n                queue_sigchld_trap();\n              }\n            }\n            else {\n              queue_sigchld_trap(local_58);\n            }\n          }\n          else {\n            queue_sigchld_trap(local_58);\n            wait_signal_received = 0x11;\n            if ((DAT_00247694 == 0) && (wait_intr_flag != 0)) {\nLAB_00162080:\n                    /* WARNING: Subroutine does not return */\n              __longjmp_chk(wait_intr_buf,1);\n            }\n          }\n        }\n      }\n      if ((((asynchronous_notification != 0) && (interactive != 0)) && (executing_builtin == 0)) &&\n         ((jobs != 0 && (DAT_0023877c != 0)))) {\n        FUN_0015fd20();\n      }\nLAB_00161f6f:\n      if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return local_58;\n    }\n  } while( true );\n  puVar10 = (undefined8 *)*puVar10;\n  goto joined_r0x00161dff;\n}\n\n",
  "FUN_00152500": "\nlong FUN_00152500(long param_1)\n\n{\n  __pid_t _Var1;\n  undefined8 uVar2;\n  \n  _Var1 = getpid();\n  uVar2 = itos((long)_Var1);\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x527);\n  }\n  *(undefined8 *)(param_1 + 8) = uVar2;\n  *(uint *)(param_1 + 0x28) = *(uint *)(param_1 + 0x28) | 0x10;\n  return param_1;\n}\n\n",
  "rl_vi_check": "\nundefined8 rl_vi_check(void)\n\n{\n  size_t sVar1;\n  \n  if ((rl_point != 0) && (rl_point == rl_end)) {\n    sVar1 = __ctype_get_mb_cur_max();\n    if ((sVar1 < 2) || (rl_byte_oriented != 0)) {\n      rl_point = rl_point + -1;\n    }\n    else {\n      rl_point = _rl_find_prev_mbchar(rl_line_buffer,rl_point,1);\n    }\n    return 0;\n  }\n  return 0;\n}\n\n",
  "_rl_arg_init": "\nvoid _rl_arg_init(void)\n\n{\n  rl_save_prompt();\n  rl_readline_state = rl_readline_state | 0x400;\n  _rl_argcxt = 0;\n  return;\n}\n\n",
  "err_badarraysub": "\nvoid err_badarraysub(undefined8 param_1)\n\n{\n  report_error(\"%s: %s\",param_1,bash_badsub_errmsg);\n  return;\n}\n\n",
  "FUN_00194f90": "\nvoid FUN_00194f90(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  uVar3 = rl_completion_entry_function;\n  uVar2 = rl_attempted_completion_function;\n  uVar1 = rl_ignore_some_completions_function;\n  rl_completion_entry_function = rl_username_completion_function;\n  rl_attempted_completion_function = 0;\n  rl_complete_internal(0x3f);\n  rl_completion_entry_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar2;\n  rl_ignore_some_completions_function = uVar1;\n  return;\n}\n\n",
  "do_word_assignment": "\nvoid do_word_assignment(undefined8 param_1)\n\n{\n  FUN_00173b20(param_1,1);\n  return;\n}\n\n",
  "shell_glob_filename": "\nlong * shell_glob_filename(undefined8 param_1,uint param_2)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  long *plVar3;\n  \n  noglob_dot_filenames = (uint)(glob_dot_filenames == 0);\n  uVar2 = quote_string_for_globbing(param_1,param_2 | 2);\n  plVar3 = (long *)glob_filename(uVar2,(ulong)(glob_star != 0) << 10);\n  sh_xfree(uVar2,\"pathexp.c\",0x1a3);\n  if ((plVar3 != (long *)0x0) && (plVar3 != &glob_error_return)) {\n    if (DAT_00238b30 == 0) {\n      lVar1 = *plVar3;\n    }\n    else {\n      ignore_glob_matches(plVar3);\n      lVar1 = *plVar3;\n    }\n    if (lVar1 == 0) {\n      sh_xfree(plVar3,\"pathexp.c\",0x1ad);\n      return &glob_error_return;\n    }\n    strvec_sort(plVar3,1);\n  }\n  return plVar3;\n}\n\n",
  "FUN_001f14b0": "\nundefined8 FUN_001f14b0(void)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  if (-1 < DAT_00240558) {\n    iVar1 = DAT_00240558 - history_base;\n    iVar2 = where_history();\n    rl_get_previous_history(iVar2 - iVar1,0);\n  }\n  DAT_00240558 = 0xffffffff;\n  _rl_internal_startup_hook = DAT_0024b6c8;\n  return 0;\n}\n\n",
  "kill_pid": "\nint kill_pid(__pid_t param_1,int param_2,int param_3)\n\n{\n  long lVar1;\n  long *plVar2;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  long lVar6;\n  long *plVar7;\n  long lVar8;\n  undefined8 *puVar9;\n  bool bVar10;\n  long in_FS_OFFSET;\n  int local_14c;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 < -1) {\n    param_1 = -param_1;\n    bVar10 = true;\n  }\n  else {\n    if (param_3 == 0) {\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        iVar3 = kill(param_1,param_2);\n        return iVar3;\n      }\n      goto LAB_001619e7;\n    }\n    bVar10 = false;\n  }\n  sigemptyset(&local_148);\n  sigaddset(&local_148,0x11);\n  sigemptyset(&local_c8);\n  sigprocmask(0,&local_148,&local_c8);\n  lVar5 = FUN_00160ba0(param_1,0,&local_14c);\n  lVar6 = jobs;\n  iVar3 = shell_pgrp;\n  if (local_14c == -1) {\nLAB_001619d8:\n    iVar3 = killpg(param_1,param_2);\n  }\n  else {\n    lVar8 = (long)local_14c;\n    lVar1 = *(long *)(jobs + lVar8 * 8);\n    *(uint *)(lVar1 + 0x18) = *(uint *)(lVar1 + 0x18) & 0xfffffffd;\n    iVar4 = *(int *)(lVar1 + 0x10);\n    if (bVar10) {\n      if (iVar4 == iVar3) goto LAB_001619d8;\n    }\n    else if (iVar4 == iVar3) {\n      puVar9 = *(undefined8 **)(lVar1 + 8);\n      do {\n        if ((*(int *)(puVar9 + 2) == 1) || (*(char *)((long)puVar9 + 0xc) == '\\x7f')) {\n          kill(*(__pid_t *)(puVar9 + 1),param_2);\n          if ((*(int *)(puVar9 + 2) == 0) && ((param_2 == 0xf || (param_2 == 1)))) {\n            kill(*(__pid_t *)(puVar9 + 1),0x12);\n          }\n          puVar9 = (undefined8 *)*puVar9;\n          lVar6 = jobs;\n        }\n      } while (*(undefined8 **)(*(long *)(lVar6 + lVar8 * 8) + 8) != puVar9);\n      iVar3 = 0;\n      goto LAB_00161978;\n    }\n    iVar3 = killpg(iVar4,param_2);\n    if (lVar5 != 0) {\n      lVar6 = *(long *)(jobs + lVar8 * 8);\n      if (*(int *)(lVar6 + 0x14) == 2) {\n        if ((param_2 == 0xf) || (iVar4 = 2, param_2 == 1)) {\n          killpg(*(__pid_t *)(lVar6 + 0x10),0x12);\n          lVar6 = *(long *)(jobs + lVar8 * 8);\n          iVar4 = *(int *)(lVar6 + 0x14);\n        }\n        if ((param_2 == 0x12) && (iVar4 == 2)) {\n          plVar2 = *(long **)(lVar6 + 8);\n          plVar7 = plVar2;\n          do {\n            if (*(char *)((long)plVar7 + 0xc) == '\\x7f') {\n              *(undefined4 *)(plVar7 + 2) = 1;\n            }\n            plVar7 = (long *)*plVar7;\n          } while (plVar2 != plVar7);\n          *(undefined4 *)(lVar6 + 0x14) = 1;\n          *(uint *)(lVar6 + 0x18) = *(uint *)(lVar6 + 0x18) & 0xfffffffe | 2;\n        }\n      }\n    }\n  }\nLAB_00161978:\n  sigprocmask(2,&local_c8,(sigset_t *)0x0);\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar3;\n  }\nLAB_001619e7:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "history_search": "\nvoid history_search(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_001f6220(param_1,param_2,0);\n  return;\n}\n\n",
  "__vfprintf_chk": "\nvoid __vfprintf_chk(void)\n\n{\n  (*(code *)PTR___vfprintf_chk_00237868)();\n  return;\n}\n\n",
  "getpwnam": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\npasswd * getpwnam(char *__name)\n\n{\n  passwd *ppVar1;\n  \n  ppVar1 = (passwd *)(*(code *)PTR_getpwnam_00237b18)();\n  return ppVar1;\n}\n\n",
  "hash_insert": "\nvoid hash_insert(char *param_1,long *param_2,ulong param_3)\n\n{\n  undefined8 *puVar1;\n  char cVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  uint uVar5;\n  char *pcVar6;\n  int iVar7;\n  \n  if (param_2 == (long *)0x0) {\n    param_2 = (long *)hash_create(0);\n  }\n  if (((param_3 & 1) == 0) && (lVar4 = hash_search(param_1,param_2,0), lVar4 != 0)) {\n    return;\n  }\n  iVar7 = *(int *)(param_2 + 1);\n  if ((iVar7 * 2 <= *(int *)((long)param_2 + 0xc)) && (0 < iVar7 * 4)) {\n    FUN_0017fb90(param_2);\n    iVar7 = *(int *)(param_2 + 1);\n  }\n  cVar2 = *param_1;\n  if (cVar2 == '\\0') {\n    uVar5 = 0x811c9dc5;\n  }\n  else {\n    uVar5 = 0x811c9dc5;\n    pcVar6 = param_1;\n    do {\n      pcVar6 = pcVar6 + 1;\n      uVar5 = (int)cVar2 ^ uVar5 * 0x1000193;\n      cVar2 = *pcVar6;\n    } while (cVar2 != '\\0');\n  }\n  puVar3 = (undefined8 *)sh_xmalloc(0x20,\"hashlib.c\",0x164);\n  puVar1 = (undefined8 *)(*param_2 + (long)(int)(iVar7 - 1U & uVar5) * 8);\n  *puVar3 = *puVar1;\n  *puVar1 = puVar3;\n  puVar3[2] = 0;\n  puVar3[1] = param_1;\n  *(uint *)(puVar3 + 3) = uVar5;\n  *(undefined4 *)((long)puVar3 + 0x1c) = 0;\n  *(int *)((long)param_2 + 0xc) = *(int *)((long)param_2 + 0xc) + 1;\n  return;\n}\n\n",
  "compspec_create": "\nvoid compspec_create(void)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x58,\"pcomplib.c\",0x35);\n  *puVar1 = 0;\n  *(undefined8 *)(puVar1 + 2) = 0;\n  *(undefined8 *)(puVar1 + 4) = 0;\n  *(undefined8 *)(puVar1 + 6) = 0;\n  *(undefined8 *)(puVar1 + 8) = 0;\n  *(undefined8 *)(puVar1 + 10) = 0;\n  *(undefined8 *)(puVar1 + 0xc) = 0;\n  *(undefined8 *)(puVar1 + 0xe) = 0;\n  *(undefined8 *)(puVar1 + 0x10) = 0;\n  *(undefined8 *)(puVar1 + 0x12) = 0;\n  *(undefined8 *)(puVar1 + 0x14) = 0;\n  return;\n}\n\n",
  "rl_set_keymap_from_edit_mode": "\nvoid rl_set_keymap_from_edit_mode(void)\n\n{\n  if (rl_editing_mode != 1) {\n    if (rl_editing_mode == 0) {\n      _rl_keymap = &vi_insertion_keymap;\n    }\n    return;\n  }\n  _rl_keymap = emacs_standard_keymap;\n  return;\n}\n\n",
  "ignore_tty_job_signals": "\nvoid ignore_tty_job_signals(void)\n\n{\n  set_signal_handler(0x14,1);\n  set_signal_handler(0x15,1);\n  set_signal_handler(0x16,1);\n  return;\n}\n\n",
  "reset_shell_flags": "\nvoid reset_shell_flags(void)\n\n{\n  disallow_filename_globbing = 0;\n  mark_modified_vars = 0;\n  just_one_command = 0;\n  read_but_dont_execute = 0;\n  place_keywords_in_env = 0;\n  unbound_vars_is_error = 0;\n  noclobber = 0;\n  forced_interactive = 0;\n  jobs_m_flag = 0;\n  echo_command_at_execute = 0;\n  no_symbolic_links = 0;\n  pipefail_opt = 0;\n  privileged_mode = 0;\n  function_trace_mode = 0;\n  error_trace_mode = 0;\n  errexit_flag = 0;\n  exit_immediately_on_error = 0;\n  verbose_flag = 0;\n  echo_input_at_read = 0;\n  interactive_comments = 1;\n  hashing_enabled = 1;\n  asynchronous_notification = 0;\n  histexp_flag = 0;\n  brace_expansion = 1;\n  restricted = 0;\n  return;\n}\n\n",
  "lstat": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint lstat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_lstat_00237ac0)();\n  return iVar1;\n}\n\n",
  "rl_vi_back_to_indent": "\nundefined8 rl_vi_back_to_indent(void)\n\n{\n  char cVar1;\n  long lVar2;\n  long lVar3;\n  uint uVar4;\n  \n  rl_beg_of_line(1);\n  lVar3 = (long)rl_point;\n  if (rl_point < rl_end) {\n    uVar4 = (rl_end + -1) - rl_point;\n    lVar2 = (long)(rl_point + 1);\n    do {\n      cVar1 = *(char *)(rl_line_buffer + -1 + lVar2);\n      if ((cVar1 != ' ') && (cVar1 != '\\t')) {\n        return 0;\n      }\n      rl_point = (int)lVar2;\n      lVar2 = lVar2 + 1;\n    } while (lVar2 != (ulong)uVar4 + 2 + lVar3);\n  }\n  return 0;\n}\n\n",
  "rl_possible_completions": "\nvoid rl_possible_completions(undefined8 param_1,undefined4 param_2)\n\n{\n  rl_completion_invoking_key = param_2;\n  rl_complete_internal(0x3f);\n  return;\n}\n\n",
  "wait_builtin": "\nint wait_builtin(undefined8 param_1)\n\n{\n  long lVar1;\n  char *pcVar2;\n  bool bVar3;\n  long **pplVar4;\n  int iVar5;\n  int iVar6;\n  long **pplVar7;\n  uint uVar8;\n  long in_FS_OFFSET;\n  long **local_270;\n  long local_268;\n  int local_25c;\n  uint local_254;\n  ulong local_250;\n  ulong local_248;\n  int local_240;\n  undefined2 local_23c;\n  sigset_t local_238;\n  sigset_t local_1b8;\n  sigset_t local_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_254 = 0;\n  bVar3 = false;\n  local_268 = 0;\n  reset_internal_getopt();\n  uVar8 = 0;\nLAB_001b6313:\n  do {\n    iVar5 = internal_getopt(param_1,&DAT_00210a16);\n    pplVar4 = loptend;\n    if (iVar5 == -1) break;\n    if (iVar5 != 0x6e) {\n      if (iVar5 < 0x6f) {\n        if (iVar5 != -99) {\n          if (iVar5 != 0x66) goto LAB_001b63b8;\n          local_254 = 2;\n          goto LAB_001b6313;\n        }\n        builtin_help();\n      }\n      else {\n        if (iVar5 == 0x70) {\n          local_268 = list_optarg;\n          uVar8 = list_optflags;\n          goto LAB_001b6313;\n        }\nLAB_001b63b8:\n        builtin_usage();\n      }\n      iVar5 = 0x102;\n      goto LAB_001b638b;\n    }\n    bVar3 = true;\n  } while( true );\n  local_270 = loptend;\n  if (local_268 != 0) {\n    local_25c = assoc_expand_once;\n    if (assoc_expand_once == 0) {\n      iVar5 = 0;\n    }\n    else {\n      iVar5 = (-(uint)((uVar8 & 0x200) == 0) & 0xfffffffe) + 3;\n      local_25c = (-(uint)((uVar8 & 0x200) == 0) & 0xfffff000) + 0x1080;\n    }\n    iVar6 = legal_identifier(local_268);\n    if ((iVar6 == 0) && (iVar5 = valid_array_reference(local_268,iVar5), iVar5 == 0)) {\n      sh_invalidid(local_268);\n    }\n    else {\n      iVar5 = builtin_unbind_variable(local_268);\n      if (iVar5 != -2) goto LAB_001b6440;\n    }\n    wait_signal_received = 0;\n    iVar5 = 1;\n    wait_intr_flag = 0;\n    goto LAB_001b638b;\n  }\nLAB_001b6440:\n  wait_intr_flag = 1;\n  iVar5 = __sigsetjmp(wait_intr_buf,1);\n  if (iVar5 == 0) {\n    iVar6 = first_pending_trap();\n    if (iVar6 == 0x11) {\n      if (posixly_correct == 0) {\n        iVar6 = next_pending_trap(0x12);\n        goto LAB_001b6478;\n      }\n      iVar5 = 0x91;\n    }\n    else {\nLAB_001b6478:\n      if (iVar6 == -1) {\n        if (bVar3) {\n          if (pplVar4 != (long **)0x0) {\n            sigemptyset(&local_138);\n            sigaddset(&local_138,0x11);\n            sigemptyset(&local_b8);\n            sigprocmask(0,&local_138,&local_b8);\n            iVar5 = 0;\n            pplVar7 = pplVar4;\n            do {\n              iVar6 = legal_number(*pplVar7[1],&local_248);\n              if ((iVar6 == 0) || (local_248 != (long)(int)local_248)) {\n                iVar6 = get_job_spec(pplVar7);\n              }\n              else {\n                iVar6 = get_job_by_pid(local_248 & 0xffffffff,0,0);\n              }\n              if ((((iVar6 == -1) || (iVar6 < 0)) || (jobs == 0)) ||\n                 ((DAT_0023877c <= iVar6 || (lVar1 = *(long *)(jobs + (long)iVar6 * 8), lVar1 == 0))\n                 )) {\n                sh_badjob(*pplVar7[1]);\n              }\n              else if ((*(uint *)(lVar1 + 0x18) & 0x80) == 0) {\n                iVar5 = iVar5 + 1;\n                *(uint *)(lVar1 + 0x18) = *(uint *)(lVar1 + 0x18) | 0x80;\n              }\n              pplVar7 = (long **)*pplVar7;\n            } while (pplVar7 != (long **)0x0);\n            sigprocmask(2,&local_b8,(sigset_t *)0x0);\n            if (iVar5 == 0) {\n              wait_signal_received = 0;\n              iVar5 = 0x7f;\n              wait_intr_flag = 0;\n              goto LAB_001b638b;\n            }\n            local_254 = local_254 | 8;\n          }\n          iVar5 = wait_for_any_job(local_254,&local_240);\n          if ((local_268 != 0) && (-1 < iVar5)) {\n            builtin_bind_var_to_int(local_268,(long)local_240,local_25c);\n          }\n          if (iVar5 < 0) {\n            iVar5 = 0x7f;\n          }\n          if (pplVar4 != (long **)0x0) {\n            FUN_001b61f0();\n          }\n        }\n        else {\n          if (pplVar4 == (long **)0x0) {\n            wait_for_background_pids(&local_240);\n            wait_signal_received = 0;\n            wait_intr_flag = 0;\n            iVar5 = 0;\n            goto LAB_001b638b;\n          }\n          do {\n            pcVar2 = (char *)*local_270[1];\n            if ((byte)(*pcVar2 - 0x30U) < 10) {\n              iVar5 = legal_number(pcVar2,&local_250);\n              if (iVar5 != 0) {\n                iVar6 = (int)local_250;\n                if (local_250 == (long)iVar6) {\n                  iVar5 = wait_for_single_pid(local_250 & 0xffffffff,local_254 | 1);\n                  if (iVar5 < 0x101) {\n                    local_23c = (undefined2)iVar5;\n                    local_240 = iVar6;\n                  }\n                  else {\n                    local_240 = -1;\n                    iVar5 = 0x7f;\n                    local_23c = 0x7f;\n                  }\n                  goto LAB_001b6658;\n                }\n              }\n              iVar5 = 1;\n              sh_badpid(pcVar2);\n              goto LAB_001b658c;\n            }\n            if (*pcVar2 == '%') {\n              sigemptyset(&local_238);\n              sigaddset(&local_238,0x11);\n              sigemptyset(&local_1b8);\n              sigprocmask(0,&local_238,&local_1b8);\n              iVar5 = get_job_spec(local_270);\n              if (iVar5 < 0) {\n                if (iVar5 != -2) goto LAB_001b6795;\n              }\n              else {\n                if ((iVar5 < DAT_0023877c) && (*(long *)(jobs + (long)iVar5 * 8) != 0)) {\n                  sigprocmask(2,&local_1b8,(sigset_t *)0x0);\n                  iVar5 = wait_for_job(iVar5,local_254,&local_240);\n                  goto LAB_001b6658;\n                }\nLAB_001b6795:\n                sh_badjob(*local_270[1]);\n              }\n              iVar5 = 0x7f;\n              sigprocmask(2,&local_1b8,(sigset_t *)0x0);\n              local_240 = -1;\n              local_23c = 0x7f;\n              local_270 = (long **)*local_270;\n            }\n            else {\n              iVar5 = 1;\n              sh_badpid(pcVar2);\n              local_240 = -1;\n              local_23c = 0x7f;\nLAB_001b6658:\n              if (wait_signal_received != 0) {\n                last_command_exit_signal = wait_signal_received;\n                iVar5 = wait_signal_received + 0x80;\n                wait_sigint_cleanup();\n                goto LAB_001b658c;\n              }\n              local_270 = (long **)*local_270;\n            }\n          } while (local_270 != (long **)0x0);\n          if ((local_268 != 0) && (local_240 != -1)) {\n            builtin_bind_var_to_int(local_268,(long)local_240,local_25c);\n          }\n        }\n        goto LAB_001b658c;\n      }\n      iVar5 = iVar6 + 0x80;\n    }\n    wait_signal_received = 0;\n    wait_intr_flag = 0;\n    last_command_exit_signal = iVar6;\n  }\n  else {\n    last_command_exit_signal = wait_signal_received;\n    iVar5 = wait_signal_received + 0x80;\n    wait_sigint_cleanup();\nLAB_001b658c:\n    wait_signal_received = 0;\n    wait_intr_flag = 0;\n  }\nLAB_001b638b:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00147180": "\nvoid FUN_00147180(long param_1)\n\n{\n  char cVar1;\n  \n  FUN_001446d0(&DAT_002111d0);\n  DAT_00241f2c = DAT_00241f2c + 1;\n  FUN_00146230(*(undefined8 *)(param_1 + 8));\n  if (DAT_00241f18 != 0) {\n    FUN_001452c0(&DAT_00213d70);\n  }\n  if (command_string_index < 1) {\nLAB_001471d7:\n    FUN_001446d0(&DAT_001fab1e);\n  }\n  else {\n    cVar1 = *(char *)(the_printed_command + -1 + (long)command_string_index);\n    if ((cVar1 != '&') && (cVar1 != '\\n')) goto LAB_001471d7;\n  }\n  FUN_001446d0(&DAT_001fc7bd);\n  DAT_00241f34 = DAT_00241f34 + DAT_00238404;\n  FUN_00146230(*(undefined8 *)(param_1 + 0x10));\n  if (DAT_00241f18 != 0) {\n    FUN_001452c0(&DAT_00213d70);\n  }\n  DAT_00241f34 = DAT_00241f34 - DAT_00238404;\n  if (0 < command_string_index) {\n    cVar1 = *(char *)(the_printed_command + -1 + (long)command_string_index);\n    if ((cVar1 == '&') || (cVar1 == '\\n')) goto LAB_00147257;\n  }\n  FUN_001446d0(&DAT_001fab1e);\nLAB_00147257:\n  FUN_001446d0(&DAT_001ff6d2);\n  FUN_001449a0(DAT_00241f34);\n  FUN_001446d0(&DAT_002102da,&DAT_001fab5f);\n  return;\n}\n\n",
  "iconv": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t iconv(iconv_t __cd,char **__inbuf,size_t *__inbytesleft,char **__outbuf,\n            size_t *__outbytesleft)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_iconv_002378b0)();\n  return sVar1;\n}\n\n",
  "rl_vi_complete": "\nundefined8 rl_vi_complete(undefined8 param_1,int param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  ushort **ppuVar3;\n  size_t sVar4;\n  \n  if (((rl_point < rl_end) && (cVar1 = *(char *)(rl_line_buffer + rl_point), cVar1 != ' ')) &&\n     (cVar1 != '\\t')) {\n    cVar1 = *(char *)(rl_line_buffer + 1 + (long)rl_point);\n    if ((cVar1 != ' ') && (cVar1 != '\\t')) {\n      ppuVar3 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar3 + 0x8b) & 1) == 0) {\n        rl_vi_eword();\n      }\n      else {\n        rl_vi_eWord(1,0x45);\n      }\n      if (rl_end <= rl_point) goto LAB_001d19d0;\n    }\n    sVar4 = __ctype_get_mb_cur_max();\n    iVar2 = rl_point;\n    if ((sVar4 == 1) || (rl_byte_oriented != 0)) {\n      rl_point = rl_point + 1;\n    }\n    else {\n      rl_point = _rl_forward_char_internal(1);\n      if ((rl_point == iVar2) || (rl_end < rl_point)) {\n        rl_point = rl_end;\n      }\n    }\n  }\nLAB_001d19d0:\n  if (param_2 == 0x2a) {\n    rl_complete_internal(0x2a);\n  }\n  else {\n    if (param_2 == 0x3d) {\n      rl_complete_internal(0x3f);\n      return 0;\n    }\n    if (param_2 != 0x5c) {\n      rl_complete(0,param_2);\n      return 0;\n    }\n    rl_complete_internal(9);\n  }\n  DAT_0023b36c = 1;\n  DAT_0023b368 = rl_arg_sign;\n  _rl_vi_last_command = param_2;\n  rl_begin_undo_group();\n  _rl_keymap = &vi_insertion_keymap;\n  if (_rl_show_mode_in_prompt == 0) {\n    DAT_0024a3c8 = param_2;\n    return 0;\n  }\n  DAT_0024a3c8 = param_2;\n  _rl_reset_prompt();\n  return 0;\n}\n\n",
  "internal_warning": "\nvoid internal_warning(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                     undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                     undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                     undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  FUN_0015b0b0(1);\n  fwrite(\"warning: \",1,9,stderr);\n  local_d0 = &stack0x00000008;\n  local_d8 = 8;\n  local_c8 = local_b8;\n  local_d4 = 0x30;\n  __vfprintf_chk(stderr,1,param_9,&local_d8);\n  fputc(10,stderr);\n  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_arg_dispatch": "\nundefined8 _rl_arg_dispatch(ulong param_1,uint param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  if ((((int)param_2 < 0) || (_rl_keymap[(long)(int)param_2 * 0x10] != '\\0')) ||\n     (*(code **)(_rl_keymap + (long)(int)param_2 * 0x10 + 8) != rl_universal_argument)) {\n    uVar1 = (param_2 & 0xffffff7f) - 0x30;\n    if (uVar1 < 10) {\n      if (rl_explicit_arg != 0) {\n        uVar1 = uVar1 + rl_numeric_arg * 10;\n      }\n      _rl_argcxt = _rl_argcxt | 2;\n      uVar3 = 1;\n      rl_explicit_arg = 1;\n      rl_numeric_arg = uVar1;\n    }\n    else {\n      if (((param_2 & 0xffffff7f) == 0x2d) && (rl_explicit_arg == 0)) {\n        rl_numeric_arg = 1;\n        _rl_argcxt = _rl_argcxt | 1;\n        rl_arg_sign = 0xffffffff;\n        return 1;\n      }\n      if (((_rl_argcxt & 1) != 0) && ((rl_numeric_arg == 1 && (rl_explicit_arg == 0)))) {\n        rl_explicit_arg = 1;\n      }\n      rl_restore_prompt();\n      rl_clear_message();\n      rl_readline_state = rl_readline_state & 0xfffffffffffffbff;\n      uVar3 = _rl_dispatch(param_2,_rl_keymap);\n      if ((rl_readline_state & 0x80000) != 0) {\n        if (rl_done == 0) {\n          (*(code *)rl_redisplay_function)();\n          uVar3 = 0;\n        }\n        else {\n          uVar3 = 0;\n        }\n      }\n    }\n  }\n  else if ((param_1 & 2) == 0) {\n    rl_numeric_arg = rl_numeric_arg << 2;\n    uVar3 = 1;\n  }\n  else if ((rl_readline_state & 0x80000) == 0) {\n    iVar2 = _rl_bracketed_read_key();\n    rl_restore_prompt();\n    rl_clear_message();\n    rl_readline_state = rl_readline_state & 0xfffffffffffffbff;\n    if (-1 < iVar2) {\n      uVar3 = _rl_dispatch(iVar2,_rl_keymap);\n      return uVar3;\n    }\n    uVar3 = 0xffffffff;\n  }\n  else {\n    _rl_argcxt = _rl_argcxt | 4;\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
  "caller_builtin": "\nundefined4 caller_builtin(long param_1)\n\n{\n  char *__s1;\n  long lVar1;\n  int iVar2;\n  long lVar3;\n  long lVar4;\n  long lVar5;\n  undefined *puVar6;\n  undefined *puVar7;\n  undefined4 uVar8;\n  long in_FS_OFFSET;\n  long local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((param_1 != 0) && (*(char ***)(param_1 + 8) != (char **)0x0)) &&\n     (__s1 = **(char ***)(param_1 + 8), *__s1 == '-')) {\n    iVar2 = strcmp(__s1,\"--help\");\n    if (iVar2 == 0) {\n      builtin_help();\n      uVar8 = 0x102;\n      goto LAB_001a2a66;\n    }\n  }\n  lVar3 = find_variable(\"FUNCNAME\");\n  if (lVar3 != 0) {\n    if ((*(byte *)(lVar3 + 0x28) & 4) == 0) {\n      lVar3 = 0;\n    }\n    else {\n      lVar3 = *(long *)(lVar3 + 8);\n    }\n  }\n  lVar4 = find_variable(\"BASH_SOURCE\");\n  if (lVar4 != 0) {\n    if ((*(byte *)(lVar4 + 0x28) & 4) == 0) {\n      lVar4 = 0;\n    }\n    else {\n      lVar4 = *(long *)(lVar4 + 8);\n    }\n  }\n  lVar5 = find_variable(\"BASH_LINENO\");\n  if ((((lVar5 != 0) && ((*(byte *)(lVar5 + 0x28) & 4) != 0)) &&\n      ((lVar5 = *(long *)(lVar5 + 8), lVar5 != 0 && ((*(long *)(lVar5 + 8) != 0 && (lVar4 != 0))))))\n     && (*(long *)(lVar4 + 8) != 0)) {\n    iVar2 = no_options(param_1);\n    lVar1 = loptend;\n    if (iVar2 != 0) {\n      uVar8 = 0x102;\n      goto LAB_001a2a66;\n    }\n    uVar8 = 0;\n    if (loptend == 0) {\n      puVar6 = (undefined *)array_reference(lVar5,0);\n      puVar7 = (undefined *)array_reference(lVar4,1);\n      if (puVar7 == (undefined *)0x0) {\n        puVar7 = &DAT_0020f205;\n      }\n      if (puVar6 == (undefined *)0x0) {\n        puVar6 = &DAT_0020f205;\n      }\n      __printf_chk(1,\"%s %s\\n\",puVar6,puVar7);\n      goto LAB_001a2a66;\n    }\n    if ((lVar3 != 0) && (*(long *)(lVar3 + 8) != 0)) {\n      iVar2 = legal_number(**(undefined8 **)(loptend + 8),&local_38);\n      if (iVar2 == 0) {\n        uVar8 = 0x102;\n        sh_invalidnum(**(undefined8 **)(lVar1 + 8));\n        builtin_usage();\n        goto LAB_001a2a66;\n      }\n      lVar5 = array_reference(lVar5,local_38);\n      lVar4 = array_reference(lVar4,local_38 + 1);\n      lVar3 = array_reference(lVar3,local_38 + 1);\n      if ((lVar5 != 0 && lVar4 != 0) && (lVar3 != 0)) {\n        __printf_chk(1,\"%s %s %s\\n\",lVar5,lVar3,lVar4);\n        goto LAB_001a2a66;\n      }\n    }\n  }\n  uVar8 = 1;\nLAB_001a2a66:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar8;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "sigismember": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigismember(sigset_t *__set,int __signo)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigismember_00237df0)();\n  return iVar1;\n}\n\n",
  "make_array_variable_value": "\nundefined8\nmake_array_variable_value\n          (char **param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,uint param_5)\n\n{\n  byte bVar1;\n  uint uVar2;\n  char **ppcVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char *pcVar6;\n  undefined8 uVar7;\n  \n  if ((param_5 & 1) != 0) {\n    ppcVar3 = (char **)sh_xmalloc(0x30,\"arrayfunc.c\",0xa5);\n    pcVar6 = *param_1;\n    sVar4 = strlen(pcVar6);\n    pcVar5 = (char *)sh_xmalloc(sVar4 + 1,\"arrayfunc.c\",0xa6);\n    pcVar5 = strcpy(pcVar5,pcVar6);\n    bVar1 = *(byte *)(param_1 + 5);\n    pcVar6 = param_1[1];\n    *ppcVar3 = pcVar5;\n    if ((bVar1 & 0x40) == 0) {\n      pcVar6 = (char *)array_reference(pcVar6,param_2);\n    }\n    else {\n      pcVar6 = (char *)assoc_reference(pcVar6,param_3);\n    }\n    if (pcVar6 == (char *)0x0) {\n      pcVar6 = (char *)sh_xmalloc(1,\"arrayfunc.c\",0xaf);\n      ppcVar3[1] = pcVar6;\n      *pcVar6 = '\\0';\n    }\n    else {\n      sVar4 = strlen(pcVar6);\n      pcVar5 = (char *)sh_xmalloc(sVar4 + 1,\"arrayfunc.c\",0xac);\n      pcVar6 = strcpy(pcVar5,pcVar6);\n      ppcVar3[1] = pcVar6;\n    }\n    uVar2 = *(uint *)(param_1 + 5);\n    ppcVar3[2] = (char *)0x0;\n    *(uint *)(ppcVar3 + 5) = uVar2 & 0xffffffba;\n    uVar7 = make_variable_value(ppcVar3,param_4,param_5);\n    dispose_variable(ppcVar3);\n    return uVar7;\n  }\n  uVar7 = make_variable_value(param_1,param_4,param_5);\n  return uVar7;\n}\n\n",
  "FUN_001ab8e0": "\nvoid FUN_001ab8e0(int param_1,char *param_2,uint param_3,int param_4)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  uint uVar3;\n  ulong uVar4;\n  \n  pcVar1 = *(char **)(shell_builtins + (long)param_1 * 0x30 + 0x20);\n  *param_2 = (-((*(uint *)(shell_builtins + (long)param_1 * 0x30 + 0x10) & 1) == 0) & 10U) + 0x20;\n  strncpy(param_2 + 1,pcVar1,(long)(int)(param_3 - 2));\n  param_2[(long)(int)param_3 + -2] = '>';\n  param_2[(long)(int)param_3 + -1] = '\\0';\n  __printf_chk(1,&DAT_002102da,param_2);\n  if ((param_1 * 2 < num_shell_builtins) &&\n     (param_1 = param_1 + param_4, param_1 < num_shell_builtins)) {\n    sVar2 = strlen(param_2);\n    uVar4 = sVar2 & 0xffffffff;\n    if ((int)sVar2 < (int)param_3) {\n      do {\n        uVar3 = (int)uVar4 + 1;\n        uVar4 = (ulong)uVar3;\n        putc(0x20,stdout);\n      } while (param_3 != uVar3);\n    }\n    pcVar1 = *(char **)(shell_builtins + (long)param_1 * 0x30 + 0x20);\n    *param_2 = (-((*(uint *)(shell_builtins + (long)param_1 * 0x30 + 0x10) & 1) == 0) & 10U) + 0x20;\n    strncpy(param_2 + 1,pcVar1,(long)(int)(param_3 - 3));\n    param_2[(long)(int)param_3 + -3] = '>';\n    param_2[(long)(int)param_3 + -2] = '\\0';\n    puts(param_2);\n    return;\n  }\n  putchar(10);\n  return;\n}\n\n",
  "wextglob_pattern_p": "\nbool wextglob_pattern_p(int *param_1)\n\n{\n  bool bVar1;\n  \n  bVar1 = false;\n  if ((*param_1 - 0x21U < 0x20) && ((0xc0000601UL >> ((ulong)(*param_1 - 0x21U) & 0x3f) & 1) != 0))\n  {\n    bVar1 = param_1[1] == 0x28;\n  }\n  return bVar1;\n}\n\n",
  "_rl_add_executing_keyseq": "\nvoid _rl_add_executing_keyseq(undefined param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = (long)rl_key_sequence_length;\n  if (rl_key_sequence_length + 2 < _rl_executing_keyseq_size) {\n    rl_key_sequence_length = rl_key_sequence_length + 1;\n    *(undefined *)(rl_executing_keyseq + lVar1) = param_1;\n    return;\n  }\n  _rl_executing_keyseq_size = _rl_executing_keyseq_size + 0x10;\n  rl_executing_keyseq = xrealloc(rl_executing_keyseq,(long)_rl_executing_keyseq_size);\n  lVar1 = (long)rl_key_sequence_length;\n  rl_key_sequence_length = rl_key_sequence_length + 1;\n  *(undefined *)(rl_executing_keyseq + lVar1) = param_1;\n  return;\n}\n\n",
  "FUN_00194eb0": "\nundefined8 FUN_00194eb0(void)\n\n{\n  int iVar1;\n  long lVar2;\n  int iVar3;\n  \n  iVar3 = rl_point;\n  iVar1 = rl_end;\n  lVar2 = FUN_001942c0(rl_line_buffer);\n  if (lVar2 != 0) {\n    FUN_00194d10(lVar2);\n    if (iVar3 != 0) {\n      iVar3 = rl_end - (iVar1 - iVar3);\n    }\n    rl_point = iVar3;\n    rl_insert(1,0x20);\n    return 0;\n  }\n  FUN_001934f0();\n  return 1;\n}\n\n",
  "_rl_init_line_state": "\nvoid _rl_init_line_state(void)\n\n{\n  rl_mark = 0;\n  rl_end = 0;\n  rl_point = 0;\n  DAT_0024a320 = rl_line_buffer;\n  *rl_line_buffer = 0;\n  return;\n}\n\n",
  "wcrtomb": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t wcrtomb(char *__s,wchar_t __wc,mbstate_t *__ps)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_wcrtomb_00237bf0)();\n  return sVar1;\n}\n\n",
  "get_current_prompt_level": "\nchar get_current_prompt_level(void)\n\n{\n  char cVar1;\n  \n  cVar1 = '\\x01';\n  if (current_prompt_string != 0) {\n    cVar1 = (current_prompt_string == ps2_prompt) + '\\x01';\n  }\n  return cVar1;\n}\n\n",
  "FUN_001ee5e0": "\nundefined8 FUN_001ee5e0(int param_1)\n\n{\n  ulong uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  rl_readline_state = rl_readline_state | 0x40;\n  iVar2 = rl_read_key();\n  uVar1 = rl_readline_state;\n  rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n  if (iVar2 < 0) {\n    return 1;\n  }\n  if ((uVar1 & 0x1000) != 0) {\n    _rl_add_macro_char(iVar2);\n    uVar1 = rl_readline_state;\n  }\n  if ((uVar1 & 0x80000) == 0) {\n    _rl_restore_tty_signals();\n  }\n  if (param_1 < 1) {\n    return 0;\n  }\n  uVar3 = FUN_001ee210(param_1,iVar2);\n  return uVar3;\n}\n\n",
  "rl_fetch_history": "\nundefined8 rl_fetch_history(int param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  if (rl_explicit_arg != 0) {\n    iVar1 = where_history();\n    iVar2 = -param_1;\n    if (-1 < param_1) {\n      iVar2 = (iVar1 + history_base) - param_1;\n    }\n    if ((0 < iVar2) && (iVar2 < iVar1 + history_base)) {\n      rl_get_previous_history(iVar2,param_2);\n      return 0;\n    }\n    if (rl_editing_mode == 0) {\n      rl_ding();\n      return 0;\n    }\n  }\n  iVar2 = where_history();\n  rl_get_previous_history(iVar2 + 1,0);\n  return 0;\n}\n\n",
  "FUN_001f2960": "\nundefined * FUN_001f2960(long param_1,int *param_2,int param_3,uint param_4,int *param_5)\n\n{\n  char cVar1;\n  long lVar2;\n  char cVar3;\n  int iVar4;\n  size_t sVar5;\n  long lVar6;\n  undefined *puVar7;\n  undefined *puVar8;\n  uint uVar9;\n  int iVar10;\n  ulong uVar11;\n  ulong uVar12;\n  int iVar13;\n  char *pcVar14;\n  long in_FS_OFFSET;\n  \n  iVar10 = *param_2;\n  uVar12 = (ulong)iVar10;\n  pcVar14 = (char *)(param_1 + uVar12);\n  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n  _rl_adjust_point();\n  cVar3 = *pcVar14;\n  uVar11 = uVar12;\n  iVar13 = iVar10;\n  if (cVar3 == '\\0') {\n    if (param_4 == 0) {\nLAB_001f2b24:\n      puVar8 = (undefined *)0x0;\n      goto LAB_001f2a61;\n    }\n    puVar8 = (undefined *)xmalloc(1);\n    iVar10 = 0;\n    puVar7 = puVar8;\n  }\n  else {\n    do {\n      if (cVar3 == param_3) {\n        if ((iVar10 < iVar13) || ((param_4 & 1) != 0)) goto LAB_001f2a90;\n        cVar3 = *pcVar14;\n        puVar8 = (undefined *)0x0;\n        goto LAB_001f2a5b;\n      }\n      sVar5 = __ctype_get_mb_cur_max();\n      if ((sVar5 < 2) || (rl_byte_oriented != 0)) {\nLAB_001f29e0:\n        if (*pcVar14 == '\\\\') {\n          iVar13 = iVar13 + (uint)(*(char *)(param_1 + 1 + uVar11) == param_3);\n        }\n      }\n      else {\n        iVar4 = _rl_get_char_len(pcVar14);\n        if (iVar4 < 2) goto LAB_001f29e0;\n        iVar13 = iVar4 + -1 + iVar13;\n      }\n      iVar13 = iVar13 + 1;\n      uVar11 = (ulong)iVar13;\n      pcVar14 = (char *)(param_1 + uVar11);\n      cVar3 = *pcVar14;\n    } while (cVar3 != '\\0');\n    if ((iVar13 <= iVar10) && ((param_4 & 1) == 0)) goto LAB_001f2b24;\nLAB_001f2a90:\n    puVar8 = (undefined *)xmalloc((long)((iVar13 - iVar10) + 1));\n    if (iVar10 < iVar13) {\n      lVar6 = 1;\n      uVar11 = uVar12;\n      while( true ) {\n        iVar10 = (int)uVar12;\n        cVar3 = *(char *)(param_1 + uVar11);\n        if ((cVar3 == '\\\\') && (cVar1 = *(char *)(param_1 + 1 + uVar11), cVar1 == param_3)) {\n          iVar10 = iVar10 + 1;\n          cVar3 = cVar1;\n        }\n        uVar9 = iVar10 + 1;\n        uVar12 = (ulong)uVar9;\n        puVar8[lVar6 + -1] = cVar3;\n        iVar10 = (int)lVar6;\n        lVar6 = lVar6 + 1;\n        if (iVar13 <= (int)uVar9) break;\n        uVar11 = (ulong)(int)uVar9;\n      }\n      puVar7 = puVar8 + iVar10;\n    }\n    else {\n      iVar10 = 0;\n      puVar7 = puVar8;\n    }\n  }\n  *puVar7 = 0;\n  *param_5 = iVar10;\n  cVar3 = *pcVar14;\nLAB_001f2a5b:\n  iVar13 = (iVar13 + 1) - (uint)(cVar3 == '\\0');\nLAB_001f2a61:\n  *param_2 = iVar13;\n  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar8;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "pop_scope": "\nvoid pop_scope(int param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  long *plVar3;\n  undefined8 uVar4;\n  \n  plVar3 = shell_variables;\n  if ((*(byte *)((long)shell_variables + 0xc) & 0x18) != 0) {\n    lVar1 = shell_variables[3];\n    if (lVar1 != 0) {\n      *(undefined8 *)(lVar1 + 0x10) = 0;\n    }\n    lVar2 = *shell_variables;\n    shell_variables = (long *)lVar1;\n    if (lVar2 != 0) {\n      sh_xfree(lVar2,\"variables.c\",0x15a2);\n    }\n    lVar1 = plVar3[4];\n    if (lVar1 != 0) {\n      if (param_1 == 0) {\n        hash_flush(lVar1,FUN_0015a320);\n      }\n      else {\n        hash_flush(lVar1,FUN_0015a310);\n      }\n      hash_dispose(plVar3[4]);\n    }\n    sh_xfree(plVar3,\"variables.c\",0x15ab);\n    uVar4 = find_variable(&DAT_001fce6e);\n    setifs(uVar4);\n    return;\n  }\n  internal_error(\"pop_scope: head of shell_variables not a temporary environment scope\");\n  return;\n}\n\n",
  "getmaxchild": "\nvoid getmaxchild(void)\n\n{\n  if (0 < DAT_0023b300) {\n    return;\n  }\n  DAT_0023b300 = sysconf(1);\n  return;\n}\n\n",
  "dequote_string": "\nundefined2 * dequote_string(byte *param_1)\n\n{\n  mbstate_t mVar1;\n  byte bVar2;\n  undefined2 *__dest;\n  char *pcVar3;\n  size_t sVar4;\n  size_t sVar5;\n  undefined2 *puVar6;\n  byte *pbVar7;\n  long lVar8;\n  size_t sVar9;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  bVar2 = *param_1;\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  if (bVar2 == 1) {\n    if (param_1[1] == 0) {\n      internal_debug(\"dequote_string: string with bare CTLESC\");\n      bVar2 = *param_1;\n      goto LAB_00170a09;\n    }\nLAB_00170bd2:\n    if (param_1[2] == 0) {\n      lVar8 = 3;\n      sVar9 = 2;\n    }\n    else {\n      sVar9 = strlen((char *)param_1);\n      lVar8 = sVar9 + 1;\n    }\n  }\n  else {\nLAB_00170a09:\n    lVar8 = 1;\n    sVar9 = 0;\n    if (bVar2 != 0) {\n      lVar8 = 2;\n      sVar9 = 1;\n      if (param_1[1] != 0) goto LAB_00170bd2;\n    }\n  }\n  __dest = (undefined2 *)sh_xmalloc(lVar8,\"subst.c\",0x130f);\n  bVar2 = *param_1;\n  puVar6 = __dest;\n  pbVar7 = param_1;\n  if (bVar2 == 0x7f) {\n    if (param_1[1] == 0) {\n      *(undefined *)__dest = 0;\n      goto LAB_00170af3;\n    }\nLAB_00170b2a:\n    pcVar3 = strchr((char *)param_1,1);\n    if (pcVar3 != (char *)0x0) goto LAB_00170a92;\n  }\n  else {\n    if (bVar2 == 1) {\n      if (param_1[1] == 0) {\n        *__dest = 1;\n        goto LAB_00170af3;\n      }\n      goto LAB_00170b2a;\n    }\n    pcVar3 = strchr((char *)param_1,1);\n    if (pcVar3 != (char *)0x0) {\n      while (bVar2 != 0) {\nLAB_00170a92:\n        while( true ) {\n          mVar1 = local_48;\n          if (bVar2 == 1) {\n            bVar2 = pbVar7[1];\n            if (bVar2 == 0) goto LAB_00170af0;\n            pbVar7 = pbVar7 + 1;\n          }\n          else {\n            bVar2 = *pbVar7;\n          }\n          if (locale_mb_cur_max < 2) break;\n          if (((*(uint *)(is_basic_table + (ulong)(bVar2 >> 5) * 4) >> (bVar2 & 0x1f) & 1) == 0) &&\n             ((locale_utf8locale == 0 || ((char)bVar2 < '\\0')))) {\n            sVar4 = mbrtowc((wchar_t *)0x0,(char *)pbVar7,(size_t)(param_1 + (sVar9 - (long)pbVar7))\n                            ,&local_48);\n            if (0xfffffffffffffffd < sVar4) {\n              *(byte *)puVar6 = *pbVar7;\n              goto LAB_00170a88;\n            }\n            sVar5 = 1;\n            if (sVar4 != 0) {\n              sVar5 = sVar4;\n            }\n            sVar4 = 0;\n            bVar2 = *pbVar7;\n            while( true ) {\n              *(byte *)((long)puVar6 + sVar4) = bVar2;\n              sVar4 = sVar4 + 1;\n              if (sVar4 == sVar5) break;\n              bVar2 = pbVar7[sVar4];\n            }\n          }\n          else {\n            *(byte *)puVar6 = bVar2;\n            sVar5 = 1;\n          }\n          puVar6 = (undefined2 *)((long)puVar6 + sVar5);\n          bVar2 = pbVar7[sVar5];\n          pbVar7 = pbVar7 + sVar5;\n          if (bVar2 == 0) goto LAB_00170af0;\n        }\n        *(byte *)puVar6 = bVar2;\nLAB_00170a88:\n        bVar2 = pbVar7[1];\n        puVar6 = (undefined2 *)((long)puVar6 + 1);\n        pbVar7 = pbVar7 + 1;\n        local_48 = mVar1;\n      }\nLAB_00170af0:\n      *(undefined *)puVar6 = 0;\n      goto LAB_00170af3;\n    }\n  }\n  strcpy((char *)__dest,(char *)param_1);\nLAB_00170af3:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return __dest;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "reset_mail_files": "\nvoid reset_mail_files(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  if (0 < DAT_002478b0) {\n    uVar1 = DAT_002478b0 - 1;\n    plVar2 = DAT_002478b8 + 1;\n    plVar4 = DAT_002478b8;\n    plVar5 = plVar2;\n    while( true ) {\n      lVar3 = *plVar4;\n      *(undefined8 *)(lVar3 + 0x18) = 0;\n      *(undefined8 *)(lVar3 + 0x10) = 0;\n      *(undefined8 *)(lVar3 + 0x20) = 0;\n      *(undefined4 *)(lVar3 + 0x28) = 0;\n      if (plVar5 == plVar2 + uVar1) break;\n      plVar4 = plVar5;\n      plVar5 = plVar5 + 1;\n    }\n  }\n  return;\n}\n\n",
  "FUN_0015bbc0": "\nuint FUN_0015bbc0(int param_1)\n\n{\n  uint uVar1;\n  \n  if (0x3f < param_1) {\n    uVar1 = 0;\n    if (param_1 - 0x5eU < 0x21) {\n      uVar1 = (uint)(0x140000001 >> ((byte)(param_1 - 0x5eU) & 0x3f)) & 1;\n    }\n    return uVar1;\n  }\n  if (param_1 < 0x21) {\n    return 0;\n  }\n  return (uint)(0xf400bf6200000000 >> ((byte)param_1 & 0x3f)) & 1;\n}\n\n",
  "add_history": "\nvoid add_history(undefined8 param_1)\n\n{\n  void **ppvVar1;\n  long *plVar2;\n  time_t tVar3;\n  size_t sVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  long lVar7;\n  int iVar8;\n  long lVar9;\n  long in_FS_OFFSET;\n  char acStack_78 [72];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_0024b6e4 == 0) {\n    if (DAT_0024b6e0 == 0) {\nLAB_001f1b30:\n      DAT_0024b6e0 = 0x1f6;\n      goto LAB_001f1b3a;\n    }\nLAB_001f1a74:\n    if (DAT_0024b6e0 + -1 == history_length) {\n      DAT_0024b6e0 = DAT_0024b6e0 + 0x32;\n      DAT_0024b6e8 = (long *)xrealloc(DAT_0024b6e8,(long)DAT_0024b6e0 * 8);\n    }\n    lVar9 = (long)(history_length + 1) * 8;\n    lVar7 = lVar9 + -8;\n    iVar8 = history_length + 1;\n  }\n  else {\n    lVar7 = (long)history_length;\n    if (history_length == history_max_entries) {\n      if (history_length == 0) goto LAB_001f1b07;\n      ppvVar1 = (void **)*DAT_0024b6e8;\n      if (ppvVar1 != (void **)0x0) {\n        if (*ppvVar1 != (void *)0x0) {\n          free(*ppvVar1);\n        }\n        if (ppvVar1[1] != (void *)0x0) {\n          free(ppvVar1[1]);\n        }\n        xfree(ppvVar1);\n        lVar7 = (long)history_length;\n      }\n      memmove(DAT_0024b6e8,DAT_0024b6e8 + 1,lVar7 << 3);\n      history_base = history_base + 1;\n      lVar9 = (long)history_length * 8;\n      lVar7 = lVar9 + -8;\n      iVar8 = history_length;\n    }\n    else {\n      if (DAT_0024b6e0 != 0) goto LAB_001f1a74;\n      if (history_max_entries < 1) goto LAB_001f1b30;\n      if (history_max_entries < 0x2001) {\n        DAT_0024b6e0 = history_max_entries + 2;\n      }\n      else {\n        DAT_0024b6e0 = 0x2000;\n      }\nLAB_001f1b3a:\n      lVar7 = 0;\n      lVar9 = 8;\n      DAT_0024b6e8 = (long *)xmalloc();\n      iVar8 = 1;\n    }\n  }\n  tVar3 = time((time_t *)0x0);\n  __snprintf_chk(acStack_78,0x3f,1,0x40,&DAT_00213dca,tVar3);\n  sVar4 = strlen(acStack_78);\n  pcVar5 = (char *)xmalloc(sVar4 + 1);\n  pcVar5 = strcpy(pcVar5,acStack_78);\n  *pcVar5 = history_comment_char;\n  uVar6 = alloc_history_entry(param_1);\n  plVar2 = DAT_0024b6e8;\n  *(undefined8 *)((long)DAT_0024b6e8 + lVar9) = 0;\n  *(undefined8 *)((long)plVar2 + lVar7) = uVar6;\n  history_length = iVar8;\nLAB_001f1b07:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "make_cond_command": "\nvoid make_cond_command(long param_1)\n\n{\n  undefined8 *puVar1;\n  undefined4 uVar2;\n  \n  puVar1 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0x1e0);\n  uVar2 = 0;\n  puVar1[3] = param_1;\n  puVar1[2] = 0;\n  *puVar1 = 0xb;\n  if (param_1 != 0) {\n    uVar2 = *(undefined4 *)(param_1 + 4);\n  }\n  *(undefined4 *)(puVar1 + 1) = uVar2;\n  return;\n}\n\n",
  "reinit_special_variables": "\nvoid reinit_special_variables(void)\n\n{\n  long lVar1;\n  char *__nptr;\n  \n  lVar1 = find_variable(\"COMP_WORDBREAKS\");\n  if (lVar1 == 0) {\n    reset_completer_word_break_chars();\n  }\n  if (privileged_mode == 0) {\n    setup_glob_ignore(\"GLOBIGNORE\");\n  }\n  lVar1 = find_variable(\"OPTERR\");\n  if (lVar1 != 0) {\n    __nptr = (char *)get_variable_value(lVar1);\n    if ((__nptr != (char *)0x0) && (*__nptr != '\\0')) {\n      lVar1 = strtol(__nptr,(char **)0x0,10);\n      sh_opterr = (int)lVar1;\n      return;\n    }\n  }\n  sh_opterr = 1;\n  return;\n}\n\n",
  "check_selfref": "\nundefined8 check_selfref(char *param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *__s2;\n  \n  if ((*param_1 == *param_2) && (iVar1 = strcmp(param_1,param_2), iVar1 == 0)) {\n    return 1;\n  }\n  uVar2 = valid_array_reference(param_2,0);\n  if ((int)uVar2 == 0) {\n    return uVar2;\n  }\n  __s2 = (char *)array_variable_name(param_2,0,0,0);\n  if (((__s2 != (char *)0x0) && (*param_1 == *__s2)) && (iVar1 = strcmp(param_1,__s2), iVar1 == 0))\n  {\n    sh_xfree(__s2,\"general.c\",0x15a);\n    return 1;\n  }\n  sh_xfree(__s2,\"general.c\",0x15d);\n  return 0;\n}\n\n",
  "sysconf": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nlong sysconf(int __name)\n\n{\n  long lVar1;\n  \n  lVar1 = (*(code *)PTR_sysconf_00237d80)();\n  return lVar1;\n}\n\n",
  "rl_tilde_expand": "\nundefined8 rl_tilde_expand(void)\n\n{\n  int iVar1;\n  long lVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  char cVar5;\n  char *pcVar6;\n  int iVar7;\n  size_t __n;\n  int iVar8;\n  \n  iVar7 = rl_end;\n  iVar8 = rl_point + -1;\n  if ((rl_end == rl_point) && (rl_line_buffer[rl_end] == '~')) {\n    uVar4 = tilde_expand(&DAT_00213ec8);\n    _rl_replace_text(uVar4,iVar8,iVar7);\n    xfree(uVar4);\n    return 0;\n  }\n  if (-1 < iVar8) {\n    lVar2 = (long)iVar8;\n    cVar5 = rl_line_buffer[lVar2];\n    if (cVar5 != '~') {\n      while ((cVar5 != ' ' && (cVar5 != '\\t'))) {\n        lVar2 = lVar2 + -1;\n        if ((int)lVar2 == -1) {\n          lVar2 = 0;\n          iVar7 = 0;\n          pcVar3 = rl_line_buffer;\n          goto LAB_001e8b32;\n        }\n        cVar5 = rl_line_buffer[lVar2];\n      }\n      iVar7 = (int)lVar2 + 1;\n      lVar2 = (long)iVar7;\n      pcVar3 = rl_line_buffer + lVar2;\n      goto LAB_001e8b32;\n    }\n  }\n  iVar7 = 0;\n  if (-1 < iVar8) {\n    iVar7 = iVar8;\n  }\n  lVar2 = (long)iVar7;\n  pcVar3 = rl_line_buffer + lVar2;\nLAB_001e8b32:\n  pcVar6 = rl_line_buffer + lVar2 + 1;\n  iVar8 = iVar7;\n  do {\n    iVar1 = iVar8;\n    cVar5 = *pcVar6;\n    pcVar6 = pcVar6 + 1;\n    if (cVar5 == ' ' || cVar5 == '\\t') break;\n    iVar8 = iVar1 + 1;\n  } while (iVar1 + 1 < rl_end);\n  if (*pcVar3 != '~') {\n    return 0;\n  }\n  __n = (size_t)((iVar1 - iVar7) + 1);\n  pcVar3 = (char *)xmalloc((long)((iVar1 - iVar7) + 2));\n  strncpy(pcVar3,rl_line_buffer + lVar2,__n);\n  pcVar3[__n] = '\\0';\n  uVar4 = tilde_expand(pcVar3);\n  xfree(pcVar3);\n  _rl_replace_text(uVar4,iVar7,iVar1);\n  xfree(uVar4);\n  return 0;\n}\n\n",
  "__vsnprintf_chk": "\nvoid __vsnprintf_chk(void)\n\n{\n  (*(code *)PTR___vsnprintf_chk_00237c68)();\n  return;\n}\n\n",
  "array_variable_name": "\nchar * array_variable_name(char *param_1,uint param_2,undefined8 *param_3,int *param_4)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  size_t sVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  puVar2 = (undefined *)mbschr(param_1,0x5b);\n  if (puVar2 == (undefined *)0x0) {\n    if (param_3 != (undefined8 *)0x0) {\n      *param_3 = 0;\n    }\n  }\n  else {\n    iVar5 = (int)((long)puVar2 - (long)param_1);\n    if ((param_2 & 0x60) == 0x60) {\n      sVar3 = strlen(param_1);\n      iVar1 = (int)sVar3 + -1;\n    }\n    else {\n      iVar1 = skipsubscript(param_1,(long)puVar2 - (long)param_1 & 0xffffffff,param_2 >> 5 & 1);\n    }\n    if ((iVar5 + 1 < iVar1) && (param_1[iVar1] == ']')) {\n      *puVar2 = 0;\n      sVar3 = strlen(param_1);\n      pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"arrayfunc.c\",0x590);\n      pcVar4 = strcpy(pcVar4,param_1);\n      *puVar2 = 0x5b;\n      if (param_3 != (undefined8 *)0x0) {\n        *param_3 = puVar2 + 1;\n      }\n      if (param_4 == (int *)0x0) {\n        return pcVar4;\n      }\n      *param_4 = iVar1 - iVar5;\n      return pcVar4;\n    }\n    err_badarraysub(param_1);\n    if (param_3 != (undefined8 *)0x0) {\n      *param_3 = puVar2;\n    }\n  }\n  if (param_4 == (int *)0x0) {\n    return (char *)0x0;\n  }\n  *param_4 = 0;\n  return (char *)0x0;\n}\n\n",
  "rl_insert_completions": "\nvoid rl_insert_completions(undefined8 param_1,undefined4 param_2)\n\n{\n  rl_completion_invoking_key = param_2;\n  rl_complete_internal(0x2a);\n  return;\n}\n\n",
  "run_trap_cleanup": "\nvoid run_trap_cleanup(int param_1)\n\n{\n  (&DAT_00247e40)[param_1] = (&DAT_00247e40)[param_1] & 0xffffffcf;\n  return;\n}\n\n",
  "make_simple_command": "\nlong make_simple_command(long param_1,long *param_2,long param_3)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  long *plVar3;\n  long *plVar4;\n  undefined8 *puVar5;\n  \n  if (param_3 == 0) {\n    param_3 = make_bare_simple_command();\n    parser_state = parser_state | 0x80000;\n  }\n  if (param_1 == 0) {\n    plVar3 = param_2;\n    if (param_2 != (long *)0x0) {\n      do {\n        plVar4 = plVar3;\n        plVar3 = (long *)*plVar4;\n      } while (plVar3 != (long *)0x0);\n      lVar1 = *(long *)(param_3 + 0x18);\n      *plVar4 = *(long *)(lVar1 + 0x10);\n      *(long **)(lVar1 + 0x10) = param_2;\n      return param_3;\n    }\n  }\n  else {\n    lVar1 = *(long *)(param_3 + 0x18);\n    uVar2 = *(undefined8 *)(lVar1 + 8);\n    if (DAT_00241ebc < 1) {\n      puVar5 = (undefined8 *)sh_xmalloc(0x10,\"make_cmd.c\",0xa3);\n    }\n    else {\n      DAT_00241ebc = DAT_00241ebc + -1;\n      puVar5 = *(undefined8 **)(wlcache + (long)DAT_00241ebc * 8);\n    }\n    *puVar5 = uVar2;\n    parser_state = parser_state & 0xfff7ffff;\n    puVar5[1] = param_1;\n    *(undefined8 **)(lVar1 + 8) = puVar5;\n  }\n  return param_3;\n}\n\n",
  "expand_words": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong expand_words(long param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  undefined8 *puVar6;\n  long *plVar7;\n  bool bVar8;\n  \n  tempenv_assign_error = 0;\n  if (param_1 == 0) {\n    return 0;\n  }\n  puVar1 = (undefined8 *)copy_word_list();\n  if (puVar1 == (undefined8 *)0x0) {\n    _DAT_00247840 = (undefined8 *)0x0;\n    puVar1 = subst_assign_varlist;\n    if (subst_assign_varlist == (undefined8 *)0x0) goto LAB_0017f4c7;\n  }\n  else {\n    if (subst_assign_varlist != (undefined8 *)0x0) {\n      _DAT_00247840 = puVar1;\n      dispose_words();\n    }\n    subst_assign_varlist = (undefined8 *)0x0;\n    puVar5 = puVar1;\n    puVar6 = puVar1;\n    do {\n      puVar3 = puVar6;\n      if ((*(byte *)(puVar3[1] + 8) & 4) == 0) {\n        if (puVar1 != puVar3) {\n          subst_assign_varlist = puVar1;\n          *puVar5 = 0;\n        }\n        if (place_keywords_in_env != 0) {\n          puVar1 = (undefined8 *)*puVar3;\n          puVar6 = puVar3;\n          while (puVar1 != (undefined8 *)0x0) {\n            while (puVar2 = puVar1, (*(byte *)(puVar2[1] + 8) & 4) == 0) {\n              puVar1 = (undefined8 *)*puVar2;\n              puVar6 = puVar2;\n              if ((undefined8 *)*puVar2 == (undefined8 *)0x0) goto LAB_0017f556;\n            }\n            puVar1 = puVar2;\n            if (subst_assign_varlist != (undefined8 *)0x0) {\n              *puVar5 = puVar2;\n              puVar1 = subst_assign_varlist;\n            }\n            subst_assign_varlist = puVar1;\n            *puVar6 = *puVar2;\n            *puVar2 = 0;\n            puVar5 = puVar2;\n            puVar1 = (undefined8 *)*puVar6;\n          }\n        }\nLAB_0017f556:\n        _DAT_00247840 = puVar3;\n        if (brace_expansion != 0) {\n          puVar3 = (undefined8 *)FUN_00168ba0();\n        }\n        lVar4 = FUN_0017a460(puVar3);\n        if (lVar4 == 0) {\n          lVar4 = 0;\n          bVar8 = true;\n          plVar7 = (long *)0x0;\n          if (subst_assign_varlist == (undefined8 *)0x0) {\n            return 0;\n          }\n        }\n        else {\n          if (disallow_filename_globbing == 0) {\n            lVar4 = FUN_00170ca0();\n          }\n          else {\n            lVar4 = dequote_list();\n          }\n          if (subst_assign_varlist == (undefined8 *)0x0) {\n            return lVar4;\n          }\n          bVar8 = lVar4 == 0;\n          if (bVar8) {\n            plVar7 = (long *)0x0;\n          }\n          else {\n            plVar7 = *(long **)(lVar4 + 8);\n            if (plVar7 != (long *)0x0) {\n              plVar7 = (long *)*plVar7;\n            }\n          }\n        }\n        FUN_00168e50(subst_assign_varlist,plVar7,bVar8);\n        dispose_words(subst_assign_varlist);\n        subst_assign_varlist = (undefined8 *)0x0;\n        return lVar4;\n      }\n      puVar5 = puVar3;\n      puVar6 = (undefined8 *)*puVar3;\n    } while ((undefined8 *)*puVar3 != (undefined8 *)0x0);\n    _DAT_00247840 = (undefined8 *)0x0;\n    subst_assign_varlist = puVar1;\n    *puVar3 = 0;\n  }\n  FUN_00168e50(puVar1,0,1);\nLAB_0017f4c7:\n  dispose_words(subst_assign_varlist);\n  subst_assign_varlist = (undefined8 *)0x0;\n  return 0;\n}\n\n",
  "rl_end_of_history": "\nundefined8 rl_end_of_history(void)\n\n{\n  rl_maybe_replace_line();\n  using_history();\n  rl_maybe_unsave_line();\n  return 0;\n}\n\n",
  "FUN_001f0770": "\nvoid FUN_001f0770(void)\n\n{\n  char *pcVar1;\n  char **ppcVar2;\n  size_t sVar3;\n  char *pcVar4;\n  \n  _rl_saved_line_for_history = (char **)xmalloc(0x18);\n  pcVar1 = rl_line_buffer;\n  sVar3 = strlen(rl_line_buffer);\n  pcVar4 = (char *)xmalloc(sVar3 + 1);\n  ppcVar2 = _rl_saved_line_for_history;\n  pcVar4 = strcpy(pcVar4,pcVar1);\n  pcVar1 = rl_undo_list;\n  *ppcVar2 = pcVar4;\n  ppcVar2 = _rl_saved_line_for_history;\n  _rl_saved_line_for_history[1] = (char *)0x0;\n  ppcVar2[2] = pcVar1;\n  return;\n}\n\n",
  "_rl_revert_previous_lines": "\nvoid _rl_revert_previous_lines(void)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  char **ppcVar4;\n  char *__dest;\n  char *pcVar5;\n  char *pcVar6;\n  \n  pcVar6 = rl_line_buffer;\n  sVar2 = strlen(rl_line_buffer);\n  pcVar3 = (char *)xmalloc(sVar2 + 1);\n  pcVar3 = strcpy(pcVar3,pcVar6);\n  pcVar6 = rl_undo_list;\n  iVar1 = where_history();\n  if (history_length == iVar1) {\n    ppcVar4 = (char **)previous_history();\n  }\n  else {\n    ppcVar4 = (char **)current_history();\n  }\n  while (ppcVar4 != (char **)0x0) {\n    while (ppcVar4[2] != (char *)0x0) {\n      if (ppcVar4[2] == pcVar6) {\n        pcVar6 = (char *)0x0;\n      }\n      rl_replace_line(*ppcVar4,0);\n      pcVar5 = ppcVar4[2];\n      rl_mark = 0;\n      rl_point = rl_end;\n      if (rl_editing_mode == 0) {\n        rl_point = 0;\n        rl_mark = rl_end;\n      }\n      rl_undo_list = pcVar5;\n      ppcVar4[2] = (char *)0x0;\n      while (pcVar5 != (char *)0x0) {\n        rl_do_undo();\n        pcVar5 = rl_undo_list;\n      }\n      if (*ppcVar4 != (char *)0x0) {\n        free(*ppcVar4);\n      }\n      pcVar5 = rl_line_buffer;\n      sVar2 = strlen(rl_line_buffer);\n      __dest = (char *)xmalloc(sVar2 + 1);\n      pcVar5 = strcpy(__dest,pcVar5);\n      *ppcVar4 = pcVar5;\n      ppcVar4 = (char **)previous_history();\n      if (ppcVar4 == (char **)0x0) goto LAB_001f10eb;\n    }\n    ppcVar4 = (char **)previous_history();\n  }\nLAB_001f10eb:\n  rl_undo_list = pcVar6;\n  history_set_pos(iVar1);\n  rl_replace_line(pcVar3,0);\n  _rl_set_the_line();\n  xfree(pcVar3);\n  return;\n}\n\n",
  "getpagesize": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint getpagesize(void)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_getpagesize_00237dd8)();\n  return iVar1;\n}\n\n",
  "_rl_bracketed_text": "\nundefined * _rl_bracketed_text(long *param_1)\n\n{\n  long lVar1;\n  bool bVar2;\n  int iVar3;\n  undefined *puVar4;\n  char *__s1;\n  long lVar5;\n  undefined uVar6;\n  long lVar7;\n  \n  lVar7 = 0;\n  lVar5 = 0x40;\n  puVar4 = (undefined *)xmalloc(0x40);\n  *puVar4 = 0;\n  rl_readline_state = rl_readline_state | 0x40;\n  do {\n    iVar3 = rl_read_key();\n    if (iVar3 < 0) {\n      rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\nLAB_001e9f54:\n      if (param_1 != (long *)0x0) {\n        *param_1 = lVar7;\n      }\n      return puVar4;\n    }\n    if ((rl_readline_state & 0x1000) != 0) {\n      _rl_add_macro_char(iVar3);\n    }\n    if (iVar3 == 0xd) {\n      if (lVar5 == lVar7) {\n        bVar2 = false;\n        uVar6 = 10;\nLAB_001e9f18:\n        lVar5 = lVar5 * 2;\n        puVar4 = (undefined *)xrealloc(puVar4,lVar5);\n        goto LAB_001e9eb5;\n      }\n      puVar4[lVar7] = 10;\n    }\n    else {\n      uVar6 = (undefined)iVar3;\n      bVar2 = 5 < lVar7 + 1U && iVar3 == 0x7e;\n      if (lVar5 == lVar7) goto LAB_001e9f18;\nLAB_001e9eb5:\n      puVar4[lVar7] = uVar6;\n      if (bVar2) {\n        lVar1 = lVar7 + -5;\n        __s1 = puVar4 + lVar1;\n        if (*__s1 == '\\x1b') {\n          iVar3 = strncmp(__s1,\"\\x1b[201~\",6);\n          if (iVar3 == 0) {\n            rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n            if (lVar5 == lVar1) {\n              puVar4 = (undefined *)xrealloc(puVar4,lVar7 + -4);\n              __s1 = puVar4 + lVar1;\n            }\n            *__s1 = '\\0';\n            lVar7 = lVar1;\n            goto LAB_001e9f54;\n          }\n        }\n      }\n    }\n    lVar7 = lVar7 + 1;\n  } while( true );\n}\n\n",
  "coproc_rclose": "\nvoid coproc_rclose(long param_1,int param_2)\n\n{\n  int __fd;\n  \n  __fd = *(int *)(param_1 + 0xc);\n  if ((-1 < __fd) && (__fd == param_2)) {\n    close(__fd);\n    *(undefined4 *)(param_1 + 0xc) = 0xffffffff;\n    return;\n  }\n  return;\n}\n\n",
  "tt_setonechar": "\nundefined8 tt_setonechar(uint *param_1)\n\n{\n  param_1[3] = param_1[3] & 0xfffffffd | 0x8001;\n  *param_1 = *param_1 & 0xffffffbf | 0x100;\n  param_1[1] = param_1[1] & 0xffffffc7 | 5;\n  *(undefined2 *)((long)param_1 + 0x16) = 0x100;\n  return 0;\n}\n\n",
  "make_for_command": "\nvoid make_for_command(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  undefined4 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x20,\"make_cmd.c\",0xd1);\n  *(undefined8 *)(puVar1 + 2) = param_1;\n  puVar1[1] = param_4;\n  *(undefined8 *)(puVar1 + 4) = param_2;\n  *(undefined8 *)(puVar1 + 6) = param_3;\n  *puVar1 = 0;\n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar2[3] = puVar1;\n  *puVar2 = 0;\n  *puVar1 = 0;\n  puVar2[2] = 0;\n  return;\n}\n\n",
  "FUN_001452c0": "\nvoid FUN_001452c0(char *param_1)\n\n{\n  long *plVar1;\n  \n  if ((*param_1 != '\\0') && ((*param_1 != ';' || (param_1[1] != '\\0')))) {\n    FUN_001446d0(&DAT_002102da,param_1);\n  }\n  plVar1 = DAT_00241f18;\n  if (DAT_00241f18 != (long *)0x0) {\n    FUN_001446d0(&DAT_001ff6d2);\n    do {\n      FUN_001446d0(&DAT_001fc632,*(undefined8 *)plVar1[4],plVar1[5]);\n      FUN_001446d0(&DAT_001ff6d2);\n      plVar1 = (long *)*plVar1;\n    } while (plVar1 != (long *)0x0);\n    DAT_00241f28 = 1;\n    if ((*param_1 != '\\0') && ((*param_1 != ';' || (param_1[1] != '\\0')))) {\n      FUN_001446d0(&DAT_001fdb1c);\n    }\n    dispose_redirects(DAT_00241f18);\n    DAT_00241f28 = 1;\n  }\n  DAT_00241f18 = (long *)0x0;\n  return;\n}\n\n",
  "do_assignment_no_expand": "\nvoid do_assignment_no_expand(undefined8 param_1)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_28;\n  undefined4 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20 = 4;\n  local_28 = param_1;\n  FUN_00173b20(&local_28,0);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_set_keymap_name": "\nint rl_set_keymap_name(char *param_1,char *param_2)\n\n{\n  char *pcVar1;\n  undefined *puVar2;\n  int iVar3;\n  char **ppcVar4;\n  long lVar5;\n  size_t sVar6;\n  size_t sVar7;\n  char *pcVar8;\n  char **ppcVar9;\n  int iVar10;\n  long lVar11;\n  undefined8 *puVar12;\n  int iVar13;\n  \n  puVar2 = PTR_PTR_s_emacs_00240468;\n  pcVar8 = *(char **)PTR_PTR_s_emacs_00240468;\n  if (pcVar8 == (char *)0x0) {\n    lVar5 = 0x10;\n    lVar11 = 0x20;\n    iVar10 = 0;\n    sVar7 = 0;\n  }\n  else {\n    ppcVar9 = (char **)(PTR_PTR_s_emacs_00240468 + 0x10);\n    iVar10 = 0;\n    ppcVar4 = ppcVar9;\n    do {\n      if (param_2 == ppcVar4[-1]) {\n        if (iVar10 < 8) {\n          return -1;\n        }\n        goto LAB_001de4ed;\n      }\n      iVar10 = iVar10 + 1;\n      pcVar1 = *ppcVar4;\n      ppcVar4 = ppcVar4 + 2;\n    } while (pcVar1 != (char *)0x0);\n    iVar10 = -1;\nLAB_001de4ed:\n    iVar13 = 0;\n    do {\n      iVar3 = strcasecmp(param_1,pcVar8);\n      if (iVar3 == 0) {\n        if (iVar13 < 8) {\n          return -1;\n        }\n        if (iVar10 == -1) {\n          *(char **)(puVar2 + (long)iVar13 * 0x10 + 8) = param_2;\n          return iVar13;\n        }\n        goto LAB_001de600;\n      }\n      pcVar8 = *ppcVar9;\n      ppcVar9 = ppcVar9 + 2;\n      iVar13 = iVar13 + 1;\n    } while (pcVar8 != (char *)0x0);\n    lVar5 = 1;\n    sVar6 = 0x10;\n    if (iVar10 != -1) {\nLAB_001de600:\n      xfree(*(undefined8 *)(puVar2 + (long)iVar10 * 0x10));\n      sVar7 = strlen(param_1);\n      pcVar8 = (char *)xmalloc(sVar7 + 1);\n      ppcVar9 = (char **)(PTR_PTR_s_emacs_00240468 + (long)iVar10 * 0x10);\n      pcVar8 = strcpy(pcVar8,param_1);\n      *ppcVar9 = pcVar8;\n      return iVar10;\n    }\n    do {\n      sVar7 = sVar6;\n      iVar10 = (int)lVar5;\n      lVar5 = lVar5 + 1;\n      sVar6 = sVar7 + 0x10;\n    } while (*(long *)(puVar2 + sVar7) != 0);\n    lVar5 = lVar5 * 0x10;\n    lVar11 = (long)(iVar10 + 2) << 4;\n  }\n  if ((undefined **)puVar2 == &PTR_s_emacs_00240480) {\n    PTR_PTR_s_emacs_00240468 = (undefined *)xmalloc(lVar11);\n    memcpy(PTR_PTR_s_emacs_00240468,&PTR_s_emacs_00240480,sVar7);\n  }\n  else {\n    PTR_PTR_s_emacs_00240468 = (undefined *)xrealloc(puVar2);\n  }\n  sVar6 = strlen(param_1);\n  pcVar8 = (char *)xmalloc(sVar6 + 1);\n  puVar2 = PTR_PTR_s_emacs_00240468;\n  pcVar8 = strcpy(pcVar8,param_1);\n  ppcVar9 = (char **)(puVar2 + sVar7);\n  puVar12 = (undefined8 *)(puVar2 + lVar5);\n  *ppcVar9 = pcVar8;\n  ppcVar9[1] = param_2;\n  *puVar12 = 0;\n  puVar12[1] = 0;\n  return iVar10;\n}\n\n",
  "FUN_0013d9a0": "\nuint * FUN_0013d9a0(void)\n\n{\n  char *pcVar1;\n  char **ppcVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  long lVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  uint *puVar9;\n  char **ppcVar10;\n  undefined4 uVar11;\n  \n  iVar3 = FUN_0013d3a0();\n  uVar11 = line_number;\n  if (iVar3 == 0x112) {\n    DAT_00240b38 = 0x113;\n    return (uint *)0x0;\n  }\n  if (iVar3 == 0x28) {\n    lVar6 = FUN_0013e0a0();\n    if (DAT_00240b38 == 0x29) {\n      puVar9 = (uint *)make_cond_node(6,0,lVar6,0);\n      FUN_0013d3a0();\n      return puVar9;\n    }\n    if (lVar6 != 0) {\n      dispose_cond_node(lVar6);\n    }\n    lVar6 = FUN_00135070(DAT_00240b38);\n    if (lVar6 != 0) {\n      parser_error(uVar11,\"unexpected token `%s\\', expected `)\\'\",lVar6);\n      sh_xfree(lVar6,\"/usr/local/src/chet/src/bash/src/parse.y\",0x121b);\n      DAT_00240b38 = 0x113;\n      return (uint *)0x0;\n    }\n    parser_error(uVar11,\"expected `)\\'\");\n    DAT_00240b38 = 0x113;\n    return (uint *)0x0;\n  }\n  if (iVar3 == 0x115) {\nLAB_0013da58:\n    puVar9 = (uint *)FUN_0013d9a0();\n    if (puVar9 == (uint *)0x0) {\n      return (uint *)0x0;\n    }\n    *puVar9 = *puVar9 ^ 4;\n    return puVar9;\n  }\n  if (iVar3 != 0x119) {\n    if (iVar3 < 0x100) {\n      parser_error(line_number,\"unexpected token `%c\\' in conditional command\",iVar3);\n      DAT_00240b38 = 0x113;\n      return (uint *)0x0;\n    }\n    lVar6 = FUN_00135070(iVar3);\n    if (lVar6 != 0) {\n      parser_error(line_number,\"unexpected token `%s\\' in conditional command\",lVar6);\n      sh_xfree(lVar6,\"/usr/local/src/chet/src/bash/src/parse.y\",0x129b);\n      DAT_00240b38 = 0x113;\n      return (uint *)0x0;\n    }\n    parser_error(line_number,\"unexpected token %d in conditional command\",iVar3);\n    DAT_00240b38 = 0x113;\n    return (uint *)0x0;\n  }\n  pcVar1 = *yylval;\n  if (*pcVar1 == '!') {\n    if (pcVar1[1] == '\\0') {\n      dispose_word(yylval);\n      goto LAB_0013da58;\n    }\n  }\n  else if ((((*pcVar1 == '-') && (pcVar1[1] != '\\0')) && (pcVar1[2] == '\\0')) &&\n          (iVar3 = test_unop(), uVar4 = DAT_00240b58, ppcVar2 = DAT_00240b50, ppcVar10 = yylval,\n          iVar3 != 0)) {\n    if (DAT_00240b58 == 0) {\n      uVar4 = FUN_0013a230();\n    }\n    else {\n      if (DAT_00240b58 - 0x119 < 2) {\n        DAT_00240b50 = (char **)0x0;\n        yylval = ppcVar2;\n      }\n      DAT_00240b58 = 0;\n    }\n    if (uVar4 != 0x119) {\n      dispose_word(ppcVar10);\n      lVar6 = FUN_00135070(uVar4);\n      if (lVar6 != 0) {\n        parser_error(line_number,\"unexpected argument `%s\\' to conditional unary operator\",lVar6);\n        sh_xfree(lVar6,\"/usr/local/src/chet/src/bash/src/parse.y\",0x123b);\n        DAT_00240b38 = 0x113;\n        return (uint *)0x0;\n      }\n      parser_error(line_number,\"unexpected argument to conditional unary operator\");\n      DAT_00240b38 = 0x113;\n      return (uint *)0x0;\n    }\n    uVar7 = make_cond_node(5,yylval,0,0);\n    puVar9 = (uint *)make_cond_node(3,ppcVar10,uVar7,0);\n    FUN_0013d3a0();\n    return puVar9;\n  }\n  uVar7 = make_cond_node(5,yylval,0,0);\n  uVar4 = DAT_00240b58;\n  if (DAT_00240b58 == 0) {\n    uVar4 = FUN_0013a230();\n  }\n  else {\n    if (DAT_00240b58 - 0x119 < 2) {\n      yylval = DAT_00240b50;\n      DAT_00240b50 = (char **)0x0;\n    }\n    DAT_00240b58 = 0;\n  }\n  if (uVar4 == 0x119) {\n    iVar3 = test_binop(*yylval);\n    ppcVar10 = yylval;\n    if (iVar3 == 0) {\n      pcVar1 = *yylval;\n      if (((*pcVar1 != '=') || (pcVar1[1] != '~')) || (pcVar1[2] != '\\0')) goto LAB_0013db50;\n      uVar4 = parser_state & 0x1000;\n      parser_state = parser_state | 0x10000;\n      goto LAB_0013dc57;\n    }\n    pcVar1 = *yylval;\n    if (*pcVar1 == '=') {\n      if ((pcVar1[1] != '\\0') &&\n         ((uVar4 = parser_state & 0x1000, pcVar1[1] != '=' || (pcVar1[2] != '\\0'))))\n      goto LAB_0013dc57;\n    }\n    else if ((*pcVar1 != '!') || ((pcVar1[1] != '=' || (pcVar1[2] != '\\0')))) goto LAB_0013dc50;\n    parser_state = parser_state | 0x1000;\n    uVar4 = 0x1000;\n    uVar11 = extended_glob;\n  }\n  else {\n    if ((uVar4 & 0xfffffffd) != 0x3c) {\n      if (((uVar4 == 0x112) || (uVar4 == 0x120)) || ((uVar4 == 0x121 || (uVar4 == 0x29)))) {\n        uVar8 = make_word(&DAT_001faae2);\n        puVar9 = (uint *)make_cond_node(3,uVar8,uVar7,0);\n        DAT_00240b38 = uVar4;\n        return puVar9;\n      }\nLAB_0013db50:\n      lVar6 = FUN_00135070(uVar4);\n      if (lVar6 == 0) {\n        parser_error(line_number,\"conditional binary operator expected\");\n      }\n      else {\n        parser_error(line_number,\"unexpected token `%s\\', conditional binary operator expected\",\n                     lVar6);\n        sh_xfree(lVar6,\"/usr/local/src/chet/src/bash/src/parse.y\",0x126e);\n      }\n      dispose_cond_node(uVar7);\n      DAT_00240b38 = 0x113;\n      return (uint *)0x0;\n    }\n    ppcVar10 = (char **)make_word_from_token(uVar4);\nLAB_0013dc50:\n    uVar4 = parser_state & 0x1000;\nLAB_0013dc57:\n    uVar11 = extended_glob;\n    if (uVar4 == 0) goto LAB_0013dc65;\n  }\n  extended_glob = 1;\nLAB_0013dc65:\n  uVar5 = DAT_00240b58;\n  ppcVar2 = DAT_00240b50;\n  if (DAT_00240b58 == 0) {\n    uVar5 = FUN_0013a230();\n    uVar4 = parser_state & 0x1000;\n  }\n  else {\n    if (DAT_00240b58 - 0x119 < 2) {\n      DAT_00240b50 = (char **)0x0;\n      yylval = ppcVar2;\n    }\n    DAT_00240b58 = 0;\n  }\n  if (uVar4 != 0) {\n    extended_glob = uVar11;\n  }\n  parser_state = parser_state & 0xfffeefff;\n  if (uVar5 == 0x119) {\n    uVar8 = make_cond_node(5,yylval,0,0);\n    puVar9 = (uint *)make_cond_node(4,ppcVar10,uVar7,uVar8);\n    FUN_0013d3a0();\n  }\n  else {\n    lVar6 = FUN_00135070();\n    if (lVar6 == 0) {\n      parser_error(line_number,\"unexpected argument to conditional binary operator\");\n    }\n    else {\n      parser_error(line_number,\"unexpected argument `%s\\' to conditional binary operator\",lVar6);\n      sh_xfree(lVar6,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1289);\n    }\n    puVar9 = (uint *)0x0;\n    dispose_cond_node(uVar7);\n    dispose_word(ppcVar10);\n    DAT_00240b38 = 0x113;\n  }\n  return puVar9;\n}\n\n",
  "reset_local_contexts": "\nvoid reset_local_contexts(void)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  lVar2 = shell_variables;\n  if (shell_variables != global_variables) {\n    do {\n      lVar1 = *(long *)(lVar2 + 0x18);\n      dispose_var_context(lVar2);\n      lVar2 = lVar1;\n    } while (lVar1 != global_variables);\n  }\n  shell_variables = global_variables;\n  variable_context = 0;\n  return;\n}\n\n",
  "set_if_not": "\nvoid set_if_not(undefined8 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  \n  if (shell_variables == 0) {\n    FUN_00152b20();\n    lVar1 = find_variable(param_1);\n  }\n  else {\n    lVar1 = find_variable(param_1);\n  }\n  if (lVar1 != 0) {\n    return;\n  }\n  FUN_00154e30(param_1,param_2,*(undefined8 *)(global_variables + 0x20),1,0);\n  return;\n}\n\n",
  "FUN_00168ba0": "\nlong ** FUN_00168ba0(long **param_1)\n\n{\n  uint uVar1;\n  char *__s1;\n  char **ppcVar2;\n  char *__s2;\n  int iVar3;\n  long lVar4;\n  char **ppcVar5;\n  long **pplVar6;\n  char **ppcVar7;\n  long **pplVar8;\n  char **ppcVar9;\n  long **local_48;\n  \n  local_48 = (long **)0x0;\n  pplVar6 = (long **)0x0;\n  if (param_1 != (long **)0x0) {\n    do {\n      while( true ) {\n        pplVar8 = param_1;\n        param_1 = (long **)*pplVar8;\n        uVar1 = *(uint *)(pplVar8[1] + 1);\n        if ((((uVar1 & 0x4000000) == 0) && ((uVar1 & 0x28000) != 0x28000)) &&\n           (lVar4 = mbschr(*pplVar8[1],0x7b), lVar4 != 0)) break;\n        *pplVar8 = (long *)pplVar6;\n        pplVar6 = pplVar8;\n        if (param_1 == (long **)0x0) goto LAB_00168cd0;\n      }\n      ppcVar5 = (char **)brace_expand(*pplVar8[1]);\n      __s1 = *ppcVar5;\n      ppcVar9 = ppcVar5;\n      while (__s1 != (char *)0x0) {\n        ppcVar9 = ppcVar9 + 1;\n        ppcVar7 = (char **)alloc_word_desc();\n        ppcVar2 = (char **)pplVar8[1];\n        *ppcVar7 = __s1;\n        __s2 = *ppcVar2;\n        if ((*__s1 == *__s2) && (iVar3 = strcmp(__s1,__s2), iVar3 == 0)) {\n          *(undefined4 *)(ppcVar7 + 1) = *(undefined4 *)(ppcVar2 + 1);\n        }\n        else {\n          ppcVar7 = (char **)make_word_flags(ppcVar7,__s1);\n        }\n        pplVar6 = (long **)make_word_list(ppcVar7,pplVar6);\n        __s1 = *ppcVar9;\n      }\n      sh_xfree(ppcVar5,\"subst.c\",0x309e);\n      *pplVar8 = (long *)local_48;\n      local_48 = pplVar8;\n    } while (param_1 != (long **)0x0);\nLAB_00168cd0:\n    if (local_48 != (long **)0x0) {\n      dispose_words(local_48);\n    }\n    if (pplVar6 != (long **)0x0) {\n      if (*pplVar6 == (long *)0x0) {\n        return pplVar6;\n      }\n      pplVar6 = (long **)list_reverse(pplVar6);\n      return pplVar6;\n    }\n  }\n  return (long **)0x0;\n}\n\n",
  "glob_char_p": "\nbool glob_char_p(char *param_1)\n\n{\n  ulong uVar1;\n  bool bVar2;\n  \n  if (0x3c < (byte)(*param_1 - 0x21U)) {\n    return false;\n  }\n  uVar1 = 1L << (*param_1 - 0x21U & 0x3f);\n  if ((uVar1 & 0x1c00000040000200) == 0) {\n    bVar2 = false;\n    if ((uVar1 & 0x80000401) != 0) {\n      return param_1[1] == '(';\n    }\n  }\n  else {\n    bVar2 = true;\n  }\n  return bVar2;\n}\n\n",
  "stifle_history": "\nvoid stifle_history(int param_1)\n\n{\n  void **ppvVar1;\n  undefined8 *puVar2;\n  long lVar3;\n  int iVar4;\n  int iVar5;\n  \n  iVar4 = 0;\n  if (-1 < param_1) {\n    iVar4 = param_1;\n  }\n  if (iVar4 < history_length) {\n    iVar5 = history_length - iVar4;\n    lVar3 = 0;\n    puVar2 = DAT_0024b6e8;\n    do {\n      ppvVar1 = *(void ***)((long)puVar2 + lVar3);\n      if (ppvVar1 != (void **)0x0) {\n        if (*ppvVar1 != (void *)0x0) {\n          free(*ppvVar1);\n        }\n        if (ppvVar1[1] != (void *)0x0) {\n          free(ppvVar1[1]);\n        }\n        xfree(ppvVar1);\n        puVar2 = DAT_0024b6e8;\n      }\n      lVar3 = lVar3 + 8;\n    } while ((long)iVar5 * 8 != lVar3);\n    history_base = iVar5;\n    if (param_1 < 1) {\n      history_length = 0;\n    }\n    else {\n      lVar3 = 0;\n      do {\n        puVar2[lVar3] = puVar2[(history_length - iVar4) + lVar3];\n        lVar3 = lVar3 + 1;\n      } while ((int)lVar3 < iVar4);\n      history_length = 1;\n      if (0 < iVar4) {\n        history_length = iVar4;\n      }\n      puVar2 = puVar2 + history_length;\n    }\n    *puVar2 = 0;\n  }\n  history_max_entries = iVar4;\n  max_input_history = iVar4;\n  DAT_0024b6e4 = 1;\n  return;\n}\n\n",
  "strlist_merge": "\nlong * strlist_merge(long *param_1,long *param_2)\n\n{\n  long lVar1;\n  long *plVar2;\n  size_t sVar3;\n  char *pcVar4;\n  char *pcVar5;\n  undefined8 *puVar6;\n  int iVar7;\n  long lVar8;\n  int local_3c;\n  \n  if (param_1 == (long *)0x0) {\n    if (param_2 == (long *)0x0) {\n      plVar2 = (long *)strlist_create(1);\nLAB_001c7865:\n      puVar6 = (undefined8 *)*plVar2;\n      iVar7 = 0;\n      goto LAB_001c77f8;\n    }\n    local_3c = *(int *)((long)param_2 + 0xc);\n    iVar7 = 0;\n    plVar2 = (long *)strlist_create(local_3c + 1);\n    lVar8 = 0;\n  }\n  else {\n    iVar7 = *(int *)((long)param_1 + 0xc);\n    if (param_2 == (long *)0x0) {\n      plVar2 = (long *)strlist_create(iVar7 + 1);\n      local_3c = 0;\n      if (iVar7 < 1) goto LAB_001c7865;\n    }\n    else {\n      local_3c = *(int *)((long)param_2 + 0xc);\n      plVar2 = (long *)strlist_create(local_3c + 1 + iVar7);\n      if (iVar7 < 1) {\n        lVar8 = 0;\n        iVar7 = 0;\n        goto LAB_001c776e;\n      }\n    }\n    lVar8 = 0;\n    do {\n      lVar1 = lVar8 * 8;\n      pcVar5 = *(char **)(*param_1 + lVar8 * 8);\n      if (pcVar5 != (char *)0x0) {\n        sVar3 = strlen(pcVar5);\n        pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"stringlist.c\",0x9e);\n        pcVar5 = strcpy(pcVar4,pcVar5);\n      }\n      lVar8 = lVar8 + 1;\n      *(char **)(*plVar2 + lVar1) = pcVar5;\n    } while ((int)lVar8 < iVar7);\n    lVar8 = (long)iVar7 << 3;\n  }\nLAB_001c776e:\n  if (local_3c < 1) {\n    puVar6 = (undefined8 *)(lVar8 + *plVar2);\n  }\n  else {\n    lVar8 = 0;\n    do {\n      pcVar5 = *(char **)(*param_2 + lVar8);\n      if (pcVar5 != (char *)0x0) {\n        sVar3 = strlen(pcVar5);\n        pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"stringlist.c\",0xa0);\n        pcVar5 = strcpy(pcVar4,pcVar5);\n      }\n      lVar1 = *plVar2;\n      *(char **)(lVar1 + (long)iVar7 * 8 + lVar8) = pcVar5;\n      lVar8 = lVar8 + 8;\n    } while ((long)local_3c * 8 != lVar8);\n    iVar7 = iVar7 + local_3c;\n    puVar6 = (undefined8 *)(lVar1 + (long)iVar7 * 8);\n  }\nLAB_001c77f8:\n  *(int *)((long)plVar2 + 0xc) = iVar7;\n  *puVar6 = 0;\n  return plVar2;\n}\n\n",
  "FUN_001683d0": "\nbool FUN_001683d0(char *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  if ((((9 < (byte)(*param_1 - 0x30U)) || (iVar1 = all_digits(), iVar1 == 0)) && (param_2 == 0)) &&\n     (iVar1 = valid_array_reference(param_1,0), iVar1 == 0)) {\n    iVar1 = legal_identifier(param_1);\n    return iVar1 != 0;\n  }\n  return true;\n}\n\n",
  "find_variable_nameref": "\nundefined8 * find_variable_nameref(undefined8 *param_1)\n\n{\n  char *pcVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  int iVar4;\n  bool bVar5;\n  \n  iVar4 = 9;\n  puVar3 = param_1;\n  while( true ) {\n    if (puVar3 == (undefined8 *)0x0) {\n      return (undefined8 *)0x0;\n    }\n    if ((*(byte *)((long)puVar3 + 0x29) & 8) == 0) {\n      return puVar3;\n    }\n    iVar4 = iVar4 + -1;\n    if (iVar4 == 0) {\n      return (undefined8 *)0x0;\n    }\n    pcVar1 = (char *)puVar3[1];\n    if (pcVar1 == (char *)0x0) break;\n    if (*pcVar1 == '\\0') {\n      return (undefined8 *)0x0;\n    }\n    bVar5 = false;\n    if (expanding_redir == 0) {\n      bVar5 = (assigning_in_environment | executing_builtin) != 0;\n    }\n    puVar2 = (undefined8 *)FUN_00152c60(pcVar1,bVar5);\n    if ((param_1 == puVar2) || (bVar5 = puVar3 == puVar2, puVar3 = puVar2, bVar5)) {\n      internal_warning(\"%s: circular name reference\",*param_1);\n      if ((variable_context != 0) && (*(int *)((long)puVar2 + 0x2c) != 0)) {\n        puVar3 = (undefined8 *)find_global_variable_noref(*puVar2);\n        return puVar3;\n      }\n      return (undefined8 *)0x0;\n    }\n  }\n  return (undefined8 *)0x0;\n}\n\n",
  "FUN_00156bc0": "\nvoid FUN_00156bc0(void)\n\n{\n  undefined4 uVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  long lVar5;\n  int iVar6;\n  \n  if (export_env != (undefined8 *)0x0) {\n    strvec_flush();\n  }\n  iVar6 = 0;\n  for (puVar2 = shell_variables; puVar2 != (undefined8 *)0x0; puVar2 = (undefined8 *)puVar2[3]) {\n    if (puVar2[4] != 0) {\n      iVar6 = iVar6 + *(int *)(puVar2[4] + 0xc);\n    }\n  }\n  if (shell_functions != 0) {\n    iVar6 = iVar6 + *(int *)(shell_functions + 0xc);\n  }\n  iVar6 = iVar6 + 1;\n  if (temporary_env != 0) {\n    iVar6 = iVar6 + *(int *)(temporary_env + 0xc);\n  }\n  if (invalid_env != 0) {\n    iVar6 = iVar6 + *(int *)(invalid_env + 0xc);\n  }\n  if (DAT_00242330 < iVar6) {\n    DAT_00242330 = iVar6;\n    environ = (undefined8 *)strvec_resize();\n    export_env = environ;\n  }\n  lVar4 = temporary_env;\n  *export_env = 0;\n  DAT_00242334 = 0;\n  puVar2 = shell_variables;\n  if (lVar4 != 0) {\n    puVar2 = (undefined8 *)sh_xmalloc(0x28,\"variables.c\",0x146b);\n    *puVar2 = 0;\n    uVar1 = variable_context;\n    *(undefined4 *)((long)puVar2 + 0xc) = 0;\n    *(undefined4 *)(puVar2 + 1) = uVar1;\n    lVar4 = temporary_env;\n    puVar2[2] = 0;\n    puVar2[4] = lVar4;\n    puVar2[3] = shell_variables;\n  }\n  if (invalid_env == 0) {\n    lVar4 = map_over(FUN_001512b0,puVar2);\n    if (lVar4 == 0) goto LAB_00156d5f;\n    lVar5 = FUN_00151a90(lVar4);\n    sh_xfree(lVar4,\"variables.c\",0x1370);\n    puVar3 = puVar2;\n    if (lVar5 == 0) goto LAB_00156d5f;\nLAB_00156d42:\n    FUN_00151fa0(lVar5);\n  }\n  else {\n    puVar3 = (undefined8 *)sh_xmalloc(0x28,\"variables.c\",0x146b);\n    *puVar3 = 0;\n    uVar1 = variable_context;\n    *(undefined4 *)((long)puVar3 + 0xc) = 0;\n    *(undefined4 *)(puVar3 + 1) = uVar1;\n    lVar4 = invalid_env;\n    puVar3[2] = 0;\n    puVar3[4] = lVar4;\n    puVar3[3] = puVar2;\n    lVar4 = map_over(FUN_001512b0,puVar3);\n    if (lVar4 != 0) {\n      lVar5 = FUN_00151a90(lVar4);\n      sh_xfree(lVar4,\"variables.c\",0x1370);\n      if (lVar5 != 0) goto LAB_00156d42;\n    }\n  }\n  if (puVar3 != puVar2) {\n    sh_xfree(puVar3,\"variables.c\",0x1429);\n  }\nLAB_00156d5f:\n  if (puVar2 != shell_variables) {\n    sh_xfree(puVar2,\"variables.c\",0x142c);\n  }\n  if ((restricted == 0) && (lVar4 = map_over_funcs(FUN_00151290), lVar4 != 0)) {\n    lVar5 = FUN_00151a90(lVar4);\n    sh_xfree(lVar4,\"variables.c\",0x1380);\n    if (lVar5 != 0) {\n      FUN_00151fa0(lVar5);\n    }\n  }\n  array_needs_making = 0;\n  return;\n}\n\n",
  "echo_builtin": "\nvoid echo_builtin(long **param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  bool bVar3;\n  uint uVar4;\n  FILE *__stream;\n  char cVar5;\n  char *pcVar6;\n  char *pcVar7;\n  size_t sVar8;\n  byte *pbVar9;\n  ulong uVar10;\n  int iVar11;\n  long lVar12;\n  long in_FS_OFFSET;\n  uint local_48;\n  int local_44;\n  long local_40;\n  \n  iVar11 = xpg_echo;\n  __stream = stdout;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((posixly_correct == 0) || (xpg_echo == 0)) {\n    if (param_1 != (long **)0x0) {\n      bVar3 = true;\n      do {\n        pcVar7 = (char *)*param_1[1];\n        if ((pcVar7 == (char *)0x0) || (*pcVar7 != '-')) {\nLAB_001a6fa8:\n          clearerr(__stream);\n          goto LAB_001a6fb0;\n        }\n        local_48 = 0;\n        cVar5 = pcVar7[1];\n        if (cVar5 == '\\0') goto LAB_001a6fa8;\n        lVar12 = 1;\n        do {\n          pcVar6 = strchr(\"neE\",(int)cVar5);\n          if (pcVar6 == (char *)0x0) goto LAB_001a6fa8;\n          local_48 = (uint)lVar12;\n          lVar12 = lVar12 + 1;\n          cVar5 = pcVar7[lVar12];\n        } while (cVar5 != '\\0');\n        bVar1 = pcVar7[1];\n        if (bVar1 == 0) goto LAB_001a6fa8;\n        local_48 = (uint)(char)bVar1;\n        pbVar9 = (byte *)(pcVar7 + 2);\n        uVar4 = (uint)bVar1;\n        while (bVar1 != 0) {\n          cVar5 = (char)uVar4;\n          if (cVar5 == 'e') {\n            iVar11 = 1;\n          }\n          else if (cVar5 == 'n') {\n            bVar3 = false;\n          }\n          else {\n            if (cVar5 != 'E') goto LAB_001a6fa8;\n            iVar11 = 0;\n          }\n          bVar1 = *pbVar9;\n          local_48 = (uint)(char)bVar1;\n          pbVar9 = pbVar9 + 1;\n          uVar4 = local_48;\n        }\n        param_1 = (long **)*param_1;\n      } while (param_1 != (long **)0x0);\n      clearerr(__stream);\n      goto LAB_001a70d4;\n    }\n    clearerr(stdout);\n  }\n  else {\n    clearerr(stdout);\n    bVar3 = true;\n    if (param_1 != (long **)0x0) {\nLAB_001a6fb0:\n      do {\n        local_44 = 0;\n        local_48 = 0;\n        pcVar7 = (char *)*param_1[1];\n        if (iVar11 == 0) {\n          if (pcVar7 != (char *)0x0) {\n            __printf_chk(1,&DAT_002102da,pcVar7);\n          }\n          bVar2 = false;\n          if (terminating_signal == 0) goto LAB_001a7077;\nLAB_001a714c:\n          termsig_handler(terminating_signal);\n          if (interrupt_state == 0) goto LAB_001a7085;\nLAB_001a7165:\n          throw_to_top_level();\n          if (bVar2) goto LAB_001a7173;\n        }\n        else {\n          uVar10 = 0;\n          if ((((pcVar7 != (char *)0x0) && (*pcVar7 != '\\0')) && (uVar10 = 1, pcVar7[1] != '\\0')) &&\n             (uVar10 = 2, pcVar7[2] != '\\0')) {\n            sVar8 = strlen(pcVar7);\n            uVar10 = sVar8 & 0xffffffff;\n          }\n          pcVar7 = (char *)ansicstr(pcVar7,uVar10,1,&local_48,&local_44);\n          bVar2 = false;\n          pcVar6 = pcVar7;\n          if (pcVar7 != (char *)0x0) {\n            for (; 0 < local_44; local_44 = local_44 + -1) {\n              putc((int)*pcVar6,stdout);\n              pcVar6 = pcVar6 + 1;\n            }\n            bVar2 = true;\n          }\n          if (terminating_signal != 0) goto LAB_001a714c;\nLAB_001a7077:\n          if (interrupt_state != 0) goto LAB_001a7165;\nLAB_001a7085:\n          if (bVar2) {\nLAB_001a7173:\n            sh_xfree(pcVar7,\"./echo.def\",0xba);\n          }\n        }\n        param_1 = (long **)*param_1;\n        if (local_48 != 0) goto LAB_001a70ed;\n        if (param_1 != (long **)0x0) {\n          putc(0x20,stdout);\n        }\n        if (terminating_signal != 0) {\n          termsig_handler(terminating_signal);\n        }\n        if (interrupt_state != 0) {\n          throw_to_top_level();\n        }\n      } while (param_1 != (long **)0x0);\nLAB_001a70d4:\n      if (!bVar3) goto LAB_001a70ed;\n    }\n  }\n  putc(10,stdout);\nLAB_001a70ed:\n  sh_chkwrite(0);\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "clear_history": "\nvoid clear_history(void)\n\n{\n  void **ppvVar1;\n  int iVar2;\n  long *plVar3;\n  long lVar4;\n  long lVar5;\n  \n  lVar5 = 0;\n  lVar4 = DAT_0024b6e8;\n  if (0 < history_length) {\n    do {\n      plVar3 = (long *)(lVar4 + lVar5 * 8);\n      ppvVar1 = (void **)*plVar3;\n      if (ppvVar1 != (void **)0x0) {\n        if (*ppvVar1 != (void *)0x0) {\n          free(*ppvVar1);\n        }\n        if (ppvVar1[1] != (void *)0x0) {\n          free(ppvVar1[1]);\n        }\n        xfree(ppvVar1);\n        plVar3 = (long *)(DAT_0024b6e8 + lVar5 * 8);\n        lVar4 = DAT_0024b6e8;\n      }\n      iVar2 = history_length;\n      lVar5 = lVar5 + 1;\n      *plVar3 = 0;\n    } while ((int)lVar5 < iVar2);\n  }\n  history_length = 0;\n  history_offset = 0;\n  history_base = 1;\n  return;\n}\n\n",
  "sh_erange": "\nvoid sh_erange(long param_1,char *param_2)\n\n{\n  if (param_2 == (char *)0x0) {\n    param_2 = \"argument\";\n  }\n  if (param_1 != 0) {\n    builtin_error(\"%s: %s out of range\",param_1);\n    return;\n  }\n  builtin_error(\"%s out of range\",param_2);\n  return;\n}\n\n",
  "push_scope": "\nundefined8 * push_scope(undefined4 param_1,long param_2)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  \n  puVar4 = (undefined8 *)sh_xmalloc(0x28,\"variables.c\",0x146b);\n  *puVar4 = 0;\n  uVar1 = variable_context;\n  *(undefined4 *)((long)puVar4 + 0xc) = param_1;\n  *(undefined4 *)(puVar4 + 1) = uVar1;\n  puVar4[3] = 0;\n  puVar4[2] = 0;\n  if (param_2 == 0) {\n    puVar4[4] = 0;\n  }\n  else {\n    puVar4[4] = param_2;\n    FUN_00152050(param_2,FUN_00151390,0);\n    *(uint *)((long)puVar4 + 0xc) = *(uint *)((long)puVar4 + 0xc) | 2;\n  }\n  lVar2 = (long)shell_variables;\n  puVar3 = puVar4;\n  puVar4[3] = shell_variables;\n  shell_variables = puVar3;\n  *(undefined8 **)(lVar2 + 0x10) = puVar4;\n  return puVar4;\n}\n\n",
  "FUN_001eedd0": "\nundefined8 FUN_001eedd0(int param_1,int param_2)\n\n{\n  bool bVar1;\n  wchar_t __wc;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  wchar_t __wc_00;\n  ushort **ppuVar6;\n  __int32_t **pp_Var7;\n  size_t sVar8;\n  long lVar9;\n  size_t sVar10;\n  char *__s;\n  int iVar11;\n  void *pvVar12;\n  ulong uVar13;\n  int iVar14;\n  int iVar15;\n  long in_FS_OFFSET;\n  int local_98;\n  wchar_t local_6c;\n  mbstate_t local_68;\n  mbstate_t local_60;\n  char local_58 [24];\n  long local_40;\n  \n  iVar14 = rl_point;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 < 0) {\n    FUN_001edaf0(-param_1);\n    iVar11 = rl_point;\n  }\n  else {\n    FUN_001edc60();\n    iVar11 = iVar14;\n    iVar14 = rl_point;\n  }\n  local_68.__count = 0;\n  local_68.__value = (_union_27)0x0;\n  rl_modifying(iVar11,iVar14);\n  if (iVar11 < iVar14) {\n    bVar1 = false;\n    do {\n      while( true ) {\n        uVar3 = _rl_char_value(rl_line_buffer,iVar11);\n        uVar13 = (ulong)uVar3;\n        sVar8 = __ctype_get_mb_cur_max();\n        if ((sVar8 < 2) || (rl_byte_oriented != 0)) {\n          iVar5 = iVar11 + 1;\n        }\n        else {\n          iVar5 = _rl_find_next_mbchar(rl_line_buffer,iVar11,1,1);\n        }\n        iVar4 = _rl_walphabetic(uVar13);\n        if (iVar4 != 0) break;\n        bVar1 = false;\n        iVar11 = iVar5;\n        if (iVar14 <= iVar5) goto LAB_001eeee0;\n      }\n      if (param_2 == 3) {\n        if (bVar1) {\n          sVar8 = __ctype_get_mb_cur_max();\n          if ((sVar8 == 1) || (rl_byte_oriented != 0)) goto LAB_001eee5d;\n          local_98 = 2;\n        }\n        else {\n          sVar8 = __ctype_get_mb_cur_max();\n          bVar1 = true;\n          if ((sVar8 == 1) || (rl_byte_oriented != 0)) goto LAB_001eef7f;\n          local_98 = 1;\n        }\nLAB_001eefb4:\n        lVar9 = (long)iVar11;\n        sVar8 = mbrtowc(&local_6c,(char *)(rl_line_buffer + lVar9),(long)(iVar14 - iVar11),&local_68\n                       );\n        if (sVar8 < 0xfffffffffffffffe) {\n          if (sVar8 == 0) {\n            local_6c = L'\\0';\n          }\n          if (local_98 == 1) goto LAB_001ef152;\nLAB_001ef00d:\n          __wc = local_6c;\n          iVar4 = iswupper(local_6c);\n          if (iVar4 == 0) goto LAB_001eee94;\n          __wc_00 = towlower(__wc);\n        }\n        else {\n          local_6c = (wchar_t)*(char *)(rl_line_buffer + lVar9);\n          if (local_98 != 1) goto LAB_001ef00d;\nLAB_001ef152:\n          __wc = local_6c;\n          iVar4 = iswlower(local_6c);\n          if (iVar4 == 0) goto LAB_001eee94;\n          __wc_00 = towupper(__wc);\n        }\n        if (__wc_00 != __wc) {\n          __s = local_58;\n          local_60.__count = 0;\n          local_60.__value = (_union_27)0x0;\n          sVar10 = wcrtomb(__s,__wc_00,&local_60);\n          iVar4 = (int)sVar10;\n          iVar15 = (int)sVar8;\n          if (iVar4 < 0) {\n            local_60.__count = 0;\n            local_60.__value = (_union_27)0x0;\n            sVar10 = wcrtomb(__s,local_6c,&local_60);\n            iVar4 = (int)sVar10;\n            if (-1 < iVar4) goto LAB_001ef061;\n            uVar13 = (ulong)iVar15;\n            pvVar12 = (void *)(lVar9 + rl_line_buffer);\n            __s = (char *)__strncpy_chk(__s,pvVar12,uVar13,0x11);\n            iVar4 = iVar15;\n          }\n          else {\nLAB_001ef061:\n            uVar13 = (ulong)iVar4;\n            pvVar12 = (void *)(lVar9 + rl_line_buffer);\n          }\n          iVar2 = rl_end;\n          if (0 < iVar4) {\n            local_58[iVar4] = '\\0';\n          }\n          if (sVar8 == uVar13) {\n            memcpy(pvVar12,__s,sVar8);\n          }\n          else {\n            if (uVar13 < sVar8) {\n              memcpy(pvVar12,__s,uVar13);\n              memmove((void *)((long)pvVar12 + uVar13),(void *)((long)pvVar12 + sVar8),\n                      (iVar2 - lVar9) - sVar8);\n            }\n            else {\n              if (uVar13 <= sVar8) goto LAB_001eee94;\n              rl_extend_line_buffer((((rl_end * 2 - iVar11) + 2) - iVar15) + iVar4);\n              pvVar12 = (void *)(lVar9 + rl_line_buffer);\n              memmove((void *)((long)pvVar12 + uVar13),(void *)((long)pvVar12 + sVar8),\n                      (rl_end - lVar9) - sVar8);\n              memcpy(pvVar12,__s,uVar13);\n            }\n            iVar4 = iVar4 - iVar15;\n            iVar14 = iVar14 + iVar4;\n            rl_end = iVar4 + rl_end;\n            *(undefined *)(rl_line_buffer + rl_end) = 0;\n            iVar5 = iVar5 + iVar4;\n          }\n        }\n      }\n      else {\n        sVar8 = __ctype_get_mb_cur_max();\n        if ((sVar8 != 1) && (local_98 = param_2, rl_byte_oriented == 0)) goto LAB_001eefb4;\n        if (param_2 == 1) {\nLAB_001eef7f:\n          ppuVar6 = __ctype_b_loc();\n          if ((*(byte *)((long)*ppuVar6 + (uVar13 & 0xff) * 2 + 1) & 2) != 0) {\n            pp_Var7 = __ctype_toupper_loc();\n            uVar13 = (ulong)(uint)(*pp_Var7)[uVar13 & 0xff];\n          }\n        }\n        else {\nLAB_001eee5d:\n          ppuVar6 = __ctype_b_loc();\n          if ((*(byte *)((long)*ppuVar6 + (uVar13 & 0xff) * 2 + 1) & 1) != 0) {\n            pp_Var7 = __ctype_tolower_loc();\n            uVar13 = (ulong)(uint)(*pp_Var7)[uVar13 & 0xff];\n          }\n        }\n        *(char *)(rl_line_buffer + iVar11) = (char)uVar13;\n      }\nLAB_001eee94:\n      iVar11 = iVar5;\n    } while (iVar11 < iVar14);\n  }\nLAB_001eeee0:\n  rl_point = iVar14;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 0;\n}\n\n",
  "hash_string": "\nvoid hash_string(char *param_1)\n\n{\n  if (*param_1 != '\\0') {\n    do {\n      param_1 = param_1 + 1;\n    } while (*param_1 != '\\0');\n    return;\n  }\n  return;\n}\n\n",
  "expand_words_shellexp": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 expand_words_shellexp(long param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  tempenv_assign_error = 0;\n  if (param_1 == 0) {\n    return 0;\n  }\n  _DAT_00247840 = copy_word_list();\n  if ((brace_expansion == 0) || (_DAT_00247840 == 0)) {\n    lVar1 = FUN_0017a460();\n  }\n  else {\n    uVar2 = FUN_00168ba0();\n    lVar1 = FUN_0017a460(uVar2);\n  }\n  if (lVar1 != 0) {\n    uVar2 = dequote_list(lVar1);\n    return uVar2;\n  }\n  return 0;\n}\n\n",
  "read_history": "\nvoid read_history(undefined8 param_1)\n\n{\n  read_history_range(param_1,0,0xffffffff);\n  return;\n}\n\n",
  "dollar_vars_changed": "\nundefined4 dollar_vars_changed(void)\n\n{\n  return DAT_00248a98;\n}\n\n",
  "ansiexpand": "\nchar * ansiexpand(long param_1,int param_2,int param_3,undefined4 *param_4)\n\n{\n  char *pcVar1;\n  long lVar2;\n  char *pcVar3;\n  int iVar4;\n  \n  iVar4 = param_3 - param_2;\n  pcVar1 = (char *)sh_xmalloc((long)(iVar4 + 1),\"strtrans.c\",0x17f);\n  if (param_2 < param_3) {\n    lVar2 = (long)param_2;\n    do {\n      pcVar1[lVar2 - param_2] = *(char *)(param_1 + lVar2);\n      lVar2 = lVar2 + 1;\n    } while ((int)lVar2 < param_3);\n    pcVar3 = pcVar1 + iVar4;\n  }\n  else {\n    iVar4 = 0;\n    pcVar3 = pcVar1;\n  }\n  *pcVar3 = '\\0';\n  if (*pcVar1 == '\\0') {\n    pcVar3 = pcVar1;\n    if (param_4 != (undefined4 *)0x0) {\n      *param_4 = 0;\n    }\n  }\n  else {\n    pcVar3 = (char *)FUN_001c9490(pcVar1,iVar4,2,0);\n    sh_xfree(pcVar1,\"strtrans.c\",0x187);\n  }\n  return pcVar3;\n}\n\n",
  "signal_is_hard_ignored": "\nuint signal_is_hard_ignored(int param_1)\n\n{\n  return (&DAT_00247e40)[param_1] & 2;\n}\n\n",
  "FUN_001da580": "\nundefined8 FUN_001da580(char *param_1)\n\n{\n  long lVar1;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    lVar1 = strtol(param_1,(char **)0x0,10);\n    rl_completion_query_items = (int)lVar1;\n    if (rl_completion_query_items < 0) {\n      rl_completion_query_items = 0;\n    }\n    return 0;\n  }\n  rl_completion_query_items = 100;\n  return 0;\n}\n\n",
  "_rl_push_executing_macro": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid _rl_push_executing_macro(void)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar2 = (undefined8 *)xmalloc(0x18);\n  _DAT_0024b180 = _DAT_0024b180 + 1;\n  puVar1 = puVar2;\n  *puVar2 = DAT_0024b188;\n  DAT_0024b188 = puVar1;\n  *(undefined4 *)(puVar2 + 2) = DAT_0024b1a0;\n  puVar2[1] = rl_executing_macro;\n  return;\n}\n\n",
  "FUN_00152550": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong FUN_00152550(long param_1)\n\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  timeval local_38;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  gettimeofday(&local_38,(__timezone_ptr_t)0x0);\n  uVar1 = itos((local_38.tv_sec - shell_start_time) + _DAT_002422f0);\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x527);\n  }\n  *(uint *)(param_1 + 0x28) = *(uint *)(param_1 + 0x28) | 0x10;\n  *(undefined8 *)(param_1 + 8) = uVar1;\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001b4200": "\nvoid FUN_001b4200(void)\n\n{\n  set_signal_handler(0x12,DAT_00248c10);\n  return;\n}\n\n",
  "sh_nojobs": "\nvoid sh_nojobs(long param_1)\n\n{\n  if (param_1 != 0) {\n    builtin_error(\"%s: no job control\",param_1);\n    return;\n  }\n  builtin_error(\"no job control\",0);\n  return;\n}\n\n",
  "FUN_00133ad0": "\nvoid FUN_00133ad0(void)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar1 = exit_immediately_on_error;\n  exit_immediately_on_error = 0;\n  iVar2 = force_execute_file(\"/usr/local/share/bashdb/bashdb-main.inc\",1);\n  if (iVar2 < 0) {\n    internal_warning(\"cannot start debugger; debugging mode disabled\");\n    debugging_mode = 0;\n  }\n  function_trace_mode = debugging_mode;\n  error_trace_mode = debugging_mode;\n  set_shellopts();\n  set_bashopts();\n  exit_immediately_on_error = exit_immediately_on_error + iVar1;\n  return;\n}\n\n",
  "xmbsrtowcs": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong xmbsrtowcs(wchar_t *param_1,char **param_2,long param_3,mbstate_t *param_4)\n\n{\n  wchar_t wVar1;\n  char *pcVar2;\n  int iVar3;\n  size_t __n;\n  ulong uVar4;\n  void *__ptr;\n  long lVar5;\n  long in_FS_OFFSET;\n  char *local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_4 == (mbstate_t *)0x0) && (param_4 = (mbstate_t *)&DAT_00248e88, DAT_00248e80 == 0)) {\n    _DAT_00248e88 = 0;\n    DAT_00248e80 = 1;\n  }\n  pcVar2 = *param_2;\n  __n = strlen(pcVar2);\n  if (param_1 == (wchar_t *)0x0) {\n    __ptr = malloc(__n * 4 + 4);\n    local_48 = *param_4;\n    local_50 = pcVar2;\n    lVar5 = __mbsrtowcs_chk(__ptr,&local_50,__n,&local_48,0x3fffffffffffffff);\n    if (__ptr != (void *)0x0) {\n      free(__ptr);\n    }\n  }\n  else {\n    lVar5 = 0;\n    if (param_3 != 0) {\n      do {\n        iVar3 = mbsinit(param_4);\n        if (iVar3 == 0) {\n          uVar4 = mbrtowc(param_1,*param_2,__n,param_4);\njoined_r0x001c36da:\n          if (0xfffffffffffffffd < uVar4) {\n            lVar5 = -1;\n            break;\n          }\n          wVar1 = *param_1;\n          __n = __n - uVar4;\n          *param_2 = *param_2 + uVar4;\n          if (wVar1 == L'\\0') {\n            *param_2 = (char *)0x0;\n            break;\n          }\n        }\n        else {\n          pcVar2 = *param_2;\n          if (*pcVar2 == '\\0') {\n            *param_1 = L'\\0';\n            *param_2 = (char *)0x0;\n            break;\n          }\n          if (*pcVar2 != '\\\\') {\n            uVar4 = mbrtowc(param_1,pcVar2,__n,param_4);\n            goto joined_r0x001c36da;\n          }\n          *param_1 = L'\\\\';\n          __n = __n - 1;\n          *param_2 = pcVar2 + 1;\n        }\n        lVar5 = lVar5 + 1;\n        param_1 = param_1 + 1;\n      } while (param_3 != lVar5);\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "memalign": "\nulong memalign(long param_1,long param_2)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  \n  uVar1 = FUN_001f85f0(param_1 + param_2,0,0);\n  uVar2 = uVar1;\n  if ((uVar1 != 0) && ((uVar1 & param_1 - 1U) != 0)) {\n    uVar2 = (param_1 - 1U) + uVar1 & -param_1;\n    *(undefined *)(uVar2 - 0x10) = 0xd6;\n    *(int *)(uVar2 - 0xc) = (int)uVar2 - (int)uVar1;\n  }\n  return uVar2;\n}\n\n",
  "rl_copy_region_to_kill": "\nundefined8 rl_copy_region_to_kill(void)\n\n{\n  undefined8 uVar1;\n  \n  if (rl_mark != rl_point) {\n    uVar1 = rl_copy_text();\n    FUN_001e9370(uVar1,rl_point < rl_mark);\n  }\n  _rl_fix_point(1);\n  _rl_last_command_was_kill = _rl_last_command_was_kill + 1;\n  return 0;\n}\n\n",
  "rl_capitalize_word": "\nvoid rl_capitalize_word(undefined8 param_1)\n\n{\n  FUN_001eedd0(param_1,3);\n  return;\n}\n\n",
  "rl_vi_editing_mode": "\nundefined8 rl_vi_editing_mode(void)\n\n{\n  rl_insert_mode = 1;\n  rl_editing_mode = 0;\n  rl_vi_insert_mode(1);\n  return 0;\n}\n\n",
  "FUN_0019b8d0": "\nvoid FUN_0019b8d0(char *param_1,undefined4 param_2)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *pcVar3;\n  \n  lVar1 = find_variable_tempenv(\"PATH\");\n  if (((lVar1 != 0) && (pcVar3 = *(char **)(lVar1 + 8), pcVar3 != (char *)0x0)) && (*pcVar3 != '\\0')\n     ) {\n    FUN_0019b620(param_1,pcVar3,param_2,0);\n    return;\n  }\n  sVar2 = strlen(param_1);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"findcmd.c\",0x113);\n  strcpy(pcVar3,param_1);\n  return;\n}\n\n",
  "array_flush": "\nvoid array_flush(undefined8 *param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    return;\n  }\n  lVar2 = *(long *)(param_1[2] + 0x10);\n  lVar1 = lVar2;\n  if (param_1[2] != lVar2) {\n    do {\n      lVar2 = *(long *)(lVar1 + 0x10);\n      if (*(long *)(lVar1 + 8) != 0) {\n        sh_xfree(*(long *)(lVar1 + 8),\"array.c\",0x21e);\n      }\n      sh_xfree(lVar1,\"array.c\",0x21f);\n      lVar1 = lVar2;\n    } while (param_1[2] != lVar2);\n  }\n  *(long *)(lVar2 + 0x18) = lVar2;\n  *(long *)(lVar2 + 0x10) = lVar2;\n  *param_1 = 0xffffffffffffffff;\n  param_1[1] = 0;\n  param_1[3] = 0;\n  return;\n}\n\n",
  "list_length": "\nint list_length(long *param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = 0;\n  if (param_1 == (long *)0x0) {\n    return 0;\n  }\n  do {\n    param_1 = (long *)*param_1;\n    iVar1 = iVar1 + 1;\n  } while (param_1 != (long *)0x0);\n  return iVar1;\n}\n\n",
  "find_in_path": "\nvoid find_in_path(void)\n\n{\n  FUN_0019b620();\n  return;\n}\n\n",
  "start_pipeline": "\nvoid start_pipeline(void)\n\n{\n  int iVar1;\n  \n  if (the_pipeline != 0) {\n    cleanup_the_pipeline();\n    if (pipeline_pgrp != shell_pgrp) {\n      pipeline_pgrp = 0;\n    }\n    sh_closepipe(&pgrp_pipe);\n  }\n  if (job_control != 0) {\n    iVar1 = pipe(&pgrp_pipe);\n    if (iVar1 == -1) {\n      sys_error(\"start_pipeline: pgrp pipe\");\n      return;\n    }\n  }\n  return;\n}\n\n",
  "FUN_001354e0": "\nvoid FUN_001354e0(void)\n\n{\n  ulong uVar1;\n  undefined uVar2;\n  int iVar3;\n  size_t sVar4;\n  ulong uVar5;\n  size_t __n;\n  ulong uVar6;\n  long in_FS_OFFSET;\n  bool bVar7;\n  mbstate_t local_40;\n  mbstate_t local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((DAT_00240da8 != (char *)0x0) && (*DAT_00240da8 != '\\0')) {\n    if (DAT_00240da8[1] == '\\0') {\n      uVar5 = 2;\n      __n = 1;\n      if (0x7fff < DAT_00240e40) goto LAB_00135545;\nLAB_001355ee:\n      if (DAT_00240e40 < uVar5) goto LAB_0013556d;\n    }\n    else {\n      if (DAT_00240da8[2] == '\\0') {\n        uVar5 = 3;\n        __n = 2;\n        if (DAT_00240e40 < 0x8000) goto LAB_001355ee;\n      }\n      else {\n        __n = strlen(DAT_00240da8);\n        if (__n == 0) goto LAB_001355af;\n        uVar5 = __n + 1;\n        if ((0x3fff < __n) || (DAT_00240e40 < 0x8000)) goto LAB_001355ee;\n      }\nLAB_00135545:\n      sh_xfree(DAT_00240e48,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1a5c);\n      DAT_00240e48 = (void *)0x0;\nLAB_0013556d:\n      DAT_00240e40 = uVar5;\n      DAT_00240e48 = (void *)sh_xrealloc(DAT_00240e48,uVar5,\n                                         \"/usr/local/src/chet/src/bash/src/parse.y\",0x1a63);\n    }\n    if (locale_mb_cur_max == 1) {\n      if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n        memset(DAT_00240e48,1,__n);\n        return;\n      }\n      goto LAB_001357b6;\n    }\n    if (locale_utf8locale == 0) {\n      local_38.__count = 0;\n      local_38.__value = (_union_27)0x0;\n    }\n    uVar6 = 0;\n    uVar5 = 1;\n    do {\n      uVar1 = uVar5 - 1;\n      if (locale_utf8locale == 0) {\n        local_40 = local_38;\n        if (DAT_00240da8[uVar1] == -1) goto LAB_00135590;\n        sVar4 = mbrtowc((wchar_t *)0x0,DAT_00240da8 + uVar6,uVar5 - uVar6,&local_40);\n        if ((sVar4 == 1) || (sVar4 == 0xffffffffffffffff)) goto LAB_00135700;\n        uVar2 = 0;\n        if (sVar4 != 0xfffffffffffffffe) {\nLAB_001356d5:\n          if (sVar4 < 2) goto LAB_00135590;\n          uVar6 = uVar5;\n          if (locale_utf8locale != 0) goto LAB_00135713;\n          local_38 = local_40;\n          uVar2 = 0;\n        }\n      }\n      else {\n        if (DAT_00240da8[uVar1] == -1) {\nLAB_00135590:\n          if (uVar1 < __n) {\n            memset((void *)((long)DAT_00240e48 + uVar1),1,__n - uVar1);\n          }\n          break;\n        }\n        if ((DAT_00240da8[uVar6] < '\\0') &&\n           (iVar3 = utf8_mblen(DAT_00240da8 + uVar6,uVar5 - uVar6), iVar3 != -1)) {\n          if (iVar3 == -2) {\nLAB_00135713:\n            uVar2 = 0;\n            goto LAB_00135670;\n          }\n          sVar4 = (size_t)iVar3;\n          if (iVar3 != 1) goto LAB_001356d5;\n        }\nLAB_00135700:\n        uVar2 = 1;\n        uVar6 = uVar5;\n      }\nLAB_00135670:\n      *(undefined *)((long)DAT_00240e48 + uVar1) = uVar2;\n      bVar7 = uVar5 < __n;\n      uVar5 = uVar5 + 1;\n    } while (bVar7);\n  }\nLAB_001355af:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\nLAB_001357b6:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "get_shopt_options": "\nlong get_shopt_options(void)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *__dest;\n  int iVar3;\n  long lVar4;\n  char **ppcVar5;\n  char *pcVar6;\n  \n  pcVar6 = \"autocd\";\n  lVar4 = 1;\n  lVar1 = strvec_create(0x3b);\n  sVar2 = 6;\n  ppcVar5 = &PTR_s_assoc_expand_once_00236438;\n  while( true ) {\n    __dest = (char *)sh_xmalloc(sVar2 + 1,\"./shopt.def\",0x308);\n    pcVar6 = strcpy(__dest,pcVar6);\n    *(char **)(lVar1 + -8 + lVar4 * 8) = pcVar6;\n    pcVar6 = *ppcVar5;\n    iVar3 = (int)lVar4;\n    lVar4 = lVar4 + 1;\n    if (pcVar6 == (char *)0x0) break;\n    sVar2 = strlen(pcVar6);\n    ppcVar5 = ppcVar5 + 3;\n  }\n  *(undefined8 *)(lVar1 + (long)iVar3 * 8) = 0;\n  return lVar1;\n}\n\n",
  "rl_noninc_reverse_search_again": "\nbool rl_noninc_reverse_search_again(undefined8 param_1,int param_2)\n\n{\n  int iVar1;\n  bool bVar2;\n  \n  if (DAT_0024a480 == 0) {\n    rl_ding();\n    bVar2 = true;\n  }\n  else {\n    if (((rl_editing_mode == 0) && (_rl_keymap == vi_movement_keymap)) && (param_2 == 0x6e)) {\n      iVar1 = FUN_001d4610(DAT_0024a480,0xffffffff,0x10);\n    }\n    else {\n      iVar1 = FUN_001d4610(DAT_0024a480,0xffffffff,0);\n    }\n    bVar2 = iVar1 != 1;\n  }\n  return bVar2;\n}\n\n",
  "parser_will_prompt": "\nbool parser_will_prompt(void)\n\n{\n  bool bVar1;\n  \n  bVar1 = true;\n  if (current_readline_line != 0) {\n    bVar1 = *(char *)(current_readline_line + current_readline_line_index) == '\\0';\n  }\n  return bVar1;\n}\n\n",
  "FUN_001bdca0": "\nvoid FUN_001bdca0(char *param_1)\n\n{\n  wchar_t *pwVar1;\n  long lVar2;\n  size_t __len;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  wchar_t *local_40;\n  mbstate_t local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = mbsmbchar();\n  if (lVar2 != 0) {\n    __len = strlen(param_1);\n    lVar2 = xdupmbstowcs(&local_40,0,param_1);\n    pwVar1 = local_40;\n    if (lVar2 != -1) {\n      wcdequote_pathname(local_40);\n      local_38.__count = 0;\n      local_38.__value = (_union_27)0x0;\n      sVar3 = wcsrtombs(param_1,&local_40,__len,&local_38);\n      if ((sVar3 == 0xffffffffffffffff) || ((local_40 != (wchar_t *)0x0 && (*local_40 != L'\\0')))) {\n        local_38.__count = 0;\n        local_38.__value = (_union_27)0x0;\n        xwcsrtombs(param_1,&local_40,__len,&local_38);\n      }\n      param_1[__len] = '\\0';\n      sh_xfree(pwVar1,\"glob.c\",0x219);\n      goto LAB_001bdd4f;\n    }\n  }\n  udequote_pathname(param_1);\nLAB_001bdd4f:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00195250": "\nvoid FUN_00195250(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined4 uVar4;\n  \n  uVar4 = rl_completion_mode(FUN_00195250);\n  uVar3 = rl_completion_entry_function;\n  uVar2 = rl_attempted_completion_function;\n  uVar1 = rl_ignore_some_completions_function;\n  rl_attempted_completion_function = 0;\n  rl_completion_entry_function = FUN_00192f60;\n  rl_complete_internal(uVar4);\n  rl_completion_entry_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar2;\n  rl_ignore_some_completions_function = uVar1;\n  return;\n}\n\n",
  "close_buffered_fd": "\nint close_buffered_fd(int param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if (-1 < param_1) {\n    if ((param_1 < DAT_00247f64) && (DAT_00247f68 != 0)) {\n      piVar2 = *(int **)(DAT_00247f68 + (long)param_1 * 8);\n      if (piVar2 != (int *)0x0) {\n        param_1 = *piVar2;\n        if ((*(byte *)(piVar2 + 8) & 0x20) != 0) {\n          *(undefined8 *)(piVar2 + 2) = 0;\n        }\n        free_buffered_stream(piVar2);\n      }\n    }\n    iVar1 = close(param_1);\n    return iVar1;\n  }\n  piVar2 = __errno_location();\n  *piVar2 = 9;\n  return -1;\n}\n\n",
  "local_builtin": "\nundefined8 local_builtin(long param_1)\n\n{\n  char *__s1;\n  int iVar1;\n  undefined8 uVar2;\n  \n  if (((param_1 != 0) && (*(char ***)(param_1 + 8) != (char **)0x0)) &&\n     (__s1 = **(char ***)(param_1 + 8), *__s1 == '-')) {\n    iVar1 = strcmp(__s1,\"--help\");\n    if (iVar1 == 0) {\n      builtin_help();\n      return 0x102;\n    }\n  }\n  if (variable_context != 0) {\n    uVar2 = FUN_001a51a0(param_1,1);\n    return uVar2;\n  }\n  builtin_error(\"can only be used in a function\");\n  return 1;\n}\n\n",
  "rl_vi_insertion_mode": "\nundefined8 rl_vi_insertion_mode(undefined8 param_1,undefined4 param_2)\n\n{\n  DAT_0024a3c8 = param_2;\n  _rl_keymap = &vi_insertion_keymap;\n  if (_rl_show_mode_in_prompt == 0) {\n    return 0;\n  }\n  _rl_reset_prompt();\n  return 0;\n}\n\n",
  "FUN_0016e2d0": "\nvoid FUN_0016e2d0(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined *puVar2;\n  size_t sVar3;\n  size_t sVar4;\n  ulong uVar5;\n  undefined *puVar6;\n  long in_FS_OFFSET;\n  undefined auStack_38 [8];\n  long local_30;\n  undefined *puVar7;\n  \n  puVar6 = auStack_38;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar4 = __ctype_get_mb_cur_max();\n  sVar3 = ifs_firstc_len;\n  puVar7 = auStack_38;\n  puVar2 = auStack_38;\n  while (puVar7 != auStack_38 + -(sVar4 + 0x10 & 0xfffffffffffff000)) {\n    puVar6 = puVar2 + -0x1000;\n    *(undefined8 *)(puVar2 + -8) = *(undefined8 *)(puVar2 + -8);\n    puVar7 = puVar2 + -0x1000;\n    puVar2 = puVar2 + -0x1000;\n  }\n  uVar5 = (ulong)((uint)(sVar4 + 0x10) & 0xff0);\n  lVar1 = -uVar5;\n  if (uVar5 != 0) {\n    *(undefined8 *)(puVar6 + -8) = *(undefined8 *)(puVar6 + -8);\n  }\n  if (ifs_firstc_len == 1) {\n    puVar6[lVar1 + 1] = 0;\n    puVar6[lVar1] = ifs_firstc;\n  }\n  else {\n    *(undefined8 *)(puVar6 + lVar1 + -8) = 0x16e392;\n    memcpy(puVar6 + lVar1,&ifs_firstc,ifs_firstc_len);\n    puVar6[sVar3 + lVar1] = 0;\n  }\n  *(undefined8 *)(puVar6 + lVar1 + -8) = 0x16e35d;\n  string_list_internal(param_1,(long)puVar6 + lVar1);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  *(undefined **)(puVar6 + lVar1 + -8) = &UNK_0016e3bd;\n  __stack_chk_fail();\n}\n\n",
  "rl_backward_word": "\nvoid rl_backward_word(int param_1)\n\n{\n  if (-1 < param_1) {\n    FUN_001edaf0();\n    return;\n  }\n  FUN_001edc60(-param_1);\n  return;\n}\n\n",
  "all_array_variables": "\nvoid * all_array_variables(void)\n\n{\n  int iVar1;\n  void *__base;\n  \n  __base = (void *)map_over(FUN_00151370,shell_variables);\n  if (__base != (void *)0x0) {\n    iVar1 = strvec_len(__base);\n    qsort(__base,(long)iVar1,8,FUN_001513a0);\n  }\n  return __base;\n}\n\n",
  "wait_for_background_pids": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint wait_for_background_pids(undefined4 *param_1)\n\n{\n  undefined4 uVar1;\n  long *plVar2;\n  undefined8 *puVar3;\n  uint uVar4;\n  long lVar5;\n  long *plVar6;\n  int *piVar7;\n  long *plVar8;\n  undefined2 uVar9;\n  int iVar10;\n  long lVar11;\n  long lVar12;\n  int iVar13;\n  long lVar14;\n  long in_FS_OFFSET;\n  int local_14c;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_14c = 0;\n  do {\n    sigemptyset(&local_148);\n    sigaddset(&local_148,0x11);\n    sigemptyset(&local_c8);\n    sigprocmask(0,&local_148,&local_c8);\n    iVar10 = DAT_0023877c;\n    if (DAT_0023877c < 1) {\n      lVar14 = 0;\n    }\n    else {\n      lVar12 = 0;\n      lVar14 = 0;\n      lVar11 = jobs;\n      do {\n        lVar5 = *(long *)(lVar11 + lVar12);\n        if (lVar5 != 0) {\n          iVar13 = *(int *)(lVar5 + 0x14);\n          if (iVar13 == 2) {\n            plVar2 = *(long **)(lVar5 + 8);\n            do {\n              plVar8 = plVar2;\n              if (plVar8 == (long *)0x0) {\n                do {\n                  invalidInstructionException();\n                } while( true );\n              }\n              plVar2 = (long *)*plVar8;\n            } while (*(long **)(lVar5 + 8) != (long *)*plVar8);\n            builtin_warning(\"job %d[%d] stopped\",(int)lVar14 + 1,*(undefined4 *)(plVar8 + 1));\n            lVar5 = *(long *)(jobs + lVar12);\n            lVar11 = jobs;\n            iVar10 = DAT_0023877c;\n            if (lVar5 == 0) goto LAB_00165680;\n            iVar13 = *(int *)(lVar5 + 0x14);\n          }\n          if ((iVar13 == 1) && ((*(byte *)(lVar5 + 0x18) & 1) == 0)) break;\n        }\nLAB_00165680:\n        iVar13 = (int)lVar14 + 1;\n        lVar14 = (long)iVar13;\n        lVar12 = lVar12 + 8;\n      } while (iVar13 < iVar10);\n    }\n    if ((int)lVar14 == iVar10) {\n      sigprocmask(2,&local_c8,(sigset_t *)0x0);\n      for (puVar3 = procsubs; puVar3 != (undefined8 *)0x0; puVar3 = (undefined8 *)*puVar3) {\n        if (*(int *)(puVar3 + 2) != 0) {\n          wait_for(*(undefined4 *)(puVar3 + 1),0);\n        }\n      }\n      FUN_00165350(1);\n      if ((DAT_0023877c != 0) && (DAT_00247660 == 0)) {\n        FUN_001626a0();\n      }\n      if ((bgpids != 0) && (DAT_0024253c != 0)) {\n        sh_xfree(bgpids,\"jobs.c\",0x3a4);\n        bgpids = 0;\n        _DAT_00242538 = 0;\n        DAT_00242540 = 0;\n      }\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return local_14c;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    plVar2 = *(long **)(*(long *)(jobs + lVar14 * 8) + 8);\n    plVar8 = plVar2;\n    do {\n      plVar6 = plVar8;\n      if (plVar6 == (long *)0x0) {\n        do {\n          invalidInstructionException();\n        } while( true );\n      }\n      plVar8 = (long *)*plVar6;\n    } while (plVar2 != (long *)*plVar6);\n    uVar1 = *(undefined4 *)(plVar6 + 1);\n    sigprocmask(2,&local_c8,(sigset_t *)0x0);\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      throw_to_top_level();\n    }\n    piVar7 = __errno_location();\n    *piVar7 = 0;\n    uVar4 = wait_for_single_pid(uVar1,1);\n    if (param_1 != (undefined4 *)0x0) {\n      *param_1 = uVar1;\n      uVar9 = 0x7f;\n      if (uVar4 < 0x101) {\n        uVar9 = (undefined2)uVar4;\n      }\n      *(undefined2 *)(param_1 + 1) = uVar9;\n    }\n    if (((uVar4 == 0xffffffff) && (*piVar7 == 10)) && (DAT_0023877c != 0)) {\n      FUN_0015ebc0();\n    }\n    local_14c = local_14c + 1;\n  } while( true );\n}\n\n",
  "rl_prep_terminal": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid rl_prep_terminal(int param_1)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  int *piVar4;\n  undefined1 *puVar5;\n  FILE *__stream;\n  int iVar6;\n  long in_FS_OFFSET;\n  undefined local_80 [8];\n  undefined local_78 [50];\n  cc_t cStack_46;\n  cc_t cStack_45;\n  cc_t cStack_44;\n  cc_t cStack_43;\n  cc_t cStack_42;\n  cc_t cStack_41;\n  speed_t local_40;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_0024a590 == 0) {\n    _rl_block_sigint();\n    __stream = rl_instream;\n    if (rl_instream == (FILE *)0x0) {\n      __stream = stdin;\n    }\n    iVar2 = fileno(__stream);\n    iVar3 = ioctl(iVar2,0x5413,local_80);\n    if (iVar3 == 0) {\n      ioctl(iVar2,0x5414,local_80);\n    }\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    iVar3 = FUN_001d5280(iVar2,(termios *)local_78);\n    if (iVar3 < 0) {\n      iVar2 = *piVar4;\n      if ((iVar2 == 0x19 || iVar2 == 0x16) || (iVar2 == 0x5f)) {\n        _rl_echoing_p = 1;\n      }\n    }\n    else {\n      _DAT_0024a540 = CONCAT44(local_78._4_4_,local_78._0_4_);\n      uRam000000000024a548 = CONCAT44(local_78._12_4_,local_78._8_4_);\n      _DAT_0024a550 =\n           CONCAT26(local_78._22_2_,CONCAT15(local_78[21],CONCAT14(local_78[20],local_78._16_4_)));\n      _uRam000000000024a558 = CONCAT17(local_78[31],CONCAT16(local_78[30],local_78._24_6_));\n      _DAT_0024a560 = CONCAT71(local_78._33_7_,local_78[32]);\n      DAT_0024a570 = local_78[48];\n      DAT_0024a570_1._0_1_ = local_78[49];\n      DAT_0024a570_1._1_1_ = cStack_46;\n      DAT_0024a570_1._2_1_ = cStack_45;\n      DAT_0024a570_1._3_1_ = cStack_44;\n      DAT_0024a570_1._4_1_ = cStack_43;\n      DAT_0024a570_1._5_1_ = cStack_42;\n      DAT_0024a570_1._6_1_ = cStack_41;\n      _DAT_0024a578 = local_40;\n      uRam000000000024a568._0_1_ = local_78[40];\n      uRam000000000024a568._1_1_ = local_78[41];\n      uRam000000000024a568._2_1_ = local_78[42];\n      uRam000000000024a568._3_1_ = local_78[43];\n      uRam000000000024a568._4_1_ = local_78[44];\n      uRam000000000024a568._5_1_ = local_78[45];\n      uRam000000000024a568._6_1_ = local_78[46];\n      uRam000000000024a568._7_1_ = local_78[47];\n      iVar3 = _rl_bind_stty_chars;\n      iVar6 = rl_editing_mode;\n      if (_rl_bind_stty_chars != 0) {\n        if (rl_editing_mode == 0) {\n          rl_tty_unset_default_bindings(&vi_insertion_keymap);\n        }\n        else {\n          rl_tty_unset_default_bindings(_rl_keymap);\n        }\n      }\n      DAT_0024a580 = DAT_0024a555;\n      rl_readline_state = rl_readline_state | 0x40000;\n      DAT_0024a581 = DAT_0024a55c;\n      DAT_0024a582 = DAT_0024a561;\n      DAT_0024a583 = DAT_0024a553;\n      DAT_0024a584 = DAT_0024a55f;\n      DAT_0024a585 = DAT_0024a554;\n      DAT_0024a586 = DAT_0024a55d;\n      _rl_intr_char = (uint)DAT_0024a551;\n      DAT_0024a587 = DAT_0024a551;\n      _rl_quit_char = (uint)DAT_0024a552;\n      DAT_0024a588 = DAT_0024a552;\n      _rl_susp_char = (uint)DAT_0024a55b;\n      DAT_0024a589 = DAT_0024a55b;\n      _DAT_0024a58b = DAT_0024a559;\n      DAT_0024a58d = DAT_0024a560;\n      DAT_0024a58e = DAT_0024a55e;\n      if (iVar3 != 0) {\n        if (iVar6 == 0) {\n          FUN_001d52f0(&vi_insertion_keymap,local_78[19],local_78[20],local_78[31],local_78[32]);\n        }\n        else {\n          FUN_001d52f0(_rl_keymap,local_78[19],local_78[20],local_78[31],local_78[32]);\n        }\n      }\n      _rl_echoctl = DAT_0024a54c & 0x200;\n      _rl_echoing_p = DAT_0024a54c & 8;\n      if (DAT_0024a555 != 0) {\n        _rl_eof_char = (uint)DAT_0024a555;\n      }\n      if (((local_78._8_4_ & 0x30) == 0x30) || (param_1 != 0)) {\n        local_78._0_4_ = local_78._0_4_ & 0xffffffcf;\n      }\n      local_78._0_4_ = local_78._0_4_ & 0xfffffebf;\n      local_78[32] = '\\0';\n      local_78[22] = '\\0';\n      local_78[23] = '\\x01';\n      uVar1 = local_78._12_4_ & 0xffffeff5;\n      if ((local_78._12_4_ & 0x1000) == 0) {\n        uVar1 = local_78._12_4_ & 0xfffffff5;\n      }\n      local_78._12_4_ = uVar1 | 1;\n      puVar5 = &vi_insertion_keymap;\n      if (iVar6 != 0) {\n        puVar5 = _rl_keymap;\n      }\n      if ((local_78[30] != 0) && (puVar5[(ulong)local_78[30] * 0x10] == '\\0')) {\n        local_78[30] = 0;\n      }\n      while( true ) {\n        iVar3 = tcsetattr(iVar2,1,(termios *)local_78);\n        if (-1 < iVar3) break;\n        if (*piVar4 != 4) goto LAB_001d5a01;\n        *piVar4 = 0;\n      }\n      if (_rl_enable_keypad != 0) {\n        _rl_control_keypad(1);\n      }\n      iVar2 = 1;\n      if (_rl_enable_bracketed_paste != 0) {\n        iVar2 = 3;\n        fwrite(&DAT_00213357,1,8,rl_outstream);\n      }\n      fflush(rl_outstream);\n      rl_readline_state = rl_readline_state | 4;\n      DAT_0024a590 = iVar2;\n    }\nLAB_001d5a01:\n    _rl_release_sigint();\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_old_menu_complete": "\nundefined8 rl_old_menu_complete(int param_1,undefined4 param_2)\n\n{\n  long *plVar1;\n  int iVar2;\n  undefined4 uVar3;\n  long lVar4;\n  long *plVar5;\n  code *pcVar6;\n  long in_FS_OFFSET;\n  undefined4 local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (rl_last_func == rl_old_menu_complete) {\nLAB_001d9a48:\n    if (DAT_0024a6d0 != (long *)0x0) goto LAB_001d98b7;\n  }\n  else {\n    if (DAT_0024a6d8 != (void *)0x0) {\n      free(DAT_0024a6d8);\n    }\n    plVar1 = DAT_0024a6d0;\n    if (DAT_0024a6d0 != (long *)0x0) {\n      lVar4 = *DAT_0024a6d0;\n      plVar5 = DAT_0024a6d0;\n      while (lVar4 != 0) {\n        plVar5 = plVar5 + 1;\n        xfree();\n        lVar4 = *plVar5;\n      }\n      xfree(plVar1);\n    }\n    DAT_0024a6c8 = 0;\n    rl_readline_state = rl_readline_state | 0x4000;\n    DAT_0024a6c4 = 0;\n    DAT_0024a6d0 = (long *)0x0;\n    rl_filename_completion_desired = 0;\n    rl_filename_quoting_desired = 1;\n    rl_completion_type = 0x25;\n    rl_completion_suppress_quote = 0;\n    rl_completion_suppress_append = 0;\n    rl_completion_append_character = 0x20;\n    rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;\n    DAT_0024a728 = 0;\n    pcVar6 = rl_menu_completion_entry_function;\n    if ((rl_menu_completion_entry_function == (code *)0x0) &&\n       (pcVar6 = rl_completion_entry_function, rl_completion_entry_function == (code *)0x0)) {\n      pcVar6 = rl_filename_completion_function;\n    }\n    DAT_0024a6b8 = '\\0';\n    DAT_0024a6bc = 0;\n    DAT_0024a6c0 = rl_point;\n    local_34 = 0;\n    rl_completion_invoking_key = param_2;\n    iVar2 = 0;\n    if (rl_point != 0) {\n      DAT_0024a6b8 = _rl_find_completion_word(&local_34,&DAT_0024a6bc);\n      iVar2 = DAT_0024a6c0;\n    }\n    DAT_0024a6b4 = rl_point;\n    rl_point = iVar2;\n    DAT_0024a6d8 = (void *)rl_copy_text();\n    DAT_0024a6d0 = (long *)FUN_001d8df0(DAT_0024a6d8,DAT_0024a6b4,DAT_0024a6c0,pcVar6,local_34,\n                                        (int)DAT_0024a6b8);\n    if ((DAT_0024a6d0 == (long *)0x0) ||\n       (iVar2 = FUN_001d74a0(&DAT_0024a6d0,rl_filename_completion_desired), iVar2 == 0)) {\n      rl_ding();\n      if (DAT_0024a6d0 != (long *)0x0) {\n        free(DAT_0024a6d0);\n      }\n      DAT_0024a6d0 = (long *)0x0;\n      if (DAT_0024a6d8 != (void *)0x0) {\n        free(DAT_0024a6d8);\n      }\n      rl_readline_state = rl_readline_state & 0xffffffffffffbfff;\n      DAT_0024a6d8 = (void *)0x0;\n      DAT_0024a730 = 0;\n      goto LAB_001d9a02;\n    }\n    rl_readline_state = rl_readline_state & 0xffffffffffffbfff;\n    DAT_0024a6c8 = 0;\n    if (*DAT_0024a6d0 != 0) {\n      lVar4 = 1;\n      do {\n        DAT_0024a6c8 = (int)lVar4;\n        plVar1 = DAT_0024a6d0 + lVar4;\n        lVar4 = lVar4 + 1;\n      } while (*plVar1 != 0);\n      if ((DAT_0024a6c8 != 1) && (_rl_complete_show_all != 0)) {\n        FUN_001d8aa0();\n        goto LAB_001d9a48;\n      }\n    }\nLAB_001d98b7:\n    if (DAT_0024a6c8 != 0) {\n      DAT_0024a6c4 = param_1 + DAT_0024a6c4;\n      if (DAT_0024a6c4 < 0) {\n        do {\n          DAT_0024a6c4 = DAT_0024a6c4 + DAT_0024a6c8;\n          if (-1 < DAT_0024a6c4) break;\n          DAT_0024a6c4 = DAT_0024a6c4 + DAT_0024a6c8;\n        } while (DAT_0024a6c4 < 0);\n      }\n      else {\n        DAT_0024a6c4 = DAT_0024a6c4 % DAT_0024a6c8;\n      }\n      if ((DAT_0024a6c4 == 0) && (1 < DAT_0024a6c8)) {\n        rl_ding();\n        FUN_001d5f60(DAT_0024a6d8,DAT_0024a6b4,2,&DAT_0024a6b8);\n      }\n      else {\n        FUN_001d5f60(DAT_0024a6d0[DAT_0024a6c4],DAT_0024a6b4,1,&DAT_0024a6b8);\n        uVar3 = FUN_001d5e50(DAT_0024a6d8,DAT_0024a6d0[DAT_0024a6c4]);\n        FUN_001d7d90(DAT_0024a6d0[DAT_0024a6c4],DAT_0024a6bc,(int)DAT_0024a6b8,uVar3);\n      }\n      DAT_0024a730 = 1;\n      goto LAB_001d9a02;\n    }\n  }\n  rl_ding();\n  if (DAT_0024a6d0 != (long *)0x0) {\n    free(DAT_0024a6d0);\n  }\n  DAT_0024a6d0 = (long *)0x0;\n  DAT_0024a730 = 0;\nLAB_001d9a02:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_clear_history": "\nvoid rl_clear_history(void)\n\n{\n  void **ppvVar1;\n  long lVar2;\n  long lVar3;\n  void *pvVar4;\n  \n  pvVar4 = rl_undo_list;\n  lVar2 = history_list();\n  if (0 < history_length) {\n    lVar3 = 0;\n    do {\n      ppvVar1 = *(void ***)(lVar2 + lVar3 * 8);\n      if (ppvVar1[2] != (void *)0x0) {\n        if (ppvVar1[2] == pvVar4) {\n          pvVar4 = (void *)0x0;\n        }\n        _rl_free_undo_list();\n        ppvVar1[2] = (void *)0x0;\n      }\n      if (*ppvVar1 != (void *)0x0) {\n        free(*ppvVar1);\n      }\n      if (ppvVar1[1] != (void *)0x0) {\n        free(ppvVar1[1]);\n      }\n      lVar3 = lVar3 + 1;\n      xfree(ppvVar1);\n    } while ((int)lVar3 < history_length);\n  }\n  rl_undo_list = pvVar4;\n  history_length = 0;\n  history_offset = 0;\n  return;\n}\n\n",
  "FUN_00151280": "\nbool FUN_00151280(long param_1)\n\n{\n  return (*(byte *)(param_1 + 0x29) & 0x10) == 0;\n}\n\n",
  "makunbound": "\nundefined8 makunbound(char *param_1,long param_2)\n\n{\n  uint uVar1;\n  char **ppcVar2;\n  undefined8 uVar3;\n  long lVar4;\n  size_t sVar5;\n  char *__dest;\n  char *pcVar6;\n  long lVar7;\n  \n  if (param_2 == 0) {\n    return 0xffffffff;\n  }\n  while (lVar4 = hash_remove(param_1,*(undefined8 *)(param_2 + 0x20),0), lVar4 == 0) {\n    param_2 = *(long *)(param_2 + 0x18);\n    if (param_2 == 0) {\n      return 0xffffffff;\n    }\n  }\n  ppcVar2 = *(char ***)(lVar4 + 0x10);\n  if (ppcVar2 != (char **)0x0) {\n    uVar1 = *(uint *)(ppcVar2 + 5);\n    if ((uVar1 & 1) != 0) {\n      array_needs_making = array_needs_making + 1;\n    }\n    if (((uVar1 & 0x20) != 0) &&\n       ((*(int *)((long)ppcVar2 + 0x2c) == variable_context ||\n        ((localvar_unset != 0 && (*(int *)((long)ppcVar2 + 0x2c) < variable_context)))))) {\n      if ((uVar1 & 0x20000) == 0) {\n        pcVar6 = ppcVar2[1];\n        if ((uVar1 & 4) == 0) {\n          if ((uVar1 & 0x40) == 0) {\n            if ((uVar1 & 0x800) == 0) {\n              if (pcVar6 != (char *)0x0) {\n                sh_xfree(pcVar6,\"variables.c\",0xfb2);\n              }\n            }\n            else if (pcVar6 != (char *)0x0) {\n              sh_xfree(pcVar6,\"variables.c\",0xfb0);\n            }\n          }\n          else {\n            assoc_dispose();\n          }\n        }\n        else {\n          array_dispose();\n        }\n      }\n      ppcVar2[1] = (char *)0x0;\n      *(uint *)(ppcVar2 + 5) = (*(uint *)(ppcVar2 + 5) & 0x100001) == 0x100001 | 0x1020;\n      if (ppcVar2[2] != (char *)0x0) {\n        sh_xfree(ppcVar2[2],\"variables.c\",0xfba);\n        ppcVar2[2] = (char *)0x0;\n      }\n      pcVar6 = *ppcVar2;\n      uVar3 = *(undefined8 *)(param_2 + 0x20);\n      sVar5 = strlen(pcVar6);\n      __dest = (char *)sh_xmalloc(sVar5 + 1,\"variables.c\",0xfbc);\n      pcVar6 = strcpy(__dest,pcVar6);\n      lVar7 = hash_insert(pcVar6,uVar3,0);\n      pcVar6 = *ppcVar2;\n      *(char ***)(lVar7 + 0x10) = ppcVar2;\n      stupidly_hack_special_variables(pcVar6);\n      sh_xfree(*(undefined8 *)(lVar4 + 8),\"variables.c\",0xfc0);\n      sh_xfree(lVar4,\"variables.c\",0xfc1);\n      return 0;\n    }\n  }\n  sVar5 = strlen(param_1);\n  pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"variables.c\",0xfc8);\n  pcVar6 = strcpy(pcVar6,param_1);\n  sh_xfree(*(undefined8 *)(lVar4 + 8),\"variables.c\",0xfca);\n  sh_xfree(lVar4,\"variables.c\",0xfcb);\n  dispose_variable(ppcVar2);\n  stupidly_hack_special_variables(pcVar6);\n  sh_xfree(pcVar6,\"variables.c\",0xfcf);\n  return 0;\n}\n\n",
  "u32tocesc": "\nundefined8 u32tocesc(uint param_1,undefined8 param_2)\n\n{\n  if (param_1 < 0x10000) {\n    __sprintf_chk(param_2,1,0xffffffffffffffff,\"\\\\u%04X\");\n    return 6;\n  }\n  __sprintf_chk(param_2,1,0xffffffffffffffff,\"\\\\U%08X\");\n  return 10;\n}\n\n",
  "rl_vi_delete_to": "\nint rl_vi_delete_to(undefined8 param_1,ulong param_2)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  ushort **ppuVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  \n  puVar1 = _rl_vimvcxt;\n  uVar7 = (undefined4)(param_2 & 0xffffffff);\n  if (_rl_vi_redoing == 0) {\n    if (_rl_vimvcxt == (undefined8 *)0x0) {\n      puVar4 = (undefined8 *)xmalloc(0x24);\n      *puVar4 = 1;\n      rl_mark = rl_point;\n      uVar6 = rl_end;\n      puVar4[1] = 0;\n      *(undefined4 *)(puVar4 + 2) = 0xffffffff;\n      *(undefined4 *)((long)puVar4 + 0x14) = rl_mark;\n      *(undefined4 *)(puVar4 + 3) = uVar6;\n      *(undefined4 *)((long)puVar4 + 0x1c) = uVar7;\n      *(undefined4 *)(puVar4 + 4) = 0xffffffff;\n      puVar5 = (undefined8 *)0x0;\n      _rl_vimvcxt = puVar4;\n    }\n    else {\n      *_rl_vimvcxt = 1;\n      rl_mark = rl_point;\n      uVar6 = rl_end;\n      puVar1[1] = 0;\n      *(undefined4 *)(puVar1 + 2) = 0xffffffff;\n      *(undefined4 *)((long)puVar1 + 0x14) = rl_mark;\n      *(undefined4 *)(puVar1 + 3) = uVar6;\n      *(int *)((long)puVar1 + 0x1c) = (int)param_2;\n      *(undefined4 *)(puVar1 + 4) = 0xffffffff;\n      puVar5 = (undefined8 *)0x0;\n      puVar4 = puVar1;\n    }\n  }\n  else {\n    puVar4 = (undefined8 *)xmalloc(0x24);\n    *puVar4 = 1;\n    rl_mark = rl_point;\n    uVar6 = rl_end;\n    puVar4[1] = 0;\n    *(undefined4 *)(puVar4 + 2) = 0xffffffff;\n    *(undefined4 *)((long)puVar4 + 0x14) = rl_mark;\n    *(undefined4 *)(puVar4 + 3) = uVar6;\n    *(undefined4 *)((long)puVar4 + 0x1c) = uVar7;\n    *(undefined4 *)(puVar4 + 4) = 0xffffffff;\n    puVar5 = puVar1;\n    _rl_vimvcxt = puVar4;\n  }\n  *(undefined4 *)((long)puVar4 + 0x14) = rl_mark;\n  ppuVar3 = __ctype_b_loc();\n  if ((*(byte *)((long)*ppuVar3 + (param_2 & 0xff) * 2 + 1) & 1) == 0) {\n    if (_rl_vi_redoing != 0) {\n      if (DAT_0024a400 == 100) {\n        *(undefined4 *)(puVar4 + 4) = 100;\n        rl_mark = uVar6;\n        rl_beg_of_line(1,param_2 & 0xffffffff);\n        rl_readline_state = rl_readline_state & 0xffffffffffefffff;\n        iVar2 = FUN_001cff80(_rl_vimvcxt);\n      }\n      else {\n        *(int *)(puVar4 + 4) = DAT_0024a400;\n        iVar2 = FUN_001d23d0(puVar4);\n      }\n      goto joined_r0x001d2825;\n    }\n    if ((rl_readline_state & 0x80000) != 0) {\n      rl_readline_state = rl_readline_state | 0x100000;\n      return 0;\n    }\n    iVar2 = _rl_bracketed_read_key();\n    *(int *)(puVar4 + 4) = iVar2;\n    if (-1 < iVar2) {\n      iVar2 = FUN_001d2470(puVar4);\n      goto joined_r0x001d2825;\n    }\n    *(undefined4 *)(puVar4 + 4) = 0;\n  }\n  else {\n    *(undefined4 *)(puVar4 + 4) = 0x24;\n    iVar2 = FUN_001d23d0(puVar4);\njoined_r0x001d2825:\n    if (-1 < iVar2) goto LAB_001d2827;\n  }\n  rl_ding();\n  iVar2 = -1;\nLAB_001d2827:\n  xfree(_rl_vimvcxt);\n  _rl_vimvcxt = puVar5;\n  return iVar2;\n}\n\n",
  "regexec": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint regexec(regex_t *__preg,char *__string,size_t __nmatch,regmatch_t *__pmatch,int __eflags)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_regexec_00237c18)();\n  return iVar1;\n}\n\n",
  "restart_job_control": "\nvoid restart_job_control(void)\n\n{\n  if (shell_tty == -1) {\n    initialize_job_control(0);\n    return;\n  }\n  close(shell_tty);\n  initialize_job_control(0);\n  return;\n}\n\n",
  "delete_var": "\nundefined8 delete_var(undefined8 param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  \n  if (param_2 == 0) {\n    return 0xffffffff;\n  }\n  do {\n    lVar2 = hash_remove(param_1,*(undefined8 *)(param_2 + 0x20),0);\n    if (lVar2 != 0) {\n      uVar1 = *(undefined8 *)(lVar2 + 0x10);\n      sh_xfree(*(undefined8 *)(lVar2 + 8),\"variables.c\",0xf7d);\n      sh_xfree(lVar2,\"variables.c\",0xf7e);\n      dispose_variable(uVar1);\n      return 0;\n    }\n    param_2 = *(long *)(param_2 + 0x18);\n  } while (param_2 != 0);\n  return 0xffffffff;\n}\n\n",
  "FUN_00191df0": "\nundefined8 FUN_00191df0(undefined8 param_1)\n\n{\n  FUN_00191ae0(param_1,FUN_00191550);\n  return 0;\n}\n\n",
  "initialize_traps": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid initialize_traps(void)\n\n{\n  uint uVar1;\n  code **ppcVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  \n  pending_traps._4_8_ = 0;\n  pending_traps._252_8_ = 0;\n  DAT_00247c18 = 0;\n  DAT_00247c10 = 0;\n  DAT_00247c08 = 0;\n  trap_list = 0;\n  DAT_00247f44 = 0;\n  _DAT_00247f48 = 0;\n  DAT_00247e40 = 0;\n  original_signals._0_8_ = initialize_traps;\n  puVar4 = (undefined8 *)(pending_traps + 8);\n  for (lVar3 = 0x1f; lVar3 != 0; lVar3 = lVar3 + -1) {\n    *puVar4 = 0;\n    puVar4 = puVar4 + 1;\n  }\n  puVar4 = &DAT_00247a08;\n  for (lVar3 = 0x40; lVar3 != 0; lVar3 = lVar3 + -1) {\n    *puVar4 = 0;\n    puVar4 = puVar4 + 1;\n  }\n  _DAT_00247e44 = 0;\n  _DAT_00247f3c = 0;\n  puVar4 = (undefined8 *)&DAT_00247e48;\n  for (lVar3 = 0x1f; lVar3 != 0; lVar3 = lVar3 + -1) {\n    *puVar4 = 0;\n    puVar4 = puVar4 + 1;\n  }\n  ppcVar2 = (code **)(original_signals + 8);\n  do {\n    *ppcVar2 = initialize_traps;\n    ppcVar2 = ppcVar2 + 1;\n  } while (ppcVar2 != (code **)&DAT_00247e28);\n  original_signals._136_8_ = set_signal_handler(0x11,0);\n  set_signal_handler(0x11,original_signals._136_8_);\n  if (original_signals._136_8_ == 1) {\n    DAT_00247e84 = DAT_00247e84 | 2;\n  }\n  DAT_00247e84 = DAT_00247e84 | 0xc;\n  original_signals._16_8_ = set_signal_handler(2,0);\n  set_signal_handler(2,original_signals._16_8_);\n  uVar1 = DAT_00247e48;\n  if (original_signals._16_8_ == 1) {\n    uVar1 = DAT_00247e48 | 2;\n  }\n  _DAT_00247e44 = CONCAT44(uVar1,DAT_00247e44) | 0x400000000;\n  original_signals._24_8_ = set_signal_handler(3,0);\n  set_signal_handler(3,original_signals._24_8_);\n  if (original_signals._24_8_ == 1) {\n    DAT_00247e4c = DAT_00247e4c | 2;\n  }\n  DAT_00247e4c = DAT_00247e4c | 4;\n  if (interactive == 0) {\n    get_original_tty_job_signals();\n    return;\n  }\n  original_signals._120_8_ = set_signal_handler(0xf,0);\n  set_signal_handler(0xf,original_signals._120_8_);\n  if (original_signals._120_8_ == 1) {\n    DAT_00247e7c = DAT_00247e7c | 2;\n  }\n  DAT_00247e7c = DAT_00247e7c | 4;\n  get_original_tty_job_signals();\n  return;\n}\n\n",
  "chdir": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint chdir(char *__path)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_chdir_002379c8)();\n  return iVar1;\n}\n\n",
  "sh_stat": "\nint sh_stat(undefined8 *param_1,stat *param_2)\n\n{\n  undefined8 *__s;\n  int iVar1;\n  size_t sVar2;\n  int *piVar3;\n  \n  if (*(char *)param_1 != '\\0') {\n    if (((*(char *)param_1 == '/') && (*(char *)((long)param_1 + 1) == 'd')) &&\n       (iVar1 = strncmp((char *)param_1,\"/dev/fd/\",8), iVar1 == 0)) {\n      __s = param_1 + 1;\n      sVar2 = strlen((char *)__s);\n      param_1 = (undefined8 *)sh_xrealloc(DAT_00249f80,sVar2 + 9,\"eaccess.c\",0x71);\n      DAT_00249f80 = param_1;\n      *param_1 = 0x2f64662f7665642f;\n      strcpy((char *)(param_1 + 1),(char *)__s);\n    }\n    iVar1 = stat((char *)param_1,param_2);\n    return iVar1;\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 2;\n  return -1;\n}\n\n",
  "find_flag": "\nundefined8 find_flag(int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined1 *puVar3;\n  \n  puVar3 = shell_flags;\n  iVar2 = 0;\n  iVar1 = 0x61;\n  do {\n    puVar3 = puVar3 + 0x10;\n    if (iVar1 == param_1) {\n      return *(undefined8 *)(shell_flags + (long)iVar2 * 0x10 + 8);\n    }\n    iVar1 = (int)(char)*puVar3;\n    iVar2 = iVar2 + 1;\n  } while (*puVar3 != '\\0');\n  return 0;\n}\n\n",
  "expand_string_dollar_quote": "\nundefined * expand_string_dollar_quote(byte *param_1,int param_2)\n\n{\n  byte *__s;\n  mbstate_t mVar1;\n  int iVar2;\n  size_t sVar3;\n  undefined *puVar4;\n  ulong uVar5;\n  undefined *puVar6;\n  char *__s1;\n  char *__s2;\n  ulong uVar7;\n  size_t sVar8;\n  size_t sVar9;\n  byte bVar10;\n  undefined8 uVar11;\n  long lVar12;\n  ulong uVar13;\n  uint uVar14;\n  long lVar15;\n  long lVar16;\n  uint uVar18;\n  int iVar19;\n  byte *pbVar20;\n  long lVar21;\n  long in_FS_OFFSET;\n  int local_50;\n  uint local_4c;\n  mbstate_t local_48;\n  long local_40;\n  long lVar17;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar3 = strlen((char *)param_1);\n  uVar13 = sVar3 + 1;\n  puVar4 = (undefined *)sh_xmalloc(uVar13,\"subst.c\",0x1051);\n  bVar10 = *param_1;\n  puVar6 = puVar4;\n  if (bVar10 != 0) {\n    uVar5 = 0;\n    lVar21 = 0;\n    pbVar20 = param_1;\n    do {\n      iVar19 = (int)uVar5;\n      if (bVar10 == 0x24) {\n        uVar14 = iVar19 + 1;\n        pbVar20 = param_1 + (int)uVar14;\n        bVar10 = *pbVar20;\n        if ((bVar10 != 0x27) && (bVar10 != 0x22)) {\n          if (uVar13 <= lVar21 + 2U) {\n            do {\n              uVar13 = uVar13 + 0x10;\n            } while (uVar13 <= lVar21 + 2U);\n            puVar6 = (undefined *)sh_xrealloc(puVar6,uVar13,\"subst.c\");\n          }\n          puVar6[lVar21] = 0x24;\n          uVar5 = (ulong)uVar14;\n          lVar12 = lVar21 + 1;\n          goto LAB_0016ee18;\n        }\n        uVar18 = iVar19 + 2;\n        uVar5 = (ulong)uVar18;\n        if (param_1[(long)(int)uVar14 + 1] == 0) {\n          if (uVar13 <= lVar21 + 3U) {\n            do {\n              uVar13 = uVar13 + 0x10;\n            } while (uVar13 <= lVar21 + 3U);\n            puVar6 = (undefined *)sh_xrealloc(puVar6,uVar13,\"subst.c\");\n          }\n          puVar6[lVar21] = 0x24;\n          lVar12 = lVar21 + 2;\n          puVar6[lVar21 + 1] = bVar10;\nLAB_0016f196:\n          pbVar20 = param_1 + (int)uVar5;\n        }\n        else {\n          if (bVar10 == 0x27) {\n            local_4c = FUN_00167020(param_1,sVar3,uVar5,0x400);\n            if ((((int)uVar18 < (int)local_4c) && (param_1[(int)local_4c] == 0)) &&\n               (param_1[(long)(int)local_4c + -1] != 0x27)) {\n              if (uVar13 <= lVar21 + 3U) {\n                do {\n                  uVar13 = uVar13 + 0x10;\n                } while (uVar13 <= lVar21 + 3U);\n                puVar6 = (undefined *)sh_xrealloc(puVar6,uVar13,\"subst.c\",0x109c);\n              }\n              puVar6[lVar21] = 0x24;\n              lVar12 = lVar21 + 2;\n              puVar6[lVar21 + 1] = 0x27;\n              goto LAB_0016f196;\n            }\n            uVar11 = substring(param_1,uVar5,local_4c - 1);\n            __s2 = (char *)ansiexpand(uVar11,0,~uVar18 + local_4c,&local_50);\n            sh_xfree(uVar11,\"subst.c\",0x10a3);\n            __s1 = (char *)sh_single_quote(__s2);\nLAB_0016f2e0:\n            uVar5 = (ulong)local_4c;\n            sh_xfree(__s2,\"subst.c\",0x10bf);\n            sVar8 = strlen(__s1);\n            local_50 = (int)sVar8;\n            uVar7 = (local_50 + 1) + lVar21;\n            if (uVar13 <= uVar7) {\n              do {\n                uVar13 = uVar13 + 0x80;\n              } while (uVar13 <= uVar7);\n              puVar6 = (undefined *)sh_xrealloc(puVar6,uVar13,\"subst.c\");\n            }\n            strcpy(puVar6 + lVar21,__s1);\n            uVar11 = 0x10c6;\n            lVar12 = lVar21 + local_50;\n          }\n          else {\n            local_4c = uVar18;\n            __s1 = (char *)FUN_0016aa90(param_1,&local_4c,0x400);\n            if ((((int)local_4c <= (int)uVar18) || (param_1[(int)local_4c] != 0)) ||\n               (bVar10 == param_1[(long)(int)local_4c + -1])) {\n              __s2 = (char *)locale_expand(__s1,0,local_4c - uVar18,0,&local_50);\n              sh_xfree(__s1,\"subst.c\",0x10b6);\n              iVar19 = local_50;\n              if ((singlequote_translations == 0) ||\n                 ((~uVar18 + local_4c == local_50 &&\n                  ((local_50 == 0 ||\n                   ((*__s1 == *__s2 && (iVar2 = strncmp(__s1,__s2,(long)local_50), iVar2 == 0)))))))\n                 ) {\n                __s1 = (char *)sh_mkdoublequoted(__s2,iVar19,0);\n              }\n              else {\n                __s1 = (char *)sh_single_quote(__s2);\n              }\n              goto LAB_0016f2e0;\n            }\n            if (uVar13 <= lVar21 + 3U) {\n              do {\n                uVar13 = uVar13 + 0x10;\n              } while (uVar13 <= lVar21 + 3U);\n              puVar6 = (undefined *)sh_xrealloc(puVar6,uVar13,\"subst.c\",0x10af);\n            }\n            puVar6[lVar21] = 0x24;\n            uVar11 = 0x10b2;\n            lVar12 = lVar21 + 2;\n            puVar6[lVar21 + 1] = bVar10;\n          }\n          sh_xfree(__s1,\"subst.c\",uVar11);\n          pbVar20 = param_1 + (int)uVar5;\n        }\n      }\n      else if ((char)bVar10 < '%') {\n        if (bVar10 != 1) {\n          if (bVar10 != 0x22) goto LAB_0016f0b9;\n          goto LAB_0016ef2a;\n        }\n        uVar5 = (locale_mb_cur_max + 2) + lVar21;\n        if (uVar13 <= uVar5) {\n          do {\n            uVar13 = uVar13 + 0x40;\n          } while (uVar13 <= uVar5);\n          puVar6 = (undefined *)sh_xrealloc(puVar6,uVar13,\"subst.c\",0x1079);\n        }\n        mVar1 = local_48;\n        lVar15 = lVar21;\n        if (param_2 != 0) {\n          iVar19 = iVar19 + 1;\n          lVar15 = lVar21 + 1;\n          puVar6[lVar21] = *pbVar20;\n        }\n        lVar21 = (long)iVar19;\n        pbVar20 = param_1 + lVar21;\n        bVar10 = *pbVar20;\n        if (bVar10 == 0) {\nLAB_0016f138:\n          puVar4 = puVar6 + lVar15;\n          goto LAB_0016f13b;\n        }\n        uVar5 = (ulong)(iVar19 + 1U);\n        lVar12 = lVar15 + 1;\n        if (1 < locale_mb_cur_max) {\n          if ((*(uint *)(is_basic_table + (ulong)(bVar10 >> 5) * 4) >> (bVar10 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale == 0) || (sVar8 = 1, (char)bVar10 < '\\0')) {\n              sVar8 = mbrtowc((wchar_t *)0x0,(char *)pbVar20,sVar3 - lVar21,&local_48);\n              if (0xfffffffffffffffd < sVar8) {\n                puVar6[lVar15] = *pbVar20;\n                local_48 = mVar1;\n                goto LAB_0016f196;\n              }\n              bVar10 = *pbVar20;\n              if (sVar8 == 0) {\n                sVar8 = 1;\n              }\n            }\n          }\n          else {\n            sVar8 = 1;\n          }\n          lVar12 = lVar15 + sVar8;\n          lVar17 = lVar15;\n          while( true ) {\n            lVar16 = lVar17 + 1;\n            puVar6[lVar17] = bVar10;\n            if (lVar16 == lVar12) break;\n            bVar10 = param_1[lVar16 + (lVar21 - lVar15)];\n            lVar17 = lVar16;\n          }\n          uVar5 = (ulong)(uint)(iVar19 + (int)sVar8);\n          goto LAB_0016f196;\n        }\n        puVar6[lVar15] = bVar10;\n        pbVar20 = param_1 + (int)(iVar19 + 1U);\n      }\n      else if (bVar10 == 0x27) {\nLAB_0016ef2a:\n        iVar19 = iVar19 + 1;\n        if (bVar10 == 0x27) {\n          local_4c = FUN_00167020(param_1,sVar3,iVar19,0x400);\n        }\n        else {\n          local_4c = FUN_0016a7c0();\n        }\n        local_50 = (local_4c - iVar19) + -1;\n        uVar5 = (int)((local_4c - iVar19) + 2) + lVar21;\n        if (uVar13 <= uVar5) {\n          do {\n            uVar13 = uVar13 + 0x40;\n          } while (uVar13 <= uVar5);\n          puVar6 = (undefined *)sh_xrealloc(puVar6,uVar13,\"subst.c\",0x106c);\n        }\n        puVar6[lVar21] = bVar10;\n        lVar12 = lVar21 + 1;\n        if (0 < local_50) {\n          strncpy(puVar6 + lVar12,(char *)(param_1 + iVar19),(long)local_50);\n          lVar12 = lVar12 + local_50;\n        }\n        if ((iVar19 < (int)local_4c) && (param_1[(long)(int)local_4c + -1] == bVar10)) {\n          puVar6[lVar12] = bVar10;\n          lVar12 = lVar12 + 1;\n        }\n        uVar5 = (ulong)(int)local_4c;\n        pbVar20 = param_1 + uVar5;\n      }\n      else if (bVar10 == 0x5c) {\n        uVar5 = (locale_mb_cur_max + 2) + lVar21;\n        if (uVar13 <= uVar5) {\n          do {\n            uVar13 = uVar13 + 0x40;\n          } while (uVar13 <= uVar5);\n          puVar6 = (undefined *)sh_xrealloc(puVar6,uVar13,\"subst.c\",0x105e);\n        }\n        mVar1 = local_48;\n        lVar15 = lVar21 + 1;\n        __s = param_1 + (iVar19 + 1);\n        puVar6[lVar21] = *pbVar20;\n        bVar10 = *__s;\n        if (bVar10 == 0) goto LAB_0016f138;\n        if (1 < locale_mb_cur_max) {\n          if ((*(uint *)(is_basic_table + (ulong)(bVar10 >> 5) * 4) >> (bVar10 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale == 0) || (sVar8 = 1, (char)bVar10 < '\\0')) {\n              sVar9 = mbrtowc((wchar_t *)0x0,(char *)__s,sVar3 - (long)(iVar19 + 1),&local_48);\n              if (0xfffffffffffffffd < sVar9) {\n                uVar5 = (ulong)(iVar19 + 2);\n                lVar12 = lVar21 + 2;\n                puVar6[lVar15] = *__s;\n                local_48 = mVar1;\n                goto LAB_0016f196;\n              }\n              bVar10 = *__s;\n              sVar8 = 1;\n              if (sVar9 != 0) {\n                sVar8 = sVar9;\n              }\n            }\n          }\n          else {\n            sVar8 = 1;\n          }\n          lVar17 = lVar15;\n          while( true ) {\n            lVar12 = lVar17 + 1;\n            puVar6[lVar17] = bVar10;\n            if (lVar12 == sVar8 + lVar15) break;\n            bVar10 = param_1[lVar12 + (iVar19 - lVar21)];\n            lVar17 = lVar12;\n          }\n          uVar5 = (ulong)(uint)(iVar19 + 1 + (int)sVar8);\n          goto LAB_0016f196;\n        }\n        uVar5 = (ulong)(iVar19 + 2U);\n        puVar6[lVar15] = bVar10;\n        lVar12 = lVar21 + 2;\n        pbVar20 = param_1 + (int)(iVar19 + 2U);\n      }\n      else {\nLAB_0016f0b9:\n        uVar5 = (locale_mb_cur_max + 1) + lVar21;\n        if (uVar13 <= uVar5) {\n          do {\n            uVar13 = uVar13 + 0x40;\n          } while (uVar13 <= uVar5);\n          puVar6 = (undefined *)sh_xrealloc(puVar6,uVar13,\"subst.c\",0x1059);\n        }\n        mVar1 = local_48;\n        bVar10 = *pbVar20;\n        uVar14 = iVar19 + 1;\n        uVar5 = (ulong)uVar14;\n        lVar12 = lVar21 + 1;\n        if (1 < locale_mb_cur_max) {\n          if ((*(uint *)(is_basic_table + (ulong)(bVar10 >> 5) * 4) >> (bVar10 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale == 0) || (sVar8 = 1, (char)bVar10 < '\\0')) {\n              sVar9 = mbrtowc((wchar_t *)0x0,(char *)pbVar20,sVar3 - (long)iVar19,&local_48);\n              if (0xfffffffffffffffd < sVar9) {\n                uVar5 = (ulong)uVar14;\n                puVar6[lVar21] = param_1[iVar19];\n                local_48 = mVar1;\n                goto LAB_0016f196;\n              }\n              sVar8 = 1;\n              if (sVar9 != 0) {\n                sVar8 = sVar9;\n              }\n            }\n          }\n          else {\n            sVar8 = 1;\n          }\n          lVar15 = lVar21;\n          do {\n            lVar12 = lVar15 + 1;\n            puVar6[lVar15] = param_1[lVar12 + (iVar19 - lVar21) + -1];\n            lVar15 = lVar12;\n          } while (lVar12 != lVar21 + sVar8);\n          uVar5 = (ulong)(uint)(iVar19 + (int)sVar8);\n          goto LAB_0016f196;\n        }\n        puVar6[lVar21] = bVar10;\n        pbVar20 = param_1 + (int)uVar14;\n      }\nLAB_0016ee18:\n      bVar10 = *pbVar20;\n      lVar21 = lVar12;\n    } while (bVar10 != 0);\n    puVar4 = puVar6 + lVar12;\n  }\nLAB_0016f13b:\n  *puVar4 = 0;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar6;\n}\n\n",
  "show_shell_version": "\nvoid show_shell_version(int param_1)\n\n{\n  if (DAT_00248660 == '\\0') {\n    __snprintf_chk(&DAT_00248660,0x20,1,0x20,\"%s.%d(%d)-%s\",&DAT_001fefc0,0,1,\"release\");\n  }\n  __printf_chk(1,\"GNU bash, version %s (%s)\\n\",&DAT_00248660,\"x86_64-pc-linux-gnu\");\n  if (param_1 == 0) {\n    return;\n  }\n  puts(\"Copyright (C) 2022 Free Software Foundation, Inc.\");\n  puts(\"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\\n\");\n  puts(\"This is free software; you are free to change and redistribute it.\");\n  puts(\"There is NO WARRANTY, to the extent permitted by law.\");\n  return;\n}\n\n",
  "_rl_release_sigint": "\nvoid _rl_release_sigint(void)\n\n{\n  if ((DAT_0024aa88 != 0) && (DAT_0024aa88 = 0, _rl_caught_signal != 0)) {\n    _rl_signal_handler(_rl_caught_signal);\n    return;\n  }\n  return;\n}\n\n",
  "rewind_input_string": "\nvoid rewind_input_string(void)\n\n{\n  DAT_00240a70 = DAT_00240a70 -\n                 (int)(((int)DAT_00240d90 - (int)DAT_00240da0) +\n                      (uint)(*(char *)(DAT_00240a70 + -1) == '\\n'));\n  return;\n}\n\n",
  "_rl_reset_completion_state": "\nvoid _rl_reset_completion_state(void)\n\n{\n  rl_completion_found_quote = 0;\n  rl_completion_quote_character = 0;\n  return;\n}\n\n",
  "rl_vi_end_word": "\nundefined8 rl_vi_end_word(int param_1,ulong param_2)\n\n{\n  ushort **ppuVar1;\n  \n  if (param_1 < 0) {\n    rl_ding();\n    return 1;\n  }\n  ppuVar1 = __ctype_b_loc();\n  if ((*(byte *)((long)*ppuVar1 + (param_2 & 0xff) * 2 + 1) & 1) == 0) {\n    rl_vi_eword();\n    return 0;\n  }\n  rl_vi_eWord(param_1,param_2 & 0xffffffff);\n  return 0;\n}\n\n",
  "rl_get_previous_history": "\nundefined8 rl_get_previous_history(int param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  undefined8 uVar6;\n  \n  if (param_1 < 0) {\n    uVar6 = rl_get_next_history(-param_1);\n    return uVar6;\n  }\n  if ((param_1 == 0) || (lVar3 = history_list(), lVar1 = _rl_saved_line_for_history, lVar3 == 0)) {\n    return 0;\n  }\n  if (_rl_history_saved_point == -1) {\n    if (rl_point == 0) {\n      iVar2 = rl_point;\n      if (rl_end == 0) goto LAB_001f1261;\n    }\n    else {\n      iVar2 = rl_point;\n      if (rl_point == rl_end) {\n        iVar2 = _rl_history_saved_point;\n      }\n    }\n    _rl_history_saved_point = iVar2;\n  }\nLAB_001f1261:\n  if (_rl_saved_line_for_history == 0) {\n    FUN_001f0770();\n  }\n  rl_maybe_replace_line();\n  puVar5 = (undefined8 *)0x0;\n  do {\n    puVar4 = (undefined8 *)previous_history();\n    if (puVar4 == (undefined8 *)0x0) {\n      if (puVar5 == (undefined8 *)0x0) {\n        if (lVar1 == 0) {\n          _rl_free_saved_history_line();\n        }\n        rl_ding();\n        return 0;\n      }\n      break;\n    }\n    param_1 = param_1 + -1;\n    puVar5 = puVar4;\n  } while (param_1 != 0);\n  rl_replace_line(*puVar5,0);\n  rl_mark = 0;\n  rl_undo_list = puVar5[2];\n  rl_point = rl_end;\n  if (rl_editing_mode == 0) {\n    rl_point = 0;\n    rl_mark = rl_end;\n  }\n  FUN_001f06f0();\n  return 0;\n}\n\n",
  "memmove": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memmove_00237cf8)();\n  return pvVar1;\n}\n\n",
  "builtin_usage": "\nvoid builtin_usage(void)\n\n{\n  if ((this_command_name != (char *)0x0) && (*this_command_name != '\\0')) {\n    __fprintf_chk(stderr,1,\"%s: usage: \");\n  }\n  __fprintf_chk(stderr,1,&DAT_0020fbe7,*(undefined8 *)(current_builtin + 0x20));\n  fflush(stderr);\n  return;\n}\n\n",
  "FUN_001a3980": "\nvoid FUN_001a3980(void)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  \n  uVar2 = get_name_for_error();\n  __fprintf_chk(stderr,1,&DAT_001fd57b,uVar2);\n  if (interactive_shell == 0) {\n    uVar1 = executing_line_number();\n    __fprintf_chk(stderr,1,\"line %d: \",uVar1);\n  }\n  if ((this_command_name != (char *)0x0) && (*this_command_name != '\\0')) {\n    __fprintf_chk(stderr,1,&DAT_001fd57b);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001f5180": "\nchar * FUN_001f5180(char *param_1)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  char *__dest;\n  \n  if (param_1 != (char *)0x0) {\n    sVar2 = strlen(param_1);\n    pcVar3 = (char *)xmalloc(sVar2 + 1);\n    pcVar3 = strcpy(pcVar3,param_1);\n    return pcVar3;\n  }\n  pcVar3 = (char *)sh_get_env_value(&DAT_001faa94);\n  if (pcVar3 == (char *)0x0) {\n    pcVar3 = (char *)0x0;\n  }\n  else {\n    sVar2 = strlen(pcVar3);\n    iVar1 = (int)sVar2;\n    __dest = (char *)xmalloc((long)(iVar1 + 10));\n    pcVar3 = strcpy(__dest,pcVar3);\n    pcVar3[iVar1] = '/';\n    *(undefined8 *)(pcVar3 + (long)iVar1 + 1) = 0x79726f747369682e;\n    *(undefined *)((long)(pcVar3 + (long)iVar1 + 1) + 8) = 0;\n  }\n  return pcVar3;\n}\n\n",
  "FUN_00151290": "\nbool FUN_00151290(long param_1)\n\n{\n  return (*(uint *)(param_1 + 0x28) & 0x1001) == 1;\n}\n\n",
  "FUN_001a2e10": "\nundefined8 FUN_001a2e10(char *param_1,int param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  int iVar3;\n  int iVar4;\n  char *__path;\n  char *__path_00;\n  size_t sVar5;\n  int *piVar6;\n  long lVar7;\n  undefined8 uVar8;\n  \n  if ((the_current_working_directory == 0) && (lVar7 = get_working_directory(\"chdir\"), lVar7 != 0))\n  {\n    sh_xfree(lVar7,\"./cd.def\",0x233);\n  }\n  __path = (char *)make_absolute(param_1,the_current_working_directory);\n  if (param_2 == 0) {\n    __path_00 = (char *)sh_canonpath(__path,3);\n  }\n  else {\n    __path_00 = (char *)sh_physpath(__path,0);\n  }\n  sVar5 = strlen(param_1);\n  if (__path_00 == (char *)0x0) {\nLAB_001a2e85:\n    if (posixly_correct == 0) {\n      bVar1 = true;\n      __path_00 = __path;\n      bVar2 = true;\n      if (param_2 == 0) goto LAB_001a2e9d;\nLAB_001a2f4e:\n      iVar3 = chdir(param_1);\n      __path = __path_00;\n      if (iVar3 != 0) {\nLAB_001a30c0:\n        sh_xfree(__path,\"./cd.def\",0x291);\n        return 0;\n      }\n      goto LAB_001a2f5e;\n    }\n    if (param_2 == 0) {\n      piVar6 = __errno_location();\n      if (*piVar6 != 0x24) {\n        if (*piVar6 != 2) {\n          *piVar6 = 0x14;\n        }\nLAB_001a2f16:\n        sh_xfree(__path,\"./cd.def\",0x25b);\n        return 0;\n      }\n      if (0x1000 < (int)sVar5) goto LAB_001a2f16;\n      iVar3 = chdir(__path);\n      if (iVar3 != 0) goto LAB_001a2eb5;\n    }\n    else {\n      iVar3 = chdir(param_1);\n      if (iVar3 != 0) goto LAB_001a30c0;\n    }\nLAB_001a2fc8:\n    if (the_current_working_directory != 0) {\n      sh_xfree(the_current_working_directory,\"./cd.def\",0xbf);\n    }\n    the_current_working_directory = 0;\n    lVar7 = get_working_directory(&DAT_00210a34);\n    if (lVar7 != 0) {\n      sh_xfree(lVar7,\"./cd.def\",0x284);\n      goto LAB_001a2f6b;\n    }\n  }\n  else {\n    if (*__path_00 == '\\0') {\n      sh_xfree(__path_00,\"./cd.def\",0x247);\n      goto LAB_001a2e85;\n    }\n    sh_xfree(__path,\"./cd.def\",0x244);\n    bVar1 = false;\n    bVar2 = false;\n    if (param_2 != 0) goto LAB_001a2f4e;\nLAB_001a2e9d:\n    bVar1 = bVar2;\n    iVar3 = chdir(__path_00);\n    if (iVar3 != 0) {\n      piVar6 = __errno_location();\n      __path = __path_00;\nLAB_001a2eb5:\n      iVar3 = *piVar6;\n      if ((posixly_correct == 0) && (iVar4 = chdir(param_1), iVar4 == 0)) {\n        if (the_current_working_directory != 0) {\n          sh_xfree(the_current_working_directory,\"./cd.def\",0xbf);\n        }\n        the_current_working_directory = 0;\n        lVar7 = get_working_directory(&DAT_00210a34);\n        if (lVar7 == 0) {\n          uVar8 = 1;\n          set_working_directory(__path);\n        }\n        else {\n          uVar8 = 1;\n          sh_xfree(lVar7,\"./cd.def\",0x2a1);\n        }\n      }\n      else {\n        *piVar6 = iVar3;\n        uVar8 = 0;\n      }\n      sh_xfree(__path,\"./cd.def\",0x2ab);\n      return uVar8;\n    }\nLAB_001a2f5e:\n    __path = __path_00;\n    if (bVar1) goto LAB_001a2fc8;\n  }\n  set_working_directory(__path);\nLAB_001a2f6b:\n  sh_xfree(__path,\"./cd.def\",0x289);\n  return 1;\n}\n\n",
  "parse_and_execute_cleanup": "\nvoid parse_and_execute_cleanup(int param_1)\n\n{\n  int iVar1;\n  \n  if (0 < running_trap) {\n    if (running_trap != param_1) {\n      run_trap_cleanup(running_trap + -1);\n    }\n    unfreeze_jobs_list();\n  }\n  iVar1 = have_unwind_protects();\n  if (iVar1 == 0) {\n    parse_and_execute_level = 0;\n    return;\n  }\n  run_unwind_frame(\"parse_and_execute top\");\n  return;\n}\n\n",
  "FUN_001f23f0": "\nulong FUN_001f23f0(long param_1,uint param_2)\n\n{\n  byte bVar1;\n  char cVar2;\n  ushort *puVar3;\n  ulong uVar4;\n  char *pcVar5;\n  ushort **ppuVar6;\n  char *pcVar7;\n  byte *pbVar8;\n  int iVar9;\n  ulong uVar10;\n  byte bVar11;\n  long lVar12;\n  int __c;\n  int iVar13;\n  ulong uVar14;\n  \n  uVar10 = (ulong)(int)param_2;\n  uVar14 = (ulong)param_2;\n  bVar11 = *(byte *)(param_1 + uVar10);\n  if (bVar11 == 0) {\n    return uVar14;\n  }\n  __c = (int)(char)bVar11;\n  pcVar5 = strchr(\"()\\n\",__c);\n  if (pcVar5 != (char *)0x0) goto LAB_001f242c;\n  ppuVar6 = __ctype_b_loc();\n  puVar3 = *ppuVar6;\n  if ((*(byte *)((long)puVar3 + (ulong)bVar11 * 2 + 1) & 8) == 0) {\nLAB_001f249d:\n    param_2 = (uint)uVar14;\n    pcVar5 = strchr(\"<>;&|\",__c);\n    if (pcVar5 == (char *)0x0) goto LAB_001f2508;\n    bVar1 = *(byte *)(param_1 + 1 + uVar10);\n    if (bVar1 == bVar11) {\n      if (bVar1 == 0x3c) {\n        cVar2 = *(char *)(param_1 + 2 + uVar10);\n        if (cVar2 == '-') {\n          param_2 = param_2 + 1;\n        }\n        else {\n          param_2 = param_2 + (cVar2 == '<');\n        }\n      }\nLAB_001f2672:\n      return (ulong)(param_2 + 2);\n    }\n    if (bVar1 == 0x26) {\n      if ((bVar11 & 0xfd) == 0x3c) {\n        param_2 = param_2 + 2;\n        pbVar8 = (byte *)((int)param_2 + param_1);\n        bVar11 = *pbVar8;\n        while( true ) {\n          if (bVar11 == 0) {\n            return (ulong)param_2;\n          }\n          if ((*(byte *)((long)puVar3 + (ulong)bVar11 * 2 + 1) & 8) == 0) break;\n          bVar11 = pbVar8[1];\n          pbVar8 = pbVar8 + 1;\n          param_2 = param_2 + 1;\n        }\n        return (ulong)(param_2 + (bVar11 == 0x2d));\n      }\nLAB_001f242c:\n      return (ulong)(param_2 + 1);\n    }\n    if (bVar1 == 0x3e) {\n      if (bVar11 == 0x26) goto LAB_001f2672;\n      goto LAB_001f242c;\n    }\n    if (bVar1 == 0x7c) {\n      if (bVar11 == 0x3e) goto LAB_001f2672;\n      goto LAB_001f242c;\n    }\n    if ((bVar1 != 0x28) || ((bVar11 & 0xfd) != 0x3c)) goto LAB_001f242c;\n    param_2 = param_2 + 2;\n    iVar9 = 1;\n    __c = 0x29;\n  }\n  else {\n    uVar4 = (long)(int)(param_2 + 1);\n    do {\n      uVar10 = uVar4;\n      bVar11 = *(byte *)(param_1 + uVar10);\n      uVar14 = uVar10 & 0xffffffff;\n      if (bVar11 == 0) {\n        return uVar14;\n      }\n      uVar4 = uVar10 + 1;\n    } while ((*(byte *)((long)puVar3 + (ulong)bVar11 * 2 + 1) & 8) != 0);\n    __c = (int)(char)bVar11;\n    if ((bVar11 & 0xfd) == 0x3c) goto LAB_001f249d;\nLAB_001f2508:\n    pcVar5 = strchr(\"\\\"\\'`\",__c);\n    if (pcVar5 == (char *)0x0) {\n      lVar12 = (long)(int)uVar14;\n      iVar9 = 0;\n      __c = 0;\n      cVar2 = *(char *)(param_1 + lVar12);\n      pcVar5 = history_word_delimiters;\n      goto LAB_001f257e;\n    }\n    param_2 = (int)uVar14 + 1;\n    iVar9 = 0;\n  }\n  uVar14 = (ulong)param_2;\n  lVar12 = (long)(int)param_2;\n  cVar2 = *(char *)(param_1 + lVar12);\n  pcVar5 = history_word_delimiters;\n  if (cVar2 == '\\0') {\n    return uVar14;\n  }\nLAB_001f257e:\n  do {\n    iVar13 = (int)uVar14;\n    if (cVar2 == '\\\\') {\n      if ((*(char *)(param_1 + 1 + lVar12) == '\\n') || (__c != 0x27)) {\n        iVar13 = iVar13 + 1;\n      }\n      else {\n        if (iVar9 != 0) goto LAB_001f2558;\nLAB_001f2608:\n        iVar9 = 0;\n        if (cVar2 == __c) {\n          __c = 0;\n        }\n      }\n    }\n    else if (iVar9 == 0) {\n      if (__c != 0) goto LAB_001f2608;\n      pcVar7 = strchr(\"<>$!@?+*\",(int)cVar2);\n      if ((pcVar7 == (char *)0x0) || (*(char *)(param_1 + 1 + lVar12) != '(')) {\nLAB_001f25ab:\n        __c = (int)cVar2;\n        pcVar7 = strchr(pcVar5,__c);\n        if (pcVar7 != (char *)0x0) {\n          return uVar14;\n        }\n        pcVar7 = strchr(\"\\\"\\'`\",__c);\n        if (pcVar7 == (char *)0x0) {\n          __c = 0;\n        }\n      }\n      else {\n        iVar13 = iVar13 + 2;\n        iVar9 = 1;\n        __c = 0x29;\n      }\n    }\n    else if (cVar2 == '(') {\n      iVar9 = iVar9 + 1;\n    }\n    else {\nLAB_001f2558:\n      if (cVar2 == __c) {\n        iVar9 = iVar9 + -1;\n        if (iVar9 == 0) {\n          __c = 0;\n        }\n      }\n      else if (__c == 0) goto LAB_001f25ab;\n    }\n    uVar14 = (ulong)(iVar13 + 1U);\n    lVar12 = (long)(int)(iVar13 + 1U);\n    cVar2 = *(char *)(param_1 + lVar12);\n    if (cVar2 == '\\0') {\n      return uVar14;\n    }\n  } while( true );\n}\n\n",
  "assoc_replace": "\nundefined8 assoc_replace(undefined8 param_1,long param_2,char *param_3)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *__dest;\n  undefined8 uVar3;\n  \n  lVar1 = hash_search(param_2,param_1,2);\n  if (lVar1 == 0) {\n    uVar3 = 0;\n  }\n  else {\n    if (*(long *)(lVar1 + 8) != param_2) {\n      sh_xfree(param_2,\"assoc.c\",0x6b);\n    }\n    uVar3 = *(undefined8 *)(lVar1 + 0x10);\n    if (param_3 != (char *)0x0) {\n      sVar2 = strlen(param_3);\n      __dest = (char *)sh_xmalloc(sVar2 + 1,\"assoc.c\",0x6d);\n      param_3 = strcpy(__dest,param_3);\n    }\n    *(char **)(lVar1 + 0x10) = param_3;\n  }\n  return uVar3;\n}\n\n",
  "wcsncmp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcsncmp(wchar_t *__s1,wchar_t *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wcsncmp_00237e80)();\n  return iVar1;\n}\n\n",
  "progcomp_size": "\nundefined4 progcomp_size(void)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = 0;\n  if (prog_completes != 0) {\n    uVar1 = *(undefined4 *)(prog_completes + 0xc);\n  }\n  return uVar1;\n}\n\n",
  "rl_vi_overstrike": "\nundefined8 rl_vi_overstrike(int param_1,undefined4 param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_0024a420 == 0) {\n    DAT_0024a420 = 1;\n    rl_begin_undo_group();\n  }\n  if (param_1 < 1) {\n    return 0;\n  }\n  uVar1 = _rl_overwrite_char(param_1,param_2);\n  if ((int)uVar1 == 0) {\n    DAT_0024a410 = DAT_0024a410 + param_1;\n    return uVar1;\n  }\n  return 1;\n}\n\n",
  "_rl_compare_chars": "\nundefined8\n_rl_compare_chars(long param_1,int param_2,undefined8 param_3,long param_4,int param_5,\n                 undefined8 param_6)\n\n{\n  char *pcVar1;\n  int iVar2;\n  int iVar3;\n  long lVar4;\n  char *pcVar5;\n  \n  pcVar1 = (char *)(param_1 + param_2);\n  iVar2 = _rl_get_char_len(pcVar1,param_3);\n  if (0 < iVar2) {\n    pcVar5 = (char *)(param_4 + param_5);\n    iVar3 = _rl_get_char_len(pcVar5,param_6);\n    if (((iVar2 == iVar3) && (0 < iVar3)) && (*pcVar1 == *pcVar5)) {\n      if (1 < iVar2) {\n        lVar4 = 1;\n        do {\n          if (pcVar1[lVar4] != pcVar5[lVar4]) {\n            return 0;\n          }\n          lVar4 = lVar4 + 1;\n        } while (iVar2 != lVar4);\n      }\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
  "FUN_00164d30": "\nvoid FUN_00164d30(int param_1)\n\n{\n  __pid_t __pid;\n  \n  set_signal_handler(0x14,DAT_00247688);\n  set_signal_handler(0x16,DAT_00247680);\n  set_signal_handler(0x15,DAT_00247678);\n  DAT_00247670 = set_signal_handler(0x12,FUN_00162a10);\n  give_terminal_to(shell_pgrp,0);\n  __pid = getpid();\n  kill(__pid,param_1);\n  return;\n}\n\n",
  "fdopen": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nFILE * fdopen(int __fd,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = (FILE *)(*(code *)PTR_fdopen_00237ca0)();\n  return pFVar1;\n}\n\n",
  "hash_flush": "\nvoid hash_flush(long *param_1,code *param_2)\n\n{\n  long *plVar1;\n  long **pplVar2;\n  long lVar3;\n  long *plVar4;\n  long lVar5;\n  \n  if (param_1 == (long *)0x0) {\n    return;\n  }\n  if (*(int *)((long)param_1 + 0xc) != 0) {\n    if (0 < *(int *)(param_1 + 1)) {\n      lVar3 = *param_1;\n      lVar5 = 0;\n      do {\n        pplVar2 = (long **)(lVar5 * 8 + lVar3);\n        plVar4 = *pplVar2;\n        if (*pplVar2 != (long *)0x0) {\n          do {\n            plVar1 = (long *)*plVar4;\n            if (param_2 == (code *)0x0) {\n              sh_xfree(plVar4[2],\"hashlib.c\",0x18d);\n            }\n            else {\n              (*param_2)(plVar4[2]);\n            }\n            sh_xfree(plVar4[1],\"hashlib.c\",0x18e);\n            sh_xfree(plVar4,\"hashlib.c\",399);\n            plVar4 = plVar1;\n          } while (plVar1 != (long *)0x0);\n          lVar3 = *param_1;\n          pplVar2 = (long **)(lVar5 * 8 + lVar3);\n        }\n        *pplVar2 = (long *)0x0;\n        lVar5 = lVar5 + 1;\n      } while (*(int *)(param_1 + 1) != (int)lVar5 && (int)lVar5 <= *(int *)(param_1 + 1));\n    }\n    *(undefined4 *)((long)param_1 + 0xc) = 0;\n  }\n  return;\n}\n\n",
  "rl_backward_kill_line": "\nundefined8 rl_backward_kill_line(int param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = rl_point;\n  if (param_1 < 0) {\n    rl_end_of_line(1);\n    if (rl_point != iVar1) {\n      rl_kill_text(iVar1);\n    }\n    rl_point = iVar1;\n    if (rl_editing_mode == 1) {\n      rl_mark = iVar1;\n    }\n  }\n  else if (rl_point == 0) {\n    rl_ding();\n  }\n  else {\n    rl_beg_of_line(1);\n    if (rl_point != iVar1) {\n      rl_kill_text(iVar1);\n    }\n    if (rl_editing_mode == 1) {\n      rl_mark = rl_point;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
  "replace_history_entry": "\nlong replace_history_entry(int param_1,char *param_2,char *param_3)\n\n{\n  long lVar1;\n  char **ppcVar2;\n  size_t sVar3;\n  char *pcVar4;\n  char *pcVar5;\n  long lVar6;\n  \n  lVar6 = 0;\n  if ((-1 < param_1) && (param_1 < history_length)) {\n    ppcVar2 = (char **)xmalloc(0x18);\n    lVar6 = *(long *)(DAT_0024b6e8 + (long)param_1 * 8);\n    sVar3 = strlen(param_2);\n    pcVar4 = (char *)xmalloc(sVar3 + 1);\n    pcVar5 = strcpy(pcVar4,param_2);\n    pcVar4 = *(char **)(lVar6 + 8);\n    ppcVar2[2] = param_3;\n    *ppcVar2 = pcVar5;\n    if (pcVar4 != (char *)0x0) {\n      sVar3 = strlen(pcVar4);\n      pcVar5 = (char *)xmalloc(sVar3 + 1);\n      pcVar4 = strcpy(pcVar5,pcVar4);\n    }\n    lVar1 = DAT_0024b6e8;\n    ppcVar2[1] = pcVar4;\n    *(char ***)(lVar1 + (long)param_1 * 8) = ppcVar2;\n  }\n  return lVar6;\n}\n\n",
  "FUN_001f9500": "\nchar * FUN_001f9500(char *param_1,ulong param_2,char *param_3,undefined4 param_4)\n\n{\n  uint uVar1;\n  char cVar2;\n  int iVar3;\n  ulong *puVar4;\n  char *pcVar5;\n  long lVar6;\n  ulong uVar7;\n  char cVar8;\n  uint uVar9;\n  ulong __new_len;\n  char cVar10;\n  ulong __n;\n  int iVar11;\n  ulong uVar12;\n  char *pcVar13;\n  char *pcVar14;\n  int local_58;\n  \n  if (param_2 == 0) {\n    FUN_001f8ee0(param_1,param_3,param_4);\n    return (char *)0x0;\n  }\n  if (param_1 == (char *)0x0) {\n    pcVar5 = (char *)FUN_001f85f0(param_2,param_3,param_4);\n    return pcVar5;\n  }\n  iVar3 = (int)param_1[-0xf];\n  if (0x1b < iVar3) {\n    pcVar5 = \"unknown\";\n    if (param_3 != (char *)0x0) {\n      pcVar5 = param_3;\n    }\n    __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar5,param_4);\n    fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"nunits < 28\",param_3,param_4);\n  }\n  if (param_1[-0x10] != -9) {\n    pcVar5 = \"unknown\";\n    if (param_3 != (char *)0x0) {\n      pcVar5 = param_3;\n    }\n    __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar5,param_4);\n    fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"realloc: called with unallocated block argument\",param_3,param_4);\n  }\n  if (*(short *)(param_1 + -0xe) != 0x5555) {\n    pcVar5 = \"unknown\";\n    if (param_3 != (char *)0x0) {\n      pcVar5 = param_3;\n    }\n    __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar5,param_4);\n    fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"p->minfo.mi_magic2 == 0x5555\",param_3,param_4);\n  }\n  if ((ulong)(&DAT_00214400)[iVar3] < (ulong)(*(int *)(param_1 + -0xc) + 0x23U & 0xfffffff0)) {\n    pcVar5 = \"unknown\";\n    if (param_3 != (char *)0x0) {\n      pcVar5 = param_3;\n    }\n    __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar5,param_4);\n    fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"realloc: underflow detected; mh_nbytes out of range\",param_3,param_4);\n  }\n  pcVar5 = \"unknown\";\n  pcVar14 = param_1 + -8;\n  if (param_3 != (char *)0x0) {\n    pcVar5 = param_3;\n  }\n  do {\n    pcVar13 = pcVar14;\n    pcVar14 = pcVar13 + 1;\n    if (*pcVar13 != 'U') {\n      __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar5,param_4);\n      fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n      programming_error(\"realloc: underflow detected; magic8 corrupted\",param_3,param_4);\n    }\n  } while (param_1 != pcVar14);\n  uVar12 = (ulong)*(uint *)(pcVar13 + -0xb);\n  uVar1 = *(uint *)(pcVar14 + uVar12);\n  if (*(uint *)(pcVar13 + -0xb) != uVar1) {\n    pcVar5 = \"unknown\";\n    if (param_3 != (char *)0x0) {\n      pcVar5 = param_3;\n    }\n    __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar5,param_4);\n    fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"realloc: start and end chunk sizes differ\",param_3,param_4);\n  }\n  if (param_2 == uVar12) {\n    return pcVar14;\n  }\n  if (param_2 + 0x23 >> 0x20 != 0) {\n    return (char *)0x0;\n  }\n  local_58 = (int)param_2;\n  uVar9 = local_58 + 0x23U & 0xfffffff0;\n  uVar7 = (ulong)uVar9;\n  cVar10 = (char)(param_2 >> 8);\n  cVar8 = (char)(param_2 >> 0x10);\n  cVar2 = (char)(param_2 >> 0x18);\n  if (uVar7 < (ulong)(&DAT_00214400)[iVar3 + -1] || uVar7 == (&DAT_00214400)[iVar3 + -1]) {\n    if ((ulong)(&DAT_00214400)[iVar3 + -2] <= uVar7 && uVar7 != (&DAT_00214400)[iVar3 + -2])\n    goto LAB_001f984b;\n  }\n  else if (uVar7 <= (ulong)(&DAT_00214400)[iVar3]) {\nLAB_001f984b:\n    *(uint *)(pcVar14 + uVar12) = 0;\n    *(int *)(pcVar13 + -0xb) = local_58;\n    pcVar5 = pcVar14 + (param_2 & 0xffffffff);\n    *pcVar5 = (char)param_2;\n    pcVar5[2] = cVar8;\n    pcVar5[1] = cVar10;\n    pcVar5[3] = cVar2;\n    return pcVar14;\n  }\n  __n = uVar12;\n  if (param_2 < uVar12) {\n    __n = param_2 & 0xffffffff;\n  }\n  iVar11 = iVar3;\n  if ((uVar1 < uVar9) || (iVar11 = DAT_0024b79c, (uint)(DAT_0024b7a0 >> 1) < uVar9)) {\n    if (0x1b < iVar11) {\nLAB_001f9940:\n      if (iVar11 < iVar3) {\n        iVar3 = iVar11;\n      }\n      if (malloc_mmap_threshold < iVar3) {\n        return (char *)0x0;\n      }\n      goto LAB_001f96c1;\n    }\n    lVar6 = (long)iVar11;\n    __new_len = (&DAT_00214400)[lVar6];\n  }\n  else {\n    __new_len = 0x20;\n    iVar11 = 0;\n    lVar6 = 0;\n  }\n  puVar4 = &DAT_00214400 + lVar6;\n  while (__new_len < uVar7) {\n    iVar11 = iVar11 + 1;\n    puVar4 = puVar4 + 1;\n    if (iVar11 == 0x1c) goto LAB_001f9940;\n    __new_len = *puVar4;\n  }\n  if (iVar11 < iVar3) {\n    iVar3 = iVar11;\n  }\n  if (malloc_mmap_threshold < iVar3) {\n    *(undefined4 *)(pcVar14 + uVar12) = 0;\n    (&DAT_0024b7b0)[iVar11] = 1;\n    pcVar5 = (char *)mremap(pcVar13 + -0xf,(&DAT_00214400)[pcVar13[-0xe]],__new_len,1);\n    (&DAT_0024b7b0)[iVar11] = 0;\n    if (pcVar5 == &DAT_ffffffffffffffff) {\n      return (char *)0x0;\n    }\n    if (pcVar13 + -0xf != pcVar5) {\n      *pcVar5 = -9;\n      *(undefined2 *)(pcVar5 + 2) = 0x5555;\n      *(undefined8 *)(pcVar5 + 8) = 0x5555555555555555;\n    }\n    pcVar5[1] = (char)iVar11;\n    pcVar14 = pcVar5 + param_2 + 0x10;\n    *(int *)(pcVar5 + 4) = local_58;\n    *pcVar14 = (char)param_2;\n    pcVar14[1] = cVar10;\n    pcVar14[2] = cVar8;\n    pcVar14[3] = cVar2;\n    return pcVar5 + 0x10;\n  }\nLAB_001f96c1:\n  pcVar5 = (char *)FUN_001f85f0(param_2,param_3,param_4);\n  if (pcVar5 == (char *)0x0) {\n    return (char *)0x0;\n  }\n  memcpy(pcVar5,pcVar14,__n);\n  FUN_001f8ee0(pcVar14,param_3,param_4);\n  return pcVar5;\n}\n\n",
  "FUN_00151260": "\nundefined8 FUN_00151260(undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
  "print_assoc_assignment": "\nvoid print_assoc_assignment(undefined8 *param_1,int param_2)\n\n{\n  long lVar1;\n  undefined *puVar2;\n  \n  lVar1 = assoc_to_assign(param_1[1]);\n  if (lVar1 != 0) {\n    __printf_chk(1,\"%s=%s\\n\",*param_1,lVar1);\n    sh_xfree(lVar1,\"arrayfunc.c\",0x4dd);\n    return;\n  }\n  puVar2 = &DAT_001ff15d;\n  if (param_2 == 0) {\n    puVar2 = &DAT_001ff146;\n  }\n  __printf_chk(1,\"%s=%s\\n\",*param_1,puVar2);\n  return;\n}\n\n",
  "rl_get_termcap": "\nundefined8 rl_get_termcap(char *param_1)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined **ppuVar5;\n  char *__s1;\n  \n  if (DAT_0024b668 == 0) {\n    return 0;\n  }\n  cVar2 = '@';\n  ppuVar5 = &PTR_DAT_00235a70;\n  iVar4 = 0;\n  cVar1 = *param_1;\n  __s1 = \"@7\";\n  while( true ) {\n    if (cVar1 == cVar2) {\n      iVar3 = strcmp(__s1,param_1);\n      if (iVar3 == 0) {\n        return *(undefined8 *)(&PTR_DAT_00235a68)[(long)iVar4 * 2];\n      }\n    }\n    iVar4 = iVar4 + 1;\n    if (iVar4 == 0x22) break;\n    __s1 = *ppuVar5;\n    ppuVar5 = ppuVar5 + 2;\n    cVar2 = *__s1;\n  }\n  return 0;\n}\n\n",
  "programmable_completions": "\nundefined8\nprogrammable_completions(char *param_1,undefined8 param_2,int param_3,int param_4,int *param_5)\n\n{\n  int iVar1;\n  size_t __n;\n  undefined8 uVar2;\n  char *pcVar3;\n  size_t __n_00;\n  size_t sVar4;\n  size_t sVar5;\n  undefined8 extraout_RDX;\n  undefined8 extraout_RDX_00;\n  undefined8 *puVar6;\n  char *__s;\n  char *pcVar7;\n  int iVar8;\n  long in_FS_OFFSET;\n  undefined auVar9 [16];\n  undefined auVar10 [16];\n  long *plVar11;\n  int local_a0;\n  int local_50;\n  int local_4c;\n  long local_48;\n  long local_40;\n  \n  iVar8 = 1;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = 0;\n  local_50 = 0;\n  pcomp_line = rl_line_buffer;\n  pcomp_ind = rl_point;\n  __n = (size_t)param_3;\n  __s = param_1;\n  do {\n    local_4c = 0;\n    plVar11 = &local_48;\n    uVar2 = FUN_001a0af0(__s,__s,param_2,param_3,param_4,&local_50,&local_4c);\n    auVar9._8_8_ = plVar11;\n    auVar9._0_8_ = uVar2;\n    pcVar7 = __s;\n    if ((local_50 == 0) &&\n       (((pcVar3 = strrchr(__s,0x2f), pcVar3 == (char *)0x0 || (pcVar3[1] == '\\0')) ||\n        (auVar9 = FUN_001a0af0(pcVar3 + 1,__s,param_2,param_3,param_4,&local_50,&local_4c,&local_48)\n        , local_50 == 0)))) {\n      auVar9 = FUN_001a0af0(\"_DefaultCmD_\",__s,param_2,param_3,param_4,&local_50,&local_4c,&local_48\n                           );\n      uVar2 = auVar9._8_8_;\n      puVar6 = auVar9._0_8_;\n      if (local_50 != 0) goto LAB_001a0ef2;\n      if (local_4c == 0) {\n        auVar9._8_4_ = progcomp_alias;\n        auVar9._0_8_ = puVar6;\n        auVar9._12_4_ = 0;\n        if (progcomp_alias == 0) {\n          if (iVar8 != 0x21) goto LAB_001a0df0;\nLAB_001a0dcc:\n          puVar6 = auVar9._0_8_;\n          internal_warning(\"programmable_completion: %s: possible retry loop\",param_1,auVar9._8_8_);\n          __s = pcVar7;\nLAB_001a0df0:\n          if (pcomp_line != rl_line_buffer) {\n            sh_xfree(pcomp_line,\"pcomplete.c\",0x6c4);\n          }\n          if (__s != param_1) {\n            sh_xfree(__s,\"pcomplete.c\",0x6c6);\n          }\n          uVar2 = 0;\n          if (puVar6 != (undefined8 *)0x0) {\n            uVar2 = *puVar6;\n            sh_xfree(puVar6,\"pcomplete.c\",0x6cb);\n          }\n          if (param_5 != (int *)0x0) {\n            *param_5 = local_50;\n          }\n          if (local_48 != 0) {\n            compspec_dispose();\n          }\n          pcomp_line = rl_line_buffer;\n          pcomp_ind = rl_point;\n          if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n            __stack_chk_fail();\n          }\n          return uVar2;\n        }\n        auVar10 = find_alias(__s);\n        auVar9._8_8_ = auVar10._8_8_;\n        if (auVar10._0_8_ == 0) goto LAB_001a0ef2;\n        pcVar7 = *(char **)(auVar10._0_8_ + 8);\n        __n_00 = strlen(pcVar7);\n        pcVar3 = pcomp_line;\n        if (__n_00 == 0) goto LAB_001a0df0;\n        sVar4 = strlen(__s);\n        local_a0 = (int)__n_00;\n        local_a0 = local_a0 - (int)sVar4;\n        sVar5 = strlen(pcVar3);\n        pcVar3 = (char *)sh_xmalloc((long)local_a0 + 1 + sVar5,\"pcomplete.c\",0x695);\n        if (0 < param_3) {\n          strncpy(pcVar3,pcomp_line,__n);\n        }\n        strncpy(pcVar3 + __n,pcVar7,__n_00);\n        strcpy(pcVar3 + __n_00 + __n,pcomp_line + sVar4 + __n);\n        iVar1 = skip_to_delim(pcVar7,0,&DAT_001ff6c9,0x101);\n        if (iVar1 < 1) {\n          sh_xfree(pcVar3,\"pcomplete.c\",0x6a3);\n          goto LAB_001a0df0;\n        }\n        auVar9 = substring(pcVar7,0,iVar1);\n        uVar2 = auVar9._8_8_;\n        pcVar7 = auVar9._0_8_;\n        pcomp_ind = pcomp_ind + local_a0;\n        param_4 = param_4 + local_a0;\n        if (__s != param_1) {\n          sh_xfree(__s,\"pcomplete.c\",0x6ad);\n          uVar2 = extraout_RDX;\n        }\n        if (pcomp_line != rl_line_buffer) {\n          sh_xfree(pcomp_line,\"pcomplete.c\",0x6af);\n          uVar2 = extraout_RDX_00;\n        }\n        local_4c = 1;\n        pcomp_line = pcVar3;\n      }\n      auVar9._8_8_ = uVar2;\n      auVar9._0_8_ = puVar6;\n      __s = pcVar7;\n      if (iVar8 == 0x21) goto LAB_001a0dcc;\n    }\n    else {\nLAB_001a0ef2:\n      puVar6 = auVar9._0_8_;\n      if (iVar8 == 0x21) goto LAB_001a0dcc;\n      if (local_4c == 0) goto LAB_001a0df0;\n    }\n    iVar8 = iVar8 + 1;\n  } while( true );\n}\n\n",
  "strip_trailing_ifs_whitespace": "\nbyte * strip_trailing_ifs_whitespace(byte *param_1,undefined8 param_2,int param_3)\n\n{\n  byte bVar1;\n  long lVar2;\n  byte *pbVar3;\n  size_t sVar4;\n  \n  if (param_1 == (byte *)0x0) {\n    pbVar3 = &DAT_ffffffffffffffff;\n  }\n  else {\n    if (*param_1 == 0) {\n      lVar2 = -1;\n    }\n    else {\n      pbVar3 = param_1;\n      if (param_1[1] == 0) goto LAB_0016ead6;\n      lVar2 = 1;\n      if (param_1[2] != 0) {\n        sVar4 = strlen((char *)param_1);\n        lVar2 = sVar4 - 1;\n      }\n    }\n    pbVar3 = param_1 + lVar2;\n    if (pbVar3 <= param_1) goto LAB_0016ead6;\n  }\n  do {\n    bVar1 = *pbVar3;\n    if ((((1 < (byte)(bVar1 - 9)) && (bVar1 != 0x20)) ||\n        (*(char *)((long)&ifs_cmap + (ulong)bVar1) == '\\0')) &&\n       (((param_3 == 0 || (bVar1 != 1)) || ((1 < (byte)(pbVar3[1] - 9) && (pbVar3[1] != 0x20))))))\n    break;\n    pbVar3 = pbVar3 + -1;\n  } while (param_1 < pbVar3);\nLAB_0016ead6:\n  pbVar3[1] = 0;\n  return param_1;\n}\n\n",
  "rl_kill_line": "\nundefined8 rl_kill_line(int param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = rl_point;\n  if (param_1 < 0) {\n    if (rl_point == 0) {\n      rl_ding();\n      return 0;\n    }\n    rl_beg_of_line(1);\n    if (rl_point != iVar1) {\n      rl_kill_text(iVar1);\n    }\n    if (rl_editing_mode == 1) {\n      rl_mark = rl_point;\n    }\n  }\n  else {\n    rl_end_of_line(1);\n    if (rl_point != iVar1) {\n      rl_kill_text(iVar1);\n    }\n    rl_point = iVar1;\n    if (rl_editing_mode == 1) {\n      rl_mark = iVar1;\n      rl_point = rl_mark;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
  "rl_ding": "\nundefined8 rl_ding(void)\n\n{\n  if (_rl_echoing_p == 0) {\n    return 0xffffffff;\n  }\n  if (_rl_bell_preference != 1) {\n    if (_rl_bell_preference != 2) {\n      return 0;\n    }\n    if (DAT_0024b660 != 0) {\n      tputs(DAT_0024b660,1,_rl_output_character_function);\n      return 0;\n    }\n  }\n  fputc(7,stderr);\n  fflush(stderr);\n  return 0;\n}\n\n",
  "set_current_flags": "\nvoid set_current_flags(char *param_1)\n\n{\n  char cVar1;\n  int **ppiVar2;\n  char cVar3;\n  int *piVar4;\n  \n  if (param_1 != (char *)0x0) {\n    ppiVar2 = (int **)(shell_flags + 0x18);\n    cVar3 = 'b';\n    piVar4 = &mark_modified_vars;\n    while( true ) {\n      cVar1 = *param_1;\n      param_1 = param_1 + 1;\n      *piVar4 = (int)cVar1;\n      if (cVar3 == '\\0') break;\n      piVar4 = *ppiVar2;\n      cVar3 = *(char *)(ppiVar2 + 1);\n      ppiVar2 = ppiVar2 + 2;\n    }\n  }\n  return;\n}\n\n",
  "glob_pattern_p": "\nint glob_pattern_p(char *__pattern,int __quote)\n\n{\n  int iVar1;\n  int *piVar2;\n  int iVar3;\n  size_t sVar4;\n  long lVar5;\n  ulong uVar6;\n  int *piVar7;\n  int *piVar8;\n  int iVar9;\n  long in_FS_OFFSET;\n  bool bVar10;\n  int *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar4 = __ctype_get_mb_cur_max();\n  if ((sVar4 == 1) || (lVar5 = mbsmbchar(__pattern), lVar5 == 0)) {\n    if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n      iVar3 = FUN_001bcfa0(__pattern);\n      return iVar3;\n    }\n  }\n  else {\n    lVar5 = xdupmbstowcs(&local_18,0,__pattern);\n    if (lVar5 == -1) {\n      iVar3 = FUN_001bcfa0(__pattern);\n    }\n    else {\n      iVar3 = *local_18;\n      if (iVar3 != 0) {\n        iVar9 = 0;\n        iVar1 = iVar3 + -0x5b;\n        bVar10 = iVar3 == 0x5b;\n        piVar2 = local_18 + 1;\n        piVar8 = local_18;\n        if (bVar10) goto LAB_001bdb12;\n        do {\n          piVar7 = piVar2;\n          if (bVar10 || SBORROW4(iVar3,0x5b) != iVar1 < 0) {\n            if (iVar3 - 0x21U < 0x20) {\n              uVar6 = 1L << ((byte)(iVar3 - 0x21U) & 0x3f);\n              if ((uVar6 & 0x80000401) == 0) {\n                if ((uVar6 & 0x40000200) != 0) {\nLAB_001bdb35:\n                  iVar3 = 1;\n                  break;\n                }\n              }\n              else if (piVar8[1] == 0x28) goto LAB_001bdb35;\n            }\n          }\n          else if (iVar3 == 0x5c) {\n            iVar3 = piVar8[1];\n            if (iVar3 == 0) break;\n            piVar7 = piVar8 + 2;\n          }\n          else if ((iVar3 == 0x5d) && (iVar9 != 0)) goto LAB_001bdb35;\n          while( true ) {\n            iVar3 = *piVar7;\n            if (iVar3 == 0) goto LAB_001bdb3b;\n            iVar1 = iVar3 + -0x5b;\n            bVar10 = iVar1 == 0;\n            piVar2 = piVar7 + 1;\n            piVar8 = piVar7;\n            if (!bVar10) break;\nLAB_001bdb12:\n            piVar7 = piVar2;\n            iVar9 = iVar9 + 1;\n          }\n        } while( true );\n      }\nLAB_001bdb3b:\n      sh_xfree(local_18,\"glob.c\",0xb3);\n    }\n    if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return iVar3;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_vi_bracktype": "\nuint rl_vi_bracktype(int param_1)\n\n{\n  uint uVar1;\n  \n  if (param_1 == 0x5d) {\n    return 0xfffffffe;\n  }\n  if (param_1 < 0x5e) {\n    uVar1 = 0xffffffff;\n    if ((param_1 != 0x29) && (uVar1 = 2, param_1 != 0x5b)) {\n      return (uint)(param_1 == 0x28);\n    }\n  }\n  else {\n    uVar1 = 3;\n    if (param_1 != 0x7b) {\n      return (uint)(param_1 != 0x7d) * 3 - 3;\n    }\n  }\n  return uVar1;\n}\n\n",
  "sh_get_env_value": "\nundefined8 sh_get_env_value(void)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = find_variable();\n  if (lVar1 != 0) {\n    uVar2 = get_variable_value(lVar1);\n    return uVar2;\n  }\n  return 0;\n}\n\n",
  "FUN_00147cb0": "\nvoid FUN_00147cb0(long param_1,int param_2,int param_3,long param_4,uint param_5)\n\n{\n  long lVar1;\n  undefined uVar2;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  uint uVar6;\n  ulong uVar7;\n  int iVar8;\n  long lVar9;\n  long in_FS_OFFSET;\n  byte abStack_58 [21];\n  undefined local_43;\n  long local_40;\n  \n  uVar7 = (ulong)param_5;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_43 = 0;\n  if (param_3 == 0) {\n    iVar8 = 0;\n  }\n  else {\n    lVar9 = 0x14;\n    lVar5 = param_4 / 0x3c;\n    param_4 = param_4 % 0x3c;\n    do {\n      iVar4 = (int)lVar9;\n      lVar1 = lVar5 / 10;\n      uVar6 = (int)lVar5 + (int)lVar1 * -10 + 0x30;\n      abStack_58[lVar9] = (byte)uVar6;\n      lVar9 = lVar9 + -1;\n      lVar5 = lVar1;\n    } while (lVar1 != 0);\n    lVar5 = 1;\n    do {\n      *(char *)(param_1 + -1 + lVar5) = (char)uVar6;\n      iVar8 = (int)lVar5;\n      lVar5 = lVar5 + 1;\n      uVar6 = (uint)abStack_58[lVar5 + iVar4 + -1];\n    } while (abStack_58[lVar5 + iVar4 + -1] != 0);\n    *(undefined *)(param_1 + iVar8) = 0x6d;\n    iVar8 = iVar8 + 1;\n  }\n  lVar5 = 0x14;\n  do {\n    iVar4 = (int)lVar5;\n    lVar9 = param_4 / 10;\n    uVar6 = (int)param_4 + (int)lVar9 * -10 + 0x30;\n    abStack_58[lVar5] = (byte)uVar6;\n    lVar5 = lVar5 + -1;\n    param_4 = lVar9;\n  } while (lVar9 != 0);\n  lVar5 = (long)(iVar8 + 1);\n  do {\n    *(char *)(param_1 + -1 + lVar5) = (char)uVar6;\n    iVar3 = (int)lVar5;\n    lVar5 = lVar5 + 1;\n    uVar6 = (uint)abStack_58[lVar5 + ((long)iVar4 - (long)iVar8) + -1];\n  } while (abStack_58[lVar5 + ((long)iVar4 - (long)iVar8) + -1] != 0);\n  if (param_2 != 0) {\n    uVar2 = locale_decpoint();\n    lVar5 = 2;\n    *(undefined *)(param_1 + iVar3) = uVar2;\n    iVar8 = 100;\n    while( true ) {\n      iVar4 = (int)uVar7;\n      uVar7 = (long)iVar4 % (long)iVar8 & 0xffffffff;\n      *(char *)((iVar3 + -1) + param_1 + lVar5) = (char)(iVar4 / iVar8) + '0';\n      if (param_2 < (int)lVar5) break;\n      iVar8 = *(int *)(&DAT_001fce10 + lVar5 * 4);\n      lVar5 = lVar5 + 1;\n    }\n    iVar3 = param_2 + iVar3 + 1;\n  }\n  if (param_3 != 0) {\n    lVar5 = (long)iVar3;\n    iVar3 = iVar3 + 1;\n    *(undefined *)(param_1 + lVar5) = 0x73;\n  }\n  *(undefined *)(param_1 + iVar3) = 0;\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001e0bd0": "\nchar * FUN_001e0bd0(char *param_1,byte param_2,int *param_3,int *param_4,int *param_5,int *param_6)\n\n{\n  char cVar1;\n  bool bVar2;\n  bool bVar3;\n  int iVar4;\n  size_t sVar5;\n  char *pcVar6;\n  size_t sVar7;\n  int *piVar8;\n  ulong uVar9;\n  uint uVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  int iVar14;\n  long lVar15;\n  ulong uVar16;\n  int iVar17;\n  int iVar18;\n  int iVar19;\n  char *pcVar20;\n  int iVar21;\n  char *pcVar22;\n  bool bVar23;\n  undefined auVar24 [16];\n  char *local_a8;\n  int local_94;\n  char *local_88;\n  int local_74;\n  \n  local_a8 = param_1;\n  if (((rl_prompt == param_1) != (bool)(param_2 & 1)) && (_rl_show_mode_in_prompt != 0)) {\n    if (rl_editing_mode == 1) {\n      if (_rl_emacs_mode_str == (char *)0x0) {\n        sVar5 = 1;\n        pcVar6 = \"@\";\n        iVar4 = 1;\n      }\n      else {\n        sVar5 = (size_t)_rl_emacs_modestr_len;\n        pcVar6 = _rl_emacs_mode_str;\n        iVar4 = _rl_emacs_modestr_len;\n      }\n    }\n    else if (_rl_keymap == &vi_insertion_keymap) {\n      if (_rl_vi_ins_mode_str == (char *)0x0) {\n        sVar5 = 5;\n        iVar4 = 5;\n        pcVar6 = \"(ins)\";\n      }\n      else {\n        sVar5 = (size_t)_rl_vi_ins_modestr_len;\n        pcVar6 = _rl_vi_ins_mode_str;\n        iVar4 = _rl_vi_ins_modestr_len;\n      }\n    }\n    else if (_rl_vi_cmd_mode_str == (char *)0x0) {\n      sVar5 = 5;\n      iVar4 = 5;\n      pcVar6 = \"(cmd)\";\n    }\n    else {\n      sVar5 = (size_t)_rl_vi_cmd_modestr_len;\n      pcVar6 = _rl_vi_cmd_mode_str;\n      iVar4 = _rl_vi_cmd_modestr_len;\n    }\n    sVar7 = strlen(param_1);\n    local_a8 = (char *)xmalloc((long)(iVar4 + 1 + (int)sVar7));\n    memcpy(local_a8,pcVar6,sVar5);\n    strcpy(local_a8 + sVar5,param_1);\n  }\n  sVar5 = __ctype_get_mb_cur_max();\n  iVar4 = (int)sVar5;\n  if (_rl_screenwidth == 0) {\n    _rl_get_screen_size(0,0);\n  }\n  sVar5 = strlen(local_a8);\n  iVar18 = (int)sVar5;\n  if (((iVar4 < 2) || (rl_byte_oriented != 0)) &&\n     (pcVar6 = strchr(local_a8,1), pcVar6 == (char *)0x0)) {\n    iVar19 = _rl_screenwidth;\n    if (_rl_screenwidth < 1) {\n      iVar19 = 0x50;\n    }\n    if (iVar18 < iVar19) {\n      if (local_a8 == param_1) {\n        sVar5 = strlen(local_a8);\n        pcVar6 = (char *)xmalloc(sVar5 + 1);\n        local_a8 = strcpy(pcVar6,local_a8);\n      }\n      if (param_3 != (int *)0x0) {\n        *param_3 = iVar18;\n      }\n      if (param_4 != (int *)0x0) {\n        *param_4 = 0;\n      }\n      if (param_5 != (int *)0x0) {\n        *param_5 = 0;\n      }\n      if (param_6 != (int *)0x0) {\n        *param_6 = iVar18;\n      }\n      DAT_0024a868 = (undefined8 *)xrealloc(DAT_0024a868,8);\n      *DAT_0024a868 = 0xffffffff00000000;\n      return local_a8;\n    }\n  }\n  auVar24 = xmalloc((long)(iVar18 + 1));\n  uVar9 = auVar24._8_8_;\n  pcVar6 = auVar24._0_8_;\n  if (_rl_screenwidth < 1) {\n    if (0x4f < iVar18) {\n      iVar19 = iVar18 / 0x50 + 1;\n      lVar15 = (long)(iVar18 / 0x50 + 2) << 2;\n      goto LAB_001e0c8d;\n    }\n  }\n  else if (_rl_screenwidth <= iVar18) {\n    uVar9 = (long)iVar18 % (long)_rl_screenwidth & 0xffffffff;\n    iVar19 = iVar18 / _rl_screenwidth + 1;\n    lVar15 = (long)(iVar18 / _rl_screenwidth + 2) << 2;\n    goto LAB_001e0c8d;\n  }\n  lVar15 = 8;\n  iVar19 = 1;\nLAB_001e0c8d:\n  DAT_0024a868 = (undefined8 *)xrealloc(DAT_0024a868,lVar15,uVar9);\n  *(undefined4 *)DAT_0024a868 = 0;\n  memset((undefined4 *)((long)DAT_0024a868 + 4),0xff,(long)iVar19 << 2);\n  cVar1 = *local_a8;\n  pcVar20 = pcVar6;\n  if (cVar1 == '\\0') {\n    local_74 = 0;\n    iVar21 = 0;\n    iVar18 = 0;\n    iVar19 = 0;\n    local_94 = 0;\n  }\n  else {\n    bVar23 = false;\n    iVar17 = 0;\n    iVar21 = 0;\n    bVar2 = false;\n    local_74 = 0;\n    iVar18 = 0;\n    iVar19 = 0;\n    bVar3 = false;\n    local_94 = 0;\n    local_88 = (char *)0x0;\n    pcVar13 = local_a8;\n    do {\n      pcVar22 = pcVar13;\n      if (bVar3) {\n        if (cVar1 != '\\x02') {\n          if ((1 < iVar4) && (rl_byte_oriented == 0)) goto LAB_001e1090;\n          *pcVar20 = cVar1;\n          pcVar20 = pcVar20 + 1;\n          iVar19 = iVar19 + 1;\n          pcVar12 = pcVar13 + 1;\n          goto LAB_001e0d40;\n        }\n        if (((bVar23) &&\n            (*(int *)((long)DAT_0024a868 + (long)iVar17 * 4) = (int)pcVar20 - auVar24._0_4_,\n            iVar17 == 1)) && (bVar2)) {\n          iVar18 = iVar19;\n        }\n        pcVar12 = pcVar13 + 1;\n        if (pcVar13 == local_88 + 1) {\n          bVar3 = false;\n        }\n        else {\n          bVar3 = false;\n          local_74 = ((int)pcVar20 - auVar24._0_4_) + -1;\n        }\n      }\n      else if (cVar1 == '\\x01') {\n        bVar3 = true;\n        pcVar12 = pcVar13 + 1;\n        local_88 = pcVar13;\n      }\n      else {\n        if ((iVar4 < 2) || (rl_byte_oriented != 0)) {\n          *pcVar20 = cVar1;\n          pcVar20 = pcVar20 + 1;\n          iVar21 = iVar21 + 1;\n          local_94 = local_94 + 1;\n          pcVar12 = pcVar13 + 1;\n        }\n        else {\nLAB_001e1090:\n          iVar14 = (int)((long)pcVar13 - (long)local_a8);\n          iVar11 = _rl_find_next_mbchar(local_a8,(long)pcVar13 - (long)local_a8 & 0xffffffff,1,1);\n          uVar10 = iVar11 - iVar14;\n          if (uVar10 == 0) {\n            pcVar22 = pcVar13 + -1;\n          }\n          else {\n            uVar16 = (ulong)uVar10;\n            uVar9 = 0;\n            do {\n              pcVar20[uVar9] = pcVar13[uVar9];\n              uVar9 = uVar9 + 1;\n            } while (uVar16 != uVar9);\n            pcVar22 = pcVar13 + (uVar10 - 1);\n            pcVar20 = pcVar20 + uVar16;\n            pcVar13 = pcVar13 + uVar16;\n          }\n          pcVar12 = pcVar13;\n          if (bVar3) {\n            iVar19 = iVar19 + uVar10;\n          }\n          else {\n            local_94 = local_94 + uVar10;\n            if (iVar14 < iVar11) {\n              sVar5 = __ctype_get_mb_cur_max();\n              if ((sVar5 == 1) || (rl_byte_oriented != 0)) {\n                iVar21 = iVar21 + uVar10;\n              }\n              else {\n                iVar11 = FUN_001e08f0(local_a8,iVar14,iVar11,0);\n                iVar21 = iVar21 + iVar11;\n              }\n            }\n          }\n        }\nLAB_001e0d40:\n        pcVar13 = pcVar22;\n        if ((!bVar2) && (bVar2 = _rl_screenwidth <= iVar21, _rl_screenwidth <= iVar21)) {\n          iVar18 = iVar19;\n        }\n        iVar11 = _rl_screenwidth * (iVar17 + 1);\n        if (iVar11 <= iVar21) {\n          piVar8 = (int *)((long)DAT_0024a868 + ((long)iVar17 + 1) * 4);\n          if (*piVar8 == -1) {\n            uVar9 = (long)pcVar20 - (long)pcVar6 & 0xffffffff;\n            iVar14 = (int)uVar9;\n            if (iVar11 < iVar21) {\n              *pcVar20 = '\\0';\n              if ((iVar4 < 2) || (rl_byte_oriented != 0)) {\n                iVar14 = (int)((long)pcVar20 - (long)pcVar6) - (iVar21 - iVar11);\n              }\n              else {\n                iVar14 = _rl_find_prev_mbchar(pcVar6,uVar9,0);\n                piVar8 = (int *)((long)DAT_0024a868 + ((long)iVar17 + 1) * 4);\n              }\n            }\n            *piVar8 = iVar14;\n            iVar17 = iVar17 + 1;\n          }\n        }\n        if (!bVar3) {\n          bVar23 = iVar21 == iVar11;\n        }\n      }\n      cVar1 = pcVar13[1];\n      pcVar13 = pcVar12;\n    } while (cVar1 != '\\0');\n  }\n  iVar4 = _rl_screenwidth;\n  *pcVar20 = '\\0';\n  if (local_94 <= iVar4) {\n    iVar18 = iVar19;\n  }\n  if (param_3 != (int *)0x0) {\n    *param_3 = local_94;\n  }\n  if (param_4 != (int *)0x0) {\n    *param_4 = local_74;\n  }\n  if (param_5 != (int *)0x0) {\n    *param_5 = iVar18;\n  }\n  if (param_6 != (int *)0x0) {\n    *param_6 = iVar21;\n  }\n  if (local_a8 != param_1) {\n    xfree(local_a8);\n  }\n  return pcVar6;\n}\n\n",
  "coproc_close": "\nvoid coproc_close(long param_1)\n\n{\n  if (-1 < *(int *)(param_1 + 0xc)) {\n    close(*(int *)(param_1 + 0xc));\n    *(undefined4 *)(param_1 + 0xc) = 0xffffffff;\n  }\n  if (-1 < *(int *)(param_1 + 0x10)) {\n    close(*(int *)(param_1 + 0x10));\n    *(undefined4 *)(param_1 + 0x10) = 0xffffffff;\n  }\n  *(undefined8 *)(param_1 + 0x14) = 0xffffffffffffffff;\n  return;\n}\n\n",
  "xtrace_print_word_list": "\nvoid xtrace_print_word_list(long **param_1,uint param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  undefined *puVar4;\n  \n  if (xtrace_fp == (FILE *)0x0) {\n    xtrace_fp = stderr;\n  }\n  if ((param_2 & 1) != 0) {\n    pcVar3 = (char *)indirection_level_string();\n    fputs(pcVar3,xtrace_fp);\n  }\n  if (param_1 != (long **)0x0) {\n    do {\n      while ((pcVar3 = (char *)*param_1[1], pcVar3 != (char *)0x0 && (*pcVar3 != '\\0'))) {\n        if ((param_2 & 2) == 0) {\n          iVar1 = sh_contains_shell_metas(pcVar3);\n          if (iVar1 == 0) {\n            iVar1 = ansic_shouldquote(pcVar3);\n            if (iVar1 == 0) goto LAB_00145a52;\n            uVar2 = ansic_quote(pcVar3,0,0);\n            puVar4 = &DAT_00213d70;\n            if (*param_1 != (long *)0x0) {\n              puVar4 = &DAT_001fdb1c;\n            }\n            __fprintf_chk(xtrace_fp,1,&DAT_001fc632,uVar2,puVar4);\n            sh_xfree(uVar2,\"print_cmd.c\",0x245);\n          }\n          else {\n            uVar2 = sh_single_quote();\n            puVar4 = &DAT_00213d70;\n            if (*param_1 != (long *)0x0) {\n              puVar4 = &DAT_001fdb1c;\n            }\n            __fprintf_chk(xtrace_fp,1,&DAT_001fc632,uVar2,puVar4);\n            sh_xfree(uVar2,\"print_cmd.c\",0x23f);\n          }\n        }\n        else {\nLAB_00145a52:\n          puVar4 = &DAT_00213d70;\n          if (*param_1 != (long *)0x0) {\n            puVar4 = &DAT_001fdb1c;\n          }\n          __fprintf_chk(xtrace_fp,1,&DAT_001fc632,pcVar3,puVar4);\n        }\n        param_1 = (long **)*param_1;\n        if (param_1 == (long **)0x0) goto LAB_00145ab5;\n      }\n      puVar4 = &DAT_00213d70;\n      if (*param_1 != (long *)0x0) {\n        puVar4 = &DAT_001fdb1c;\n      }\n      __fprintf_chk(xtrace_fp,1,&DAT_001fc718,puVar4);\n      param_1 = (long **)*param_1;\n    } while (param_1 != (long **)0x0);\n  }\nLAB_00145ab5:\n  fputc(10,xtrace_fp);\n  fflush(xtrace_fp);\n  return;\n}\n\n",
  "rl_set_signals": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 rl_set_signals(void)\n\n{\n  __sigset_t *__set;\n  __sigset_t *__set_00;\n  long in_FS_OFFSET;\n  sigaction sStack_2b8;\n  sigaction local_218;\n  undefined local_178 [12];\n  undefined4 uStack_16c;\n  undefined4 local_168;\n  undefined4 uStack_164;\n  undefined4 uStack_160;\n  undefined4 uStack_15c;\n  undefined4 local_158;\n  undefined4 uStack_154;\n  undefined4 uStack_150;\n  undefined4 uStack_14c;\n  undefined4 local_148;\n  undefined4 uStack_144;\n  undefined4 uStack_140;\n  undefined4 uStack_13c;\n  undefined4 local_138;\n  undefined4 uStack_134;\n  undefined4 uStack_130;\n  undefined4 uStack_12c;\n  undefined4 local_128;\n  undefined4 uStack_124;\n  undefined4 uStack_120;\n  undefined4 uStack_11c;\n  undefined4 local_118;\n  undefined4 uStack_114;\n  undefined4 uStack_110;\n  undefined4 uStack_10c;\n  undefined4 local_108;\n  undefined4 uStack_104;\n  undefined4 uStack_100;\n  undefined4 uStack_fc;\n  undefined4 local_f8;\n  undefined4 uStack_f4;\n  uint uStack_f0;\n  undefined4 uStack_ec;\n  _func_5327 *local_e8;\n  sigaction local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (rl_catch_signals == 0) {\nLAB_001e7650:\n    sigemptyset((sigset_t *)_rl_orig_sigset);\n    sigprocmask(0,(sigset_t *)0x0,(sigset_t *)_rl_orig_sigset);\n    goto LAB_001e7570;\n  }\n  if (DAT_0024aa80 == 0) {\n    sigemptyset((sigset_t *)&DAT_0024aa00);\n    sigaddset((sigset_t *)&DAT_0024aa00,2);\n    sigaddset((sigset_t *)&DAT_0024aa00,0xf);\n    sigaddset((sigset_t *)&DAT_0024aa00,1);\n    sigaddset((sigset_t *)&DAT_0024aa00,3);\n    sigaddset((sigset_t *)&DAT_0024aa00,0xe);\n    sigaddset((sigset_t *)&DAT_0024aa00,0x14);\n    sigaddset((sigset_t *)&DAT_0024aa00,0x15);\n    sigaddset((sigset_t *)&DAT_0024aa00,0x16);\n    DAT_0024aa80 = 1;\n    if (rl_catch_signals == 0) goto LAB_001e7650;\n  }\n  if (DAT_0024b13c != 0) goto LAB_001e7570;\n  __set = &local_218.sa_mask;\n  __set_00 = &local_d8.sa_mask;\n  sigemptyset((sigset_t *)_rl_orig_sigset);\n  sigprocmask(0,(sigset_t *)&DAT_0024aa00,(sigset_t *)_rl_orig_sigset);\n  sigemptyset(__set);\n  local_d8.__sigaction_handler.sa_handler = FUN_001e74b0;\n  local_218.sa_flags = 0;\n  local_d8.sa_flags = 0;\n  sigemptyset(__set_00);\n  sigemptyset((sigset_t *)&DAT_0024b0a8);\n  sigaction(2,&local_d8,(sigaction *)local_178);\n  if ((code *)CONCAT44(local_178._4_4_,local_178._0_4_) != FUN_001e74b0) {\n    _DAT_0024b0a0 = local_178._0_4_;\n    uRam000000000024b0a4 = local_178._4_4_;\n    _DAT_0024b0a8 = local_178._8_4_;\n    uRam000000000024b0ac = uStack_16c;\n    _DAT_0024b0b0 = local_168;\n    uRam000000000024b0b4 = uStack_164;\n    uRam000000000024b0b8 = uStack_160;\n    uRam000000000024b0bc = uStack_15c;\n    _DAT_0024b130 = local_e8;\n    _DAT_0024b0c0 = local_158;\n    uRam000000000024b0c4 = uStack_154;\n    uRam000000000024b0c8 = uStack_150;\n    uRam000000000024b0cc = uStack_14c;\n    _DAT_0024b0d0 = local_148;\n    uRam000000000024b0d4 = uStack_144;\n    uRam000000000024b0d8 = uStack_140;\n    uRam000000000024b0dc = uStack_13c;\n    _DAT_0024b0e0 = local_138;\n    uRam000000000024b0e4 = uStack_134;\n    uRam000000000024b0e8 = uStack_130;\n    uRam000000000024b0ec = uStack_12c;\n    _DAT_0024b0f0 = local_128;\n    uRam000000000024b0f4 = uStack_124;\n    uRam000000000024b0f8 = uStack_120;\n    uRam000000000024b0fc = uStack_11c;\n    _DAT_0024b100 = local_118;\n    uRam000000000024b104 = uStack_114;\n    uRam000000000024b108 = uStack_110;\n    uRam000000000024b10c = uStack_10c;\n    _DAT_0024b110 = local_108;\n    uRam000000000024b114 = uStack_104;\n    uRam000000000024b118 = uStack_100;\n    uRam000000000024b11c = uStack_fc;\n    _DAT_0024b120 = local_f8;\n    uRam000000000024b124 = uStack_f4;\n    uRam000000000024b128 = uStack_f0;\n    uRam000000000024b12c = uStack_ec;\n  }\n  if (CONCAT44(uRam000000000024b0a4,_DAT_0024b0a0) == 1) {\n    sigaction(2,(sigaction *)&DAT_0024b0a0,&local_218);\n  }\n  sigemptyset(__set);\n  local_d8.__sigaction_handler.sa_handler = FUN_001e74b0;\n  local_218.sa_flags = 0;\n  local_d8.sa_flags = 0;\n  sigemptyset(__set_00);\n  sigemptyset((sigset_t *)&DAT_0024b008);\n  sigaction(0xf,&local_d8,(sigaction *)local_178);\n  if ((code *)CONCAT44(local_178._4_4_,local_178._0_4_) != FUN_001e74b0) {\n    _DAT_0024b000 = local_178._0_4_;\n    uRam000000000024b004 = local_178._4_4_;\n    _DAT_0024b008 = local_178._8_4_;\n    uRam000000000024b00c = uStack_16c;\n    _DAT_0024b090 = local_e8;\n    _DAT_0024b010 = local_168;\n    uRam000000000024b014 = uStack_164;\n    uRam000000000024b018 = uStack_160;\n    uRam000000000024b01c = uStack_15c;\n    _DAT_0024b020 = local_158;\n    uRam000000000024b024 = uStack_154;\n    uRam000000000024b028 = uStack_150;\n    uRam000000000024b02c = uStack_14c;\n    _DAT_0024b030 = local_148;\n    uRam000000000024b034 = uStack_144;\n    uRam000000000024b038 = uStack_140;\n    uRam000000000024b03c = uStack_13c;\n    _DAT_0024b040 = local_138;\n    uRam000000000024b044 = uStack_134;\n    uRam000000000024b048 = uStack_130;\n    uRam000000000024b04c = uStack_12c;\n    _DAT_0024b050 = local_128;\n    uRam000000000024b054 = uStack_124;\n    uRam000000000024b058 = uStack_120;\n    uRam000000000024b05c = uStack_11c;\n    _DAT_0024b060 = local_118;\n    uRam000000000024b064 = uStack_114;\n    uRam000000000024b068 = uStack_110;\n    uRam000000000024b06c = uStack_10c;\n    _DAT_0024b070 = local_108;\n    uRam000000000024b074 = uStack_104;\n    uRam000000000024b078 = uStack_100;\n    uRam000000000024b07c = uStack_fc;\n    _DAT_0024b080 = local_f8;\n    uRam000000000024b084 = uStack_f4;\n    uRam000000000024b088 = uStack_f0;\n    uRam000000000024b08c = uStack_ec;\n  }\n  if (CONCAT44(uRam000000000024b004,_DAT_0024b000) == 1) {\n    sigaction(0xf,(sigaction *)&DAT_0024b000,&local_218);\n  }\n  sigemptyset(__set);\n  local_d8.__sigaction_handler.sa_handler = FUN_001e74b0;\n  local_218.sa_flags = 0;\n  local_d8.sa_flags = 0;\n  sigemptyset(__set_00);\n  sigemptyset((sigset_t *)&DAT_0024af68);\n  sigaction(1,&local_d8,(sigaction *)local_178);\n  if ((code *)CONCAT44(local_178._4_4_,local_178._0_4_) != FUN_001e74b0) {\n    _DAT_0024af60 = local_178._0_4_;\n    uRam000000000024af64 = local_178._4_4_;\n    _DAT_0024af68 = local_178._8_4_;\n    uRam000000000024af6c = uStack_16c;\n    _DAT_0024aff0 = local_e8;\n    _DAT_0024af70 = local_168;\n    uRam000000000024af74 = uStack_164;\n    uRam000000000024af78 = uStack_160;\n    uRam000000000024af7c = uStack_15c;\n    _DAT_0024af80 = local_158;\n    uRam000000000024af84 = uStack_154;\n    uRam000000000024af88 = uStack_150;\n    uRam000000000024af8c = uStack_14c;\n    _DAT_0024af90 = local_148;\n    uRam000000000024af94 = uStack_144;\n    uRam000000000024af98 = uStack_140;\n    uRam000000000024af9c = uStack_13c;\n    _DAT_0024afa0 = local_138;\n    uRam000000000024afa4 = uStack_134;\n    uRam000000000024afa8 = uStack_130;\n    uRam000000000024afac = uStack_12c;\n    _DAT_0024afb0 = local_128;\n    uRam000000000024afb4 = uStack_124;\n    uRam000000000024afb8 = uStack_120;\n    uRam000000000024afbc = uStack_11c;\n    _DAT_0024afc0 = local_118;\n    uRam000000000024afc4 = uStack_114;\n    uRam000000000024afc8 = uStack_110;\n    uRam000000000024afcc = uStack_10c;\n    _DAT_0024afd0 = local_108;\n    uRam000000000024afd4 = uStack_104;\n    uRam000000000024afd8 = uStack_100;\n    uRam000000000024afdc = uStack_fc;\n    _DAT_0024afe0 = local_f8;\n    uRam000000000024afe4 = uStack_f4;\n    uRam000000000024afe8 = uStack_f0;\n    uRam000000000024afec = uStack_ec;\n  }\n  if (CONCAT44(uRam000000000024af64,_DAT_0024af60) == 1) {\n    sigaction(1,(sigaction *)&DAT_0024af60,&local_218);\n  }\n  sigemptyset(__set);\n  local_d8.__sigaction_handler.sa_handler = FUN_001e74b0;\n  local_218.sa_flags = 0;\n  local_d8.sa_flags = 0;\n  sigemptyset(__set_00);\n  sigemptyset((sigset_t *)&DAT_0024ae28);\n  sigaction(3,&local_d8,(sigaction *)local_178);\n  if ((code *)CONCAT44(local_178._4_4_,local_178._0_4_) != FUN_001e74b0) {\n    _DAT_0024ae20 = local_178._0_4_;\n    uRam000000000024ae24 = local_178._4_4_;\n    _DAT_0024ae28 = local_178._8_4_;\n    uRam000000000024ae2c = uStack_16c;\n    _DAT_0024aeb0 = local_e8;\n    _DAT_0024ae30 = local_168;\n    uRam000000000024ae34 = uStack_164;\n    uRam000000000024ae38 = uStack_160;\n    uRam000000000024ae3c = uStack_15c;\n    _DAT_0024ae40 = local_158;\n    uRam000000000024ae44 = uStack_154;\n    uRam000000000024ae48 = uStack_150;\n    uRam000000000024ae4c = uStack_14c;\n    _DAT_0024ae50 = local_148;\n    uRam000000000024ae54 = uStack_144;\n    uRam000000000024ae58 = uStack_140;\n    uRam000000000024ae5c = uStack_13c;\n    _DAT_0024ae60 = local_138;\n    uRam000000000024ae64 = uStack_134;\n    uRam000000000024ae68 = uStack_130;\n    uRam000000000024ae6c = uStack_12c;\n    _DAT_0024ae70 = local_128;\n    uRam000000000024ae74 = uStack_124;\n    uRam000000000024ae78 = uStack_120;\n    uRam000000000024ae7c = uStack_11c;\n    _DAT_0024ae80 = local_118;\n    uRam000000000024ae84 = uStack_114;\n    uRam000000000024ae88 = uStack_110;\n    uRam000000000024ae8c = uStack_10c;\n    _DAT_0024ae90 = local_108;\n    uRam000000000024ae94 = uStack_104;\n    uRam000000000024ae98 = uStack_100;\n    uRam000000000024ae9c = uStack_fc;\n    _DAT_0024aea0 = local_f8;\n    uRam000000000024aea4 = uStack_f4;\n    uRam000000000024aea8 = uStack_f0;\n    uRam000000000024aeac = uStack_ec;\n  }\n  if (CONCAT44(uRam000000000024ae24,_DAT_0024ae20) == 1) {\n    sigaction(3,(sigaction *)&DAT_0024ae20,&local_218);\n  }\n  local_d8.__sigaction_handler.sa_handler = FUN_001e74b0;\n  local_d8.sa_flags = 0;\n  sigemptyset(__set_00);\n  sigemptyset((sigset_t *)&DAT_0024aec8);\n  sigaction(0xe,&local_d8,(sigaction *)local_178);\n  if ((code *)CONCAT44(local_178._4_4_,local_178._0_4_) != FUN_001e74b0) {\n    DAT_0024aec0._0_4_ = local_178._0_4_;\n    DAT_0024aec0._4_4_ = local_178._4_4_;\n    _DAT_0024aec8 = local_178._8_4_;\n    uRam000000000024aecc = uStack_16c;\n    _DAT_0024af50 = local_e8;\n    _DAT_0024aed0 = local_168;\n    uRam000000000024aed4 = uStack_164;\n    uRam000000000024aed8 = uStack_160;\n    uRam000000000024aedc = uStack_15c;\n    _DAT_0024aee0 = local_158;\n    uRam000000000024aee4 = uStack_154;\n    uRam000000000024aee8 = uStack_150;\n    uRam000000000024aeec = uStack_14c;\n    _DAT_0024aef0 = local_148;\n    uRam000000000024aef4 = uStack_144;\n    uRam000000000024aef8 = uStack_140;\n    uRam000000000024aefc = uStack_13c;\n    _DAT_0024af00 = local_138;\n    uRam000000000024af04 = uStack_134;\n    uRam000000000024af08 = uStack_130;\n    uRam000000000024af0c = uStack_12c;\n    _DAT_0024af10 = local_128;\n    uRam000000000024af14 = uStack_124;\n    uRam000000000024af18 = uStack_120;\n    uRam000000000024af1c = uStack_11c;\n    _DAT_0024af20 = local_118;\n    uRam000000000024af24 = uStack_114;\n    uRam000000000024af28 = uStack_110;\n    uRam000000000024af2c = uStack_10c;\n    _DAT_0024af30 = local_108;\n    uRam000000000024af34 = uStack_104;\n    uRam000000000024af38 = uStack_100;\n    uRam000000000024af3c = uStack_fc;\n    _DAT_0024af40 = local_f8;\n    uRam000000000024af44 = uStack_f4;\n    uRam000000000024af48 = uStack_f0;\n    uRam000000000024af4c = uStack_ec;\n  }\n  if (CONCAT44(DAT_0024aec0._4_4_,(undefined4)DAT_0024aec0) == 1) {\n    sigaction(0xe,(sigaction *)&DAT_0024aec0,&sStack_2b8);\nLAB_001e7cfc:\n    if ((uRam000000000024af48 & 0x10000000) != 0) {\n      sigaction(0xe,(sigaction *)&DAT_0024aec0,&sStack_2b8);\n    }\n  }\n  else if (CONCAT44(DAT_0024aec0._4_4_,(undefined4)DAT_0024aec0) != 0) goto LAB_001e7cfc;\n  sigemptyset(__set);\n  local_d8.__sigaction_handler.sa_handler = FUN_001e74b0;\n  local_218.sa_flags = 0;\n  local_d8.sa_flags = 0;\n  sigemptyset(__set_00);\n  sigemptyset((sigset_t *)&DAT_0024ad88);\n  sigaction(0x14,&local_d8,(sigaction *)local_178);\n  if ((code *)CONCAT44(local_178._4_4_,local_178._0_4_) != FUN_001e74b0) {\n    _DAT_0024ad80 = local_178._0_4_;\n    uRam000000000024ad84 = local_178._4_4_;\n    _DAT_0024ad88 = local_178._8_4_;\n    uRam000000000024ad8c = uStack_16c;\n    _DAT_0024ae10 = local_e8;\n    _DAT_0024ad90 = local_168;\n    uRam000000000024ad94 = uStack_164;\n    uRam000000000024ad98 = uStack_160;\n    uRam000000000024ad9c = uStack_15c;\n    _DAT_0024ada0 = local_158;\n    uRam000000000024ada4 = uStack_154;\n    uRam000000000024ada8 = uStack_150;\n    uRam000000000024adac = uStack_14c;\n    _DAT_0024adb0 = local_148;\n    uRam000000000024adb4 = uStack_144;\n    uRam000000000024adb8 = uStack_140;\n    uRam000000000024adbc = uStack_13c;\n    _DAT_0024adc0 = local_138;\n    uRam000000000024adc4 = uStack_134;\n    uRam000000000024adc8 = uStack_130;\n    uRam000000000024adcc = uStack_12c;\n    _DAT_0024add0 = local_128;\n    uRam000000000024add4 = uStack_124;\n    uRam000000000024add8 = uStack_120;\n    uRam000000000024addc = uStack_11c;\n    _DAT_0024ade0 = local_118;\n    uRam000000000024ade4 = uStack_114;\n    uRam000000000024ade8 = uStack_110;\n    uRam000000000024adec = uStack_10c;\n    _DAT_0024adf0 = local_108;\n    uRam000000000024adf4 = uStack_104;\n    uRam000000000024adf8 = uStack_100;\n    uRam000000000024adfc = uStack_fc;\n    _DAT_0024ae00 = local_f8;\n    uRam000000000024ae04 = uStack_f4;\n    uRam000000000024ae08 = uStack_f0;\n    uRam000000000024ae0c = uStack_ec;\n  }\n  if (CONCAT44(uRam000000000024ad84,_DAT_0024ad80) == 1) {\n    sigaction(0x14,(sigaction *)&DAT_0024ad80,&local_218);\n  }\n  sigemptyset(__set);\n  local_d8.__sigaction_handler.sa_handler = FUN_001e74b0;\n  local_218.sa_flags = 0;\n  local_d8.sa_flags = 0;\n  sigemptyset(__set_00);\n  sigemptyset((sigset_t *)&DAT_0024ace8);\n  sigaction(0x16,&local_d8,(sigaction *)local_178);\n  if ((code *)CONCAT44(local_178._4_4_,local_178._0_4_) != FUN_001e74b0) {\n    _DAT_0024ace0 = local_178._0_4_;\n    uRam000000000024ace4 = local_178._4_4_;\n    _DAT_0024ace8 = local_178._8_4_;\n    uRam000000000024acec = uStack_16c;\n    _DAT_0024ad70 = local_e8;\n    _DAT_0024acf0 = local_168;\n    uRam000000000024acf4 = uStack_164;\n    uRam000000000024acf8 = uStack_160;\n    uRam000000000024acfc = uStack_15c;\n    _DAT_0024ad00 = local_158;\n    uRam000000000024ad04 = uStack_154;\n    uRam000000000024ad08 = uStack_150;\n    uRam000000000024ad0c = uStack_14c;\n    _DAT_0024ad10 = local_148;\n    uRam000000000024ad14 = uStack_144;\n    uRam000000000024ad18 = uStack_140;\n    uRam000000000024ad1c = uStack_13c;\n    _DAT_0024ad20 = local_138;\n    uRam000000000024ad24 = uStack_134;\n    uRam000000000024ad28 = uStack_130;\n    uRam000000000024ad2c = uStack_12c;\n    _DAT_0024ad30 = local_128;\n    uRam000000000024ad34 = uStack_124;\n    uRam000000000024ad38 = uStack_120;\n    uRam000000000024ad3c = uStack_11c;\n    _DAT_0024ad40 = local_118;\n    uRam000000000024ad44 = uStack_114;\n    uRam000000000024ad48 = uStack_110;\n    uRam000000000024ad4c = uStack_10c;\n    _DAT_0024ad50 = local_108;\n    uRam000000000024ad54 = uStack_104;\n    uRam000000000024ad58 = uStack_100;\n    uRam000000000024ad5c = uStack_fc;\n    _DAT_0024ad60 = local_f8;\n    uRam000000000024ad64 = uStack_f4;\n    uRam000000000024ad68 = uStack_f0;\n    uRam000000000024ad6c = uStack_ec;\n  }\n  if (CONCAT44(uRam000000000024ace4,_DAT_0024ace0) == 1) {\n    sigaction(0x16,(sigaction *)&DAT_0024ace0,&local_218);\n  }\n  sigemptyset(__set);\n  local_d8.__sigaction_handler.sa_handler = FUN_001e74b0;\n  local_218.sa_flags = 0;\n  local_d8.sa_flags = 0;\n  sigemptyset(__set_00);\n  sigemptyset((sigset_t *)&DAT_0024ac48);\n  sigaction(0x15,&local_d8,(sigaction *)local_178);\n  if ((code *)CONCAT44(local_178._4_4_,local_178._0_4_) != FUN_001e74b0) {\n    _DAT_0024ac40 = local_178._0_4_;\n    uRam000000000024ac44 = local_178._4_4_;\n    _DAT_0024ac48 = local_178._8_4_;\n    uRam000000000024ac4c = uStack_16c;\n    _DAT_0024acd0 = local_e8;\n    _DAT_0024ac50 = local_168;\n    uRam000000000024ac54 = uStack_164;\n    uRam000000000024ac58 = uStack_160;\n    uRam000000000024ac5c = uStack_15c;\n    _DAT_0024ac60 = local_158;\n    uRam000000000024ac64 = uStack_154;\n    uRam000000000024ac68 = uStack_150;\n    uRam000000000024ac6c = uStack_14c;\n    _DAT_0024ac70 = local_148;\n    uRam000000000024ac74 = uStack_144;\n    uRam000000000024ac78 = uStack_140;\n    uRam000000000024ac7c = uStack_13c;\n    _DAT_0024ac80 = local_138;\n    uRam000000000024ac84 = uStack_134;\n    uRam000000000024ac88 = uStack_130;\n    uRam000000000024ac8c = uStack_12c;\n    _DAT_0024ac90 = local_128;\n    uRam000000000024ac94 = uStack_124;\n    uRam000000000024ac98 = uStack_120;\n    uRam000000000024ac9c = uStack_11c;\n    _DAT_0024aca0 = local_118;\n    uRam000000000024aca4 = uStack_114;\n    uRam000000000024aca8 = uStack_110;\n    uRam000000000024acac = uStack_10c;\n    _DAT_0024acb0 = local_108;\n    uRam000000000024acb4 = uStack_104;\n    uRam000000000024acb8 = uStack_100;\n    uRam000000000024acbc = uStack_fc;\n    _DAT_0024acc0 = local_f8;\n    uRam000000000024acc4 = uStack_f4;\n    uRam000000000024acc8 = uStack_f0;\n    uRam000000000024accc = uStack_ec;\n  }\n  if (CONCAT44(uRam000000000024ac44,_DAT_0024ac40) == 1) {\n    sigaction(0x15,(sigaction *)&DAT_0024ac40,&local_218);\n  }\n  DAT_0024b13c = 1;\n  sigprocmask(2,(sigset_t *)_rl_orig_sigset,(sigset_t *)0x0);\nLAB_001e7570:\n  if ((rl_catch_sigwinch != 0) && (DAT_0024b138 == 0)) {\n    sigemptyset(&local_218.sa_mask);\n    local_218.sa_flags = 0;\n    local_d8.__sigaction_handler.sa_handler = FUN_001e74c0;\n    local_d8.sa_flags = 0x10000000;\n    sigemptyset(&local_d8.sa_mask);\n    sigemptyset((sigset_t *)&DAT_0024aba8);\n    sigaction(0x1c,&local_d8,(sigaction *)local_178);\n    DAT_0024aba0._0_4_ = local_178._0_4_;\n    DAT_0024aba0._4_4_ = local_178._4_4_;\n    _DAT_0024aba8 = local_178._8_4_;\n    uRam000000000024abac = uStack_16c;\n    _DAT_0024ac30 = local_e8;\n    _DAT_0024abb0 = local_168;\n    uRam000000000024abb4 = uStack_164;\n    uRam000000000024abb8 = uStack_160;\n    uRam000000000024abbc = uStack_15c;\n    _DAT_0024abc0 = local_158;\n    uRam000000000024abc4 = uStack_154;\n    uRam000000000024abc8 = uStack_150;\n    uRam000000000024abcc = uStack_14c;\n    _DAT_0024abd0 = local_148;\n    uRam000000000024abd4 = uStack_144;\n    uRam000000000024abd8 = uStack_140;\n    uRam000000000024abdc = uStack_13c;\n    _DAT_0024abe0 = local_138;\n    uRam000000000024abe4 = uStack_134;\n    uRam000000000024abe8 = uStack_130;\n    uRam000000000024abec = uStack_12c;\n    _DAT_0024abf0 = local_128;\n    uRam000000000024abf4 = uStack_124;\n    uRam000000000024abf8 = uStack_120;\n    uRam000000000024abfc = uStack_11c;\n    _DAT_0024ac00 = local_118;\n    uRam000000000024ac04 = uStack_114;\n    uRam000000000024ac08 = uStack_110;\n    uRam000000000024ac0c = uStack_10c;\n    _DAT_0024ac10 = local_108;\n    uRam000000000024ac14 = uStack_104;\n    uRam000000000024ac18 = uStack_100;\n    uRam000000000024ac1c = uStack_fc;\n    _DAT_0024ac20 = local_f8;\n    uRam000000000024ac24 = uStack_f4;\n    uRam000000000024ac28 = uStack_f0;\n    uRam000000000024ac2c = uStack_ec;\n    if (CONCAT44(local_178._4_4_,local_178._0_4_) == 1) {\n      sigaction(0x1c,(sigaction *)&DAT_0024aba0,&local_218);\n    }\n    DAT_0024b138 = 1;\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 0;\n}\n\n",
  "FUN_0015c2b0": "\nlong FUN_0015c2b0(void)\n\n{\n  long lVar1;\n  ulong uVar2;\n  long lVar3;\n  \n  lVar1 = FUN_0015bee0();\n  while( true ) {\n    lVar3 = lVar1;\n    if (DAT_00242448 != 0xd) {\n      return lVar3;\n    }\n    FUN_0015d330();\n    uVar2 = FUN_0015c2b0();\n    DAT_00242444 = 6;\n    if (uVar2 == 0) break;\n    if ((long)uVar2 < 0) {\n                    /* WARNING: Subroutine does not return */\n      FUN_0015bcf0(\"exponent less than 0\");\n    }\n    lVar1 = 1;\n    do {\n      if ((uVar2 & 1) != 0) {\n        lVar1 = lVar1 * lVar3;\n      }\n      lVar3 = lVar3 * lVar3;\n      uVar2 = (long)uVar2 >> 1;\n    } while (uVar2 != 0);\n  }\n  DAT_00242444 = 6;\n  return 1;\n}\n\n",
  "mbsnrtowcs": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbsnrtowcs(wchar_t *__dst,char **__src,size_t __nmc,size_t __len,mbstate_t *__ps)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_mbsnrtowcs_00237d08)();\n  return sVar1;\n}\n\n",
  "FUN_001626a0": "\nvoid FUN_001626a0(void)\n\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  ulong uVar4;\n  ulong uVar5;\n  \n  iVar2 = DAT_00247694;\n  DAT_00247690 = DAT_00247690 + 1;\n  if (0 < DAT_0023877c) {\n    uVar4 = 0;\n    iVar3 = DAT_0023877c;\n    do {\n      while( true ) {\n        uVar5 = uVar4 & 0xffffffff;\n        lVar1 = *(long *)(jobs + uVar4 * 8);\n        if ((((lVar1 == 0) || (*(int *)(lVar1 + 0x14) != 4)) || ((*(byte *)(lVar1 + 0x18) & 2) == 0)\n            ) || ((iVar3 == 0 || (DAT_00247660 != 0)))) break;\n        uVar4 = uVar4 + 1;\n        FUN_0015f990(uVar5,0);\n        iVar3 = DAT_0023877c;\n        if (DAT_0023877c <= (int)uVar4) goto LAB_00162718;\n      }\n      uVar4 = uVar4 + 1;\n    } while ((int)uVar4 < iVar3);\n  }\nLAB_00162718:\n  if (DAT_00242520 != 0) {\n    FUN_00160a10();\n  }\n  last_procsub_child = 0;\n  coproc_reap();\n  DAT_00247690 = DAT_00247690 + -1;\n  if ((DAT_00247690 == 0) && (iVar2 != DAT_00247694)) {\n    DAT_00247690 = 1;\n    FUN_00161c20(0);\n    DAT_00247690 = 0;\n    return;\n  }\n  return;\n}\n\n",
  "wcsmatch": "\nundefined8 wcsmatch(long param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  \n  if ((param_2 != 0) && (param_1 != 0)) {\n    uVar1 = internal_wstrmatch();\n    return uVar1;\n  }\n  return 1;\n}\n\n",
  "expand_assignment_string_to_string": "\nundefined8 expand_assignment_string_to_string(char *param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    lVar1 = expand_string_assignment();\n    if (lVar1 != 0) {\n      uVar2 = string_list_internal(lVar1,&DAT_001fdb1c);\n      dispose_words(lVar1);\n      return uVar2;\n    }\n  }\n  return 0;\n}\n\n",
  "save_pipeline": "\nvoid save_pipeline(int param_1)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_128);\n  sigaddset(&sStack_128,0x11);\n  sigemptyset(&local_a8);\n  sigprocmask(0,&sStack_128,&local_a8);\n  puVar1 = (undefined8 *)sh_xmalloc(0x10,\"jobs.c\",0x1d8);\n  *puVar1 = the_pipeline;\n  puVar1[1] = DAT_00247668;\n  DAT_00247668 = puVar1;\n  if (param_1 != 0) {\n    the_pipeline = 0;\n  }\n  DAT_00247664 = already_making_children;\n  sigprocmask(2,&local_a8,(sigset_t *)0x0);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001b18b0": "\nundefined8 FUN_001b18b0(int param_1)\n\n{\n  if (param_1 == 0x2d) {\n    if (posixly_correct != 0) {\n      return 0;\n    }\n    posixly_correct = 1;\n    bind_variable(\"POSIXLY_CORRECT\",\"y\",0);\n  }\n  else {\n    if ((param_1 == 0x2b) && (posixly_correct == 0)) {\n      return 0;\n    }\n    posixly_correct = 0;\n    unbind_variable_noref(\"POSIXLY_CORRECT\");\n  }\n  sv_strict_posix(\"POSIXLY_CORRECT\");\n  return 0;\n}\n\n",
  "FUN_001b8cb0": "\nlong FUN_001b8cb0(void)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  char *pcVar3;\n  \n  lVar2 = FUN_001b8b90();\n  if (DAT_00248db8 != 0) {\n    if (0x7fffffff < lVar2) {\n      uVar1 = **(undefined8 **)(DAT_00248db8 + 8);\n      pcVar3 = strerror(0x22);\n      builtin_error(\"warning: %s: %s\",uVar1,pcVar3);\n      return 0x7fffffff;\n    }\n    if (lVar2 < -0x80000000) {\n      uVar1 = **(undefined8 **)(DAT_00248db8 + 8);\n      pcVar3 = strerror(0x22);\n      builtin_error(\"warning: %s: %s\",uVar1,pcVar3);\n      return 0x80000000;\n    }\n  }\n  return lVar2;\n}\n\n",
  "glob_dirscan": "\nchar * glob_dirscan(char *param_1,int param_2)\n\n{\n  char cVar1;\n  uint uVar2;\n  char *pcVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char *pcVar6;\n  \n  pcVar6 = (char *)0x0;\n  pcVar5 = (char *)0x0;\n  if (param_1 != (char *)0x0) {\n    cVar1 = *param_1;\n    while (cVar1 != '\\0') {\n      uVar2 = (int)cVar1 - 0x21;\n      if ((((byte)uVar2 < 0x20) && ((0xc0000601UL >> ((ulong)uVar2 & 0x3f) & 1) != 0)) &&\n         (param_1[1] == '(')) {\n        if (pcVar6 == (char *)0x0) {\n          sVar4 = strlen(param_1);\n          pcVar6 = param_1 + (sVar4 - 1);\n        }\n        pcVar3 = (char *)glob_patscan(param_1 + 2,pcVar6,0);\n        if (pcVar3 == (char *)0x0) {\n          pcVar3 = param_1 + 1;\n        }\n        else if (*pcVar3 == '\\0') {\n          return pcVar5;\n        }\n      }\n      else {\n        pcVar3 = param_1 + 1;\n        if (cVar1 == param_2) {\n          pcVar5 = param_1;\n        }\n      }\n      param_1 = pcVar3;\n      cVar1 = *pcVar3;\n    }\n  }\n  return pcVar5;\n}\n\n",
  "sh_physpath": "\nchar * sh_physpath(char *param_1)\n\n{\n  bool bVar1;\n  char cVar2;\n  size_t sVar3;\n  char *__path;\n  char *pcVar4;\n  int *piVar5;\n  ssize_t sVar6;\n  char *pcVar7;\n  char *pcVar8;\n  long lVar9;\n  char *pcVar10;\n  char *pcVar11;\n  char *pcVar12;\n  long in_FS_OFFSET;\n  int local_2070;\n  undefined local_2058 [4112];\n  char local_1048 [4104];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar3 = strlen(param_1);\n  __path = (char *)sh_xmalloc(0x1001,\"pathphys.c\",0x5c);\n  if ((int)sVar3 < 0x1000) {\n    pcVar4 = (char *)sh_xmalloc(0x1001,\"pathphys.c\",100);\n    strcpy(pcVar4,param_1);\n    cVar2 = *pcVar4;\n  }\n  else {\n    sVar3 = strlen(param_1);\n    pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"pathphys.c\",0x61);\n    pcVar4 = strcpy(pcVar4,param_1);\n    cVar2 = *pcVar4;\n  }\n  pcVar12 = pcVar4 + 1;\n  if (((cVar2 == '/') && (pcVar4[1] == '/')) && (pcVar4[2] != '/')) {\n    pcVar11 = pcVar4 + 2;\n    cVar2 = '/';\n    pcVar10 = pcVar4;\n    pcVar8 = __path;\n    while( true ) {\n      pcVar10 = pcVar10 + 1;\n      *pcVar8 = cVar2;\n      if (pcVar11 <= pcVar10) break;\n      cVar2 = *pcVar10;\n      pcVar8 = pcVar8 + 1;\n    }\n    bVar1 = true;\n  }\n  else {\n    *__path = cVar2;\n    bVar1 = false;\n    pcVar11 = pcVar12;\n  }\n  lVar9 = (long)pcVar11 - (long)pcVar4;\n  if (pcVar11 < pcVar12) {\n    lVar9 = 1;\n  }\n  pcVar11 = pcVar4 + lVar9;\n  pcVar10 = __path + lVar9;\n  cVar2 = *pcVar11;\n  if (cVar2 != '\\0') {\n    local_2070 = 0;\n    pcVar8 = pcVar10;\n    do {\n      if (cVar2 == '/') {\nLAB_001c6a20:\n        cVar2 = pcVar11[1];\n        pcVar11 = pcVar11 + 1;\n      }\n      else {\n        if (cVar2 != '.') {\nLAB_001c6932:\n          pcVar7 = pcVar8;\n          if (pcVar8 != pcVar10) {\n            *pcVar10 = '/';\n            pcVar7 = pcVar10 + 1;\n          }\n          cVar2 = *pcVar11;\n          if ((cVar2 != '/') && (cVar2 != '\\0')) {\n            do {\n              if (0xfff < (long)pcVar7 - (long)__path) goto LAB_001c698f;\n              pcVar11 = pcVar11 + 1;\n              *pcVar7 = cVar2;\n              pcVar7 = pcVar7 + 1;\n              cVar2 = *pcVar11;\n            } while ((cVar2 != '\\0') && (cVar2 != '/'));\n          }\n          *pcVar7 = '\\0';\n          sVar6 = readlink(__path,local_1048,0x1000);\n          if ((int)sVar6 < 0) {\n            piVar5 = __errno_location();\n            if (*piVar5 == 0x16) {\n              cVar2 = *pcVar11;\n              pcVar10 = pcVar7;\n              goto LAB_001c6a2a;\n            }\n          }\n          else {\n            local_2070 = local_2070 + 1;\n            if (local_2070 < 0x15) {\n              lVar9 = (long)(int)sVar6;\n              local_1048[lVar9] = '\\0';\n              sVar3 = strlen(pcVar11);\n              if (lVar9 + 2 + sVar3 < 0x1000) {\n                pcVar7 = (char *)__strcpy_chk(local_2058,local_1048,0x1001);\n                local_2058[lVar9] = 0x2f;\n                memcpy(pcVar7 + lVar9,pcVar11,sVar3 + 1);\n                strcpy(pcVar4,pcVar7);\n                cVar2 = *pcVar4;\n                pcVar11 = pcVar4;\n                if (local_1048[0] == '/') {\n                  bVar1 = false;\n                  pcVar7 = pcVar12;\n                  if (cVar2 == '/') {\n                    if ((pcVar4[1] == '/') && (pcVar4[2] != '/')) {\n                      bVar1 = true;\n                      pcVar7 = pcVar4 + 2;\n                    }\n                    pcVar10 = __path;\n                    pcVar8 = __path;\n                    if (pcVar7 <= pcVar4) goto LAB_001c6a20;\n                  }\n                  lVar9 = 0;\n                  while( true ) {\n                    __path[lVar9] = cVar2;\n                    lVar9 = lVar9 + 1;\n                    if ((long)pcVar7 - (long)pcVar4 == lVar9) break;\n                    cVar2 = pcVar4[lVar9];\n                  }\n                  pcVar8 = __path + ((long)pcVar7 - (long)pcVar4);\n                  cVar2 = *pcVar7;\n                  pcVar10 = pcVar8;\n                  pcVar11 = pcVar7;\n                }\n                goto LAB_001c6a2a;\n              }\nLAB_001c698f:\n              piVar5 = __errno_location();\n              *piVar5 = 0x24;\n            }\n            else {\n              piVar5 = __errno_location();\n              *piVar5 = 0x28;\n            }\n          }\n          pcVar12 = (char *)0x0;\n          sh_xfree(__path,\"pathphys.c\",0xb9);\n          sh_xfree(pcVar4,\"pathphys.c\",0xba);\n          goto LAB_001c69c0;\n        }\n        cVar2 = pcVar11[1];\n        if ((cVar2 == '/') || (cVar2 == '\\0')) {\n          pcVar11 = pcVar11 + 1;\n        }\n        else {\n          if ((cVar2 != '.') || ((cVar2 = pcVar11[2], cVar2 != '/' && (cVar2 != '\\0'))))\n          goto LAB_001c6932;\n          pcVar11 = pcVar11 + 2;\n          if (pcVar8 < pcVar10) {\n            do {\n              pcVar10 = pcVar10 + -1;\n              if (pcVar10 == pcVar8) break;\n            } while (*pcVar10 != '/');\n          }\n        }\n      }\nLAB_001c6a2a:\n    } while (cVar2 != '\\0');\n  }\n  *pcVar10 = '\\0';\n  sh_xfree(pcVar4,\"pathphys.c\",0xee);\n  pcVar12 = __path;\n  if ((((*__path == '/') && (__path[1] == '/')) && (!bVar1)) && (__path[2] != '/')) {\n    if (__path[2] == '\\0') {\n      __path[1] = '\\0';\n    }\n    else {\n      sVar3 = strlen(__path + 1);\n      memmove(__path,__path + 1,sVar3 + 1);\n    }\n  }\nLAB_001c69c0:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pcVar12;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "assign_array_var_from_word_list": "\nlong assign_array_var_from_word_list(long param_1,long *param_2,uint param_3)\n\n{\n  long lVar1;\n  \n  if ((param_3 & 1) == 0) {\n    lVar1 = 0;\n  }\n  else {\n    lVar1 = **(long **)(param_1 + 8) + 1;\n  }\n  if (param_2 != (long *)0x0) {\n    do {\n      FUN_0018a8b0(param_1,lVar1,0,*(undefined8 *)param_2[1],param_3 & 0xfffffffe);\n      param_2 = (long *)*param_2;\n      lVar1 = lVar1 + 1;\n    } while (param_2 != (long *)0x0);\n  }\n  *(uint *)(param_1 + 0x28) = *(uint *)(param_1 + 0x28) & 0xffffefff;\n  return param_1;\n}\n\n",
  "FUN_001da530": "\nundefined8 FUN_001da530(char *param_1)\n\n{\n  long lVar1;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    lVar1 = strtol(param_1,(char **)0x0,10);\n    _rl_completion_prefix_display_length = (int)lVar1;\n    if (_rl_completion_prefix_display_length < 0) {\n      _rl_completion_prefix_display_length = 0;\n    }\n    return 0;\n  }\n  _rl_completion_prefix_display_length = 0;\n  return 0;\n}\n\n",
  "unlink": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_unlink_00237f10)();\n  return iVar1;\n}\n\n",
  "set_itemlist_dirty": "\nvoid set_itemlist_dirty(uint *param_1)\n\n{\n  *param_1 = *param_1 | 2;\n  return;\n}\n\n",
  "FUN_00151270": "\nundefined8 FUN_00151270(undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
  "_rl_set_screen_size": "\nvoid _rl_set_screen_size(int param_1,int param_2)\n\n{\n  if (_rl_term_autowrap == -1) {\n    _rl_init_terminal_io(rl_terminal_name);\n  }\n  if (param_1 < 1) {\n    if (param_2 < 1) {\n      return;\n    }\n  }\n  else {\n    _rl_screenheight = param_1;\n    if (param_2 < 1) goto LAB_001ed825;\n  }\n  _rl_screenwidth = param_2;\n  if (_rl_term_autowrap == 0) {\n    _rl_screenwidth = param_2 + -1;\n  }\nLAB_001ed825:\n  _rl_screenchars = _rl_screenwidth * _rl_screenheight;\n  return;\n}\n\n",
  "mailstat": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint mailstat(char *param_1,stat *param_2)\n\n{\n  char *pcVar1;\n  stat *__buf;\n  char *__s;\n  uint uVar2;\n  __nlink_t _Var3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  __dev_t _Var6;\n  __off_t _Var7;\n  __blksize_t _Var8;\n  __blkcnt_t _Var9;\n  __time_t _Var10;\n  __time_t _Var11;\n  __time_t _Var12;\n  long lVar13;\n  long lVar14;\n  undefined4 uVar15;\n  undefined4 uVar16;\n  undefined4 uVar17;\n  undefined4 uVar18;\n  undefined4 uVar19;\n  undefined4 uVar20;\n  undefined4 uVar21;\n  undefined4 uVar22;\n  undefined4 uVar23;\n  undefined4 uVar24;\n  undefined4 uVar25;\n  undefined4 uVar26;\n  undefined4 uVar27;\n  undefined4 uVar28;\n  undefined4 uVar29;\n  undefined4 uVar30;\n  undefined4 uVar31;\n  undefined4 uVar32;\n  undefined4 uVar33;\n  undefined4 uVar34;\n  undefined4 uVar35;\n  undefined4 uVar36;\n  undefined4 uVar37;\n  undefined4 uVar38;\n  undefined4 uVar39;\n  undefined4 uVar40;\n  undefined4 uVar41;\n  undefined4 uVar42;\n  undefined4 uVar43;\n  undefined4 uVar44;\n  undefined4 uVar45;\n  undefined4 uVar46;\n  undefined4 uVar47;\n  undefined4 uVar48;\n  undefined4 uVar49;\n  int iVar50;\n  int iVar51;\n  size_t sVar52;\n  DIR *__dirp;\n  dirent *pdVar53;\n  size_t sVar54;\n  long lVar55;\n  long lVar56;\n  int *piVar57;\n  long lVar58;\n  long lVar59;\n  undefined *puVar60;\n  undefined4 *puVar61;\n  undefined *puVar62;\n  long in_FS_OFFSET;\n  byte bVar63;\n  undefined local_4030 [16384];\n  \n  bVar63 = 0;\n  puVar62 = &stack0xffffffffffffffd0;\n  do {\n    puVar60 = puVar62;\n    *(undefined8 *)(puVar60 + -0x1000) = *(undefined8 *)(puVar60 + -0x1000);\n    puVar62 = puVar60 + -0x1000;\n  } while (puVar60 + -0x1000 != local_4030);\n  *(undefined8 *)(puVar60 + 0x2ff0) = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  *(undefined8 *)(puVar60 + -0x1190) = 0x1ca08c;\n  iVar50 = stat(param_1,param_2);\n  if ((iVar50 == 0) && (uVar2 = param_2->st_mode, (uVar2 & 0xf000) == 0x4000)) {\n    *(undefined8 *)(puVar60 + -0x1190) = 0x1ca0b4;\n    sVar52 = strlen(param_1);\n    if (sVar52 < 0x1ffc) {\n      uVar15 = *(undefined4 *)((long)&param_2->st_dev + 4);\n      uVar16 = *(undefined4 *)&param_2->st_ino;\n      uVar17 = *(undefined4 *)((long)&param_2->st_ino + 4);\n      _Var3 = param_2->st_nlink;\n      uVar4 = *(undefined8 *)&param_2->st_mode;\n      uVar5 = *(undefined8 *)&param_2->st_gid;\n      _Var6 = param_2->st_rdev;\n      _Var7 = param_2->st_size;\n      _Var8 = param_2->st_blksize;\n      pcVar1 = puVar60 + -0x1018;\n      _Var9 = param_2->st_blocks;\n      _Var10 = (param_2->st_atim).tv_sec;\n      lVar59 = (param_2->st_atim).tv_nsec;\n      _Var11 = (param_2->st_mtim).tv_sec;\n      *(undefined4 *)(puVar60 + -0x1138) = *(undefined4 *)&param_2->st_dev;\n      *(undefined4 *)(puVar60 + -0x1134) = uVar15;\n      *(undefined4 *)(puVar60 + -0x1130) = uVar16;\n      *(undefined4 *)(puVar60 + -0x112c) = uVar17;\n      lVar56 = (param_2->st_mtim).tv_nsec;\n      _Var12 = (param_2->st_ctim).tv_sec;\n      lVar55 = (param_2->st_ctim).tv_nsec;\n      lVar58 = param_2->__unused[0];\n      lVar13 = param_2->__unused[1];\n      lVar14 = param_2->__unused[2];\n      __buf = (stat *)(puVar60 + -0x10a8);\n      *(__nlink_t *)(puVar60 + -0x1128) = _Var3;\n      *(undefined8 *)(puVar60 + -0x1120) = uVar4;\n      *(undefined8 *)(puVar60 + -0x1118) = uVar5;\n      *(__dev_t *)(puVar60 + -0x1110) = _Var6;\n      *(__off_t *)(puVar60 + -0x1108) = _Var7;\n      *(__blksize_t *)(puVar60 + -0x1100) = _Var8;\n      *(__blkcnt_t *)(puVar60 + -0x10f8) = _Var9;\n      *(__time_t *)(puVar60 + -0x10f0) = _Var10;\n      *(long *)(puVar60 + -0x10e8) = lVar59;\n      *(__time_t *)(puVar60 + -0x10e0) = _Var11;\n      *(long *)(puVar60 + -0x10d8) = lVar56;\n      *(__time_t *)(puVar60 + -0x10d0) = _Var12;\n      *(long *)(puVar60 + -0x10c8) = lVar55;\n      *(long *)(puVar60 + -0x10c0) = lVar58;\n      *(long *)(puVar60 + -0x10b8) = lVar13;\n      *(long *)(puVar60 + -0x10b0) = lVar14;\n      *(undefined8 *)(puVar60 + -0x1190) = 0x1ca15d;\n      __sprintf_chk(pcVar1,1,0x2000,&DAT_002128cc,param_1);\n      *(undefined8 *)(puVar60 + -0x1190) = 0x1ca168;\n      iVar51 = stat(pcVar1,__buf);\n      if ((iVar51 == 0) && ((*(uint *)(puVar60 + -0x1090) & 0xf000) == 0x4000)) {\n        *(undefined8 *)(puVar60 + -0x1190) = 0x1ca1ce;\n        __sprintf_chk(pcVar1,1,0x2000,\"%s/tmp\",param_1);\n        *(undefined8 *)(puVar60 + -0x1190) = 0x1ca1d9;\n        iVar51 = stat(pcVar1,__buf);\n        if ((iVar51 == 0) && ((*(uint *)(puVar60 + -0x1090) & 0xf000) == 0x4000)) {\n          *(undefined8 *)(puVar60 + -0x1190) = 0x1ca20e;\n          __sprintf_chk(pcVar1,1,0x2000,&DAT_002128da,param_1);\n          *(undefined8 *)(puVar60 + -0x1190) = 0x1ca219;\n          iVar51 = stat(pcVar1,__buf);\n          if ((iVar51 == 0) && ((*(uint *)(puVar60 + -0x1090) & 0xf000) == 0x4000)) {\n            *(undefined8 *)(puVar60 + -0x1150) = *(undefined8 *)(puVar60 + -0x1050);\n            if ((*(long *)(puVar60 + -0x10a8) ==\n                 CONCAT44(DAT_0024a040._4_4_,(undefined4)DAT_0024a040)) &&\n               (((*(long *)(puVar60 + -0x10a0) ==\n                  CONCAT44(DAT_0024a048._4_4_,(undefined4)DAT_0024a048) &&\n                 (*(long *)(puVar60 + -0x1060) ==\n                  CONCAT44(DAT_0024a088._4_4_,(undefined4)DAT_0024a088))) &&\n                (*(long *)(puVar60 + -0x1150) == CONCAT44(uRam000000000024a09c,_DAT_0024a098))))) {\n              iVar50 = 0;\n              puVar61 = &DAT_00249fa0;\n              for (lVar59 = 0x24; lVar59 != 0; lVar59 = lVar59 + -1) {\n                *(undefined4 *)&param_2->st_dev = *puVar61;\n                puVar61 = puVar61 + (ulong)bVar63 * -2 + 1;\n                param_2 = (stat *)((long)param_2 + (ulong)bVar63 * -8 + 4);\n              }\n            }\n            else {\n              DAT_0024a040._0_4_ = *(undefined4 *)(puVar60 + -0x10a8);\n              DAT_0024a040._4_4_ = *(undefined4 *)(puVar60 + -0x10a4);\n              DAT_0024a048._0_4_ = *(undefined4 *)(puVar60 + -0x10a0);\n              DAT_0024a048._4_4_ = *(undefined4 *)(puVar60 + -0x109c);\n              *(uint *)(puVar60 + -0x1140) = uVar2;\n              lVar59 = 0;\n              __s = puVar60 + 0xfe8;\n              _DAT_0024a050 = *(undefined4 *)(puVar60 + -0x1098);\n              uRam000000000024a054 = *(undefined4 *)(puVar60 + -0x1094);\n              uRam000000000024a058 = *(undefined4 *)(puVar60 + -0x1090);\n              uRam000000000024a05c = *(undefined4 *)(puVar60 + -0x108c);\n              *(undefined4 *)(puVar60 + -0x113c) = 0;\n              puVar62 = &DAT_002128dd;\n              _DAT_0024a060 = *(undefined4 *)(puVar60 + -0x1088);\n              uRam000000000024a064 = *(undefined4 *)(puVar60 + -0x1084);\n              uRam000000000024a068 = *(undefined4 *)(puVar60 + -0x1080);\n              uRam000000000024a06c = *(undefined4 *)(puVar60 + -0x107c);\n              _DAT_0024a070 = *(undefined4 *)(puVar60 + -0x1078);\n              uRam000000000024a074 = *(undefined4 *)(puVar60 + -0x1074);\n              uRam000000000024a078 = *(undefined4 *)(puVar60 + -0x1070);\n              uRam000000000024a07c = *(undefined4 *)(puVar60 + -0x106c);\n              _DAT_0024a080 = *(undefined4 *)(puVar60 + -0x1068);\n              uRam000000000024a084 = *(undefined4 *)(puVar60 + -0x1064);\n              DAT_0024a088._0_4_ = *(undefined4 *)(puVar60 + -0x1060);\n              DAT_0024a088._4_4_ = *(undefined4 *)(puVar60 + -0x105c);\n              _DAT_0024a090 = *(undefined4 *)(puVar60 + -0x1058);\n              uRam000000000024a094 = *(undefined4 *)(puVar60 + -0x1054);\n              _DAT_0024a098 = *(undefined4 *)(puVar60 + -0x1050);\n              uRam000000000024a09c = *(undefined4 *)(puVar60 + -0x104c);\n              _DAT_0024a0a0 = *(undefined4 *)(puVar60 + -0x1048);\n              uRam000000000024a0a4 = *(undefined4 *)(puVar60 + -0x1044);\n              uRam000000000024a0a8 = *(undefined4 *)(puVar60 + -0x1040);\n              uRam000000000024a0ac = *(undefined4 *)(puVar60 + -0x103c);\n              *(undefined4 *)(puVar60 + -0x1164) = 2;\n              _DAT_0024a0b0 = *(undefined4 *)(puVar60 + -0x1038);\n              uRam000000000024a0b4 = *(undefined4 *)(puVar60 + -0x1034);\n              uRam000000000024a0b8 = *(undefined4 *)(puVar60 + -0x1030);\n              uRam000000000024a0bc = *(undefined4 *)(puVar60 + -0x102c);\n              *(stat **)(puVar60 + -0x1148) = param_2;\n              _DAT_0024a0c0 = *(undefined4 *)(puVar60 + -0x1028);\n              uRam000000000024a0c4 = *(undefined4 *)(puVar60 + -0x1024);\n              uRam000000000024a0c8 = *(undefined4 *)(puVar60 + -0x1020);\n              uRam000000000024a0cc = *(undefined4 *)(puVar60 + -0x101c);\n              *(undefined8 *)(puVar60 + -0x1188) = 0;\n              *(undefined8 *)(puVar60 + -0x1170) = 0;\n              *(undefined8 *)(puVar60 + -0x1178) = 0;\n              *(stat **)(puVar60 + -0x1180) = __buf;\n              *(char **)(puVar60 + -0x1160) = param_1;\n              *(char **)(puVar60 + -0x1158) = pcVar1;\n              while( true ) {\n                pcVar1 = *(char **)(puVar60 + -0x1158);\n                *(undefined8 *)(puVar60 + -0x1190) = 0x1ca365;\n                __sprintf_chk(pcVar1,1,0x2000,\"%s/%s\",*(undefined8 *)(puVar60 + -0x1160),puVar62);\n                *(undefined8 *)(puVar60 + -0x1190) = 0x1ca383;\n                __sprintf_chk(__s,1,0x2001,&DAT_002128e7,pcVar1);\n                *(undefined8 *)(puVar60 + -0x1190) = 0x1ca38b;\n                sVar52 = strlen(__s);\n                *(undefined8 *)(puVar60 + -0x1190) = 0x1ca396;\n                __dirp = opendir(pcVar1);\n                if (__dirp == (DIR *)0x0) break;\nLAB_001ca3b0:\n                *(undefined8 *)(puVar60 + -0x1190) = 0x1ca3b8;\n                pdVar53 = readdir(__dirp);\n                if (pdVar53 != (dirent *)0x0) {\n                  while (pdVar53->d_name[0] != '.') {\n                    *(undefined8 *)(puVar60 + -0x1190) = 0x1ca3d3;\n                    sVar54 = strlen(pdVar53->d_name);\n                    if (0x2000 < sVar52 + sVar54) break;\n                    *(undefined8 *)(puVar60 + -0x1190) = 0x1ca3ef;\n                    memcpy(__s + sVar52,pdVar53->d_name,sVar54 + 1);\n                    *(undefined8 *)(puVar60 + -0x1190) = 0x1ca3fc;\n                    iVar50 = stat(__s,*(stat **)(puVar60 + -0x1180));\n                    if (iVar50 != 0) break;\n                    *(long *)(puVar60 + -0x1178) =\n                         *(long *)(puVar60 + -0x1178) + *(long *)(puVar60 + -0x1078);\n                    lVar56 = *(long *)(puVar60 + -0x1060);\n                    lVar55 = *(long *)(puVar60 + -0x1050);\n                    *(long *)(puVar60 + -0x1170) = *(long *)(puVar60 + -0x1170) + 1;\n                    lVar58 = lVar56;\n                    if (lVar56 <= lVar59) {\n                      lVar58 = lVar59;\n                    }\n                    if (lVar56 != lVar55) {\n                      lVar59 = lVar58;\n                    }\n                    if (lVar55 <= *(long *)(puVar60 + -0x1188)) {\n                      lVar55 = *(long *)(puVar60 + -0x1188);\n                    }\n                    *(long *)(puVar60 + -0x1188) = lVar55;\n                    *(undefined8 *)(puVar60 + -0x1190) = 0x1ca44b;\n                    pdVar53 = readdir(__dirp);\n                    if (pdVar53 == (dirent *)0x0) goto LAB_001ca454;\n                  }\n                  goto LAB_001ca3b0;\n                }\nLAB_001ca454:\n                *(undefined8 *)(puVar60 + -0x1190) = 0x1ca45c;\n                closedir(__dirp);\n                puVar62 = &DAT_002128cf;\n                if (*(int *)(puVar60 + -0x1164) == 1) {\n                  lVar56 = *(long *)(puVar60 + -0x1188);\n                  *(undefined8 *)(puVar60 + -0x1128) = 1;\n                  puVar61 = *(undefined4 **)(puVar60 + -0x1148);\n                  *(long *)(puVar60 + -0x10f0) = lVar59;\n                  if (lVar56 == 0) {\n                    lVar56 = *(long *)(puVar60 + -0x1150);\n                  }\n                  *(undefined8 *)(puVar60 + -0x1108) = *(undefined8 *)(puVar60 + -0x1178);\n                  iVar50 = 0;\n                  DAT_00249fa0 = *(undefined4 *)(puVar60 + -0x1138);\n                  uVar15 = *(undefined4 *)(puVar60 + -0x1134);\n                  uVar16 = *(undefined4 *)(puVar60 + -0x1130);\n                  uVar17 = *(undefined4 *)(puVar60 + -0x112c);\n                  uVar18 = *(undefined4 *)(puVar60 + -0x1118);\n                  uVar19 = *(undefined4 *)(puVar60 + -0x1114);\n                  uVar20 = *(undefined4 *)(puVar60 + -0x1110);\n                  uVar21 = *(undefined4 *)(puVar60 + -0x110c);\n                  uVar22 = *(undefined4 *)(puVar60 + -0x1108);\n                  uVar23 = *(undefined4 *)(puVar60 + -0x1104);\n                  uVar24 = *(undefined4 *)(puVar60 + -0x1100);\n                  uVar25 = *(undefined4 *)(puVar60 + -0x10fc);\n                  *(long *)(puVar60 + -0x10e0) = lVar56;\n                  uVar26 = *(undefined4 *)(puVar60 + -0x10d8);\n                  uVar27 = *(undefined4 *)(puVar60 + -0x10d4);\n                  uVar28 = *(undefined4 *)(puVar60 + -0x10d0);\n                  uVar29 = *(undefined4 *)(puVar60 + -0x10cc);\n                  *(uint *)(puVar60 + -0x1120) = *(uint *)(puVar60 + -0x1140) & 0xffffbfff | 0x8000;\n                  uVar30 = *(undefined4 *)(puVar60 + -0x10e8);\n                  uVar31 = *(undefined4 *)(puVar60 + -0x10e4);\n                  uVar32 = *(undefined4 *)(puVar60 + -0x10e0);\n                  uVar33 = *(undefined4 *)(puVar60 + -0x10dc);\n                  uVar34 = *(undefined4 *)(puVar60 + -0x1128);\n                  uVar35 = *(undefined4 *)(puVar60 + -0x1124);\n                  uVar36 = *(undefined4 *)(puVar60 + -0x1120);\n                  uVar37 = *(undefined4 *)(puVar60 + -0x111c);\n                  *(undefined8 *)(puVar60 + -0x10f8) = *(undefined8 *)(puVar60 + -0x1170);\n                  uVar38 = *(undefined4 *)(puVar60 + -0x10c8);\n                  uVar39 = *(undefined4 *)(puVar60 + -0x10c4);\n                  uVar40 = *(undefined4 *)(puVar60 + -0x10c0);\n                  uVar41 = *(undefined4 *)(puVar60 + -0x10bc);\n                  uVar42 = *(undefined4 *)(puVar60 + -0x10f8);\n                  uVar43 = *(undefined4 *)(puVar60 + -0x10f4);\n                  uVar44 = *(undefined4 *)(puVar60 + -0x10f0);\n                  uVar45 = *(undefined4 *)(puVar60 + -0x10ec);\n                  uVar46 = *(undefined4 *)(puVar60 + -0x10b8);\n                  uVar47 = *(undefined4 *)(puVar60 + -0x10b4);\n                  uVar48 = *(undefined4 *)(puVar60 + -0x10b0);\n                  uVar49 = *(undefined4 *)(puVar60 + -0x10ac);\n                  uRam0000000000249fa4 = uVar15;\n                  uRam0000000000249fa8 = uVar16;\n                  uRam0000000000249fac = uVar17;\n                  _DAT_00249fb0 = uVar34;\n                  uRam0000000000249fb4 = uVar35;\n                  uRam0000000000249fb8 = uVar36;\n                  uRam0000000000249fbc = uVar37;\n                  _DAT_00249fc0 = uVar18;\n                  uRam0000000000249fc4 = uVar19;\n                  uRam0000000000249fc8 = uVar20;\n                  uRam0000000000249fcc = uVar21;\n                  _DAT_00249fd0 = uVar22;\n                  uRam0000000000249fd4 = uVar23;\n                  uRam0000000000249fd8 = uVar24;\n                  uRam0000000000249fdc = uVar25;\n                  _DAT_00249fe0 = uVar42;\n                  uRam0000000000249fe4 = uVar43;\n                  uRam0000000000249fe8 = uVar44;\n                  uRam0000000000249fec = uVar45;\n                  _DAT_00249ff0 = uVar30;\n                  uRam0000000000249ff4 = uVar31;\n                  uRam0000000000249ff8 = uVar32;\n                  uRam0000000000249ffc = uVar33;\n                  _DAT_0024a000 = uVar26;\n                  uRam000000000024a004 = uVar27;\n                  uRam000000000024a008 = uVar28;\n                  uRam000000000024a00c = uVar29;\n                  _DAT_0024a010 = uVar38;\n                  uRam000000000024a014 = uVar39;\n                  uRam000000000024a018 = uVar40;\n                  uRam000000000024a01c = uVar41;\n                  _DAT_0024a020 = uVar46;\n                  uRam000000000024a024 = uVar47;\n                  uRam000000000024a028 = uVar48;\n                  uRam000000000024a02c = uVar49;\n                  *puVar61 = DAT_00249fa0;\n                  puVar61[1] = uVar15;\n                  puVar61[2] = uVar16;\n                  puVar61[3] = uVar17;\n                  puVar61[4] = uVar34;\n                  puVar61[5] = uVar35;\n                  puVar61[6] = uVar36;\n                  puVar61[7] = uVar37;\n                  puVar61[8] = uVar18;\n                  puVar61[9] = uVar19;\n                  puVar61[10] = uVar20;\n                  puVar61[0xb] = uVar21;\n                  puVar61[0xc] = uVar22;\n                  puVar61[0xd] = uVar23;\n                  puVar61[0xe] = uVar24;\n                  puVar61[0xf] = uVar25;\n                  puVar61[0x10] = uVar42;\n                  puVar61[0x11] = uVar43;\n                  puVar61[0x12] = uVar44;\n                  puVar61[0x13] = uVar45;\n                  puVar61[0x14] = uVar30;\n                  puVar61[0x15] = uVar31;\n                  puVar61[0x16] = uVar32;\n                  puVar61[0x17] = uVar33;\n                  puVar61[0x18] = uVar26;\n                  puVar61[0x19] = uVar27;\n                  puVar61[0x1a] = uVar28;\n                  puVar61[0x1b] = uVar29;\n                  puVar61[0x1c] = uVar38;\n                  puVar61[0x1d] = uVar39;\n                  puVar61[0x1e] = uVar40;\n                  puVar61[0x1f] = uVar41;\n                  puVar61[0x20] = uVar46;\n                  puVar61[0x21] = uVar47;\n                  puVar61[0x22] = uVar48;\n                  puVar61[0x23] = uVar49;\n                  goto LAB_001ca180;\n                }\n                *(undefined4 *)(puVar60 + -0x1164) = 1;\n              }\n              iVar50 = *(int *)(puVar60 + -0x113c);\n            }\n          }\n        }\n      }\n    }\n    else {\n      *(undefined8 *)(puVar60 + -0x1190) = 0x1ca57f;\n      piVar57 = __errno_location();\n      iVar50 = -1;\n      *piVar57 = 0x24;\n    }\n  }\nLAB_001ca180:\n  if (*(long *)(puVar60 + 0x2ff0) != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    *(undefined **)(puVar60 + -0x1190) = &UNK_001ca601;\n    __stack_chk_fail();\n  }\n  return iVar50;\n}\n\n",
  "time_to_check_mail": "\nbool time_to_check_mail(void)\n\n{\n  bool bVar1;\n  int iVar2;\n  long lVar3;\n  time_t tVar4;\n  long in_FS_OFFSET;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar3 = get_string_value(\"MAILCHECK\");\n  if (lVar3 != 0) {\n    iVar2 = legal_number(lVar3,&local_18);\n    if ((iVar2 != 0) && (-1 < local_18)) {\n      tVar4 = time((time_t *)0x0);\n      bVar1 = true;\n      if (local_18 != 0) {\n        bVar1 = local_18 <= tVar4 - DAT_002478a8;\n      }\n      goto LAB_001808c2;\n    }\n  }\n  bVar1 = false;\nLAB_001808c2:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001edaf0": "\nundefined8 FUN_001edaf0(int param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  size_t sVar5;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  do {\n    if (rl_point == 0) {\n      return 0;\n    }\n    sVar5 = __ctype_get_mb_cur_max();\n    if ((sVar5 < 2) || (rl_byte_oriented != 0)) {\n      iVar3 = rl_point + -1;\n    }\n    else {\n      iVar3 = _rl_find_prev_mbchar(rl_line_buffer,rl_point,1);\n    }\n    uVar1 = _rl_char_value(rl_line_buffer,iVar3);\n    iVar2 = _rl_walphabetic(uVar1);\n    iVar4 = rl_point;\n    while ((rl_point = iVar3, iVar2 == 0 && (iVar4 = rl_point, 0 < rl_point))) {\n      sVar5 = __ctype_get_mb_cur_max();\n      if ((sVar5 < 2) || (rl_byte_oriented != 0)) {\n        iVar3 = rl_point + -1;\n      }\n      else {\n        iVar3 = _rl_find_prev_mbchar(rl_line_buffer,rl_point,1);\n      }\n      uVar1 = _rl_char_value(rl_line_buffer,iVar3);\n      iVar2 = _rl_walphabetic(uVar1);\n      iVar4 = rl_point;\n    }\n    do {\n      rl_point = iVar4;\n      if (rl_point == 0) break;\n      sVar5 = __ctype_get_mb_cur_max();\n      if ((sVar5 < 2) || (rl_byte_oriented != 0)) {\n        iVar4 = rl_point + -1;\n      }\n      else {\n        iVar4 = _rl_find_prev_mbchar(rl_line_buffer,rl_point,1);\n      }\n      uVar1 = _rl_char_value(rl_line_buffer,iVar4);\n      iVar3 = _rl_walphabetic(uVar1);\n    } while (iVar3 != 0);\n    param_1 = param_1 + -1;\n    if (param_1 == 0) {\n      return 0;\n    }\n  } while( true );\n}\n\n",
  "get_name_for_error": "\nchar * get_name_for_error(void)\n\n{\n  long lVar1;\n  char *pcVar2;\n  \n  if (interactive_shell == 0) {\n    lVar1 = find_variable(\"BASH_SOURCE\");\n    if ((((lVar1 != 0) && ((*(byte *)(lVar1 + 0x28) & 4) != 0)) && (*(long *)(lVar1 + 8) != 0)) &&\n       ((pcVar2 = (char *)array_reference(*(long *)(lVar1 + 8),0), pcVar2 != (char *)0x0 &&\n        (*pcVar2 != '\\0')))) {\n      return pcVar2;\n    }\n    if (dollar_vars != (char *)0x0) {\n      return dollar_vars;\n    }\n  }\n  if (((shell_name != (char *)0x0) && (*shell_name != '\\0')) &&\n     (pcVar2 = (char *)base_pathname(), pcVar2 != (char *)0x0)) {\n    return pcVar2;\n  }\n  return \"bash\";\n}\n\n",
  "execute_shell_function": "\nundefined4 execute_shell_function(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  undefined (*pauVar3) [16];\n  \n  puVar2 = (undefined4 *)sh_xmalloc(0x10,\"execute_cmd.c\",0x147);\n  *puVar2 = 0x20;\n  pauVar3 = (undefined (*) [16])sh_xmalloc(0x20,\"execute_cmd.c\",0x14d);\n  *(undefined (**) [16])(puVar2 + 2) = pauVar3;\n  *pauVar3 = (undefined  [16])0x0;\n  pauVar3[1] = (undefined  [16])0x0;\n  begin_unwind_frame(\"execute-shell-function\");\n  add_unwind_protect(dispose_fd_bitmap,puVar2);\n  uVar1 = FUN_0014f460(param_1,param_2,0,puVar2,0,0);\n  if (*(long *)(puVar2 + 2) != 0) {\n    sh_xfree(*(long *)(puVar2 + 2),\"execute_cmd.c\",0x159);\n  }\n  sh_xfree(puVar2,\"execute_cmd.c\",0x15a);\n  discard_unwind_frame(\"execute-shell-function\");\n  return uVar1;\n}\n\n",
  "make_group_command": "\nvoid make_group_command(undefined8 param_1)\n\n{\n  undefined4 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x10,\"make_cmd.c\",0x15c);\n  *(undefined8 *)(puVar1 + 2) = param_1;\n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar2[3] = puVar1;\n  *puVar2 = 9;\n  *puVar1 = 0;\n  puVar2[2] = 0;\n  return;\n}\n\n",
  "FUN_001b5380": "\nvoid FUN_001b5380(int param_1,ulong param_2,int param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  undefined auStack_78 [72];\n  long local_30;\n  \n  lVar2 = (long)param_1;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = (&DAT_002351c8)[lVar2 * 8];\n  if (iVar1 == -2) {\n    iVar1 = (-(uint)(posixly_correct == 0) & 0x200) + 0x200;\n  }\n  if (param_3 != 0) {\n    if ((&PTR_s_microseconds_002351d8)[lVar2 * 4] == (undefined *)0x0) {\n      __sprintf_chk(auStack_78,1,0x40,\"(-%c) \",*(undefined4 *)(&DAT_002351c0 + lVar2 * 0x20));\n    }\n    else {\n      __sprintf_chk(auStack_78,1,0x40,\"(%s, -%c) \");\n    }\n    __printf_chk(1,\"%-20s %20s\",(&PTR_s_real_time_non_blocking_time_002351d0)[lVar2 * 4],auStack_78)\n    ;\n  }\n  if (param_2 == 0xffffffffffffffff) {\n    puts(\"unlimited\");\n  }\n  else {\n    print_rlimtype(param_2 / (ulong)(long)iVar1,1,param_2 % (ulong)(long)iVar1);\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_vi_domove": "\nundefined8 rl_vi_domove(undefined8 param_1,int *param_2)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  lVar1 = _rl_vimvcxt;\n  iVar2 = _rl_bracketed_read_key();\n  *(int *)(lVar1 + 0x20) = iVar2;\n  *param_2 = iVar2;\n  if (-1 < iVar2) {\n    uVar3 = FUN_001d2470(lVar1);\n    return uVar3;\n  }\n  *(undefined4 *)(lVar1 + 0x20) = 0;\n  return 0xffffffff;\n}\n\n",
  "get_current_user_info": "\nvoid get_current_user_info(void)\n\n{\n  if (DAT_00238050 != 0) {\n    return;\n  }\n  FUN_00133bd0();\n  return;\n}\n\n",
  "hash_builtin": "\nulong hash_builtin(undefined8 param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  bool bVar3;\n  int iVar4;\n  char *pcVar5;\n  char *pcVar6;\n  long lVar7;\n  ulong uVar8;\n  ulong uVar9;\n  long **pplVar10;\n  code *pcVar11;\n  undefined *puVar12;\n  uint uVar13;\n  uint uVar14;\n  bool bVar15;\n  \n  if (hashing_enabled == 0) {\n    builtin_error(\"hashing disabled\");\n    return 1;\n  }\n  uVar8 = 0;\n  uVar14 = 0;\n  reset_internal_getopt();\n  bVar3 = false;\n  bVar15 = false;\n  pcVar6 = (char *)0x0;\n  while (iVar4 = internal_getopt(param_1,\"dlp:rt\"), pplVar10 = loptend, iVar4 != -1) {\n    if (iVar4 == -99) {\n      builtin_help();\n      return 0x102;\n    }\n    switch(iVar4) {\n    case 100:\n      uVar8 = 1;\n      break;\n    default:\n      builtin_usage();\n      return 0x102;\n    case 0x6c:\n      bVar3 = true;\n      break;\n    case 0x70:\n      pcVar6 = list_optarg;\n      break;\n    case 0x72:\n      bVar15 = true;\n      break;\n    case 0x74:\n      uVar14 = 1;\n    }\n  }\n  uVar13 = (uint)uVar8;\n  if (loptend == (long **)0x0) {\n    if ((uVar14 | uVar13) != 0) {\n      puVar12 = &DAT_0020fc0d;\n      if (uVar13 == 0) {\n        puVar12 = &DAT_0020fc10;\n      }\n      sh_needarg(puVar12);\n      return (ulong)(uVar14 | uVar13);\n    }\n    if (!bVar15) {\n      if ((hashed_filenames == 0) || (*(int *)(hashed_filenames + 0xc) == 0)) {\n        if ((posixly_correct == 0) && ((!bVar3 || (shell_compatibility_level < 0x33)))) {\n          __printf_chk(1,\"%s: hash table empty\\n\",this_command_name);\n        }\n      }\n      else {\n        pcVar11 = FUN_001ab350;\n        if (!bVar3) {\n          puts(\"hits\\tcommand\");\n          pcVar11 = FUN_001ab320;\n        }\n        hash_walk(hashed_filenames,pcVar11);\n      }\n      uVar8 = sh_chkwrite(0);\n      return uVar8;\n    }\n  }\n  else if (!bVar15) goto LAB_001ab510;\n  phash_flush();\nLAB_001ab510:\n  if (uVar14 != 0) {\n    plVar1 = *pplVar10;\n    do {\n      pcVar6 = (char *)phash_search(*pplVar10[1]);\n      if (pcVar6 == (char *)0x0) {\n        uVar14 = 0;\n        sh_notfound(*pplVar10[1]);\n      }\n      else {\n        if (bVar3) {\n          __printf_chk(1,\"builtin hash -p %s %s\\n\",pcVar6,*pplVar10[1]);\n        }\n        else {\n          if (plVar1 != (long *)0x0) {\n            __printf_chk(1,&DAT_0020fc4e,*pplVar10[1]);\n          }\n          puts(pcVar6);\n        }\n        sh_xfree(pcVar6,\"./hash.def\",0x12d);\n      }\n      pplVar10 = (long **)*pplVar10;\n    } while (pplVar10 != (long **)0x0);\n    return (ulong)(uVar14 ^ 1);\n  }\n  bVar15 = pcVar6 != (char *)0x0;\n  if ((restricted != 0) && (bVar15)) {\n    pcVar5 = strchr(pcVar6,0x2f);\n    if (pcVar5 != (char *)0x0) {\n      sh_restricted();\n      return 1;\n    }\n    pcVar5 = (char *)find_user_command(pcVar6);\n    if (((pcVar5 == (char *)0x0) || (*pcVar5 == '\\0')) ||\n       (iVar4 = executable_file(pcVar5), iVar4 == 0)) {\n      sh_notfound(pcVar6);\n      sh_xfree(pcVar5,\"./hash.def\",0xa5);\n      return 1;\n    }\n    sh_xfree(pcVar5,\"./hash.def\",0xa8);\n    bVar15 = true;\n  }\n  uVar9 = 0;\n  for (; pplVar10 != (long **)0x0; pplVar10 = (long **)*pplVar10) {\n    lVar2 = *pplVar10[1];\n    iVar4 = absolute_program(lVar2);\n    if (iVar4 == 0) {\n      if (bVar15) {\n        iVar4 = file_isdir(pcVar6);\n        if (iVar4 == 0) {\n          phash_insert(lVar2,pcVar6,0,0);\n        }\n        else {\n          uVar9 = 1;\n          pcVar5 = strerror(0x15);\n          builtin_error(\"%s: %s\",pcVar6,pcVar5);\n        }\n      }\n      else if (uVar13 == 0) {\n        lVar7 = find_function(lVar2);\n        if ((lVar7 == 0) && (lVar7 = find_shell_builtin(lVar2), lVar7 == 0)) {\n          phash_remove(lVar2);\n          lVar7 = find_user_command(lVar2);\n          if (lVar7 == 0) {\n            uVar9 = 1;\n            sh_notfound(lVar2);\n          }\n          else {\n            iVar4 = executable_file(lVar7);\n            if (iVar4 == 0) {\n              uVar9 = 1;\n              sh_notfound(lVar2);\n              sh_xfree(lVar7,\"./hash.def\",0xe5);\n            }\n            else {\n              phash_insert(lVar2,lVar7,dot_found_in_search,0);\n              sh_xfree(lVar7,\"./hash.def\",0xe5);\n            }\n          }\n        }\n      }\n      else {\n        iVar4 = phash_remove();\n        if (iVar4 != 0) {\n          sh_notfound(lVar2);\n          uVar9 = uVar8;\n        }\n      }\n    }\n  }\n  fflush(stdout);\n  return uVar9;\n}\n\n",
  "queue_sigchld_trap": "\nvoid queue_sigchld_trap(int param_1)\n\n{\n  if (0 < param_1) {\n    pending_traps._68_4_ = pending_traps._68_4_ + param_1;\n    DAT_00247e28 = 1;\n    trapped_signal_received = 0x11;\n  }\n  return;\n}\n\n",
  "sh_noassign": "\nvoid sh_noassign(undefined8 param_1)\n\n{\n  internal_error(\"%s: cannot assign\",param_1);\n  return;\n}\n\n",
  "make_cond_node": "\nvoid make_cond_node(undefined4 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined4 uVar1;\n  undefined4 *puVar2;\n  \n  puVar2 = (undefined4 *)sh_xmalloc(0x28,\"make_cmd.c\",0x1cd);\n  uVar1 = line_number;\n  *puVar2 = 0;\n  puVar2[1] = uVar1;\n  puVar2[2] = param_1;\n  *(undefined8 *)(puVar2 + 4) = param_2;\n  *(undefined8 *)(puVar2 + 6) = param_3;\n  *(undefined8 *)(puVar2 + 8) = param_4;\n  return;\n}\n\n",
  "rl_insert": "\nulong rl_insert(int param_1)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  if (rl_insert_mode == 1) {\n    uVar3 = 0;\n    if (0 < param_1) {\n      uVar1 = FUN_001ee210();\n      uVar3 = (ulong)uVar1;\n    }\n  }\n  else {\n    uVar1 = _rl_overwrite_char();\n    uVar3 = (ulong)uVar1;\n  }\n  while( true ) {\n    if (_rl_optimize_typeahead == 0) {\n      return uVar3;\n    }\n    if (rl_num_chars_to_read != 0) {\n      return uVar3;\n    }\n    if ((rl_readline_state & 0x20800) != 0) {\n      return uVar3;\n    }\n    iVar2 = _rl_pushed_input_available();\n    if (iVar2 != 0) {\n      return uVar3;\n    }\n    iVar2 = _rl_input_queued(0);\n    if (iVar2 == 0) {\n      return uVar3;\n    }\n    uVar1 = rl_read_key();\n    if ((int)uVar1 < 1) break;\n    if ((_rl_keymap[(ulong)(uVar1 & 0xff) * 0x10] != '\\0') ||\n       (*(code **)(_rl_keymap + (ulong)(uVar1 & 0xff) * 0x10 + 8) != rl_insert)) {\n      if (uVar1 == 0xfffe) {\n        return uVar3;\n      }\n      break;\n    }\n    if (rl_insert_mode == 1) {\n      uVar1 = FUN_001ee210();\n    }\n    else {\n      uVar1 = _rl_overwrite_char();\n    }\n    if (uVar1 == 1) {\n      uVar3 = 1;\n    }\n    else {\n      uVar3 = (ulong)(uVar1 | rl_done);\n      if ((uVar1 | rl_done) != 0) {\n        return (ulong)uVar1;\n      }\n    }\n  }\n  rl_last_func = rl_insert;\n  _rl_reset_argument();\n  rl_key_sequence_length = 0;\n  *rl_executing_keyseq = 0;\n  uVar3 = rl_execute_next(uVar1);\n  return uVar3;\n}\n\n",
  "shift_builtin": "\nundefined8 shift_builtin(long param_1)\n\n{\n  char *__s1;\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((((param_1 != 0) && (*(char ***)(param_1 + 8) != (char **)0x0)) &&\n      (__s1 = **(char ***)(param_1 + 8), *__s1 == '-')) &&\n     (iVar1 = strcmp(__s1,\"--help\"), iVar1 == 0)) {\n    builtin_help();\n    uVar2 = 0x102;\n    goto LAB_001b3d88;\n  }\n  iVar1 = get_numeric_arg(param_1,0,&local_18);\n  if (iVar1 != 0) {\n    uVar2 = 0;\n    if (local_18 == 0) goto LAB_001b3d88;\n    if (-1 < local_18) {\n      iVar1 = number_of_args();\n      if (local_18 <= iVar1) {\n        if (iVar1 == local_18) {\n          clear_dollar_vars();\n        }\n        else {\n          shift_args();\n        }\n        invalidate_cached_quoted_dollar_at();\n        uVar2 = 0;\n        goto LAB_001b3d88;\n      }\n      if (print_shift_error == 0) goto LAB_001b3dcb;\n    }\n    if (param_1 != 0) {\n      param_1 = **(long **)(param_1 + 8);\n    }\n    sh_erange(param_1,\"shift count\");\n  }\nLAB_001b3dcb:\n  uVar2 = 1;\nLAB_001b3d88:\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
  "FUN_00151ea0": "\nundefined8 FUN_00151ea0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = legal_alias_name(param_4,0);\n  if (iVar1 != 0) {\n    add_alias(param_4,param_2);\n    uVar2 = FUN_001515d0(param_1);\n    return uVar2;\n  }\n  report_error(\"`%s\\': invalid alias name\",param_4);\n  return param_1;\n}\n\n",
  "expand_and_quote_assoc_word": "\nlong expand_and_quote_assoc_word(char *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  long lVar4;\n  char *pcVar5;\n  char *pcVar6;\n  char *pcVar7;\n  size_t sVar8;\n  undefined *puVar9;\n  int iVar10;\n  char *pcVar11;\n  long lVar12;\n  long local_48;\n  int local_3c;\n  \n  if (*param_1 != '[') {\nLAB_0018b3c2:\n    lVar4 = sh_single_quote(param_1);\n    return lVar4;\n  }\n  iVar2 = skipsubscript(param_1,0,0);\n  pcVar11 = param_1 + iVar2;\n  if (*pcVar11 != ']') goto LAB_0018b3c2;\n  *pcVar11 = '\\0';\n  pcVar5 = (char *)expand_subscript_string(param_1 + 1,0);\n  if (pcVar5 == (char *)0x0) {\n    pcVar6 = (char *)sh_single_quote(&DAT_00213d70);\n  }\n  else {\n    pcVar6 = strchr(pcVar5,1);\n    if (pcVar6 == (char *)0x0) {\n      pcVar6 = (char *)sh_single_quote(pcVar5);\n    }\n    else {\n      pcVar7 = (char *)quote_escapes();\n      if (pcVar7 == (char *)0x0) {\n        pcVar6 = (char *)sh_single_quote(&DAT_00213d70);\n      }\n      else {\n        pcVar6 = (char *)sh_single_quote(pcVar7);\n        if (pcVar5 == pcVar7) goto LAB_0018b44f;\n      }\n      sh_xfree(pcVar7,\"arrayfunc.c\",0x3fa);\n    }\n  }\nLAB_0018b44f:\n  *pcVar11 = ']';\n  sh_xfree(pcVar5,\"arrayfunc.c\",0x3fc);\n  if ((pcVar6 == (char *)0x0) || (*pcVar6 == '\\0')) {\n    local_3c = 0;\n    lVar4 = 2;\n    iVar10 = 2;\n    sVar8 = 0;\n    local_48 = 1;\n    lVar12 = 5;\n  }\n  else if (pcVar6[1] == '\\0') {\n    local_48 = 2;\n    lVar4 = 3;\n    iVar10 = 3;\n    sVar8 = 1;\n    local_3c = 1;\n    lVar12 = 6;\n  }\n  else if (pcVar6[2] == '\\0') {\n    local_48 = 3;\n    lVar4 = 4;\n    iVar10 = 4;\n    sVar8 = 2;\n    local_3c = 2;\n    lVar12 = 7;\n  }\n  else {\n    sVar8 = strlen(pcVar6);\n    local_3c = (int)sVar8;\n    sVar8 = (size_t)local_3c;\n    local_48 = (long)(local_3c + 1);\n    lVar12 = (long)(local_3c + 5);\n    iVar10 = local_3c + 2;\n    lVar4 = (long)iVar10;\n  }\n  puVar9 = (undefined *)sh_xmalloc(lVar12,\"arrayfunc.c\",0x3ff);\n  *puVar9 = 0x5b;\n  memcpy(puVar9 + 1,pcVar6,sVar8);\n  iVar3 = iVar2 + 1;\n  puVar9[local_48] = *pcVar11;\n  cVar1 = param_1[iVar3];\n  if (cVar1 == '+') {\n    puVar9[lVar4] = 0x2b;\n    iVar3 = iVar2 + 2;\n    iVar10 = local_3c + 3;\n    lVar4 = (long)iVar10;\n    cVar1 = param_1[iVar3];\n  }\n  puVar9[lVar4] = cVar1;\n  pcVar11 = (char *)expand_subscript_string(param_1 + (iVar3 + 1),0);\n  if (pcVar11 == (char *)0x0) {\n    pcVar5 = (char *)sh_single_quote(&DAT_00213d70);\n  }\n  else {\n    pcVar5 = strchr(pcVar11,1);\n    if (pcVar5 == (char *)0x0) {\n      pcVar5 = (char *)sh_single_quote(pcVar11);\n    }\n    else {\n      pcVar7 = (char *)quote_escapes();\n      if (pcVar7 == (char *)0x0) {\n        pcVar5 = (char *)sh_single_quote(&DAT_00213d70);\n      }\n      else {\n        pcVar5 = (char *)sh_single_quote(pcVar7);\n        if (pcVar11 == pcVar7) goto LAB_0018b5e9;\n      }\n      sh_xfree(pcVar7,\"arrayfunc.c\",0x40d);\n    }\n  }\nLAB_0018b5e9:\n  sh_xfree(pcVar11,\"arrayfunc.c\",0x40e);\n  if ((pcVar5 != (char *)0x0) && (*pcVar5 != '\\0')) {\n    if (pcVar5[1] == '\\0') {\n      lVar12 = lVar12 + 1;\n    }\n    else if (pcVar5[2] == '\\0') {\n      lVar12 = lVar12 + 2;\n    }\n    else {\n      sVar8 = strlen(pcVar5);\n      lVar12 = lVar12 + sVar8;\n    }\n  }\n  lVar4 = sh_xrealloc(puVar9,lVar12,\"arrayfunc.c\",0x40f);\n  strcpy((char *)((iVar10 + 1) + lVar4),pcVar5);\n  sh_xfree(pcVar6,\"arrayfunc.c\",0x412);\n  sh_xfree(pcVar5,\"arrayfunc.c\",0x413);\n  return lVar4;\n}\n\n",
  "mitos": "\nvoid mitos(undefined8 param_1)\n\n{\n  char *__s;\n  long in_FS_OFFSET;\n  undefined auStack_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  __s = (char *)fmtumax(param_1,10,auStack_28,0x16,0);\n  strdup(__s);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_getenv": "\nchar * _getenv(char *__name)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = getenv(__name);\n  return pcVar1;\n}\n\n",
  "strvec_create": "\nvoid strvec_create(int param_1)\n\n{\n  sh_xmalloc((long)param_1 << 3,\"stringvec.c\",0x28);\n  return;\n}\n\n",
  "get_tty_state": "\nundefined8 get_tty_state(void)\n\n{\n  int iVar1;\n  \n  iVar1 = shell_tty;\n  if ((shell_tty != -1) || (iVar1 = fileno(stderr), iVar1 != -1)) {\n    iVar1 = tcgetattr(iVar1,(termios *)&DAT_002475e0);\n    if (iVar1 < 0) {\n      return 0xffffffff;\n    }\n    if (check_window_size != 0) {\n      get_new_window_size(0,0,0);\n    }\n  }\n  return 0;\n}\n\n",
  "_rl_fix_last_undo_of_type": "\nundefined8 _rl_fix_last_undo_of_type(int param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  long *plVar1;\n  \n  plVar1 = rl_undo_list;\n  if (rl_undo_list != (long *)0x0) {\n    do {\n      if (*(int *)(plVar1 + 3) == param_1) {\n        *(undefined4 *)(plVar1 + 1) = param_2;\n        *(undefined4 *)((long)plVar1 + 0xc) = param_3;\n        return 0;\n      }\n      plVar1 = (long *)*plVar1;\n    } while (plVar1 != (long *)0x0);\n  }\n  return 1;\n}\n\n",
  "rl_save_prompt": "\nvoid rl_save_prompt(void)\n\n{\n  DAT_0024a858 = DAT_0024a8a0;\n  DAT_0024a850 = DAT_0024a898;\n  DAT_0024a838 = DAT_0024a894;\n  DAT_0024a83c = DAT_0024a890;\n  DAT_0024a840 = DAT_0024a88c;\n  DAT_0024a844 = DAT_0024a880;\n  DAT_0024a834 = DAT_0024a878;\n  DAT_0024a830 = DAT_0024a870;\n  DAT_0024a848 = DAT_0024a868;\n  DAT_0024a8a0 = 0;\n  DAT_0024a898 = 0;\n  DAT_0024a890 = 0;\n  DAT_0024a894 = 0;\n  DAT_0024a880 = 0;\n  DAT_0024a88c = 0;\n  DAT_0024a878 = 0;\n  DAT_0024a870 = 0;\n  DAT_0024a868 = 0;\n  return;\n}\n\n",
  "FUN_0015a300": "\nvoid FUN_0015a300(undefined8 param_1)\n\n{\n  FUN_0015a140(param_1,0);\n  return;\n}\n\n",
  "FUN_001952c0": "\nvoid FUN_001952c0(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined4 uVar4;\n  \n  uVar4 = rl_completion_mode(FUN_001952c0);\n  uVar3 = rl_completion_entry_function;\n  uVar2 = rl_attempted_completion_function;\n  uVar1 = rl_ignore_some_completions_function;\n  rl_attempted_completion_function = 0;\n  rl_completion_entry_function = rl_username_completion_function;\n  rl_complete_internal(uVar4);\n  rl_completion_entry_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar2;\n  rl_ignore_some_completions_function = uVar1;\n  return;\n}\n\n",
  "maybe_set_return_trap": "\nvoid maybe_set_return_trap(char *param_1)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  \n  if (((byte)DAT_00247f4c & 1) != 0) {\n    return;\n  }\n  sVar1 = strlen(param_1);\n  pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"trap.c\",0x31a);\n  pcVar2 = strcpy(pcVar2,param_1);\n  FUN_001815b0(0x43,pcVar2);\n  return;\n}\n\n",
  "FUN_001d4900": "\nundefined8 FUN_001d4900(int param_1,int param_2)\n\n{\n  char *__s2;\n  int iVar1;\n  undefined4 uVar2;\n  char **ppcVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  int local_34;\n  long local_30;\n  \n  ppcVar3 = (char **)0x0;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  rl_maybe_save_line();\n  if (param_1 != 0) {\n    do {\n      while( true ) {\n        if (_rl_caught_signal != 0) {\n          _rl_signal_handler(_rl_caught_signal);\n        }\n        iVar1 = FUN_001d44a0(DAT_0024a460,_rl_history_search_pos + param_2,param_2,0,&local_34);\n        if (iVar1 == -1) goto LAB_001d49f0;\n        _rl_history_search_pos = iVar1;\n        uVar2 = where_history();\n        history_set_pos(_rl_history_search_pos);\n        ppcVar3 = (char **)current_history();\n        history_set_pos(uVar2);\n        __s2 = *ppcVar3;\n        if ((DAT_0024a470 != (char *)0x0) && (*DAT_0024a470 == *__s2)) break;\n        param_1 = param_1 + -1;\n        DAT_0024a470 = __s2;\n        if (param_1 == 0) goto LAB_001d49f0;\n      }\n      iVar1 = strcmp(DAT_0024a470,__s2);\n    } while ((iVar1 == 0) || (param_1 = param_1 + -1, DAT_0024a470 = __s2, param_1 != 0));\nLAB_001d49f0:\n    if (ppcVar3 != (char **)0x0) {\n      FUN_001d4590(ppcVar3);\n      if ((DAT_0024a468 & 1) == 0) {\n        rl_point = local_34;\n        if (local_34 < 0) {\n          rl_point = rl_end;\n        }\n      }\n      else {\n        rl_point = DAT_0024a46c;\n      }\n      uVar4 = 0;\n      goto LAB_001d4a1e;\n    }\n  }\n  rl_maybe_unsave_line();\n  rl_ding();\n  rl_point = DAT_0024a46c;\n  uVar4 = 1;\nLAB_001d4a1e:\n  rl_mark = rl_end;\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n",
  "array_keys_to_word_list": "\nlong * array_keys_to_word_list(long param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  long *plVar3;\n  undefined8 *puVar4;\n  \n  if (((param_1 != 0) && (*(long *)(param_1 + 8) != 0)) &&\n     (puVar4 = (undefined8 *)(*(undefined8 **)(param_1 + 0x10))[2],\n     *(undefined8 **)(param_1 + 0x10) != puVar4)) {\n    plVar3 = (long *)0x0;\n    do {\n      uVar1 = itos(*puVar4);\n      uVar2 = make_bare_word(uVar1);\n      plVar3 = (long *)make_word_list(uVar2,plVar3);\n      sh_xfree(uVar1,\"array.c\",0x317);\n      puVar4 = (undefined8 *)puVar4[2];\n    } while (*(undefined8 **)(param_1 + 0x10) != puVar4);\n    if (plVar3 != (long *)0x0) {\n      if (*plVar3 == 0) {\n        return plVar3;\n      }\n      plVar3 = (long *)list_reverse(plVar3);\n      return plVar3;\n    }\n  }\n  return (long *)0x0;\n}\n\n",
  "expand_string_to_string": "\nundefined8 expand_string_to_string(char *param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    lVar1 = FUN_0017af90();\n    if (lVar1 != 0) {\n      uVar2 = string_list_internal(lVar1,&DAT_001fdb1c);\n      dispose_words(lVar1);\n      return uVar2;\n    }\n  }\n  return 0;\n}\n\n",
  "rl_set_screen_size": "\nvoid rl_set_screen_size(int param_1,int param_2)\n\n{\n  if (_rl_term_autowrap == -1) {\n    _rl_init_terminal_io(rl_terminal_name);\n  }\n  if (param_1 < 1) {\n    if (param_2 < 1) {\n      return;\n    }\n  }\n  else {\n    _rl_screenheight = param_1;\n    if (param_2 < 1) goto LAB_001ed8e5;\n  }\n  _rl_screenwidth = param_2;\n  if (_rl_term_autowrap == 0) {\n    _rl_screenwidth = param_2 + -1;\n  }\nLAB_001ed8e5:\n  _rl_screenchars = _rl_screenwidth * _rl_screenheight;\n  return;\n}\n\n",
  "FUN_001516e0": "\nlong FUN_001516e0(long param_1)\n\n{\n  undefined8 *puVar1;\n  long *plVar2;\n  long *plVar3;\n  size_t sVar4;\n  char *__dest;\n  char *pcVar5;\n  long lVar6;\n  \n  if (*(long *)(param_1 + 8) != 0) {\n    assoc_dispose();\n  }\n  plVar2 = hashed_filenames;\n  if (hashed_filenames != (long *)0x0) {\n    if (*(int *)((long)hashed_filenames + 0xc) == 0) {\n      plVar2 = (long *)0x0;\n    }\n    else {\n      plVar2 = (long *)hash_create(*(undefined4 *)(hashed_filenames + 1));\n      if (0 < *(int *)(hashed_filenames + 1)) {\n        lVar6 = 0;\n        plVar3 = hashed_filenames;\n        do {\n          puVar1 = *(undefined8 **)(*plVar3 + lVar6 * 8);\n          for (; puVar1 != (undefined8 *)0x0; puVar1 = (undefined8 *)*puVar1) {\n            pcVar5 = (char *)puVar1[1];\n            sVar4 = strlen(pcVar5);\n            __dest = (char *)sh_xmalloc(sVar4 + 1,\"variables.c\",0x6cf);\n            pcVar5 = strcpy(__dest,pcVar5);\n            assoc_insert(plVar2,pcVar5,*(undefined8 *)puVar1[2]);\n            plVar3 = hashed_filenames;\n          }\n          lVar6 = lVar6 + 1;\n        } while (*(int *)(plVar3 + 1) != (int)lVar6 && (int)lVar6 <= *(int *)(plVar3 + 1));\n      }\n    }\n  }\n  *(long **)(param_1 + 8) = plVar2;\n  return param_1;\n}\n\n",
  "rl_copy_backward_word": "\nvoid rl_copy_backward_word(ulong param_1)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  \n  uVar2 = rl_point;\n  uVar1 = rl_mark;\n  if (-1 < (int)param_1) {\n    rl_backward_word(param_1,0);\n    rl_mark = rl_point;\n    rl_forward_word(param_1 & 0xffffffff,0);\n    FUN_001e9520(0);\n    rl_mark = uVar1;\n    rl_point = uVar2;\n    return;\n  }\n  rl_copy_forward_word(-(int)param_1);\n  return;\n}\n\n",
  "FUN_001da6e0": "\nvoid FUN_001da6e0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_d0 = &stack0x00000008;\n  local_c8 = local_b8;\n  local_d8 = 8;\n  local_d4 = 0x30;\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  fwrite(\"readline: \",1,10,stderr);\n  if (DAT_0024a7b8 != 0) {\n    __fprintf_chk(stderr,1,\"%s: line %d: \",DAT_0024a7a8,DAT_0024a7a0);\n  }\n  __vfprintf_chk(stderr,1,param_9,&local_d8);\n  fputc(10,stderr);\n  fflush(stderr);\n  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00190570": "\nbool FUN_00190570(long param_1,int param_2)\n\n{\n  char *pcVar1;\n  char cVar2;\n  bool bVar3;\n  int iVar4;\n  long lVar5;\n  long lVar6;\n  long in_FS_OFFSET;\n  undefined local_32;\n  undefined local_31;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_32 = history_expansion_char;\n  local_31 = 0;\n  if (param_2 < 1) {\nLAB_001905ea:\n    iVar4 = 0;\n    if (history_quoting_state == 0x27) {\n      iVar4 = skip_to_delim(param_1,0,&DAT_001ff32d,0x201);\n      if ((*(char *)(param_1 + iVar4) == '\\0') || (param_2 <= iVar4)) goto LAB_00190688;\n      iVar4 = iVar4 + 1;\n    }\n    while (iVar4 = skip_to_histexp(param_1,iVar4,&local_32,0x201), 0 < iVar4) {\n      if (param_2 <= iVar4) {\n        bVar3 = param_2 < iVar4;\n        goto LAB_00190621;\n      }\n      iVar4 = iVar4 + 1;\n    }\n    bVar3 = false;\n  }\n  else {\n    lVar6 = (long)param_2;\n    pcVar1 = (char *)(param_1 + -1 + lVar6);\n    if ((*pcVar1 != '[') || (lVar5 = mbschr(param_1 + 1 + lVar6,0x5d), lVar5 == 0)) {\n      if (param_2 == 1) goto LAB_001905ea;\n      cVar2 = *pcVar1;\n      if (cVar2 == '{') {\n        if (*(char *)(param_1 + -2 + lVar6) == '$') {\n          lVar5 = mbschr(param_1 + 1 + lVar6,0x7d);\n          if (lVar5 != 0) goto LAB_00190688;\n          cVar2 = *pcVar1;\n          goto LAB_001905cc;\n        }\n      }\n      else {\nLAB_001905cc:\n        if ((cVar2 == '$') && (*(char *)(param_1 + lVar6) == '!')) goto LAB_00190688;\n      }\n      if ((extended_glob == 0) ||\n         ((*(char *)(param_1 + 1 + lVar6) != '(' ||\n          (lVar6 = mbschr(param_1 + 2 + lVar6,0x29), lVar6 == 0)))) goto LAB_001905ea;\n    }\nLAB_00190688:\n    bVar3 = true;\n  }\nLAB_00190621:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return bVar3;\n}\n\n",
  "rl_vi_arg_digit": "\nvoid rl_vi_arg_digit(undefined8 param_1,int param_2)\n\n{\n  if (((param_2 == 0x30) && (rl_numeric_arg == 1)) && (rl_explicit_arg == 0)) {\n    rl_beg_of_line(1);\n    return;\n  }\n  rl_digit_argument();\n  return;\n}\n\n",
  "__gmon_start__": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __gmon_start__(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n",
  "err_unboundvar": "\nvoid err_unboundvar(undefined8 param_1)\n\n{\n  report_error(\"%s: unbound variable\",param_1);\n  return;\n}\n\n",
  "FUN_0019e360": "\nundefined8 FUN_0019e360(uint *param_1)\n\n{\n  undefined8 uVar1;\n  long *plVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  undefined8 *puVar6;\n  ulong uVar7;\n  uint uVar8;\n  \n  plVar2 = (long *)strlist_create(num_shell_builtins);\n  uVar8 = num_shell_builtins;\n  if ((int)num_shell_builtins < 1) {\n    puVar6 = (undefined8 *)*plVar2;\n    uVar8 = 0;\n  }\n  else {\n    puVar6 = (undefined8 *)*plVar2;\n    uVar7 = (ulong)num_shell_builtins;\n    puVar3 = (undefined8 *)shell_builtins;\n    puVar4 = puVar6;\n    do {\n      uVar1 = *puVar3;\n      puVar5 = puVar4 + 1;\n      puVar3 = puVar3 + 6;\n      *puVar4 = uVar1;\n      puVar4 = puVar5;\n    } while (puVar5 != puVar6 + uVar7);\n    puVar6 = puVar6 + (int)uVar8;\n  }\n  *(uint *)((long)plVar2 + 0xc) = uVar8;\n  *puVar6 = 0;\n  *(long **)(param_1 + 4) = plVar2;\n  *param_1 = *param_1 | 0x20;\n  return 0;\n}\n\n",
  "FUN_001f2310": "\nchar * FUN_001f2310(long param_1,int param_2,int param_3,int param_4)\n\n{\n  int iVar1;\n  char *__dest;\n  long lVar2;\n  char *pcVar3;\n  size_t __n;\n  long lVar4;\n  char *__src;\n  \n  if (param_4 == 3) {\n    iVar1 = 0x1d;\n    __src = \"unrecognized history modifier\";\n  }\n  else {\n    iVar1 = 0x18;\n    __src = \"no previous substitution\";\n    if (param_4 != 4) {\n      iVar1 = 0x12;\n      __src = \"bad word specifier\";\n      if (param_4 != 1) {\n        __src = \"event not found\";\n        if (param_4 == 2) {\n          __src = \"substitution failed\";\n        }\n        iVar1 = (uint)(param_4 == 2) * 4 + 0xf;\n      }\n    }\n  }\n  __dest = (char *)xmalloc((long)(iVar1 + 3 + (param_3 - param_2)));\n  if (*(char *)(param_1 + param_2) == '\\0') {\n    lVar4 = 2;\n    lVar2 = 1;\n    pcVar3 = __dest;\n  }\n  else {\n    __n = (size_t)(param_3 - param_2);\n    strncpy(__dest,(char *)(param_1 + param_2),__n);\n    pcVar3 = __dest + __n;\n    lVar2 = __n + 1;\n    lVar4 = __n + 2;\n  }\n  *pcVar3 = ':';\n  __dest[lVar2] = ' ';\n  strcpy(__dest + lVar4,__src);\n  return __dest;\n}\n\n",
  "_rl_set_normal_color": "\nvoid _rl_set_normal_color(void)\n\n{\n  if (DAT_00240620 == 0) {\n    return;\n  }\n  if (DAT_00240620 == 1) {\n    if (*DAT_00240628 == '0') {\n      return;\n    }\n  }\n  else if (((DAT_00240620 == 2) && (*DAT_00240628 == '0')) && (DAT_00240628[1] == '0')) {\n    return;\n  }\n  fwrite(PTR_DAT_002405e8,_rl_color_indicator,1,rl_outstream);\n  fwrite(DAT_00240628,DAT_00240620,1,rl_outstream);\n  fwrite(PTR_DAT_002405f8,DAT_002405f0,1,rl_outstream);\n  return;\n}\n\n",
  "FUN_0015ede0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0015ede0(int param_1)\n\n{\n  uint uVar1;\n  long lVar2;\n  int iVar3;\n  long **pplVar4;\n  long **pplVar5;\n  ulong uVar6;\n  int iVar7;\n  uint uVar8;\n  long **pplVar9;\n  \n  pplVar9 = *(long ***)(*(long *)(jobs + (long)param_1 * 8) + 8);\n  pplVar5 = (long **)*pplVar9;\n  if (pplVar9 == pplVar5) {\n    iVar7 = 2;\n  }\n  else {\n    pplVar4 = pplVar5;\n    iVar3 = 1;\n    do {\n      iVar7 = iVar3;\n      pplVar4 = (long **)*pplVar4;\n      iVar3 = iVar7 + 1;\n    } while (pplVar4 != pplVar9);\n    iVar7 = iVar7 + 2;\n  }\n  if (_DAT_00247698 < iVar7) {\n    DAT_002476a0 = sh_xrealloc(DAT_002476a0,(long)iVar7 << 2,\"jobs.c\",0x1047);\n    pplVar9 = *(long ***)(*(long *)(jobs + (long)param_1 * 8) + 8);\n    pplVar5 = (long **)*pplVar9;\n    _DAT_00247698 = iVar7;\n  }\n  lVar2 = DAT_002476a0;\n  uVar6 = 1;\n  pplVar4 = pplVar9;\n  while( true ) {\n    uVar1 = *(uint *)((long)pplVar4 + 0xc);\n    if ((char)(((byte)uVar1 & 0x7f) + 1) < '\\x02') {\n      uVar8 = uVar1 >> 8 & 0xff;\n      if ((byte)uVar1 == 0x7f) {\n        uVar8 = 0;\n      }\n      *(uint *)(lVar2 + -4 + uVar6 * 4) = uVar8;\n    }\n    else {\n      *(uint *)(lVar2 + -4 + uVar6 * 4) = (uVar1 & 0x7f) + 0x80;\n    }\n    if (pplVar9 == pplVar5) break;\n    uVar6 = uVar6 + 1;\n    pplVar4 = pplVar5;\n    pplVar5 = (long **)*pplVar5;\n  }\n  *(undefined4 *)(lVar2 + (long)(int)(uVar6 & 0xffffffff) * 4) = 0xffffffff;\n  set_pipestatus_array(lVar2,uVar6 & 0xffffffff);\n  return;\n}\n\n",
  "internal_wstrmatch": "\nundefined8 internal_wstrmatch(wchar_t *param_1,wchar_t *param_2,undefined4 param_3)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  undefined8 uVar3;\n  \n  if (param_2 == (wchar_t *)0x0) {\n    return 1;\n  }\n  if (param_1 != (wchar_t *)0x0) {\n    sVar1 = wcslen(param_2);\n    sVar2 = wcslen(param_1);\n    uVar3 = FUN_001c1f10(param_2,param_2 + sVar1,param_1,param_1 + sVar2,0,param_3);\n    return uVar3;\n  }\n  return 1;\n}\n\n",
  "_rl_find_next_mbchar": "\nint _rl_find_next_mbchar(long param_1,int param_2,int param_3,int param_4)\n\n{\n  int iVar1;\n  size_t sVar2;\n  int iVar3;\n  int iVar4;\n  char *pcVar5;\n  long in_FS_OFFSET;\n  wchar_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  iVar4 = 0;\n  if (-1 < param_2) {\n    iVar4 = param_2;\n  }\n  if (0 < param_3) {\n    iVar1 = _rl_adjust_point(param_1,iVar4,&local_48);\n    iVar3 = iVar4 + iVar1;\n    if (iVar1 == -1) {\n      iVar4 = iVar4 + 1;\n    }\n    else {\n      if ((iVar3 <= iVar4) || (param_3 = param_3 + -1, iVar4 = iVar3, param_3 != 0)) {\n        iVar4 = iVar3;\nLAB_001f6db3:\n        do {\n          pcVar5 = (char *)(param_1 + iVar4);\n          sVar2 = strlen(pcVar5);\n          if (sVar2 == 0) break;\n          if ((_rl_utf8locale == 0) || (*pcVar5 < '\\0')) {\n            sVar2 = mbrtowc(&local_4c,pcVar5,sVar2,&local_48);\n            if (sVar2 < 0xfffffffffffffffe) {\n              if (sVar2 != 0) {\n                iVar4 = iVar4 + (int)sVar2;\n                goto joined_r0x001f6daa;\n              }\n              break;\n            }\n            local_48.__count = 0;\n            local_48.__value = (_union_27)0x0;\n            iVar4 = iVar4 + 1;\n          }\n          else {\n            local_48.__count = 0;\n            local_48.__value = (_union_27)0x0;\n            iVar4 = iVar4 + 1;\n            local_4c = (int)*pcVar5;\njoined_r0x001f6daa:\n            if (param_4 != 0) {\n              if (local_4c < L'`') {\n                if (local_4c < L'A') {\n                  if (local_4c < L'$') {\n                    if (local_4c < L' ') {\nLAB_001f6e19:\n                      iVar1 = wcwidth(local_4c);\n                      if (iVar1 == 0) goto LAB_001f6db3;\n                    }\n                  }\n                  else if (0x1a < (uint)(local_4c + L'\\xffffffdb')) goto LAB_001f6e19;\n                }\n              }\n              else if (0x1d < (uint)(local_4c + L'\\xffffff9f')) goto LAB_001f6e19;\n            }\n          }\n          param_3 = param_3 + -1;\n        } while (param_3 != 0);\n      }\n      if (param_4 != 0) {\n        pcVar5 = (char *)(iVar4 + param_1);\n        sVar2 = strlen(pcVar5);\n        while (sVar2 = mbrtowc(&local_4c,pcVar5,sVar2,&local_48), sVar2 - 1 < 0xfffffffffffffffd) {\n          if (local_4c < L'`') {\n            if (L'@' < local_4c) break;\n            if (local_4c < L'$') {\n              if (L'\\x1f' < local_4c) break;\n            }\n            else if ((uint)(local_4c + L'\\xffffffdb') < 0x1b) break;\n          }\n          else if ((uint)(local_4c + L'\\xffffff9f') < 0x1e) break;\n          iVar1 = wcwidth(local_4c);\n          if (iVar1 != 0) break;\n          iVar4 = iVar4 + (int)sVar2;\n          pcVar5 = (char *)(iVar4 + param_1);\n          sVar2 = strlen(pcVar5);\n        }\n      }\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "initialize_aliases": "\nvoid initialize_aliases(void)\n\n{\n  if (aliases != 0) {\n    return;\n  }\n  aliases = hash_create(0x40);\n  return;\n}\n\n",
  "FUN_001b1aa0": "\nbool FUN_001b1aa0(char *param_1)\n\n{\n  bool bVar1;\n  \n  if (*param_1 == 'e') {\n    bVar1 = false;\n    if (no_line_editing == 0) {\n      return rl_editing_mode == 1;\n    }\n  }\n  else {\n    bVar1 = (no_line_editing | rl_editing_mode) == 0;\n  }\n  return bVar1;\n}\n\n",
  "set_error_trap": "\nvoid set_error_trap(char *param_1)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  \n  sVar1 = strlen(param_1);\n  pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"trap.c\",0x31a);\n  pcVar2 = strcpy(pcVar2,param_1);\n  FUN_001815b0(0x42,pcVar2);\n  return;\n}\n\n",
  "tt_seteightbit": "\nundefined8 tt_seteightbit(uint *param_1)\n\n{\n  *param_1 = *param_1 & 0xffffffdf;\n  param_1[2] = param_1[2] & 0xfffffeff | 0x30;\n  return 0;\n}\n\n",
  "FUN_001e0330": "\nundefined8 FUN_001e0330(int param_1)\n\n{\n  long *plVar1;\n  char *pcVar2;\n  int iVar3;\n  long lVar4;\n  undefined *puVar5;\n  long *plVar6;\n  size_t sVar7;\n  undefined8 uVar8;\n  char *__dest;\n  long lVar9;\n  long lVar10;\n  \n  rl_readline_state = rl_readline_state | 0x80;\n  lVar4 = _rl_scxt_alloc(1,0);\n  if (param_1 < 0) {\n    *(uint *)(lVar4 + 4) = *(uint *)(lVar4 + 4) | 1;\n  }\n  puVar5 = _rl_isearch_terminators;\n  if (_rl_isearch_terminators == (undefined *)0x0) {\n    puVar5 = &DAT_00213c6c;\n  }\n  *(undefined **)(lVar4 + 0xa0) = puVar5;\n  plVar6 = (long *)history_list();\n  rl_maybe_replace_line();\n  if ((plVar6 == (long *)0x0) || (*plVar6 == 0)) {\n    lVar10 = 8;\n    iVar3 = 0;\n  }\n  else {\n    lVar10 = 1;\n    do {\n      iVar3 = (int)lVar10;\n      plVar1 = plVar6 + lVar10;\n      lVar10 = lVar10 + 1;\n    } while (*plVar1 != 0);\n    lVar10 = (long)(iVar3 + 1) << 3;\n  }\n  *(int *)(lVar4 + 0x28) = iVar3;\n  lVar10 = xmalloc(lVar10);\n  iVar3 = *(int *)(lVar4 + 0x28);\n  *(long *)(lVar4 + 0x18) = lVar10;\n  if (iVar3 < 1) {\n    lVar9 = 0;\n  }\n  else {\n    lVar9 = 0;\n    do {\n      *(undefined8 *)(lVar10 + lVar9 * 8) = *(undefined8 *)plVar6[lVar9];\n      lVar9 = lVar9 + 1;\n    } while (iVar3 != lVar9);\n    lVar9 = (long)iVar3 * 8;\n  }\n  if (_rl_saved_line_for_history == (undefined8 *)0x0) {\n    sVar7 = strlen(rl_line_buffer);\n    __dest = (char *)xmalloc(sVar7 + 1);\n    pcVar2 = rl_line_buffer;\n    *(char **)(lVar4 + 0x20) = __dest;\n    strcpy(__dest,pcVar2);\n    iVar3 = *(int *)(lVar4 + 0x28);\n    *(undefined8 *)(*(long *)(lVar4 + 0x18) + lVar9) = *(undefined8 *)(lVar4 + 0x20);\n  }\n  else {\n    *(undefined8 *)(lVar10 + lVar9) = *_rl_saved_line_for_history;\n  }\n  *(int *)(lVar4 + 0x28) = iVar3 + 1;\n  *(undefined4 *)(lVar4 + 0x60) = *(undefined4 *)(lVar4 + 0x38);\n  rl_save_prompt();\n  *(undefined4 *)(lVar4 + 0x14) = 0x80;\n  puVar5 = (undefined *)xmalloc(0x80);\n  *(undefined4 *)(lVar4 + 0x10) = 0;\n  *(undefined **)(lVar4 + 8) = puVar5;\n  *puVar5 = 0;\n  pcVar2 = rl_line_buffer;\n  *(uint *)(lVar4 + 100) = param_1 >> 0x1f | 1;\n  *(char **)(lVar4 + 0x90) = pcVar2;\n  sVar7 = strlen(pcVar2);\n  _rl_iscxt = lVar4;\n  *(int *)(lVar4 + 0x98) = (int)sVar7;\n  *(undefined4 *)(lVar4 + 0x9c) = rl_point;\n  _rl_init_executing_keyseq();\n  FUN_001df030(*(undefined8 *)(lVar4 + 8),*(undefined4 *)(lVar4 + 4));\n  if ((rl_readline_state & 0x80000) == 0) {\n    do {\n      _rl_search_getchar(lVar4);\n      if (*(int *)(lVar4 + 0x6c) < 0) {\n        *(uint *)(lVar4 + 4) = *(uint *)(lVar4 + 4) | 4;\n        *(undefined4 *)(lVar4 + 0x60) = *(undefined4 *)(lVar4 + 0x3c);\n        uVar8 = _rl_isearch_cleanup(lVar4,0xffffffff);\n        return uVar8;\n      }\n      iVar3 = FUN_001df160(lVar4);\n    } while (0 < iVar3);\n    uVar8 = _rl_isearch_cleanup(lVar4,iVar3);\n    return uVar8;\n  }\n  return 0;\n}\n\n",
  "find_string_in_alist": "\nundefined4 find_string_in_alist(char *param_1,char **param_2,int param_3)\n\n{\n  int iVar1;\n  char *__s2;\n  \n  __s2 = *param_2;\n  do {\n    if (__s2 == (char *)0x0) {\n      return 0xffffffff;\n    }\n    while (param_3 == 0) {\n      if (*param_1 != *__s2) goto LAB_00199bc8;\n      iVar1 = strcmp(param_1,__s2);\n      if (iVar1 == 0) goto LAB_00199bec;\n      __s2 = param_2[2];\n      param_2 = param_2 + 2;\n      if (__s2 == (char *)0x0) {\n        return 0xffffffff;\n      }\n    }\n    iVar1 = strmatch(__s2,param_1,0x20);\n    if (iVar1 != 1) {\nLAB_00199bec:\n      return *(undefined4 *)(param_2 + 1);\n    }\nLAB_00199bc8:\n    __s2 = param_2[2];\n    param_2 = param_2 + 2;\n  } while( true );\n}\n\n",
  "__libc_current_sigrtmax": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __libc_current_sigrtmax(void)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___libc_current_sigrtmax_00237e28)();\n  return iVar1;\n}\n\n",
  "add_history_time": "\nvoid add_history_time(char *param_1)\n\n{\n  long lVar1;\n  void *__ptr;\n  size_t sVar2;\n  char *pcVar3;\n  \n  if ((param_1 != (char *)0x0) && (0 < history_length)) {\n    lVar1 = *(long *)(DAT_0024b6e8 + -8 + (long)history_length * 8);\n    __ptr = *(void **)(lVar1 + 8);\n    if (__ptr != (void *)0x0) {\n      free(__ptr);\n    }\n    sVar2 = strlen(param_1);\n    pcVar3 = (char *)xmalloc(sVar2 + 1);\n    pcVar3 = strcpy(pcVar3,param_1);\n    *(char **)(lVar1 + 8) = pcVar3;\n    return;\n  }\n  return;\n}\n\n",
  "wctob": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wctob(wint_t __c)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wctob_00237d90)();\n  return iVar1;\n}\n\n",
  "convert_var_to_array": "\nlong convert_var_to_array(long param_1)\n\n{\n  uint uVar1;\n  long lVar2;\n  uint uVar3;\n  undefined8 uVar4;\n  \n  lVar2 = *(long *)(param_1 + 8);\n  uVar4 = array_create();\n  if (lVar2 != 0) {\n    array_insert(uVar4,0,lVar2);\n  }\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"arrayfunc.c\",0x58);\n  }\n  *(undefined8 *)(param_1 + 8) = uVar4;\n  *(undefined8 *)(param_1 + 0x18) = 0;\n  *(undefined8 *)(param_1 + 0x20) = 0;\n  if (*(long *)(param_1 + 0x10) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x10),\"arrayfunc.c\",0x5f);\n    *(undefined8 *)(param_1 + 0x10) = 0;\n  }\n  uVar1 = *(uint *)(param_1 + 0x28);\n  if ((uVar1 & 1) != 0) {\n    array_needs_making = array_needs_making + 1;\n  }\n  uVar3 = uVar1 & 0xffffefff;\n  if (lVar2 == 0) {\n    uVar3 = uVar1;\n  }\n  *(uint *)(param_1 + 0x28) = uVar3 & 0xfffff7bf | 4;\n  return param_1;\n}\n\n",
  "list_minus_o_opts": "\nvoid list_minus_o_opts(int param_1,int param_2)\n\n{\n  int *piVar1;\n  char *pcVar2;\n  int iVar3;\n  int **ppiVar4;\n  char *pcVar5;\n  \n  pcVar5 = \"allexport\";\n  iVar3 = 0x61;\n  ppiVar4 = (int **)&DAT_00235fd0;\n  do {\n    if (iVar3 == 0) {\n      if (ppiVar4[2] == (int *)0x0) {\n        iVar3 = **ppiVar4;\n      }\n      else {\n        iVar3 = (*(code *)ppiVar4[2])(pcVar5);\n      }\n      if ((iVar3 != param_1) && (param_1 != -1)) goto LAB_001b1bfb;\nLAB_001b1c30:\n      if (param_2 != 0) {\n        iVar3 = (-(uint)(iVar3 == 0) & 0xfffffffe) + 0x2d;\nLAB_001b1c8b:\n        __printf_chk(1,\"set %co %s\\n\",iVar3,pcVar5);\n        goto LAB_001b1bfb;\n      }\n      pcVar2 = \"off\";\n      if (iVar3 != 0) {\n        pcVar2 = \"on\";\n      }\nLAB_001b1c48:\n      __printf_chk(1,\"%-15s\\t%s\\n\",pcVar5,pcVar2);\n      pcVar5 = (char *)ppiVar4[3];\n    }\n    else {\n      piVar1 = (int *)find_flag();\n      if (piVar1 == (int *)0x0) {\n        if ((param_1 == -1) || (param_1 == 0)) {\n          iVar3 = 0x2b;\n          if (param_2 != 0) goto LAB_001b1c8b;\n          pcVar2 = \"off\";\n          goto LAB_001b1c48;\n        }\n      }\n      else {\n        iVar3 = *piVar1;\n        if ((param_1 == -1) || (param_1 == iVar3)) goto LAB_001b1c30;\n      }\nLAB_001b1bfb:\n      pcVar5 = (char *)ppiVar4[3];\n    }\n    if ((int *)pcVar5 == (int *)0x0) {\n      return;\n    }\n    iVar3 = *(int *)(ppiVar4 + 4);\n    ppiVar4 = ppiVar4 + 5;\n  } while( true );\n}\n\n",
  "put_command_name_into_env": "\nvoid put_command_name_into_env(undefined8 param_1)\n\n{\n  update_export_env_inplace(&DAT_001fcee8,2,param_1);\n  return;\n}\n\n",
  "set_current_options": "\nvoid set_current_options(long param_1)\n\n{\n  uint uVar1;\n  int *piVar2;\n  uint **ppuVar3;\n  int iVar4;\n  int iVar5;\n  long lVar6;\n  char *pcVar7;\n  \n  if (param_1 != 0) {\n    iVar5 = 0x61;\n    pcVar7 = \"allexport\";\n    lVar6 = 1;\n    ppuVar3 = (uint **)&DAT_00235fd0;\n    while( true ) {\n      iVar4 = (-(uint)(*(char *)(param_1 + -1 + lVar6) == '\\0') & 0xfffffffe) + 0x2d;\n      if (iVar5 == 0) {\n        if (ppuVar3[2] == (uint *)0x0) {\n          uVar1 = **ppuVar3;\n        }\n        else {\n          uVar1 = (*(code *)ppuVar3[2])(pcVar7);\n        }\n        if (iVar4 != (-(uint)(uVar1 == 0) & 0xfffffffe) + 0x2d) {\n          if (ppuVar3[1] == (uint *)0x0) {\n            **ppuVar3 = (uint)(iVar4 == 0x2d);\n          }\n          else {\n            (*(code *)ppuVar3[1])(iVar4,pcVar7);\n          }\n        }\n      }\n      else {\n        piVar2 = (int *)find_flag(iVar5);\n        if (iVar4 != (-(uint)(*piVar2 == 0) & 0xfffffffe) + 0x2d) {\n          change_flag(iVar5,iVar4);\n        }\n      }\n      pcVar7 = (char *)ppuVar3[3];\n      iVar5 = (int)lVar6;\n      lVar6 = lVar6 + 1;\n      if ((uint *)pcVar7 == (uint *)0x0) break;\n      iVar5 = *(int *)(ppuVar3 + 4);\n      ppuVar3 = ppuVar3 + 5;\n    }\n    set_posix_options(param_1 + iVar5);\n    return;\n  }\n  return;\n}\n\n",
  "mbsinit": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_mbsinit_00237e48)();\n  return iVar1;\n}\n\n",
  "rl_get_keymap": "\nundefined * rl_get_keymap(void)\n\n{\n  return _rl_keymap;\n}\n\n",
  "sv_xtracefd": "\nvoid sv_xtracefd(undefined8 param_1)\n\n{\n  char *__nptr;\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  FILE *pFVar4;\n  long in_FS_OFFSET;\n  char *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = find_variable();\n  if (((lVar2 == 0) || (__nptr = *(char **)(lVar2 + 8), __nptr == (char *)0x0)) || (*__nptr == '\\0')\n     ) {\n    if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n      xtrace_reset();\n      return;\n    }\n    goto LAB_00153b9c;\n  }\n  uVar3 = strtol(__nptr,&local_28,10);\n  if ((local_28 == __nptr) || (*local_28 != '\\0')) {\nLAB_00153b3e:\n    internal_error(\"%s: %s: invalid value for trace file descriptor\",param_1,\n                   *(undefined8 *)(lVar2 + 8));\n  }\n  else {\n    iVar1 = sh_validfd(uVar3 & 0xffffffff);\n    if (iVar1 == 0) goto LAB_00153b3e;\n    pFVar4 = fdopen((int)(uVar3 & 0xffffffff),\"w\");\n    if (pFVar4 == (FILE *)0x0) {\n      internal_error(\"%s: %s: cannot open as FILE\",param_1,*(undefined8 *)(lVar2 + 8));\n    }\n    else {\n      xtrace_set(uVar3 & 0xffffffff,pFVar4);\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\nLAB_00153b9c:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "unset_builtin": "\nuint unset_builtin(undefined8 param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  char **ppcVar6;\n  long lVar7;\n  size_t sVar8;\n  char *pcVar9;\n  char *pcVar10;\n  char *pcVar11;\n  uint uVar12;\n  undefined8 *puVar13;\n  undefined8 uVar14;\n  byte bVar15;\n  uint uVar16;\n  int unaff_R13D;\n  uint uVar17;\n  uint uVar18;\n  uint uVar19;\n  long in_FS_OFFSET;\n  bool bVar20;\n  int local_70;\n  int local_4c;\n  long local_48;\n  long local_40;\n  \n  uVar19 = 0;\n  uVar17 = 0;\n  uVar12 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  reset_internal_getopt();\n  while (iVar2 = internal_getopt(param_1,&DAT_00210496), iVar2 != -1) {\n    if (iVar2 == 0x6e) {\n      uVar19 = 1;\n    }\n    else if (iVar2 < 0x6f) {\n      if (iVar2 == -99) {\n        builtin_help();\n        uVar16 = 0x102;\n        goto LAB_001b27f1;\n      }\n      if (iVar2 != 0x66) {\nLAB_001b2830:\n        builtin_usage();\n        uVar16 = 0x102;\n        goto LAB_001b27f1;\n      }\n      uVar12 = 1;\n    }\n    else {\n      if (iVar2 != 0x76) goto LAB_001b2830;\n      uVar17 = 1;\n    }\n  }\n  uVar16 = uVar12 & uVar17;\n  if (uVar16 == 0) {\n    bVar20 = assoc_expand_once != 0;\n    if (loptend != (undefined8 *)0x0) {\n      bVar1 = (byte)uVar19 ^ 1;\n      local_70 = 0;\n      puVar13 = loptend;\n      do {\n        pcVar11 = *(char **)puVar13[1];\n        uVar3 = builtin_arrayref_flags((char **)puVar13[1],bVar20);\n        uVar16 = uVar17;\n        if ((uVar19 | uVar12) == 0) {\n          iVar2 = tokenize_array_reference(pcVar11,uVar3,&local_48);\n          uVar4 = (uint)(iVar2 != 0);\n          uVar5 = legal_identifier(pcVar11);\n          uVar18 = uVar12 | uVar17 | uVar5;\n          if (uVar18 == 0) {\nLAB_001b2a08:\n            ppcVar6 = (char **)find_function(pcVar11);\n            bVar15 = ppcVar6 == (char **)0x0 & bVar1;\n            if (bVar15 == 0) goto LAB_001b2cb8;\nLAB_001b2a25:\n            unaff_R13D = unbind_func(pcVar11);\n            uVar4 = 1;\nLAB_001b298a:\n            if ((unaff_R13D == -1) && (bVar15 != 0)) {\n              if ((uVar18 | uVar4) == 0) {\nLAB_001b2aed:\n                unaff_R13D = unbind_func(pcVar11);\n                uVar14 = *(undefined8 *)puVar13[1];\n                goto LAB_001b2afe;\n              }\n              unaff_R13D = -1;\n            }\n            if (uVar4 == 0) {\nLAB_001b2bf8:\n              uVar14 = *(undefined8 *)puVar13[1];\n              goto LAB_001b2afe;\n            }\n            goto LAB_001b29ab;\n          }\n          if ((uVar5 | uVar12) != 0) {\nLAB_001b2a4f:\n            ppcVar6 = (char **)find_variable(pcVar11);\n            if (ppcVar6 == (char **)0x0) {\n              if (uVar17 == 0) {\n                ppcVar6 = (char **)find_function(pcVar11);\n                if (ppcVar6 != (char **)0x0) {\n                  if ((*(uint *)(ppcVar6 + 5) & 2) == 0) {\n                    if (uVar4 != 0) {\n                      bVar15 = 1;\n                      uVar18 = 0;\n                      goto LAB_001b293d;\n                    }\n                    bVar15 = 1;\n                    uVar18 = 0;\n                    goto LAB_001b2a25;\n                  }\n                  goto LAB_001b2cd1;\n                }\n                uVar16 = 0;\n              }\n              lVar7 = find_variable_last_nameref(pcVar11,0);\n              if ((lVar7 == 0) || ((*(byte *)(lVar7 + 0x29) & 8) == 0)) {\n                unaff_R13D = unbind_variable(pcVar11);\n                bVar15 = 1;\n              }\n              else {\n                iVar2 = valid_array_reference(*(undefined8 *)(lVar7 + 8),0);\n                if (iVar2 == 0) {\n                  unaff_R13D = unbind_variable(*(undefined8 *)(lVar7 + 8));\n                  bVar15 = 1;\n                }\n                else {\n                  pcVar10 = *(char **)(lVar7 + 8);\n                  sVar8 = strlen(pcVar10);\n                  pcVar9 = (char *)sh_xmalloc(sVar8 + 1,\"./set.def\",0x3dd);\n                  pcVar10 = strcpy(pcVar9,pcVar10);\n                  lVar7 = array_variable_part(pcVar10,0,&local_48,&local_4c);\n                  if (lVar7 != 0) {\n                    pcVar9 = (char *)(local_48 + -1 + (long)local_4c);\n                    if (*pcVar9 == ']') {\n                      *pcVar9 = '\\0';\n                    }\n                    unaff_R13D = unbind_array_element(lVar7,local_48,uVar3);\n                  }\n                  sh_xfree(pcVar10,\"./set.def\",0x3e5);\n                  bVar15 = 1;\n                }\n              }\n              goto LAB_001b2ad2;\n            }\n            uVar18 = *(uint *)(ppcVar6 + 5);\n            if ((uVar18 & 0x2000) != 0) {\nLAB_001b2c08:\n              builtin_error(\"%s: cannot unset\",pcVar11);\n              local_70 = local_70 + 1;\n              puVar13 = (undefined8 *)*puVar13;\n              goto LAB_001b29af;\n            }\n            pcVar9 = *ppcVar6;\n            pcVar10 = pcVar9;\n            if ((*pcVar11 == *pcVar9) &&\n               (iVar2 = strcmp(pcVar11,pcVar9), pcVar10 = pcVar11, iVar2 != 0)) {\n              pcVar10 = pcVar9;\n            }\nLAB_001b291d:\n            if ((uVar18 & 2) != 0) {\n              pcVar11 = \"variable\";\n              goto LAB_001b2c37;\n            }\n            pcVar11 = pcVar10;\n            if (uVar4 == 0) {\n              bVar15 = bVar1;\n              if (uVar19 != 0) goto LAB_001b2bb0;\n              unaff_R13D = unbind_variable(pcVar10);\n              goto LAB_001b2ad2;\n            }\n            uVar4 = 0;\n            uVar18 = uVar17;\n            bVar15 = bVar1;\nLAB_001b293d:\n            if (shell_compatibility_level < 0x34) {\n              uVar3 = uVar3 | 4;\n            }\n            unaff_R13D = unbind_array_element(ppcVar6,local_48,uVar3);\n            if (unaff_R13D == -2) {\n              if ((*(byte *)(ppcVar6 + 5) & 0x44) == 0) {\n                local_70 = local_70 + 1;\n                builtin_error(\"%s: not an array variable\",*ppcVar6);\n                puVar13 = (undefined8 *)*puVar13;\n                goto LAB_001b29af;\n              }\n            }\n            else if (-1 < unaff_R13D) goto LAB_001b298a;\n            local_70 = local_70 + 1;\n            goto LAB_001b298a;\n          }\nLAB_001b2a98:\n          sh_invalidid(pcVar11);\n          local_70 = local_70 + 1;\n          puVar13 = (undefined8 *)*puVar13;\n        }\n        else {\n          uVar18 = legal_identifier(pcVar11);\n          if ((uVar12 | uVar17 | uVar18) == 0) {\n            ppcVar6 = (char **)find_function(pcVar11);\n            uVar18 = 0;\nLAB_001b2cb8:\n            bVar15 = bVar1;\n            if ((ppcVar6 != (char **)0x0) && ((*(byte *)(ppcVar6 + 5) & 2) != 0)) {\nLAB_001b2cd1:\n              pcVar11 = \"function\";\nLAB_001b2c37:\n              builtin_error(\"%s: cannot unset: readonly %s\",*ppcVar6,pcVar11);\n              local_70 = local_70 + 1;\n              puVar13 = (undefined8 *)*puVar13;\n              goto LAB_001b29af;\n            }\n            goto LAB_001b2a25;\n          }\n          if ((uVar18 | uVar12) == 0) goto LAB_001b2a98;\n          uVar18 = uVar17;\n          if (uVar12 != 0) goto LAB_001b2a08;\n          if (uVar19 == 0) {\n            uVar4 = 0;\n            goto LAB_001b2a4f;\n          }\n          ppcVar6 = (char **)find_variable_last_nameref(pcVar11,0);\n          if (ppcVar6 != (char **)0x0) {\n            uVar18 = *(uint *)(ppcVar6 + 5);\n            uVar4 = uVar18 & 0x2000;\n            pcVar10 = pcVar11;\n            if ((uVar18 & 0x2000) != 0) goto LAB_001b2c08;\n            goto LAB_001b291d;\n          }\n          bVar15 = 0;\nLAB_001b2bb0:\n          unaff_R13D = unbind_nameref(pcVar11);\nLAB_001b2ad2:\n          if ((unaff_R13D != -1) || (bVar15 == 0)) goto LAB_001b2bf8;\n          if (uVar16 == 0) goto LAB_001b2aed;\n          unaff_R13D = -1;\n          uVar14 = *(undefined8 *)puVar13[1];\nLAB_001b2afe:\n          stupidly_hack_special_variables(uVar14);\nLAB_001b29ab:\n          puVar13 = (undefined8 *)*puVar13;\n        }\nLAB_001b29af:\n      } while (puVar13 != (undefined8 *)0x0);\n      uVar16 = (uint)(local_70 != 0);\n    }\n  }\n  else {\n    builtin_error(\"cannot simultaneously unset a function and a variable\");\n  }\nLAB_001b27f1:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar16;\n}\n\n",
  "rl_transpose_words": "\nint rl_transpose_words(int param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  int iVar7;\n  int iVar8;\n  \n  iVar2 = rl_point;\n  uVar1 = rl_end;\n  rl_point = iVar2;\n  if (param_1 != 0) {\n    if (param_1 < 0) {\n      FUN_001edaf0(-param_1);\n      iVar7 = rl_point;\n      FUN_001edaf0(1);\n      iVar8 = rl_point;\n      FUN_001edc60(-param_1);\n    }\n    else {\n      FUN_001edc60();\n      iVar7 = rl_point;\n      FUN_001edaf0(1);\n      iVar8 = rl_point;\n      FUN_001edaf0(param_1);\n    }\n    iVar3 = rl_point;\n    FUN_001edc60(1);\n    iVar4 = rl_point;\n    if ((iVar3 == iVar8) || (iVar8 < rl_point)) {\n      rl_ding();\n      param_1 = 1;\n      rl_point = iVar2;\n    }\n    else {\n      uVar5 = rl_copy_text(iVar3,rl_point);\n      uVar6 = rl_copy_text(iVar8,iVar7);\n      rl_begin_undo_group();\n      rl_point = iVar8;\n      rl_delete_text(iVar8,iVar7);\n      rl_insert_text(uVar5);\n      param_1 = 0;\n      rl_point = iVar3;\n      rl_delete_text(iVar3,iVar4);\n      rl_insert_text(uVar6);\n      rl_end = uVar1;\n      rl_point = iVar7;\n      rl_end_undo_group();\n      xfree(uVar5);\n      xfree(uVar6);\n    }\n  }\n  return param_1;\n}\n\n",
  "rl_copy_keymap": "\nvoid rl_copy_keymap(long param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  long lVar4;\n  \n  puVar1 = (undefined *)xmalloc(0x1010);\n  puVar2 = puVar1;\n  do {\n    *puVar2 = 0;\n    puVar3 = puVar2 + 0x10;\n    *(undefined8 *)(puVar2 + 8) = 0;\n    puVar2 = puVar3;\n  } while (puVar1 + 0x1010 != puVar3);\n  lVar4 = 0;\n  do {\n    puVar1[lVar4] = *(undefined *)(param_1 + lVar4);\n    *(undefined8 *)(puVar1 + lVar4 + 8) = *(undefined8 *)(param_1 + 8 + lVar4);\n    lVar4 = lVar4 + 0x10;\n  } while (lVar4 != 0x1010);\n  return;\n}\n\n",
  "sleep": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuint sleep(uint __seconds)\n\n{\n  uint uVar1;\n  \n  uVar1 = (*(code *)PTR_sleep_00237e70)();\n  return uVar1;\n}\n\n",
  "FUN_001b6e60": "\nundefined8 FUN_001b6e60(void)\n\n{\n  if (DAT_0023a6b8 != -1) {\n    restricted_shell = DAT_0023a6b8;\n    return 0;\n  }\n  DAT_0023a6b8 = shell_is_restricted(shell_name);\n  restricted_shell = DAT_0023a6b8;\n  return 0;\n}\n\n",
  "copy_word": "\nvoid copy_word(undefined8 *param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = make_bare_word(*param_1);\n  *(undefined4 *)(lVar1 + 8) = *(undefined4 *)(param_1 + 1);\n  return;\n}\n\n",
  "FUN_001d5ec0": "\nchar * FUN_001d5ec0(char *param_1,undefined4 param_2,char *param_3)\n\n{\n  char *pcVar1;\n  \n  if ((((param_1 != (char *)0x0) && (rl_completer_quote_characters != (char *)0x0)) &&\n      (rl_filename_completion_desired != 0)) && (rl_filename_quoting_desired != 0)) {\n    if ((*param_3 != '\\0') &&\n       (pcVar1 = strchr(rl_completer_quote_characters,(int)*param_3), pcVar1 == (char *)0x0)) {\n      return param_1;\n    }\n    if (((rl_filename_quote_characters != (char *)0x0) &&\n        (pcVar1 = strpbrk(param_1,rl_filename_quote_characters), pcVar1 != (char *)0x0)) &&\n       (rl_filename_quoting_function != (undefined *)0x0)) {\n                    /* WARNING: Could not recover jumptable at 0x001d5f4c. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      pcVar1 = (char *)(*(code *)rl_filename_quoting_function)(param_1,param_2,param_3);\n      return pcVar1;\n    }\n  }\n  return param_1;\n}\n\n",
  "rl_overwrite_mode": "\nundefined8 rl_overwrite_mode(int param_1)\n\n{\n  if (rl_explicit_arg == 0) {\n    rl_insert_mode = rl_insert_mode ^ 1;\n    return 0;\n  }\n  rl_insert_mode = (uint)(param_1 < 1);\n  return 0;\n}\n\n",
  "_rl_get_screen_size": "\nvoid _rl_get_screen_size(int param_1,int param_2)\n\n{\n  int iVar1;\n  char *pcVar2;\n  long lVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  long in_FS_OFFSET;\n  ushort local_38;\n  ushort local_36;\n  long local_30;\n  uint uVar7;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = ioctl(param_1,0x5413,&local_38);\n  if (iVar1 == 0) {\n    uVar5 = (uint)local_36;\n    _rl_screenwidth = (uint)local_36;\n    uVar4 = (uint)local_38;\n    uVar6 = (uint)local_36;\n    uVar7 = (uint)local_36;\n    _rl_screenheight = uVar4;\n    if (param_2 == 0) {\n      if (rl_prefer_env_winsize != 0) goto LAB_001eca27;\n      _rl_screenwidth = uVar6;\n      if (uVar7 == 0) goto LAB_001eca3b;\n      if (local_38 != 0) goto LAB_001eca80;\nLAB_001ecc00:\n      pcVar2 = (char *)sh_get_env_value(\"LINES\");\n      if (pcVar2 != (char *)0x0) {\n        lVar3 = strtol(pcVar2,(char **)0x0,10);\n        _rl_screenheight = (uint)lVar3;\n      }\n      if ((int)_rl_screenheight < 1) goto LAB_001ecb31;\n    }\n    else {\n      if (uVar7 == 0) goto LAB_001ecafc;\n      _rl_screenwidth = uVar7;\n      if (local_38 == 0) {\n        uVar4 = 0;\n        goto LAB_001ecb31;\n      }\n    }\nLAB_001eca80:\n    if (1 < (int)_rl_screenwidth) goto joined_r0x001ecb9e;\nLAB_001ecb70:\n    _rl_screenwidth = 0x50;\nLAB_001ecb7f:\n    if (0 < (int)_rl_screenheight) goto joined_r0x001ecb9e;\n  }\n  else {\n    if (param_2 == 0) {\n      if (rl_prefer_env_winsize == 0) {\n        _rl_screenwidth = 0xffffffff;\n        uVar5 = 0xffffffff;\n        uVar4 = 0xffffffff;\n        _rl_screenheight = 0xffffffff;\n      }\n      else {\n        uVar5 = 0xffffffff;\n        uVar4 = 0xffffffff;\nLAB_001eca27:\n        _rl_screenheight = 0xffffffff;\n        _rl_screenwidth = 0xffffffff;\n      }\nLAB_001eca3b:\n      pcVar2 = (char *)sh_get_env_value(\"COLUMNS\");\n      if (pcVar2 != (char *)0x0) {\n        lVar3 = strtol(pcVar2,(char **)0x0,10);\n        _rl_screenwidth = (uint)lVar3;\n      }\n      if (((int)_rl_screenwidth < 1) && (_rl_screenwidth = uVar5, (int)uVar5 < 1))\n      goto LAB_001ecafc;\n    }\n    else {\n      _rl_screenheight = 0xffffffff;\n      _rl_screenwidth = 0xffffffff;\n      uVar4 = _rl_screenheight;\nLAB_001ecafc:\n      if (DAT_0024b670 != 0) {\n        _rl_screenwidth = tgetnum(&DAT_00213d66);\n      }\n    }\n    if (0 < (int)_rl_screenheight) goto LAB_001eca80;\n    if (param_2 == 0) goto LAB_001ecc00;\nLAB_001ecb31:\n    _rl_screenheight = uVar4;\n    if (0 < (int)uVar4) goto LAB_001eca80;\n    if (DAT_0024b670 != 0) {\n      _rl_screenheight = tgetnum(&DAT_00213d69);\n      if ((int)_rl_screenwidth < 2) goto LAB_001ecb70;\n      goto LAB_001ecb7f;\n    }\n    if ((int)_rl_screenwidth < 2) goto LAB_001ecb70;\n  }\n  _rl_screenheight = 0x18;\njoined_r0x001ecb9e:\n  if (rl_change_environment != 0) {\n    sh_set_lines_and_columns(_rl_screenheight);\n  }\n  if (_rl_term_autowrap == 0) {\n    _rl_screenwidth = _rl_screenwidth - 1;\n  }\n  _rl_screenchars = _rl_screenheight * _rl_screenwidth;\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "push_stream": "\nvoid push_stream(int param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  bool bVar3;\n  \n  puVar1 = (undefined8 *)sh_xmalloc(0x40,\"/usr/local/src/chet/src/bash/src/parse.y\",0x6d6);\n  xbcopy(&bash_input,puVar1 + 1,0x28);\n  bVar3 = bash_input == 4;\n  puVar1[7] = 0;\n  if ((bVar3) && (-1 < (int)DAT_00240a70)) {\n    uVar2 = set_buffered_stream((int)DAT_00240a70,0);\n    puVar1[7] = uVar2;\n  }\n  DAT_00240a68 = 0;\n  *(undefined4 *)(puVar1 + 6) = line_number;\n  *puVar1 = stream_list;\n  stream_list = puVar1;\n  EOF_Reached = 0;\n  if (param_1 != 0) {\n    line_number = 0;\n  }\n  return;\n}\n\n",
  "array_variable_part": "\nundefined8 array_variable_part(void)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = array_variable_name();\n  if (lVar1 != 0) {\n    uVar2 = find_variable(lVar1);\n    sh_xfree(lVar1,\"arrayfunc.c\",0x5ad);\n    return uVar2;\n  }\n  return 0;\n}\n\n",
  "history_total_bytes": "\nint history_total_bytes(void)\n\n{\n  char **ppcVar1;\n  size_t sVar2;\n  size_t sVar3;\n  undefined8 *puVar4;\n  int iVar5;\n  \n  iVar5 = 0;\n  puVar4 = DAT_0024b6e8;\n  if (DAT_0024b6e8 != (undefined8 *)0x0) {\n    while( true ) {\n      ppcVar1 = (char **)*puVar4;\n      puVar4 = puVar4 + 1;\n      if (ppcVar1 == (char **)0x0) break;\n      sVar2 = strlen(*ppcVar1);\n      sVar3 = strlen(ppcVar1[1]);\n      iVar5 = iVar5 + (int)sVar2 + (int)sVar3;\n    }\n  }\n  return iVar5;\n}\n\n",
  "getrandom": "\nvoid getrandom(void)\n\n{\n  (*(code *)PTR_getrandom_00237e30)();\n  return;\n}\n\n",
  "FUN_001516c0": "\nundefined8 FUN_001516c0(undefined8 param_1)\n\n{\n  FUN_001515d0();\n  return param_1;\n}\n\n",
  "close": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_close_00237f50)();\n  return iVar1;\n}\n\n",
  "all_visible_variables": "\nvoid * all_visible_variables(void)\n\n{\n  int iVar1;\n  void *__base;\n  \n  __base = (void *)map_over(FUN_00151280,shell_variables);\n  if (__base != (void *)0x0) {\n    iVar1 = strvec_len(__base);\n    qsort(__base,(long)iVar1,8,FUN_001513a0);\n  }\n  return __base;\n}\n\n",
  "FUN_00167770": "\nvoid FUN_00167770(long param_1,ulong param_2,int *param_3,byte *param_4,uint param_5)\n\n{\n  byte bVar1;\n  mbstate_t mVar2;\n  uint uVar3;\n  size_t sVar4;\n  wchar_t *pwVar5;\n  char *__dest;\n  int iVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  long lVar9;\n  byte *__s_00;\n  int iVar10;\n  long lVar11;\n  long in_FS_OFFSET;\n  int local_88;\n  wchar_t *local_68;\n  wchar_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  if (((param_5 & 0x10) == 0) || (*param_4 != 0x27)) {\n    if (*param_4 == 0) {\n      iVar6 = *param_3;\n      __s = (char *)(iVar6 + param_1);\n      sVar4 = strlen(__s);\n      local_88 = (int)param_2;\n      if ((((iVar6 != 0) && (local_88 = 0, *__s != '\\0')) && (local_88 = 1, __s[1] != '\\0')) &&\n         (local_88 = 2, __s[2] != '\\0')) {\n        local_88 = (int)sVar4;\n      }\n      __dest = (char *)sh_xmalloc(sVar4 + 1,\"subst.c\",0x4ab);\n      strcpy(__dest,__s);\n      local_88 = local_88 + *param_3;\n      goto LAB_00167919;\n    }\n  }\n  else if (param_4[1] == 0) {\n    FUN_001674a0(param_1,param_3,0);\n    local_88 = *param_3 + -1;\n    goto LAB_00167919;\n  }\n  iVar6 = *param_3;\n  uVar7 = (ulong)iVar6;\n  __s_00 = (byte *)(param_1 + uVar7);\n  bVar1 = *__s_00;\n  if (bVar1 != 0) {\n    local_68 = (wchar_t *)0x0;\n    uVar8 = uVar7;\n    do {\n      iVar10 = (int)(char)bVar1;\n      iVar6 = (int)uVar7;\n      if (((iVar10 == 1) && ((param_5 & 0x10) == 0)) ||\n         (((((byte)(param_5 >> 5) ^ 1) & 1) != 0 &&\n          ((iVar10 == 1 && (*(char *)(param_1 + 1 + uVar8) == '\\x7f')))))) {\n        uVar7 = (ulong)(iVar6 + 2U);\n        uVar8 = (ulong)(int)(iVar6 + 2U);\n        if (param_2 <= uVar8) {\n          uVar7 = param_2 & 0xffffffff;\n          break;\n        }\n      }\n      else {\n        if (((((byte)~bVar1 >> 7 & uVar8 < param_2) == 0) || (locale_utf8locale == 0)) &&\n           (sVar4 = __ctype_get_mb_cur_max(), 1 < sVar4)) {\n          uVar3 = mblen((char *)__s_00,param_2 - uVar8);\n          if ((uVar3 < 2) ||\n             (uVar3 = mbtowc(&local_4c,(char *)__s_00,param_2 - uVar8), 0xfffffffd < uVar3))\n          goto LAB_0016785f;\n          if (local_68 == (wchar_t *)0x0) {\n            sVar4 = mbstowcs((wchar_t *)0x0,(char *)param_4,0);\n            if (sVar4 == 0xffffffffffffffff) {\n              lVar9 = 4;\n              lVar11 = 1;\n            }\n            else {\n              lVar11 = sVar4 + 1;\n              lVar9 = lVar11 * 4;\n            }\n            local_68 = (wchar_t *)sh_xmalloc(lVar9,\"subst.c\",0x4df);\n            __mbstowcs_chk(local_68,param_4,lVar11,0x3fffffffffffffff);\n          }\n          pwVar5 = wcschr(local_68,local_4c);\n          mVar2 = local_48;\n        }\n        else {\nLAB_0016785f:\n          if ((*param_4 == bVar1) && (param_4[1] == 0)) break;\n          pwVar5 = (wchar_t *)mbschr(param_4,iVar10);\n          mVar2 = local_48;\n        }\n        local_48 = mVar2;\n        if (pwVar5 != (wchar_t *)0x0) break;\n        if (locale_mb_cur_max < 2) {\nLAB_001678c8:\n          uVar7 = (ulong)(iVar6 + 1);\n        }\n        else {\n          bVar1 = *__s_00;\n          if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale == 0) || ((char)bVar1 < '\\0')) {\n              sVar4 = mbrtowc((wchar_t *)0x0,(char *)__s_00,param_2 - uVar8,&local_48);\n              if (sVar4 < 0xfffffffffffffffe) {\n                if (sVar4 == 0) goto LAB_001678c8;\n                uVar7 = (ulong)(uint)(iVar6 + (int)sVar4);\n              }\n              else {\n                uVar7 = (ulong)(iVar6 + 1);\n                local_48 = mVar2;\n              }\n              goto LAB_001678cb;\n            }\n            if (bVar1 == 0) goto LAB_001678c8;\n          }\n          uVar7 = (ulong)(iVar6 + 1);\n        }\nLAB_001678cb:\n        uVar8 = (ulong)(int)uVar7;\n      }\n      __s_00 = (byte *)(param_1 + uVar8);\n      bVar1 = *__s_00;\n    } while (bVar1 != 0);\n    if (local_68 != (wchar_t *)0x0) {\n      sh_xfree(local_68,\"subst.c\",0x4f0);\n    }\n    iVar6 = *param_3;\n  }\n  local_88 = (int)uVar7;\n  substring(param_1,iVar6,uVar7 & 0xffffffff);\nLAB_00167919:\n  *param_3 = local_88;\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00192770": "\nvoid FUN_00192770(void)\n\n{\n  FUN_00192690(0x3f);\n  return;\n}\n\n",
  "FUN_001da6c0": "\nvoid FUN_001da6c0(undefined8 param_1)\n\n{\n  _rl_reset_region_color(1,param_1);\n  return;\n}\n\n",
  "rl_noninc_forward_search": "\nvoid rl_noninc_forward_search(undefined8 param_1,int param_2)\n\n{\n  if (param_2 != 0x3f) {\n    param_2 = 0;\n  }\n  FUN_001d4e70(1,param_2);\n  return;\n}\n\n",
  "bash_re_edit": "\nundefined8 bash_re_edit(char *param_1)\n\n{\n  size_t sVar1;\n  char *__dest;\n  \n  if (DAT_00248868 != (char *)0x0) {\n    sh_xfree(DAT_00248868,\"bashline.c\",0x2cf);\n  }\n  sVar1 = strlen(param_1);\n  __dest = (char *)sh_xmalloc(sVar1 + 1,\"bashline.c\",0x2d1);\n  DAT_00248868 = strcpy(__dest,param_1);\n  DAT_00248878 = rl_startup_hook;\n  rl_startup_hook = FUN_00193490;\n  return 0;\n}\n\n",
  "save_bash_input": "\nint save_bash_input(int param_1,int param_2)\n\n{\n  long lVar1;\n  int iVar2;\n  \n  if (*(long *)(DAT_00247f68 + (long)param_1 * 8) != 0) {\n    sync_buffered_stream(param_1);\n  }\n  if ((param_2 == -1) && (param_2 = fcntl(param_1,0,10), param_2 == -1)) {\n    iVar2 = fcntl(param_1,1,0);\n    if (iVar2 != 0) {\n      return -1;\n    }\n    sys_error(\"cannot allocate new file descriptor for bash input from fd %d\",param_1);\n    return -1;\n  }\n  if ((param_2 < DAT_00247f64) && (*(long *)(DAT_00247f68 + (long)param_2 * 8) != 0)) {\n    internal_error(\"save_bash_input: buffer already exists for new fd %d\",param_2);\n    lVar1 = *(long *)(DAT_00247f68 + (long)param_2 * 8);\n    if ((*(byte *)(lVar1 + 0x20) & 0x20) != 0) {\n      *(undefined8 *)(lVar1 + 8) = 0;\n    }\n    free_buffered_stream();\n  }\n  if (bash_input == 4) {\n    DAT_00240a70._0_4_ = param_2;\n    fd_to_buffered_stream(param_2);\n    close_buffered_fd(param_1);\n  }\n  else {\n    bash_input_fd_changed = bash_input_fd_changed + 1;\n  }\n  if (default_buffered_input == param_1) {\n    default_buffered_input = param_2;\n  }\n  fcntl(param_2,2,1);\n  return param_2;\n}\n\n",
  "xtrace_fdchk": "\nvoid xtrace_fdchk(int param_1)\n\n{\n  if (xtrace_fd != param_1) {\n    return;\n  }\n  xtrace_reset();\n  return;\n}\n\n",
  "FUN_00130020": "\nvoid FUN_00130020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)PTR_002377f8)();\n  return;\n}\n\n",
  "getpeername": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint getpeername(int __fd,sockaddr *__addr,socklen_t *__len)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_getpeername_00237968)();\n  return iVar1;\n}\n\n",
  "last_history_line": "\nundefined8 * last_history_line(void)\n\n{\n  undefined8 *puVar1;\n  \n  using_history();\n  puVar1 = (undefined8 *)previous_history();\n  using_history();\n  if (puVar1 != (undefined8 *)0x0) {\n    puVar1 = (undefined8 *)*puVar1;\n  }\n  return puVar1;\n}\n\n",
  "set_dollar_vars_changed": "\nvoid set_dollar_vars_changed(void)\n\n{\n  uint uVar1;\n  \n  if (variable_context == 0) {\n    uVar1 = DAT_00248a98 | 1;\n    if (this_shell_builtin == set_builtin) {\n      DAT_00248a98 = DAT_00248a98 | 4;\n      return;\n    }\n  }\n  else {\n    uVar1 = DAT_00248a98 | 2;\n  }\n  DAT_00248a98 = uVar1;\n  return;\n}\n\n",
  "FUN_001d7d90": "\nvoid FUN_001d7d90(undefined8 param_1,int param_2,int param_3,int param_4)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  char *__s;\n  size_t sVar4;\n  char *__dest;\n  long in_FS_OFFSET;\n  char *local_150;\n  stat local_148;\n  stat local_b8;\n  undefined local_24 [4];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_3 == 0) {\nLAB_001d7df0:\n    if (param_2 != 0) goto LAB_001d7df4;\nLAB_001d7e56:\n    if ((rl_completion_suppress_append == 0) && (rl_completion_append_character != 0)) {\n      lVar3 = (long)param_3;\n      param_3 = param_3 + 1;\n      local_24[lVar3] = (char)rl_completion_append_character;\n    }\n  }\n  else {\n    if (((rl_point != 0) && (rl_completion_suppress_quote == 0)) &&\n       (param_3 != *(char *)(rl_line_buffer + -1 + (long)rl_point))) {\n      local_24[0] = (undefined)param_3;\n      param_3 = 1;\n      goto LAB_001d7df0;\n    }\n    param_3 = 0;\n    if (param_2 == 0) goto LAB_001d7e56;\nLAB_001d7df4:\n    lVar3 = (long)param_3;\n    param_3 = param_3 + 1;\n    local_24[lVar3] = (char)param_2;\n  }\n  local_24[param_3] = 0;\n  if (rl_filename_completion_desired == 0) {\n    if (rl_point == rl_end) {\n      rl_insert_text(local_24);\n    }\n    goto LAB_001d7e29;\n  }\n  __s = (char *)tilde_expand();\n  if (rl_filename_stat_hook != (code *)0x0) {\n    sVar4 = strlen(__s);\n    __dest = (char *)xmalloc(sVar4 + 1);\n    local_150 = strcpy(__dest,__s);\n    (*rl_filename_stat_hook)(&local_150);\n    xfree(__s);\n    __s = local_150;\n  }\n  if ((param_4 == 0) || (rl_completion_mark_symlink_dirs != 0)) {\n    iVar2 = stat(__s,&local_148);\n  }\n  else {\n    iVar2 = lstat(__s,&local_148);\n  }\n  if (iVar2 == 0) {\n    if ((local_148.st_mode & 0xf000) == 0x4000) {\n      if (_rl_complete_mark_directories != 0) {\n        cVar1 = *(char *)(rl_line_buffer + rl_point);\n        if ((rl_point != 0) && (cVar1 == '\\0')) {\n          cVar1 = *(char *)(rl_line_buffer + -1 + (long)rl_point);\n        }\n        if (cVar1 != '/') {\n          rl_insert_text(&DAT_001fe10e);\n        }\n      }\n    }\n    else if ((((local_148.st_mode & 0xf000) != 0xa000) || (iVar2 = stat(__s,&local_b8), iVar2 != 0))\n            || ((local_b8.st_mode & 0xf000) != 0x4000)) goto LAB_001d7f05;\n  }\n  else {\nLAB_001d7f05:\n    if (rl_point == rl_end) {\n      rl_insert_text(local_24);\n    }\n  }\n  xfree(__s);\nLAB_001d7e29:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "FUN_0015a750": "\nundefined4 * FUN_0015a750(undefined4 *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined4 *puVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  \n  puVar2 = (undefined4 *)sh_xmalloc(0x28,\"copy_cmd.c\",0x139);\n  puVar1 = *(undefined8 **)(param_1 + 4);\n  *puVar2 = *param_1;\n  puVar2[1] = param_1[1];\n  puVar2[2] = param_1[2];\n  puVar3 = puVar1;\n  if (puVar1 != (undefined8 *)0x0) {\n    puVar3 = (undefined8 *)make_bare_word(*puVar1);\n    *(undefined4 *)(puVar3 + 1) = *(undefined4 *)(puVar1 + 1);\n  }\n  lVar4 = *(long *)(param_1 + 6);\n  *(undefined8 **)(puVar2 + 4) = puVar3;\n  if (lVar4 != 0) {\n    lVar4 = FUN_0015a750();\n  }\n  *(long *)(puVar2 + 6) = lVar4;\n  lVar4 = *(long *)(param_1 + 8);\n  if (lVar4 != 0) {\n    lVar4 = FUN_0015a750();\n  }\n  *(long *)(puVar2 + 8) = lVar4;\n  return puVar2;\n}\n\n",
  "FUN_001dba30": "\nundefined8 FUN_001dba30(char *param_1)\n\n{\n  size_t sVar1;\n  \n  if (param_1 == (char *)0x0) {\n    if (_rl_vi_cmd_mode_str != (undefined *)0x0) {\n      free(_rl_vi_cmd_mode_str);\n    }\n    _rl_vi_cmd_mode_str = (undefined *)0x0;\n    _rl_vi_cmd_modestr_len = 0;\n    return 0;\n  }\n  if (*param_1 == '\\0') {\n    if (_rl_vi_cmd_mode_str != (undefined *)0x0) {\n      free(_rl_vi_cmd_mode_str);\n    }\n    _rl_vi_cmd_mode_str = (undefined *)xmalloc(1);\n    _rl_vi_cmd_modestr_len = 0;\n    *_rl_vi_cmd_mode_str = 0;\n    return 0;\n  }\n  if (_rl_vi_cmd_mode_str != (undefined *)0x0) {\n    free(_rl_vi_cmd_mode_str);\n  }\n  sVar1 = strlen(param_1);\n  _rl_vi_cmd_mode_str = (undefined *)xmalloc(sVar1 * 2 + 1);\n  rl_translate_keyseq(param_1,_rl_vi_cmd_mode_str,&_rl_vi_cmd_modestr_len);\n  *(undefined *)((long)_rl_vi_cmd_mode_str + (long)_rl_vi_cmd_modestr_len) = 0;\n  return 0;\n}\n\n",
  "FUN_001373e0": "\nvoid FUN_001373e0(void)\n\n{\n  undefined *puVar1;\n  \n  ps1_prompt = get_string_value(&DAT_001fa152);\n  ps2_prompt = get_string_value(&DAT_001fa156);\n  ps0_prompt = get_string_value(&DAT_001faa99);\n  if (prompt_string_pointer == (long *)0x0) {\n    prompt_string_pointer = &ps1_prompt;\n  }\n  if (*prompt_string_pointer != 0) {\n    puVar1 = (undefined *)decode_prompt_string();\n    if (puVar1 != (undefined *)0x0) goto LAB_0013743f;\n  }\n  puVar1 = (undefined *)sh_xmalloc(1,\"/usr/local/src/chet/src/bash/src/parse.y\",0x15c0);\n  *puVar1 = 0;\nLAB_0013743f:\n  current_prompt_string = *prompt_string_pointer;\n  prompt_string_pointer = &ps2_prompt;\n  if (no_line_editing == 0) {\n    if (current_readline_prompt != (undefined *)0x0) {\n      sh_xfree(current_readline_prompt,\"/usr/local/src/chet/src/bash/src/parse.y\",0x15ca);\n    }\n    current_readline_prompt = puVar1;\n    return;\n  }\n  if (DAT_00240d78 != (undefined *)0x0) {\n    sh_xfree(DAT_00240d78,\"/usr/local/src/chet/src/bash/src/parse.y\",0x15d0);\n  }\n  DAT_00240d78 = puVar1;\n  return;\n}\n\n",
  "set_tty_state": "\nundefined8 set_tty_state(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  int __fd;\n  __pid_t _Var3;\n  undefined8 uVar4;\n  \n  __fd = shell_tty;\n  if (((shell_tty == -1) && (__fd = fileno(stderr), __fd == -1)) ||\n     (iVar2 = tcsetattr(__fd,1,(termios *)&DAT_002475e0), uVar1 = shell_level, -1 < iVar2)) {\n    uVar4 = 0;\n  }\n  else {\n    uVar4 = 0xffffffff;\n    if (interactive != 0) {\n      _Var3 = getpid();\n      sys_error(\"[%ld: %d (%d)] tcsetattr\",(long)_Var3,uVar1,__fd);\n    }\n  }\n  return uVar4;\n}\n\n",
  "_rl_enable_meta_key": "\nvoid _rl_enable_meta_key(void)\n\n{\n  if ((DAT_0024b658 != 0) && (DAT_0024b650 != 0)) {\n    tputs(DAT_0024b650,1,_rl_output_character_function);\n    DAT_0024b5bc = 1;\n    return;\n  }\n  return;\n}\n\n",
  "FUN_0017af90": "\nundefined8 FUN_0017af90(char *param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  undefined8 uVar3;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    lVar1 = FUN_0017aeb0();\n    if (lVar1 != 0) {\n      lVar2 = FUN_00171b00(lVar1);\n      dispose_words(lVar1);\n      if (lVar2 != 0) {\n        uVar3 = dequote_list(lVar2);\n        return uVar3;\n      }\n    }\n    return 0;\n  }\n  return 0;\n}\n\n",
  "FUN_001da6b0": "\nvoid FUN_001da6b0(undefined8 param_1)\n\n{\n  _rl_reset_region_color(0,param_1);\n  return;\n}\n\n",
  "builtin_address_internal": "\nchar ** builtin_address_internal(char *param_1,uint param_2)\n\n{\n  char cVar1;\n  undefined *puVar2;\n  int iVar3;\n  int iVar4;\n  char **ppcVar5;\n  int iVar6;\n  int iVar7;\n  \n  puVar2 = shell_builtins;\n  iVar6 = num_shell_builtins + -1;\n  if (-1 < iVar6) {\n    cVar1 = *param_1;\n    iVar7 = 0;\n    do {\n      while( true ) {\n        iVar4 = iVar6 + iVar7 >> 1;\n        ppcVar5 = (char **)(puVar2 + (long)iVar4 * 0x30);\n        iVar3 = (int)**ppcVar5 - (int)cVar1;\n        if ((iVar3 == 0) && (iVar3 = strcmp(*ppcVar5,param_1), iVar3 == 0)) {\n          if (ppcVar5[1] == (char *)0x0) {\n            return (char **)0x0;\n          }\n          if ((*(uint *)(ppcVar5 + 2) & 2) != 0) {\n            return (char **)0x0;\n          }\n          if ((*(uint *)(ppcVar5 + 2) & 1 | param_2) == 0) {\n            return (char **)0x0;\n          }\n          return ppcVar5;\n        }\n        if (0 < iVar3) break;\n        iVar7 = iVar4 + 1;\n        if (iVar6 < iVar7) {\n          return (char **)0x0;\n        }\n      }\n      iVar6 = iVar4 + -1;\n    } while (iVar7 <= iVar6);\n  }\n  return (char **)0x0;\n}\n\n",
  "assoc_insert": "\nundefined8 assoc_insert(undefined8 param_1,long param_2,char *param_3)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *__dest;\n  undefined8 uVar3;\n  \n  lVar1 = hash_search(param_2,param_1,2);\n  if (lVar1 == 0) {\n    uVar3 = 0xffffffff;\n  }\n  else {\n    if (*(long *)(lVar1 + 8) != param_2) {\n      sh_xfree(param_2,\"assoc.c\",0x54);\n    }\n    if (*(long *)(lVar1 + 0x10) != 0) {\n      sh_xfree(*(long *)(lVar1 + 0x10),\"assoc.c\",0x55);\n    }\n    if (param_3 != (char *)0x0) {\n      sVar2 = strlen(param_3);\n      __dest = (char *)sh_xmalloc(sVar2 + 1,\"assoc.c\",0x56);\n      param_3 = strcpy(__dest,param_3);\n    }\n    *(char **)(lVar1 + 0x10) = param_3;\n    uVar3 = 0;\n  }\n  return uVar3;\n}\n\n",
  "FUN_001449a0": "\nvoid FUN_001449a0(int param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  if (DAT_00241ef0 <= param_1) {\n    DAT_00241ef0 = DAT_00241ef0 + 0x10 + (param_1 - DAT_00241ef0 & 0xfffffff0U);\n    DAT_00241ef8 = (undefined *)sh_xrealloc(DAT_00241ef8,(long)DAT_00241ef0,\"print_cmd.c\",0x5d4);\n  }\n  puVar2 = DAT_00241ef8;\n  puVar1 = DAT_00241ef8;\n  if (0 < param_1) {\n    puVar1 = (undefined *)memset(DAT_00241ef8,0x20,(long)param_1);\n    puVar2 = puVar1 + param_1;\n  }\n  *puVar2 = 0;\n  FUN_001446d0(&DAT_002102da,puVar1);\n  return;\n}\n\n",
  "FUN_00170510": "\nlong * FUN_00170510(long *param_1)\n\n{\n  char **ppcVar1;\n  char *pcVar2;\n  long lVar3;\n  uint uVar4;\n  char *pcVar5;\n  long *plVar6;\n  \n  plVar6 = param_1;\n  if (param_1 != (long *)0x0) {\n    do {\n      ppcVar1 = (char **)plVar6[1];\n      pcVar2 = *ppcVar1;\n      pcVar5 = (char *)quote_string(pcVar2);\n      lVar3 = plVar6[1];\n      *ppcVar1 = pcVar5;\n      uVar4 = *(uint *)(lVar3 + 8);\n      if (*pcVar2 == '\\0') {\n        uVar4 = uVar4 | 0x40000;\n        *(uint *)(lVar3 + 8) = uVar4;\n      }\n      *(uint *)(lVar3 + 8) = uVar4 | 2;\n      sh_xfree(pcVar2,\"subst.c\",0x1344);\n      plVar6 = (long *)*plVar6;\n    } while (plVar6 != (long *)0x0);\n  }\n  return param_1;\n}\n\n",
  "set_signal_handler": "\n_union_1457 set_signal_handler(int param_1,_union_1457 param_2)\n\n{\n  int iVar1;\n  _union_1457 _Var2;\n  long in_FS_OFFSET;\n  sigaction local_158;\n  sigaction local_b8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_158.sa_flags = 0;\n  if (((param_1 == 0x11) || (param_1 == 0x1c)) ||\n     ((param_1 == 0xf && (param_2.sa_handler == sigterm_sighandler)))) {\n    local_158.sa_flags = 0x10000000;\n  }\n  local_158.__sigaction_handler = param_2;\n  sigemptyset(&local_158.sa_mask);\n  sigemptyset(&local_b8.sa_mask);\n  iVar1 = sigaction(param_1,&local_158,&local_b8);\n  _Var2.sa_handler = (__sighandler_t)0x0;\n  if (iVar1 == 0) {\n    _Var2 = local_b8.__sigaction_handler;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return (_union_1457)_Var2.sa_handler;\n}\n\n",
  "close_pgrp_pipe": "\nvoid close_pgrp_pipe(void)\n\n{\n  sh_closepipe(&pgrp_pipe);\n  return;\n}\n\n",
  "_rl_keyseq_cxt_dispose": "\nvoid _rl_keyseq_cxt_dispose(void)\n\n{\n  xfree();\n  return;\n}\n\n",
  "sort_variables": "\nvoid sort_variables(void *param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = strvec_len();\n  qsort(param_1,(long)iVar1,8,FUN_001513a0);\n  return;\n}\n\n",
  "FUN_001b6e40": "\nundefined8 FUN_001b6e40(void)\n\n{\n  set_shellopts();\n  return 0;\n}\n\n",
  "builtin_unbind_variable": "\nundefined8 builtin_unbind_variable(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = find_variable();\n  if (lVar1 != 0) {\n    if ((*(uint *)(lVar1 + 0x28) & 2) == 0) {\n      if ((*(uint *)(lVar1 + 0x28) & 0x2000) == 0) goto LAB_001a50de;\n      builtin_error(\"%s: cannot unset\",param_1);\n    }\n    else {\n      builtin_error(\"%s: cannot unset: readonly %s\",param_1,\"variable\");\n    }\n    return 0xfffffffe;\n  }\nLAB_001a50de:\n  uVar2 = unbind_variable(param_1);\n  return uVar2;\n}\n\n",
  "sv_shcompat": "\nvoid sv_shcompat(undefined8 param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte *pbVar3;\n  ushort *puVar4;\n  int iVar5;\n  long lVar6;\n  ushort **ppuVar7;\n  \n  lVar6 = find_variable();\n  if (((lVar6 == 0) || (pbVar3 = *(byte **)(lVar6 + 8), pbVar3 == (byte *)0x0)) ||\n     (bVar1 = *pbVar3, bVar1 == 0)) goto LAB_00153c54;\n  ppuVar7 = __ctype_b_loc();\n  puVar4 = *ppuVar7;\n  if ((*(byte *)((long)puVar4 + (ulong)bVar1 * 2 + 1) & 8) != 0) {\n    bVar2 = pbVar3[1];\n    if (((bVar2 == 0x2e) && ((*(byte *)((long)puVar4 + (ulong)pbVar3[2] * 2 + 1) & 8) != 0)) &&\n       (pbVar3[3] == 0)) {\n      iVar5 = (char)pbVar3[2] + -0x30 + ((char)bVar1 * 5 + -0xf0) * 2;\n    }\n    else {\n      if (((*(byte *)((long)puVar4 + (ulong)bVar2 * 2 + 1) & 8) == 0) || (pbVar3[2] != 0))\n      goto LAB_00153c40;\n      iVar5 = (char)bVar2 + -0x30 + ((char)bVar1 * 5 + -0xf0) * 2;\n    }\n    if (iVar5 - 0x1fU < 0x16) {\n      shell_compatibility_level = iVar5;\n      set_compatibility_opts();\n      return;\n    }\n  }\nLAB_00153c40:\n  internal_error(\"%s: %s: compatibility value out of range\",param_1,pbVar3);\nLAB_00153c54:\n  shell_compatibility_level = 0x34;\n  set_compatibility_opts();\n  return;\n}\n\n",
  "_rl_reset_locale": "\nvoid _rl_reset_locale(void)\n\n{\n  char *__s1;\n  int iVar1;\n  char *__s2;\n  char cVar2;\n  \n  __s1 = DAT_0024b6b0;\n  __s2 = (char *)_rl_init_locale();\n  if (__s1 == (char *)0x0) {\n    if (__s2 == (char *)0x0) {\nLAB_001f061b:\n      xfree(__s1);\n      return;\n    }\n    cVar2 = *__s2;\n  }\n  else if ((__s2 == (char *)0x0) ||\n          ((cVar2 = *__s2, *__s1 == cVar2 && (iVar1 = strcmp(__s1,__s2), iVar1 == 0))))\n  goto LAB_001f061b;\n  if (cVar2 != '\\0') {\n    if (cVar2 == 'C') {\n      if (__s2[1] != '\\0') goto LAB_001f06a6;\n    }\n    else if ((cVar2 != 'P') || (iVar1 = strcmp(__s2,\"POSIX\"), iVar1 != 0)) {\nLAB_001f06a6:\n      _rl_meta_flag = 1;\n      _rl_convert_meta_chars_to_ascii = 0;\n      _rl_output_meta_chars = 1;\n      xfree(__s1);\n      return;\n    }\n  }\n  _rl_meta_flag = 0;\n  _rl_convert_meta_chars_to_ascii = 1;\n  _rl_output_meta_chars = 0;\n  xfree(__s1);\n  return;\n}\n\n",
  "__snprintf_chk": "\nvoid __snprintf_chk(void)\n\n{\n  (*(code *)PTR___snprintf_chk_00237820)();\n  return;\n}\n\n",
  "chown": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint chown(char *__file,__uid_t __owner,__gid_t __group)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_chown_00237c88)();\n  return iVar1;\n}\n\n",
  "FUN_00190530": "\nundefined8 FUN_00190530(char **param_1)\n\n{\n  char cVar1;\n  char *pcVar2;\n  \n  pcVar2 = *param_1;\n  if (pcVar2 != (char *)0x0) {\n    for (; cVar1 = *pcVar2, cVar1 != '\\0'; pcVar2 = pcVar2 + 1) {\n      if (cVar1 == '\\\\') {\n        pcVar2 = pcVar2 + 1;\n      }\n      else if (cVar1 == '&') {\n        *(uint *)((long)param_1 + 0xc) = *(uint *)((long)param_1 + 0xc) | 1;\n        return 0;\n      }\n    }\n  }\n  return 0;\n}\n\n",
  "_rl_pop_executing_macro": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid _rl_pop_executing_macro(void)\n\n{\n  if (rl_executing_macro != (void *)0x0) {\n    free(rl_executing_macro);\n  }\n  rl_executing_macro = (void *)0x0;\n  DAT_0024b1a0 = 0;\n  if (DAT_0024b188 == (undefined8 *)0x0) {\n    _DAT_0024b180 = _DAT_0024b180 + -1;\n  }\n  else {\n    rl_executing_macro = (void *)DAT_0024b188[1];\n    DAT_0024b1a0 = *(undefined4 *)(DAT_0024b188 + 2);\n    DAT_0024b188 = (undefined8 *)*DAT_0024b188;\n    xfree();\n    _DAT_0024b180 = _DAT_0024b180 + -1;\n    if (rl_executing_macro != (void *)0x0) {\n      return;\n    }\n  }\n  rl_readline_state = rl_readline_state & 0xfffffffffffff7ff;\n  return;\n}\n\n",
  "_rl_revert_all_lines": "\nvoid _rl_revert_all_lines(void)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = where_history();\n  using_history();\n  _rl_revert_previous_lines();\n  history_set_pos(uVar1);\n  return;\n}\n\n",
  "bash_add_history": "\nvoid bash_add_history(char *param_1)\n\n{\n  char cVar1;\n  char *__s;\n  int iVar2;\n  undefined4 uVar3;\n  size_t sVar4;\n  char **ppcVar5;\n  size_t sVar6;\n  undefined8 uVar7;\n  char *__s_00;\n  long lVar8;\n  \n  if ((command_oriented_history != 0) && (1 < current_command_line_count)) {\n    iVar2 = FUN_00190710();\n    if (((parser_state._2_1_ & 2) == 0) || (here_doc_first_line != 0)) {\nLAB_00190d78:\n      __s_00 = \"\\n\";\n      if ((current_command_line_comment + 1 != current_command_line_count) && (literal_history == 0)\n         ) {\n        __s_00 = (char *)history_delimiting_chars(param_1);\n      }\n    }\n    else {\n      __s_00 = \"\";\n      sVar4 = strlen(param_1);\n      if (param_1[sVar4 - 1] != '\\n') goto LAB_00190d78;\n    }\n    using_history();\n    ppcVar5 = (char **)previous_history();\n    current_command_line_comment = -2;\n    if (iVar2 != 0) {\n      current_command_line_comment = current_command_line_count;\n    }\n    if (ppcVar5 != (char **)0x0) {\n      __s = *ppcVar5;\n      sVar4 = strlen(__s);\n      iVar2 = (int)sVar4;\n      if (DAT_00240a18 == 0) {\n        lVar8 = (long)iVar2;\n        cVar1 = __s[lVar8 + -1];\n        if (cVar1 == '\\\\') {\n          if (__s[lVar8 + -2] == '\\\\') goto LAB_00190eb0;\n          __s[lVar8 + -1] = '\\0';\n          __s_00 = \"\";\n        }\n        else {\n          lVar8 = (long)(iVar2 + 1);\n          if (cVar1 == '\\n') {\n            __s_00 = __s_00 + (*__s_00 == ';');\n          }\n        }\n      }\n      else {\nLAB_00190eb0:\n        lVar8 = (long)(iVar2 + 1);\n      }\n      sVar4 = strlen(param_1);\n      sVar6 = strlen(__s_00);\n      uVar7 = sh_xmalloc(sVar4 + lVar8 + sVar6,\"bashhist.c\",0x3a3);\n      __sprintf_chk(uVar7,1,0xffffffffffffffff,\"%s%s%s\",*ppcVar5,__s_00,param_1);\n      uVar3 = where_history();\n      lVar8 = replace_history_entry(uVar3,uVar7,ppcVar5[2]);\n      sh_xfree(uVar7,\"bashhist.c\",0x3aa);\n      if (lVar8 != 0) {\n        free_history_entry(lVar8);\n        using_history();\n        return;\n      }\n      goto LAB_00190d2e;\n    }\n  }\n  iVar2 = history_is_stifled();\n  if ((iVar2 == 0) || ((history_length | history_max_entries) != 0)) {\n    hist_last_line_added = 1;\n    hist_last_line_pushed = 0;\n    add_history(param_1);\n    history_lines_this_session = history_lines_this_session + 1;\n  }\nLAB_00190d2e:\n  using_history();\n  return;\n}\n\n",
  "extglob_pattern_p": "\nbool extglob_pattern_p(byte *param_1)\n\n{\n  bool bVar1;\n  \n  bVar1 = false;\n  if (((byte)(*param_1 - 0x21) < 0x20) &&\n     ((0xc0000601UL >> ((ulong)(*param_1 - 0x21) & 0x3f) & 1) != 0)) {\n    bVar1 = param_1[1] == 0x28;\n  }\n  return bVar1;\n}\n\n",
  "getuid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__uid_t getuid(void)\n\n{\n  __uid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_getuid_002379d8)();\n  return _Var1;\n}\n\n",
  "rl_filename_completion_function": "\nchar * rl_filename_completion_function(char *param_1,int param_2)\n\n{\n  char cVar1;\n  byte bVar2;\n  byte bVar3;\n  ushort *puVar4;\n  wchar_t wVar5;\n  int iVar6;\n  size_t sVar7;\n  char *pcVar8;\n  char *pcVar9;\n  byte *pbVar10;\n  dirent *pdVar11;\n  size_t sVar12;\n  char *pcVar13;\n  long lVar14;\n  size_t sVar15;\n  ushort **ppuVar16;\n  __int32_t **pp_Var17;\n  char *pcVar18;\n  DIR *__dirp;\n  __int32_t _Var19;\n  ulong uVar20;\n  uint uVar21;\n  long in_FS_OFFSET;\n  wchar_t *local_90;\n  wchar_t local_58;\n  wchar_t local_54;\n  mbstate_t local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  __dirp = DAT_0024a700;\n  if (param_2 == 0) {\n    if (DAT_0024a700 != (DIR *)0x0) {\n      closedir(DAT_0024a700);\n      DAT_0024a700 = (DIR *)0x0;\n    }\n    if (DAT_0024a6f8 != (char *)0x0) {\n      free(DAT_0024a6f8);\n    }\n    if (DAT_0024a6f0 != (byte *)0x0) {\n      free(DAT_0024a6f0);\n    }\n    if (DAT_0024a6e8 != (char *)0x0) {\n      free(DAT_0024a6e8);\n    }\n    sVar7 = strlen(param_1);\n    pcVar8 = (char *)xmalloc(sVar7 + 1);\n    DAT_0024a6f0 = (byte *)strcpy(pcVar8,param_1);\n    if (*param_1 == '\\0') {\n      lVar14 = 2;\n      param_1 = \".\";\n    }\n    else {\n      sVar7 = strlen(param_1);\n      lVar14 = sVar7 + 1;\n    }\n    pcVar8 = (char *)xmalloc(lVar14);\n    pcVar8 = strcpy(pcVar8,param_1);\n    DAT_0024a6f8 = pcVar8;\n    pcVar9 = strrchr(pcVar8,0x2f);\n    if (pcVar9 == (char *)0x0) {\n      *pcVar8 = '.';\n      DAT_0024a6f8[1] = '\\0';\n    }\n    else {\n      strcpy((char *)DAT_0024a6f0,pcVar9 + 1);\n      pcVar9[1] = '\\0';\n    }\n    pcVar8 = DAT_0024a6f8;\n    if ((rl_completion_found_quote == 0) || (rl_filename_dequoting_function == (code *)0x0)) {\n      sVar7 = strlen(DAT_0024a6f8);\n      pcVar9 = (char *)xmalloc(sVar7 + 1);\n      DAT_0024a6e8 = strcpy(pcVar9,pcVar8);\n    }\n    else {\n      DAT_0024a6e8 = (char *)(*rl_filename_dequoting_function)\n                                       (DAT_0024a6f8,rl_completion_quote_character);\n    }\n    cVar1 = *DAT_0024a6f8;\n    if (cVar1 == '~') {\n      pcVar8 = (char *)tilde_expand();\n      xfree(DAT_0024a6f8);\n      DAT_0024a6f8 = pcVar8;\n    }\n    if (rl_directory_rewrite_hook == (code *)0x0) {\n      if ((rl_directory_completion_hook == (code *)0x0) ||\n         (iVar6 = (*rl_directory_completion_hook)(&DAT_0024a6f8), iVar6 == 0)) {\n        if ((cVar1 != '~') &&\n           ((rl_completion_found_quote != 0 && (rl_filename_dequoting_function != (code *)0x0)))) {\n          xfree();\n          pcVar8 = DAT_0024a6e8;\n          sVar7 = strlen(DAT_0024a6e8);\n          pcVar9 = (char *)xmalloc(sVar7 + 1);\n          DAT_0024a6f8 = strcpy(pcVar9,pcVar8);\n        }\n      }\n      else {\n        xfree(DAT_0024a6e8);\n        pcVar8 = DAT_0024a6f8;\n        sVar7 = strlen(DAT_0024a6f8);\n        pcVar9 = (char *)xmalloc(sVar7 + 1);\n        DAT_0024a6e8 = strcpy(pcVar9,pcVar8);\n      }\n    }\n    else {\n      (*rl_directory_rewrite_hook)(&DAT_0024a6f8);\n    }\n    DAT_0024a700 = opendir(DAT_0024a6f8);\n    if (((*DAT_0024a6f0 != 0) && (rl_completion_found_quote != 0)) &&\n       (rl_filename_dequoting_function != (code *)0x0)) {\n      pbVar10 = (byte *)(*rl_filename_dequoting_function)\n                                  (DAT_0024a6f0,rl_completion_quote_character);\n      xfree(DAT_0024a6f0);\n      DAT_0024a6f0 = pbVar10;\n    }\n    __dirp = DAT_0024a700;\n    sVar7 = strlen((char *)DAT_0024a6f0);\n    rl_filename_completion_desired = 1;\n    DAT_0024a6e0 = (uint)sVar7;\n  }\n  if (__dirp != (DIR *)0x0) {\n    pdVar11 = readdir(__dirp);\n    while (pdVar11 != (dirent *)0x0) {\n      pcVar8 = pdVar11->d_name;\n      sVar7 = strlen(pcVar8);\n      iVar6 = (int)(sVar7 & 0xffffffff);\n      pcVar9 = pcVar8;\n      if ((rl_filename_rewrite_hook != (code *)0x0) &&\n         (pcVar9 = (char *)(*rl_filename_rewrite_hook)(pcVar8,sVar7 & 0xffffffff), pcVar8 != pcVar9)\n         ) {\n        sVar7 = strlen(pcVar9);\n        iVar6 = (int)sVar7;\n      }\n      pbVar10 = DAT_0024a6f0;\n      uVar21 = DAT_0024a6e0;\n      if (DAT_0024a6e0 == 0) {\n        if (_rl_match_hidden_files == 0) {\n          if (*pcVar9 == 0x2e) goto joined_r0x001d6d92;\n        }\n        else if ((*pcVar9 == 0x2e) &&\n                ((pcVar9[1] == 0 || ((pcVar9[1] == 0x2e && (pcVar9[2] == 0))))))\n        goto joined_r0x001d6d92;\nLAB_001d6805:\n        pcVar18 = DAT_0024a6f8;\n        pcVar13 = DAT_0024a6e8;\n        if ((DAT_0024a6f8 == (char *)0x0) || ((*DAT_0024a6f8 == '.' && (DAT_0024a6f8[1] == '\\0'))))\n        {\n          sVar7 = strlen(pcVar9);\n          pcVar13 = (char *)xmalloc(sVar7 + 1);\n          pcVar13 = strcpy(pcVar13,pcVar9);\n        }\n        else {\n          sVar7 = strlen(pcVar8);\n          if ((rl_complete_with_tilde_expansion == 0) || (*pcVar13 != '~')) {\n            sVar12 = strlen(pcVar13);\n            iVar6 = (int)sVar12;\n            pcVar13 = (char *)xmalloc((long)(iVar6 + 2) + sVar7);\n            pcVar18 = DAT_0024a6e8;\n            strcpy(pcVar13,DAT_0024a6e8);\n            lVar14 = (long)iVar6;\n            if (pcVar18[lVar14 + -1] == '/') goto LAB_001d6de0;\n            pcVar13[lVar14] = '/';\n            pcVar18 = pcVar13 + (iVar6 + 1);\n          }\n          else {\n            sVar12 = strlen(pcVar18);\n            iVar6 = (int)sVar12;\n            pcVar13 = (char *)xmalloc((long)(iVar6 + 2) + sVar7);\n            strcpy(pcVar13,DAT_0024a6f8);\n            lVar14 = (long)iVar6;\n            if (DAT_0024a6f8[lVar14 + -1] == '/') {\nLAB_001d6de0:\n              pcVar18 = pcVar13 + lVar14;\n            }\n            else {\n              pcVar13[lVar14] = '/';\n              pcVar18 = pcVar13 + (iVar6 + 1);\n              *pcVar18 = '\\0';\n            }\n          }\n          strcpy(pcVar18,pcVar9);\n        }\n        if (pcVar9 != pcVar8) {\n          xfree(pcVar9);\n        }\n        goto LAB_001d68a9;\n      }\n      local_50.__count = 0;\n      local_50.__value = (_union_27)0x0;\n      local_48.__count = 0;\n      local_48.__value = (_union_27)0x0;\n      if ((int)DAT_0024a6e0 <= iVar6) {\n        if (_rl_completion_case_fold == 0) {\n          if (*pcVar9 == *DAT_0024a6f0) {\n            iVar6 = strncmp((char *)DAT_0024a6f0,pcVar9,(long)(int)DAT_0024a6e0);\njoined_r0x001d6bcc:\n            if (iVar6 == 0) goto LAB_001d6805;\n          }\n        }\n        else if (_rl_completion_case_map == 0) {\n          sVar7 = __ctype_get_mb_cur_max();\n          if ((1 < sVar7) && (rl_byte_oriented == 0)) {\n            sVar7 = (size_t)(int)uVar21;\n            pcVar13 = pcVar9;\n            do {\n              sVar12 = mbrtowc(&local_58,pcVar13,(long)iVar6,&local_50);\n              sVar15 = mbrtowc(&local_54,(char *)pbVar10,sVar7,&local_48);\n              if ((sVar12 | sVar15) == 0) goto LAB_001d6805;\n              if ((sVar12 < 0xfffffffffffffffe) && (sVar15 < 0xfffffffffffffffe)) {\n                wVar5 = towlower(local_58);\n                local_58 = wVar5;\n                local_54 = towlower(local_54);\n                if (wVar5 != local_54) goto joined_r0x001d6d92;\n                uVar21 = uVar21 - (int)sVar12;\n                pcVar13 = pcVar13 + sVar12;\n                pbVar10 = pbVar10 + sVar12;\n              }\n              else {\n                if (*pcVar13 != *pbVar10) goto joined_r0x001d6d92;\n                uVar21 = uVar21 - 1;\n                pcVar13 = pcVar13 + 1;\n                pbVar10 = pbVar10 + 1;\n              }\n              if (uVar21 == 0) goto LAB_001d6805;\n            } while( true );\n          }\n          ppuVar16 = __ctype_b_loc();\n          bVar2 = *pcVar9;\n          puVar4 = *ppuVar16;\n          _Var19 = (__int32_t)(char)bVar2;\n          if ((*(byte *)((long)puVar4 + (ulong)bVar2 * 2 + 1) & 1) != 0) {\n            pp_Var17 = __ctype_tolower_loc();\n            _Var19 = (*pp_Var17)[bVar2];\n          }\n          bVar2 = *pbVar10;\n          iVar6 = (int)(char)bVar2;\n          if ((*(byte *)((long)puVar4 + (ulong)bVar2 * 2 + 1) & 1) != 0) {\n            pp_Var17 = __ctype_tolower_loc();\n            iVar6 = (*pp_Var17)[bVar2];\n          }\n          if (_Var19 == iVar6) {\n            iVar6 = strncasecmp((char *)pbVar10,pcVar9,(long)(int)uVar21);\n            goto joined_r0x001d6bcc;\n          }\n        }\n        else {\n          sVar7 = __ctype_get_mb_cur_max();\n          if ((1 < sVar7) && (rl_byte_oriented == 0)) {\n            sVar7 = (size_t)(int)uVar21;\n            pcVar13 = pcVar9;\n            do {\n              local_90 = &local_58;\n              sVar12 = mbrtowc(local_90,pcVar13,(long)iVar6,&local_50);\n              sVar15 = mbrtowc(&local_54,(char *)pbVar10,sVar7,&local_48);\n              if ((sVar12 | sVar15) == 0) goto LAB_001d6805;\n              if ((sVar12 < 0xfffffffffffffffe) && (sVar15 < 0xfffffffffffffffe)) {\n                pcVar13 = pcVar13 + sVar12;\n                pbVar10 = pbVar10 + sVar12;\n                uVar21 = uVar21 - (int)sVar12;\n                wVar5 = towlower(local_58);\n                local_58 = wVar5;\n                local_54 = towlower(local_54);\n                if ((((wVar5 != L'-') && (wVar5 != L'_')) ||\n                    ((local_54 != L'-' && (local_54 != L'_')))) && (wVar5 != local_54))\n                goto joined_r0x001d6d92;\n              }\n              else {\n                bVar2 = *pbVar10;\n                if ((*pcVar13 != bVar2) || ((bVar2 == 0x2d || (bVar2 == 0x5f))))\n                goto joined_r0x001d6d92;\n                pcVar13 = pcVar13 + 1;\n                pbVar10 = pbVar10 + 1;\n                uVar21 = uVar21 - 1;\n              }\n              if (uVar21 == 0) goto LAB_001d6805;\n            } while( true );\n          }\n          ppuVar16 = __ctype_b_loc();\n          uVar20 = 0;\n          puVar4 = *ppuVar16;\n          while( true ) {\n            bVar2 = pcVar9[uVar20];\n            _Var19 = (__int32_t)(char)bVar2;\n            if ((*(byte *)((long)puVar4 + (ulong)bVar2 * 2 + 1) & 1) != 0) {\n              pp_Var17 = __ctype_tolower_loc();\n              _Var19 = (*pp_Var17)[bVar2];\n            }\n            bVar3 = pbVar10[uVar20];\n            iVar6 = (int)(char)bVar3;\n            if ((*(byte *)((long)puVar4 + (ulong)bVar3 * 2 + 1) & 1) != 0) {\n              pp_Var17 = __ctype_tolower_loc();\n              iVar6 = (*pp_Var17)[bVar3];\n            }\n            if ((((bVar2 != 0x2d) && (bVar2 != 0x5f)) || ((bVar3 != 0x2d && (bVar3 != 0x5f)))) &&\n               (_Var19 != iVar6)) break;\n            uVar20 = uVar20 + 1;\n            if (uVar21 == uVar20) goto LAB_001d6805;\n          }\n        }\n      }\njoined_r0x001d6d92:\n      if (DAT_0024a700 == (DIR *)0x0) goto LAB_001d6805;\n      pdVar11 = readdir(DAT_0024a700);\n    }\n    if (DAT_0024a700 != (DIR *)0x0) {\n      closedir(DAT_0024a700);\n      DAT_0024a700 = (DIR *)0x0;\n    }\n  }\n  if (DAT_0024a6f8 != (char *)0x0) {\n    xfree();\n    DAT_0024a6f8 = (char *)0x0;\n  }\n  if (DAT_0024a6f0 != (byte *)0x0) {\n    xfree();\n    DAT_0024a6f0 = (byte *)0x0;\n  }\n  pcVar13 = DAT_0024a6e8;\n  if (DAT_0024a6e8 != (char *)0x0) {\n    pcVar13 = (char *)0x0;\n    xfree(DAT_0024a6e8);\n    DAT_0024a6e8 = (char *)0x0;\n  }\nLAB_001d68a9:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pcVar13;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001512b0": "\nuint FUN_001512b0(long param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = *(uint *)(param_1 + 0x28) & 1;\n  if (uVar1 != 0) {\n    uVar1 = (uint)((*(uint *)(param_1 + 0x28) & 0x9000) != 0x1000);\n  }\n  return uVar1;\n}\n\n",
  "_rl_backward_char_internal": "\nint _rl_backward_char_internal(int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  if (param_1 < 1) {\n    iVar1 = 0;\n    if (-1 < rl_point) {\n      iVar1 = rl_point;\n    }\n    return iVar1;\n  }\n  iVar1 = rl_point;\n  if (0 < rl_point) {\n    do {\n      param_1 = param_1 + -1;\n      iVar1 = _rl_find_prev_mbchar(rl_line_buffer,iVar1,1);\n      if (param_1 < 1) break;\n    } while (0 < iVar1);\n    if (param_1 == 0) {\n      iVar2 = 0;\n      if (-1 < iVar1) {\n        iVar2 = iVar1;\n      }\n      return iVar2;\n    }\n  }\n  return 0;\n}\n\n",
  "FUN_001525e0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong FUN_001525e0(long param_1)\n\n{\n  __pid_t _Var1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  _Var1 = getpid();\n  if ((subshell_environment != 0) && (_Var1 != _DAT_002422e8)) {\n    seedrand();\n    _DAT_002422e8 = _Var1;\n    iVar2 = brand();\n    if (iVar2 != last_random_value) goto LAB_0015261d;\n  }\n  do {\n    iVar2 = brand();\n  } while (iVar2 == last_random_value);\nLAB_0015261d:\n  last_random_value = iVar2;\n  uVar3 = itos((long)iVar2);\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x527);\n  }\n  *(undefined8 *)(param_1 + 8) = uVar3;\n  *(uint *)(param_1 + 0x28) = *(uint *)(param_1 + 0x28) | 0x10;\n  return param_1;\n}\n\n",
  "using_history": "\nvoid using_history(void)\n\n{\n  history_offset = history_length;\n  return;\n}\n\n",
  "wctype": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nwctype_t wctype(char *__property)\n\n{\n  wctype_t wVar1;\n  \n  wVar1 = (*(code *)PTR_wctype_00237ad8)();\n  return wVar1;\n}\n\n",
  "array_dispose": "\nvoid array_dispose(long param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 != 0) {\n    array_flush();\n    lVar1 = *(long *)(param_1 + 0x10);\n    if (lVar1 != 0) {\n      if (*(long *)(lVar1 + 8) != 0) {\n        sh_xfree(*(long *)(lVar1 + 8),\"array.c\",0x21e);\n      }\n      sh_xfree(lVar1,\"array.c\",0x21f);\n    }\n    sh_xfree(param_1,\"array.c\",0x7b);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00152a70": "\nlong FUN_00152a70(long param_1)\n\n{\n  size_t sVar1;\n  char *__dest;\n  char *pcVar2;\n  \n  pcVar2 = the_printed_command_except_trap;\n  if ((the_printed_command_except_trap == (char *)0x0) || (*the_printed_command_except_trap == '\\0')\n     ) {\n    pcVar2 = (char *)sh_xmalloc(1,\"variables.c\",0x537);\n    *pcVar2 = '\\0';\n  }\n  else {\n    sVar1 = strlen(the_printed_command_except_trap);\n    __dest = (char *)sh_xmalloc(sVar1 + 1,\"variables.c\",0x534);\n    pcVar2 = strcpy(__dest,pcVar2);\n  }\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x53a);\n  }\n  *(char **)(param_1 + 8) = pcVar2;\n  return param_1;\n}\n\n",
  "__sigsetjmp": "\nvoid __sigsetjmp(void)\n\n{\n  (*(code *)PTR___sigsetjmp_00237e68)();\n  return;\n}\n\n",
  "FUN_00194bb0": "\nundefined8 FUN_00194bb0(char *param_1,int param_2,int *param_3,int *param_4)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uVar3;\n  size_t sVar4;\n  int iVar5;\n  int iVar6;\n  long in_FS_OFFSET;\n  undefined local_42;\n  undefined local_41;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = mbschr(param_1,0x24);\n  if (lVar2 != 0) {\n    iVar5 = (int)*(char *)(lVar2 + 1);\n    if (iVar5 == 0x28) {\n      iVar6 = 0x29;\n    }\n    else {\n      iVar6 = 0x7d;\n      if (iVar5 != 0x7b) {\n        iVar6 = 0;\n        iVar5 = 0;\n        uVar3 = 0x24;\n        goto LAB_00194c0e;\n      }\n    }\n    if (param_2 == 0) {\n      uVar3 = 0x24;\n    }\n    else {\n      local_42 = (undefined)iVar6;\n      local_41 = 0;\n      iVar1 = skip_to_delim(lVar2,1,&local_42,0x101);\n      uVar3 = 0x24;\n      if (iVar6 != *(char *)(lVar2 + iVar1)) {\n        uVar3 = 0;\n      }\n    }\n    goto LAB_00194c0e;\n  }\n  if (*param_1 == '~') {\n    iVar6 = 0;\n    iVar5 = 0;\n    uVar3 = 0x7e;\n    goto LAB_00194c0e;\n  }\n  lVar2 = mbschr(param_1,0x60);\n  if (lVar2 == 0) {\nLAB_00194cca:\n    iVar6 = 0;\n    iVar5 = 0;\n    uVar3 = 0;\n  }\n  else {\n    if (param_2 != 0) {\n      sVar4 = strlen(param_1);\n      iVar5 = unclosed_pair(param_1,sVar4 & 0xffffffff,&DAT_00213e43);\n      if (iVar5 != 0) goto LAB_00194cca;\n    }\n    iVar6 = 0;\n    iVar5 = 0;\n    uVar3 = 0x60;\n  }\nLAB_00194c0e:\n  *param_3 = iVar5;\n  *param_4 = iVar6;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
  "fc_execute_file": "\nvoid fc_execute_file(undefined8 param_1)\n\n{\n  FUN_001a7e10(param_1,0xa3);\n  return;\n}\n\n",
  "FUN_001af6d0": "\nvoid FUN_001af6d0(void)\n\n{\n  if (read_timeout != 0) {\n    shtimer_clear();\n    read_timeout = 0;\n    return;\n  }\n  read_timeout = 0;\n  return;\n}\n\n",
  "push_args": "\nvoid push_args(long *param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long lVar4;\n  \n  lVar1 = find_variable(\"BASH_ARGV\");\n  if (lVar1 != 0) {\n    if ((*(byte *)(lVar1 + 0x28) & 4) == 0) {\n      lVar1 = 0;\n    }\n    else {\n      lVar1 = *(long *)(lVar1 + 8);\n    }\n  }\n  lVar2 = find_variable(\"BASH_ARGC\");\n  if (lVar2 != 0) {\n    if ((*(byte *)(lVar2 + 0x28) & 4) == 0) {\n      lVar2 = 0;\n    }\n    else {\n      lVar2 = *(long *)(lVar2 + 8);\n    }\n  }\n  lVar4 = 0;\n  if (param_1 != (long *)0x0) {\n    do {\n      lVar4 = lVar4 + 1;\n      array_rshift(lVar1,1,*(undefined8 *)param_1[1]);\n      param_1 = (long *)*param_1;\n    } while (param_1 != (long *)0x0);\n  }\n  uVar3 = itos(lVar4);\n  array_rshift(lVar2,1,uVar3);\n  sh_xfree(uVar3,\"variables.c\",0x167b);\n  return;\n}\n\n",
  "array_quote_escapes": "\nlong array_quote_escapes(long param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long lVar4;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  lVar1 = *(long *)(param_1 + 0x10);\n  lVar3 = lVar1;\n  if (lVar1 != 0) {\n    if (*(long *)(param_1 + 8) == 0) {\n      return 0;\n    }\n    lVar4 = *(long *)(lVar1 + 0x10);\n    lVar3 = param_1;\n    if (lVar1 != lVar4) {\n      do {\n        uVar2 = quote_escapes(*(undefined8 *)(lVar4 + 8));\n        if (*(long *)(lVar4 + 8) != 0) {\n          sh_xfree(*(long *)(lVar4 + 8),\"array.c\",0x153);\n        }\n        *(undefined8 *)(lVar4 + 8) = uVar2;\n        lVar4 = *(long *)(lVar4 + 0x10);\n      } while (*(long *)(param_1 + 0x10) != lVar4);\n    }\n  }\n  return lVar3;\n}\n\n",
  "set_default_locale": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid set_default_locale(void)\n\n{\n  char *__s;\n  size_t sVar1;\n  char *__dest;\n  \n  __s = setlocale(6,\"\");\n  _DAT_002489c8 = __s;\n  if (__s != (char *)0x0) {\n    sVar1 = strlen(__s);\n    __dest = (char *)sh_xmalloc(sVar1 + 1,\"locale.c\",0x54);\n    _DAT_002489c8 = strcpy(__dest,__s);\n  }\n  sVar1 = __ctype_get_mb_cur_max();\n  locale_mb_cur_max = (undefined4)sVar1;\n  locale_utf8locale = FUN_0019a3c0();\n  locale_shiftstates = mblen((char *)0x0,0);\n  return;\n}\n\n",
  "rl_execute_next": "\nundefined8 rl_execute_next(undefined4 param_1)\n\n{\n  rl_readline_state = rl_readline_state | 0x20000;\n  rl_pending_input = param_1;\n  return 0;\n}\n\n",
  "wcwidth": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcwidth(wchar_t __c)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wcwidth_00237bd0)();\n  return iVar1;\n}\n\n",
  "display_signal_list": "\nint display_signal_list(long **param_1,int param_2)\n\n{\n  ulong uVar1;\n  uint uVar2;\n  int iVar3;\n  char *pcVar4;\n  undefined *puVar5;\n  ulong extraout_RDX;\n  ulong uVar6;\n  int iVar7;\n  char cVar8;\n  char *__s2;\n  int iVar9;\n  long in_FS_OFFSET;\n  bool bVar10;\n  ulong local_48;\n  long local_40;\n  \n  iVar9 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (long **)0x0) {\n    bVar10 = param_2 == 0;\n    iVar7 = 1;\nLAB_001a4cd3:\n    do {\n      pcVar4 = (char *)signal_name(iVar7);\n      if (*pcVar4 == 'S') {\n        iVar3 = strncmp(pcVar4,\"SIGJUNK\",7);\n        if (iVar3 != 0) {\n          if ((posixly_correct == 0) || (!bVar10)) goto LAB_001a4c9b;\n          if ((pcVar4[1] == 'I') && (pcVar4[2] == 'G')) {\n            pcVar4 = pcVar4 + 3;\n          }\nLAB_001a4d20:\n          puVar5 = &DAT_001fdb1c;\n          if (iVar7 == 0x40) {\n            puVar5 = &DAT_00213d70;\n          }\n          iVar7 = iVar7 + 1;\n          __printf_chk(1,&DAT_001fc632,pcVar4,puVar5);\n          if (iVar7 == 0x41) break;\n          goto LAB_001a4cd3;\n        }\n      }\n      else if ((*pcVar4 != 'U') || (iVar3 = strncmp(pcVar4,\"Unknown\",7), iVar3 != 0)) {\n        if ((posixly_correct != 0) && (bVar10)) goto LAB_001a4d20;\nLAB_001a4c9b:\n        iVar9 = iVar9 + 1;\n        __printf_chk(1,\"%2d) %s\",iVar7,pcVar4);\n        if (iVar9 < 5) {\n          putchar(9);\n        }\n        else {\n          iVar9 = 0;\n          putchar(10);\n        }\n      }\n      iVar7 = iVar7 + 1;\n    } while (iVar7 != 0x41);\n    if (((posixly_correct != 0) && (bVar10)) || (iVar9 != 0)) {\n      iVar9 = 0;\n      putchar(10);\n    }\n  }\n  else {\n    do {\n      while (iVar7 = legal_number(*param_1[1],&local_48), iVar7 == 0) {\n        cVar8 = '\\x03';\n        if (posixly_correct != 0) {\n          cVar8 = (this_shell_builtin != kill_builtin) + '\\x02';\n        }\n        uVar2 = decode_signal(*param_1[1],cVar8);\n        uVar6 = (ulong)uVar2;\n        if (uVar2 == 0xffffffff) goto LAB_001a4be0;\n        __printf_chk(1,\"%d\\n\");\nLAB_001a4b70:\n        param_1 = (long **)*param_1;\n        if (param_1 == (long **)0x0) goto LAB_001a4c03;\n      }\n      if (0x80 < (long)local_48) {\n        local_48 = local_48 - 0x80;\n      }\n      uVar1 = local_48;\n      uVar6 = extraout_RDX;\n      if (local_48 < 0x41) {\n        pcVar4 = (char *)signal_name(local_48 & 0xffffffff);\n        __s2 = \"SIGJUNK\";\n        if (*pcVar4 == 'S') {\nLAB_001a4c3c:\n          iVar7 = strncmp(pcVar4,__s2,7);\n          if (iVar7 == 0) goto LAB_001a4b70;\n        }\n        else if (*pcVar4 == 'U') {\n          __s2 = \"Unknown\";\n          goto LAB_001a4c3c;\n        }\n        if ((this_shell_builtin == kill_builtin) && (uVar1 != 0)) {\n          pcVar4 = pcVar4 + 3;\n        }\n        puts(pcVar4);\n        goto LAB_001a4b70;\n      }\nLAB_001a4be0:\n      iVar9 = 1;\n      builtin_error(\"%s: invalid signal specification\",*param_1[1],uVar6);\n      param_1 = (long **)*param_1;\n    } while (param_1 != (long **)0x0);\n  }\nLAB_001a4c03:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar9;\n}\n\n",
  "FUN_00180f40": "\nvoid FUN_00180f40(int param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar1 = (&DAT_00247e40)[param_1];\n  if ((&trap_list)[param_1] != 1) {\n    uVar2 = uVar1 & 0xffffffbf | 1;\n    if ((uVar1 & 0x10) != 0) {\n      uVar2 = uVar1 & 0xffffffbf | 0x21;\n    }\n    (&DAT_00247e40)[param_1] = uVar2;\n    return;\n  }\n  uVar2 = uVar1 | 0x41;\n  if ((uVar1 & 0x10) != 0) {\n    uVar2 = uVar1 | 0x61;\n  }\n  (&DAT_00247e40)[param_1] = uVar2;\n  return;\n}\n\n",
  "get_urandom32": "\nvoid get_urandom32(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  uint local_3c;\n  uint local_38;\n  uint local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar4 = getrandom(&local_3c,4,1);\n  uVar1 = DAT_0023b314;\n  if (lVar4 != 4) {\n    if (subshell_environment != 0) {\n      gettimeofday((timeval *)&local_38,(__timezone_ptr_t)0x0);\n      uVar2 = getpid();\n      uVar3 = getppid();\n      DAT_0023b314 = uVar1 ^ local_30 ^ local_38 ^ current_user ^ 0x1cce30 ^ uVar2 ^ uVar3;\n    }\n    do {\n      if (DAT_0023b314 == 0) {\n        if (DAT_0024a118 != 0x1f0cce42) {\n          local_3c = 0x1f0cce42;\n          DAT_0023b314 = 0x1f0cce42;\n          break;\n        }\n        DAT_0023b314 = 0x1b95efb;\n        local_3c = DAT_0023b314;\n      }\n      else {\n        DAT_0023b314 = (DAT_0023b314 % 0x1f31d) * 0x41a7 + (DAT_0023b314 / 0x1f31d) * -0xb14;\n        local_3c = DAT_0023b314;\n        if ((int)DAT_0023b314 < 0) {\n          DAT_0023b314 = DAT_0023b314 + 0x7fffffff;\n          local_3c = DAT_0023b314 & 0x7fffffff;\n        }\n      }\n    } while (DAT_0024a118 == local_3c);\n  }\n  DAT_0024a118 = local_3c;\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "shell_execve": "\nint shell_execve(char *param_1,char **param_2,char **param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int *piVar5;\n  char **ppcVar6;\n  ssize_t sVar7;\n  size_t sVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  int iVar12;\n  long in_FS_OFFSET;\n  char local_c8 [136];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  execve(param_1,param_2,param_3);\n  piVar5 = __errno_location();\n  iVar3 = *piVar5;\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (iVar3 == 8) {\n    iVar3 = open(param_1,0);\n    if (iVar3 < 0) {\nLAB_0014a6f4:\n      reset_parser();\n      delete_all_aliases();\n      history_lines_this_session = 0;\n      without_job_control();\n      set_sigchld_handler();\n      init_job_stats();\n      reset_shell_flags();\n      reset_shell_options();\n      reset_shopt_options();\n      if ((*(byte *)(shell_variables + 0xc) & 8) != 0) {\n        shell_variables = *(long *)(shell_variables + 0x18);\n      }\n      clear_unwind_protect_list(0);\n      parse_and_execute_level = 0;\n      sourcenest = 0;\n      evalnest = 0;\n      funcnest = 0;\n      return_catch_flag = 0;\n      variable_context = 0;\n      executing_list = 0;\n      if (interactive_shell == 0) {\n        unset_bash_input(0);\n      }\n      set_sigint_handler();\n      iVar3 = strvec_len(param_2);\n      ppcVar6 = (char **)strvec_resize(param_2,iVar3 + 2);\n      if (iVar3 != 0) {\n        uVar9 = (ulong)(iVar3 - 1);\n        memmove(ppcVar6 + ((long)iVar3 - uVar9),ppcVar6 + (long)iVar3 + (-1 - uVar9),uVar9 * 8 + 8);\n      }\n      pcVar10 = shell_name;\n      ppcVar6[1] = param_1;\n      *ppcVar6 = pcVar10;\n      ppcVar6[iVar3 + 1] = (char *)0x0;\n      if (**ppcVar6 == '-') {\n        *ppcVar6 = *ppcVar6 + 1;\n      }\n      if (restricted != 0) {\n        change_flag(0x72,0x2b);\n      }\n      lVar11 = 0;\n      if (subshell_argv != (char **)0x0) {\n        while (lVar11 = lVar11 + 1, (int)lVar11 < subshell_argc) {\n          sh_xfree(*(undefined8 *)((long)subshell_argv + lVar11 * 8),\"execute_cmd.c\",0x17c7);\n        }\n        sh_xfree(subshell_argv,\"execute_cmd.c\",0x17c8);\n      }\n      dispose_command(DAT_00242178);\n      DAT_00242178 = 0;\n      subshell_envp = param_3;\n      subshell_argv = ppcVar6;\n      subshell_argc = iVar3 + 1;\n      unbind_args();\n      clear_fifo_list();\n                    /* WARNING: Subroutine does not return */\n      __longjmp_chk(subshell_top_level,1);\n    }\n    uVar9 = read(iVar3,local_c8,0x80);\n    iVar2 = (int)uVar9;\n    close(iVar3);\n    if (iVar2 != 0) {\n      if ((iVar2 < 1) || (iVar3 = check_binary_file(local_c8,uVar9 & 0xffffffff), iVar3 == 0))\n      goto LAB_0014a6f4;\n      pcVar10 = strerror(8);\n      internal_error(\"%s: cannot execute binary file: %s\",param_1,pcVar10);\n      *piVar5 = 8;\n      iVar2 = 0x7e;\n    }\n  }\n  else {\n    last_command_exit_value = (iVar3 == 2) + 0x7e;\n    iVar2 = file_isdir(param_1);\n    if (iVar2 == 0) {\n      iVar2 = executable_file(param_1);\n      if (((iVar2 != 0) && (iVar3 != 7)) && (iVar3 != 0xc)) {\n        if (iVar3 == 2) {\n          *piVar5 = 2;\n          internal_error(\"%s: cannot execute: required file not found\",param_1);\n          iVar2 = last_command_exit_value;\n          goto LAB_0014a696;\n        }\n        iVar2 = open(param_1,0);\n        if (-1 < iVar2) {\n          sVar7 = read(iVar2,local_c8,0x80);\n          iVar4 = (int)sVar7;\n          close(iVar2);\n          if (((0 < iVar4) && (local_c8[iVar4 + -1] = '\\0', 2 < iVar4)) &&\n             ((local_c8[0] == '#' && (local_c8[1] == '!')))) {\n            pcVar10 = local_c8 + 2;\n            iVar2 = 2;\n            do {\n              cVar1 = *pcVar10;\n              if ((cVar1 != ' ') && (cVar1 != '\\t')) {\n                iVar12 = iVar2;\n                if (iVar2 < iVar4) {\n                  pcVar10 = local_c8 + iVar2;\n                  goto LAB_0014aa9c;\n                }\n                break;\n              }\n              iVar2 = iVar2 + 1;\n              pcVar10 = pcVar10 + 1;\n              iVar12 = iVar2;\n            } while (iVar4 != iVar2);\nLAB_0014a965:\n            pcVar10 = (char *)substring(local_c8,iVar2,iVar12);\n            sVar8 = strlen(pcVar10);\n            *piVar5 = iVar3;\n            iVar3 = (int)sVar8;\n            if (pcVar10[(long)iVar3 + -1] == '\\r') {\n              pcVar10 = (char *)sh_xrealloc(pcVar10,(long)(iVar3 + 2),\"execute_cmd.c\",0x1778);\n              pcVar10[(long)iVar3 + -1] = '^';\n              pcVar10[iVar3] = 'M';\n              pcVar10[(long)iVar3 + 1] = '\\0';\n              if (pcVar10 == (char *)0x0) {\n                sys_error(\"%s: %s: bad interpreter\",param_1,&DAT_00213d70);\n                iVar2 = 0x7e;\n                goto LAB_0014a696;\n              }\n            }\n            sys_error(\"%s: %s: bad interpreter\",param_1,pcVar10);\n            sh_xfree(pcVar10,\"execute_cmd.c\",0x177e);\n            iVar2 = 0x7e;\n            goto LAB_0014a696;\n          }\n        }\n      }\n      *piVar5 = iVar3;\n      file_error(param_1);\n      iVar2 = last_command_exit_value;\n    }\n    else {\n      pcVar10 = strerror(0x15);\n      internal_error(\"%s: %s\",param_1,pcVar10);\n      iVar2 = last_command_exit_value;\n    }\n  }\nLAB_0014a696:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\nLAB_0014aa9c:\n  if (((byte)(cVar1 - 9U) < 2) || (cVar1 == ' ')) goto LAB_0014a965;\n  iVar12 = iVar12 + 1;\n  pcVar10 = pcVar10 + 1;\n  if (iVar4 == iVar12) goto LAB_0014a965;\n  cVar1 = *pcVar10;\n  goto LAB_0014aa9c;\n}\n\n",
  "dispose_word": "\nvoid dispose_word(long *param_1)\n\n{\n  long lVar1;\n  \n  if (*param_1 != 0) {\n    sh_xfree(*param_1,\"dispose_cmd.c\",0xf9);\n  }\n  if (DAT_00241ec8 <= DAT_00241ecc) {\n    sh_xfree(param_1,\"dispose_cmd.c\",0xfa);\n    return;\n  }\n  *param_1 = -0x2020202020202021;\n  param_1[1] = -0x2020202020202021;\n  lVar1 = (long)DAT_00241ecc;\n  DAT_00241ecc = DAT_00241ecc + 1;\n  *(long **)(wdcache + lVar1 * 8) = param_1;\n  return;\n}\n\n",
  "rl_vi_append_mode": "\nundefined8 rl_vi_append_mode(undefined8 param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  \n  if (rl_point < rl_end) {\n    sVar2 = __ctype_get_mb_cur_max();\n    iVar1 = rl_point;\n    if ((sVar2 == 1) || (rl_byte_oriented != 0)) {\n      rl_point = rl_point + 1;\n    }\n    else {\n      rl_point = _rl_forward_char_internal(1);\n      if ((rl_point == iVar1) || (rl_end < rl_point)) {\n        rl_point = rl_end;\n      }\n    }\n  }\n  DAT_0023b36c = 1;\n  DAT_0023b368 = rl_arg_sign;\n  _rl_vi_last_command = param_2;\n  rl_begin_undo_group();\n  DAT_0024a3c8 = param_2;\n  _rl_keymap = &vi_insertion_keymap;\n  if (_rl_show_mode_in_prompt == 0) {\n    return 0;\n  }\n  _rl_reset_prompt();\n  return 0;\n}\n\n",
  "FUN_001987b0": "\n/* WARNING: Type propagation algorithm not settling */\n\nlong FUN_001987b0(char *param_1,uint param_2,uint param_3)\n\n{\n  byte bVar1;\n  char cVar2;\n  char cVar3;\n  int iVar4;\n  uint uVar5;\n  char *pcVar6;\n  char *pcVar7;\n  long lVar8;\n  ulong uVar9;\n  undefined *puVar10;\n  uint uVar11;\n  ulong uVar12;\n  undefined8 *puVar13;\n  uint uVar14;\n  uint unaff_R13D;\n  uint uVar15;\n  uint uVar16;\n  long in_FS_OFFSET;\n  bool bVar17;\n  uint local_7c;\n  long local_70;\n  int local_60;\n  uint local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  rl_filename_quote_characters = &DAT_001ff3ee;\n  complete_fullquote = 1;\n  rl_ignore_some_completions_function = FUN_00191d90;\n  puVar13 = &DAT_00248880;\n  for (lVar8 = 0x20; lVar8 != 0; lVar8 = lVar8 + -1) {\n    *puVar13 = 0;\n    puVar13 = puVar13 + 1;\n  }\n  uVar12 = 0x20;\n  uVar9 = 9;\n  puVar10 = &DAT_001ff3ee;\n  while( true ) {\n    *(undefined *)((long)&DAT_00248880 + uVar12) = 1;\n    if ((char)uVar9 == '\\0') break;\n    uVar12 = uVar9;\n    uVar9 = (ulong)(byte)puVar10[2];\n    puVar10 = puVar10 + 1;\n  }\n  if (dircomplete_expand == 0) {\n    rl_directory_rewrite_hook = FUN_00195b80;\n    rl_directory_completion_hook = (code *)0x0;\n  }\n  else {\n    rl_directory_completion_hook = FUN_00195b80;\n    rl_directory_rewrite_hook = (code *)0x0;\n  }\n  rl_sort_completion_matches = 1;\n  rl_filename_stat_hook = FUN_00191f40;\n  uVar15 = param_2 - 1;\n  if (-1 < (int)uVar15) {\n    uVar12 = (ulong)(int)uVar15;\n    do {\n      cVar2 = rl_line_buffer[uVar12];\n      iVar4 = (int)uVar12;\n      uVar9 = uVar12 & 0xffffffff;\n      if ((cVar2 != ' ') && (cVar2 != '\\t')) {\n        if ((cVar2 != '\\\"') && (cVar2 != '\\'')) {\n          local_60 = -1;\n          goto LAB_001988d2;\n        }\n        local_60 = (int)cVar2;\n        if ((int)uVar9 == 0) goto LAB_001989b8;\n        uVar12 = (ulong)((int)uVar9 + -1);\n        goto LAB_00198998;\n      }\n      uVar12 = uVar12 - 1;\n      uVar15 = iVar4 - 1;\n    } while ((int)uVar12 != -1);\n  }\n  if ((current_prompt_string != ps1_prompt) && (iVar4 = parser_in_command_position(), iVar4 == 0)) {\n    local_60 = -1;\n    goto LAB_001989d9;\n  }\n  iVar4 = uVar15 - 1;\n  if (iVar4 < 1) {\n    local_60 = -1;\nLAB_0019958b:\n    bVar17 = uVar15 < 2;\n  }\n  else {\n    local_60 = -1;\nLAB_00198a3f:\n    pcVar6 = rl_line_buffer + iVar4;\n    do {\n      if ((*pcVar6 != ' ') && (*pcVar6 != '\\t')) goto LAB_00198a6a;\n      pcVar6 = pcVar6 + -1;\n      iVar4 = iVar4 + -1;\n    } while (iVar4 != 0);\n    bVar17 = (bool)((byte)~(byte)(uVar15 >> 0x18) >> 7);\n  }\n  if (bVar17 == false) {\nLAB_00198a6a:\n    if ((int)uVar15 < 1) {\nLAB_00198b70:\n      cVar3 = *param_1;\n      if (uVar15 != 0) goto LAB_00199375;\n      cVar2 = *rl_line_buffer;\nLAB_00198b8a:\n      if (cVar2 != '`') goto LAB_00198b92;\nLAB_00198cd4:\n      if (cVar3 == '`') goto LAB_00198c5e;\n      iVar4 = unclosed_pair(rl_line_buffer,param_3,&DAT_00213e43);\n      if (iVar4 != 0) goto LAB_00198b92;\n      local_7c = 0xffffffff;\n      if ((*param_1 != '`') || (rl_completion_quote_character == 0x27)) goto LAB_00198ba5;\n      goto LAB_00198b3b;\n    }\n    cVar2 = rl_line_buffer[(int)uVar15];\n    if (cVar2 != '(') goto LAB_00198cc7;\n    if ((rl_line_buffer[iVar4] != '\\0') &&\n       (lVar8 = mbschr(\";|&{(`\",(int)rl_line_buffer[iVar4]), lVar8 != 0)) {\n      cVar3 = *param_1;\n      cVar2 = rl_line_buffer[(int)uVar15];\n      goto LAB_00198b8a;\n    }\n    rl_attempted_completion_over = 1;\n    lVar8 = 0;\n    goto LAB_00198936;\n  }\n  cVar2 = rl_line_buffer[(int)uVar15];\n  if (cVar2 != '(') {\n    if ((int)uVar15 < 1) goto LAB_00198b70;\nLAB_00198cc7:\n    cVar3 = *param_1;\n    if (cVar2 == '`') goto LAB_00198cd4;\n  }\nLAB_00198b92:\n  local_7c = 1;\n  if (*param_1 == '`') {\nLAB_00198c5e:\n    local_7c = 1;\n    if (rl_completion_quote_character != 0x27) goto LAB_00198c6b;\n  }\nLAB_00198ba5:\n  lVar8 = 0;\n  if (prog_completion_enabled != 0) goto LAB_00198903;\n  local_70 = progcomp_search(\"_InitialWorD_\");\n  uVar15 = 0;\nLAB_00198bd3:\n  if (*param_1 == '\\0') goto LAB_00198c00;\n  bVar17 = 0 < (int)local_7c;\n  if ((local_70 != 0) && (bVar17)) {\n    local_7c = 1;\n    goto LAB_00198c00;\n  }\n  goto LAB_00198c1e;\nLAB_001988d2:\n  uVar15 = (uint)uVar9;\n  if (cVar2 == '\\0') {\n    cVar2 = *param_1;\n    local_7c = 0;\n    goto joined_r0x0019911f;\n  }\n  lVar8 = mbschr(\";|&{(`\");\n  if (lVar8 == 0) goto LAB_001989d9;\n  cVar2 = rl_line_buffer[uVar12];\n  if (uVar15 == 0) {\n    iVar4 = char_is_quoted(rl_line_buffer,0);\n    if (iVar4 == 0) {\n      iVar4 = -1;\n      uVar15 = 0;\n      goto LAB_0019958b;\n    }\nLAB_0019920a:\n    cVar2 = *param_1;\n    local_7c = 0xffffffff;\n  }\n  else {\n    bVar1 = rl_line_buffer[uVar12 - 1];\n    if (cVar2 == '&') {\n      if ((bVar1 & 0xfd) != 0x3c) {\nLAB_001992a9:\n        iVar4 = char_is_quoted(rl_line_buffer,uVar9);\n        if (iVar4 == 0) {\n          if (((rl_line_buffer[uVar12] == '(') && (rl_line_buffer[uVar12 - 1] != '\\0')) &&\n             (lVar8 = mbschr(&DAT_001ff6b7,(int)rl_line_buffer[uVar12 - 1]), lVar8 != 0)) {\n            cVar2 = rl_line_buffer[uVar12];\n          }\n          else {\n            iVar4 = uVar15 - 1;\n            if (iVar4 != 0) goto LAB_00198a3f;\n            cVar2 = rl_line_buffer[uVar12];\n            if (cVar2 == '(') goto LAB_00198b92;\n          }\n          goto LAB_00198cc7;\n        }\n        goto LAB_0019920a;\n      }\n      cVar2 = *param_1;\n      local_7c = 0xffffffff;\n    }\n    else {\n      if (((cVar2 != '|') || (bVar1 != 0x3e)) && ((cVar2 != '{' || (bVar1 != 0x24))))\n      goto LAB_001992a9;\n      cVar2 = *param_1;\n      local_7c = 0xffffffff;\n    }\n  }\njoined_r0x0019911f:\n  if ((cVar2 != '`') || (rl_completion_quote_character == 0x27)) goto LAB_001988ee;\nLAB_00198b3b:\n  iVar4 = unclosed_pair(rl_line_buffer,param_2,&DAT_00213e43);\n  if ((iVar4 == 0) || (iVar4 = unclosed_pair(rl_line_buffer,param_3,&DAT_00213e43), iVar4 == 0))\n  goto LAB_001988ee;\nLAB_00198c6b:\n  lVar8 = rl_completion_matches(param_1,FUN_001962d0);\n  uVar15 = prog_completion_enabled;\n  if (prog_completion_enabled != 0) goto LAB_00198903;\nLAB_00198914:\n  local_70 = progcomp_search(\"_InitialWorD_\");\n  if (lVar8 == 0) goto LAB_00198d41;\nLAB_00198936:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar8;\n  }\n  goto LAB_00199597;\n  while (uVar12 = uVar12 - 1, (int)uVar12 != -1) {\nLAB_00198998:\n    cVar2 = rl_line_buffer[uVar12];\n    uVar9 = uVar12 & 0xffffffff;\n    if ((cVar2 != ' ') && (cVar2 != '\\t')) goto LAB_001988d2;\n  }\nLAB_001989b8:\n  if (ps1_prompt != current_prompt_string) {\n    iVar4 = parser_in_command_position();\n    if (iVar4 != 0) {\n      uVar15 = 0xffffffff;\n      iVar4 = -2;\n      goto LAB_0019958b;\n    }\nLAB_001989d9:\n    cVar2 = *param_1;\n    local_7c = 0;\n    goto joined_r0x0019911f;\n  }\n  cVar3 = *param_1;\nLAB_00199375:\n  local_7c = 1;\n  if ((cVar3 == '`') && (rl_completion_quote_character != 0x27)) goto LAB_00198c6b;\nLAB_001988ee:\n  lVar8 = 0;\n  if (prog_completion_enabled != 0) {\nLAB_00198903:\n    iVar4 = progcomp_size();\n    uVar15 = (uint)(0 < iVar4);\n    goto LAB_00198914;\n  }\n  local_70 = progcomp_search(\"_InitialWorD_\");\n  uVar15 = 0;\nLAB_00198d41:\n  if (local_7c != 0) goto LAB_00198bd3;\nLAB_00198c00:\n  if (current_prompt_string == ps1_prompt) {\n    if (DAT_00248988 != 0) {\n      sh_xfree(DAT_00248988,\"bashline.c\",0x68a);\n    }\n    DAT_00248988 = 0;\n    pcVar6 = rl_line_buffer;\n    uVar14 = 0;\n    while (uVar16 = uVar14, iVar4 = skip_to_delim(pcVar6,uVar16,\";|&{(`\",0x101),\n          pcVar6 = rl_line_buffer, iVar4 <= (int)param_2) {\n      cVar2 = rl_line_buffer[iVar4];\n      if (cVar2 == '\\0') break;\n      uVar14 = iVar4 + 1;\n      if ((iVar4 < 1) || (cVar2 != '|')) {\n        if ((cVar2 == '{') && ((int)uVar16 <= iVar4)) {\n          if (((int)uVar16 < iVar4) && ((int)uVar16 < iVar4 + -1)) {\n            lVar8 = (long)(iVar4 + -1);\n            do {\n              cVar2 = rl_line_buffer[lVar8];\n              if ((cVar2 != ' ') && (cVar2 != '\\t')) {\n                bVar1 = rl_line_buffer[(long)iVar4 + 1];\n                uVar12 = (ulong)bVar1;\n                if ((int)lVar8 <= (int)uVar16) goto LAB_00199092;\n                if (rl_line_buffer[(long)iVar4 + -1] == '{') goto LAB_0019909d;\n                pcVar7 = strchr(\";|&{(`\",(int)cVar2);\n                uVar12 = (ulong)bVar1;\n                if (pcVar7 == (char *)0x0) goto LAB_0019909d;\n                goto LAB_00199092;\n              }\n              lVar8 = lVar8 + -1;\n            } while ((int)uVar16 < (int)lVar8);\n          }\n          uVar12 = (ulong)(byte)rl_line_buffer[(long)iVar4 + 1];\nLAB_00199092:\n          if ((*(byte *)(&sh_syntaxtab + uVar12) & 2) == 0) {\nLAB_0019909d:\n            iVar4 = skip_to_delim(pcVar6,uVar14,\";|&{(`\",0x101);\n            if (((int)param_2 < iVar4) || (rl_line_buffer[iVar4] == '\\0')) break;\n            pcVar6 = rl_line_buffer;\n            uVar14 = iVar4 + 1;\n          }\n        }\n      }\n      else if (rl_line_buffer[(long)iVar4 + -1] == '>') {\n        iVar4 = skip_to_delim(rl_line_buffer,uVar14,\";|&{(`\",0x101);\n        if (((int)param_2 < iVar4) || (rl_line_buffer[iVar4] == '\\0')) break;\n        pcVar6 = rl_line_buffer;\n        uVar14 = iVar4 + 1;\n      }\n    }\n    uVar14 = skip_to_delim(rl_line_buffer,param_3,\";|&{(`\",0x101);\n    pcVar6 = (char *)0x0;\n    iVar4 = 0;\n    do {\n      uVar11 = uVar16;\n      uVar5 = unaff_R13D;\n      if ((rl_end < (int)uVar11) || ((iVar4 != 0 && (rl_point < (int)uVar11)))) goto LAB_00198f02;\n      if (pcVar6 != (char *)0x0) {\n        sh_xfree(pcVar6,\"bashline.c\",0x6a4);\n      }\n      if ((rl_line_buffer[(int)uVar11] == ' ') || (rl_line_buffer[(int)uVar11] == '\\t')) {\n        lVar8 = (long)(int)(uVar11 + 1);\n        do {\n          do {\n            pcVar6 = rl_line_buffer + lVar8;\n            uVar11 = (uint)lVar8;\n            lVar8 = lVar8 + 1;\n          } while (*pcVar6 == ' ');\n        } while (*pcVar6 == '\\t');\n      }\n      uVar5 = skip_to_delim(rl_line_buffer,uVar11,&DAT_001ff6c9,0x101);\n      pcVar6 = (char *)substring(rl_line_buffer,uVar11,uVar5);\n      iVar4 = assignment(pcVar6,0);\n      uVar16 = uVar5 + 1;\n      unaff_R13D = uVar5;\n    } while (iVar4 != 0);\n    iVar4 = 0;\n    unaff_R13D = uVar11;\nLAB_00198f02:\n    if ((param_3 | param_2) == 0) {\n      if (uVar14 == 0) {\nLAB_00199232:\n        bVar17 = *param_1 != '\\0';\n        if ((uVar14 != 0) || (unaff_R13D != 0)) {\n          if (((int)unaff_R13D <= (int)param_2) || (bVar17)) goto LAB_00198f2c;\nLAB_00199278:\n          if ((rl_line_buffer[(int)param_2] != ' ') && (rl_line_buffer[(int)param_2] != '\\t'))\n          goto LAB_00198f2c;\n          goto LAB_00198f76;\n        }\n        if (((uVar15 & 1) == 0) || (bVar17)) {\n          if ((param_2 != param_3) || ((-1 < (int)param_2 || (bVar17)))) goto LAB_00199187;\n          goto LAB_00199278;\n        }\nLAB_0019948b:\n        DAT_00248988 = programmable_completions(\"_EmptycmD_\",param_1,0,0,&local_44);\n      }\n      else {\n        if (*param_1 != '\\0') {\n          if (unaff_R13D == 0) goto LAB_00198f26;\n          goto LAB_00198f2c;\n        }\nLAB_00198f76:\n        local_44 = 0;\n      }\n      if ((local_7c != 0) && ((uVar15 & 1) != 0)) {\nLAB_00198f8d:\n        if ((local_70 != 0) && (local_44 == 0)) goto LAB_00199418;\n      }\nLAB_00198fa6:\n      if (pcVar6 != (char *)0x0) goto LAB_00198fab;\n    }\n    else {\n      if (param_2 == param_3) {\n        if ((uVar14 == 0) || (param_2 != unaff_R13D)) goto LAB_00199232;\nLAB_00198f26:\n        if ((int)param_3 < (int)uVar5) goto LAB_00198f76;\nLAB_00198f2c:\n        bVar17 = (int)unaff_R13D < (int)uVar14 && iVar4 == 0;\n        if ((int)uVar14 <= (int)unaff_R13D || iVar4 != 0) {\n          if ((int)uVar14 <= (int)unaff_R13D) goto LAB_00199187;\n          goto LAB_00198f59;\n        }\n        if ((((param_3 == uVar5) && (rl_line_buffer[(int)uVar14] == '\\0')) &&\n            (rl_line_buffer[(long)(int)uVar14 + -1] != ' ')) &&\n           (rl_line_buffer[(long)(int)uVar14 + -1] != '\\t')) {\n          local_44 = 0;\n          local_7c = 0;\n          if (param_2 == unaff_R13D) {\n            if ((*pcVar6 == *param_1) && (iVar4 = strcmp(pcVar6,param_1), iVar4 == 0)) {\n              local_7c = 1;\n              goto LAB_001991d9;\n            }\n          }\n          else if (pcVar6 == (char *)0x0) goto LAB_00198c14;\n          goto LAB_00198fab;\n        }\n        if (uVar15 == 0) goto LAB_00198f59;\n        DAT_00248988 = programmable_completions(pcVar6,param_1,unaff_R13D,uVar14,&local_44);\n        local_7c = 0;\n        if (param_2 != unaff_R13D) goto LAB_00198fa6;\n        if (local_70 == 0) {\n          if (*pcVar6 == *param_1) {\n            iVar4 = strcmp(pcVar6,param_1);\n            local_7c = 0;\n            if (iVar4 == 0) {\n              local_7c = uVar15;\n            }\n          }\n          goto LAB_00198fab;\n        }\n        local_44 = 0;\n        local_7c = uVar15;\nLAB_00199418:\n        DAT_00248988 = programmable_completions(\"_InitialWorD_\",param_1,unaff_R13D,uVar14,&local_44)\n        ;\n        goto LAB_00198fa6;\n      }\n      if ((uVar14 != 0) || (unaff_R13D != 0)) goto LAB_00198f2c;\n      if ((*param_1 == '\\0') && ((uVar15 & 1) != 0)) goto LAB_0019948b;\nLAB_00199187:\n      if ((*pcVar6 == '\\0') && (*param_1 == '\\0')) {\n        cVar2 = '\\0';\n        if ((iVar4 == 0) && (0 < (int)param_2)) {\n          if (rl_line_buffer[(long)(int)param_2 + -1] == '\\0') goto LAB_001991ca;\n          lVar8 = mbschr(\";|&{(`\",(int)rl_line_buffer[(long)(int)param_2 + -1]);\n          if (lVar8 == 0) {\n            if (*pcVar6 != '\\0') goto LAB_00198f59;\n            cVar2 = *param_1;\n            goto LAB_001994fe;\n          }\n          goto LAB_0019946a;\n        }\nLAB_001994fe:\n        if ((cVar2 != '\\0') || (0 >= (int)param_2)) goto LAB_00198f59;\nLAB_001991ca:\n        local_7c = local_7c + iVar4;\n        bVar17 = local_7c != 0;\n        local_44 = 0;\n      }\n      else {\nLAB_00198f59:\n        if (((param_2 != unaff_R13D) || (param_3 != uVar14)) ||\n           ((*pcVar6 != *param_1 ||\n            ((iVar4 = strcmp(pcVar6,param_1), (int)param_2 < 1 || (iVar4 != 0))))))\n        goto LAB_00198f76;\nLAB_0019946a:\n        local_44 = 0;\n        bVar17 = true;\n        local_7c = 1;\n      }\nLAB_001991d9:\n      if (((uVar15 & 1) != 0) && (bVar17)) goto LAB_00198f8d;\nLAB_00198fab:\n      sh_xfree(pcVar6,\"bashline.c\",0x6e4);\n    }\n    if (local_44 != 0) {\n      pcomp_set_readline_variables(local_44,1);\n      lVar8 = rl_completion_matches(param_1,FUN_00191510);\n      if ((local_44 & 2) == 0) {\n        rl_attempted_completion_over = 1;\n      }\n      if ((lVar8 != 0) || ((local_44 & 0x40) == 0)) goto LAB_00198936;\n    }\n  }\nLAB_00198c14:\n  bVar17 = 0 < (int)local_7c;\nLAB_00198c1e:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    lVar8 = bash_default_completion(param_1,param_2,param_3,local_60,bVar17);\n    return lVar8;\n  }\nLAB_00199597:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0015a320": "\nvoid FUN_0015a320(undefined8 *param_1)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  long lVar3;\n  \n  if ((*(uint *)(param_1 + 5) & 0x300001) == 0x300001) {\n    *(uint *)(param_1 + 5) = *(uint *)(param_1 + 5) & 0xffefffff;\n    lVar3 = FUN_00154e30(*param_1,param_1[1],*(undefined8 *)(shell_variables + 0x20),0,0);\n    lVar2 = shell_variables;\n    if (shell_variables == global_variables) {\n      *(uint *)(param_1 + 5) = *(uint *)(param_1 + 5) & 0xffdfffff;\n    }\n    if (lVar3 != 0) {\n      uVar1 = *(undefined4 *)(lVar2 + 8);\n      *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | *(uint *)(param_1 + 5);\n      *(undefined4 *)(lVar3 + 0x2c) = uVar1;\n      dispose_variable(param_1);\n      return;\n    }\n  }\n  else {\n    stupidly_hack_special_variables();\n  }\n  dispose_variable(param_1);\n  return;\n}\n\n",
  "FUN_001b6e20": "\nundefined8 FUN_001b6e20(void)\n\n{\n  assoc_expand_once = expand_once_flag;\n  return 0;\n}\n\n",
  "make_redirection": "\nundefined8 * make_redirection(undefined8 param_1,int param_2,char **param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  size_t sVar3;\n  char *pcVar4;\n  long in_FS_OFFSET;\n  long local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  puVar2 = (undefined8 *)sh_xmalloc(0x30,\"make_cmd.c\",0x2b9);\n  puVar2[1] = param_1;\n  puVar2[4] = param_3;\n  puVar2[5] = 0;\n  *(int *)(puVar2 + 3) = param_2;\n  *(undefined4 *)((long)puVar2 + 0x14) = 0;\n  *(undefined4 *)(puVar2 + 2) = param_4;\n  *puVar2 = 0;\n  switch(param_2) {\n  case 0:\n  case 10:\n  case 0xc:\n    *(undefined4 *)((long)puVar2 + 0x14) = 0x241;\n    break;\n  case 1:\n  case 2:\n  case 4:\n  case 5:\n  case 6:\n  case 7:\n  case 8:\n  case 9:\n  case 0xf:\n  case 0x10:\n  case 0x11:\n  case 0x12:\n    break;\n  case 3:\n  case 0x13:\n    *(undefined4 *)((long)puVar2 + 0x14) = 0x441;\n    break;\n  case 0xb:\n    *(undefined4 *)((long)puVar2 + 0x14) = 0x42;\n    break;\n  case 0xd:\n  case 0xe:\n    pcVar4 = *param_3;\n    sVar3 = strlen(pcVar4);\n    pcVar4 = pcVar4 + ((int)sVar3 + -1);\n    if (*pcVar4 == '-') {\n      *pcVar4 = '\\0';\n      iVar1 = all_digits(*param_3);\n      if (((iVar1 == 0) || (iVar1 = legal_number(*param_3,&local_38), iVar1 == 0)) ||\n         (local_38 != (int)local_38)) {\n        *(uint *)(puVar2 + 3) = (param_2 != 0xd) + 0x11;\n      }\n      else {\n        dispose_word(param_3);\n        *(uint *)(puVar2 + 3) = (param_2 != 0xd) + 0xf;\n        *(int *)(puVar2 + 4) = (int)local_38;\n      }\n    }\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"make_redirection: redirection instruction `%d\\' out of range\",param_2);\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar2;\n}\n\n",
  "get_job_spec": "\nulong get_job_spec(long param_1)\n\n{\n  char cVar1;\n  byte bVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  byte *__nptr;\n  bool bVar6;\n  \n  if (param_1 == 0) {\n    return (ulong)DAT_00238790;\n  }\n  __nptr = **(byte ***)(param_1 + 8);\n  bVar2 = *__nptr;\n  if (bVar2 == 0) {\n    return 0xffffffff;\n  }\n  if (bVar2 == 0x25) {\n    bVar2 = __nptr[1];\n    __nptr = __nptr + 1;\n  }\n  if ((byte)(bVar2 - 0x30) < 10) {\n    iVar3 = all_digits(__nptr);\n    if (iVar3 != 0) {\n      lVar5 = strtol((char *)__nptr,(char **)0x0,10);\n      iVar3 = (int)lVar5;\n      if (iVar3 < 0) {\n        return 0xffffffff;\n      }\n      if (DAT_0023877c < iVar3) {\n        return 0xffffffff;\n      }\n      return (ulong)(iVar3 - 1);\n    }\n    bVar2 = *__nptr;\n    cVar1 = bVar2 - 0x2d;\n    bVar6 = cVar1 == '\\0';\n    if (bVar6) goto LAB_001a4a64;\n  }\n  else {\n    cVar1 = bVar2 - 0x2d;\n    bVar6 = bVar2 == 0x2d;\n    if (bVar6) {\nLAB_001a4a64:\n      return (ulong)DAT_00238794;\n    }\n  }\n  if (bVar6 || SBORROW1(bVar2,'-') != cVar1 < '\\0') {\n    if ((bVar2 < 0x2c) && ((0xfffff7dffffffffeU >> ((ulong)bVar2 & 0x3f) & 1) == 0)) {\n      return (ulong)DAT_00238790;\n    }\n  }\n  else if (bVar2 == 0x3f) {\n    uVar4 = get_job_by_name(__nptr + 1,2);\n    return uVar4;\n  }\n  uVar4 = get_job_by_name(__nptr,0);\n  return uVar4;\n}\n\n",
  "_rl_errmsg": "\nvoid _rl_errmsg(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n               undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n               undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_d0 = &stack0x00000008;\n  local_d8 = 8;\n  local_c8 = local_b8;\n  local_d4 = 0x30;\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  fwrite(\"readline: \",1,10,stderr);\n  __vfprintf_chk(stderr,1,param_9,&local_d8);\n  fputc(10,stderr);\n  fflush(stderr);\n  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "match_pattern_wchar": "\nbool match_pattern_wchar(wint_t *param_1,wint_t *param_2,uint param_3)\n\n{\n  uint uVar1;\n  int iVar2;\n  wint_t __wc;\n  wint_t wVar3;\n  ulong uVar4;\n  \n  __wc = *param_2;\n  wVar3 = *param_1;\n  if (__wc == 0) {\n    return wVar3 == 0x2a;\n  }\n  uVar1 = wVar3 - 0x21;\n  if (uVar1 < 0x3c) {\n    uVar4 = 1L << ((byte)uVar1 & 0x3f);\n    if ((uVar4 & 0x400000040000200) != 0) {\n      return true;\n    }\n    if ((uVar4 & 0x80000401) == 0) {\n      if (uVar1 == 0x3b) {\n        if ((param_3 & 0x10) == 0) {\n          wVar3 = param_1[1];\n        }\n        else {\n          iVar2 = iswupper(__wc);\n          if (iVar2 != 0) {\n            __wc = towlower(__wc);\n          }\n          wVar3 = param_1[1];\n          iVar2 = iswupper(wVar3);\n          if (iVar2 != 0) {\n            wVar3 = towlower(wVar3);\n          }\n        }\n        return wVar3 == __wc;\n      }\n    }\n    else if (param_1[1] == 0x28) {\n      return true;\n    }\n  }\n  if ((param_3 & 0x10) != 0) {\n    iVar2 = iswupper(__wc);\n    if (iVar2 != 0) {\n      __wc = towlower(__wc);\n    }\n    iVar2 = iswupper(wVar3);\n    if (iVar2 != 0) {\n      wVar3 = towlower(wVar3);\n    }\n  }\n  return wVar3 == __wc;\n}\n\n",
  "tteightbit": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint tteightbit(void)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  termios local_58;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00249ee0 == 0) {\n    iVar1 = -1;\n  }\n  else {\n    local_58._48_8_ = DAT_00249f70;\n    local_58.c_oflag = tRam0000000000249f44;\n    local_58.c_lflag = tRam0000000000249f4c;\n    local_58.c_ospeed = DAT_00249f78;\n    local_58.c_iflag = _DAT_00249f40 & 0xffffffdf;\n    local_58._16_4_ = _DAT_00249f50;\n    local_58.c_cc._3_4_ = uRam0000000000249f54;\n    local_58.c_cc._7_4_ = uRam0000000000249f58;\n    local_58.c_cc._11_4_ = uRam0000000000249f5c;\n    local_58.c_cflag = uRam0000000000249f48 & 0xfffffeff | 0x30;\n    local_58.c_cc._15_4_ = _DAT_00249f60;\n    local_58.c_cc._19_4_ = uRam0000000000249f64;\n    local_58.c_cc._23_4_ = uRam0000000000249f68;\n    local_58.c_cc._27_4_ = uRam0000000000249f6c;\n    iVar1 = tcsetattr(0,1,&local_58);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "utf8_mblen": "\nuint utf8_mblen(byte *param_1,long param_2)\n\n{\n  byte bVar1;\n  byte bVar2;\n  \n  if (param_1 == (byte *)0x0) {\n    return 0;\n  }\n  if (param_2 != 0) {\n    bVar1 = *param_1;\n    if (-1 < (char)bVar1) {\n      return (uint)(bVar1 != 0);\n    }\n    if (0xc1 < bVar1) {\n      bVar2 = param_1[1];\n      if (bVar1 < 0xe0) {\n        if (param_2 != 1) {\n          return (-(uint)((byte)(bVar2 + 0x80) < 0x40) & 3) - 1;\n        }\n      }\n      else if (bVar1 < 0xf0) {\n        if (param_2 != 1) {\n          if (0x3f < (byte)(bVar2 + 0x80)) {\n            return 0xffffffff;\n          }\n          if ((bVar1 < 0xe1) && (bVar2 < 0xa0)) {\n            return 0xffffffff;\n          }\n          if ((bVar1 == 0xed) && (0x9f < bVar2)) {\n            return 0xffffffff;\n          }\n          if (param_2 != 2) {\n            return (-(uint)((byte)(param_1[2] + 0x80) < 0x40) & 4) - 1;\n          }\n        }\n      }\n      else {\n        if (0xf4 < bVar1) {\n          return 0xffffffff;\n        }\n        if (param_2 != 1) {\n          if (0x3f < (byte)(bVar2 + 0x80)) {\n            return 0xffffffff;\n          }\n          if ((bVar1 < 0xf1) && (bVar2 < 0x90)) {\n            return 0xffffffff;\n          }\n          if ((bVar1 == 0xf4) && (0x8f < bVar2)) {\n            return 0xffffffff;\n          }\n          if (param_2 != 2) {\n            if (0x3f < (byte)(param_1[2] + 0x80)) {\n              return 0xffffffff;\n            }\n            if (param_2 != 3) {\n              return (-(uint)((byte)(param_1[3] + 0x80) < 0x40) & 5) - 1;\n            }\n          }\n        }\n      }\n      return 0xfffffffe;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
  "legal_number": "\nundefined8 legal_number(long param_1,undefined8 *param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (param_2 != (undefined8 *)0x0) {\n    *param_2 = 0;\n  }\n  if (param_1 != 0) {\n    uVar1 = FUN_001411c0();\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "check_add_history": "\nundefined4 check_add_history(char *param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  char **ppcVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  char *__s;\n  size_t sVar6;\n  char *__dest;\n  \n  if (history_control == 0) {\n    if ((DAT_00238d30 == 0) || (DAT_00238d30 < 1)) goto LAB_001910e5;\nLAB_00190fdc:\n    lVar4 = 0;\n    do {\n      ppcVar3 = (char **)(DAT_00238d28 + lVar4 * 0x10);\n      __s = *ppcVar3;\n      if ((*(byte *)((long)ppcVar3 + 0xc) & 1) != 0) {\n        using_history();\n        puVar5 = (undefined8 *)previous_history();\n        using_history();\n        if (puVar5 == (undefined8 *)0x0) {\n          sVar6 = strlen(__s);\n          __dest = (char *)sh_xmalloc(sVar6 + 1,\"bashhist.c\",0x412);\n          __s = strcpy(__dest,__s);\n        }\n        else {\n          __s = (char *)strcreplace(__s,0x26,*puVar5,1);\n        }\n      }\n      iVar1 = strmatch(__s,param_1,(ulong)(extended_glob != 0) << 5);\n      if ((*(byte *)(DAT_00238d28 + 0xc + lVar4 * 0x10) & 1) != 0) {\n        sh_xfree(__s,\"bashhist.c\",0x42f);\n      }\n      if (iVar1 != 1) {\n        return 0;\n      }\n      lVar4 = lVar4 + 1;\n    } while ((int)lVar4 < DAT_00238d30);\n  }\n  else {\n    if (((history_control & 1) != 0) && (*param_1 == ' ')) {\n      return 0;\n    }\n    if ((history_control & 2) != 0) {\n      using_history();\n      ppcVar3 = (char **)previous_history();\n      if (((ppcVar3 != (char **)0x0) && (**ppcVar3 == *param_1)) &&\n         (iVar1 = strcmp(*ppcVar3,param_1), iVar1 == 0)) {\n        using_history();\n        return 0;\n      }\n      using_history();\n    }\n    if ((DAT_00238d30 != 0) && (0 < DAT_00238d30)) goto LAB_00190fdc;\n  }\n  if ((history_control & 4) != 0) {\n    using_history();\n    while (ppcVar3 = (char **)previous_history(), ppcVar3 != (char **)0x0) {\n      if ((**ppcVar3 == *param_1) && (iVar1 = strcmp(*ppcVar3,param_1), iVar1 == 0)) {\n        uVar2 = where_history();\n        lVar4 = remove_history(uVar2);\n        if (lVar4 != 0) {\n          free_history_entry(lVar4);\n        }\n      }\n    }\n    using_history();\n  }\nLAB_001910e5:\n  if (param_2 == 0) {\n    bash_add_history(param_1);\n  }\n  else {\n    hist_last_line_added = 1;\n    hist_last_line_pushed = 0;\n    add_history(param_1);\n    history_lines_this_session = history_lines_this_session + 1;\n    using_history();\n  }\n  return 1;\n}\n\n",
  "FUN_001a3b30": "\nvoid FUN_001a3b30(void)\n\n{\n  builtin_error(\"too many arguments\");\n  top_level_cleanup();\n                    /* WARNING: Subroutine does not return */\n  jump_to_top_level(2);\n}\n\n",
  "unalias_builtin": "\nulong unalias_builtin(undefined8 param_1)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  long *plVar3;\n  bool bVar4;\n  \n  bVar4 = false;\n  reset_internal_getopt();\n  do {\n    iVar1 = internal_getopt(param_1,&DAT_0020f48f);\n    if (iVar1 == -1) {\n      if (bVar4) {\n        delete_all_aliases();\n        return 0;\n      }\n      iVar1 = 0;\n      plVar3 = loptend;\n      if (loptend != (long *)0x0) {\n        do {\n          puVar2 = (undefined8 *)find_alias(*(undefined8 *)plVar3[1]);\n          if (puVar2 == (undefined8 *)0x0) {\n            iVar1 = iVar1 + 1;\n            sh_notfound(*(undefined8 *)plVar3[1]);\n          }\n          else {\n            remove_alias(*puVar2);\n          }\n          plVar3 = (long *)*plVar3;\n        } while (plVar3 != (long *)0x0);\n        return (ulong)(iVar1 != 0);\n      }\n      break;\n    }\n    if (iVar1 == -99) {\n      builtin_help();\n      return 0x102;\n    }\n    bVar4 = true;\n  } while (iVar1 == 0x61);\n  builtin_usage();\n  return 0x102;\n}\n\n",
  "rl_history_search_backward": "\nundefined8 rl_history_search_backward(int param_1,undefined4 param_2)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  if ((rl_last_func != rl_history_search_forward) && (rl_last_func != rl_history_search_backward)) {\n    FUN_001d4840(1);\n  }\n  if (DAT_0024a46c != 0) {\n    iVar2 = -param_1;\n    if (0 < param_1) {\n      iVar2 = param_1;\n    }\n    uVar1 = FUN_001d4900(iVar2,((param_1 < 1) - 1) + (uint)(param_1 < 1));\n    return uVar1;\n  }\n  uVar1 = rl_get_previous_history(param_1,param_2);\n  return uVar1;\n}\n\n",
  "wcscoll": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcscoll(wchar_t *__s1,wchar_t *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wcscoll_00237890)();\n  return iVar1;\n}\n\n",
  "sh_xfree": "\nvoid sh_xfree(long param_1)\n\n{\n  if (param_1 != 0) {\n    sh_free();\n    return;\n  }\n  return;\n}\n\n",
  "cfree": "\nvoid cfree(void *__ptr)\n\n{\n  FUN_001f8ee0(__ptr,0,0);\n  return;\n}\n\n",
  "ansic_shouldquote": "\nulong ansic_shouldquote(byte *param_1)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  uint uVar3;\n  ushort **ppuVar4;\n  ulong uVar5;\n  \n  if (param_1 != (byte *)0x0) {\n    bVar2 = *param_1;\n    while (bVar2 != 0) {\n      uVar3 = *(uint *)(is_basic_table + (ulong)(bVar2 >> 5) * 4) >> (bVar2 & 0x1f) & 1;\n      if (uVar3 == 0) {\n        uVar5 = ansic_wshouldquote(param_1);\n        return uVar5;\n      }\n      ppuVar4 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar4 + (ulong)bVar2 * 2 + 1) & 0x40) == 0) {\n        return (ulong)uVar3;\n      }\n      pbVar1 = param_1 + 1;\n      param_1 = param_1 + 1;\n      bVar2 = *pbVar1;\n    }\n  }\n  return 0;\n}\n\n",
  "FUN_0017b240": "\nundefined8 FUN_0017b240(char *param_1,uint param_2)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long lVar3;\n  undefined8 uVar4;\n  long *plVar5;\n  \n  if (*param_1 != '\\0') {\n    if ((param_2 & 3) != 0) {\n      param_2 = 8;\n    }\n    plVar2 = (long *)FUN_0017b140(param_1,param_2);\n    plVar5 = plVar2;\n    if (plVar2 != (long *)0x0) {\n      do {\n        remove_quoted_nulls(*(undefined8 *)plVar5[1]);\n        plVar1 = plVar5 + 1;\n        plVar5 = (long *)*plVar5;\n        *(uint *)(*plVar1 + 8) = *(uint *)(*plVar1 + 8) & 0xfffbffff;\n      } while (plVar5 != (long *)0x0);\n      goto LAB_0017b28f;\n    }\n  }\n  plVar2 = (long *)0x0;\nLAB_0017b28f:\n  lVar3 = string_list_internal(plVar2,&DAT_001fdb1c);\n  uVar4 = 0;\n  dispose_words(plVar2);\n  if (lVar3 != 0) {\n    uVar4 = quote_string_for_globbing(lVar3,1);\n    sh_xfree(lVar3,\"subst.c\",0x1679);\n  }\n  return uVar4;\n}\n\n",
  "rl_exchange_point_and_mark": "\nundefined8 rl_exchange_point_and_mark(void)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = rl_point;\n  if (rl_end < rl_mark) {\n    rl_mark = -1;\n  }\n  else if (-1 < rl_mark) {\n    rl_point = rl_mark;\n    _rl_keep_mark_active = _rl_keep_mark_active + 1;\n    rl_mark = uVar1;\n    DAT_0024b688 = 1;\n    return 0;\n  }\n  rl_ding();\n  rl_mark = 0;\n  return 1;\n}\n\n",
  "FUN_00133580": "\n/* WARNING: Removing unreachable block (ram,0x00133593) */\n/* WARNING: Removing unreachable block (ram,0x0013359f) */\n\nvoid FUN_00133580(void)\n\n{\n  return;\n}\n\n",
  "cleanup_the_pipeline": "\nvoid cleanup_the_pipeline(void)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long *plVar3;\n  long in_FS_OFFSET;\n  sigset_t sStack_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_138);\n  sigaddset(&sStack_138,0x11);\n  sigemptyset(&local_b8);\n  sigprocmask(0,&sStack_138,&local_b8);\n  plVar2 = the_pipeline;\n  the_pipeline = (long *)0x0;\n  sigprocmask(2,&local_b8,(sigset_t *)0x0);\n  plVar3 = plVar2;\n  if (plVar2 != (long *)0x0) {\n    do {\n      plVar1 = (long *)*plVar3;\n      if (plVar3[3] != 0) {\n        sh_xfree(plVar3[3],\"jobs.c\",0x5c2);\n      }\n      sh_xfree(plVar3,\"jobs.c\",0x5c3);\n      plVar3 = plVar1;\n    } while (plVar2 != plVar1);\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "spname": "\nulong spname(char *param_1,char *param_2)\n\n{\n  char *pcVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  DIR *__dirp;\n  dirent *pdVar5;\n  ulong uVar6;\n  char cVar7;\n  char *pcVar8;\n  char *pcVar9;\n  char *pcVar10;\n  char *__s2;\n  char *__s1;\n  long in_FS_OFFSET;\n  char local_2058 [4096];\n  char local_1058 [16];\n  char local_1048;\n  char local_1047;\n  char local_1046 [4102];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar9 = param_1;\n  pcVar10 = param_2;\nLAB_001c84cf:\n  do {\n    cVar2 = *pcVar9;\n    while (cVar2 != '/') {\n      *pcVar10 = '\\0';\n      cVar2 = *pcVar9;\n      if (cVar2 == '\\0') {\n        if ((((param_1[1] != '\\0') || (param_2[1] != '\\0')) || (*param_1 == '.')) ||\n           (*param_2 != '.')) {\n          iVar4 = strcmp(param_1,param_2);\n          uVar6 = (ulong)(iVar4 != 0);\n          goto LAB_001c85cd;\n        }\nLAB_001c85c8:\n        uVar6 = 0xffffffff;\nLAB_001c85cd:\n        if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n          return uVar6;\n        }\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      pcVar8 = local_2058;\n      if (cVar2 != '/') {\n        do {\n          if (pcVar8 < local_1058) {\n            *pcVar8 = cVar2;\n            pcVar8 = pcVar8 + 1;\n          }\n          cVar2 = pcVar9[1];\n          pcVar9 = pcVar9 + 1;\n        } while ((cVar2 != '/') && (cVar2 != '\\0'));\n      }\n      *pcVar8 = '\\0';\n      pcVar8 = \".\";\n      if (*param_2 != '\\0') {\n        pcVar8 = param_2;\n      }\n      __dirp = opendir(pcVar8);\n      if (__dirp == (DIR *)0x0) goto LAB_001c85c8;\n      iVar4 = 3;\nLAB_001c8540:\n      pdVar5 = readdir(__dirp);\n      if (pdVar5 != (dirent *)0x0) {\n        while( true ) {\n          pcVar8 = pdVar5->d_name;\n          cVar2 = pdVar5->d_name[0];\n          __s2 = local_2058;\n          __s1 = pcVar8;\n          cVar7 = local_2058[0];\n          if (cVar2 == local_2058[0]) {\n            do {\n              if (cVar2 == '\\0') {\n                __strcpy_chk(&local_1048,pcVar8,0x1001);\n                closedir(__dirp);\n                if (local_1048 != '.') goto LAB_001c872a;\n                if (local_1047 == '\\0') goto LAB_001c85c8;\n                goto LAB_001c8796;\n              }\n              cVar2 = __s1[1];\n              pcVar1 = __s2 + 1;\n              __s1 = __s1 + 1;\n              __s2 = __s2 + 1;\n              cVar7 = *pcVar1;\n            } while (cVar2 == *pcVar1);\n          }\n          if (cVar2 == '\\0') break;\n          if (cVar7 != '\\0') {\n            if (((__s1[1] != '\\0') && (cVar2 == __s2[1] && __s2[1] != '\\0')) &&\n               ((__s1[1] == cVar7 && (iVar3 = strcmp(__s1 + 2,__s2 + 2), iVar3 == 0)))) {\n              iVar4 = 1;\n              goto LAB_001c880b;\n            }\n            iVar3 = strcmp(__s1 + 1,__s2 + 1);\n            if ((iVar3 != 0) && (iVar3 = strcmp(__s1 + 1,__s2), iVar3 != 0)) goto LAB_001c8694;\n            goto LAB_001c86b1;\n          }\n          iVar3 = strcmp(__s1 + 1,__s2);\n          if (iVar3 == 0) goto LAB_001c86b1;\n          pdVar5 = readdir(__dirp);\n          if (pdVar5 == (dirent *)0x0) goto LAB_001c870b;\n        }\n        if (cVar7 == '\\0') goto LAB_001c8540;\nLAB_001c8694:\n        iVar3 = strcmp(__s1,__s2 + 1);\n        if (iVar3 != 0) goto LAB_001c8540;\nLAB_001c86b1:\n        if (iVar4 != 1) {\n          iVar4 = 2;\nLAB_001c880b:\n          __strcpy_chk(&local_1048,pcVar8,0x1001);\n        }\n        goto LAB_001c8540;\n      }\nLAB_001c870b:\n      closedir(__dirp);\n      if (local_1048 == '.') {\n        if ((local_1047 == '\\0') || (iVar4 == 3)) goto LAB_001c85c8;\nLAB_001c8796:\n        *pcVar10 = '.';\n      }\n      else {\n        if (iVar4 == 3) goto LAB_001c85c8;\nLAB_001c872a:\n        *pcVar10 = local_1048;\n        if (local_1048 == '\\0') goto LAB_001c84cf;\n      }\n      pcVar8 = &local_1047;\n      cVar2 = local_1047;\n      while( true ) {\n        pcVar10 = pcVar10 + 1;\n        pcVar8 = pcVar8 + 1;\n        *pcVar10 = cVar2;\n        if (cVar2 == '\\0') break;\n        cVar2 = *pcVar8;\n      }\n      cVar2 = *pcVar9;\n    }\n    *pcVar10 = '/';\n    pcVar9 = pcVar9 + 1;\n    pcVar10 = pcVar10 + 1;\n  } while( true );\n}\n\n",
  "FUN_0015a310": "\nvoid FUN_0015a310(undefined8 param_1)\n\n{\n  FUN_0015a140(param_1,1);\n  return;\n}\n\n",
  "bash_logout": "\nvoid bash_logout(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (login_shell != 0) {\n    uVar1 = DAT_00248aac + 1;\n    uVar2 = DAT_00248aac | subshell_environment;\n    DAT_00248aac = uVar1;\n    if (uVar2 == 0) {\n      maybe_execute_file(\"~/.bash_logout\",1);\n      return;\n    }\n  }\n  return;\n}\n\n",
  "sh_notbuiltin": "\nvoid sh_notbuiltin(undefined8 param_1)\n\n{\n  builtin_error(\"%s: not a shell builtin\",param_1);\n  return;\n}\n\n",
  "FUN_00192f00": "\nvoid FUN_00192f00(void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)get_string_value(\"HOSTFILE\");\n  if (pcVar1 == (char *)0x0) {\n    pcVar1 = (char *)get_string_value(\"hostname_completion_file\");\n    if (pcVar1 == (char *)0x0) {\n      pcVar1 = \"/etc/hosts\";\n    }\n  }\n  FUN_00192b60(pcVar1);\n  if (DAT_00248860 != 0) {\n    hostname_list_initialized = hostname_list_initialized + 1;\n  }\n  return;\n}\n\n",
  "extract_colon_unit": "\nundefined * extract_colon_unit(char *param_1,int *param_2)\n\n{\n  char *pcVar1;\n  char cVar2;\n  size_t sVar3;\n  undefined *puVar4;\n  char *pcVar5;\n  int iVar6;\n  int iVar7;\n  \n  if (param_1 == (char *)0x0) {\n    return (undefined *)0x0;\n  }\n  sVar3 = strlen(param_1);\n  iVar7 = *param_2;\n  if ((int)sVar3 <= iVar7) {\n    return (undefined *)0x0;\n  }\n  if (iVar7 == 0) {\n    cVar2 = *param_1;\n    pcVar5 = param_1;\nLAB_001424a6:\n    if (cVar2 != ':') goto LAB_001424aa;\n  }\n  else {\n    pcVar5 = param_1 + iVar7;\n    cVar2 = *pcVar5;\n    if (cVar2 == ':') {\n      iVar7 = iVar7 + 1;\n      pcVar5 = param_1 + iVar7;\n      cVar2 = *pcVar5;\n      goto LAB_001424a6;\n    }\nLAB_001424aa:\n    if (cVar2 != '\\0') {\n      pcVar1 = param_1 + (long)iVar7 + 1;\n      do {\n        pcVar5 = pcVar1;\n        iVar6 = ((iVar7 + 1) - (int)(param_1 + (long)iVar7 + 1)) + (int)pcVar5;\n        if (*pcVar5 == '\\0') break;\n        pcVar1 = pcVar5 + 1;\n      } while (*pcVar5 != ':');\n      *param_2 = iVar6;\n      if (iVar7 != iVar6) {\n        puVar4 = (undefined *)substring(param_1,iVar7,iVar6);\n        return puVar4;\n      }\n      goto LAB_0014251e;\n    }\n  }\n  *param_2 = iVar7;\n  iVar6 = iVar7;\nLAB_0014251e:\n  if (*pcVar5 != '\\0') {\n    *param_2 = iVar6 + 1;\n  }\n  puVar4 = (undefined *)sh_xmalloc(1,\"general.c\",0x416);\n  *puVar4 = 0;\n  return puVar4;\n}\n\n",
  "rl_beg_of_line": "\nundefined8 rl_beg_of_line(void)\n\n{\n  rl_point = 0;\n  return 0;\n}\n\n",
  "all_digits": "\nvoid all_digits(void)\n\n{\n  FUN_001415eb();\n  return;\n}\n\n",
  "char_is_quoted": "\nint char_is_quoted(byte *param_1,int param_2)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  mbstate_t mVar3;\n  size_t sVar4;\n  size_t sVar5;\n  byte bVar6;\n  long lVar7;\n  byte *pbVar8;\n  int iVar9;\n  int iVar10;\n  long in_FS_OFFSET;\n  mbstate_t local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50.__count = 0;\n  local_50.__value = (_union_27)0x0;\n  sVar4 = strlen((char *)param_1);\n  uVar2 = no_longjmp_on_fatal_error;\n  no_longjmp_on_fatal_error = 1;\n  if ((current_command_line_count < 1) || (DAT_00240a18 < 1)) {\n    if (-1 < param_2) {\n      bVar6 = *param_1;\n      iVar10 = 0;\n      lVar7 = 0;\n      pbVar8 = param_1;\n      goto LAB_0016d262;\n    }\nLAB_0016d2d0:\n    iVar10 = 0;\n  }\n  else {\n    cVar1 = *(char *)(dstack + -1 + (long)DAT_00240a18);\n    if (cVar1 == '\\'') {\n      local_48.__count = 0;\n      local_48.__value = (_union_27)0x0;\n      bVar6 = *param_1;\n      if ((bVar6 == 0x27) || (bVar6 == 0)) {\n        iVar10 = 0;\n      }\n      else {\n        iVar10 = 0;\n        lVar7 = 0;\n        pbVar8 = param_1;\n        do {\n          mVar3 = local_48;\n          if (locale_mb_cur_max < 2) {\nLAB_0016d5f6:\n            iVar10 = iVar10 + 1;\n          }\n          else {\n            if ((*(uint *)(is_basic_table + (ulong)(bVar6 >> 5) * 4) >> (bVar6 & 0x1f) & 1) == 0) {\n              if ((locale_utf8locale == 0) || (sVar5 = 1, (char)bVar6 < '\\0')) {\n                sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar8,sVar4 - lVar7,&local_48);\n                if (0xfffffffffffffffd < sVar5) {\n                  iVar10 = iVar10 + 1;\n                  local_48 = mVar3;\n                  goto LAB_0016d5da;\n                }\n                if (sVar5 == 0) goto LAB_0016d5f6;\n              }\n            }\n            else {\n              sVar5 = 1;\n            }\n            iVar10 = iVar10 + (int)sVar5;\n          }\nLAB_0016d5da:\n          lVar7 = (long)iVar10;\n          pbVar8 = param_1 + lVar7;\n          bVar6 = *pbVar8;\n        } while ((bVar6 != 0) && (bVar6 != 0x27));\n      }\n      iVar10 = (iVar10 + 1) - (uint)(bVar6 == 0);\n    }\n    else {\n      iVar10 = 0;\n      if (cVar1 == '\\\"') {\n        iVar10 = FUN_0016a7c0(param_1,sVar4,0,0x400);\n      }\n    }\n    if (iVar10 <= param_2) {\n      lVar7 = (long)iVar10;\n      bVar6 = param_1[lVar7];\n      pbVar8 = param_1 + lVar7;\nLAB_0016d262:\n      do {\n        mVar3 = local_50;\n        if (bVar6 == 0x5c) {\n          iVar9 = iVar10 + 1;\n          if (param_2 < iVar9) goto LAB_0016d2d0;\n          if (param_2 == iVar9) break;\n          bVar6 = param_1[iVar9];\n          if (locale_mb_cur_max < 2) {\n            iVar10 = iVar10 + 2;\n            if (iVar10 <= param_2) goto LAB_0016d256;\n            goto LAB_0016d2d0;\n          }\n          if ((*(uint *)(is_basic_table + (ulong)(bVar6 >> 5) * 4) >> (bVar6 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale == 0) || ((char)bVar6 < '\\0')) {\n              sVar5 = mbrtowc((wchar_t *)0x0,(char *)(param_1 + iVar9),sVar4 - (long)iVar9,&local_50\n                             );\n              if (sVar5 < 0xfffffffffffffffe) {\n                if (sVar5 == 0) goto LAB_0016d359;\n                goto LAB_0016d3a5;\n              }\n              iVar10 = iVar10 + 2;\n              local_50 = mVar3;\n            }\n            else {\n              if (bVar6 != 0) goto LAB_0016d3a0;\nLAB_0016d359:\n              iVar10 = iVar10 + 2;\n            }\n          }\n          else {\nLAB_0016d3a0:\n            sVar5 = 1;\nLAB_0016d3a5:\n            iVar10 = iVar9 + (int)sVar5;\n          }\njoined_r0x0016d422:\n          if (param_2 < iVar10) goto LAB_0016d2d0;\n        }\n        else if (bVar6 == 0x24) {\n          if ((param_1[lVar7 + 1] != 0x27) || (param_1[lVar7 + 2] == 0)) {\nLAB_0016d27b:\n            if (locale_mb_cur_max < 2) {\n              iVar10 = iVar10 + 1;\n              local_50 = mVar3;\n              goto joined_r0x0016d422;\n            }\n            if ((*(uint *)(is_basic_table + (ulong)(bVar6 >> 5) * 4) >> (bVar6 & 0x1f) & 1) == 0) {\n              if ((locale_utf8locale == 0) || ((char)bVar6 < '\\0')) {\n                sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar8,sVar4 - lVar7,&local_50);\n                if ((sVar5 < 0xfffffffffffffffe) && (mVar3 = local_50, sVar5 != 0))\n                goto LAB_0016d3c5;\n              }\n              else if (bVar6 != 0) goto LAB_0016d3c0;\n              local_50 = mVar3;\n              iVar10 = iVar10 + 1;\n            }\n            else {\nLAB_0016d3c0:\n              sVar5 = 1;\nLAB_0016d3c5:\n              iVar10 = iVar10 + (int)sVar5;\n            }\n            goto joined_r0x0016d422;\n          }\n          iVar10 = FUN_00167020(param_1,sVar4,iVar10 + 2,0x400);\n          if (param_2 < iVar10) goto LAB_0016d2d3;\n        }\n        else {\n          if ((bVar6 != 0x27) && (bVar6 != 0x22)) goto LAB_0016d27b;\n          iVar10 = iVar10 + 1;\n          if (bVar6 == 0x27) {\n            local_48.__count = 0;\n            local_48.__value = (_union_27)0x0;\nLAB_0016d440:\n            lVar7 = (long)iVar10;\n            pbVar8 = param_1 + lVar7;\n            bVar6 = *pbVar8;\n            if (bVar6 != 0) {\n              while( true ) {\n                mVar3 = local_48;\n                if (bVar6 == 0x27) goto LAB_0016d498;\n                if (locale_mb_cur_max < 2) break;\n                if ((*(uint *)(is_basic_table + (ulong)(bVar6 >> 5) * 4) >> (bVar6 & 0x1f) & 1) == 0\n                   ) {\n                  if ((locale_utf8locale == 0) || (iVar9 = 1, (char)bVar6 < '\\0')) {\n                    sVar5 = mbrtowc((wchar_t *)0x0,(char *)pbVar8,sVar4 - lVar7,&local_48);\n                    if (0xfffffffffffffffd < sVar5) {\n                      iVar10 = iVar10 + 1;\n                      local_48 = mVar3;\n                      goto LAB_0016d440;\n                    }\n                    iVar9 = (int)sVar5;\n                    if (sVar5 == 0) break;\n                  }\n                }\n                else {\n                  iVar9 = 1;\n                }\n                iVar10 = iVar10 + iVar9;\n                lVar7 = (long)iVar10;\n                pbVar8 = param_1 + lVar7;\n                bVar6 = *pbVar8;\n                if (bVar6 == 0) goto LAB_0016d498;\n              }\n              iVar10 = iVar10 + 1;\n              goto LAB_0016d440;\n            }\nLAB_0016d498:\n            iVar10 = (iVar10 + 1) - (uint)(bVar6 == 0);\n          }\n          else {\n            iVar10 = FUN_0016a7c0(param_1,sVar4,iVar10,0x400);\n          }\n          if (param_2 < iVar10) break;\n        }\nLAB_0016d256:\n        lVar7 = (long)iVar10;\n        bVar6 = param_1[lVar7];\n        pbVar8 = param_1 + lVar7;\n      } while( true );\n    }\n    iVar10 = 1;\n  }\nLAB_0016d2d3:\n  no_longjmp_on_fatal_error = uVar2;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar10;\n}\n\n",
  "get_minus_o_opts": "\nvoid get_minus_o_opts(void)\n\n{\n  char *pcVar1;\n  long lVar2;\n  char *pcVar3;\n  int iVar4;\n  long lVar5;\n  undefined **ppuVar6;\n  char *pcVar7;\n  \n  lVar2 = strvec_create(0x1d);\n  ppuVar6 = &PTR_s_emacs_00236010;\n  lVar5 = 1;\n  pcVar1 = \"braceexpand\";\n  pcVar7 = \"allexport\";\n  while( true ) {\n    pcVar3 = pcVar1;\n    *(char **)(lVar2 + -8 + lVar5 * 8) = pcVar7;\n    iVar4 = (int)lVar5;\n    lVar5 = lVar5 + 1;\n    if (pcVar3 == (char *)0x0) break;\n    pcVar1 = *ppuVar6;\n    ppuVar6 = ppuVar6 + 5;\n    pcVar7 = pcVar3;\n  }\n  *(undefined8 *)(lVar2 + (long)iVar4 * 8) = 0;\n  return;\n}\n\n",
  "FUN_00181610": "\nvoid FUN_00181610(int param_1)\n\n{\n  set_signal_handler(param_1,*(undefined8 *)(original_signals + (long)param_1 * 8));\n  FUN_001815b0(param_1,0);\n  (&DAT_00247e40)[param_1] = (&DAT_00247e40)[param_1] & 0xfffffffe;\n  return;\n}\n\n",
  "full_pathname": "\nchar * full_pathname(char *param_1)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  if (*param_1 == '~') {\n    pcVar2 = (char *)bash_tilde_expand(param_1,0);\n  }\n  else {\n    sVar1 = strlen(param_1);\n    pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"general.c\",0x374);\n    pcVar2 = strcpy(pcVar2,param_1);\n  }\n  pcVar3 = pcVar2;\n  if (*pcVar2 != '/') {\n    pcVar3 = (char *)sh_makepath(0,pcVar2,6);\n    sh_xfree(pcVar2,\"general.c\",0x37a);\n  }\n  return pcVar3;\n}\n\n",
  "get_locale_var": "\nchar * get_locale_var(void)\n\n{\n  char *pcVar1;\n  \n  if ((DAT_002489b0 != (char *)0x0) && (*DAT_002489b0 != '\\0')) {\n    return DAT_002489b0;\n  }\n  pcVar1 = (char *)get_string_value();\n  if (((pcVar1 == (char *)0x0) || (*pcVar1 == '\\0')) &&\n     ((DAT_002489a8 == (char *)0x0 || (pcVar1 = DAT_002489a8, *DAT_002489a8 == '\\0')))) {\n    pcVar1 = \"\";\n  }\n  return pcVar1;\n}\n\n",
  "strmatch": "\nundefined8 strmatch(long param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  \n  if ((param_2 != 0) && (param_1 != 0)) {\n    uVar1 = xstrmatch();\n    return uVar1;\n  }\n  return 1;\n}\n\n",
  "FUN_0015ef00": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0015ef00(long **param_1,uint param_2,uint param_3,FILE *param_4)\n\n{\n  char *__s2;\n  int iVar1;\n  byte bVar8;\n  long **pplVar2;\n  long lVar3;\n  undefined *puVar4;\n  char **ppcVar5;\n  undefined8 uVar6;\n  size_t sVar7;\n  long **pplVar9;\n  char *pcVar10;\n  uint uVar11;\n  bool bVar12;\n  long **pplVar13;\n  bool bVar14;\n  bool bVar15;\n  char *local_58;\n  byte local_3c;\n  \n  pplVar9 = param_1;\n  if (param_1 == (long **)0x0) {\n    return;\n  }\n  do {\n    pplVar2 = pplVar9;\n    pplVar9 = (long **)*pplVar2;\n  } while ((long **)*pplVar2 != param_1);\n  lVar3 = (long)(int)param_2 * 8;\n  puVar4 = &DAT_001fdb1e;\n  if (param_3 != 0) {\n    puVar4 = &DAT_001fdb18;\n  }\n  pplVar9 = param_1;\nLAB_0015ef77:\n  bVar14 = pplVar2 == pplVar9;\n  if (param_3 != 0) goto LAB_0015f003;\nLAB_0015ef86:\n  fputc(0x20,param_4);\n  bVar12 = false;\n  if (-1 < (int)param_2) {\n    iVar1 = *(int *)(*(long *)(jobs + lVar3) + 0x14);\n    pplVar13 = pplVar2;\n    if (iVar1 != 2) goto joined_r0x0015f160;\n    bVar12 = bVar14;\n    if ((posixly_correct == 0) || ((char)*(uint *)((long)pplVar2 + 0xc) != '\\x7f')) {\n      local_58 = \"Stopped\";\n      DAT_002465a0 = \"Stopped\";\n      if (param_1 == pplVar9) goto LAB_0015f302;\n    }\n    else {\n      DAT_002465a0 = &DAT_00247620;\n      uVar6 = signal_name(*(uint *)((long)pplVar2 + 0xc) >> 8 & 0xff);\n      __snprintf_chk(DAT_002465a0,0x40,1,0xffffffffffffffff,\"Stopped(%s)\",uVar6);\n      if (param_1 == pplVar9) goto LAB_0015f1e9;\n    }\n  }\n  do {\n    bVar15 = false;\nLAB_0015efa4:\n    if (pplVar9[3] != (long *)0x0) {\n      fputs((char *)pplVar9[3],param_4);\n    }\n    if (bVar12 == false) {\n      if ((bVar14 != false) || (bVar15)) {\n        if (asynchronous_notification != 0) goto joined_r0x0015f256;\n        goto LAB_0015f258;\n      }\n    }\n    else {\n      pcVar10 = (char *)FUN_0015eb60();\n      ppcVar5 = *(char ***)(jobs + lVar3);\n      if ((*(int *)((long)ppcVar5 + 0x14) == 1) && ((*(byte *)(ppcVar5 + 3) & 1) == 0)) {\n        fwrite(&DAT_001fdb60,1,2,param_4);\n        ppcVar5 = *(char ***)(jobs + lVar3);\n      }\n      __s2 = *ppcVar5;\n      iVar1 = strcmp(pcVar10,__s2);\n      if (iVar1 != 0) {\n        uVar6 = polite_directory_format(__s2);\n        __fprintf_chk(param_4,1,\"  (wd: %s)\",uVar6);\n      }\n      if (asynchronous_notification == 0) {\n        fputc(10,param_4);\n        goto LAB_0015f26e;\n      }\njoined_r0x0015f256:\n      if (interactive != 0) {\n        putc(0xd,param_4);\n      }\nLAB_0015f258:\n      fputc(10,param_4);\n      if (pplVar2 == pplVar9) {\nLAB_0015f26e:\n        fflush(param_4);\n        return;\n      }\n    }\n    pplVar9 = (long **)*pplVar9;\n    if (param_1 == pplVar9) goto LAB_0015ef77;\n    __fprintf_chk(param_4,1,puVar4);\n    bVar14 = pplVar2 == pplVar9;\n    if (param_3 == 0) goto LAB_0015ef86;\nLAB_0015f003:\n    __fprintf_chk(param_4,1,&DAT_001fdb21,(long)*(int *)(pplVar9 + 1));\n    fputc(0x20,param_4);\n    local_3c = (byte)~(byte)(param_2 >> 0x18) >> 7;\n    if ((int)(param_3 | param_2) < 0) goto LAB_0015f0ee;\n    iVar1 = *(int *)(*(long *)(jobs + lVar3) + 0x14);\n    pplVar13 = pplVar9;\n    if (iVar1 != 2) {\njoined_r0x0015f160:\n      if (iVar1 != 1) goto LAB_0015f166;\n      local_58 = \"Running\";\n      DAT_002465a0 = \"Running\";\nLAB_0015f082:\n      if (param_1 != pplVar9) goto LAB_0015f2e0;\n      fputs(local_58,param_4);\n      goto LAB_0015f09d;\n    }\nLAB_0015f166:\n    DAT_002465a0 = &DAT_001fdb6e;\n    uVar11 = *(uint *)((long)pplVar13 + 0xc);\n    bVar8 = (byte)(uVar11 >> 8);\n    if ((char)uVar11 != '\\x7f') {\n      uVar11 = uVar11 & 0x7f;\n      if ('\\x01' < (char)((char)uVar11 + '\\x01')) goto LAB_0015f2b6;\n      if (uVar11 != 0) {\n        local_58 = \"Unknown status\";\n        DAT_002465a0 = \"Unknown status\";\n        goto LAB_0015f082;\n      }\n      local_58 = &DAT_00247620;\n      DAT_002465a0 = &DAT_00247620;\n      if (bVar8 == 0) {\n        _DAT_00247620 = 0x656e6f44;\n        _DAT_00247628 = 0;\n        _DAT_00247650 = 0;\n        _DAT_00247658 = 0;\n        _DAT_0024765c = 0;\n        DAT_0024765e = 0;\n        DAT_0024765f = 0;\n        _DAT_00247630 = 0;\n        uRam0000000000247634 = 0;\n        uRam0000000000247638 = 0;\n        uRam000000000024763c = 0;\n        _DAT_00247640 = 0;\n        uRam0000000000247644 = 0;\n        uRam0000000000247648 = 0;\n        uRam000000000024764c = 0;\n        if (param_1 != pplVar9) goto LAB_0015f2e0;\n        goto LAB_0015f302;\n      }\n      pcVar10 = \"Done(%d)\";\n      if (posixly_correct == 0) {\n        pcVar10 = \"Exit %d\";\n      }\n      __snprintf_chk(&DAT_00247620,0x40,1,0x40,pcVar10,bVar8);\n      local_58 = DAT_002465a0;\n      if (param_1 != pplVar9) goto LAB_0015f2e0;\nLAB_0015f1e9:\n      bVar15 = param_3 != 0;\n      local_58 = DAT_002465a0;\n      bVar12 = bVar14;\n      if (DAT_002465a0 != (char *)0x0) {\nLAB_0015f302:\n        fputs(local_58,param_4);\n        iVar1 = 0x16;\n        if (*local_58 != '\\0') {\nLAB_0015f09d:\n          iVar1 = 0x17;\n          if ((local_58[1] != '\\0') && (iVar1 = 0x16, local_58[2] != '\\0')) {\n            sVar7 = strlen(local_58);\n            iVar1 = 0x16;\n            if ((int)sVar7 != 0) {\n              iVar1 = 0x18 - (int)sVar7;\n            }\n          }\n        }\n        __fprintf_chk(param_4,1,&DAT_001fdb4d,iVar1,&DAT_00213d70);\n        uVar11 = *(uint *)((long)pplVar13 + 0xc);\n        if (((char)uVar11 == '\\x7f') || (uVar11 == 0xffff)) {\n          local_3c = 1;\n        }\n        else {\nLAB_0015f0e0:\n          local_3c = 1;\n          if ((uVar11 & 0x80) != 0) {\n            fwrite(\"(core dumped) \",1,0xe,param_4);\n          }\n        }\nLAB_0015f0ee:\n        bVar15 = param_3 != 0;\n        if ((param_1 == pplVar9) || (!bVar15)) {\n          bVar12 = (bool)(local_3c & bVar14);\n        }\n        else {\nLAB_0015f10a:\n          fwrite(&DAT_001fc764,1,2,param_4);\n          bVar15 = true;\n          bVar12 = (bool)(local_3c & bVar14);\n        }\n      }\n      goto LAB_0015efa4;\n    }\n    uVar11 = (uint)bVar8;\nLAB_0015f2b6:\n    local_58 = strsignal(uVar11);\n    if (local_58 == (char *)0x0) {\n      __snprintf_chk(&DAT_00247620,0x40,1,0x40,\"Signal %d\",uVar11);\n      local_58 = &DAT_00247620;\n    }\n    DAT_002465a0 = local_58;\n    if (param_1 == pplVar9) goto LAB_0015f302;\nLAB_0015f2e0:\n    bVar12 = bVar14;\n    if (param_3 != 0) {\n      if ((*(int *)(pplVar13 + 2) == *(int *)(param_1 + 2)) &&\n         (*(int *)((long)pplVar13 + 0xc) == *(int *)((long)param_1 + 0xc))) {\n        __fprintf_chk(param_4,1,&DAT_001fdb4d,0x16,&DAT_00213d70);\n        uVar11 = *(uint *)((long)pplVar13 + 0xc);\n        if (((char)uVar11 == '\\x7f') || (uVar11 == 0xffff)) goto LAB_0015f438;\n        goto LAB_0015f0e0;\n      }\n      if (local_58 != (char *)0x0) goto LAB_0015f302;\nLAB_0015f438:\n      local_3c = 1;\n      goto LAB_0015f10a;\n    }\n  } while( true );\n}\n\n",
  "_rl_nsearch_cleanup": "\nbool _rl_nsearch_cleanup(undefined8 param_1,int param_2)\n\n{\n  _rl_scxt_dispose(param_1,0);\n  rl_readline_state = rl_readline_state & 0xfffffffffffffeff;\n  _rl_nscxt = 0;\n  return param_2 != 1;\n}\n\n",
  "_rl_bracketed_read_key": "\nuint _rl_bracketed_read_key(void)\n\n{\n  uint uVar1;\n  int iVar2;\n  byte *pbVar3;\n  long in_FS_OFFSET;\n  long local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  rl_readline_state = rl_readline_state | 0x40;\n  uVar1 = rl_read_key();\n  rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n  if ((int)uVar1 < 0) {\n    uVar1 = 0xffffffff;\n  }\n  else if ((_rl_enable_bracketed_paste != 0) && (uVar1 == 0x1b)) {\n    iVar2 = _rl_read_bracketed_paste_prefix(0x1b);\n    if (iVar2 == 1) {\n      pbVar3 = (byte *)_rl_bracketed_text(&local_28);\n      if (local_28 == 0) {\n        uVar1 = 0;\n        xfree(pbVar3);\n      }\n      else {\n        uVar1 = (uint)*pbVar3;\n        if (local_28 != 1) {\n          local_28 = local_28 + -1;\n          do {\n            _rl_unget_char(pbVar3[local_28]);\n            local_28 = local_28 + -1;\n          } while (local_28 != 0);\n        }\n        xfree(pbVar3);\n      }\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_vi_undo": "\nvoid rl_vi_undo(void)\n\n{\n  rl_undo_command();\n  return;\n}\n\n",
  "coproc_closeall": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid coproc_closeall(void)\n\n{\n  if (-1 < DAT_0023842c) {\n    close(DAT_0023842c);\n    DAT_0023842c = -1;\n  }\n  if (-1 < DAT_00238430) {\n    close(DAT_00238430);\n    DAT_00238430 = -1;\n  }\n  _DAT_00238434 = 0xffffffffffffffff;\n  return;\n}\n\n",
  "word_split": "\nundefined8 word_split(undefined8 *param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (param_1 == (undefined8 *)0x0) {\n    return 0;\n  }\n  if ((param_2 != 0) && ((*(uint *)(param_1 + 1) & 2) == 0)) {\n    uVar1 = list_string(*param_1);\n    return uVar1;\n  }\n  uVar1 = list_string(*param_1,&DAT_00213d70);\n  return uVar1;\n}\n\n",
  "quote_compound_array_list": "\nvoid quote_compound_array_list(long *param_1)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  int iVar3;\n  undefined *puVar4;\n  size_t sVar5;\n  char *pcVar6;\n  char *pcVar7;\n  char *pcVar8;\n  char cVar9;\n  int iVar10;\n  long lVar11;\n  char *pcVar12;\n  char *pcVar13;\n  long local_48;\n  int local_3c;\n  \n  if (param_1 == (long *)0x0) {\n    return;\n  }\n  do {\n    ppcVar1 = (char **)param_1[1];\n    if ((ppcVar1 != (char **)0x0) && (pcVar13 = *ppcVar1, pcVar13 != (char *)0x0)) {\n      if ((*(byte *)(ppcVar1 + 1) & 4) == 0) {\n        pcVar12 = strchr(pcVar13,1);\n        if (pcVar12 != (char *)0x0) {\n          pcVar13 = (char *)quote_escapes(pcVar13);\n        }\n        puVar4 = (undefined *)sh_single_quote(pcVar13);\n        if (*(char **)param_1[1] != pcVar13) {\n          sh_xfree(pcVar13,\"arrayfunc.c\",0x42d);\n          pcVar13 = *(char **)param_1[1];\n        }\n      }\n      else if (*pcVar13 == '[') {\n        iVar2 = skipsubscript(pcVar13,0,0);\n        pcVar12 = pcVar13 + iVar2;\n        if (*pcVar12 == ']') {\n          sVar5 = strlen(pcVar13);\n          *pcVar12 = '\\0';\n          pcVar8 = pcVar13 + 1;\n          pcVar6 = strchr(pcVar8,1);\n          if (pcVar6 == (char *)0x0) {\n            pcVar6 = (char *)sh_single_quote(pcVar8);\n          }\n          else {\n            pcVar7 = (char *)quote_escapes();\n            pcVar6 = (char *)sh_single_quote(pcVar7);\n            if (pcVar8 != pcVar7) {\n              sh_xfree(pcVar7,\"arrayfunc.c\",0x3ca);\n            }\n          }\n          *pcVar12 = ']';\n          puVar4 = (undefined *)sh_xmalloc((long)((int)sVar5 * 4 + 5),\"arrayfunc.c\",0x3cd);\n          *puVar4 = 0x5b;\n          if ((pcVar6 == (char *)0x0) || (*pcVar6 == '\\0')) {\n            local_3c = 0;\n            lVar11 = 2;\n            iVar10 = 2;\n            sVar5 = 0;\n            local_48 = 1;\n          }\n          else if (pcVar6[1] == '\\0') {\n            local_48 = 2;\n            lVar11 = 3;\n            sVar5 = 1;\n            iVar10 = 3;\n            local_3c = 1;\n          }\n          else if (pcVar6[2] == '\\0') {\n            local_48 = 3;\n            lVar11 = 4;\n            sVar5 = 2;\n            iVar10 = 4;\n            local_3c = 2;\n          }\n          else {\n            sVar5 = strlen(pcVar6);\n            local_3c = (int)sVar5;\n            iVar10 = local_3c + 2;\n            sVar5 = (size_t)local_3c;\n            local_48 = (long)(local_3c + 1);\n            lVar11 = (long)iVar10;\n          }\n          memcpy(puVar4 + 1,pcVar6,sVar5);\n          sh_xfree(pcVar6,\"arrayfunc.c\",0x3d1);\n          iVar3 = iVar2 + 1;\n          puVar4[local_48] = *pcVar12;\n          cVar9 = pcVar13[iVar3];\n          if (cVar9 == '+') {\n            puVar4[lVar11] = 0x2b;\n            iVar3 = iVar2 + 2;\n            iVar10 = local_3c + 3;\n            lVar11 = (long)iVar10;\n            cVar9 = pcVar13[iVar3];\n          }\n          puVar4[lVar11] = cVar9;\n          pcVar13 = pcVar13 + (iVar3 + 1);\n          pcVar12 = strchr(pcVar13,1);\n          if (pcVar12 == (char *)0x0) {\n            pcVar12 = (char *)sh_single_quote(pcVar13);\n          }\n          else {\n            pcVar8 = (char *)quote_escapes();\n            pcVar12 = (char *)sh_single_quote(pcVar8);\n            if (pcVar13 != pcVar8) {\n              sh_xfree(pcVar8,\"arrayfunc.c\",0x3da);\n            }\n          }\n          strcpy(puVar4 + (iVar10 + 1),pcVar12);\n          pcVar13 = *(char **)param_1[1];\n        }\n        else {\n          puVar4 = (undefined *)sh_single_quote();\n          pcVar13 = *(char **)param_1[1];\n        }\n      }\n      else {\n        puVar4 = (undefined *)sh_single_quote(pcVar13);\n        pcVar13 = *(char **)param_1[1];\n      }\n      sh_xfree(pcVar13,\"arrayfunc.c\",0x431);\n      *(undefined **)param_1[1] = puVar4;\n    }\n    param_1 = (long *)*param_1;\n  } while (param_1 != (long *)0x0);\n  return;\n}\n\n",
  "FUN_00144a20": "\nvoid FUN_00144a20(byte *param_1)\n\n{\n  undefined4 uVar1;\n  \n  do {\n    if ((*param_1 & 4) == 0) {\n      uVar1 = *(undefined4 *)(param_1 + 8);\n    }\n    else {\n      FUN_001446d0(&DAT_001fc61b);\n      uVar1 = *(undefined4 *)(param_1 + 8);\n    }\n    switch(uVar1) {\n    case 0:\n      return;\n    case 1:\n      FUN_00144a20(*(undefined8 *)(param_1 + 0x18));\n      FUN_001446d0(&DAT_001fc621);\n      param_1 = *(byte **)(param_1 + 0x20);\n      break;\n    case 2:\n      FUN_00144a20(*(undefined8 *)(param_1 + 0x18));\n      FUN_001446d0(&DAT_001fc626);\n      param_1 = *(byte **)(param_1 + 0x20);\n      break;\n    case 3:\n      FUN_001446d0(&DAT_002102da,**(undefined8 **)(param_1 + 0x10));\n      FUN_001446d0(&DAT_001fdb1c);\n      param_1 = *(byte **)(param_1 + 0x18);\n      break;\n    case 4:\n      FUN_00144a20(*(undefined8 *)(param_1 + 0x18));\n      FUN_001446d0(&DAT_001fdb1c);\n      FUN_001446d0(&DAT_002102da,**(undefined8 **)(param_1 + 0x10));\n      FUN_001446d0(&DAT_001fdb1c);\n      param_1 = *(byte **)(param_1 + 0x20);\n      break;\n    case 5:\n      FUN_001446d0(&DAT_002102da,**(undefined8 **)(param_1 + 0x10));\n      return;\n    default:\n      FUN_001446d0(&DAT_001fc75b);\n      FUN_00144a20(*(undefined8 *)(param_1 + 0x18));\n      FUN_001446d0(&DAT_001fc61e);\n      return;\n    }\n  } while( true );\n}\n\n",
  "rl_maybe_unsave_line": "\nundefined8 rl_maybe_unsave_line(void)\n\n{\n  void *__ptr;\n  void **ppvVar1;\n  \n  if (_rl_saved_line_for_history != (void **)0x0) {\n    rl_replace_line(*_rl_saved_line_for_history,0);\n    ppvVar1 = _rl_saved_line_for_history;\n    rl_undo_list = _rl_saved_line_for_history[2];\n    if (*_rl_saved_line_for_history != (void *)0x0) {\n      free(*_rl_saved_line_for_history);\n    }\n    __ptr = ppvVar1[1];\n    if (__ptr != (void *)0x0) {\n      free(__ptr);\n    }\n    xfree(ppvVar1);\n    _rl_saved_line_for_history = (void **)0x0;\n    rl_point = rl_end;\n    return 0;\n  }\n  rl_ding();\n  return 0;\n}\n\n",
  "_rl_clear_to_eol": "\nvoid _rl_clear_to_eol(int param_1)\n\n{\n  int iVar1;\n  \n  if (_rl_term_clreol != 0) {\n    tputs(_rl_term_clreol,1,_rl_output_character_function);\n    return;\n  }\n  if (param_1 == 0) {\n    return;\n  }\n  if (0 < param_1) {\n    iVar1 = 0;\n    do {\n      iVar1 = iVar1 + 1;\n      putc(0x20,rl_outstream);\n    } while (param_1 != iVar1);\n  }\n  _rl_last_c_pos = _rl_last_c_pos + param_1;\n  return;\n}\n\n",
  "_rl_isearch_cleanup": "\nbool _rl_isearch_cleanup(long param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  size_t sVar4;\n  \n  if (-1 < param_2) {\n    rl_replace_line(*(undefined8 *)(*(long *)(param_1 + 0x18) + (long)*(int *)(param_1 + 0x38) * 8),\n                    0);\n    rl_restore_prompt();\n    if (DAT_0024a7d8 != (void *)0x0) {\n      free(DAT_0024a7d8);\n    }\n    DAT_0024a7d8 = *(void **)(param_1 + 8);\n    iVar2 = *(int *)(param_1 + 0x38);\n    *(undefined8 *)(param_1 + 8) = 0;\n    DAT_0024a7d0 = *(undefined4 *)(param_1 + 0x10);\n    *(undefined8 *)(param_1 + 0x10) = 0;\n    iVar1 = *(int *)(param_1 + 0x3c);\n    if (iVar1 < iVar2) {\n      rl_get_previous_history(iVar2 - iVar1,0);\n      iVar2 = *(int *)(param_1 + 0x9c);\n    }\n    else {\n      rl_get_next_history(iVar1 - iVar2,0);\n      iVar2 = *(int *)(param_1 + 0x9c);\n    }\n    if (iVar2 < 0) {\n      if (*(int *)(param_1 + 0x3c) == *(int *)(param_1 + 0x38)) {\n        uVar3 = *(undefined4 *)(param_1 + 0x30);\n      }\n      else {\n        sVar4 = strlen(rl_line_buffer);\n        uVar3 = (undefined4)sVar4;\n      }\n      *(undefined4 *)(param_1 + 0x9c) = uVar3;\n      rl_mark = *(undefined4 *)(param_1 + 0x34);\n      rl_deactivate_mark();\n      iVar2 = *(int *)(param_1 + 0x9c);\n    }\n    rl_point = iVar2;\n    _rl_fix_point(0);\n    rl_deactivate_mark();\n    rl_clear_message();\n  }\n  if (*(void **)(param_1 + 8) != (void *)0x0) {\n    free(*(void **)(param_1 + 8));\n  }\n  if (*(void **)(param_1 + 0x20) != (void *)0x0) {\n    free(*(void **)(param_1 + 0x20));\n  }\n  if (*(void **)(param_1 + 0x18) != (void *)0x0) {\n    free(*(void **)(param_1 + 0x18));\n  }\n  xfree(param_1);\n  rl_readline_state = rl_readline_state & 0xffffffffffffff7f;\n  _rl_iscxt = 0;\n  return param_2 != 0;\n}\n\n",
  "FUN_00142fc0": "\nvoid FUN_00142fc0(undefined8 param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  \n  uVar2 = make_bare_word();\n  lVar3 = make_word_flags(uVar2,param_1);\n  iVar1 = DAT_00241ebc;\n  *(uint *)(lVar3 + 8) = *(uint *)(lVar3 + 8) | 0x101032;\n  if (iVar1 < 1) {\n    puVar4 = (undefined8 *)sh_xmalloc(0x10,\"make_cmd.c\",0xa3);\n  }\n  else {\n    DAT_00241ebc = iVar1 + -1;\n    puVar4 = *(undefined8 **)(wlcache + (long)DAT_00241ebc * 8);\n  }\n  puVar4[1] = lVar3;\n  *puVar4 = 0;\n  return;\n}\n\n",
  "sh_un_double_quote": "\nvoid sh_un_double_quote(char *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  size_t sVar3;\n  undefined *puVar4;\n  uint uVar5;\n  uint uVar6;\n  \n  sVar3 = strlen(param_1);\n  puVar4 = (undefined *)sh_xmalloc(sVar3 + 1,\"shquote.c\",0xe5);\n  uVar6 = (uint)*param_1;\n  if (*param_1 != '\\0') {\n    bVar2 = false;\n    uVar5 = uVar6;\n    do {\n      while (!bVar2) {\n        if ((uVar6 == 0x5c) && (bVar1 = param_1[1], (*(byte *)(&sh_syntaxtab + bVar1) & 0x40) != 0))\n        {\n          bVar2 = true;\n        }\n        else {\n          *puVar4 = (char)uVar5;\n          bVar1 = param_1[1];\n          puVar4 = puVar4 + 1;\n        }\n        uVar5 = (uint)bVar1;\n        uVar6 = (uint)(char)bVar1;\n        param_1 = param_1 + 1;\n        if (bVar1 == 0) goto LAB_001c8db5;\n      }\n      *puVar4 = (char)uVar5;\n      bVar1 = param_1[1];\n      uVar5 = (uint)bVar1;\n      puVar4 = puVar4 + 1;\n      bVar2 = false;\n      param_1 = param_1 + 1;\n      uVar6 = (uint)(char)bVar1;\n    } while (bVar1 != 0);\n  }\nLAB_001c8db5:\n  *puVar4 = 0;\n  return;\n}\n\n",
  "FUN_001512e0": "\nuint FUN_001512e0(long param_1)\n\n{\n  if (((*(uint *)(param_1 + 0x28) & 0x1020) == 0x20) &&\n     (*(int *)(param_1 + 0x2c) == variable_context)) {\n    return *(uint *)(param_1 + 0x28) & 1;\n  }\n  return 0;\n}\n\n",
  "FUN_00180f90": "\nvoid FUN_00180f90(int param_1)\n\n{\n  set_signal_handler(param_1,*(undefined8 *)(original_signals + (long)param_1 * 8));\n  (&DAT_00247e40)[param_1] = (&DAT_00247e40)[param_1] & 0xfffffffe;\n  return;\n}\n\n",
  "can_optimize_connection": "\nbool can_optimize_connection(long param_1)\n\n{\n  int iVar1;\n  \n  if (*DAT_00240a70 != '\\0') {\n    return false;\n  }\n  iVar1 = parser_expanding_alias();\n  if (iVar1 == 0) {\n    iVar1 = *(int *)(*(long *)(param_1 + 0x18) + 0x18);\n    if ((iVar1 - 0x120U < 2) || (iVar1 == 0x3b)) {\n      return **(int **)(*(long *)(param_1 + 0x18) + 0x10) == 4;\n    }\n  }\n  return false;\n}\n\n",
  "assoc_quote_escapes": "\nlong * assoc_quote_escapes(long *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long lVar3;\n  \n  if (param_1 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  if (*(int *)((long)param_1 + 0xc) == 0) {\n    return (long *)0x0;\n  }\n  lVar3 = 0;\n  if (0 < *(int *)(param_1 + 1)) {\n    do {\n      for (puVar1 = *(undefined8 **)(*param_1 + lVar3 * 8); puVar1 != (undefined8 *)0x0;\n          puVar1 = (undefined8 *)*puVar1) {\n        uVar2 = quote_escapes(puVar1[2]);\n        if (puVar1[2] != 0) {\n          sh_xfree(puVar1[2],\"assoc.c\",0xb8);\n        }\n        puVar1[2] = uVar2;\n      }\n      lVar3 = lVar3 + 1;\n    } while (*(int *)(param_1 + 1) != (int)lVar3 && (int)lVar3 <= *(int *)(param_1 + 1));\n  }\n  return param_1;\n}\n\n",
  "remove_quoted_escapes": "\nchar * remove_quoted_escapes(char *param_1)\n\n{\n  char *__src;\n  \n  if (param_1 != (char *)0x0) {\n    __src = (char *)dequote_escapes();\n    strcpy(param_1,__src);\n    sh_xfree(__src,\"subst.c\",0x1377);\n  }\n  return param_1;\n}\n\n",
  "_rl_enable_paren_matching": "\nvoid _rl_enable_paren_matching(int param_1)\n\n{\n  code *pcVar1;\n  \n  pcVar1 = rl_insert_close;\n  if (param_1 == 0) {\n    pcVar1 = rl_insert;\n  }\n  rl_bind_key_in_map(0x29,pcVar1,emacs_standard_keymap);\n  rl_bind_key_in_map(0x5d,pcVar1,emacs_standard_keymap);\n  rl_bind_key_in_map(0x7d,pcVar1,emacs_standard_keymap);\n  rl_bind_key_in_map(0x29,pcVar1,&vi_insertion_keymap);\n  rl_bind_key_in_map(0x5d,pcVar1,&vi_insertion_keymap);\n  rl_bind_key_in_map(0x7d,pcVar1,&vi_insertion_keymap);\n  return;\n}\n\n",
  "getpwent": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\npasswd * getpwent(void)\n\n{\n  passwd *ppVar1;\n  \n  ppVar1 = (passwd *)(*(code *)PTR_getpwent_00237b78)();\n  return ppVar1;\n}\n\n",
  "get_current_options": "\nlong get_current_options(void)\n\n{\n  undefined uVar1;\n  int iVar2;\n  long lVar3;\n  undefined *puVar4;\n  undefined8 *puVar5;\n  long lVar6;\n  char *pcVar7;\n  int iVar8;\n  \n  lVar6 = 1;\n  iVar2 = num_posix_options();\n  lVar3 = sh_xmalloc((long)iVar2 + 0x1d,\"./set.def\",0x155);\n  iVar8 = 0x61;\n  pcVar7 = \"allexport\";\n  puVar5 = &DAT_00235fd0;\n  while( true ) {\n    if (iVar8 == 0) {\n      if ((code *)puVar5[2] == (code *)0x0) {\n        uVar1 = *(undefined *)*puVar5;\n      }\n      else {\n        uVar1 = (*(code *)puVar5[2])(pcVar7);\n      }\n    }\n    else {\n      puVar4 = (undefined *)find_flag(iVar8);\n      uVar1 = *puVar4;\n    }\n    *(undefined *)(lVar3 + -1 + lVar6) = uVar1;\n    pcVar7 = (char *)puVar5[3];\n    iVar8 = (int)lVar6;\n    lVar6 = lVar6 + 1;\n    if (pcVar7 == (char *)0x0) break;\n    iVar8 = *(int *)(puVar5 + 4);\n    puVar5 = puVar5 + 5;\n  }\n  get_posix_options(iVar8 + lVar3);\n  *(undefined *)(lVar3 + (iVar2 + iVar8)) = 0;\n  return lVar3;\n}\n\n",
  "FUN_00137960": "\nuint FUN_00137960(ulong param_1,undefined8 param_2,undefined8 param_3,char *param_4)\n\n{\n  char *pcVar1;\n  char cVar2;\n  bool bVar3;\n  char *pcVar4;\n  byte bVar5;\n  uint uVar6;\n  int iVar7;\n  int iVar8;\n  char *pcVar9;\n  char *pcVar10;\n  bool bVar11;\n  \n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n  }\n  if (sigwinch_received != 0) {\n    sigwinch_received = 0;\n    get_new_window_size(0,0,0);\n  }\n  uVar6 = DAT_00240b34;\n  iVar7 = line_number;\n  if (DAT_00240b34 != 0) {\n    DAT_00240b34 = 0;\n    return uVar6;\n  }\n  if (DAT_00240da8 != (char *)0x0) {\n    uVar6 = (uint)(byte)DAT_00240da8[(long)DAT_00240da0];\n    pcVar10 = DAT_00240da8;\n    bVar3 = false;\n    if (DAT_00240da8[(long)DAT_00240da0] != 0) goto LAB_001379dd;\n    bVar3 = false;\n    if (pushed_string_list != (char *)0x0) goto LAB_001379dd;\n    line_number = line_number + 1;\n    if ((char *)0x7fff < DAT_00240d98) {\n      bVar3 = false;\n      sh_xfree(DAT_00240da8,\"/usr/local/src/chet/src/bash/src/parse.y\",0x92f);\n      DAT_00240da8 = (char *)0x0;\n      DAT_00240d98 = (char *)0x0;\n      goto LAB_00137b60;\n    }\n  }\n  line_number = iVar7 + 1;\n  bVar3 = false;\nLAB_00137b60:\n  do {\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      throw_to_top_level();\n    }\n    DAT_00240d8c = 0;\n    param_4 = (char *)(ulong)interactive_shell;\n    if (interactive_shell == 0) {\nLAB_00137d00:\n      notify_and_cleanup();\n      if ((no_line_editing != 0) && (interactive != 0)) {\n        if (1 < bash_input - 1U) goto LAB_00137bb8;\n        fputs(DAT_00240d78,stderr);\n        fflush(stderr);\n      }\nLAB_00137d50:\n      if (bash_input == 2) {\n        clearerr(stdin);\n      }\n    }\n    else {\n      if (interactive == 0) goto LAB_00137d50;\n      if (bash_input - 1U < 2) goto LAB_00137d00;\n    }\nLAB_00137bb8:\n    iVar7 = 0;\n    do {\n      while( true ) {\n        iVar8 = (*DAT_00240a78)();\n        if (terminating_signal != 0) {\n          termsig_handler(terminating_signal);\n        }\n        if (interrupt_state != 0) {\n          throw_to_top_level();\n        }\n        if (iVar8 == 0) break;\n        if (DAT_00240d98 < (char *)0xffffffffffffff00) {\n          if (DAT_00240d98 <= (char *)(long)(iVar7 + 2)) {\n            do {\n              DAT_00240d98 = DAT_00240d98 + 0x100;\n            } while (DAT_00240d98 <= (char *)(long)(iVar7 + 2));\n            param_4 = (char *)0x984;\n            DAT_00240da8 = (char *)sh_xrealloc(DAT_00240da8,DAT_00240d98,\n                                               \"/usr/local/src/chet/src/bash/src/parse.y\",0x984);\n          }\n        }\n        else if (DAT_00240d98 != &DAT_ffffffffffffffff) {\n          param_4 = (char *)0x980;\n          DAT_00240d98 = &DAT_ffffffffffffffff;\n          DAT_00240da8 = (char *)sh_xrealloc(DAT_00240da8,0xffffffffffffffff,\n                                             \"/usr/local/src/chet/src/bash/src/parse.y\",0x980);\n        }\n        pcVar10 = DAT_00240da8 + iVar7;\n        if (iVar8 == -1) {\n          if (bash_input == 2) {\n            clearerr(stdin);\n          }\n          if (iVar7 == 0) {\n            DAT_00240d8c = -1;\n          }\n          *pcVar10 = '\\0';\n          goto LAB_00137c11;\n        }\n        *pcVar10 = (char)iVar8;\n        if (iVar8 == 10) {\n          *pcVar10 = '\\0';\n          current_command_line_count = current_command_line_count + 1;\n          goto LAB_00137c11;\n        }\n        bVar3 = iVar8 == 0x5c && !bVar3;\n        iVar7 = iVar7 + 1;\n      }\n    } while (bash_input != 3);\n    if (iVar7 == 0) {\n      DAT_00240d8c = -1;\n    }\n    iVar8 = -1;\n    DAT_00240da8[iVar7] = '\\0';\nLAB_00137c11:\n    DAT_00240d90 = (char *)(long)iVar7;\n    DAT_00240da0 = (char *)0x0;\n    FUN_001354e0();\n    pcVar10 = DAT_00240da8;\n    if (remember_on_history == 0) goto joined_r0x00137c9b;\n    if (DAT_00240da8 != (char *)0x0) {\n      if (*DAT_00240da8 == '\\0') {\n        if (1 < current_command_line_count) {\n          if (((DAT_00240a18 != 0) && (*(char *)(dstack + -1 + (long)DAT_00240a18) != '\\0')) ||\n             ((pcVar9 = (char *)history_delimiting_chars(), pcVar10 = DAT_00240da8,\n              pcVar9 != (char *)0x0 && (*pcVar9 == ';')))) {\n            maybe_add_history();\n            pcVar10 = DAT_00240da8;\n          }\n          goto joined_r0x00137c9b;\n        }\n        if (echo_input_at_read == 0) goto LAB_0013815e;\nLAB_00138207:\n        if (DAT_00240d8c == -1) {\n          uVar6 = (uint)(byte)DAT_00240da8[(long)DAT_00240da0];\n          pcVar10 = DAT_00240da8;\n          goto LAB_001379dd;\n        }\n        if (shell_eof_token == 0) goto LAB_00138222;\nLAB_0013816a:\n        if ((DAT_00240d98 < (char *)0xfffffffffffffffc) &&\n           (param_4 = DAT_00240d90 + 3, DAT_00240d98 < param_4)) {\n          pcVar10 = DAT_00240d98 + 3;\n          param_4 = (char *)0x9fb;\n          DAT_00240d98 = DAT_00240d98 + 2;\n          DAT_00240da8 = (char *)sh_xrealloc(DAT_00240da8,pcVar10,\n                                             \"/usr/local/src/chet/src/bash/src/parse.y\",0x9fb);\n        }\n        pcVar10 = DAT_00240da8;\n        pcVar9 = DAT_00240d90;\n        if ((bash_input == 3) &&\n           ((((pushed_string_list == (char *)0x0 || (*(long *)(pushed_string_list + 0x18) == 0)) &&\n             ((bool)(iVar8 == -1 & bVar3))) && ((param_1 & 1) != 0)))) {\n          DAT_00240da8[(long)DAT_00240d90] = '\\\\';\n        }\n        else {\n          DAT_00240da8[(long)DAT_00240d90] = '\\n';\n        }\n        pcVar4 = DAT_00240e40;\n        pcVar1 = pcVar9 + 2;\n        (pcVar10 + 1)[(long)pcVar9] = '\\0';\n        if (pcVar4 < pcVar1) {\n          param_4 = (char *)0xa0c;\n          DAT_00240e40 = pcVar1;\n          DAT_00240e48 = sh_xrealloc(DAT_00240e48,pcVar1,\"/usr/local/src/chet/src/bash/src/parse.y\",\n                                     0xa0c);\n          pcVar9 = DAT_00240d90;\n          pcVar10 = DAT_00240da8;\n        }\n        pcVar9[DAT_00240e48] = '\\x01';\n      }\n      else {\n        history_quoting_state = DAT_00240a18;\n        if (DAT_00240a18 != 0) {\n          cVar2 = *(char *)(dstack + -1 + (long)DAT_00240a18);\n          history_quoting_state = 0x27;\n          if ((cVar2 != '\\'') && (history_quoting_state = 0, cVar2 == '\\\"')) {\n            history_quoting_state = 0x22;\n          }\n        }\n        pcVar10 = (char *)pre_process_line(DAT_00240da8,1,1);\n        history_quoting_state = 0;\n        if (DAT_00240da8 != pcVar10) {\n          sh_xfree(DAT_00240da8,\"/usr/local/src/chet/src/bash/src/parse.y\",0x9bb);\n          DAT_00240da8 = pcVar10;\n          if (pcVar10 == (char *)0x0) {\n            DAT_00240d90 = (char *)0x0;\nLAB_001380fc:\n            current_command_line_count = current_command_line_count + -1;\n            DAT_00240d98 = (char *)0x0;\n          }\n          else {\n            DAT_00240d98 = (char *)strlen(pcVar10);\n            DAT_00240d90 = DAT_00240d98;\n            if (DAT_00240d98 == (char *)0x0) goto LAB_001380fc;\n          }\n          FUN_001354e0();\n          pcVar10 = DAT_00240da8;\n        }\njoined_r0x00137c9b:\n        if (pcVar10 == (char *)0x0) goto LAB_00137ca1;\n        if (echo_input_at_read != 0) {\n          if (*pcVar10 == '\\0') goto LAB_00138207;\n          if (shell_eof_token == 0) {\nLAB_00138222:\n            param_4 = pcVar10;\n            __fprintf_chk(stderr,1,&DAT_0020fbe7,param_4);\n          }\n        }\nLAB_0013815e:\n        pcVar10 = DAT_00240da8;\n        if (DAT_00240d8c != -1) goto LAB_0013816a;\n      }\n      uVar6 = (uint)(byte)pcVar10[(long)DAT_00240da0];\nLAB_001379dd:\n      if (DAT_00240da0 != (char *)0x0) goto LAB_001379f3;\nLAB_001379e9:\n      DAT_00240b30 = 0;\nLAB_001379f3:\n      bVar5 = (byte)uVar6;\njoined_r0x001379f5:\n      if (bVar5 != 0) {\n        bVar11 = (char)uVar6 == '\\\\';\n        DAT_00240b30 = (uint)(DAT_00240b30 == 0) &\n                       (uint)CONCAT71((int7)((ulong)param_4 >> 8),bVar11);\n        goto LAB_00137a1a;\n      }\n      if (pushed_string_list != (char *)0x0) {\n        iVar7 = *(int *)(pushed_string_list + 0x3c);\n        if (((((iVar7 - 2U & 0xfffffffd) != 0) && ((parser_state & 0x300000) == 0)) &&\n            ((DAT_00240da0 != (char *)0x0 &&\n             (((pcVar10 + -1)[(long)DAT_00240da0] != 10 &&\n              (((&sh_syntaxtab)[(byte)(pcVar10 + -1)[(long)DAT_00240da0]] & 0x2001 | DAT_00240b30)\n               == 0)))))) &&\n           ((DAT_00240a18 == 0 ||\n            ((cVar2 = *(char *)(dstack + -1 + (long)DAT_00240a18), cVar2 != '\\'' && (cVar2 != '\\\"'))\n            )))) {\n          parser_state = parser_state | 0x200000;\n          if ((DAT_00240d90 == DAT_00240da0) && (DAT_00240da0 != (char *)0x1)) {\n            if (DAT_00240da0[DAT_00240e48 + -1] != '\\0') {\n              return 0x20;\n            }\n            DAT_00240da0[DAT_00240e48 + -1] = '\\x01';\n            return 0x20;\n          }\n          return 0x20;\n        }\n        do {\n          if (iVar7 == 4) break;\n          parser_state = parser_state & 0xffdfffff;\n          FUN_001358d0();\n          bVar5 = DAT_00240da8[(long)DAT_00240da0];\n          uVar6 = (uint)bVar5;\n          if (bVar5 == 0) break;\n          bVar11 = bVar5 == 0x5c;\nLAB_00137a1a:\n          DAT_00240da0 = DAT_00240da0 + 1;\n          if ((param_1 & 1) == 0) {\n            return uVar6;\n          }\n          if (!bVar11) {\n            return uVar6;\n          }\n          if ((DAT_00240da8[(long)DAT_00240da0] != '\\n') ||\n             (((char *)0x1 < DAT_00240da0 && (DAT_00240da0[DAT_00240e48 + -1] == '\\0')))) {\n            return 0x5c;\n          }\n          if ((interactive == 0) || (1 < bash_input - 1U)) {\nLAB_00137a7f:\n            line_number = line_number + 1;\n            if (pushed_string_list == (char *)0x0) goto LAB_00137b60;\n          }\n          else {\n            if ((pushed_string_list == (char *)0x0) || (*(long *)(pushed_string_list + 0x18) == 0))\n            {\n              FUN_001373e0();\n              goto LAB_00137a7f;\n            }\n            line_number = line_number + 1;\n          }\n          if (*(long *)(pushed_string_list + 0x18) == 0) goto LAB_00137b60;\n          pcVar9 = DAT_00240da0 + 1;\n          bVar5 = (DAT_00240da8 + 1)[(long)DAT_00240da0];\n          uVar6 = (uint)bVar5;\n          if (bVar5 != 0) goto code_r0x00137aba;\n          iVar7 = *(int *)(pushed_string_list + 0x3c);\n        } while( true );\n      }\n      if (DAT_00240d8c == -1) {\n        return -(uint)(DAT_00240da0 == (char *)0x0) | 10;\n      }\n      if (bash_input != 3) {\n        return 0;\n      }\n      if (*DAT_00240a70 == '\\0') {\n        return 0;\n      }\n      if (pushed_string_list == (char *)0x0) {\n        return 0;\n      }\n      if (*(int *)(pushed_string_list + 0x3c) != 4) {\n        return 0;\n      }\n      if (DAT_00240d8c != 0) {\n        return 0;\n      }\n      DAT_00240da0 = (char *)0x0;\n      goto LAB_00137b60;\n    }\nLAB_00137ca1:\n    DAT_00240d98 = (char *)0x0;\n    prompt_string_pointer = &current_prompt_string;\n    if (((interactive != 0) && (bash_input - 1U < 2)) &&\n       ((pushed_string_list == (char *)0x0 || (*(long *)(pushed_string_list + 0x18) == 0)))) {\n      FUN_001373e0();\n    }\n  } while( true );\ncode_r0x00137aba:\n  param_4 = pushed_string_list;\n  pcVar10 = DAT_00240da8;\n  DAT_00240da0 = pcVar9;\n  if (pcVar9 == (char *)0x0) goto LAB_001379e9;\n  goto joined_r0x001379f5;\n}\n\n",
  "sv_funcnest": "\nvoid sv_funcnest(void)\n\n{\n  int iVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  undefined4 local_18 [2];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar2 = find_variable();\n  if ((lVar2 == 0) || (iVar1 = legal_number(*(undefined8 *)(lVar2 + 8),local_18), iVar1 == 0)) {\n    local_18[0] = 0;\n  }\n  funcnest_max = local_18[0];\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "FUN_00148e00": "\nuint FUN_00148e00(uint *param_1)\n\n{\n  char cVar1;\n  char cVar2;\n  uint uVar3;\n  uint *puVar4;\n  char *pcVar5;\n  uint uVar6;\n  int iVar7;\n  undefined4 uVar8;\n  undefined *puVar9;\n  long lVar10;\n  undefined *puVar11;\n  uint uVar12;\n  undefined uVar13;\n  bool bVar14;\n  \n  uVar12 = *param_1 & 4;\n  uVar6 = *param_1 & 8;\n  if (uVar6 != 0) {\n    puVar4 = *(uint **)(param_1 + 6);\n    if (puVar4 != (uint *)0x0) {\n      *puVar4 = *puVar4 | 8;\n    }\n    puVar4 = *(uint **)(param_1 + 8);\n    if (puVar4 != (uint *)0x0) {\n      *puVar4 = *puVar4 | 8;\n    }\n  }\n  uVar3 = param_1[2];\n  if (uVar3 == 6) {\n    uVar6 = FUN_00148e00(*(undefined8 *)(param_1 + 6));\n    goto LAB_00148f04;\n  }\n  if (uVar3 == 2) {\n    uVar6 = FUN_00148e00(*(undefined8 *)(param_1 + 6));\n    if (uVar6 == 0) goto LAB_00148f04;\n  }\n  else {\n    if (uVar3 != 1) {\n      if (uVar3 == 3) {\n        pcVar5 = **(char ***)(param_1 + 4);\n        if (uVar6 == 0) {\n          if (((*pcVar5 == '-') && (pcVar5[1] == 'v')) && (pcVar5[2] == '\\0')) {\n            bVar14 = true;\n            iVar7 = valid_array_reference(**(undefined8 **)(*(long *)(param_1 + 6) + 0x10),1);\n            lVar10 = (ulong)(iVar7 != 0) << 3;\n            puVar9 = (undefined *)cond_expand_word(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10),3)\n            ;\n          }\n          else {\n            lVar10 = 0;\n            puVar9 = (undefined *)cond_expand_word(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10),0)\n            ;\n            bVar14 = false;\n          }\n        }\n        else {\n          comsub_ignore_return = comsub_ignore_return + 1;\n          if (((*pcVar5 == '-') && (pcVar5[1] == 'v')) && (pcVar5[2] == '\\0')) {\n            bVar14 = true;\n            iVar7 = valid_array_reference(**(undefined8 **)(*(long *)(param_1 + 6) + 0x10),1);\n            lVar10 = (ulong)(iVar7 != 0) << 3;\n            puVar9 = (undefined *)cond_expand_word(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10),3)\n            ;\n          }\n          else {\n            lVar10 = 0;\n            bVar14 = false;\n            puVar9 = (undefined *)cond_expand_word(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10),0)\n            ;\n          }\n          comsub_ignore_return = comsub_ignore_return + -1;\n        }\n        if (puVar9 == (undefined *)0x0) {\n          puVar9 = &DAT_00213d70;\n        }\n        if (echo_command_at_execute != 0) {\n          xtrace_print_cond_term(param_1[2],uVar12,*(undefined8 *)(param_1 + 4),puVar9,0);\n        }\n        if (bVar14) {\n          uVar8 = set_expand_once(0,0);\n          iVar7 = unary_test(**(undefined8 **)(param_1 + 4),puVar9,lVar10);\n          assoc_expand_once = uVar8;\n        }\n        else {\n          iVar7 = unary_test(**(undefined8 **)(param_1 + 4),puVar9,lVar10);\n        }\n        uVar6 = (uint)(iVar7 == 0);\n        if (puVar9 != &DAT_00213d70) {\n          sh_xfree(puVar9,\"execute_cmd.c\",0xf5b);\n        }\n        goto LAB_00148f04;\n      }\n      if (uVar3 != 4) {\n        command_error(\"execute_cond_node\",1,uVar3,0);\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level(2);\n      }\n      pcVar5 = **(char ***)(param_1 + 4);\n      cVar1 = *pcVar5;\n      cVar2 = pcVar5[1];\n      bVar14 = cVar1 == '=';\n      if (cVar2 == '=') {\n        uVar13 = false;\n        if (pcVar5[2] == '\\0') {\n          uVar13 = cVar1 == '!' || bVar14;\n        }\nLAB_00148e9f:\n        if ((cVar1 == '-') &&\n           (((((iVar7 = strcmp(pcVar5,\"-eq\"), iVar7 == 0 ||\n               (iVar7 = strcmp(pcVar5,\"-ne\"), iVar7 == 0)) ||\n              (iVar7 = strcmp(pcVar5,\"-lt\"), iVar7 == 0)) ||\n             ((iVar7 = strcmp(pcVar5,\"-le\"), iVar7 == 0 ||\n              (iVar7 = strcmp(pcVar5,\"-gt\"), iVar7 == 0)))) ||\n            (iVar7 = strcmp(pcVar5,\"-ge\"), iVar7 == 0)))) {\n          if (uVar6 != 0) {\n            comsub_ignore_return = comsub_ignore_return + 1;\n            uVar13 = 3;\n            puVar9 = (undefined *)cond_expand_word(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10),3)\n            ;\n            bVar14 = false;\n            goto LAB_00149222;\n          }\n          uVar13 = 3;\n          puVar9 = (undefined *)cond_expand_word(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10),3);\n          bVar14 = false;\n          if (puVar9 != (undefined *)0x0) goto LAB_00149036;\n          goto LAB_001492e8;\n        }\nLAB_00148ea8:\n        bVar14 = false;\nLAB_00148eb0:\n        if (uVar6 == 0) goto LAB_00148eb9;\nLAB_00149309:\n        comsub_ignore_return = comsub_ignore_return + 1;\n        puVar9 = (undefined *)cond_expand_word(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10),0);\nLAB_00149222:\n        comsub_ignore_return = comsub_ignore_return + -1;\n        if (puVar9 == (undefined *)0x0) {\n          puVar9 = &DAT_00213d70;\n        }\nLAB_00149036:\n        lVar10 = *(long *)(param_1 + 8);\n        if (uVar6 == 0) goto LAB_00148edf;\n        comsub_ignore_return = comsub_ignore_return + 1;\n        puVar11 = (undefined *)cond_expand_word(*(undefined8 *)(lVar10 + 0x10),uVar13);\n        comsub_ignore_return = comsub_ignore_return + -1;\n      }\n      else {\n        uVar13 = cVar2 == '\\0' && bVar14;\n        if ((cVar2 != '~') || (!bVar14)) goto LAB_00148e9f;\n        if (pcVar5[2] != '\\0') goto LAB_00148ea8;\n        if (shell_compatibility_level < 0x20) {\n          bVar14 = true;\n          goto LAB_00148eb0;\n        }\n        if (uVar6 != 0) {\n          bVar14 = true;\n          uVar13 = 2;\n          goto LAB_00149309;\n        }\n        bVar14 = true;\n        uVar13 = 2;\nLAB_00148eb9:\n        puVar9 = (undefined *)cond_expand_word(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10),0);\n        if (puVar9 == (undefined *)0x0) {\nLAB_001492e8:\n          lVar10 = *(long *)(param_1 + 8);\n          puVar9 = &DAT_00213d70;\n        }\n        else {\n          lVar10 = *(long *)(param_1 + 8);\n        }\nLAB_00148edf:\n        puVar11 = (undefined *)cond_expand_word(*(undefined8 *)(lVar10 + 0x10),uVar13);\n      }\n      if (puVar11 == (undefined *)0x0) {\n        puVar11 = &DAT_00213d70;\n      }\n      if (echo_command_at_execute != 0) {\n        xtrace_print_cond_term(param_1[2],uVar12,*(undefined8 *)(param_1 + 4),puVar9,puVar11);\n      }\n      uVar8 = extended_glob;\n      if (bVar14) {\n        uVar6 = sh_regmatch(puVar9,puVar11,3);\n      }\n      else {\n        extended_glob = 1;\n        iVar7 = binary_test(**(undefined8 **)(param_1 + 4),puVar9,puVar11,7);\n        uVar6 = (uint)(iVar7 == 0);\n        extended_glob = uVar8;\n      }\n      if (puVar9 != &DAT_00213d70) {\n        sh_xfree(puVar9,\"execute_cmd.c\",0xfa2);\n      }\n      if (puVar11 != &DAT_00213d70) {\n        sh_xfree(puVar11,\"execute_cmd.c\",0xfa4);\n      }\n      goto LAB_00148f04;\n    }\n    uVar6 = FUN_00148e00(*(undefined8 *)(param_1 + 6));\n    if (uVar6 != 0) goto LAB_00148f04;\n  }\n  uVar6 = FUN_00148e00(*(undefined8 *)(param_1 + 8));\nLAB_00148f04:\n  if (uVar12 != 0) {\n    uVar6 = (uint)(uVar6 == 0);\n  }\n  return uVar6;\n}\n\n",
  "setresgid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint setresgid(__gid_t __rgid,__gid_t __egid,__gid_t __sgid)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_setresgid_002379e8)();\n  return iVar1;\n}\n\n",
  "exit": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit_noreturn_(int __status)\n\n{\n  (*(code *)PTR_exit_00237df8)();\n  return;\n}\n\n",
  "FUN_0015e730": "\nint FUN_0015e730(int param_1)\n\n{\n  int *piVar1;\n  long lVar2;\n  long **pplVar3;\n  long **pplVar4;\n  long **pplVar5;\n  int iVar6;\n  \n  lVar2 = *(long *)(jobs + (long)param_1 * 8);\n  pplVar3 = *(long ***)(lVar2 + 8);\n  pplVar5 = pplVar3;\n  if ((*(byte *)(lVar2 + 0x18) & 0x40) != 0) {\n    iVar6 = 0;\n    do {\n      piVar1 = (int *)((long)pplVar5 + 0xc);\n      pplVar5 = (long **)*pplVar5;\n      if (*piVar1 != 0) {\n        iVar6 = *piVar1;\n      }\n    } while (pplVar3 != pplVar5);\n    return iVar6;\n  }\n  do {\n    pplVar4 = pplVar5;\n    pplVar5 = (long **)*pplVar4;\n  } while (pplVar3 != pplVar5);\n  return *(int *)((long)pplVar4 + 0xc);\n}\n\n",
  "tokenize_array_reference": "\nundefined8 tokenize_array_reference(undefined8 param_1,uint param_2,char **param_3)\n\n{\n  int iVar1;\n  char *__s;\n  long lVar2;\n  size_t sVar3;\n  \n  __s = (char *)mbschr(param_1,0x5b);\n  if (__s != (char *)0x0) {\n    *__s = '\\0';\n    iVar1 = legal_identifier(param_1);\n    if ((((param_2 & 1) == 0) || (lVar2 = find_variable(param_1), lVar2 == 0)) ||\n       ((*(byte *)(lVar2 + 0x28) & 0x40) == 0)) {\n      *__s = '[';\n      if (iVar1 == 0) {\n        return 0;\n      }\n      iVar1 = skipsubscript(__s,0,0);\n    }\n    else {\n      *__s = '[';\n      if (iVar1 == 0) {\n        return 0;\n      }\n      if ((param_2 & 3) == 3) {\n        sVar3 = strlen(__s);\n        iVar1 = (int)sVar3 + -1;\n      }\n      else {\n        iVar1 = skipsubscript(__s,0,1);\n      }\n    }\n    if (((__s[iVar1] == ']') && (iVar1 != 1)) && (__s[(long)iVar1 + 1] == '\\0')) {\n      if (param_3 != (char **)0x0) {\n        __s[iVar1] = '\\0';\n        *__s = '\\0';\n        *param_3 = __s + 1;\n        return 1;\n      }\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
  "bind_function_def": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid bind_function_def(char *param_1,long param_2,uint param_3)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  undefined8 uVar3;\n  size_t sVar4;\n  char *pcVar5;\n  \n  uVar1 = shell_function_defs;\n  lVar2 = hash_search(param_1,shell_function_defs,0);\n  if (lVar2 != 0) {\n    lVar2 = *(long *)(lVar2 + 0x10);\n    _DAT_002422f8 = uVar1;\n    if (lVar2 != 0) {\n      if ((param_3 & 1) == 0) {\n        return;\n      }\n      dispose_function_def_contents(lVar2);\n      copy_function_def_contents(param_2,lVar2);\n      return;\n    }\n  }\n  uVar1 = *(undefined8 *)(param_2 + 0x10);\n  *(undefined8 *)(param_2 + 0x10) = 0;\n  uVar3 = copy_function_def(param_2);\n  *(undefined8 *)(param_2 + 0x10) = uVar1;\n  uVar1 = shell_function_defs;\n  sVar4 = strlen(param_1);\n  pcVar5 = (char *)sh_xmalloc(sVar4 + 1,\"variables.c\",0xdfd);\n  pcVar5 = strcpy(pcVar5,param_1);\n  lVar2 = hash_insert(pcVar5,uVar1,1);\n  *(undefined8 *)(lVar2 + 0x10) = uVar3;\n  return;\n}\n\n",
  "de_backslash": "\nchar * de_backslash(char *param_1)\n\n{\n  byte bVar1;\n  mbstate_t mVar2;\n  int iVar3;\n  size_t sVar4;\n  ulong uVar5;\n  long lVar6;\n  size_t sVar7;\n  int iVar8;\n  int iVar9;\n  int iVar10;\n  char *pcVar11;\n  long lVar12;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar4 = strlen(param_1);\n  pcVar11 = param_1;\n  if (sVar4 != 0) {\n    iVar8 = 0;\n    uVar5 = 0;\n    iVar10 = 0;\n    do {\n      while( true ) {\n        mVar2 = local_48;\n        iVar9 = iVar8;\n        if ((param_1[uVar5] == '\\\\') &&\n           (((param_1[uVar5 + 1] + 0xa4U & 0xfb) == 0 || (param_1[uVar5 + 1] == '$')))) {\n          iVar9 = iVar8 + 1;\n        }\n        if (locale_mb_cur_max < 2) goto LAB_0016c213;\n        bVar1 = param_1[iVar9];\n        if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) != 0) break;\n        if ((locale_utf8locale == 0) || ((char)bVar1 < '\\0')) {\n          sVar7 = mbrtowc((wchar_t *)0x0,param_1 + iVar9,sVar4 - (long)iVar9,&local_48);\n          if ((0xfffffffffffffffd < sVar7) || (mVar2 = local_48, sVar7 == 0)) goto LAB_0016c213;\n          iVar8 = (int)sVar7 + iVar9;\n          goto LAB_0016c24f;\n        }\n        if (bVar1 != 0) break;\nLAB_0016c213:\n        local_48 = mVar2;\n        iVar8 = iVar9 + 1;\n        if (iVar10 < iVar9) goto LAB_0016c253;\nLAB_0016c217:\n        uVar5 = (ulong)iVar8;\n        iVar10 = iVar8;\n        if (sVar4 <= uVar5) goto LAB_0016c28a;\n      }\n      iVar8 = iVar9 + 1;\nLAB_0016c24f:\n      if (iVar9 <= iVar10) goto LAB_0016c217;\nLAB_0016c253:\n      lVar6 = (long)iVar9;\n      lVar12 = iVar10 - lVar6;\n      do {\n        param_1[lVar6 + lVar12] = param_1[lVar6];\n        lVar6 = lVar6 + 1;\n      } while ((int)lVar6 < iVar8);\n      iVar3 = (iVar8 - iVar9) + -1;\n      if (iVar8 <= iVar9) {\n        iVar3 = 0;\n      }\n      iVar10 = iVar10 + 1 + iVar3;\n      uVar5 = (ulong)iVar8;\n    } while (uVar5 < sVar4);\nLAB_0016c28a:\n    pcVar11 = param_1 + iVar10;\n  }\n  *pcVar11 = '\\0';\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return param_1;\n}\n\n",
  "FUN_001ae530": "\nint FUN_001ae530(long param_1,int param_2,int *param_3)\n\n{\n  int iVar1;\n  \n  if (param_3 != (int *)0x0) {\n    *param_3 = (param_2 < 1) + 1;\n  }\n  if ((param_1 != 0) || (param_2 < 1)) {\n    if (param_1 != DAT_00248b48) {\n      if ((-1 < param_1) && (param_1 <= DAT_00248b48)) {\n        iVar1 = DAT_00248b48 - (int)param_1;\n        if (param_2 < 1) {\n          iVar1 = (int)param_1;\n        }\n        return iVar1;\n      }\n      return -1;\n    }\n    if (param_3 != (int *)0x0) {\n      *param_3 = (0 < param_2) + 1;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
  "rl_forward_char": "\nundefined8 rl_forward_char(int param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  undefined8 uVar3;\n  \n  sVar2 = __ctype_get_mb_cur_max();\n  if ((sVar2 != 1) && (rl_byte_oriented == 0)) {\n    if (param_1 < 0) {\n      uVar3 = rl_backward_char(-param_1,param_2);\n      return uVar3;\n    }\n    iVar1 = rl_point;\n    if (param_1 != 0) {\n      if ((rl_point == rl_end) && (rl_editing_mode == 1)) {\n        rl_ding();\n        iVar1 = rl_point;\n      }\n      else {\n        iVar1 = _rl_forward_char_internal(param_1);\n        if (iVar1 == rl_point) {\n          rl_ding();\n        }\n      }\n    }\n    rl_point = iVar1;\n    return 0;\n  }\n  uVar3 = rl_forward_byte(param_1,param_2);\n  return uVar3;\n}\n\n",
  "dispose_redirects": "\nvoid dispose_redirects(long *param_1)\n\n{\n  long *plVar1;\n  ulong uVar2;\n  \n  if (param_1 == (long *)0x0) {\n    return;\n  }\n  do {\n    plVar1 = (long *)*param_1;\n    if ((*(byte *)(param_1 + 2) & 1) != 0) {\n      dispose_word(param_1[1]);\n    }\n    if (*(uint *)(param_1 + 3) < 0x14) {\n      uVar2 = 1L << ((byte)*(uint *)(param_1 + 3) & 0x3f);\n      if ((uVar2 & 0xe7c2f) == 0) {\n        if ((uVar2 & 0x110) == 0) goto LAB_0014778e;\n        sh_xfree(param_1[5],\"dispose_cmd.c\",0x140);\n      }\n      dispose_word(param_1[4]);\n    }\nLAB_0014778e:\n    sh_xfree(param_1,\"dispose_cmd.c\",0x154);\n    param_1 = plVar1;\n    if (plVar1 == (long *)0x0) {\n      return;\n    }\n  } while( true );\n}\n\n",
  "find_index_in_alist": "\nint find_index_in_alist(char *param_1,char **param_2,int param_3)\n\n{\n  int iVar1;\n  char *__s2;\n  int iVar2;\n  \n  __s2 = *param_2;\n  if (__s2 != (char *)0x0) {\n    param_2 = param_2 + 2;\n    iVar2 = 0;\n    do {\n      if (param_3 == 0) {\n        if ((*param_1 == *__s2) && (iVar1 = strcmp(param_1,__s2), iVar1 == 0)) {\n          return iVar2;\n        }\n      }\n      else {\n        iVar1 = strmatch(__s2,param_1,0x20);\n        if (iVar1 != 1) {\n          return iVar2;\n        }\n      }\n      __s2 = *param_2;\n      param_2 = param_2 + 2;\n      iVar2 = iVar2 + 1;\n    } while (__s2 != (char *)0x0);\n  }\n  return -1;\n}\n\n",
  "minus_o_option_value": "\nulong minus_o_option_value(char *param_1)\n\n{\n  long lVar1;\n  char cVar2;\n  char cVar3;\n  int iVar4;\n  ulong uVar5;\n  uint *puVar6;\n  undefined **ppuVar7;\n  int iVar8;\n  char *__s2;\n  \n  cVar3 = 'a';\n  __s2 = \"allexport\";\n  iVar8 = 0;\n  ppuVar7 = &PTR_s_braceexpand_00235fe8;\n  cVar2 = *param_1;\n  while ((cVar2 != cVar3 || (iVar4 = strcmp(param_1,__s2), iVar4 != 0))) {\n    __s2 = *ppuVar7;\n    ppuVar7 = ppuVar7 + 5;\n    iVar8 = iVar8 + 1;\n    if (__s2 == (char *)0x0) {\n      return 0xffffffff;\n    }\n    cVar3 = *__s2;\n  }\n  lVar1 = (long)iVar8 * 0x28;\n  if (*(int *)(&DAT_00235fc8 + lVar1) == 0) {\n    if (*(code **)(&DAT_00235fe0 + lVar1) != (code *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x001b1b63. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      uVar5 = (**(code **)(&DAT_00235fe0 + lVar1))(param_1);\n      return uVar5;\n    }\n    puVar6 = (uint *)(&DAT_00235fd0)[(long)iVar8 * 5];\n  }\n  else {\n    puVar6 = (uint *)find_flag();\n    if (puVar6 == (uint *)0x0) {\n      return 0xffffffff;\n    }\n  }\n  return (ulong)*puVar6;\n}\n\n",
  "sh_realloc": "\nvoid sh_realloc(void)\n\n{\n  FUN_001f9500();\n  return;\n}\n\n",
  "FUN_00133d60": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00133d60(void)\n\n{\n  uint uVar1;\n  int iVar2;\n  size_t sVar3;\n  char *__dest;\n  long in_FS_OFFSET;\n  bool bVar4;\n  char acStack_128 [264];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (shell_initialized == 0) {\n    sh_setlinebuf(stderr);\n    sh_setlinebuf(stdout);\n  }\n  initialize_shell_builtins();\n  initialize_traps();\n  initialize_signals(0);\n  if (current_host_name == (char *)0x0) {\n    iVar2 = gethostname(acStack_128,0xff);\n    if (iVar2 < 0) {\n      current_host_name = \"??host??\";\n    }\n    else {\n      sVar3 = strlen(acStack_128);\n      __dest = (char *)sh_xmalloc(sVar3 + 1,\"shell.c\",0x7a6);\n      current_host_name = strcpy(__dest,acStack_128);\n    }\n  }\n  if ((interactive_shell != 0) && (DAT_00238050 == 0)) {\n    FUN_00133bd0();\n  }\n  tilde_initialize();\n  if (restricted == 0) {\n    uVar1 = FUN_00133b90(shell_name);\n    bVar4 = (privileged_mode | restricted | _DAT_002409d4 | uVar1) != 0;\n  }\n  else {\n    uVar1 = 1;\n    bVar4 = true;\n  }\n  initialize_shell_variables(shell_environment,bVar4);\n  initialize_job_control(jobs_m_flag);\n  initialize_bash_input();\n  initialize_flags();\n  initialize_shell_options((privileged_mode | restricted | _DAT_002409d4 | uVar1) != 0);\n  initialize_bashopts((privileged_mode | restricted | _DAT_002409d4 | uVar1) != 0);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_dispatch": "\nvoid _rl_dispatch(undefined8 param_1,undefined8 param_2)\n\n{\n  _rl_dispatching_keymap = param_2;\n  _rl_dispatch_subseq(param_1,param_2,0);\n  return;\n}\n\n",
  "rl_unbind_key": "\nvoid rl_unbind_key(undefined8 param_1)\n\n{\n  rl_bind_key(param_1,0);\n  return;\n}\n\n",
  "strtold": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ndouble strtold(char *__nptr,char **__endptr)\n\n{\n  double dVar1;\n  \n  dVar1 = (double)(*(code *)PTR_strtold_00237d00)();\n  return dVar1;\n}\n\n",
  "zsyncfd": "\nvoid zsyncfd(int param_1)\n\n{\n  __off_t _Var1;\n  \n  if (0 < DAT_00248ec0 - DAT_00248ec8) {\n    _Var1 = lseek(param_1,-(DAT_00248ec0 - DAT_00248ec8),1);\n    if (_Var1 == -1) {\n      return;\n    }\n  }\n  DAT_00248ec8 = 0;\n  DAT_00248ec0 = 0;\n  return;\n}\n\n",
  "string_list_dollar_star": "\nvoid string_list_dollar_star(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined *puVar2;\n  size_t sVar3;\n  size_t sVar4;\n  ulong uVar5;\n  undefined *puVar6;\n  long in_FS_OFFSET;\n  undefined auStack_38 [8];\n  long local_30;\n  undefined *puVar7;\n  \n  puVar6 = auStack_38;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar4 = __ctype_get_mb_cur_max();\n  sVar3 = ifs_firstc_len;\n  puVar7 = auStack_38;\n  puVar2 = auStack_38;\n  while (puVar7 != auStack_38 + -(sVar4 + 0x10 & 0xfffffffffffff000)) {\n    puVar6 = puVar2 + -0x1000;\n    *(undefined8 *)(puVar2 + -8) = *(undefined8 *)(puVar2 + -8);\n    puVar7 = puVar2 + -0x1000;\n    puVar2 = puVar2 + -0x1000;\n  }\n  uVar5 = (ulong)((uint)(sVar4 + 0x10) & 0xff0);\n  lVar1 = -uVar5;\n  if (uVar5 != 0) {\n    *(undefined8 *)(puVar6 + -8) = *(undefined8 *)(puVar6 + -8);\n  }\n  if (ifs_firstc_len == 1) {\n    puVar6[lVar1 + 1] = 0;\n    puVar6[lVar1] = ifs_firstc;\n  }\n  else {\n    *(undefined8 *)(puVar6 + lVar1 + -8) = 0x16e512;\n    memcpy(puVar6 + lVar1,&ifs_firstc,ifs_firstc_len);\n    puVar6[sVar3 + lVar1] = 0;\n  }\n  *(undefined8 *)(puVar6 + lVar1 + -8) = 0x16e4e1;\n  string_list_internal(param_1,(long)puVar6 + lVar1);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  *(undefined **)(puVar6 + lVar1 + -8) = &UNK_0016e53d;\n  __stack_chk_fail();\n}\n\n",
  "FUN_0017aeb0": "\nundefined * FUN_0017aeb0(char *param_1,undefined4 param_2)\n\n{\n  size_t sVar1;\n  char *__dest;\n  undefined *puVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  char *local_38;\n  undefined4 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = 0;\n  sVar1 = strlen(param_1);\n  __dest = (char *)sh_xmalloc(sVar1 + 1,\"subst.c\",0x10fa);\n  local_38 = strcpy(__dest,param_1);\n  puVar2 = (undefined *)FUN_00177e80(&local_38,param_2,0,0,0);\n  if (puVar2 == &DAT_00247880) {\n    uVar3 = 2;\n  }\n  else {\n    if (puVar2 != &DAT_00247870) {\n      if (local_38 != (char *)0x0) {\n        sh_xfree(local_38,\"subst.c\",0x10fe);\n      }\n      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return puVar2;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    uVar3 = 1;\n  }\n  last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n  FUN_001667f0(uVar3);\n}\n\n",
  "list_stopped_jobs": "\nvoid list_stopped_jobs(undefined4 param_1)\n\n{\n  if (DAT_0023877c == 0) {\n    return;\n  }\n  if (DAT_00247660 == 0) {\n    FUN_001626a0();\n    if (DAT_0023877c == 0) {\n      return;\n    }\n  }\n  FUN_0015f750(param_1,2);\n  return;\n}\n\n",
  "coproc_flush": "\nvoid coproc_flush(void)\n\n{\n  FUN_0014a430(&sh_coproc);\n  return;\n}\n\n",
  "fputc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fputc_00237ab0)();\n  return iVar1;\n}\n\n",
  "sh_eaccess": "\nint sh_eaccess(char *param_1,uint param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  undefined auStack_b8 [24];\n  uint local_a0;\n  int local_9c;\n  __gid_t local_98;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*param_1 == '/') {\n    if ((param_1[1] == 'd') && (iVar2 = strncmp(param_1,\"/dev/fd/\",8), iVar2 == 0))\n    goto LAB_001c5a1a;\n    iVar2 = strncmp(param_1,\"/dev/std\",8);\n    if (iVar2 == 0) {\n      cVar1 = param_1[8];\n      if (cVar1 == 'i') {\n        if ((param_1[9] == 'n') && (param_1[10] == '\\0')) goto LAB_001c5a1a;\n      }\n      else {\n        if (cVar1 == 'o') {\n          iVar2 = strcmp(param_1 + 8,\"out\");\n        }\n        else {\n          if (cVar1 != 'e') goto LAB_001c598c;\n          iVar2 = strcmp(param_1 + 8,\"err\");\n        }\n        if (iVar2 == 0) {\nLAB_001c5a1a:\n          iVar2 = sh_stat(param_1,auStack_b8);\n          if (iVar2 < 0) {\n            iVar2 = -1;\n          }\n          else {\n            if ((DAT_00238044 != 0) || (((param_2 & 1) != 0 && ((local_a0 & 0x49) == 0)))) {\n              if (DAT_00238044 == local_9c) {\n                param_2 = param_2 << 6;\n              }\n              else {\n                iVar2 = group_member(local_98);\n                if (iVar2 != 0) {\n                  param_2 = param_2 * 8;\n                }\n              }\n              if ((param_2 & local_a0) == 0) {\n                piVar3 = __errno_location();\n                *piVar3 = 0xd;\n                iVar2 = -1;\n                goto LAB_001c5a5f;\n              }\n            }\n            iVar2 = 0;\n          }\nLAB_001c5a5f:\n          if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n            return iVar2;\n          }\n          goto LAB_001c5b28;\n        }\n      }\n    }\n  }\nLAB_001c598c:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    iVar2 = faccessat(-100,param_1,param_2,0x200);\n    return iVar2;\n  }\nLAB_001c5b28:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_vi_next_word": "\nundefined8 rl_vi_next_word(int param_1,ulong param_2)\n\n{\n  ushort **ppuVar1;\n  undefined8 uVar2;\n  \n  if (param_1 < 0) {\n    uVar2 = rl_vi_prev_word(-param_1);\n    return uVar2;\n  }\n  if (rl_point < rl_end + -1) {\n    ppuVar1 = __ctype_b_loc();\n    if ((*(byte *)((long)*ppuVar1 + (param_2 & 0xff) * 2 + 1) & 1) == 0) {\n      rl_vi_fword();\n      return 0;\n    }\n    rl_vi_fWord(param_1,param_2 & 0xffffffff);\n    return 0;\n  }\n  rl_ding();\n  return 0;\n}\n\n",
  "pop_dollar_vars": "\nvoid pop_dollar_vars(void)\n\n{\n  long *plVar1;\n  undefined8 *puVar2;\n  long lVar3;\n  long lVar4;\n  \n  if ((DAT_002422d8 != 0) && (DAT_002422cc != 0)) {\n    clear_dollar_vars();\n    DAT_002422cc = DAT_002422cc + -1;\n    plVar1 = (long *)(DAT_002422d8 + (long)DAT_002422cc * 0x18);\n    rest_of_args = plVar1[1];\n    lVar3 = *plVar1;\n    lVar4 = 8;\n    do {\n      *(undefined8 *)((long)&dollar_vars + lVar4) = *(undefined8 *)(lVar3 + lVar4);\n      lVar4 = lVar4 + 8;\n    } while (lVar4 != 0x50);\n    sh_xfree(lVar3,\"variables.c\",0x1636);\n    puVar2 = (undefined8 *)(DAT_002422d8 + (long)DAT_002422cc * 0x18);\n    posparam_count = *(undefined4 *)(puVar2 + 2);\n    puVar2[1] = 0;\n    *(undefined4 *)(puVar2 + 2) = 0;\n    *puVar2 = 0;\n    set_dollar_vars_unchanged();\n    invalidate_cached_quoted_dollar_at();\n    return;\n  }\n  return;\n}\n\n",
  "strtoimax": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nlong strtoimax(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
  "nohup_all_jobs": "\nvoid nohup_all_jobs(int param_1)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  long *plVar4;\n  long *plVar5;\n  long *plVar6;\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_128);\n  sigaddset(&sStack_128,0x11);\n  sigemptyset(&local_a8);\n  sigprocmask(0,&sStack_128,&local_a8);\n  if (0 < DAT_0023877c) {\n    uVar1 = DAT_0023877c - 1;\n    plVar2 = jobs + 1;\n    plVar4 = plVar2;\n    plVar6 = jobs;\n    while( true ) {\n      plVar5 = plVar4;\n      lVar3 = *plVar6;\n      if ((lVar3 != 0) && ((param_1 == 0 || (*(int *)(lVar3 + 0x14) == 1)))) {\n        *(uint *)(lVar3 + 0x18) = *(uint *)(lVar3 + 0x18) | 8;\n      }\n      if (plVar5 == plVar2 + uVar1) break;\n      plVar4 = plVar5 + 1;\n      plVar6 = plVar5;\n    }\n  }\n  sigprocmask(2,&local_a8,(sigset_t *)0x0);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00168e50": "\nvoid FUN_00168e50(long *param_1,long param_2,uint param_3)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  long lVar3;\n  code *pcVar4;\n  bool bVar5;\n  uint local_3c;\n  \n  pcVar4 = do_word_assignment;\n  if (param_3 == 0) {\n    pcVar4 = assign_in_env;\n  }\n  tempenv_assign_error = 0;\n  if (param_2 == 0) {\n    local_3c = 0;\n    bVar5 = false;\n  }\n  else {\n    bVar5 = true;\n    lVar3 = find_shell_builtin(param_2);\n    if (lVar3 == 0) {\n      lVar3 = find_function(param_2);\n      bVar5 = lVar3 != 0;\n    }\n    local_3c = posixly_correct;\n    if (posixly_correct != 0) {\n      lVar3 = find_special_builtin(param_2);\n      local_3c = (uint)(lVar3 != 0);\n    }\n  }\n  uVar1 = this_command_name;\n  if (param_1 != (long *)0x0) {\n    do {\n      this_command_name = 0;\n      assigning_in_environment = param_3 ^ 1;\n      iVar2 = (*pcVar4)(param_1[1],bVar5);\n      assigning_in_environment = 0;\n      if (iVar2 == 0) {\n        this_command_name = uVar1;\n        if (param_3 != 0) {\n          if ((posixly_correct == 0) || ((interactive_shell | executing_command_builtin) != 0)) {\nLAB_00168f7c:\n            last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n            FUN_001667f0(2);\n          }\nLAB_00168fac:\n          last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n          FUN_001667f0(1);\n        }\n        if (posixly_correct != 0) {\n          if ((interactive_shell != 0) || (local_3c == 0)) goto LAB_00168f7c;\n          goto LAB_00168fac;\n        }\n        tempenv_assign_error = tempenv_assign_error + 1;\n      }\n      param_1 = (long *)*param_1;\n    } while (param_1 != (long *)0x0);\n  }\n  this_command_name = uVar1;\n  return;\n}\n\n",
  "FUN_00194d10": "\nvoid FUN_00194d10(char *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  long lVar4;\n  \n  iVar2 = rl_point;\n  iVar1 = rl_end;\n  lVar4 = (long)rl_point;\n  if (param_1 != (char *)0x0) {\n    iVar3 = strcmp(param_1,rl_line_buffer);\n    if (iVar3 != 0) {\n      FUN_00194330(param_1);\n    }\n  }\n  sh_xfree(param_1,\"bashline.c\",0xac8);\n  if (iVar1 != iVar2) {\n    if (iVar2 < rl_end) {\n      rl_point = iVar2;\n      if ((rl_line_buffer[lVar4] != ' ') && (rl_line_buffer[lVar4] != '\\t')) {\n        rl_forward_word(1,0);\n        return;\n      }\n    }\n    return;\n  }\n  rl_point = rl_end;\n  return;\n}\n\n",
  "wait_for_any_job": "\nuint wait_for_any_job(uint param_1,undefined4 *param_2)\n\n{\n  long *plVar1;\n  long *plVar2;\n  uint uVar3;\n  int iVar4;\n  ulong uVar5;\n  long *plVar6;\n  int *piVar7;\n  long lVar8;\n  uint uVar9;\n  long in_FS_OFFSET;\n  sigset_t sStack_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00247660 == 0) {\n    sigemptyset(&sStack_148);\n    sigaddset(&sStack_148,0x11);\n    sigemptyset(&local_c8);\n    sigprocmask(0,&sStack_148,&local_c8);\n    if (0 < DAT_0023877c) {\n      uVar5 = 0;\n      do {\n        lVar8 = *(long *)(jobs + uVar5 * 8);\n        if ((param_1 & 8) == 0) {\n          if (lVar8 != 0) {\n            iVar4 = *(int *)(lVar8 + 0x14);\njoined_r0x00164487:\n            if ((iVar4 == 4) && ((*(byte *)(lVar8 + 0x18) & 2) == 0)) goto LAB_001644c0;\n          }\n        }\n        else if ((lVar8 != 0) && ((*(byte *)(lVar8 + 0x18) & 0x80) != 0)) {\n          iVar4 = *(int *)(lVar8 + 0x14);\n          goto joined_r0x00164487;\n        }\n        uVar5 = uVar5 + 1;\n      } while ((long)DAT_0023877c != uVar5);\n    }\n    sigprocmask(2,&local_c8,(sigset_t *)0x0);\n    while( true ) {\n      sigemptyset(&sStack_148);\n      sigaddset(&sStack_148,0x11);\n      sigemptyset(&local_c8);\n      sigprocmask(0,&sStack_148,&local_c8);\n      if (DAT_0023877c < 1) {\n        iVar4 = 0;\n      }\n      else {\n        uVar5 = 1;\n        do {\n          lVar8 = *(long *)(jobs + -8 + uVar5 * 8);\n          if (((lVar8 != 0) && (*(int *)(lVar8 + 0x14) == 1)) &&\n             ((*(byte *)(lVar8 + 0x18) & 1) == 0)) goto LAB_00164618;\n          iVar4 = (int)uVar5;\n          uVar5 = uVar5 + 1;\n        } while (DAT_0023877c + 1 != uVar5);\n      }\n      if (DAT_0023877c == iVar4) break;\nLAB_00164618:\n      sigprocmask(2,&local_c8,(sigset_t *)0x0);\n      if (terminating_signal != 0) {\n        termsig_handler(terminating_signal);\n      }\n      if (interrupt_state != 0) {\n        throw_to_top_level();\n      }\n      if (terminating_signal != 0) {\n        termsig_handler(terminating_signal);\n      }\n      if (((wait_intr_flag != 0) && (wait_signal_received != 0)) &&\n         ((this_shell_builtin == PTR_wait_builtin_00237f70 &&\n          (this_shell_builtin != (undefined *)0x0)))) {\n                    /* WARNING: Subroutine does not return */\n        __longjmp_chk(wait_intr_buf,1);\n      }\n      piVar7 = __errno_location();\n      *piVar7 = 0;\n      iVar4 = wait_for(0xffffffff,0);\n      if (((iVar4 == -1) && (*piVar7 == 10)) && (DAT_0023877c != 0)) {\n        FUN_0015ebc0();\n      }\n      sigemptyset(&sStack_148);\n      sigaddset(&sStack_148,0x11);\n      sigemptyset(&local_c8);\n      sigprocmask(0,&sStack_148,&local_c8);\n      if (0 < DAT_0023877c) {\n        uVar5 = 0;\nLAB_00164706:\n        do {\n          lVar8 = *(long *)(jobs + uVar5 * 8);\n          if ((param_1 & 8) == 0) {\n            if (lVar8 == 0) {\n              uVar5 = uVar5 + 1;\n              if ((long)DAT_0023877c == uVar5) break;\n              goto LAB_00164706;\n            }\nLAB_001646f3:\n            if (*(int *)(lVar8 + 0x14) == 4) goto LAB_001644c0;\n          }\n          else if ((lVar8 != 0) && ((*(byte *)(lVar8 + 0x18) & 0x80) != 0)) goto LAB_001646f3;\n          uVar5 = uVar5 + 1;\n        } while ((long)DAT_0023877c != uVar5);\n      }\n      sigprocmask(2,&local_c8,(sigset_t *)0x0);\n    }\n    uVar9 = 0xffffffff;\n    sigprocmask(2,&local_c8,(sigset_t *)0x0);\n  }\n  else {\n    uVar9 = 0xffffffff;\n  }\nLAB_0016455f:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar9;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\nLAB_001644c0:\n  uVar5 = uVar5 & 0xffffffff;\n  lVar8 = jobs;\n  uVar3 = FUN_0015e730(uVar5);\n  if ((char)(((byte)uVar3 & 0x7f) + 1) < '\\x02') {\n    uVar9 = 0;\n    if ((byte)uVar3 != 0x7f) {\n      uVar9 = uVar3 >> 8 & 0xff;\n    }\n  }\n  else {\n    uVar9 = (uVar3 & 0x7f) + 0x80;\n  }\n  plVar1 = *(long **)(*(long *)(lVar8 + (long)(int)uVar5 * 8) + 8);\n  plVar2 = plVar1;\n  do {\n    plVar6 = plVar2;\n    if (plVar6 == (long *)0x0) {\n      do {\n        invalidInstructionException();\n      } while( true );\n    }\n    plVar2 = (long *)*plVar6;\n  } while (plVar1 != (long *)*plVar6);\n  if (param_2 != (undefined4 *)0x0) {\n    *param_2 = *(undefined4 *)(plVar6 + 1);\n    *(short *)(param_2 + 1) = (short)uVar9;\n  }\n  if (((DAT_0023877c != 0) && (FUN_0015fd20(), DAT_0023877c != 0)) && (DAT_00247660 == 0)) {\n    FUN_0015f990(uVar5,0);\n  }\n  coproc_reap();\n  sigprocmask(2,&local_c8,(sigset_t *)0x0);\n  goto LAB_0016455f;\n}\n\n",
  "set_dirstack_element": "\nvoid set_dirstack_element(long param_1,int param_2,char *param_3)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  int iVar3;\n  char **ppcVar4;\n  bool bVar5;\n  \n  bVar5 = param_1 == 0;\n  if ((param_2 < 1) || (!bVar5)) {\n    if (param_1 == DAT_00248b48) {\n      iVar3 = 0;\n    }\n    else {\n      if (param_1 < 0) {\n        return;\n      }\n      if (DAT_00248b48 < param_1) {\n        return;\n      }\n      iVar3 = (int)param_1;\n      if (param_2 < 1) {\n        bVar5 = (bool)(bVar5 | (byte)((ulong)param_1 >> 0x18) >> 7);\n      }\n      else {\n        iVar3 = DAT_00248b48 - iVar3;\n        bVar5 = SUB41((uint)iVar3 >> 0x1f,0);\n      }\n    }\n    if ((bVar5 == false) && (iVar3 <= DAT_00248b48)) {\n      sh_xfree(*(undefined8 *)(DAT_00248b50 + (long)iVar3 * 8),\"./pushd.def\",0x290);\n      sVar1 = strlen(param_3);\n      pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"./pushd.def\",0x291);\n      ppcVar4 = (char **)((long)iVar3 * 8 + DAT_00248b50);\n      pcVar2 = strcpy(pcVar2,param_3);\n      *ppcVar4 = pcVar2;\n      return;\n    }\n  }\n  return;\n}\n\n",
  "_rl_end_executing_keyseq": "\nvoid _rl_end_executing_keyseq(void)\n\n{\n  if (0 < rl_key_sequence_length) {\n    rl_key_sequence_length = rl_key_sequence_length + -1;\n    *(undefined *)(rl_executing_keyseq + rl_key_sequence_length) = 0;\n  }\n  return;\n}\n\n",
  "strvec_remove": "\nundefined8 strvec_remove(char **param_1,char *param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  char *__s2;\n  long lVar4;\n  \n  if (param_1 == (char **)0x0) {\n    return 0;\n  }\n  __s2 = *param_1;\n  if (__s2 != (char *)0x0) {\n    cVar1 = *param_2;\n    lVar3 = 0;\n    do {\n      while (lVar4 = (long)(int)lVar3, cVar1 == *__s2) {\n        iVar2 = strcmp(param_2,__s2);\n        if (iVar2 == 0) {\n          for (; param_1[lVar4] != (char *)0x0; lVar4 = lVar4 + 1) {\n            param_1[lVar4] = param_1[lVar4 + 1];\n          }\n          sh_xfree(__s2,\"stringvec.c\",0x77);\n          return 1;\n        }\n        lVar3 = lVar3 + 1;\n        __s2 = param_1[lVar3];\n        if (__s2 == (char *)0x0) {\n          return 0;\n        }\n      }\n      lVar3 = lVar3 + 1;\n      __s2 = param_1[lVar3];\n    } while (__s2 != (char *)0x0);\n  }\n  return 0;\n}\n\n",
  "_rl_keyseq_cxt_alloc": "\nvoid _rl_keyseq_cxt_alloc(void)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  \n  puVar2 = (undefined8 *)xmalloc(0x30);\n  uVar1 = _rl_kscxt;\n  *puVar2 = 0;\n  puVar2[1] = 0;\n  puVar2[4] = uVar1;\n  *(undefined4 *)(puVar2 + 5) = 0x2a;\n  return;\n}\n\n",
  "FUN_00149940": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 FUN_00149940(long **param_1,uint param_2,uint param_3,int param_4)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  long **pplVar4;\n  int iVar5;\n  bool bVar6;\n  bool bVar7;\n  \n  if (param_1 == (long **)0x0) {\n    bVar6 = false;\n  }\n  else {\n    iVar5 = 0;\n    pplVar4 = param_1;\nLAB_0014999c:\n    do {\n      iVar5 = iVar5 + (*(uint *)(pplVar4 + 2) & 1);\n      if (*(int *)(pplVar4 + 1) == 0) {\n        iVar2 = *(int *)(pplVar4 + 3);\njoined_r0x00149981:\n        if ((iVar2 - 1U < 2) || (iVar2 == 0xb)) {\n          pplVar4 = (long **)*pplVar4;\n          iVar5 = iVar5 + 1;\n          if (pplVar4 == (long **)0x0) break;\n          goto LAB_0014999c;\n        }\n        if (iVar2 - 9U < 10) {\n          iVar5 = iVar5 + *(int *)(&DAT_001fcde0 + (ulong)(iVar2 - 9U) * 4);\n        }\n      }\n      else {\n        iVar2 = fd_is_bash_input();\n        if (iVar2 != 0) {\n          iVar2 = *(int *)(pplVar4 + 3);\n          goto joined_r0x00149981;\n        }\n      }\n      pplVar4 = (long **)*pplVar4;\n    } while (pplVar4 != (long **)0x0);\n    bVar6 = iVar5 != 0;\n  }\n  bVar7 = param_4 != 0;\n  if ((param_2 != 0xffffffff) || (bVar6)) {\n    iVar5 = make_child(0,bVar7);\n    if (iVar5 == 0) goto LAB_00149a73;\n    if (-1 < (int)param_2) {\n      close(param_2);\n    }\n  }\n  else {\n    if ((param_3 == 0xffffffff) && (!bVar7)) {\n      iVar5 = do_redirections(param_1,3);\n      uVar1 = redirection_undo_list;\n      do_redirections(redirection_undo_list,1);\n      dispose_redirects(uVar1);\n      redirection_undo_list = 0;\n      uVar3 = 1;\n      if ((iVar5 == 0) && (uVar3 = last_command_exit_value, last_command_subst_pid == -1)) {\n        redirection_undo_list = 0;\n        return 0;\n      }\n      return uVar3;\n    }\n    iVar5 = make_child(0,bVar7);\n    if (iVar5 == 0) {\nLAB_00149a73:\n      restore_original_signals();\n      FUN_001497c0(param_2,param_3);\n      if (-1 < DAT_0023842c) {\n        close(DAT_0023842c);\n        DAT_0023842c = -1;\n      }\n      if (-1 < DAT_00238430) {\n        close(DAT_00238430);\n        DAT_00238430 = -1;\n      }\n      interactive = 0;\n      _DAT_00238434 = 0xffffffffffffffff;\n      subshell_environment = (uint)(param_4 != 0);\n      if ((param_3 & param_2) != 0xffffffff) {\n        subshell_environment = subshell_environment | 0x10;\n      }\n      iVar5 = do_redirections(param_1,1);\n      if (iVar5 != 0) {\n                    /* WARNING: Subroutine does not return */\n        exit(1);\n      }\n                    /* WARNING: Subroutine does not return */\n      exit(0);\n    }\n  }\n  if ((int)param_3 < 0) {\n    if (param_3 == 0xffffffff) {\n      unlink_fifo_list();\n    }\n    return 0;\n  }\n  close(param_3);\n  return 0;\n}\n\n",
  "FUN_0014e920": "\nundefined4 FUN_0014e920(byte *param_1,uint param_2)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  long lVar3;\n  \n  lVar3 = *(long *)(param_1 + 8);\n  loop_level = loop_level + 1;\n  *(uint *)(lVar3 + 4) = *(uint *)(lVar3 + 4) | 8;\n  if ((*param_1 & 8) != 0) {\n    *(uint *)(*(long *)(param_1 + 0x10) + 4) = *(uint *)(*(long *)(param_1 + 0x10) + 4) | 8;\n  }\n  uVar1 = 0;\n  do {\n    iVar2 = execute_command(lVar3);\n    if ((job_control == 0) || (interactive_shell == 0)) {\n      reap_dead_jobs();\n    }\n    if (iVar2 == 0) {\nLAB_0014ea04:\n      if ((param_2 & 1) != 0) {\nLAB_0014ea0d:\n        if (breaking != 0) {\n          breaking = breaking + -1;\n        }\n        if (continuing != 0) {\n          continuing = continuing + -1;\n        }\nLAB_0014ea33:\n        loop_level = loop_level + -1;\n        return uVar1;\n      }\n    }\n    else {\n      if (((param_2 ^ 1) & 1) != 0) goto LAB_0014ea0d;\n      if (iVar2 == 0) goto LAB_0014ea04;\n    }\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      throw_to_top_level();\n    }\n    uVar1 = execute_command(*(undefined8 *)(param_1 + 0x10));\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    iVar2 = breaking;\n    if (interrupt_state != 0) {\n      throw_to_top_level();\n      iVar2 = breaking;\n    }\n    if (iVar2 != 0) {\n      breaking = iVar2 + -1;\n      goto LAB_0014ea33;\n    }\n    if (continuing != 0) {\n      continuing = continuing + -1;\n      breaking = 0;\n      if (continuing != 0) goto LAB_0014ea33;\n    }\n    lVar3 = *(long *)(param_1 + 8);\n    breaking = iVar2;\n  } while( true );\n}\n\n",
  "FUN_00192370": "\nchar * FUN_00192370(char *param_1,int param_2)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long lVar3;\n  size_t sVar4;\n  char *__dest;\n  char *pcVar5;\n  long lVar6;\n  int iVar7;\n  long lVar8;\n  long *plVar9;\n  void *pvVar10;\n  long *plVar11;\n  \n  if (param_2 == 0) {\n    if (DAT_00248870 != 0) {\n      rl_completion_suppress_append = 1;\n    }\n    DAT_002487e0 = 0;\n    if (DAT_00248844 == 0) {\n      plVar1 = (long *)history_list();\n    }\n    else {\n      strvec_dispose(DAT_00248848);\n      DAT_00248848 = (void *)0x0;\n      DAT_00248844 = 0;\n      DAT_00248840 = 0;\n      plVar1 = (long *)history_list();\n    }\n    if (plVar1 != (long *)0x0) {\n      lVar3 = 0;\n      if (*plVar1 != 0) {\n        do {\n          lVar8 = lVar3;\n          lVar3 = lVar8 + 1;\n        } while (plVar1[lVar8 + 1] != 0);\n        plVar9 = plVar1 + (int)lVar8;\n        do {\n          plVar2 = (long *)history_tokenize(*(undefined8 *)*plVar9);\n          plVar11 = plVar2;\n          if (plVar2 != (long *)0x0) {\n            for (; lVar3 = *plVar11, lVar3 != 0; plVar11 = plVar11 + 1) {\n              iVar7 = DAT_00248840 + 1;\n              if (DAT_00248844 <= iVar7) {\n                DAT_00248844 = DAT_00248844 + 10;\n                DAT_00248848 = (void *)strvec_resize();\n                lVar3 = *plVar11;\n                iVar7 = DAT_00248840 + 1;\n              }\n              pvVar10 = DAT_00248848;\n              lVar6 = (long)DAT_00248840;\n              DAT_00248840 = iVar7;\n              *(long *)((long)DAT_00248848 + lVar6 * 8) = lVar3;\n              *(undefined8 *)((long)pvVar10 + (long)iVar7 * 8) = 0;\n            }\n          }\n          plVar9 = plVar9 + -1;\n          sh_xfree(plVar2,\"bashline.c\",0xe31);\n        } while (plVar1 + (long)(int)lVar8 + (-1 - lVar8) != plVar9);\n      }\n      if (DAT_00248870 == 0) {\n        qsort(DAT_00248848,(long)DAT_00248840,8,strvec_strcmp);\n      }\n    }\n    pvVar10 = DAT_00248848;\n    DAT_002487d8 = param_1;\n    sVar4 = strlen(param_1);\n    DAT_002487d4 = (int)sVar4;\n    sVar4 = (size_t)DAT_002487d4;\n  }\n  else {\n    sVar4 = (size_t)DAT_002487d4;\n    param_1 = DAT_002487d8;\n    pvVar10 = DAT_00248848;\n  }\n  while ((pvVar10 != (void *)0x0 &&\n         (pcVar5 = *(char **)((long)pvVar10 + (long)DAT_002487e0 * 8), pcVar5 != (char *)0x0))) {\n    DAT_002487e0 = DAT_002487e0 + 1;\n    iVar7 = strncmp(param_1,pcVar5,sVar4);\n    if (iVar7 == 0) {\n      sVar4 = strlen(pcVar5);\n      __dest = (char *)sh_xmalloc(sVar4 + 1,\"bashline.c\",0xe52);\n      pcVar5 = strcpy(__dest,pcVar5);\n      return pcVar5;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
  "rl_copy_text": "\nvoid rl_copy_text(int param_1,int param_2)\n\n{\n  char *pcVar1;\n  int iVar2;\n  \n  iVar2 = param_1;\n  if (param_2 < param_1) {\n    iVar2 = param_2;\n    param_2 = param_1;\n  }\n  param_2 = param_2 - iVar2;\n  pcVar1 = (char *)xmalloc((long)(param_2 + 1));\n  pcVar1 = strncpy(pcVar1,(char *)(iVar2 + rl_line_buffer),(long)param_2);\n  pcVar1[param_2] = '\\0';\n  return;\n}\n\n",
  "array_remove_quoted_nulls": "\nlong array_remove_quoted_nulls(long param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long lVar4;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  lVar1 = *(long *)(param_1 + 0x10);\n  lVar3 = lVar1;\n  if (lVar1 != 0) {\n    if (*(long *)(param_1 + 8) == 0) {\n      return 0;\n    }\n    lVar4 = *(long *)(lVar1 + 0x10);\n    lVar3 = param_1;\n    if (lVar1 != lVar4) {\n      do {\n        uVar2 = remove_quoted_nulls(*(undefined8 *)(lVar4 + 8));\n        *(undefined8 *)(lVar4 + 8) = uVar2;\n        lVar4 = *(long *)(lVar4 + 0x10);\n      } while (*(long *)(param_1 + 0x10) != lVar4);\n    }\n  }\n  return lVar3;\n}\n\n",
  "_rl_control_keypad": "\nvoid _rl_control_keypad(int param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 == 0) {\n    lVar1 = DAT_0024b608;\n    if (DAT_0024b608 == 0) {\n      return;\n    }\n  }\n  else {\n    lVar1 = DAT_0024b610;\n    if (DAT_0024b610 == 0) {\n      return;\n    }\n  }\n  tputs(lVar1,1,_rl_output_character_function);\n  return;\n}\n\n",
  "pcomp_set_readline_variables": "\nvoid pcomp_set_readline_variables(ulong param_1,int param_2)\n\n{\n  if ((param_1 & 4) != 0) {\n    rl_filename_completion_desired = param_2;\n  }\n  if ((param_1 & 0x20) != 0) {\n    rl_completion_suppress_append = param_2;\n  }\n  if ((param_1 & 0x10) != 0) {\n    rl_filename_quoting_desired = 1 - param_2;\n  }\n  if ((param_1 & 0x100) != 0) {\n    rl_sort_completion_matches = 1 - param_2;\n  }\n  return;\n}\n\n",
  "FUN_001b8480": "\nulong FUN_001b8480(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  int iVar3;\n  size_t __n;\n  ulong uVar4;\n  long in_FS_OFFSET;\n  wchar_t local_24;\n  long local_20;\n  \n  puVar2 = DAT_00248db8;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar1 = *(long *)DAT_00248db8[1];\n  __n = strlen((char *)(lVar1 + 1));\n  local_24 = L'\\0';\n  iVar3 = mbtowc(&local_24,(char *)(lVar1 + 1),__n);\n  if (iVar3 < 1) {\n    uVar4 = (ulong)*(byte *)(*(long *)puVar2[1] + 1);\n  }\n  else {\n    uVar4 = (ulong)local_24;\n  }\n  DAT_00248db8 = (undefined8 *)*puVar2;\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_free": "\nvoid rl_free(void *param_1)\n\n{\n  if (param_1 != (void *)0x0) {\n    free(param_1);\n    return;\n  }\n  return;\n}\n\n",
  "redirection_expand": "\nundefined8 redirection_expand(void)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long *plVar4;\n  \n  lVar2 = copy_word();\n  if (posixly_correct != 0) {\n    *(uint *)(lVar2 + 8) = *(uint *)(lVar2 + 8) | 0x10;\n  }\n  uVar3 = make_word_list(lVar2,0);\n  expanding_redir = 1;\n  sv_ifs(&DAT_001fce6e);\n  plVar4 = (long *)expand_words_no_vars(uVar3);\n  uVar1 = executing_builtin;\n  expanding_redir = 0;\n  executing_builtin = 1;\n  sv_ifs(&DAT_001fce6e);\n  executing_builtin = uVar1;\n  dispose_words(uVar3);\n  if (plVar4 == (long *)0x0) {\n    uVar3 = 0;\n  }\n  else {\n    if (*plVar4 != 0) {\n      dispose_words(plVar4);\n      return 0;\n    }\n    uVar3 = string_list();\n    dispose_words(plVar4);\n  }\n  return uVar3;\n}\n\n",
  "sys_error": "\nvoid sys_error(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n              undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n              undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n              undefined8 param_13,undefined8 param_14)\n\n{\n  int __errnum;\n  char in_AL;\n  int *piVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  undefined4 local_e8;\n  undefined4 local_e4;\n  undefined *local_e0;\n  undefined *local_d8;\n  long local_d0;\n  undefined local_c8 [8];\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  \n  if (in_AL != '\\0') {\n    local_98 = param_1;\n    local_88 = param_2;\n    local_78 = param_3;\n    local_68 = param_4;\n    local_58 = param_5;\n    local_48 = param_6;\n    local_38 = param_7;\n    local_28 = param_8;\n  }\n  local_d0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_c0 = param_10;\n  local_b8 = param_11;\n  local_b0 = param_12;\n  local_a8 = param_13;\n  local_a0 = param_14;\n  piVar1 = __errno_location();\n  __errnum = *piVar1;\n  uVar2 = get_name_for_error();\n  __fprintf_chk(stderr,1,&DAT_001fd57b,uVar2);\n  local_e0 = &stack0x00000008;\n  local_e8 = 8;\n  local_d8 = local_c8;\n  local_e4 = 0x30;\n  __vfprintf_chk(stderr,1,param_9,&local_e8);\n  pcVar3 = strerror(__errnum);\n  __fprintf_chk(stderr,1,\": %s\\n\",pcVar3);\n  if (local_d0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "completions_to_stringlist": "\nlong * completions_to_stringlist(char **param_1)\n\n{\n  long lVar1;\n  char **ppcVar2;\n  int iVar3;\n  long *plVar4;\n  size_t sVar5;\n  char *pcVar6;\n  char *pcVar7;\n  undefined8 *puVar8;\n  long lVar9;\n  uint uVar10;\n  \n  if (param_1 != (char **)0x0) {\n    iVar3 = strvec_len();\n    plVar4 = (long *)strlist_create(iVar3 + 1);\n    pcVar7 = *param_1;\n    if (pcVar7 != (char *)0x0) {\n      if (param_1[1] == (char *)0x0) {\n        sVar5 = strlen(pcVar7);\n        pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"pcomplete.c\",0x15d);\n        pcVar7 = strcpy(pcVar6,pcVar7);\n        ppcVar2 = (char **)*plVar4;\n        *ppcVar2 = pcVar7;\n        *(undefined4 *)((long)plVar4 + 0xc) = 1;\n        ppcVar2[1] = (char *)0x0;\n      }\n      else {\n        if (iVar3 < 2) {\n          puVar8 = (undefined8 *)*plVar4;\n          uVar10 = 0;\n        }\n        else {\n          uVar10 = iVar3 - 1;\n          lVar9 = 0;\n          do {\n            pcVar7 = *(char **)((long)param_1 + lVar9 + 8);\n            if (pcVar7 != (char *)0x0) {\n              sVar5 = strlen(pcVar7);\n              pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"pcomplete.c\",0x163);\n              pcVar7 = strcpy(pcVar6,pcVar7);\n            }\n            lVar1 = *plVar4;\n            *(char **)(lVar1 + lVar9) = pcVar7;\n            lVar9 = lVar9 + 8;\n          } while ((ulong)uVar10 << 3 != lVar9);\n          puVar8 = (undefined8 *)(lVar1 + (ulong)uVar10 * 8);\n        }\n        *(uint *)((long)plVar4 + 0xc) = uVar10;\n        *puVar8 = 0;\n      }\n    }\n    return plVar4;\n  }\n  plVar4 = (long *)strlist_create(1);\n  return plVar4;\n}\n\n",
  "no_options": "\nundefined8 no_options(undefined8 param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  reset_internal_getopt();\n  iVar1 = internal_getopt(param_1,&DAT_00213d70);\n  uVar2 = 0;\n  if (iVar1 != -1) {\n    if (iVar1 == -99) {\n      builtin_help();\n      return 2;\n    }\n    builtin_usage();\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n",
  "FUN_00181650": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00181650(code *param_1)\n\n{\n  ulong uVar1;\n  \n  if (((DAT_00247e40 & 1) != 0) &&\n     (DAT_00247e40 = DAT_00247e40 & 0xfffffffe, param_1 != FUN_00180f90)) {\n    trap_list = 0;\n  }\n  uVar1 = 1;\n  do {\n    if (((&DAT_00247e40)[uVar1] & 1) == 0) {\n      if (((&DAT_00247e40)[uVar1] & 4) != 0) {\nLAB_001816af:\n        (*param_1)();\n      }\n    }\n    else {\n      if ((&trap_list)[uVar1] != 1) goto LAB_001816af;\n      set_signal_handler(uVar1 & 0xffffffff,1);\n    }\n    *(undefined4 *)(pending_traps + uVar1 * 4) = 0;\n    uVar1 = uVar1 + 1;\n    if (uVar1 == 0x41) {\n      if (function_trace_mode == 0) {\n        DAT_00247f44 = DAT_00247f44 & 0xfffffffe;\n        DAT_00247f4c = DAT_00247f4c & 0xfffffffe;\n      }\n      if (error_trace_mode == 0) {\n        _DAT_00247f48 = _DAT_00247f48 & 0xfffffffe;\n      }\n      return;\n    }\n  } while( true );\n}\n\n",
  "FUN_001ab000": "\nint FUN_001ab000(long param_1,int param_2)\n\n{\n  long lVar1;\n  undefined4 uVar2;\n  int iVar3;\n  char *pcVar4;\n  long in_FS_OFFSET;\n  sigset_t sStack_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_138);\n  sigaddset(&sStack_138,0x11);\n  sigemptyset(&local_b8);\n  sigprocmask(0,&sStack_138,&local_b8);\n  iVar3 = get_job_spec(param_1);\n  uVar2 = last_asynchronous_pid;\n  if (iVar3 < 0) {\n    if (iVar3 != -2) goto LAB_001ab138;\n  }\n  else if ((iVar3 < DAT_0023877c) && (lVar1 = *(long *)(jobs + (long)iVar3 * 8), lVar1 != 0)) {\n    if ((*(byte *)(lVar1 + 0x18) & 4) == 0) {\n      builtin_error(\"job %d started without job control\",iVar3 + 1);\n      uVar2 = last_asynchronous_pid;\n    }\n    else if (param_2 == 0) {\n      last_asynchronous_pid = *(undefined4 *)(lVar1 + 0x10);\n      iVar3 = start_job(iVar3,0);\n      if (-1 < iVar3) {\n        iVar3 = 0;\n        sigprocmask(2,&local_b8,(sigset_t *)0x0);\n        goto LAB_001ab0dd;\n      }\n    }\n    else {\n      iVar3 = start_job(iVar3,1);\n      uVar2 = last_asynchronous_pid;\n      if (-1 < iVar3) {\n        sigprocmask(2,&local_b8,(sigset_t *)0x0);\n        goto LAB_001ab0dd;\n      }\n    }\n  }\n  else {\nLAB_001ab138:\n    pcVar4 = \"current\";\n    if (param_1 != 0) {\n      pcVar4 = **(char ***)(param_1 + 8);\n    }\n    sh_badjob(pcVar4);\n    uVar2 = last_asynchronous_pid;\n  }\n  last_asynchronous_pid = uVar2;\n  iVar3 = 1;\n  sigprocmask(2,&local_b8,(sigset_t *)0x0);\nLAB_001ab0dd:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar3;\n}\n\n",
  "_rl_internal_char_cleanup": "\nvoid _rl_internal_char_cleanup(void)\n\n{\n  int iVar1;\n  \n  if (_rl_keep_mark_active == 0) {\n    iVar1 = rl_mark_active_p();\n    if (iVar1 != 0) {\n      rl_deactivate_mark();\n    }\n  }\n  else {\n    _rl_keep_mark_active = 0;\n  }\n  if ((rl_editing_mode == 0) && (_rl_keymap == vi_movement_keymap)) {\n    rl_vi_check();\n  }\n  if ((rl_num_chars_to_read != 0) && (rl_num_chars_to_read <= (int)rl_end)) {\n    (*(code *)rl_redisplay_function)();\n    _rl_want_redisplay = 0;\n    rl_newline(1,10);\n  }\n  iVar1 = rl_erase_empty_line;\n  if (rl_done == 0) {\n    (*(code *)rl_redisplay_function)();\n    _rl_want_redisplay = 0;\n    iVar1 = rl_done;\n    if (rl_erase_empty_line == 0) {\n      _rl_want_redisplay = 0;\n      return;\n    }\n  }\n  if (((iVar1 != 0) && (rl_last_func == rl_newline)) && ((rl_point | rl_end) == 0)) {\n    _rl_erase_entire_line();\n    return;\n  }\n  return;\n}\n\n",
  "terminate_current_pipeline": "\nvoid terminate_current_pipeline(void)\n\n{\n  if ((pipeline_pgrp != 0) && (pipeline_pgrp != shell_pgrp)) {\n    killpg(pipeline_pgrp,0xf);\n    killpg(pipeline_pgrp,0x12);\n    return;\n  }\n  return;\n}\n\n",
  "execute_array_command": "\nundefined8 execute_array_command(undefined8 param_1,undefined8 param_2)\n\n{\n  char *pcVar1;\n  long lVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  int local_24;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_24 = 0;\n  lVar2 = array_to_argv(param_1,&local_24);\n  if (0 < local_24) {\n    lVar3 = 0;\n    do {\n      while ((pcVar1 = *(char **)(lVar2 + lVar3 * 8), pcVar1 != (char *)0x0 && (*pcVar1 != '\\0'))) {\n        lVar3 = lVar3 + 1;\n        execute_variable_command(pcVar1,param_2);\n        if (local_24 <= (int)lVar3) goto LAB_001343bb;\n      }\n      lVar3 = lVar3 + 1;\n    } while ((int)lVar3 < local_24);\n  }\nLAB_001343bb:\n  strvec_dispose(lVar2);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "fputs": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fputs_00237a50)();\n  return iVar1;\n}\n\n",
  "FUN_001d52f0": "\nvoid FUN_001d52f0(long param_1,byte param_2,byte param_3,byte param_4,byte param_5)\n\n{\n  char *pcVar1;\n  \n  if ((param_2 != 0) && (pcVar1 = (char *)((ulong)param_2 * 0x10 + param_1), *pcVar1 == '\\0')) {\n    *(code **)(pcVar1 + 8) = rl_rubout;\n  }\n  if ((param_3 != 0) && (pcVar1 = (char *)((ulong)param_3 * 0x10 + param_1), *pcVar1 == '\\0')) {\n    *(code **)(pcVar1 + 8) = rl_unix_line_discard;\n  }\n  if ((param_5 != 0) && (pcVar1 = (char *)((ulong)param_5 * 0x10 + param_1), *pcVar1 == '\\0')) {\n    *(code **)(pcVar1 + 8) = rl_quoted_insert;\n  }\n  if (rl_editing_mode == 0) {\n    if ((param_4 != 0) && (pcVar1 = (char *)((ulong)param_4 * 0x10 + param_1), *pcVar1 == '\\0')) {\n      *(code **)(pcVar1 + 8) = rl_vi_unix_word_rubout;\n      return;\n    }\n  }\n  else if ((param_4 != 0) && (pcVar1 = (char *)(param_1 + (ulong)param_4 * 0x10), *pcVar1 == '\\0'))\n  {\n    *(code **)(pcVar1 + 8) = rl_unix_word_rubout;\n    return;\n  }\n  return;\n}\n\n",
  "save_proc_status": "\nvoid save_proc_status(undefined4 param_1,undefined4 param_2)\n\n{\n  long in_FS_OFFSET;\n  sigset_t sStack_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_138);\n  sigaddset(&sStack_138,0x11);\n  sigemptyset(&local_b8);\n  sigprocmask(0,&sStack_138,&local_b8);\n  FUN_0015ed20(param_1,param_2);\n  sigprocmask(2,&local_b8,(sigset_t *)0x0);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "history_truncate_file": "\nint history_truncate_file(undefined8 param_1,int param_2)\n\n{\n  bool bVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  char *__file;\n  char *__buf;\n  ssize_t sVar6;\n  ushort **ppuVar7;\n  char *pcVar8;\n  int *piVar9;\n  char *pcVar10;\n  char *pcVar11;\n  long in_FS_OFFSET;\n  stat local_168;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  history_lines_written_to_file = 0;\n  __file = (char *)FUN_001f5180();\n  if (__file == (char *)0x0) {\n    piVar9 = __errno_location();\n    history_lines_written_to_file = -param_2;\n    bVar1 = false;\n    if (*piVar9 == 0) {\n      xfree(0);\n      iVar3 = 0;\n      goto LAB_001f5dc0;\n    }\nLAB_001f5e3d:\n    history_lines_written_to_file = -param_2;\n    piVar9 = __errno_location();\n    iVar3 = *piVar9;\n    goto LAB_001f5e45;\n  }\n  iVar3 = open(__file,0,0x1b6);\n  if (iVar3 == -1) {\n    piVar9 = __errno_location();\n    if (*piVar9 != 0) {\n      iVar3 = *piVar9;\n      history_lines_written_to_file = 0;\n      xfree(__file);\n      goto LAB_001f5dc0;\n    }\n  }\n  else {\n    iVar4 = fstat(iVar3,&local_168);\n    if (iVar4 != -1) {\n      local_d8.st_gid = local_168.st_gid;\n      local_d8.st_uid = local_168.st_uid;\n      if ((local_168.st_mode & 0xf000) == 0x8000) {\n        if (local_168.st_size == 0xffffffffffffffff) {\n          bVar1 = true;\n          close(iVar3);\n          piVar9 = __errno_location();\n          *piVar9 = 0x1b;\n          iVar3 = *piVar9;\n          goto LAB_001f5e45;\n        }\n        __buf = (char *)malloc(local_168.st_size + 1);\n        if (__buf == (char *)0x0) {\n          piVar9 = __errno_location();\n          iVar4 = *piVar9;\n          close(iVar3);\n          history_lines_written_to_file = -param_2;\n          if (iVar4 != 0) {\n            bVar1 = true;\n            goto LAB_001f5e3d;\n          }\n        }\n        else {\n          sVar6 = read(iVar3,__buf,local_168.st_size);\n          close(iVar3);\n          cVar2 = history_comment_char;\n          iVar3 = (int)sVar6;\n          if (iVar3 < 1) {\n            param_2 = -param_2;\n            if (iVar3 != 0) {\n              piVar9 = __errno_location();\n              iVar3 = *piVar9;\n              free(__buf);\n              history_lines_written_to_file = param_2;\n              if (iVar3 != 0) {\n                piVar9 = __errno_location();\n                bVar1 = true;\n                iVar3 = *piVar9;\n                goto LAB_001f5e45;\n              }\n              goto LAB_001f5fdf;\n            }\n          }\n          else {\n            pcVar8 = __buf + (long)iVar3 + -1;\n            if ((param_2 == 0) || (pcVar11 = pcVar8, iVar4 = param_2, pcVar8 <= __buf)) {\n              param_2 = 0;\n              pcVar10 = pcVar8;\n            }\n            else {\n              do {\n                pcVar10 = pcVar8;\n                if ((*pcVar10 == '\\n') &&\n                   ((*pcVar11 != cVar2 ||\n                    (ppuVar7 = __ctype_b_loc(),\n                    (*(byte *)((long)*ppuVar7 + (ulong)(byte)pcVar11[1] * 2 + 1) & 8) == 0)))) {\n                  iVar4 = iVar4 + -1;\n                }\n                pcVar8 = pcVar10 + -1;\n              } while ((iVar4 != 0) && (pcVar11 = pcVar10, __buf < pcVar8));\n              param_2 = param_2 - iVar4;\n            }\n            cVar2 = history_comment_char;\n            if (__buf < pcVar8) {\n              do {\n                pcVar11 = pcVar8;\n                if ((*pcVar11 == '\\n') &&\n                   ((*pcVar10 != cVar2 ||\n                    (ppuVar7 = __ctype_b_loc(),\n                    (*(byte *)((long)*ppuVar7 + (ulong)(byte)pcVar10[1] * 2 + 1) & 8) == 0)))) {\n                  pcVar11 = pcVar11 + 1;\n                  if (__buf < pcVar11) {\n                    pcVar8 = (char *)FUN_001f4f60(__file);\n                    iVar4 = open(pcVar8,0x241,0x180);\n                    if (iVar4 == -1) {\n                      piVar9 = __errno_location();\n                      iVar3 = *piVar9;\nLAB_001f5f6f:\n                      free(__buf);\njoined_r0x001f60d8:\n                      history_lines_written_to_file = param_2;\n                      if (iVar3 == 0) {\nLAB_001f5f88:\n                        history_lines_written_to_file = param_2;\n                        iVar3 = FUN_001f50f0(pcVar8,__file);\n                        if (iVar3 == 0) goto LAB_001f5e63;\n                      }\n                    }\n                    else {\n                      sVar6 = write(iVar4,pcVar11,(long)iVar3 - ((long)pcVar11 - (long)__buf));\n                      if (-1 < sVar6) {\n                        iVar3 = fstat(iVar4,&local_d8);\n                        if (iVar3 < 0) {\n                          piVar9 = __errno_location();\nLAB_001f6188:\n                          iVar3 = *piVar9;\nLAB_001f6155:\n                          iVar4 = close(iVar4);\n                          if (-1 < iVar4) goto LAB_001f5f6f;\n                          if (iVar3 != 0) goto LAB_001f616c;\nLAB_001f60c0:\n                          piVar9 = __errno_location();\n                          iVar3 = *piVar9;\n                          free(__buf);\n                          goto joined_r0x001f60d8;\n                        }\n                        iVar3 = close(iVar4);\n                        if (iVar3 < 0) goto LAB_001f60c0;\n                        free(__buf);\n                        goto LAB_001f5f88;\n                      }\n                      piVar9 = __errno_location();\n                      iVar3 = *piVar9;\n                      iVar5 = fstat(iVar4,&local_d8);\n                      if (-1 < iVar5) goto LAB_001f6155;\n                      if (iVar3 == 0) goto LAB_001f6188;\n                      close(iVar4);\nLAB_001f616c:\n                      free(__buf);\n                      history_lines_written_to_file = param_2;\n                    }\n                    piVar9 = __errno_location();\n                    iVar3 = *piVar9;\n                    unlink(pcVar8);\n                    history_lines_written_to_file = 0;\n                    if (iVar3 == 0) goto LAB_001f5e63;\n                    xfree(__file);\n                    goto LAB_001f5e99;\n                  }\n                  break;\n                }\n                pcVar8 = pcVar11 + -1;\n                pcVar10 = pcVar11;\n              } while (__buf != pcVar11 + -1);\n            }\n          }\n          free(__buf);\n          history_lines_written_to_file = param_2;\n        }\nLAB_001f5fdf:\n        pcVar8 = (char *)0x0;\n      }\n      else {\n        bVar1 = true;\n        close(iVar3);\n        history_lines_written_to_file = -param_2;\n        piVar9 = __errno_location();\n        iVar3 = *piVar9;\nLAB_001f5e45:\n        history_lines_written_to_file = 0;\n        if ((iVar3 != 0) || (pcVar8 = (char *)0x0, !bVar1)) {\n          xfree(__file);\n          goto LAB_001f5dc0;\n        }\n      }\nLAB_001f5e63:\n      if ((local_168.st_uid != local_d8.st_uid) || (local_d8.st_gid != local_168.st_gid)) {\n        chown(__file,local_168.st_uid,local_168.st_gid);\n      }\n      iVar3 = 0;\n      xfree(__file);\n      if (pcVar8 != (char *)0x0) {\nLAB_001f5e99:\n        free(pcVar8);\n      }\n      goto LAB_001f5dc0;\n    }\n    piVar9 = __errno_location();\n    iVar4 = *piVar9;\n    close(iVar3);\n    if (iVar4 != 0) {\n      bVar1 = false;\n      goto LAB_001f5e3d;\n    }\n  }\n  history_lines_written_to_file = -param_2;\n  iVar3 = 0;\n  xfree(__file);\nLAB_001f5dc0:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0017ef50": "\nchar ** FUN_0017ef50(undefined8 param_1,int param_2,undefined4 param_3,undefined4 param_4,\n                    undefined8 param_5,undefined8 param_6)\n\n{\n  int iVar1;\n  long lVar2;\n  byte *pbVar3;\n  char **ppcVar4;\n  size_t sVar5;\n  char *__dest;\n  char *pcVar6;\n  uint uVar7;\n  undefined8 uVar8;\n  \n  if (param_2 == 0) {\n    lVar2 = find_variable_last_nameref(param_1,0);\n    if (lVar2 != 0) {\n      if ((((*(byte *)(lVar2 + 0x29) & 8) != 0) &&\n          (pcVar6 = *(char **)(lVar2 + 8), pcVar6 != (char *)0x0)) && (*pcVar6 != '\\0')) {\n        ppcVar4 = (char **)alloc_word_desc();\n        sVar5 = strlen(pcVar6);\n        __dest = (char *)sh_xmalloc(sVar5 + 1,\"subst.c\",0x1dcf);\n        pcVar6 = strcpy(__dest,pcVar6);\n        *(undefined4 *)(ppcVar4 + 1) = 0;\n        *ppcVar4 = pcVar6;\n        return ppcVar4;\n      }\n      goto LAB_0017ef8c;\n    }\n    iVar1 = legal_identifier(param_1);\n    if (iVar1 != 0) {\n      report_error(\"%s: invalid indirect expansion\",param_1);\n      goto LAB_0017f139;\n    }\n  }\n  else {\nLAB_0017ef8c:\n    legal_identifier(param_1);\n  }\n  pbVar3 = (byte *)FUN_0017c6a0(param_1,param_2,param_3,0);\n  FUN_00168d30(pbVar3,param_3,param_5,param_6);\n  if (pbVar3 == (byte *)0x0) {\n    iVar1 = valid_array_reference(param_1,0);\n    if ((iVar1 == 0) || (lVar2 = array_variable_part(param_1,0,0,0), lVar2 != 0)) {\n      return (char **)0x0;\n    }\n    report_error(\"%s: invalid indirect expansion\",param_1);\n    goto LAB_0017f139;\n  }\n  if (*pbVar3 == 0) {\nLAB_0017efc8:\n    uVar8 = 0;\nLAB_0017efca:\n    iVar1 = FUN_001683d0(pbVar3,uVar8);\n  }\n  else {\n    if ((byte)(*pbVar3 - 0x30) < 10) {\n      iVar1 = all_digits(pbVar3);\n      uVar8 = 1;\n      if (iVar1 == 0) goto LAB_0017f02b;\n      goto LAB_0017efca;\n    }\nLAB_0017f02b:\n    if (pbVar3[1] != 0) goto LAB_0017efc8;\n    iVar1 = FUN_001683d0(pbVar3,(uint)(&sh_syntaxtab)[*pbVar3] >> 0xb & 1);\n  }\n  if (iVar1 == 0) {\n    report_error(\"%s: invalid variable name\",pbVar3);\n    sh_xfree(pbVar3,\"subst.c\",0x1dfe);\nLAB_0017f139:\n    ppcVar4 = (char **)alloc_word_desc();\n    *ppcVar4 = &DAT_0024784f;\n    *(undefined4 *)(ppcVar4 + 1) = 0;\n    return ppcVar4;\n  }\n  if (*pbVar3 != 0) {\n    if ((byte)(*pbVar3 - 0x30) < 10) {\n      iVar1 = all_digits(pbVar3);\n      uVar7 = 1;\n      if (iVar1 != 0) goto LAB_0017efe4;\n    }\n    if (pbVar3[1] == 0) {\n      uVar7 = (uint)(&sh_syntaxtab)[*pbVar3] >> 0xb & 1;\n      goto LAB_0017efe4;\n    }\n  }\n  uVar7 = 0;\nLAB_0017efe4:\n  ppcVar4 = (char **)FUN_0017bfe0(pbVar3,uVar7,param_3,param_4,0);\n  sh_xfree(pbVar3,\"subst.c\",0x1e06);\n  return ppcVar4;\n}\n\n",
  "_rl_fix_point": "\nvoid _rl_fix_point(int param_1)\n\n{\n  if (rl_end < rl_point) {\n    rl_point = rl_end;\n  }\n  else if (rl_point < 0) {\n    rl_point = 0;\n  }\n  if (param_1 != 0) {\n    if (rl_end < rl_mark) {\n      rl_mark = rl_end;\n      return;\n    }\n    if (rl_mark < 0) {\n      rl_mark = 0;\n      return;\n    }\n  }\n  return;\n}\n\n",
  "FUN_001d61a0": "\nint FUN_001d61a0(byte *param_1,int param_2,undefined8 param_3)\n\n{\n  bool bVar1;\n  FILE *__stream;\n  byte bVar2;\n  int iVar3;\n  size_t sVar4;\n  size_t __n;\n  ushort **ppuVar5;\n  __int32_t **pp_Var6;\n  int iVar7;\n  __int32_t __c;\n  int iVar8;\n  byte *pbVar9;\n  byte *pbVar10;\n  long in_FS_OFFSET;\n  wchar_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar4 = strlen((char *)param_1);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  bVar1 = 0 < _rl_completion_prefix_display_length;\n  pbVar10 = param_1;\n  if ((param_2 < (int)sVar4) || (!bVar1)) {\n    if (_rl_colored_stats == 0) {\n      if (param_2 == 0) goto LAB_001d62b8;\nLAB_001d624c:\n      if ((_rl_completion_prefix_display_length < param_2) && (bVar1)) {\nLAB_001d625d:\n        iVar8 = 3;\n        iVar3 = 0x5f;\n        if (param_1[param_2] != 0x2e) {\n          iVar3 = 0x2e;\n        }\n        iVar7 = 0;\n        putc(iVar3,rl_outstream);\n        putc(iVar3,rl_outstream);\n        putc(iVar3,rl_outstream);\n        pbVar10 = param_1 + param_2;\n      }\n      else {\n        if (0 < _rl_colored_completion_prefix) goto LAB_001d622a;\n        iVar7 = 0;\n        iVar8 = 0;\n        pbVar10 = param_1 + param_2;\n      }\n    }\n    else {\n      if (param_2 == 0) goto LAB_001d6548;\n      if (_rl_colored_completion_prefix < 1) {\n        _rl_set_normal_color();\n        _rl_print_color_indicator(param_3);\n        bVar1 = 0 < _rl_completion_prefix_display_length;\n        goto LAB_001d624c;\n      }\n      if ((_rl_completion_prefix_display_length < param_2) && (bVar1)) goto LAB_001d625d;\nLAB_001d622a:\n      _rl_set_normal_color();\n      iVar8 = 0;\n      _rl_print_prefix_color();\n      iVar7 = param_2;\n    }\nLAB_001d6424:\n    bVar2 = *pbVar10;\n    if (bVar2 != 0) goto LAB_001d62cc;\n  }\n  else {\n    if (_rl_colored_stats != 0) {\nLAB_001d6548:\n      _rl_set_normal_color();\n      iVar7 = 0;\n      iVar8 = 0;\n      _rl_print_color_indicator(param_3);\n      goto LAB_001d6424;\n    }\nLAB_001d62b8:\n    iVar8 = 0;\n    bVar2 = *param_1;\n    iVar7 = _rl_colored_stats;\n    if (bVar2 == 0) goto LAB_001d644b;\nLAB_001d62cc:\n    do {\n      if (bVar2 < 0x20) {\n        putc(0x5e,rl_outstream);\n        __stream = rl_outstream;\n        ppuVar5 = __ctype_b_loc();\n        bVar2 = *pbVar10 | 0x40;\n        __c = (__int32_t)(char)bVar2;\n        if ((*(byte *)((long)*ppuVar5 + (ulong)bVar2 * 2 + 1) & 2) != 0) {\n          pp_Var6 = __ctype_toupper_loc();\n          __c = (*pp_Var6)[bVar2];\n        }\n        iVar8 = iVar8 + 2;\n        pbVar9 = pbVar10 + 1;\n        putc(__c,__stream);\n        local_48.__count = 0;\n        local_48.__value = (_union_27)0x0;\n      }\n      else if (bVar2 == 0x7f) {\n        iVar8 = iVar8 + 2;\n        pbVar9 = pbVar10 + 1;\n        putc(0x5e,rl_outstream);\n        putc(0x3f,rl_outstream);\n        local_48.__count = 0;\n        local_48.__value = (_union_27)0x0;\n      }\n      else {\n        __n = mbrtowc(&local_4c,(char *)pbVar10,\n                      (size_t)(param_1 + (((long)(int)sVar4 + 1) - (long)pbVar10)),&local_48);\n        if (__n < 0xfffffffffffffffe) {\n          if (__n == 0) break;\n          if (local_4c < L'`') {\n            if (local_4c < L'A') {\n              if (local_4c < L'$') {\n                iVar3 = 1;\n                if (L'\\x1f' < local_4c) goto LAB_001d6358;\n              }\n              else if ((uint)(local_4c + L'\\xffffffdb') < 0x1b) goto LAB_001d6484;\nLAB_001d6340:\n              iVar3 = wcwidth(local_4c);\n              if (iVar3 < 0) {\n                iVar3 = 1;\n              }\n            }\n            else {\nLAB_001d6484:\n              iVar3 = 1;\n            }\n          }\n          else {\n            iVar3 = 1;\n            if (0x1d < (uint)(local_4c + L'\\xffffff9f')) goto LAB_001d6340;\n          }\n        }\n        else {\n          local_48.__count = 0;\n          local_48.__value = (_union_27)0x0;\n          iVar3 = 1;\n          __n = 1;\n        }\nLAB_001d6358:\n        pbVar9 = pbVar10 + __n;\n        iVar8 = iVar8 + iVar3;\n        fwrite(pbVar10,1,__n,rl_outstream);\n      }\n      if ((0 < iVar7) && ((long)iVar7 <= (long)pbVar9 - (long)param_1)) {\n        _rl_prep_non_filename_text();\n        _rl_put_indicator(&DAT_00240750);\n        iVar7 = _rl_colored_stats;\n        if (_rl_colored_stats != 0) {\n          _rl_set_normal_color();\n          iVar7 = 0;\n          _rl_print_color_indicator(param_3);\n        }\n      }\n      bVar2 = *pbVar9;\n      pbVar10 = pbVar9;\n    } while (bVar2 != 0);\n  }\n  if (_rl_colored_stats != 0) {\n    _rl_prep_non_filename_text();\n    _rl_put_indicator(&DAT_00240750);\n  }\nLAB_001d644b:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar8;\n}\n\n",
  "fflush": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fflush_00237be8)();\n  return iVar1;\n}\n\n",
  "invalidate_cached_quoted_dollar_at": "\nvoid invalidate_cached_quoted_dollar_at(void)\n\n{\n  dispose_words(DAT_00247890);\n  DAT_00247890 = 0;\n  return;\n}\n\n",
  "FUN_00192780": "\nundefined8 * FUN_00192780(char *param_1,int param_2)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  char *__s;\n  size_t sVar3;\n  char *pcVar4;\n  long lVar5;\n  \n  lVar5 = (long)param_2;\n  if (param_2 == 0) {\n    rl_filename_completion_desired = 1;\n    if (DAT_00248828 != (undefined8 *)0x0) {\n      sh_xfree(DAT_00248828,\"bashline.c\",0xf39);\n    }\n    if ((DAT_00248830 != DAT_00248838) && (DAT_00248830 != (char *)0x0)) {\n      sh_xfree(DAT_00248830,\"bashline.c\",0xf3b);\n    }\n    if (DAT_00248838 != (char *)0x0) {\n      sh_xfree(DAT_00248838,\"bashline.c\",0xf3c);\n    }\n    __s = (char *)bash_tilde_expand(param_1,0);\n    if (rl_explicit_arg == 0) {\n      sVar3 = strlen(__s);\n      pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"bashline.c\",0xf4a);\n      DAT_00248830 = strcpy(pcVar4,__s);\n      DAT_00248838 = DAT_00248830;\n    }\n    else {\n      sVar3 = strlen(__s);\n      pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"bashline.c\",0xf42);\n      DAT_00248830 = strcpy(pcVar4,__s);\n      sVar3 = strlen(__s);\n      iVar1 = (int)sVar3;\n      DAT_00248838 = (char *)sh_xmalloc((long)(iVar1 + 2),\"bashline.c\",0xf44);\n      pcVar4 = strcpy(DAT_00248838,__s);\n      pcVar4[iVar1] = '*';\n      pcVar4[(long)iVar1 + 1] = '\\0';\n    }\n    if (param_1 != __s) {\n      sh_xfree(__s,\"bashline.c\",0xf4d);\n    }\n    DAT_00248828 = (undefined8 *)shell_glob_filename(DAT_00248838,0);\n    if (DAT_00248828 == &glob_error_return) {\n      DAT_00248828 = (undefined8 *)0x0;\n      DAT_002487d0 = 1;\n      return (undefined8 *)0x0;\n    }\n    DAT_002487d0 = 1;\n  }\n  else {\n    lVar5 = (long)DAT_002487d0;\n    DAT_002487d0 = DAT_002487d0 + 1;\n  }\n  puVar2 = DAT_00248828;\n  if (DAT_00248828 != (undefined8 *)0x0) {\n    puVar2 = (undefined8 *)DAT_00248828[lVar5];\n  }\n  return puVar2;\n}\n\n",
  "FUN_001bd430": "\nbool FUN_001bd430(int *param_1,int *param_2)\n\n{\n  bool bVar1;\n  \n  if (glob_always_skip_dot_and_dotdot == 0) {\n    if (noglob_dot_filenames != 0) {\n      if (*param_2 != 0x2e) {\n        return false;\n      }\nLAB_001bd479:\n      if (*param_1 == 0x2e) {\n        return false;\n      }\n      if (*param_1 != 0x5c) {\n        return true;\n      }\n      return param_1[1] != 0x2e;\n    }\n  }\n  else if (*param_2 == 0x2e) {\n    if (param_2[1] == 0) {\n      return true;\n    }\n    if ((param_2[1] == 0x2e) && (param_2[2] == 0)) {\n      return true;\n    }\n    if (noglob_dot_filenames != 0) goto LAB_001bd479;\n  }\n  else if (noglob_dot_filenames != 0) {\n    return false;\n  }\n  bVar1 = false;\n  if (*param_1 != 0x2e) {\n    if ((*param_1 == 0x5c) && (param_1[1] == 0x2e)) {\n      return false;\n    }\n    bVar1 = false;\n    if (*param_2 == 0x2e) {\n      bVar1 = true;\n      if ((param_2[1] != 0) && (bVar1 = false, param_2[1] == 0x2e)) {\n        return param_2[2] == 0;\n      }\n    }\n  }\n  return bVar1;\n}\n\n",
  "_rl_insert_char": "\nundefined8 _rl_insert_char(int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (0 < param_1) {\n    uVar1 = FUN_001ee210();\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "set_procsub_status": "\nvoid set_procsub_status(int param_1)\n\n{\n  if ((-1 < param_1) && (param_1 < DAT_00247830)) {\n    *(undefined4 *)(DAT_00247838 + (long)param_1 * 4) = 0xffffffff;\n  }\n  return;\n}\n\n",
  "parse_string_to_command": "\nundefined8 parse_string_to_command(char *param_1,uint param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  char *local_188;\n  undefined8 local_180;\n  undefined local_178 [48];\n  undefined local_148 [264];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*param_1 == '\\0') {\n    uVar2 = 0;\n  }\n  else {\n    sVar3 = 1;\n    local_188 = param_1;\n    if ((param_1[1] != '\\0') && (sVar3 = 2, param_1[2] != '\\0')) {\n      sVar3 = strlen(param_1);\n    }\n    save_parser_state(local_148);\n    save_input_line_state(local_178);\n    pushed_string_list = 0;\n    if ((param_2 & 0x400) != 0) {\n      parser_state = parser_state | 0x800000;\n    }\n    local_180 = 0;\n    expand_aliases = 0;\n    iVar1 = parse_string(param_1,\"command substitution\",\n                         (-(uint)((param_2 & 0x40) == 0) & 0xffffffc0) + 0x4d,&local_180,&local_188)\n    ;\n    reset_parser();\n    restore_input_line_state(local_178);\n    restore_parser_state(local_148);\n    uVar2 = local_180;\n    if (iVar1 < 0) {\n      if (DAT_00240da8 != (undefined *)0x0) {\n        DAT_00240da0 = 0;\n        *DAT_00240da8 = 0;\n      }\n      if ((param_2 & 0x40) == 0) {\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level(-iVar1);\n      }\n    }\n    else if ((ulong)(long)iVar1 < sVar3) {\n      dispose_command(local_180);\n      uVar2 = 0;\n    }\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
  "strvec_dispose": "\nvoid strvec_dispose(long *param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  \n  if (param_1 != (long *)0x0) {\n    lVar2 = *param_1;\n    if (lVar2 != 0) {\n      plVar1 = param_1 + 1;\n      do {\n        sh_xfree(lVar2,\"stringvec.c\",0x59);\n        lVar2 = *plVar1;\n        plVar1 = plVar1 + 1;\n      } while (lVar2 != 0);\n    }\n    sh_xfree(param_1,\"stringvec.c\",100);\n    return;\n  }\n  return;\n}\n\n",
  "current_history": "\nlong current_history(void)\n\n{\n  long lVar1;\n  \n  if (history_offset == history_length) {\n    lVar1 = 0;\n  }\n  else {\n    lVar1 = DAT_0024b6e8;\n    if (DAT_0024b6e8 != 0) {\n      return *(long *)(DAT_0024b6e8 + (long)history_offset * 8);\n    }\n  }\n  return lVar1;\n}\n\n",
  "extract_process_subst": "\nvoid extract_process_subst(long param_1,undefined8 param_2,int *param_3,uint param_4)\n\n{\n  xparse_dolparen(param_1,*param_3 + param_1,param_3,\n                  (uint)(no_longjmp_on_fatal_error != 0) << 6 | param_4);\n  return;\n}\n\n",
  "FUN_00150980": "\nundefined4 FUN_00150980(int *param_1,undefined4 param_2,undefined4 param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  FILE *__stream;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined8 uVar7;\n  char cVar8;\n  int iVar9;\n  int iVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  undefined *puVar13;\n  size_t sVar14;\n  int iVar15;\n  long lVar16;\n  char *__s;\n  int iVar17;\n  long lVar18;\n  int iVar19;\n  uint uVar20;\n  ulong uVar21;\n  char *pcVar22;\n  undefined *puVar23;\n  long in_FS_OFFSET;\n  bool bVar24;\n  uint local_47c;\n  uint local_478;\n  undefined4 local_464;\n  undefined4 local_418;\n  undefined4 local_414;\n  undefined4 local_410;\n  int local_40c;\n  undefined8 local_408;\n  undefined8 local_400;\n  undefined8 local_3f8;\n  timezone local_3f0;\n  undefined local_3e8 [16];\n  undefined local_3d8 [16];\n  undefined local_3c8 [16];\n  undefined local_3b8 [8];\n  undefined4 uStack_3b0;\n  undefined4 uStack_3ac;\n  timeval local_3a8;\n  rusage local_398;\n  undefined local_308 [144];\n  rusage local_278;\n  undefined local_1e8 [144];\n  undefined local_158 [208];\n  byte local_88 [21];\n  undefined local_73;\n  char local_68 [40];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  gettimeofday((timeval *)local_3b8,&local_3f0);\n  getrusage(RUSAGE_SELF,&local_398);\n  getrusage(RUSAGE_CHILDREN,&local_278);\n  local_40c = subshell_environment;\n  if (param_1 == (int *)0x0) {\n    local_478 = uRam0000000000000004;\n    local_47c = posixly_correct;\n    if (posixly_correct != 0) {\n      local_47c = 0;\nLAB_00150f91:\n      local_278.ru_stime.tv_sec = 0;\n      local_398.ru_stime.tv_sec = 0;\n      local_278.ru_utime.tv_sec = 0;\n      local_398.ru_utime.tv_sec = 0;\n      local_278.ru_stime.tv_usec = 0;\n      local_398.ru_stime.tv_usec = 0;\n      local_278.ru_utime.tv_usec = 0;\n      local_398.ru_utime.tv_usec = 0;\n      local_3b8._0_4_ = (undefined4)shellstart;\n      local_3b8._4_4_ = shellstart._4_4_;\n      uStack_3b0 = uRam0000000000240938;\n      uStack_3ac = uRam000000000024093c;\n    }\n    bVar24 = true;\n  }\n  else {\n    local_478 = param_1[1];\n    local_47c = local_478 >> 8 & 1;\n    if (*param_1 == 4) {\n      bVar24 = false;\n      if (((*(long *)(*(long *)(param_1 + 6) + 8) == 0) &&\n          (*(long *)(*(long *)(param_1 + 6) + 0x10) == 0)) && (bVar24 = true, posixly_correct != 0))\n      goto LAB_00150f91;\n    }\n    else {\n      bVar24 = false;\n    }\n  }\n  xbcopy(top_level,local_158,200);\n  param_1[1] = param_1[1] & 0xfffffe7f;\n  iVar9 = __sigsetjmp(top_level,0);\n  if (iVar9 == 0) {\n    local_464 = execute_command_internal(param_1,0,param_2,param_3,param_4);\n  }\n  xbcopy(local_158,top_level,200);\n  param_1[1] = local_478;\n  if (((iVar9 != 0) && (subshell_environment != 0)) && (subshell_environment != local_40c)) {\n                    /* WARNING: Subroutine does not return */\n    __longjmp_chk(top_level,iVar9);\n  }\n  local_3f8 = 0;\n  local_400 = 0;\n  local_410 = 0;\n  local_408 = 0;\n  local_414 = 0;\n  local_418 = 0;\n  gettimeofday(&local_3a8,&local_3f0);\n  getrusage(RUSAGE_SELF,(rusage *)local_308);\n  getrusage(RUSAGE_CHILDREN,(rusage *)local_1e8);\n  difftimeval(local_3e8,local_3b8,&local_3a8);\n  timeval_to_secs(local_3e8,&local_408,&local_418);\n  uVar11 = difftimeval(local_3b8,&local_278,(rusage *)local_1e8);\n  uVar12 = difftimeval(&local_3a8,&local_398,(rusage *)local_308);\n  addtimeval(local_3d8,uVar12,uVar11);\n  timeval_to_secs(local_3d8,&local_400,&local_414);\n  uVar11 = difftimeval(local_3b8,&local_278.ru_stime,local_1e8 + 0x10);\n  __s = \"real %2R\\nuser %2U\\nsys %2S\";\n  uVar12 = difftimeval(&local_3a8,&local_398.ru_stime,local_308 + 0x10);\n  addtimeval(local_3c8,uVar12,uVar11);\n  timeval_to_secs(local_3c8,&local_3f8,&local_410);\n  iVar10 = timeval_to_cpu(local_3e8,local_3d8,local_3c8);\n  uVar21 = 0x40;\n  if (local_47c == 0) {\n    __s = (char *)get_string_value(\"TIMEFORMAT\");\n    if (__s == (char *)0x0) {\n      if ((posixly_correct == 0) || (__s = \"user\\t%2lU\\nsys\\t%2lS\", !bVar24)) {\n        uVar21 = 0x40;\n        __s = \"\\nreal\\t%3lR\\nuser\\t%3lU\\nsys\\t%3lS\";\n      }\n    }\n    else {\n      if (*__s == '\\0') goto LAB_00150f19;\n      sVar14 = strlen(__s);\n      uVar21 = (ulong)(((int)sVar14 + 0x40) -\n                      (int)((long)((ulong)(uint)((int)sVar14 >> 0x1f) << 0x20 | sVar14 & 0xffffffff)\n                           % 0x40));\n    }\n  }\n  uVar7 = local_3f8;\n  uVar12 = local_400;\n  uVar11 = local_408;\n  uVar6 = local_410;\n  uVar5 = local_414;\n  uVar4 = local_418;\n  __stream = stderr;\n  puVar13 = (undefined *)sh_xmalloc(uVar21,\"execute_cmd.c\",0x4ef);\n  cVar8 = *__s;\n  puVar23 = puVar13;\n  if (cVar8 != '\\0') {\n    uVar21 = uVar21 & 0xffffffff;\n    lVar16 = 0;\n    iVar2 = (iVar10 % 100) * 10;\n    do {\n      while( true ) {\n        iVar19 = (int)uVar21;\n        iVar15 = (int)lVar16;\n        if ((cVar8 == '%') && (cVar8 = __s[1], cVar8 != '\\0')) break;\n        if (iVar19 <= iVar15 + 1) {\n          uVar20 = ((iVar15 + 1) - iVar19 & 0xffffffc0U) + 0x40 + iVar19;\n          uVar21 = (ulong)uVar20;\n          puVar13 = (undefined *)sh_xrealloc(puVar13,(long)(int)uVar20,\"execute_cmd.c\",0x4f6);\n        }\n        puVar13[lVar16] = *__s;\nLAB_00150d3b:\n        lVar16 = (long)(iVar15 + 1);\n        cVar8 = __s[1];\n        __s = __s + 1;\n        puVar23 = puVar13;\n        if (cVar8 == '\\0') goto LAB_00150e08;\n      }\n      pcVar22 = __s + 1;\n      if (cVar8 == '%') {\n        cVar8 = '%';\n        if (iVar19 <= iVar15 + 1) {\n          uVar20 = iVar19 + 0x40 + ((iVar15 + 1) - iVar19 & 0xffffffc0U);\n          uVar21 = (ulong)uVar20;\n          puVar13 = (undefined *)sh_xrealloc(puVar13,(long)(int)uVar20,\"execute_cmd.c\",0x4fc);\n          cVar8 = __s[1];\n        }\n        puVar13[lVar16] = cVar8;\n        __s = pcVar22;\n        goto LAB_00150d3b;\n      }\n      if (cVar8 == 'P') {\n        local_73 = 0;\n        lVar18 = 0x14;\n        lVar16 = (long)(iVar10 / 100);\n        do {\n          iVar17 = (int)lVar18;\n          lVar1 = lVar16 / 10;\n          uVar20 = (int)lVar16 + (int)lVar1 * -10 + 0x30;\n          local_88[lVar18] = (byte)uVar20;\n          lVar18 = lVar18 + -1;\n          lVar16 = lVar1;\n        } while (lVar1 != 0);\n        lVar16 = 0;\n        do {\n          local_68[lVar16] = (char)uVar20;\n          iVar3 = (int)lVar16;\n          lVar16 = lVar16 + 1;\n          uVar20 = (uint)local_88[lVar16 + iVar17];\n        } while (local_88[lVar16 + iVar17] != 0);\n        cVar8 = locale_decpoint();\n        local_68[iVar3 + 1] = cVar8;\n        local_68[iVar3 + 2] = (char)(iVar2 / 100) + '0';\n        iVar17 = iVar3 + 4 + iVar15;\n        local_68[iVar3 + 3] = (char)((iVar2 % 100) / 10) + '0';\n        local_68[iVar3 + 4] = '\\0';\n        if (iVar19 <= iVar17) {\n          uVar20 = (iVar17 - iVar19 & 0xffffffc0U) + 0x40 + iVar19;\n          uVar21 = (ulong)uVar20;\n          puVar13 = (undefined *)sh_xrealloc(puVar13,(long)(int)uVar20,\"execute_cmd.c\",0x50a);\n        }\n      }\n      else {\n        iVar17 = 3;\n        if ((byte)(cVar8 - 0x30U) < 10) {\n          iVar17 = (int)(char)(cVar8 - 0x30U);\n          pcVar22 = __s + 2;\n          if (3 < iVar17) {\n            iVar17 = 3;\n          }\n          cVar8 = __s[2];\n        }\n        bVar24 = cVar8 == 'l';\n        if (bVar24) {\n          cVar8 = pcVar22[1];\n          pcVar22 = pcVar22 + 1;\n        }\n        if ((cVar8 == 'R') || (cVar8 == 'E')) {\n          iVar17 = FUN_00147cb0(local_68,iVar17,bVar24,uVar11,uVar4);\n        }\n        else if (cVar8 == 'U') {\n          iVar17 = FUN_00147cb0(local_68,iVar17,bVar24,uVar12,uVar5);\n        }\n        else {\n          if (cVar8 != 'S') {\n            internal_error(\"TIMEFORMAT: `%c\\': invalid format character\",(int)cVar8);\n            sh_xfree(puVar13,\"execute_cmd.c\",0x526);\n            goto LAB_00150f19;\n          }\n          iVar17 = FUN_00147cb0(local_68,iVar17,bVar24,uVar7,uVar6);\n        }\n        iVar17 = iVar17 + iVar15;\n        if (iVar19 <= iVar17) {\n          uVar20 = iVar19 + 0x40 + (iVar17 - iVar19 & 0xffffffc0U);\n          uVar21 = (ulong)uVar20;\n          puVar13 = (undefined *)sh_xrealloc(puVar13,(long)(int)uVar20,\"execute_cmd.c\",0x529);\n        }\n      }\n      lVar16 = (long)iVar17;\n      __s = pcVar22 + 1;\n      strcpy(puVar13 + iVar15,local_68);\n      cVar8 = pcVar22[1];\n      puVar23 = puVar13;\n    } while (cVar8 != '\\0');\nLAB_00150e08:\n    puVar13 = puVar23 + lVar16;\n  }\n  *puVar13 = 0;\n  __fprintf_chk(__stream,1,&DAT_0020fbe7,puVar23);\n  fflush(__stream);\n  sh_xfree(puVar23,\"execute_cmd.c\",0x533);\nLAB_00150f19:\n  if (iVar9 != 0) {\n                    /* WARNING: Subroutine does not return */\n    __longjmp_chk(top_level,iVar9);\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_464;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_find_prev_mbchar": "\nvoid _rl_find_prev_mbchar(void)\n\n{\n  _rl_find_prev_mbchar_internal();\n  return;\n}\n\n",
  "make_select_command": "\nvoid make_select_command(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4\n                        )\n\n{\n  undefined4 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x20,\"make_cmd.c\",0xd1);\n  *(undefined8 *)(puVar1 + 2) = param_1;\n  puVar1[1] = param_4;\n  *(undefined8 *)(puVar1 + 4) = param_2;\n  *(undefined8 *)(puVar1 + 6) = param_3;\n  *puVar1 = 0;\n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar2[3] = puVar1;\n  *puVar2 = 5;\n  *puVar1 = 0;\n  puVar2[2] = 0;\n  return;\n}\n\n",
  "clean_itemlist": "\nvoid clean_itemlist(uint *param_1)\n\n{\n  uint uVar1;\n  undefined8 *puVar2;\n  \n  puVar2 = *(undefined8 **)(param_1 + 4);\n  if (puVar2 != (undefined8 *)0x0) {\n    uVar1 = *param_1;\n    if ((uVar1 & 0x30) == 0) {\n      strvec_flush(*puVar2);\n      uVar1 = *param_1;\n    }\n    if ((uVar1 & 0x10) == 0) {\n      sh_xfree(*puVar2,\"pcomplete.c\",0xf9);\n    }\n    sh_xfree(puVar2,\"pcomplete.c\",0xfa);\n  }\n  *param_1 = *param_1 & 0xffffffc9;\n  *(undefined8 *)(param_1 + 4) = 0;\n  return;\n}\n\n",
  "FUN_001e9190": "\nundefined8 FUN_001e9190(undefined4 param_1,undefined4 param_2,int param_3)\n\n{\n  undefined4 uVar1;\n  undefined8 *puVar2;\n  char *__ptr;\n  int iVar3;\n  \n  uVar1 = where_history();\n  if (0 < param_3) {\n    iVar3 = 0;\n    do {\n      previous_history();\n      iVar3 = iVar3 + 1;\n    } while (param_3 != iVar3);\n  }\n  puVar2 = (undefined8 *)previous_history();\n  history_set_pos(uVar1);\n  if (puVar2 != (undefined8 *)0x0) {\n    __ptr = (char *)history_arg_extract(param_1,param_1,*puVar2);\n    if (__ptr != (char *)0x0) {\n      if (*__ptr == '\\0') {\n        rl_ding();\n        free(__ptr);\n        return 1;\n      }\n      rl_begin_undo_group();\n      _rl_set_mark_at_pos(rl_point);\n      if ((rl_editing_mode == 0) && (_rl_keymap == vi_movement_keymap)) {\n        rl_vi_append_mode(1,param_2);\n        rl_insert_text(&DAT_001fdb1c);\n      }\n      rl_insert_text(__ptr);\n      xfree(__ptr);\n      rl_end_undo_group();\n      return 0;\n    }\n  }\n  rl_ding();\n  return 1;\n}\n\n",
  "__longjmp_chk": "\nvoid __longjmp_chk_noreturn_(void)\n\n{\n  (*(code *)PTR___longjmp_chk_00237ce8)();\n  return;\n}\n\n",
  "strlist_walk": "\nvoid strlist_walk(long *param_1,code *param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  if (param_1 == (long *)0x0) {\n    return;\n  }\n  if (0 < *(int *)((long)param_1 + 0xc)) {\n    lVar2 = 0;\n    do {\n      iVar1 = (*param_2)(*(undefined8 *)(*param_1 + lVar2 * 8));\n      if (iVar1 < 0) {\n        return;\n      }\n      lVar2 = lVar2 + 1;\n    } while (*(int *)((long)param_1 + 0xc) != (int)lVar2 &&\n             (int)lVar2 <= *(int *)((long)param_1 + 0xc));\n  }\n  return;\n}\n\n",
  "set_debug_trap": "\nvoid set_debug_trap(undefined8 param_1)\n\n{\n  set_signal(0x41,param_1);\n  return;\n}\n\n",
  "FUN_001bbe90": "\nundefined8 FUN_001bbe90(undefined8 param_1,long param_2)\n\n{\n  ulong uVar1;\n  long lVar2;\n  int iVar3;\n  undefined *puVar4;\n  long lVar5;\n  char *pcVar6;\n  undefined **ppuVar7;\n  \n  __printf_chk(1,\"complete \");\n  uVar1 = *(ulong *)(param_2 + 0x10);\n  puVar4 = (undefined *)0x40;\n  pcVar6 = \"bashdefault\";\n  ppuVar7 = &PTR_s_bashdefault_00235400;\n  while( true ) {\n    if ((uVar1 & (ulong)puVar4) == 0) {\n      pcVar6 = ppuVar7[2];\n    }\n    else {\n      __printf_chk(1,\"-o %s \",pcVar6);\n      pcVar6 = ppuVar7[2];\n    }\n    if (pcVar6 == (char *)0x0) break;\n    puVar4 = ppuVar7[3];\n    ppuVar7 = ppuVar7 + 2;\n  }\n  uVar1 = *(ulong *)(param_2 + 8);\n  iVar3 = 0x61;\n  ppuVar7 = &PTR_s_alias_002354a0;\n  while( true ) {\n    if ((iVar3 == 0) || ((uVar1 & (ulong)ppuVar7[1]) == 0)) {\n      puVar4 = ppuVar7[3];\n    }\n    else {\n      __printf_chk(1,&DAT_002111c8);\n      puVar4 = ppuVar7[3];\n    }\n    if (puVar4 == (undefined *)0x0) break;\n    iVar3 = *(int *)(ppuVar7 + 5);\n    ppuVar7 = ppuVar7 + 3;\n  }\n  pcVar6 = \"arrayvar\";\n  ppuVar7 = &PTR_s_alias_002354a0;\n  while (pcVar6 != (char *)0x0) {\n    if ((*(int *)(ppuVar7 + 5) == 0) && ((uVar1 & (ulong)ppuVar7[4]) != 0)) {\n      __printf_chk(1,&DAT_002111cd);\n    }\n    pcVar6 = ppuVar7[6];\n    ppuVar7 = ppuVar7 + 3;\n  }\n  lVar2 = *(long *)(param_2 + 0x18);\n  if (lVar2 != 0) {\n    lVar5 = sh_single_quote(lVar2);\n    __printf_chk(1,\"%s %s \",&DAT_002111d4,lVar5);\n    if (lVar2 != lVar5) {\n      sh_xfree(lVar5,\"./complete.def\",0x218);\n    }\n  }\n  lVar2 = *(long *)(param_2 + 0x20);\n  if (lVar2 != 0) {\n    lVar5 = sh_single_quote(lVar2);\n    __printf_chk(1,\"%s %s \",&DAT_002111de,lVar5);\n    if (lVar2 != lVar5) {\n      sh_xfree(lVar5,\"./complete.def\",0x218);\n    }\n  }\n  lVar2 = *(long *)(param_2 + 0x28);\n  if (lVar2 != 0) {\n    lVar5 = sh_single_quote(lVar2);\n    __printf_chk(1,\"%s %s \",&DAT_002111e1,lVar5);\n    if (lVar2 != lVar5) {\n      sh_xfree(lVar5,\"./complete.def\",0x218);\n    }\n  }\n  lVar2 = *(long *)(param_2 + 0x30);\n  if (lVar2 != 0) {\n    lVar5 = sh_single_quote(lVar2);\n    __printf_chk(1,\"%s %s \",&DAT_002109ad,lVar5);\n    if (lVar2 != lVar5) {\n      sh_xfree(lVar5,\"./complete.def\",0x218);\n    }\n  }\n  lVar2 = *(long *)(param_2 + 0x50);\n  if (lVar2 != 0) {\n    lVar5 = sh_single_quote(lVar2);\n    __printf_chk(1,\"%s %s \",&DAT_002111e4,lVar5);\n    if (lVar2 != lVar5) {\n      sh_xfree(lVar5,\"./complete.def\",0x218);\n    }\n  }\n  lVar2 = *(long *)(param_2 + 0x40);\n  if (lVar2 != 0) {\n    lVar5 = sh_single_quote(lVar2);\n    __printf_chk(1,\"%s %s \",&DAT_002111e7,lVar5);\n    if (lVar2 != lVar5) {\n      sh_xfree(lVar5,\"./complete.def\",0x218);\n    }\n  }\n  iVar3 = sh_contains_shell_metas(*(undefined8 *)(param_2 + 0x38));\n  lVar2 = *(long *)(param_2 + 0x38);\n  if (lVar2 != 0) {\n    if (iVar3 == 0) {\n      __printf_chk(1,\"%s %s \",&DAT_002111ea,lVar2);\n    }\n    else {\n      lVar5 = sh_single_quote(lVar2);\n      __printf_chk(1,\"%s %s \",&DAT_002111ea,lVar5);\n      if (lVar2 != lVar5) {\n        sh_xfree(lVar5,\"./complete.def\",0x218);\n      }\n    }\n  }\n  FUN_001bb780(param_1);\n  putchar(10);\n  return 0;\n}\n\n",
  "sv_hostfile": "\nvoid sv_hostfile(void)\n\n{\n  long lVar1;\n  \n  lVar1 = find_variable();\n  if (lVar1 != 0) {\n    hostname_list_initialized = 0;\n    return;\n  }\n  clear_hostname_list();\n  return;\n}\n\n",
  "FUN_00134c60": "\nbool FUN_00134c60(ulong param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = (int)param_1;\n  if (iVar1 < 0x131) {\n    if (iVar1 < 0x102) {\n      if (iVar1 < 0x3c) {\n        if ((-1 < iVar1) && ((0x800034000000401U >> (param_1 & 0x3f) & 1) != 0)) {\n          return true;\n        }\n      }\n      else if (iVar1 - 0x7bU < 3) {\n        return true;\n      }\n    }\n    else if ((0x60e0c8795e5fU >> ((ulong)(iVar1 - 0x102) & 0x3f) & 1) != 0) {\n      return true;\n    }\n  }\n  if (DAT_00240d70 != 0x119) {\n    return false;\n  }\n  return DAT_00240d6c - 0x10fU < 2;\n}\n\n",
  "discard_last_procsub_child": "\nvoid discard_last_procsub_child(void)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long *plVar3;\n  long in_FS_OFFSET;\n  sigset_t sStack_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_138);\n  sigaddset(&sStack_138,0x11);\n  sigemptyset(&local_b8);\n  sigprocmask(0,&sStack_138,&local_b8);\n  plVar2 = last_procsub_child;\n  last_procsub_child = (long *)0x0;\n  sigprocmask(2,&local_b8,(sigset_t *)0x0);\n  plVar3 = plVar2;\n  if (plVar2 != (long *)0x0) {\n    do {\n      plVar1 = (long *)*plVar3;\n      if (plVar3[3] != 0) {\n        sh_xfree(plVar3[3],\"jobs.c\",0x5c2);\n      }\n      sh_xfree(plVar3,\"jobs.c\",0x5c3);\n      plVar3 = plVar1;\n    } while (plVar2 != plVar1);\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "read": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = (*(code *)PTR_read_00237ac8)();\n  return sVar1;\n}\n\n",
  "rl_redisplay": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid rl_redisplay(void)\n\n{\n  int *piVar1;\n  undefined8 *puVar2;\n  char cVar3;\n  byte bVar4;\n  undefined uVar5;\n  void *__s;\n  byte bVar6;\n  int iVar7;\n  int iVar8;\n  size_t sVar9;\n  char **ppcVar10;\n  long lVar11;\n  ushort **ppuVar12;\n  __int32_t **pp_Var13;\n  undefined8 uVar14;\n  char *pcVar15;\n  size_t sVar16;\n  long *plVar17;\n  ulong uVar18;\n  undefined *puVar19;\n  int iVar20;\n  uint uVar21;\n  long lVar22;\n  ulong uVar23;\n  char *pcVar24;\n  undefined *puVar25;\n  uint uVar26;\n  int iVar27;\n  ulong uVar28;\n  int iVar29;\n  int iVar30;\n  uint uVar31;\n  byte bVar32;\n  long lVar33;\n  ulong uVar34;\n  ulong uVar35;\n  char *pcVar36;\n  long in_FS_OFFSET;\n  undefined local_a8;\n  size_t local_a0;\n  int local_8c;\n  int local_88;\n  int local_84;\n  int local_70;\n  uint local_60;\n  wchar_t local_54;\n  mbstate_t local_50;\n  undefined local_45 [5];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar9 = __ctype_get_mb_cur_max();\n  if (_rl_echoing_p == 0) goto LAB_001e500b;\n  _rl_block_sigint();\n  rl_readline_state = rl_readline_state | 0x1000000;\n  iVar7 = rl_mark_active_p();\n  local_84 = -1;\n  local_8c = -1;\n  if (((iVar7 != 0) && (-1 < rl_point)) && (rl_point <= rl_end)) {\n    if ((rl_end < rl_mark) || (rl_mark < 0)) {\n      local_84 = -1;\n      local_8c = -1;\n    }\n    else {\n      local_8c = rl_mark;\n      if (rl_point <= rl_mark) {\n        local_8c = rl_point;\n      }\n      local_84 = rl_mark;\n      if (rl_mark <= rl_point) {\n        local_84 = rl_point;\n      }\n    }\n  }\n  if (rl_display_prompt == (char *)0x0) {\n    rl_display_prompt = \"\";\n  }\n  if (DAT_0024a8dc == 0) {\n    FUN_001e0710(0);\n    puVar19 = PTR_DAT_00240520;\n    if (*(undefined **)PTR_DAT_00240520 != (undefined *)0x0) {\n      **(undefined **)PTR_DAT_00240520 = 0;\n    }\n    _rl_last_v_pos = 0;\n    _rl_last_c_pos = 0;\n    DAT_0024a8c0 = 0;\n    _rl_vis_botlin = 0;\n    if (*(undefined8 **)(puVar19 + 0x10) != (undefined8 *)0x0) {\n      **(undefined8 **)(puVar19 + 0x10) = 0;\n    }\n    DAT_0024a888 = 0;\n  }\n  else if (DAT_0024a8ac <= (int)_rl_screenwidth) {\n    FUN_001e0710(_rl_screenwidth + 1);\n  }\n  if (_rl_screenheight < 2) {\n    if (_rl_horizontal_scroll_mode == 0) {\n      DAT_0024a8a8 = 1;\n    }\n    _rl_horizontal_scroll_mode = 1;\n  }\n  else if (DAT_0024a8a8 != 0) {\n    _rl_horizontal_scroll_mode = 0;\n  }\n  uVar23 = (ulong)_rl_mark_modified_lines;\n  DAT_0024a8d0 = -1;\n  DAT_0024a860 = 0;\n  DAT_0024a8c8 = DAT_0024a88c - DAT_0024a870;\n  if (_rl_mark_modified_lines == 0) {\n    uVar28 = 0;\n    uVar34 = 1;\n    ppcVar10 = (char **)PTR_DAT_00240518;\n  }\n  else {\n    lVar22 = current_history();\n    if ((lVar22 == 0) || (rl_undo_list == 0)) {\n      uVar28 = 0;\n      uVar34 = 1;\n      uVar23 = 0;\n      ppcVar10 = (char **)PTR_DAT_00240518;\n    }\n    else {\n      uVar28 = 1;\n      uVar34 = 2;\n      uVar23 = 1;\n      FUN_001e05c0(1);\n      puVar19 = PTR_DAT_00240518;\n      **(undefined **)PTR_DAT_00240518 = 0x2a;\n      **(undefined **)(puVar19 + 8) = 0x30;\n      FUN_001e05c0(2);\n      ppcVar10 = (char **)PTR_DAT_00240518;\n      DAT_0024a860 = 1;\n      *(undefined *)(*(long *)PTR_DAT_00240518 + 1) = 0;\n      *(undefined *)(*(long *)((long)ppcVar10 + 8) + 1) = 0;\n    }\n  }\n  pcVar36 = DAT_0024a898;\n  pcVar24 = rl_display_prompt;\n  if (**(char **)PTR_DAT_00240520 != **ppcVar10) {\n    rl_display_fixed = 0;\n  }\n  iVar7 = (int)uVar23;\n  if ((rl_display_prompt == rl_prompt) || (DAT_0024a8a0 != 0)) {\n    if ((DAT_0024a898 != (char *)0x0) && (DAT_0024a8b0 != 0)) {\n      strlen(DAT_0024a898);\n      _rl_output_some_chars(pcVar36);\n    }\n    iVar29 = DAT_0024a894;\n    if (0 < DAT_0024a894) {\n      lVar11 = (long)iVar7;\n      lVar33 = DAT_0024a894 + lVar11;\n      lVar22 = DAT_0024a8a0 - lVar11;\n      do {\n        uVar5 = *(undefined *)(lVar22 + lVar11);\n        FUN_001e05c0((int)lVar11 + 1);\n        puVar19 = PTR_DAT_00240518;\n        *(undefined *)(*(long *)PTR_DAT_00240518 + lVar11) = uVar5;\n        *(undefined *)(*(long *)(puVar19 + 8) + lVar11) = 0x30;\n        lVar11 = lVar11 + 1;\n      } while (lVar33 != lVar11);\n      uVar26 = iVar7 + iVar29;\n      uVar23 = (ulong)uVar26;\n      uVar34 = (ulong)(uVar26 + 1);\n      uVar28 = (ulong)(int)uVar26;\n    }\n    FUN_001e05c0(uVar34);\n    iVar7 = DAT_0024a894;\n    puVar19 = PTR_DAT_00240518;\n    *(undefined *)(*(long *)PTR_DAT_00240518 + uVar28) = 0;\n    *(undefined *)(*(long *)(puVar19 + 8) + uVar28) = 0;\n    iVar7 = iVar7 - DAT_0024a88c;\n  }\n  else {\n    pcVar15 = strrchr(rl_display_prompt,10);\n    pcVar36 = pcVar24;\n    if (((pcVar15 != (char *)0x0) && (pcVar36 = pcVar15 + 1, DAT_0024a8b0 != 0)) &&\n       ((_rl_output_some_chars(pcVar24), (int)pcVar36 - (int)pcVar24 < 2 || (pcVar15[-1] != '\\r'))))\n    {\n      _rl_cr();\n      _rl_last_c_pos = 0;\n    }\n    sVar16 = strlen(pcVar36);\n    iVar29 = (int)sVar16;\n    DAT_0024a870 = iVar29;\n    if (0 < iVar29) {\n      lVar33 = (long)iVar7;\n      lVar22 = lVar33;\n      do {\n        cVar3 = pcVar36[lVar22 - lVar33];\n        FUN_001e05c0((int)lVar22 + 1);\n        puVar19 = PTR_DAT_00240518;\n        *(char *)(*(long *)PTR_DAT_00240518 + lVar22) = cVar3;\n        *(undefined *)(*(long *)(puVar19 + 8) + lVar22) = 0x30;\n        lVar22 = lVar22 + 1;\n      } while (lVar33 + 1 + (ulong)(iVar29 - 1) != lVar22);\n      uVar26 = iVar7 + iVar29;\n      uVar23 = (ulong)uVar26;\n      uVar34 = (ulong)(uVar26 + 1);\n      uVar28 = (ulong)(int)uVar26;\n    }\n    iVar7 = 0;\n    FUN_001e05c0(uVar34);\n    puVar19 = PTR_DAT_00240518;\n    *(undefined *)(*(long *)PTR_DAT_00240518 + uVar28) = 0;\n    *(undefined *)(*(long *)(puVar19 + 8) + uVar28) = 0;\n    DAT_0024a878 = 0;\n  }\n  iVar29 = DAT_0024a860;\n  iVar20 = (int)uVar23;\n  local_70 = (int)sVar9;\n  __s = *(void **)(puVar19 + 0x20);\n  DAT_0024a884 = iVar7;\n  **(undefined4 **)(puVar19 + 0x10) = 0;\n  iVar29 = iVar29 + DAT_0024a870;\n  memset(__s,0,(long)*(int *)(puVar19 + 0x1c) << 2);\n  lVar22 = DAT_0024a868;\n  if (iVar29 < (int)_rl_screenwidth) {\n    _DAT_0024a874 = 0;\nLAB_001e5236:\n    local_a0 = 1;\n    uVar26 = _DAT_0024a874;\n    if (1 < local_70) {\nLAB_001e5256:\n      local_a0 = 1;\n      uVar26 = _DAT_0024a874;\n      if (rl_byte_oriented == 0) goto LAB_001e6439;\n    }\n  }\n  else {\n    if (*(int *)(DAT_0024a868 + 4) == -1) {\n      uVar26 = 0;\n      iVar27 = 0;\n    }\n    else {\n      lVar33 = *(long *)(puVar19 + 0x10);\n      lVar11 = 0;\n      iVar8 = *(int *)(DAT_0024a868 + 4);\n      do {\n        iVar27 = iVar8;\n        *(int *)(lVar33 + 4 + lVar11 * 4) = iVar27;\n        uVar26 = (int)lVar11 + 1;\n        lVar11 = lVar11 + 1;\n        iVar8 = *(int *)(lVar22 + 4 + lVar11 * 4);\n      } while (iVar8 != -1);\n    }\n    lVar22 = DAT_0024a8a0;\n    iVar8 = DAT_0024a894;\n    if (((local_70 < 2) || (rl_byte_oriented != 0)) || (DAT_0024a8c8 < 1)) {\n      iVar29 = iVar29 - uVar26 * _rl_screenwidth;\n      _DAT_0024a874 = uVar26;\n      goto LAB_001e5236;\n    }\n    if (iVar27 < DAT_0024a894) {\n      sVar9 = __ctype_get_mb_cur_max();\n      if ((sVar9 == 1) || (rl_byte_oriented != 0)) {\n        iVar29 = iVar8 - iVar27;\n      }\n      else {\n        iVar29 = FUN_001e08f0(lVar22,iVar27,iVar8,1);\n      }\n      iVar29 = iVar29 - (iVar7 - DAT_0024a878);\n      _DAT_0024a874 = uVar26;\n      goto LAB_001e5256;\n    }\n    iVar29 = DAT_0024a878 - iVar7;\n    _DAT_0024a874 = uVar26;\nLAB_001e6439:\n    uVar26 = _DAT_0024a874;\n    local_50.__count = 0;\n    local_50.__value = (_union_27)0x0;\n    if ((_rl_utf8locale == 0) || (*rl_line_buffer < '\\0')) {\n      local_a0 = mbrtowc(&local_54,rl_line_buffer,(long)rl_end,&local_50);\n    }\n    else {\n      local_a0 = 1;\n      local_54 = (int)*rl_line_buffer;\n    }\n  }\n  iVar7 = 0;\n  if (rl_end < 1) {\n    local_60 = 0;\n  }\n  else {\n    local_a8 = 0x30;\n    uVar18 = 0;\n    uVar28 = (ulong)iVar20;\n    local_60 = 0;\n    uVar34 = (ulong)(iVar20 + 1);\nLAB_001e530d:\n    do {\n      iVar20 = (int)uVar23;\n      iVar27 = (int)uVar18;\n      if (iVar27 == local_8c) {\n        local_a8 = 0x31;\n      }\n      else if (iVar27 == local_84) {\n        local_a8 = 0x30;\n      }\n      uVar18 = (ulong)iVar27;\n      bVar4 = rl_line_buffer[uVar18];\n      if ((1 < local_70) && (rl_byte_oriented == 0)) {\n        if (local_a0 < 0xfffffffffffffffe) {\n          if (local_a0 == 0) break;\n          if (local_54 < L'`') {\n            if (local_54 < L'A') {\n              if (local_54 < L'$') {\n                local_88 = 1;\n                if (L'\\x1f' < local_54) goto LAB_001e53d0;\n              }\n              else if ((uint)(local_54 + L'\\xffffffdb') < 0x1b) goto LAB_001e599c;\nLAB_001e5398:\n              iVar8 = wcwidth(local_54);\n              local_88 = 1;\n              if (-1 < iVar8) {\n                local_88 = iVar8;\n              }\n            }\n            else {\nLAB_001e599c:\n              local_88 = 1;\n            }\n          }\n          else {\n            local_88 = 1;\n            if (0x1d < (uint)(local_54 + L'\\xffffff9f')) goto LAB_001e5398;\n          }\n        }\n        else {\n          local_50.__count = 0;\n          local_50.__value = (_union_27)0x0;\n          local_88 = 1;\n          local_a0 = 1;\n        }\n      }\nLAB_001e53d0:\n      puVar19 = PTR_DAT_00240518;\n      uVar31 = (uint)bVar4;\n      if (rl_point == iVar27) {\n        DAT_0024a8d0 = iVar20;\n        local_60 = uVar26;\n      }\n      iVar8 = (int)uVar34;\n      if ((uVar31 - 0x80 < 0x80) && (_rl_output_meta_chars == 0)) {\n        iVar8 = __sprintf_chk(local_45,1,5,&DAT_00213c8c);\n        puVar19 = PTR_DAT_00240518;\n        iVar30 = iVar8 + iVar29;\n        if ((int)_rl_screenwidth <= iVar30) {\n          iVar29 = _rl_screenwidth - iVar29;\n          if (*(int *)(PTR_DAT_00240518 + 0x18) + -2 <= (int)uVar26) {\n            iVar30 = *(int *)(PTR_DAT_00240518 + 0x18) * 2;\n            puVar2 = (undefined8 *)(PTR_DAT_00240518 + 0x10);\n            *(int *)(PTR_DAT_00240518 + 0x18) = iVar30;\n            uVar14 = xrealloc(*puVar2,(long)iVar30 * 4);\n            *(undefined8 *)(puVar19 + 0x10) = uVar14;\n          }\n          puVar19 = PTR_DAT_00240518;\n          if (*(int *)(PTR_DAT_00240518 + 0x1c) + -2 <= (int)uVar26) {\n            iVar30 = *(int *)(PTR_DAT_00240518 + 0x1c) * 2;\n            puVar2 = (undefined8 *)(PTR_DAT_00240518 + 0x20);\n            *(int *)(PTR_DAT_00240518 + 0x1c) = iVar30;\n            uVar14 = xrealloc(*puVar2,(long)iVar30 * 4);\n            *(undefined8 *)(puVar19 + 0x20) = uVar14;\n          }\n          puVar19 = PTR_DAT_00240518;\n          uVar26 = uVar26 + 1;\n          *(int *)(*(long *)(PTR_DAT_00240518 + 0x10) + (long)(int)uVar26 * 4) = iVar29 + iVar20;\n          *(int *)(*(long *)(puVar19 + 0x20) + (long)(int)uVar26 * 4) = iVar7;\n          iVar30 = iVar8 - iVar29;\n        }\n        uVar23 = uVar34;\n        uVar34 = uVar28;\n        while( true ) {\n          iVar29 = (int)uVar23;\n          iVar30 = iVar30 + 1;\n          uVar5 = local_45[uVar34 - uVar28];\n          FUN_001e05c0(uVar23);\n          puVar19 = PTR_DAT_00240518;\n          *(undefined *)(*(long *)PTR_DAT_00240518 + uVar34) = uVar5;\n          *(undefined *)(*(long *)(puVar19 + 8) + uVar34) = local_a8;\n          if ((int)_rl_screenwidth <= iVar30) {\n            if (*(int *)(puVar19 + 0x18) + -2 <= (int)uVar26) {\n              iVar30 = *(int *)(puVar19 + 0x18) * 2;\n              *(int *)(puVar19 + 0x18) = iVar30;\n              uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x10),(long)iVar30 * 4);\n              *(undefined8 *)(puVar19 + 0x10) = uVar14;\n              puVar19 = PTR_DAT_00240518;\n            }\n            uVar26 = uVar26 + 1;\n            *(int *)(*(long *)(puVar19 + 0x10) + (long)(int)uVar26 * 4) = iVar29;\n            if (*(int *)(puVar19 + 0x1c) + -2 <= (int)uVar26) {\n              iVar30 = *(int *)(puVar19 + 0x1c) * 2;\n              *(int *)(puVar19 + 0x1c) = iVar30;\n              uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x20),(long)iVar30 * 4);\n              *(undefined8 *)(puVar19 + 0x20) = uVar14;\n              puVar19 = PTR_DAT_00240518;\n            }\n            *(int *)(*(long *)(puVar19 + 0x20) + (long)(int)uVar26 * 4) = iVar7;\n            iVar30 = 0;\n          }\n          uVar34 = uVar34 + 1;\n          if (iVar29 == iVar20 + iVar8) break;\n          uVar23 = (ulong)(iVar29 + 1);\n        }\n        uVar28 = (ulong)iVar29;\n        uVar34 = (ulong)(iVar29 + 1);\nLAB_001e54e0:\n        iVar29 = iVar30;\n        if (1 < local_70) goto LAB_001e52a0;\nLAB_001e54eb:\n        iVar20 = (int)uVar23;\n        uVar18 = (ulong)(iVar27 + 1U);\n        if (rl_end <= (int)(iVar27 + 1U)) break;\n        goto LAB_001e530d;\n      }\n      if (uVar31 == 9) {\n        iVar8 = (iVar20 + 8) - iVar29 % 8;\n        iVar30 = (iVar8 - iVar20) + iVar29;\n        if (iVar30 < (int)_rl_screenwidth) {\n          if (iVar20 < iVar8) {\n            while( true ) {\n              uVar23 = uVar34;\n              iVar29 = (int)uVar23;\n              FUN_001e05c0(uVar23);\n              puVar19 = PTR_DAT_00240518;\n              *(undefined *)(*(long *)PTR_DAT_00240518 + uVar28) = 0x20;\n              *(undefined *)(*(long *)(puVar19 + 8) + uVar28) = local_a8;\n              uVar28 = uVar28 + 1;\n              if (iVar8 == iVar29) break;\n              uVar34 = (ulong)(iVar29 + 1);\n            }\n            uVar28 = (ulong)iVar29;\n            uVar34 = (ulong)(iVar29 + 1);\n          }\n        }\n        else {\n          iVar29 = _rl_screenwidth - iVar29;\n          if ((int)uVar26 < *(int *)(PTR_DAT_00240518 + 0x18) + -2) {\n            iVar30 = *(int *)(PTR_DAT_00240518 + 0x1c);\n          }\n          else {\n            iVar30 = *(int *)(PTR_DAT_00240518 + 0x18) * 2;\n            puVar2 = (undefined8 *)(PTR_DAT_00240518 + 0x10);\n            *(int *)(PTR_DAT_00240518 + 0x18) = iVar30;\n            uVar14 = xrealloc(*puVar2,(long)iVar30 * 4);\n            *(undefined8 *)(puVar19 + 0x10) = uVar14;\n            iVar30 = *(int *)(PTR_DAT_00240518 + 0x1c);\n            puVar19 = PTR_DAT_00240518;\n          }\n          PTR_DAT_00240518 = puVar19;\n          if (iVar30 + -2 <= (int)uVar26) {\n            *(int *)(puVar19 + 0x1c) = iVar30 * 2;\n            uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x20),(long)(iVar30 * 2) * 4);\n            *(undefined8 *)(puVar19 + 0x20) = uVar14;\n          }\n          puVar19 = PTR_DAT_00240518;\n          iVar30 = (iVar8 - iVar20) - iVar29;\n          uVar26 = uVar26 + 1;\n          *(int *)(*(long *)(PTR_DAT_00240518 + 0x10) + (long)(int)uVar26 * 4) = iVar29 + iVar20;\n          *(int *)(*(long *)(puVar19 + 0x20) + (long)(int)uVar26 * 4) = iVar7;\n          if (iVar20 < iVar8) {\n            while( true ) {\n              uVar23 = uVar34;\n              iVar29 = (int)uVar23;\n              FUN_001e05c0(uVar23);\n              puVar19 = PTR_DAT_00240518;\n              *(undefined *)(*(long *)PTR_DAT_00240518 + uVar28) = 0x20;\n              *(undefined *)(*(long *)(puVar19 + 8) + uVar28) = local_a8;\n              uVar28 = uVar28 + 1;\n              if (iVar8 == iVar29) break;\n              uVar34 = (ulong)(iVar29 + 1);\n            }\n            uVar28 = (ulong)iVar29;\n            uVar34 = (ulong)(iVar29 + 1);\n          }\n        }\n        goto LAB_001e54e0;\n      }\n      if (uVar31 == 10) {\n        if (_rl_horizontal_scroll_mode == 0) {\n          bVar32 = 1;\n          if ((_rl_term_up != (char *)0x0) && (*_rl_term_up != '\\0')) {\n            FUN_001e05c0(uVar34);\n            puVar19 = PTR_DAT_00240518;\n            *(undefined *)(*(long *)PTR_DAT_00240518 + uVar28) = 0;\n            *(undefined *)(*(long *)(puVar19 + 8) + uVar28) = local_a8;\n            if (*(int *)(puVar19 + 0x18) + -2 <= (int)uVar26) {\n              iVar29 = *(int *)(puVar19 + 0x18) * 2;\n              *(int *)(puVar19 + 0x18) = iVar29;\n              uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x10),(long)iVar29 * 4);\n              *(undefined8 *)(puVar19 + 0x10) = uVar14;\n              puVar19 = PTR_DAT_00240518;\n            }\n            if (*(int *)(puVar19 + 0x1c) + -2 <= (int)uVar26) {\n              iVar29 = *(int *)(puVar19 + 0x1c) * 2;\n              *(int *)(puVar19 + 0x1c) = iVar29;\n              uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x20),(long)iVar29 * 4);\n              *(undefined8 *)(puVar19 + 0x20) = uVar14;\n              puVar19 = PTR_DAT_00240518;\n            }\n            uVar26 = uVar26 + 1;\n            uVar28 = (ulong)iVar8;\n            iVar30 = 0;\n            *(int *)(*(long *)(puVar19 + 0x10) + (long)(int)uVar26 * 4) = iVar8;\n            *(int *)(*(long *)(puVar19 + 0x20) + (long)(int)uVar26 * 4) = iVar7;\n            uVar23 = uVar34;\n            uVar34 = (ulong)(iVar8 + 1);\n            goto LAB_001e54e0;\n          }\n        }\n        else {\n          bVar32 = 1;\n        }\nLAB_001e57c6:\n        FUN_001e05c0(uVar34);\n        puVar19 = PTR_DAT_00240518;\n        *(undefined *)(*(long *)PTR_DAT_00240518 + uVar28) = 0x5e;\n        *(undefined *)(*(long *)(puVar19 + 8) + uVar28) = local_a8;\n        iVar30 = iVar29 + 2;\n        if ((int)_rl_screenwidth <= iVar29 + 1) {\n          if (*(int *)(puVar19 + 0x18) + -2 <= (int)uVar26) {\n            iVar29 = *(int *)(puVar19 + 0x18) * 2;\n            *(int *)(puVar19 + 0x18) = iVar29;\n            uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x10),(long)iVar29 * 4);\n            *(undefined8 *)(puVar19 + 0x10) = uVar14;\n            puVar19 = PTR_DAT_00240518;\n          }\n          uVar26 = uVar26 + 1;\n          *(int *)(*(long *)(puVar19 + 0x10) + (long)(int)uVar26 * 4) = iVar8;\n          if (*(int *)(puVar19 + 0x1c) + -2 <= (int)uVar26) {\n            iVar29 = *(int *)(puVar19 + 0x1c) * 2;\n            *(int *)(puVar19 + 0x1c) = iVar29;\n            uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x20),(long)iVar29 * 4);\n            *(undefined8 *)(puVar19 + 0x20) = uVar14;\n            puVar19 = PTR_DAT_00240518;\n          }\n          *(int *)(*(long *)(puVar19 + 0x20) + (long)(int)uVar26 * 4) = iVar7;\n          iVar30 = 1;\n        }\n        bVar6 = 0x3f;\n        if (bVar32 != 0) {\n          ppuVar12 = __ctype_b_loc();\n          bVar6 = bVar4 | 0x40;\n          if ((*(byte *)((long)*ppuVar12 + (long)(char)bVar6 * 2 + 1) & 2) != 0) {\n            pp_Var13 = __ctype_toupper_loc();\n            bVar6 = *(byte *)(*pp_Var13 + (char)bVar6);\n          }\n        }\n        uVar31 = iVar20 + 2;\n        FUN_001e05c0(uVar31);\n        puVar19 = PTR_DAT_00240518;\n        *(byte *)(*(long *)PTR_DAT_00240518 + (long)iVar8) = bVar6;\n        *(undefined *)(*(long *)(puVar19 + 8) + (long)iVar8) = local_a8;\n        if ((int)_rl_screenwidth <= iVar30) {\n          if (*(int *)(puVar19 + 0x18) + -2 <= (int)uVar26) {\n            iVar29 = *(int *)(puVar19 + 0x18) * 2;\n            *(int *)(puVar19 + 0x18) = iVar29;\n            uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x10),(long)iVar29 * 4);\n            *(undefined8 *)(puVar19 + 0x10) = uVar14;\n            puVar19 = PTR_DAT_00240518;\n          }\n          uVar26 = uVar26 + 1;\n          *(uint *)(*(long *)(puVar19 + 0x10) + (long)(int)uVar26 * 4) = uVar31;\n          if (*(int *)(puVar19 + 0x1c) + -2 <= (int)uVar26) {\n            iVar29 = *(int *)(puVar19 + 0x1c) * 2;\n            *(int *)(puVar19 + 0x1c) = iVar29;\n            uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x20),(long)iVar29 * 4);\n            *(undefined8 *)(puVar19 + 0x20) = uVar14;\n            puVar19 = PTR_DAT_00240518;\n          }\n          *(int *)(*(long *)(puVar19 + 0x20) + (long)(int)uVar26 * 4) = iVar7;\n          iVar30 = 0;\n        }\n        uVar28 = (ulong)(int)uVar31;\n        uVar23 = (ulong)uVar31;\n        uVar34 = (ulong)(iVar20 + 3);\n        goto LAB_001e54e0;\n      }\n      bVar32 = (byte)~bVar4 >> 7 & bVar4 < 0x20;\n      if ((bVar32 != 0) || (uVar31 == 0x7f)) goto LAB_001e57c6;\n      if ((local_70 < 2) || (rl_byte_oriented != 0)) {\n        iVar30 = iVar29 + 1;\n        FUN_001e05c0(uVar34);\n        puVar19 = PTR_DAT_00240518;\n        *(byte *)(*(long *)PTR_DAT_00240518 + uVar28) = bVar4;\n        *(undefined *)(*(long *)(puVar19 + 8) + uVar28) = local_a8;\n        if (iVar30 < (int)_rl_screenwidth) {\n          uVar28 = (ulong)iVar8;\n          uVar23 = uVar34;\n          uVar34 = (ulong)(iVar8 + 1);\n        }\n        else {\n          if (*(int *)(puVar19 + 0x18) + -2 <= (int)uVar26) {\n            iVar29 = *(int *)(puVar19 + 0x18) * 2;\n            *(int *)(puVar19 + 0x18) = iVar29;\n            uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x10),(long)iVar29 * 4);\n            *(undefined8 *)(puVar19 + 0x10) = uVar14;\n            puVar19 = PTR_DAT_00240518;\n          }\n          uVar26 = uVar26 + 1;\n          *(int *)(*(long *)(puVar19 + 0x10) + (long)(int)uVar26 * 4) = iVar8;\n          if (*(int *)(puVar19 + 0x1c) + -2 <= (int)uVar26) {\n            iVar29 = *(int *)(puVar19 + 0x1c) * 2;\n            *(int *)(puVar19 + 0x1c) = iVar29;\n            uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x20),(long)iVar29 * 4);\n            *(undefined8 *)(puVar19 + 0x20) = uVar14;\n            puVar19 = PTR_DAT_00240518;\n          }\n          uVar28 = (ulong)iVar8;\n          *(int *)(*(long *)(puVar19 + 0x20) + (long)(int)uVar26 * 4) = iVar7;\n          iVar30 = 0;\n          uVar23 = uVar34;\n          uVar34 = (ulong)(iVar8 + 1);\n        }\n        goto LAB_001e54e0;\n      }\n      iVar7 = 0;\n      iVar20 = iVar29;\n      if (((int)_rl_screenwidth < local_88 + iVar29) && (iVar29 < (int)_rl_screenwidth)) {\n        iVar7 = 0;\n        do {\n          iVar30 = iVar8 + iVar7;\n          iVar20 = iVar20 + 1;\n          iVar7 = iVar7 + 1;\n          FUN_001e05c0(iVar30);\n          puVar19 = PTR_DAT_00240518;\n          *(undefined *)(*(long *)PTR_DAT_00240518 + uVar28) = 0x20;\n          *(undefined *)(*(long *)(puVar19 + 8) + uVar28) = local_a8;\n          if ((int)_rl_screenwidth <= iVar20) {\n            if (*(int *)(puVar19 + 0x18) + -2 <= (int)uVar26) {\n              iVar20 = *(int *)(puVar19 + 0x18) * 2;\n              *(int *)(puVar19 + 0x18) = iVar20;\n              uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x10),(long)iVar20 * 4);\n              *(undefined8 *)(puVar19 + 0x10) = uVar14;\n              puVar19 = PTR_DAT_00240518;\n            }\n            uVar26 = uVar26 + 1;\n            *(int *)(*(long *)(puVar19 + 0x10) + (long)(int)uVar26 * 4) = iVar30;\n            if (*(int *)(puVar19 + 0x1c) + -2 <= (int)uVar26) {\n              iVar20 = *(int *)(puVar19 + 0x1c) * 2;\n              *(int *)(puVar19 + 0x1c) = iVar20;\n              uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x20),(long)iVar20 * 4);\n              *(undefined8 *)(puVar19 + 0x20) = uVar14;\n              puVar19 = PTR_DAT_00240518;\n            }\n            *(int *)(*(long *)(puVar19 + 0x20) + (long)(int)uVar26 * 4) = iVar7;\n            iVar20 = 0;\n          }\n          uVar28 = uVar28 + 1;\n        } while (iVar29 + iVar7 < (int)_rl_screenwidth);\n        uVar23 = (ulong)iVar30;\n        uVar34 = (ulong)(iVar30 + 1);\n        uVar28 = uVar23;\n      }\n      if (iVar27 == rl_point) {\n        DAT_0024a8d0 = (int)uVar23;\n        local_60 = uVar26;\n      }\n      if (uVar18 < local_a0 + uVar18) {\n        uVar35 = uVar18;\n        do {\n          cVar3 = rl_line_buffer[uVar35];\n          FUN_001e05c0(((int)uVar23 - iVar27) + 1 + (int)uVar35);\n          puVar19 = PTR_DAT_00240518;\n          lVar22 = (uVar28 - uVar18) + uVar35;\n          uVar35 = uVar35 + 1;\n          *(char *)(*(long *)PTR_DAT_00240518 + lVar22) = cVar3;\n          *(undefined *)(*(long *)(puVar19 + 8) + lVar22) = local_a8;\n        } while (uVar35 < local_a0 + uVar18);\n        uVar31 = (int)uVar34 + -1 + (int)local_a0;\n        uVar23 = (ulong)uVar31;\n        uVar28 = (ulong)(int)uVar31;\n        uVar34 = (ulong)(uVar31 + 1);\n      }\n      iVar29 = iVar20;\n      if (local_88 != 0) {\n        iVar8 = 0;\n        uVar23 = uVar23 & 0xffffffff;\n        do {\n          puVar19 = PTR_DAT_00240518;\n          iVar20 = iVar20 + 1;\n          if ((int)_rl_screenwidth <= iVar20) {\n            if (*(int *)(PTR_DAT_00240518 + 0x18) + -2 <= (int)uVar26) {\n              iVar29 = *(int *)(PTR_DAT_00240518 + 0x18) * 2;\n              puVar2 = (undefined8 *)(PTR_DAT_00240518 + 0x10);\n              *(int *)(PTR_DAT_00240518 + 0x18) = iVar29;\n              uVar14 = xrealloc(*puVar2,(long)iVar29 * 4);\n              *(undefined8 *)(puVar19 + 0x10) = uVar14;\n            }\n            puVar19 = PTR_DAT_00240518;\n            uVar26 = uVar26 + 1;\n            *(int *)(*(long *)(PTR_DAT_00240518 + 0x10) + (long)(int)uVar26 * 4) = (int)uVar23;\n            if (*(int *)(puVar19 + 0x1c) + -2 <= (int)uVar26) {\n              iVar29 = *(int *)(puVar19 + 0x1c) * 2;\n              *(int *)(puVar19 + 0x1c) = iVar29;\n              uVar14 = xrealloc(*(undefined8 *)(puVar19 + 0x20),(long)iVar29 * 4);\n              *(undefined8 *)(puVar19 + 0x20) = uVar14;\n              puVar19 = PTR_DAT_00240518;\n            }\n            iVar20 = 0;\n            *(int *)(*(long *)(puVar19 + 0x20) + (long)(int)uVar26 * 4) = iVar7;\n          }\n          iVar8 = iVar8 + 1;\n          iVar29 = iVar20;\n        } while (local_88 != iVar8);\n      }\nLAB_001e52a0:\n      iVar20 = (int)uVar23;\n      if (rl_byte_oriented != 0) goto LAB_001e54eb;\n      iVar27 = (int)local_a0 + iVar27;\n      uVar18 = (ulong)iVar27;\n      if ((_rl_utf8locale == 0) || (cVar3 = rl_line_buffer[uVar18], cVar3 < '\\0')) {\n        local_a0 = mbrtowc(&local_54,rl_line_buffer + uVar18,(long)(rl_end - iVar27),&local_50);\n      }\n      else {\n        local_50.__count = 0;\n        local_50.__value = (_union_27)0x0;\n        local_a0 = 1;\n        local_54 = (int)cVar3;\n      }\n    } while (iVar27 < rl_end);\n  }\n  FUN_001e05c0(uVar34);\n  iVar29 = DAT_0024a8d0;\n  plVar17 = (long *)PTR_DAT_00240518;\n  *(undefined *)(*(long *)PTR_DAT_00240518 + uVar28) = 0;\n  *(undefined *)(*(long *)((long)plVar17 + 8) + uVar28) = 0;\n  if (iVar29 < 0) {\n    DAT_0024a8d0 = iVar20;\n    local_60 = uVar26;\n  }\n  if ((DAT_0024a8d8 != 0) && (uVar26 != 0)) {\n    DAT_0024a8d8 = 0;\n  }\n  DAT_0024a8c4 = uVar26;\n  if (*(int *)((long)plVar17 + 0x18) + -2 <= (int)uVar26) {\n    iVar29 = *(int *)((long)plVar17 + 0x18) * 2;\n    *(int *)((long)plVar17 + 0x18) = iVar29;\n    uVar14 = xrealloc(*(undefined8 *)((long)plVar17 + 0x10),(long)iVar29 * 4);\n    *(undefined8 *)((long)plVar17 + 0x10) = uVar14;\n    plVar17 = (long *)PTR_DAT_00240518;\n  }\n  if (*(int *)((long)plVar17 + 0x1c) + -2 <= (int)uVar26) {\n    iVar29 = *(int *)((long)plVar17 + 0x1c) * 2;\n    *(int *)((long)plVar17 + 0x1c) = iVar29;\n    lVar22 = xrealloc(plVar17[4],(long)iVar29 * 4);\n    plVar17[4] = lVar22;\n    plVar17 = (long *)PTR_DAT_00240518;\n  }\n  DAT_0024a8cc = 1;\n  *(int *)(plVar17[2] + ((long)(int)uVar26 + 1) * 4) = iVar20;\n  *(int *)(plVar17[4] + ((long)(int)uVar26 + 1) * 4) = iVar7;\n  iVar7 = DAT_0024a8c0;\n  if (((_rl_horizontal_scroll_mode == 0) && (_rl_term_up != (char *)0x0)) && (*_rl_term_up != '\\0'))\n  {\n    if ((rl_display_fixed == 0) || (DAT_0024a8b0 != 0)) {\n      DAT_0024a8b0 = 0;\n      if (_rl_screenchars <= iVar20) {\n        if ((local_70 < 2) || (rl_byte_oriented != 0)) {\n          iVar20 = _rl_screenchars + -1;\n        }\n        else {\n          iVar20 = _rl_find_prev_mbchar(*plVar17,_rl_screenchars,0);\n        }\n      }\n      iVar7 = rl_mark_active_p();\n      plVar17 = (long *)PTR_DAT_00240518;\n      if (((iVar7 != 0) && (_rl_screenheight < (int)uVar26)) &&\n         (iVar7 = uVar26 - _rl_screenheight, -1 < iVar7)) {\n        lVar22 = 4;\n        do {\n          iVar29 = *(int *)(*(long *)((long)plVar17 + 0x10) + -4 + lVar22);\n          piVar1 = (int *)(*(long *)((long)plVar17 + 0x10) + lVar22);\n          lVar22 = lVar22 + 4;\n          memset((void *)((long)iVar29 + *(long *)((long)plVar17 + 8)),0x30,(long)(*piVar1 - iVar29)\n                );\n        } while ((long)iVar7 * 4 + 8 != lVar22);\n      }\n      uVar23 = 0;\n      do {\n        iVar29 = _rl_last_c_pos;\n        uVar31 = (uint)uVar23;\n        DAT_0024a8d4 = 0;\n        iVar7 = *(int *)(plVar17[2] + uVar23 * 4);\n        if ((int)_rl_vis_botlin < (int)uVar31) {\n          puVar25 = &DAT_00213d70;\n          iVar27 = 0;\n          puVar19 = puVar25;\n        }\n        else {\n          iVar8 = *(int *)(*(long *)(PTR_DAT_00240520 + 0x10) + uVar23 * 4);\n          iVar27 = *(int *)(*(long *)(PTR_DAT_00240520 + 0x10) + 4 + uVar23 * 4) - iVar8;\n          puVar25 = (undefined *)(*(long *)(PTR_DAT_00240520 + 8) + (long)iVar8);\n          puVar19 = (undefined *)((long)iVar8 + *(long *)PTR_DAT_00240520);\n        }\n        uVar21 = (uint)(uVar23 & 0xffffffff) | uVar26;\n        FUN_001e27c0(puVar19,puVar25,*plVar17 + (long)iVar7,(long)iVar7 + plVar17[1],\n                     uVar23 & 0xffffffff,iVar27,*(int *)(plVar17[2] + 4 + uVar23 * 4) - iVar7,uVar26\n                    );\n        if ((local_70 < 2) || ((uVar31 | rl_byte_oriented) != 0)) {\n          if (DAT_0024a8d4 == 0) {\nLAB_001e649c:\n            if (((((_DAT_0024a874 == uVar31) && ((int)_rl_screenwidth < DAT_0024a870)) &&\n                 (1 < local_70)) && ((rl_byte_oriented == 0 && (_rl_last_c_pos != iVar29)))) &&\n               ((int)((DAT_0024a880 - _rl_screenwidth) - DAT_0024a878) < _rl_last_c_pos)) {\n              _rl_last_c_pos = (_rl_last_c_pos + DAT_0024a878) - DAT_0024a884;\n            }\n          }\n          if (uVar21 == 0) goto LAB_001e64ba;\n          if (uVar31 == 0) goto LAB_001e64f5;\n        }\n        else {\n          if (DAT_0024a8d4 == 0) {\n            if (((_rl_last_c_pos == iVar29) || (_rl_last_c_pos <= DAT_0024a884)) ||\n               (DAT_0024a880 <= iVar29)) goto LAB_001e649c;\n            _rl_last_c_pos = _rl_last_c_pos - DAT_0024a878;\n          }\n          if (uVar21 == 0) {\nLAB_001e64ba:\n            if (((iVar20 == _rl_last_c_pos) && (DAT_0024a888 < DAT_0024a884)) &&\n               (iVar20 < (int)_DAT_0024a87c)) {\n              if ((local_70 < 2) || (rl_byte_oriented != 0)) {\n                iVar7 = (_rl_screenwidth + DAT_0024a884) - iVar20;\n              }\n              else {\n                iVar7 = _rl_screenwidth - iVar20;\n              }\n              if (iVar7 != 0) {\n                _rl_clear_to_eol();\n              }\n            }\n          }\n          else {\nLAB_001e64f5:\n            if (uVar26 != 0) {\n              _DAT_0024a87c = *(uint *)(*(long *)(PTR_DAT_00240518 + 0x10) + 4);\n              goto LAB_001e64d0;\n            }\n          }\n          _DAT_0024a87c = iVar20 - DAT_0024a884;\n        }\nLAB_001e64d0:\n        uVar23 = uVar23 + 1;\n        uVar31 = uVar31 + 1;\n        plVar17 = (long *)PTR_DAT_00240518;\n      } while ((int)uVar23 <= (int)uVar26);\n      if (((int)uVar26 < (int)_rl_vis_botlin) && ((int)uVar31 <= (int)_rl_vis_botlin)) {\n        lVar22 = (long)(int)uVar31 << 2;\n        do {\n          pcVar24 = (char *)((long)*(int *)(*(long *)(PTR_DAT_00240520 + 0x10) + lVar22) +\n                            *(long *)PTR_DAT_00240520);\n          _rl_move_vert(uVar31);\n          FUN_001e1320(0,pcVar24,\n                       (long)*(int *)(*(long *)(PTR_DAT_00240520 + 0x10) + lVar22) +\n                       *(long *)(PTR_DAT_00240520 + 8));\n          uVar23 = (ulong)_rl_screenwidth;\n          if (_rl_vis_botlin == uVar31) {\n            sVar9 = strlen(pcVar24);\n            uVar23 = sVar9 & 0xffffffff;\n          }\n          _rl_clear_to_eol(uVar23);\n          uVar31 = uVar31 + 1;\n          lVar22 = lVar22 + 4;\n        } while ((int)uVar31 <= (int)_rl_vis_botlin);\n      }\n      _rl_vis_botlin = uVar26;\n      if ((local_60 == _rl_last_v_pos) ||\n         ((_rl_move_vert(local_60), local_70 != 1 && (rl_byte_oriented == 0)))) {\n        if (local_60 != 0) goto LAB_001e6d8c;\n        iVar7 = DAT_0024a88c + DAT_0024a884;\nLAB_001e6b6c:\n        if (0 < DAT_0024a884) {\n          if (_rl_last_c_pos < 1) {\nLAB_001e6b82:\n            lVar22 = (long)**(int **)(PTR_DAT_00240518 + 0x10);\n            iVar7 = DAT_0024a8d0 - **(int **)(PTR_DAT_00240518 + 0x10);\n            goto LAB_001e6b98;\n          }\n          sVar9 = __ctype_get_mb_cur_max();\n          if ((sVar9 < 2) || (iVar29 = DAT_0024a870, rl_byte_oriented != 0)) {\n            iVar29 = DAT_0024a880 + 1;\n          }\n          if ((iVar29 <= _rl_last_c_pos) || (DAT_0024a8a0 == 0)) goto LAB_001e6b82;\n          _rl_cr();\n          if (DAT_0024a860 != 0) {\n            _rl_output_some_chars(&DAT_00213e4c,1);\n          }\n          _rl_output_some_chars(DAT_0024a8a0,iVar7);\n          lVar22 = DAT_0024a8a0;\n          if ((local_70 < 2) || (rl_byte_oriented != 0)) {\n            _rl_last_c_pos = iVar7 + DAT_0024a860;\n            goto LAB_001e6f54;\n          }\n          if (iVar7 < 1) {\n            iVar7 = 0;\n          }\n          else {\n            sVar9 = __ctype_get_mb_cur_max();\n            if ((sVar9 != 1) && (rl_byte_oriented == 0)) {\n              iVar7 = FUN_001e08f0(lVar22,0,iVar7,1);\n            }\n          }\n          _rl_last_c_pos = (iVar7 - DAT_0024a884) + DAT_0024a860;\n          lVar22 = (long)**(int **)(PTR_DAT_00240518 + 0x10);\n          iVar7 = DAT_0024a8d0 - **(int **)(PTR_DAT_00240518 + 0x10);\n          if ((DAT_0024a884 != 0) && (iVar7 < _rl_last_c_pos)) goto LAB_001e6bab;\n          goto LAB_001e6bcd;\n        }\nLAB_001e6f54:\n        lVar22 = (long)**(int **)(PTR_DAT_00240518 + 0x10);\n        iVar7 = DAT_0024a8d0 - **(int **)(PTR_DAT_00240518 + 0x10);\n        if (DAT_0024a884 == 0) goto LAB_001e6da8;\nLAB_001e6b98:\n        if (_rl_last_c_pos <= iVar7) goto LAB_001e6da8;\n        if (1 < local_70) {\nLAB_001e6bab:\n          if (rl_byte_oriented == 0) {\n            iVar29 = 0;\n            if (0 < iVar7) {\n              lVar33 = *(long *)PTR_DAT_00240520;\n              sVar9 = __ctype_get_mb_cur_max();\n              iVar29 = iVar7;\n              if ((sVar9 != 1) && (rl_byte_oriented == 0)) {\n                iVar29 = FUN_001e08f0(lVar33 + (int)lVar22,0,iVar7,1);\n              }\n            }\n            iVar29 = iVar29 - DAT_0024a888;\n            if (iVar29 < 0) goto LAB_001e6bcd;\nLAB_001e6bbf:\n            if (_rl_last_c_pos <= iVar29) goto LAB_001e6bcd;\n            goto LAB_001e6fc0;\n          }\n          iVar29 = iVar7;\n          if (-1 < iVar7) goto LAB_001e6bbf;\n          goto LAB_001e6bdd;\n        }\n        iVar29 = iVar7;\n        if (-1 < iVar7) {\nLAB_001e6fc0:\n          _rl_backspace(_rl_last_c_pos - iVar29);\n          _rl_last_c_pos = iVar29;\n          goto LAB_001e6da8;\n        }\n      }\n      else {\n        if (local_60 == 0) {\n          if (DAT_0024a884 != 0) {\n            _rl_last_c_pos = _rl_last_c_pos + DAT_0024a884;\n            iVar7 = DAT_0024a88c + DAT_0024a884;\n            goto LAB_001e6b6c;\n          }\n          lVar22 = (long)**(int **)(PTR_DAT_00240518 + 0x10);\n          iVar7 = DAT_0024a8d0 - **(int **)(PTR_DAT_00240518 + 0x10);\n        }\n        else {\nLAB_001e6d8c:\n          iVar7 = *(int *)(*(long *)(PTR_DAT_00240518 + 0x10) + (long)(int)local_60 * 4);\n          lVar22 = (long)iVar7;\n          iVar7 = DAT_0024a8d0 - iVar7;\n        }\nLAB_001e6da8:\n        if (1 < local_70) {\nLAB_001e6bcd:\n          if (rl_byte_oriented == 0) {\n            FUN_001e1320(iVar7,lVar22 + *(long *)PTR_DAT_00240518,\n                         *(long *)(PTR_DAT_00240518 + 8) + lVar22);\n            goto LAB_001e5e4c;\n          }\n        }\nLAB_001e6bdd:\n        if (_rl_last_c_pos == iVar7) goto LAB_001e5e4c;\n      }\n      FUN_001e1320(iVar7,lVar22 + *(long *)PTR_DAT_00240518,*(long *)(PTR_DAT_00240518 + 8) + lVar22\n                  );\n    }\n  }\n  else {\n    _rl_last_v_pos = 0;\n    iVar27 = DAT_0024a88c + DAT_0024a884;\n    iVar29 = DAT_0024a8d0 - DAT_0024a8c0;\n    if (DAT_0024a8c0 == 0) {\n      iVar29 = DAT_0024a8d0 - DAT_0024a884;\n    }\n    iVar8 = (int)_rl_screenwidth / 3;\n    iVar30 = DAT_0024a884;\n    if (iVar29 < (int)(_rl_screenwidth - 1)) {\n      if ((int)(_rl_screenwidth - 2) <= DAT_0024a8d0 - DAT_0024a884) {\n        if (iVar29 < 1) {\n          iVar8 = iVar8 * ((DAT_0024a8d0 + -1) / iVar8);\n          if (((DAT_0024a884 == 0) || (iVar8 < 1)) || (iVar27 <= iVar8)) {\n            DAT_0024a8cc = (uint)(iVar8 < iVar27);\n          }\n          else {\n            DAT_0024a8cc = 0;\n            iVar8 = iVar27;\n          }\n        }\n        else {\n          DAT_0024a8cc = (uint)(DAT_0024a8c0 < iVar27);\n          iVar8 = DAT_0024a8c0;\n        }\n        goto LAB_001e5cff;\n      }\n      DAT_0024a8cc = (uint)(0 < iVar27);\n      iVar8 = 0;\n      iVar27 = DAT_0024a884;\n    }\n    else {\n      iVar29 = DAT_0024a8d0 + iVar8 * -2;\n      iVar8 = 0;\n      if (-1 < iVar29) {\n        iVar8 = iVar29;\n      }\n      if (((DAT_0024a884 == 0) || (iVar29 < 1)) || (iVar8 >= iVar27)) {\n        DAT_0024a8cc = (uint)(iVar8 < iVar27);\nLAB_001e5cff:\n        iVar27 = iVar8;\n        if (iVar8 < 1) {\n          iVar27 = DAT_0024a884;\n          if (iVar8 != 0) {\n            iVar30 = 0;\n            iVar27 = iVar8;\n          }\n          goto LAB_001e5d22;\n        }\n      }\n      else {\n        DAT_0024a8cc = 0;\n      }\n      *(undefined *)(*plVar17 + (long)iVar27) = 0x3c;\n      iVar30 = 0;\n      iVar8 = iVar27;\n    }\nLAB_001e5d22:\n    iVar27 = iVar27 + _rl_screenwidth;\n    if ((iVar27 < iVar20) && (0 < iVar27)) {\n      *(undefined *)(*plVar17 + -1 + (long)iVar27) = 0x3e;\n    }\n    iVar29 = _rl_last_c_pos;\n    if (((rl_display_fixed == 0) || (DAT_0024a8b0 != 0)) || (iVar7 != iVar8)) {\n      lVar22 = (long)iVar8;\n      DAT_0024a8b0 = 0;\n      DAT_0024a8d4 = 0;\n      FUN_001e27c0((long)iVar7 + *(long *)PTR_DAT_00240520,\n                   *(long *)(PTR_DAT_00240520 + 8) + (long)iVar7,*plVar17 + lVar22,\n                   plVar17[1] + lVar22,0,_rl_screenwidth + DAT_0024a888,_rl_screenwidth + iVar30,0);\n      if ((((1 < local_70) && (DAT_0024a8cc != 0)) &&\n          (((rl_byte_oriented | DAT_0024a8d4) == 0 &&\n           ((iVar29 != _rl_last_c_pos && (DAT_0024a884 < _rl_last_c_pos)))))) &&\n         (iVar29 < DAT_0024a880)) {\n        _rl_last_c_pos = _rl_last_c_pos - DAT_0024a878;\n      }\n      if (iVar8 == 0) {\n        if (((DAT_0024a888 < DAT_0024a884) && (iVar20 == _rl_last_c_pos)) &&\n           ((iVar7 = iVar20 - DAT_0024a884, DAT_0024a8cc != 0 && (iVar7 < (int)_DAT_0024a87c)))) {\nLAB_001e6556:\n          _rl_clear_to_eol(_rl_screenwidth - iVar7);\n          uVar26 = iVar20 - iVar8;\n          if (iVar8 != 0) goto LAB_001e5e14;\n        }\n        uVar26 = iVar20 - DAT_0024a884;\n      }\n      else {\n        uVar26 = iVar20 - iVar8;\n        if ((((DAT_0024a888 < 0) && (iVar20 == _rl_last_c_pos)) && (DAT_0024a8cc != 0)) &&\n           (iVar7 = _rl_last_c_pos, iVar20 < (int)_DAT_0024a87c)) goto LAB_001e6556;\n      }\nLAB_001e5e14:\n      _DAT_0024a87c = _rl_screenwidth;\n      if ((int)uVar26 < (int)_rl_screenwidth) {\n        _DAT_0024a87c = uVar26;\n      }\n      FUN_001e1320(DAT_0024a8d0 - iVar8,*(long *)PTR_DAT_00240518 + lVar22,\n                   *(long *)(PTR_DAT_00240518 + 8) + lVar22);\n      DAT_0024a8c0 = iVar8;\n    }\n  }\nLAB_001e5e4c:\n  fflush(rl_outstream);\n  puVar19 = PTR_DAT_00240520;\n  rl_display_fixed = 0;\n  PTR_DAT_00240520 = PTR_DAT_00240518;\n  PTR_DAT_00240518 = puVar19;\n  if ((_rl_horizontal_scroll_mode == 0) || (DAT_0024a888 = 0, DAT_0024a8c0 == 0)) {\n    DAT_0024a888 = DAT_0024a884;\n  }\n  rl_readline_state = rl_readline_state & 0xfffffffffeffffff;\n  DAT_0024a8d8 = 0;\n  _rl_release_sigint();\nLAB_001e500b:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "geteuid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__uid_t geteuid(void)\n\n{\n  __uid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_geteuid_00237a68)();\n  return _Var1;\n}\n\n",
  "rl_vi_replace": "\nundefined8 rl_vi_replace(undefined8 param_1,undefined4 param_2)\n\n{\n  undefined *puVar1;\n  undefined8 *puVar2;\n  undefined **ppuVar3;\n  code **ppcVar4;\n  bool bVar5;\n  \n  DAT_0024a410 = 0;\n  if (DAT_0024a418 == (undefined *)0x0) {\n    puVar1 = (undefined *)rl_make_bare_keymap();\n    ppuVar3 = (undefined **)&DAT_0023b388;\n    puVar2 = (undefined8 *)(puVar1 + 8);\n    DAT_0024a418 = puVar1;\n    do {\n      if (*(char *)(ppuVar3 + -1) == '\\0') {\n        *puVar2 = *ppuVar3;\n      }\n      ppuVar3 = ppuVar3 + 2;\n      puVar2 = puVar2 + 2;\n    } while (ppuVar3 != &PTR_rl_insert_0023b588);\n    ppcVar4 = (code **)(puVar1 + 0x208);\n    do {\n      *ppcVar4 = rl_vi_overstrike;\n      ppcVar4 = ppcVar4 + 2;\n    } while (ppcVar4 != (code **)(puVar1 + 0x1018));\n    bVar5 = DAT_0023b400 == '\\0';\n    *(code **)(puVar1 + 0x7f8) = rl_vi_overstrike_delete;\n    *(code **)(puVar1 + 0x1b8) = rl_vi_movement_mode;\n    *(code **)(puVar1 + 0xd8) = rl_newline;\n    *(code **)(puVar1 + 0xa8) = rl_newline;\n    if ((bVar5) && ((code *)PTR_rl_rubout_0023b408 == rl_rubout)) {\n      *(code **)(puVar1 + 0x88) = rl_vi_overstrike_delete;\n    }\n    if ((DAT_0023b4d0 == '\\0') &&\n       ((code *)PTR_rl_unix_line_discard_0023b4d8 == rl_unix_line_discard)) {\n      *(code **)(puVar1 + 0x158) = FUN_001cf960;\n    }\n    if ((DAT_0023b4f0 == '\\0') &&\n       ((code *)PTR_rl_vi_unix_word_rubout_0023b4f8 == rl_vi_unix_word_rubout)) {\n      *(code **)(puVar1 + 0x178) = FUN_001cfcf0;\n    }\n    if ((DAT_0023b510 == '\\0') && ((code *)PTR_rl_yank_0023b518 == rl_yank)) {\n      *(code **)(puVar1 + 0x198) = FUN_001cf7e0;\n    }\n    puVar1[0x1000] = 0;\n    *(undefined8 *)(puVar1 + 0x1008) = 0;\n  }\n  DAT_0023b36c = 1;\n  DAT_0023b368 = rl_arg_sign;\n  _rl_vi_last_command = param_2;\n  rl_begin_undo_group();\n  _rl_keymap = &vi_insertion_keymap;\n  if (_rl_show_mode_in_prompt != 0) {\n    DAT_0024a3c8 = param_2;\n    _rl_reset_prompt();\n  }\n  DAT_0024a3c8 = 0x52;\n  _rl_keymap = DAT_0024a418;\n  if (_rl_enable_bracketed_paste == 0) {\n    return 0;\n  }\n  rl_bind_keyseq_if_unbound(&DAT_002129fe,FUN_001cfe00);\n  return 0;\n}\n\n",
  "rl_vi_char_search": "\nulong rl_vi_char_search(undefined4 param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  ulong uVar3;\n  long lVar4;\n  uint uVar5;\n  \n  if ((param_2 == 0x3b) || (param_2 == 0x2c)) {\n    if ((DAT_0024a350 != 0) && (DAT_0024a3e4 != 0)) {\n      DAT_0024a354 = DAT_0024a350;\n      if (param_2 != 0x3b) {\n        DAT_0024a354 = -DAT_0024a350;\n      }\n      uVar3 = _rl_char_search_internal(param_1,DAT_0024a354,&DAT_0024a3f0);\n      return uVar3;\n    }\n    uVar5 = 1;\n  }\n  else {\n    if (param_2 == 0x66) {\n      DAT_0024a354 = 2;\n      DAT_0024a350 = 2;\n    }\n    else if (param_2 < 0x67) {\n      if (param_2 == 0x46) {\n        DAT_0024a354 = 0xfffffffe;\n        DAT_0024a350 = -2;\n      }\n      else if (param_2 == 0x54) {\n        DAT_0024a354 = 0xffffffff;\n        DAT_0024a350 = -1;\n      }\n    }\n    else if (param_2 == 0x74) {\n      DAT_0024a354 = 1;\n      DAT_0024a350 = 1;\n    }\n    if (_rl_vi_redoing != 0) {\n      uVar3 = _rl_char_search_internal(param_1,DAT_0024a354,&DAT_0024a3f0,DAT_0024a3e4);\n      return uVar3;\n    }\n    if ((rl_readline_state & 0x80000) == 0) {\n      iVar2 = _rl_read_mbchar(&DAT_0024a3f0,0x10);\n      if (0 < iVar2) {\n        DAT_0024a3e4 = iVar2;\n        uVar3 = _rl_char_search_internal(param_1,DAT_0024a354,&DAT_0024a3f0,iVar2);\n        return uVar3;\n      }\n      uVar5 = 0xffffffff;\n    }\n    else {\n      lVar4 = _rl_callback_data_alloc(param_1);\n      uVar1 = DAT_0024a354;\n      _rl_callback_data = lVar4;\n      *(int *)(lVar4 + 8) = param_2;\n      *(undefined4 *)(lVar4 + 4) = uVar1;\n      rl_readline_state = rl_readline_state | 0x800000;\n      _rl_callback_func = FUN_001cfd10;\n      uVar5 = 0;\n    }\n  }\n  return (ulong)uVar5;\n}\n\n",
  "unset_sigwinch_handler": "\nvoid unset_sigwinch_handler(void)\n\n{\n  set_signal_handler(0x1c,DAT_00248540);\n  return;\n}\n\n",
  "tt_setnocanon": "\nundefined8 tt_setnocanon(long param_1)\n\n{\n  *(uint *)(param_1 + 0xc) = *(uint *)(param_1 + 0xc) & 0xfffffffd;\n  return 0;\n}\n\n",
  "FUN_00192f60": "\nundefined8 * FUN_00192f60(char *param_1,int param_2)\n\n{\n  char *__s2;\n  int iVar1;\n  size_t sVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  long lVar6;\n  long lVar7;\n  int iVar8;\n  int iVar9;\n  \n  if (param_2 == 0) {\n    iVar9 = 0;\n    if (DAT_002487a8 != (undefined8 *)0x0) {\n      sh_xfree(DAT_002487a8,\"bashline.c\",0x9fa);\n    }\n    DAT_002487a8 = (undefined8 *)0x0;\n    DAT_0024879c = (int)*param_1;\n    if (DAT_0024879c == 0x40) {\n      param_1 = param_1 + 1;\n    }\n    DAT_002487a0 = (uint)(DAT_0024879c == 0x40);\n    if ((hostname_list_initialized == 0) && (FUN_00192f00(), hostname_list_initialized == 0)) {\n      DAT_00248798 = 0;\n      DAT_002487a8 = (undefined8 *)0x0;\n      return (undefined8 *)0x0;\n    }\n    iVar8 = DAT_00248858;\n    if (*param_1 == '\\0') {\n      puVar4 = (undefined8 *)strvec_create(DAT_00248858 + 1);\n      lVar7 = DAT_00248860;\n      lVar3 = (long)DAT_00248858;\n      puVar5 = puVar4;\n      if (0 < DAT_00248858) {\n        lVar6 = 0;\n        do {\n          puVar4[lVar6] = *(undefined8 *)(lVar7 + lVar6 * 8);\n          lVar6 = lVar6 + 1;\n        } while (lVar3 != lVar6);\n        puVar5 = puVar4 + lVar3;\n      }\n      *puVar5 = 0;\n    }\n    else {\n      sVar2 = strlen(param_1);\n      if (iVar8 < 1) {\n        DAT_00248798 = 0;\n        DAT_002487a8 = (undefined8 *)0x0;\n        return (undefined8 *)0x0;\n      }\n      iVar8 = 0;\n      lVar7 = 0;\n      puVar4 = (undefined8 *)0x0;\n      do {\n        if (((int)sVar2 == 0) ||\n           ((__s2 = *(char **)(DAT_00248860 + lVar7 * 8), *param_1 == *__s2 &&\n            (iVar1 = strncmp(param_1,__s2,(long)(int)sVar2), iVar1 == 0)))) {\n          if (iVar9 + -1 <= iVar8) {\n            iVar9 = iVar9 + 0x10;\n            puVar4 = (undefined8 *)strvec_resize(puVar4,iVar9);\n          }\n          lVar3 = (long)iVar8;\n          iVar8 = iVar8 + 1;\n          puVar4[lVar3] = *(undefined8 *)(DAT_00248860 + lVar7 * 8);\n        }\n        lVar7 = lVar7 + 1;\n      } while ((int)lVar7 < DAT_00248858);\n      if (iVar8 != 0) {\n        puVar4[iVar8] = 0;\n      }\n    }\n    DAT_00248798 = 0;\n    DAT_002487a8 = puVar4;\n  }\n  puVar5 = DAT_002487a8;\n  if ((DAT_002487a8 != (undefined8 *)0x0) &&\n     (puVar5 = (undefined8 *)DAT_002487a8[DAT_00248798], puVar5 != (undefined8 *)0x0)) {\n    sVar2 = strlen((char *)puVar5);\n    puVar5 = (undefined8 *)sh_xmalloc(sVar2 + 2,\"bashline.c\",0xa0c);\n    iVar9 = DAT_00248798;\n    lVar7 = (long)DAT_00248798;\n    lVar3 = (long)(int)DAT_002487a0;\n    *(char *)puVar5 = (char)DAT_0024879c;\n    strcpy((char *)(lVar3 + (long)puVar5),(char *)DAT_002487a8[lVar7]);\n    DAT_00248798 = iVar9 + 1;\n  }\n  return puVar5;\n}\n\n",
  "fg_builtin": "\nundefined8 fg_builtin(long param_1)\n\n{\n  char *__s1;\n  long *plVar1;\n  int iVar2;\n  long *plVar3;\n  undefined8 uVar4;\n  \n  if ((((param_1 != 0) && (*(char ***)(param_1 + 8) != (char **)0x0)) &&\n      (__s1 = **(char ***)(param_1 + 8), *__s1 == '-')) &&\n     (iVar2 = strcmp(__s1,\"--help\"), iVar2 == 0)) {\n    builtin_help();\n    return 0x102;\n  }\n  if (job_control == 0) {\n    sh_nojobs(0);\n    return 1;\n  }\n  iVar2 = no_options(param_1);\n  plVar1 = loptend;\n  if (iVar2 != 0) {\n    return 0x102;\n  }\n  do {\n    plVar3 = plVar1;\n    if (plVar3 == (long *)0x0) goto LAB_001ab1e0;\n    plVar1 = (long *)*plVar3;\n  } while ((long *)*plVar3 != (long *)0x0);\n  if (**(char **)plVar3[1] == '&') {\n    uVar4 = FUN_001ab000(loptend,(*(char **)plVar3[1])[1] != '\\0');\n    return uVar4;\n  }\nLAB_001ab1e0:\n  uVar4 = FUN_001ab000(loptend,1);\n  return uVar4;\n}\n\n",
  "rl_tab_insert": "\nundefined8 rl_tab_insert(int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (0 < param_1) {\n    uVar1 = FUN_001ee210(param_1,9);\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "evalexp": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 evalexp(undefined8 param_1,uint param_2,undefined4 *param_3)\n\n{\n  long lVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined4 uVar10;\n  undefined4 uVar11;\n  undefined4 uVar12;\n  undefined4 uVar13;\n  undefined4 uVar14;\n  undefined4 uVar15;\n  undefined4 uVar16;\n  undefined4 uVar17;\n  undefined8 uVar18;\n  undefined8 uVar19;\n  undefined8 uVar20;\n  undefined8 uVar21;\n  undefined8 uVar22;\n  undefined8 uVar23;\n  undefined8 uVar24;\n  undefined8 uVar25;\n  undefined8 uVar26;\n  undefined8 uVar27;\n  undefined8 uVar28;\n  undefined8 uVar29;\n  undefined8 uVar30;\n  undefined8 uVar31;\n  undefined8 uVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  int iVar35;\n  undefined8 uVar36;\n  long in_FS_OFFSET;\n  \n  uVar34 = DAT_00242420;\n  uVar33 = uRam0000000000242418;\n  uVar32 = _DAT_00242410;\n  uVar31 = uRam0000000000242408;\n  uVar30 = _DAT_00242400;\n  uVar29 = uRam00000000002423f8;\n  uVar28 = _DAT_002423f0;\n  uVar27 = uRam00000000002423e8;\n  uVar26 = _DAT_002423e0;\n  uVar25 = uRam00000000002423d8;\n  uVar24 = _DAT_002423d0;\n  uVar23 = uRam00000000002423c8;\n  uVar22 = _DAT_002423c0;\n  uVar21 = uRam00000000002423b8;\n  uVar20 = _DAT_002423b0;\n  uVar19 = uRam00000000002423a8;\n  uVar18 = _DAT_002423a0;\n  uVar17 = uRam000000000024239c;\n  uVar16 = uRam0000000000242398;\n  uVar15 = uRam0000000000242394;\n  uVar14 = _DAT_00242390;\n  uVar13 = uRam000000000024238c;\n  uVar12 = uRam0000000000242388;\n  uVar11 = uRam0000000000242384;\n  uVar10 = _DAT_00242380;\n  uVar9 = uRam000000000024237c;\n  uVar8 = uRam0000000000242378;\n  uVar7 = uRam0000000000242374;\n  uVar6 = _DAT_00242370;\n  uVar5 = uRam000000000024236c;\n  uVar4 = uRam0000000000242368;\n  uVar3 = uRam0000000000242364;\n  uVar2 = _DAT_00242360;\n  DAT_00242350 = param_2 & 1;\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  DAT_00242428 = 0;\n  iVar35 = __sigsetjmp(&DAT_00242360,0);\n  if (iVar35 == 0) {\n    uVar36 = FUN_0015d040(param_1);\n    _DAT_00242360 = uVar2;\n    uRam0000000000242364 = uVar3;\n    uRam0000000000242368 = uVar4;\n    uRam000000000024236c = uVar5;\n    _DAT_00242370 = uVar6;\n    uRam0000000000242374 = uVar7;\n    uRam0000000000242378 = uVar8;\n    uRam000000000024237c = uVar9;\n    _DAT_00242380 = uVar10;\n    uRam0000000000242384 = uVar11;\n    uRam0000000000242388 = uVar12;\n    uRam000000000024238c = uVar13;\n    _DAT_00242390 = uVar14;\n    uRam0000000000242394 = uVar15;\n    uRam0000000000242398 = uVar16;\n    uRam000000000024239c = uVar17;\n    _DAT_002423a0 = uVar18;\n    uRam00000000002423a8 = uVar19;\n    _DAT_002423b0 = uVar20;\n    uRam00000000002423b8 = uVar21;\n    _DAT_002423c0 = uVar22;\n    uRam00000000002423c8 = uVar23;\n    _DAT_002423d0 = uVar24;\n    uRam00000000002423d8 = uVar25;\n    _DAT_002423e0 = uVar26;\n    uRam00000000002423e8 = uVar27;\n    _DAT_002423f0 = uVar28;\n    uRam00000000002423f8 = uVar29;\n    _DAT_00242400 = uVar30;\n    uRam0000000000242408 = uVar31;\n    _DAT_00242410 = uVar32;\n    uRam0000000000242418 = uVar33;\n    DAT_00242420 = uVar34;\n    if (param_3 != (undefined4 *)0x0) {\n      *param_3 = 1;\n    }\n  }\n  else {\n    if (DAT_00242438 != 0) {\n      sh_xfree(DAT_00242438,\"expr.c\",0x1a9);\n    }\n    if (DAT_00242460 != 0) {\n      sh_xfree(DAT_00242460,\"expr.c\",0x1aa);\n    }\n    DAT_00242460 = 0;\n    DAT_00242438 = 0;\n    FUN_0015bc10();\n    DAT_00242344 = 0;\n    uVar36 = 0;\n    _DAT_00242360 = uVar2;\n    uRam0000000000242364 = uVar3;\n    uRam0000000000242368 = uVar4;\n    uRam000000000024236c = uVar5;\n    _DAT_00242370 = uVar6;\n    uRam0000000000242374 = uVar7;\n    uRam0000000000242378 = uVar8;\n    uRam000000000024237c = uVar9;\n    _DAT_00242380 = uVar10;\n    uRam0000000000242384 = uVar11;\n    uRam0000000000242388 = uVar12;\n    uRam000000000024238c = uVar13;\n    _DAT_00242390 = uVar14;\n    uRam0000000000242394 = uVar15;\n    uRam0000000000242398 = uVar16;\n    uRam000000000024239c = uVar17;\n    _DAT_002423a0 = uVar18;\n    uRam00000000002423a8 = uVar19;\n    _DAT_002423b0 = uVar20;\n    uRam00000000002423b8 = uVar21;\n    _DAT_002423c0 = uVar22;\n    uRam00000000002423c8 = uVar23;\n    _DAT_002423d0 = uVar24;\n    uRam00000000002423d8 = uVar25;\n    _DAT_002423e0 = uVar26;\n    uRam00000000002423e8 = uVar27;\n    _DAT_002423f0 = uVar28;\n    uRam00000000002423f8 = uVar29;\n    _DAT_00242400 = uVar30;\n    uRam0000000000242408 = uVar31;\n    _DAT_00242410 = uVar32;\n    uRam0000000000242418 = uVar33;\n    DAT_00242420 = uVar34;\n    if (param_3 != (undefined4 *)0x0) {\n      *param_3 = 0;\n    }\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar36;\n}\n\n",
  "sv_childmax": "\nvoid sv_childmax(void)\n\n{\n  long lVar1;\n  char *__nptr;\n  ulong uVar2;\n  \n  lVar1 = find_variable();\n  if (lVar1 != 0) {\n    __nptr = (char *)get_variable_value(lVar1);\n    if ((__nptr != (char *)0x0) && (*__nptr != '\\0')) {\n      uVar2 = strtol(__nptr,(char **)0x0,10);\n      set_maxchild(uVar2 & 0xffffffff);\n      return;\n    }\n  }\n  set_maxchild(0);\n  return;\n}\n\n",
  "FUN_001cbc80": "\nbool FUN_001cbc80(int param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  __fd_mask *p_Var4;\n  long in_FS_OFFSET;\n  timeval local_148;\n  ulong local_138 [16];\n  ulong local_b8 [17];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  p_Var4 = (__fd_mask *)local_138;\n  for (lVar2 = 0x10; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *p_Var4 = 0;\n    p_Var4 = p_Var4 + 1;\n  }\n  p_Var4 = (__fd_mask *)local_b8;\n  for (lVar2 = 0x10; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *p_Var4 = 0;\n    p_Var4 = p_Var4 + 1;\n  }\n  lVar2 = __fdelt_chk((long)param_1);\n  uVar3 = 1L << ((byte)param_1 & 0x3f);\n  local_138[lVar2] = local_138[lVar2] | uVar3;\n  lVar2 = __fdelt_chk((long)param_1);\n  local_b8[lVar2] = local_b8[lVar2] | uVar3;\n  local_148.tv_sec = 0;\n  local_148.tv_usec = 0;\n  iVar1 = select(param_1 + 1,(fd_set *)local_138,(fd_set *)0x0,(fd_set *)local_b8,&local_148);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0 < iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "__ctype_b_loc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n  ushort **ppuVar1;\n  \n  ppuVar1 = (ushort **)(*(code *)PTR___ctype_b_loc_00237eb8)();\n  return ppuVar1;\n}\n\n",
  "ansicstr": "\nundefined8 ansicstr(char *param_1)\n\n{\n  undefined8 uVar1;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    uVar1 = FUN_001c9490();\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "rl_maybe_save_line": "\nundefined8 rl_maybe_save_line(void)\n\n{\n  if (_rl_saved_line_for_history != 0) {\n    return 0;\n  }\n  FUN_001f0770();\n  return 0;\n}\n\n",
  "sigaddset": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigaddset(sigset_t *__set,int __signo)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigaddset_00237e90)();\n  return iVar1;\n}\n\n",
  "find_procsub_child": "\nulong find_procsub_child(int param_1)\n\n{\n  ulong uVar1;\n  \n  if ((DAT_00247834 != 0) && (0 < DAT_00247830)) {\n    uVar1 = 0;\n    do {\n      if (*(int *)(DAT_00247838 + uVar1 * 4) == param_1) {\n        return uVar1 & 0xffffffff;\n      }\n      uVar1 = uVar1 + 1;\n    } while (uVar1 != (long)DAT_00247830);\n  }\n  return 0xffffffff;\n}\n\n",
  "push_context": "\nvoid push_context(undefined8 param_1,int param_2,undefined8 param_3)\n\n{\n  if (param_2 == 0) {\n    push_dollar_vars();\n  }\n  variable_context = variable_context + 1;\n  push_var_context(param_1,4,param_3);\n  return;\n}\n\n",
  "should_optimize_fork": "\nbool should_optimize_fork(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  if (running_trap != 0) {\n    return false;\n  }\n  if (((((*param_1 == 4) && (iVar1 = signal_is_trapped(0), iVar1 == 0)) &&\n       (iVar1 = signal_is_trapped(0x42), iVar1 == 0)) && (iVar1 = any_signals_trapped(), iVar1 < 0))\n     && ((param_2 != 0 ||\n         ((*(long *)(param_1 + 4) == 0 && (*(long *)(*(long *)(param_1 + 6) + 0x10) == 0)))))) {\n    return (*(byte *)(param_1 + 1) & 0x84) == 0;\n  }\n  return false;\n}\n\n",
  "FUN_001667f0": "\nvoid FUN_001667f0_noreturn_(undefined4 param_1)\n\n{\n  set_pipestatus_from_exit(last_command_exit_value);\n  DAT_00247848 = 0;\n  if (expanding_redir != 0) {\n    undo_partial_redirects();\n  }\n  expanding_redir = 0;\n  assigning_in_environment = 0;\n  if (parse_and_execute_level == 0) {\n    top_level_cleanup();\n  }\n                    /* WARNING: Subroutine does not return */\n  jump_to_top_level(param_1);\n}\n\n",
  "__asprintf_chk": "\nvoid __asprintf_chk(void)\n\n{\n  (*(code *)PTR___asprintf_chk_00237af8)();\n  return;\n}\n\n",
  "trap_handler": "\nvoid trap_handler(int param_1)\n\n{\n  int iVar1;\n  __pid_t __pid;\n  int *piVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  sigset_t sStack_b8;\n  long local_30;\n  \n  lVar3 = (long)param_1;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((*(byte *)(&DAT_00247e40 + lVar3) & 1) == 0) {\n    if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n      internal_debug(\"trap_handler: signal %d: signal not trapped\",param_1);\n      return;\n    }\n    goto LAB_00181943;\n  }\n  if ((subshell_environment._1_1_ & 1) == 0) {\n    if ((0x40 < param_1) || ((ulong)(&trap_list)[lVar3] < 2)) goto LAB_00181880;\n    piVar2 = __errno_location();\n    DAT_00247e28 = 1;\n    iVar1 = *piVar2;\n    trapped_signal_received = param_1;\n    *(int *)(pending_traps + lVar3 * 4) = *(int *)(pending_traps + lVar3 * 4) + 1;\n    if ((this_shell_builtin != (undefined *)0x0) &&\n       (this_shell_builtin == PTR_wait_builtin_00237f70)) {\n      wait_signal_received = param_1;\n      if ((waiting_for_child != 0) && (wait_intr_flag != 0)) {\n                    /* WARNING: Subroutine does not return */\n        __longjmp_chk(wait_intr_buf,1);\n      }\n    }\n    if ((rl_readline_state._1_1_ & 0x80) != 0) {\n      bashline_set_event_hook();\n    }\n    *piVar2 = iVar1;\n  }\n  else {\n    if ((&trap_list)[lVar3] == 1) {\nLAB_00181880:\n      if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        programming_error(\"trap_handler: bad signal %d\",param_1);\n      }\n      goto LAB_00181943;\n    }\n    if (*(code **)(original_signals + lVar3 * 8) == initialize_traps) {\n      *(undefined8 *)(original_signals + lVar3 * 8) = 0;\n    }\n    set_signal_handler(param_1);\n    FUN_001815b0(param_1);\n    (&DAT_00247e40)[lVar3] = (&DAT_00247e40)[lVar3] & 0xfffffffe;\n    sigemptyset(&sStack_b8);\n    sigprocmask(2,(sigset_t *)0x0,&sStack_b8);\n    sigdelset(&sStack_b8,param_1);\n    sigprocmask(2,&sStack_b8,(sigset_t *)0x0);\n    __pid = getpid();\n    kill(__pid,param_1);\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\nLAB_00181943:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "isnetconn": "\nbool isnetconn(int param_1)\n\n{\n  bool bVar1;\n  int iVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  socklen_t local_2c;\n  sockaddr local_28;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2c = 0x10;\n  iVar2 = getpeername(param_1,&local_28,&local_2c);\n  bVar1 = true;\n  if (iVar2 < 0) {\n    piVar3 = __errno_location();\n    iVar2 = *piVar3;\n    bVar1 = iVar2 != 9 && ((iVar2 != 0x58 && iVar2 != 0x6b) && iVar2 != 0x16);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_read_mbchar": "\nulong _rl_read_mbchar(char *param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  size_t sVar3;\n  ulong __n;\n  ulong uVar4;\n  long in_FS_OFFSET;\n  wchar_t local_54;\n  mbstate_t local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50.__count = 0;\n  local_50.__value = (_union_27)0x0;\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  if (param_2 < 1) {\n    uVar4 = 0;\n  }\n  else {\n    __n = 0;\n    do {\n      iVar1 = (int)__n;\n      uVar4 = __n & 0xffffffff;\n      local_50 = local_48;\n      if (__n == 0) {\n        iVar2 = _rl_bracketed_read_key();\n      }\n      else {\n        iVar2 = rl_read_key();\n      }\n      if (iVar2 < 0) break;\n      param_1[__n] = (char)iVar2;\n      __n = __n + 1;\n      uVar4 = (ulong)(iVar1 + 1);\n      sVar3 = mbrtowc(&local_54,param_1,__n,&local_50);\n      if (sVar3 == 0xffffffffffffffff) break;\n      if (sVar3 != 0xfffffffffffffffe) {\n        if (sVar3 == 0) {\n          *param_1 = '\\0';\n          uVar4 = 1;\n        }\n        break;\n      }\n      local_50 = local_48;\n    } while ((long)param_2 != __n);\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n",
  "FUN_00167b60": "\nchar * FUN_00167b60(char *param_1,char *param_2,int param_3)\n\n{\n  wchar_t wVar1;\n  int iVar2;\n  size_t sVar3;\n  char *pcVar4;\n  long lVar5;\n  ulong uVar6;\n  wchar_t *__s;\n  char *__dest;\n  undefined8 uVar7;\n  wchar_t *pwVar8;\n  wchar_t *pwVar9;\n  ulong uVar10;\n  long in_FS_OFFSET;\n  bool bVar11;\n  wchar_t *local_60;\n  wchar_t *local_58;\n  undefined8 local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (char *)0x0) {\n    pcVar4 = (char *)0x0;\n    goto LAB_00167d63;\n  }\n  if (((*param_1 == '\\0') || (param_2 == (char *)0x0)) || (*param_2 == '\\0')) {\n    sVar3 = strlen(param_1);\n    uVar7 = 0x14a7;\n  }\n  else {\n    sVar3 = __ctype_get_mb_cur_max();\n    if (1 < sVar3) {\n      lVar5 = xdupmbstowcs(&local_50,0,param_2);\n      if (lVar5 == -1) {\n        pcVar4 = (char *)FUN_00166850(param_1,param_2,param_3);\n        if (param_1 == pcVar4) {\n          sVar3 = strlen(pcVar4);\n          uVar7 = 0x14b8;\nLAB_00167dee:\n          __dest = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",uVar7);\n          pcVar4 = strcpy(__dest,pcVar4);\n        }\n      }\n      else {\n        uVar6 = xdupmbstowcs(&local_58,0,param_1);\n        uVar7 = local_50;\n        __s = local_58;\n        if (uVar6 == 0xffffffffffffffff) {\n          sh_xfree(local_50,\"subst.c\",0x14be);\n          pcVar4 = (char *)FUN_00166850(param_1,param_2,param_3);\n          if (param_1 == pcVar4) {\n            sVar3 = strlen(pcVar4);\n            uVar7 = 0x14c0;\n            goto LAB_00167dee;\n          }\n        }\n        else {\n          if (param_3 == 3) {\n            pwVar9 = local_58;\n            uVar10 = 0;\n            do {\n              iVar2 = wcsmatch(uVar7,pwVar9,(ulong)(extended_glob != 0) << 5);\n              if (iVar2 != 1) {\n                wVar1 = *pwVar9;\n                *pwVar9 = L'\\0';\n                __s = wcsdup(__s);\n                *pwVar9 = wVar1;\n                break;\n              }\n              pwVar9 = pwVar9 + 1;\n              bVar11 = uVar6 != uVar10;\n              uVar10 = uVar10 + 1;\n            } while (bVar11);\nLAB_00167cd8:\n            local_60 = __s;\n            if (__s != local_58) {\n              sh_xfree(local_58,\"subst.c\",0x14cc);\n              sh_xfree(local_50,\"subst.c\",0x14cd);\n              sVar3 = strlen(param_1);\n              pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",0x14d0);\n              local_48.__count = 0;\n              local_48.__value = (_union_27)0x0;\n              sVar3 = wcsrtombs(pcVar4,&local_60,sVar3,&local_48);\n              pcVar4[sVar3] = '\\0';\n              sh_xfree(__s,\"subst.c\",0x14d4);\n              goto LAB_00167d63;\n            }\n          }\n          else {\n            iVar2 = (int)uVar6;\n            local_60 = local_58;\n            if (param_3 != 4) {\n              if (param_3 == 2) {\n                pwVar9 = local_58;\n                uVar10 = 0;\n                do {\n                  wVar1 = *pwVar9;\n                  *pwVar9 = L'\\0';\n                  iVar2 = wcsmatch(uVar7,__s,(ulong)(extended_glob != 0) << 5);\n                  *pwVar9 = wVar1;\n                  if (iVar2 != 1) {\n                    __s = wcsdup(pwVar9);\n                    break;\n                  }\n                  pwVar9 = pwVar9 + 1;\n                  bVar11 = uVar6 != uVar10;\n                  uVar10 = uVar10 + 1;\n                } while (bVar11);\n              }\n              else {\n                if (iVar2 < 0) goto LAB_00167e10;\n                pwVar9 = local_58 + iVar2;\n                pwVar8 = local_58 + (long)iVar2 + (-1 - (uVar6 & 0xffffffff));\n                do {\n                  wVar1 = *pwVar9;\n                  *pwVar9 = L'\\0';\n                  iVar2 = wcsmatch(uVar7,__s,(ulong)(extended_glob != 0) << 5);\n                  *pwVar9 = wVar1;\n                  if (iVar2 != 1) {\n                    __s = wcsdup(pwVar9);\n                    break;\n                  }\n                  pwVar9 = pwVar9 + -1;\n                } while (pwVar9 != pwVar8);\n              }\n              goto LAB_00167cd8;\n            }\n            if (-1 < iVar2) {\n              pwVar9 = local_58 + iVar2;\n              pwVar8 = local_58 + (long)iVar2 + (-1 - (uVar6 & 0xffffffff));\n              do {\n                iVar2 = wcsmatch(uVar7,pwVar9,(ulong)(extended_glob != 0) << 5);\n                if (iVar2 != 1) {\n                  wVar1 = *pwVar9;\n                  *pwVar9 = L'\\0';\n                  __s = wcsdup(__s);\n                  *pwVar9 = wVar1;\n                  break;\n                }\n                pwVar9 = pwVar9 + -1;\n              } while (pwVar9 != pwVar8);\n              goto LAB_00167cd8;\n            }\n          }\nLAB_00167e10:\n          sh_xfree(local_60,\"subst.c\",0x14c7);\n          sh_xfree(local_50,\"subst.c\",0x14c8);\n          sVar3 = strlen(param_1);\n          pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",0x14c9);\n          pcVar4 = strcpy(pcVar4,param_1);\n        }\n      }\nLAB_00167d63:\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return pcVar4;\n      }\n      goto LAB_00168012;\n    }\n    pcVar4 = (char *)FUN_00166850(param_1,param_2,param_3);\n    if (param_1 != pcVar4) goto LAB_00167d63;\n    sVar3 = strlen(param_1);\n    uVar7 = 0x14db;\n  }\n  pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",uVar7);\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    pcVar4 = strcpy(pcVar4,param_1);\n    return pcVar4;\n  }\nLAB_00168012:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_begin_undo_group": "\nundefined8 rl_begin_undo_group(void)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)xmalloc(0x20);\n  puVar1[1] = 0;\n  *puVar1 = rl_undo_list;\n  puVar1[2] = 0;\n  *(undefined4 *)(puVar1 + 3) = 2;\n  rl_undo_list = puVar1;\n  _rl_undo_group_level = _rl_undo_group_level + 1;\n  return 0;\n}\n\n",
  "FUN_00195af0": "\nvoid FUN_00195af0(char *param_1,undefined4 param_2,char *param_3)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *__dest;\n  \n  if ((((param_3 != (char *)0x0) && (DAT_00248830 != (char *)0x0)) && (*param_3 == '\\0')) &&\n     (*param_1 == *DAT_00248830)) {\n    iVar1 = strcmp(param_1,DAT_00248830);\n    if (iVar1 == 0) {\n      sVar2 = strlen(param_1);\n      __dest = (char *)sh_xmalloc(sVar2 + 1,\"bashline.c\",0xf6a);\n      strcpy(__dest,param_1);\n      return;\n    }\n  }\n  FUN_00195700(param_1,param_2,param_3);\n  return;\n}\n\n",
  "copy_word_list": "\nundefined8 * copy_word_list(long **param_1)\n\n{\n  long *plVar1;\n  undefined8 *puVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  \n  if (param_1 == (long **)0x0) {\n    return (undefined8 *)0x0;\n  }\n  puVar4 = (undefined8 *)0x0;\n  puVar5 = (undefined8 *)0x0;\n  do {\n    while( true ) {\n      plVar1 = param_1[1];\n      if (puVar4 == (undefined8 *)0x0) break;\n      lVar3 = make_bare_word(*plVar1);\n      *(undefined4 *)(lVar3 + 8) = *(undefined4 *)(plVar1 + 1);\n      puVar2 = (undefined8 *)make_word_list(lVar3,0);\n      *puVar5 = puVar2;\n      param_1 = (long **)*param_1;\n      puVar5 = puVar2;\n      if (param_1 == (long **)0x0) {\n        return puVar4;\n      }\n    }\n    lVar3 = make_bare_word(*plVar1);\n    *(undefined4 *)(lVar3 + 8) = *(undefined4 *)(plVar1 + 1);\n    puVar4 = (undefined8 *)make_word_list(lVar3,0);\n    param_1 = (long **)*param_1;\n    puVar5 = puVar4;\n  } while (param_1 != (long **)0x0);\n  return puVar4;\n}\n\n",
  "FUN_001d74a0": "\nundefined8 FUN_001d74a0(long **param_1,int param_2)\n\n{\n  char *__s1;\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  size_t sVar5;\n  char *pcVar6;\n  char **ppcVar7;\n  char *pcVar8;\n  char **ppcVar9;\n  char **ppcVar10;\n  int iVar11;\n  long in_FS_OFFSET;\n  char local_41;\n  long local_40;\n  \n  ppcVar9 = (char **)*param_1;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar4 = 0;\n  if (ppcVar9 == (char **)0x0) {\n    uVar3 = 0;\n  }\n  else {\n    ppcVar7 = ppcVar9;\n    if (rl_ignore_completion_duplicates != 0) {\n      pcVar8 = *ppcVar9;\n      if (pcVar8 != (char *)0x0) {\n        do {\n          iVar11 = (int)lVar4;\n          lVar4 = lVar4 + 1;\n        } while (ppcVar9[lVar4] != (char *)0x0);\n        if (rl_sort_completion_matches != 0) {\n          qsort(ppcVar9 + 1,(long)iVar11,8,_rl_qsort_string_compare);\n          pcVar8 = *ppcVar9;\n        }\n      }\n      sVar5 = strlen(pcVar8);\n      pcVar6 = (char *)xmalloc(sVar5 + 1);\n      pcVar6 = strcpy(pcVar6,pcVar8);\n      pcVar8 = ppcVar9[1];\n      if (pcVar8 == (char *)0x0) {\n        lVar4 = 0x18;\n      }\n      else {\n        iVar11 = 0;\n        do {\n          while( true ) {\n            __s1 = *ppcVar7;\n            iVar2 = strcmp(__s1,pcVar8);\n            if (iVar2 != 0) break;\n            xfree(__s1);\n            *ppcVar7 = &local_41;\n            pcVar8 = ppcVar7[2];\n            ppcVar7 = ppcVar7 + 1;\n            if (pcVar8 == (char *)0x0) goto LAB_001d7658;\n          }\n          pcVar8 = ppcVar7[2];\n          ppcVar7 = ppcVar7 + 1;\n          iVar11 = iVar11 + 1;\n        } while (pcVar8 != (char *)0x0);\nLAB_001d7658:\n        lVar4 = (long)(iVar11 + 3) << 3;\n      }\n      ppcVar7 = (char **)xmalloc(lVar4);\n      pcVar8 = ppcVar9[1];\n      if (pcVar8 == (char *)0x0) {\n        ppcVar7[1] = (char *)0x0;\n        if (*ppcVar9 != &local_41) {\n          xfree();\n        }\n        *ppcVar7 = pcVar6;\n      }\n      else {\n        ppcVar10 = ppcVar9 + 2;\n        iVar11 = 1;\n        do {\n          if (pcVar8 != &local_41) {\n            lVar4 = (long)iVar11;\n            iVar11 = iVar11 + 1;\n            ppcVar7[lVar4] = pcVar8;\n          }\n          pcVar8 = *ppcVar10;\n          ppcVar10 = ppcVar10 + 1;\n        } while (pcVar8 != (char *)0x0);\n        ppcVar7[iVar11] = (char *)0x0;\n        if (*ppcVar9 != &local_41) {\n          xfree();\n        }\n        *ppcVar7 = pcVar6;\n        if (iVar11 == 2) {\n          pcVar8 = ppcVar7[1];\n          iVar11 = strcmp(pcVar6,pcVar8);\n          if (iVar11 == 0) {\n            xfree(pcVar8);\n            ppcVar7[1] = (char *)0x0;\n          }\n        }\n      }\n      xfree(ppcVar9);\n    }\n    if ((rl_ignore_some_completions_function != (code *)0x0) && (param_2 != 0)) {\n      if (ppcVar7[1] == (char *)0x0) {\n        iVar11 = 1;\n      }\n      else {\n        lVar4 = 2;\n        do {\n          iVar11 = (int)lVar4;\n          ppcVar9 = ppcVar7 + lVar4;\n          lVar4 = lVar4 + 1;\n        } while (*ppcVar9 != (char *)0x0);\n      }\n      (*rl_ignore_some_completions_function)(ppcVar7);\n      pcVar8 = *ppcVar7;\n      if (pcVar8 == (char *)0x0) {\n        free(ppcVar7);\n        *param_1 = (long *)0x0;\n        uVar3 = 0;\n        goto LAB_001d7589;\n      }\n      ppcVar9 = ppcVar7 + 2;\n      iVar2 = 1;\n      if (ppcVar7[1] != (char *)0x0) {\n        do {\n          iVar1 = iVar2;\n          pcVar6 = *ppcVar9;\n          ppcVar9 = ppcVar9 + 1;\n          iVar2 = iVar1 + 1;\n        } while (pcVar6 != (char *)0x0);\n        if (iVar1 + 1 < iVar11) {\n          if (iVar1 == 1) {\n            *ppcVar7 = ppcVar7[1];\n            ppcVar7[1] = (char *)0x0;\n          }\n          else {\n            FUN_001d7060(ppcVar7,iVar1,pcVar8);\n          }\n          free(pcVar8);\n        }\n      }\n    }\n    *param_1 = (long *)ppcVar7;\n    uVar3 = 1;\n  }\nLAB_001d7589:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
  "make_if_command": "\nvoid make_if_command(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined4 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x20,\"make_cmd.c\",0x186);\n  *(undefined8 *)(puVar1 + 2) = param_1;\n  *(undefined8 *)(puVar1 + 4) = param_2;\n  *(undefined8 *)(puVar1 + 6) = param_3;\n  *puVar1 = 0;\n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar2[3] = puVar1;\n  *puVar2 = 3;\n  *puVar1 = 0;\n  puVar2[2] = 0;\n  return;\n}\n\n",
  "find_alias": "\nundefined8 find_alias(undefined8 param_1)\n\n{\n  long lVar1;\n  \n  if (aliases == 0) {\n    return 0;\n  }\n  lVar1 = hash_search(param_1,aliases,0);\n  if (lVar1 != 0) {\n    return *(undefined8 *)(lVar1 + 0x10);\n  }\n  return 0;\n}\n\n",
  "stop_pipeline": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nulong stop_pipeline(int param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  uint uVar2;\n  uint uVar3;\n  long *plVar4;\n  uint uVar5;\n  __pid_t _Var6;\n  __pid_t _Var7;\n  undefined8 *puVar8;\n  undefined8 *puVar9;\n  undefined8 *puVar10;\n  undefined8 *puVar11;\n  char *pcVar12;\n  size_t sVar13;\n  char *__dest;\n  long lVar14;\n  long *plVar15;\n  int *piVar16;\n  int iVar17;\n  undefined8 *puVar18;\n  long *plVar19;\n  ulong uVar20;\n  int iVar21;\n  uint uVar22;\n  uint uVar23;\n  ulong uVar24;\n  int iVar25;\n  uint uVar26;\n  ulong uVar27;\n  long in_FS_OFFSET;\n  bool bVar28;\n  sigset_t local_248;\n  sigset_t local_1c8;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_248);\n  sigaddset(&local_248,0x11);\n  sigemptyset(&local_1c8);\n  sigprocmask(0,&local_248,&local_1c8);\n  sh_closepipe(&pgrp_pipe);\n  if ((DAT_0023877c == 0) || ((DAT_00247660 == 0 && (FUN_001626a0(), DAT_0023877c == 0)))) {\n    DAT_0023877c = 8;\n    jobs = (long *)sh_xmalloc(0x40,\"jobs.c\",0x23d);\n    uVar5 = DAT_0023877c;\n    if (0 < (int)DAT_0023877c) {\n      uVar20 = (ulong)(int)DAT_0023877c;\n      memset(jobs,0,uVar20 * 8);\n      uVar24 = (ulong)interactive;\n      _DAT_00238780 = 0;\n      DAT_00238788 = 0;\n      if (interactive == 0) goto LAB_00165c60;\n      goto LAB_001659ec;\n    }\n    uVar24 = (ulong)interactive;\n    _DAT_00238780 = 0;\n    DAT_00238788 = 0;\n    if (interactive == 0) {\n      if (interactive_shell != 0) {\nLAB_00165a03:\n        if (subshell_environment != 0) goto LAB_00165a0f;\n      }\n      goto LAB_00165a21;\n    }\n    if (DAT_0023877c != 0) {\n      uVar20 = (ulong)(int)DAT_0023877c;\n      goto LAB_001659ec;\n    }\n    uVar24 = 0;\n    if (interactive_shell != 0) goto LAB_00165a03;\nLAB_00165e7f:\n    DAT_0023877c = uVar5 + 8;\n    lVar14 = (long)(int)DAT_0023877c;\n    jobs = (long *)sh_xrealloc(jobs,lVar14 * 8,\"jobs.c\",0x26e);\n    if ((int)uVar5 < (int)DAT_0023877c) {\n      uVar24 = (ulong)uVar5;\n      memset(jobs + lVar14 + -8,0,(ulong)((DAT_0023877c - 1) - uVar5) * 8 + 8);\n    }\n    else {\n      uVar24 = (ulong)uVar5;\n    }\n  }\n  else {\n    uVar20 = (ulong)(int)DAT_0023877c;\n    uVar5 = DAT_0023877c;\n    if (interactive == 0) {\n      uVar22 = (DAT_00238780 + 1) - (uint)(DAT_00238780 == 0);\n      uVar24 = (ulong)uVar22;\n      if ((int)uVar22 < (int)DAT_0023877c) {\nLAB_00165c60:\n        plVar15 = jobs + (int)uVar24;\n        do {\n          if (*plVar15 == 0) break;\n          uVar22 = (int)uVar24 + 1;\n          uVar24 = (ulong)uVar22;\n          plVar15 = plVar15 + 1;\n        } while (uVar22 != uVar5);\n      }\nLAB_001659f7:\n      if (interactive_shell != 0) goto LAB_00165a03;\nLAB_00165a0f:\n      if ((uint)uVar24 == uVar5) {\n        if ((int)uVar5 < 0x1000) goto LAB_00165a21;\n        if (DAT_00247660 != 0) goto LAB_00165e7f;\n        FUN_00165350(0);\n        if ((DAT_0023877c != 0) && (DAT_00247660 == 0)) {\n          FUN_001626a0();\n        }\n        uVar5 = DAT_00238788 + 0xe;\n        if (-1 < (int)(DAT_00238788 + 7)) {\n          uVar5 = DAT_00238788 + 7;\n        }\n        uVar22 = uVar5 & 0xfffffff8;\n        if (((DAT_00238788 & 7) == 0) || (4 < (int)DAT_00238788 % 8)) {\n          uVar22 = (uVar5 & 0xfffffff8) + 8;\n        }\n        sigemptyset(&local_148);\n        sigaddset(&local_148,0x11);\n        sigemptyset(&local_c8);\n        sigprocmask(0,&local_148,&local_c8);\n        plVar15 = jobs;\n        uVar5 = uVar22;\n        if (DAT_0023877c != uVar22) {\n          plVar15 = (long *)sh_xmalloc((long)(int)uVar22 << 3,\"jobs.c\",0x518);\n          uVar5 = DAT_0023877c;\n        }\n        plVar4 = jobs;\n        uVar3 = DAT_00238794;\n        uVar2 = DAT_00238790;\n        _DAT_0023878c = 0;\n        _DAT_0023876c = 0;\n        if ((int)uVar5 < 1) {\n          uVar20 = 0;\n          uVar26 = 0xffffffff;\n          uVar23 = 0xffffffff;\n          uVar5 = 0;\n        }\n        else {\n          uVar20 = 0;\n          lVar14 = 0;\n          uVar27 = 0xffffffff;\n          uVar24 = 0xffffffff;\n          do {\n            lVar1 = plVar4[lVar14];\n            if (lVar1 != 0) {\n              iVar25 = (int)uVar20 + 1;\n              plVar15[uVar20] = lVar1;\n              if (uVar2 == (uint)lVar14) {\n                uVar24 = uVar20 & 0xffffffff;\n              }\n              if (uVar3 == (uint)lVar14) {\n                uVar27 = uVar20 & 0xffffffff;\n              }\n              uVar20 = (ulong)iVar25;\n              if (*(int *)(lVar1 + 0x14) == 4) {\n                _DAT_0023878c = _DAT_0023878c + 1;\n                iVar17 = 0;\n                plVar19 = *(long **)(lVar1 + 8);\n                do {\n                  plVar19 = (long *)*plVar19;\n                  iVar17 = iVar17 + 1;\n                } while (*(long **)(lVar1 + 8) != plVar19);\n                _DAT_0023876c = _DAT_0023876c + iVar17;\n                uVar20 = (ulong)iVar25;\n              }\n            }\n            uVar23 = (uint)uVar24;\n            uVar26 = (uint)uVar27;\n            lVar14 = lVar14 + 1;\n          } while ((int)uVar5 != lVar14);\n          iVar25 = 1;\n          if (0 < (int)uVar20) {\n            iVar25 = (int)uVar20;\n          }\n          uVar5 = iVar25 - 1;\n        }\n        _DAT_00238780 = (ulong)uVar5;\n        DAT_00238788 = (uint)uVar20;\n        DAT_0023877c = uVar22;\n        if ((int)DAT_00238788 < (int)uVar22) {\n          memset(plVar15 + uVar20,0,(ulong)((uVar22 - 1) - DAT_00238788) * 8 + 8);\n        }\n        if (plVar15 != plVar4) {\n          sh_xfree(plVar4,\"jobs.c\",0x53c);\n          jobs = plVar15;\n        }\n        uVar5 = DAT_00238794;\n        if (uVar23 == 0xffffffff) {\n          if (uVar26 != 0xffffffff) goto LAB_001661bd;\n          if (DAT_00238790 != 0xffffffff) goto joined_r0x00166266;\nLAB_001661e1:\n          FUN_0015e940();\n        }\n        else {\n          DAT_00238790 = uVar23;\n          if (uVar26 != 0xffffffff) {\nLAB_001661bd:\n            DAT_00238794 = uVar26;\n            uVar5 = DAT_00238790;\n          }\njoined_r0x00166266:\n          if (uVar5 == 0xffffffff) goto LAB_001661e1;\n          uVar5 = DAT_00238790;\n          if ((int)DAT_00238790 < (int)DAT_00238794) {\n            uVar5 = DAT_00238794;\n          }\n          if (DAT_00238780 < (int)uVar5) goto LAB_001661e1;\n        }\n        sigprocmask(2,&local_c8,(sigset_t *)0x0);\n        if ((DAT_00238780 != 0) || (uVar5 = 0, *jobs != 0)) {\n          uVar5 = DAT_00238780 + 1;\n        }\n        uVar24 = (ulong)uVar5;\n        uVar5 = DAT_0023877c;\nLAB_00165a21:\n        if ((uint)uVar24 == uVar5) goto LAB_00165e7f;\n      }\n    }\n    else {\nLAB_001659ec:\n      do {\n        uVar24 = uVar20 & 0xffffffff;\n        if (jobs[uVar20 - 1] != 0) goto LAB_001659f7;\n        uVar20 = uVar20 - 1;\n      } while ((int)uVar20 != 0);\n      uVar24 = (ulong)interactive_shell;\n      if ((interactive_shell != 0) &&\n         (uVar24 = (ulong)subshell_environment, subshell_environment != 0)) {\n        uVar24 = 0;\n        goto LAB_00165a0f;\n      }\n    }\n  }\n  if (the_pipeline == (undefined8 *)0x0) {\n    if (param_1 != 0) {\n      FUN_0015e940();\n    }\n    already_making_children = 0;\n    sigprocmask(2,&local_1c8,(sigset_t *)0x0);\n    uVar24 = (ulong)DAT_00238790;\n    goto LAB_00165c18;\n  }\n  puVar8 = (undefined8 *)sh_xmalloc(0x38,\"jobs.c\",0x27a);\n  puVar9 = the_pipeline;\n  if (the_pipeline == (undefined8 *)*the_pipeline) {\n    iVar25 = 1;\n    puVar11 = the_pipeline;\n  }\n  else {\n    iVar25 = 1;\n    puVar18 = (undefined8 *)*the_pipeline;\n    do {\n      puVar11 = puVar18;\n      puVar18 = (undefined8 *)*puVar11;\n      iVar25 = iVar25 + 1;\n    } while (puVar18 != the_pipeline);\n  }\n  *puVar11 = 0;\n  puVar11 = (undefined8 *)*puVar9;\n  if (puVar11 != (undefined8 *)0x0) {\n    puVar9 = (undefined8 *)list_reverse();\n    puVar11 = (undefined8 *)*puVar9;\n  }\n  puVar8[1] = puVar9;\n  iVar17 = pipeline_pgrp;\n  puVar18 = puVar9;\n  while (puVar10 = puVar11, puVar10 != (undefined8 *)0x0) {\n    puVar18 = puVar10;\n    puVar11 = (undefined8 *)*puVar10;\n  }\n  bVar28 = pipeline_pgrp != shell_pgrp;\n  *puVar18 = puVar9;\n  the_pipeline = (undefined8 *)0x0;\n  *(int *)(puVar8 + 2) = iVar17;\n  iVar17 = job_control;\n  if (bVar28) {\n    pipeline_pgrp = 0;\n  }\n  uVar5 = (uint)(pipefail_opt != 0) << 6;\n  *(uint *)(puVar8 + 3) = uVar5;\n  if (iVar17 != 0) {\n    *(uint *)(puVar8 + 3) = uVar5 | 4;\n  }\n  bVar28 = false;\n  uVar5 = 0;\n  puVar11 = puVar9;\n  do {\n    uVar5 = uVar5 | *(int *)(puVar11 + 2) == 1;\n    pcVar12 = (char *)((long)puVar11 + 0xc);\n    puVar11 = (undefined8 *)*puVar11;\n    bVar28 = (bool)(bVar28 | *pcVar12 == '\\x7f');\n  } while (puVar9 != puVar11);\n  if (uVar5 == 0) {\n    uVar5 = (-(uint)!bVar28 & 2) + 2;\n  }\n  *(uint *)((long)puVar8 + 0x14) = uVar5;\n  pcVar12 = (char *)get_string_value(&DAT_001fc3d5);\n  if (pcVar12 == (char *)0x0) {\n    puVar9 = (undefined8 *)get_working_directory(\"job-working-directory\");\n    if (puVar9 == (undefined8 *)0x0) {\n      puVar9 = (undefined8 *)sh_xmalloc(10,\"jobs.c\",0x1a1);\n      *puVar9 = 0x6e776f6e6b6e753c;\n      *(undefined2 *)(puVar9 + 1) = 0x3e;\n    }\n  }\n  else {\n    sVar13 = strlen(pcVar12);\n    __dest = (char *)sh_xmalloc(sVar13 + 1,\"jobs.c\",0x19b);\n    puVar9 = (undefined8 *)strcpy(__dest,pcVar12);\n  }\n  *puVar8 = puVar9;\n  plVar15 = jobs;\n  iVar17 = *(int *)((long)puVar8 + 0x14);\n  puVar8[5] = 0;\n  puVar8[4] = param_2;\n  iVar21 = (int)uVar24;\n  puVar8[6] = 0;\n  plVar15[iVar21] = (long)puVar8;\n  uVar5 = *(uint *)(puVar8 + 3);\n  if (iVar17 == 4) {\n    if ((uVar5 & 1) != 0) {\n      FUN_0015ede0(uVar24);\n      if (*(int *)((long)puVar8 + 0x14) != 4) {\n        uVar5 = *(uint *)(puVar8 + 3);\n        goto LAB_00165bc3;\n      }\n      uVar5 = *(uint *)(puVar8 + 3);\n    }\n    _DAT_0023876c = _DAT_0023876c + iVar25;\n    _DAT_0023878c = _DAT_0023878c + 1;\n    _DAT_00238770 = _DAT_00238770 + iVar25;\n    DAT_00238788 = DAT_00238788 + 1;\n    _DAT_00238780 = CONCAT44(_DAT_00238784,iVar21);\n    if (param_1 == 0) goto LAB_00165be9;\nLAB_00165cfa:\n    _DAT_00238798 = puVar8;\n    *(uint *)(puVar8 + 3) = uVar5 & 0xfffffffe | 0x20;\n    _DAT_002387a0 = puVar8;\n    FUN_0015e940();\n    iVar21 = terminal_pgrp;\n  }\n  else {\nLAB_00165bc3:\n    _DAT_00238770 = _DAT_00238770 + iVar25;\n    DAT_00238788 = DAT_00238788 + 1;\n    _DAT_00238780 = CONCAT44(_DAT_00238784,iVar21);\n    if (param_1 != 0) goto LAB_00165cfa;\nLAB_00165be9:\n    iVar25 = job_control;\n    _DAT_00238798 = puVar8;\n    *(uint *)(puVar8 + 3) = uVar5 | 1;\n    iVar17 = shell_pgrp;\n    iVar21 = terminal_pgrp;\n    if ((((iVar25 != 0) && (iVar25 = *(int *)(puVar8 + 2), iVar25 != 0)) &&\n        ((subshell_environment & 1 | running_in_background) == 0)) &&\n       (((_Var6 = tcgetpgrp(shell_tty), -1 < _Var6 ||\n         (piVar16 = __errno_location(), iVar21 = terminal_pgrp, *piVar16 != 0x19)) &&\n        (uVar5 = running_in_background, iVar21 = iVar25, iVar25 != _Var6)))) {\n      if (iVar17 == _Var6) {\n        give_terminal_to(iVar25,0);\n        iVar21 = terminal_pgrp;\n      }\n      else {\n        _Var7 = getpid();\n        internal_debug(\"%d: maybe_give_terminal_to: terminal pgrp == %d shell pgrp = %d new pgrp = %d in_background = %d\"\n                       ,_Var7,_Var6,iVar17,iVar25,uVar5);\n        iVar21 = terminal_pgrp;\n      }\n    }\n  }\n  terminal_pgrp = iVar21;\n  already_making_children = 0;\n  sigprocmask(2,&local_1c8,(sigset_t *)0x0);\nLAB_00165c18:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar24;\n}\n\n",
  "find_shell_builtin": "\nundefined8 find_shell_builtin(undefined8 param_1)\n\n{\n  current_builtin = builtin_address_internal(param_1,0);\n  if (current_builtin != 0) {\n    return *(undefined8 *)(current_builtin + 8);\n  }\n  return 0;\n}\n\n",
  "parse_and_execute": "\n/* WARNING: Removing unreachable block (ram,0x001a9372) */\n/* WARNING: Removing unreachable block (ram,0x001a9302) */\n/* WARNING: Removing unreachable block (ram,0x001a930e) */\n/* WARNING: Removing unreachable block (ram,0x001a9319) */\n/* WARNING: Removing unreachable block (ram,0x001a92da) */\n\nuint parse_and_execute(undefined8 param_1,char *param_2,uint param_3)\n\n{\n  uint *puVar1;\n  bool bVar2;\n  int *piVar3;\n  int iVar4;\n  undefined4 uVar5;\n  char *pcVar6;\n  undefined8 uVar7;\n  long in_FS_OFFSET;\n  uint local_cc;\n  undefined8 local_c0;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  FUN_001a8750(param_1,param_3,\"parse_and_execute top\");\n  parse_and_execute_level = parse_and_execute_level + 1;\n  sigemptyset(&local_b8);\n  sigprocmask(0,(sigset_t *)0x0,&local_b8);\n  push_stream(param_3 & 0x10);\n  iVar4 = parser_expanding_alias();\n  if (iVar4 != 0) {\n    parser_save_alias();\n  }\n  if ((param_3 & 0x10) == 0) {\n    line_number = line_number + -1;\n  }\n  indirection_level = indirection_level + 1;\n  local_cc = 0;\n  if (current_token == 0x131) {\n    current_token = 10;\n  }\n  uVar5 = 0;\n  with_input_from_string(param_1,param_2);\n  clear_shell_input_line();\nLAB_001a91ae:\n  bVar2 = false;\n  if ((*DAT_00240a70 == '\\0') && (iVar4 = parser_expanding_alias(), iVar4 == 0)) goto LAB_001a91d9;\n  bVar2 = false;\n  if (interrupt_state != 0) {\n    local_cc = 1;\n    goto LAB_001a91d9;\n  }\n  uVar5 = __sigsetjmp(top_level,0);\n  switch(uVar5) {\n  case 1:\n  case 3:\n    break;\n  case 2:\n    last_command_exit_value = 1;\n    local_cc = 1;\n    set_pipestatus_from_exit(1);\n    if (subshell_environment == 0) {\n      sigprocmask(2,&local_b8,(sigset_t *)0x0);\n      goto LAB_001a91ae;\n    }\n    break;\n  case 4:\n    if ((exit_immediately_on_error != 0) && (variable_context != 0)) {\n      discard_unwind_frame(\"pe_dispose\");\n      reset_local_contexts();\n    }\n    break;\n  case 5:\n    command_error(\"parse_and_execute\",3,uVar5,0);\n  default:\n    bVar2 = false;\n    iVar4 = parse_command();\n    piVar3 = global_command;\n    if (iVar4 != 0) {\n      local_cc = 2;\n      if ((((interactive_shell == 0) && (this_shell_builtin != (undefined *)0x0)) &&\n          ((this_shell_builtin == PTR_eval_builtin_00237f48 ||\n           (this_shell_builtin == PTR_source_builtin_00237f30)))) &&\n         (((last_command_exit_value == 0x101 && (posixly_correct != 0)) &&\n          (executing_command_builtin == 0)))) {\n        bVar2 = true;\n        uVar5 = 4;\n        last_command_exit_value = 2;\n      }\n      goto LAB_001a91d9;\n    }\n    if (((param_3 & 0x20) == 0) && ((interactive_shell != 0 || (read_but_dont_execute == 0)))) {\n      if (global_command != (int *)0x0) {\n        if (((param_3 & 0x80) == 0) ||\n           ((((*global_command == 7 &&\n              ((pcVar6 = (char *)parser_remaining_input(), pcVar6 == (char *)0x0 ||\n               (*pcVar6 == '\\0')))) && (*param_2 == ***(char ***)(*(long *)(piVar3 + 6) + 8))) &&\n            (iVar4 = strcmp(param_2,**(char ***)(*(long *)(piVar3 + 6) + 8)), iVar4 == 0))))\n        goto LAB_001a95a0;\n        internal_warning(\"%s: ignoring function definition attempt\",param_2);\n        bVar2 = false;\n        last_command_exit_value = 2;\n        local_cc = 2;\n        set_pipestatus_from_exit(2);\n        reset_parser();\n        goto LAB_001a91d9;\n      }\n    }\n    else {\n      local_cc = 0;\n      dispose_command(global_command);\n      global_command = (int *)0x0;\n    }\n    goto LAB_001a91ae;\n  case 6:\n  }\n  bVar2 = true;\n  goto LAB_001a91d9;\nLAB_001a95a0:\n  uVar7 = new_fd_bitmap(0x20);\n  begin_unwind_frame(\"pe_dispose\");\n  add_unwind_protect(dispose_fd_bitmap,uVar7);\n  add_unwind_protect(dispose_command);\n  global_command = (int *)0x0;\n  if (((subshell_environment & 4) != 0) && (comsub_ignore_return != 0)) {\n    piVar3[1] = piVar3[1] | 8;\n  }\n  iVar4 = should_suppress_fork(piVar3);\n  if (iVar4 == 0) {\n    if ((*piVar3 == 6) && (iVar4 = can_optimize_connection(piVar3), iVar4 != 0)) {\n      puVar1 = (uint *)(*(long *)(*(long *)(piVar3 + 6) + 0x10) + 4);\n      *puVar1 = *puVar1 | 0x8000;\n      puVar1 = *(uint **)(*(long *)(*(long *)(piVar3 + 6) + 0x10) + 0x18);\n      *puVar1 = *puVar1 | 0x8000;\n    }\n  }\n  else {\n    piVar3[1] = piVar3[1] | 0x40;\n    **(uint **)(piVar3 + 6) = **(uint **)(piVar3 + 6) | 0x40;\n  }\n  if ((((startup_state == 2) && ((subshell_environment & 4) != 0)) && (*DAT_00240a70 == '\\0')) &&\n     (iVar4 = can_optimize_cat_file(piVar3), iVar4 != 0)) {\n    iVar4 = open_redir_file(*(undefined8 *)(*(long *)(piVar3 + 6) + 0x10));\n    if (iVar4 < 0) {\n      local_cc = 0xffffffff;\n    }\n    else {\n      local_cc = zcatfd(iVar4,1,local_c0);\n      sh_xfree(local_c0,\"evalstring.c\",0x2fa);\n      close(iVar4);\n    }\n    local_cc = local_cc >> 0x1f;\n  }\n  else {\n    local_cc = execute_command_internal(piVar3,0,0xffffffff,0xffffffff,uVar7);\n  }\n  bVar2 = false;\n  dispose_command(piVar3);\n  dispose_fd_bitmap(uVar7);\n  discard_unwind_frame(\"pe_dispose\");\n  if ((param_3 & 0x100) != 0) {\n    reset_parser();\nLAB_001a91d9:\n    run_unwind_frame(\"parse_and_execute top\");\n    if ((interrupt_state != 0) && (parse_and_execute_level == 0)) {\n      interactive = interactive_shell;\n      throw_to_top_level();\n    }\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    if (!bVar2) {\n      if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return local_cc;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n                    /* WARNING: Subroutine does not return */\n    jump_to_top_level(uVar5);\n  }\n  goto LAB_001a91ae;\n}\n\n",
  "rl_revert_line": "\nundefined8 rl_revert_line(void)\n\n{\n  if (rl_undo_list == 0) {\n    rl_ding();\n    return 0;\n  }\n  do {\n    rl_do_undo();\n  } while (rl_undo_list != 0);\n  if (rl_editing_mode == 0) {\n    rl_mark = 0;\n    rl_point = 0;\n  }\n  return 0;\n}\n\n",
  "FUN_0019eb90": "\nvoid FUN_0019eb90(char *param_1,int param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *__dest;\n  char cVar3;\n  \n  if (param_2 != 0) goto LAB_0019ec0e;\n  if (DAT_00248a38 != (char *)0x0) {\n    sh_xfree(DAT_00248a38,\"pcomplete.c\",0x2e3);\n  }\n  if (((uint)rl_readline_state & 0x4000) == 0) {\n    if ((this_shell_builtin != compgen_builtin) || (rl_completion_found_quote != 0))\n    goto LAB_0019ec3b;\njoined_r0x0019ebf7:\n    if (rl_filename_dequoting_function == (code *)0x0) goto LAB_0019ec3b;\n    DAT_00248a38 = (char *)(*rl_filename_dequoting_function)(param_1,rl_completion_quote_character);\n  }\n  else {\n    if ((this_shell_builtin != compgen_builtin) || (pcomp_curtxt == (char *)0x0)) goto LAB_0019ec3b;\n    if ((param_1 == (char *)0x0) || (*pcomp_curtxt != '\\0')) {\n      if ((rl_filename_dequoting_function == (code *)0x0) || (param_1 == (char *)0x0))\n      goto LAB_0019ec3b;\n      cVar3 = *param_1;\n    }\n    else {\n      cVar3 = *param_1;\n      if ((((cVar3 == '\\'') || (cVar3 == '\\\"')) && (cVar3 == param_1[1])) && (param_1[2] == '\\0'))\n      goto joined_r0x0019ebf7;\n      if (rl_filename_dequoting_function == (code *)0x0) goto LAB_0019ec3b;\n    }\n    if (((*pcomp_curtxt == cVar3) && (iVar1 = strcmp(pcomp_curtxt,param_1), iVar1 == 0)) ||\n       ((variable_context == 0 || (iVar1 = sh_contains_quotes(param_1), iVar1 == 0)))) {\nLAB_0019ec3b:\n      sVar2 = strlen(param_1);\n      __dest = (char *)sh_xmalloc(sVar2 + 1,\"pcomplete.c\",0x318);\n      DAT_00248a38 = strcpy(__dest,param_1);\n      rl_filename_completion_function(DAT_00248a38,0);\n      return;\n    }\n    DAT_00248a38 = (char *)(*rl_filename_dequoting_function)(param_1,rl_completion_quote_character);\n  }\nLAB_0019ec0e:\n  rl_filename_completion_function(DAT_00248a38,param_2);\n  return;\n}\n\n",
  "strvec_sort": "\nvoid strvec_sort(long *param_1,int param_2)\n\n{\n  long lVar1;\n  size_t sVar2;\n  size_t sVar3;\n  size_t sVar4;\n  \n  lVar1 = *param_1;\n  if (param_2 == 0) {\n    sVar3 = 1;\n    sVar4 = 0;\n    while (sVar2 = sVar3, lVar1 != 0) {\n      sVar3 = sVar2 + 1;\n      sVar4 = sVar2;\n      lVar1 = param_1[sVar2];\n    }\n    qsort(param_1,sVar4,8,strvec_strcmp);\n    return;\n  }\n  if (lVar1 == 0) {\n    sVar4 = 0;\n  }\n  else {\n    sVar3 = 1;\n    do {\n      sVar4 = sVar3;\n      sVar3 = sVar4 + 1;\n    } while (param_1[sVar4] != 0);\n  }\n  qsort(param_1,sVar4,8,strvec_posixcmp);\n  return;\n}\n\n",
  "set_minus_o_option": "\nundefined4 set_minus_o_option(int param_1,char *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined **ppuVar5;\n  long lVar6;\n  char *__s2;\n  \n  cVar2 = 'a';\n  iVar4 = 0;\n  ppuVar5 = &PTR_s_braceexpand_00235fe8;\n  cVar1 = *param_2;\n  __s2 = \"allexport\";\n  while ((cVar1 != cVar2 || (iVar3 = strcmp(param_2,__s2), iVar3 != 0))) {\n    __s2 = *ppuVar5;\n    ppuVar5 = ppuVar5 + 5;\n    iVar4 = iVar4 + 1;\n    if (__s2 == (char *)0x0) {\n      sh_invalidoptname(param_2);\n      return 0x102;\n    }\n    cVar2 = *__s2;\n  }\n  lVar6 = (long)iVar4;\n  if (*(int *)(&DAT_00235fc8 + lVar6 * 0x28) != 0) {\n    iVar4 = change_flag(*(int *)(&DAT_00235fc8 + lVar6 * 0x28),param_1);\n    if (iVar4 != -1) {\n      return 0;\n    }\n    sh_invalidoptname(param_2);\n    return 1;\n  }\n  if (*(code **)(&DAT_00235fe0 + lVar6 * 0x28) != (code *)0x0) {\n    (**(code **)(&DAT_00235fe0 + lVar6 * 0x28))((&o_options)[lVar6 * 5]);\n  }\n  if ((code *)(&DAT_00235fd8)[lVar6 * 5] != (code *)0x0) {\n    (*(code *)(&DAT_00235fd8)[lVar6 * 5])(param_1,param_2);\n    return 0;\n  }\n  *(uint *)(&DAT_00235fd0)[lVar6 * 5] = (uint)(param_1 == 0x2d);\n  return 0;\n}\n\n",
  "merge_temporary_env": "\nvoid merge_temporary_env(void)\n\n{\n  code *pcVar1;\n  \n  if (temporary_env != 0) {\n    pcVar1 = FUN_001566a0;\n    if (posixly_correct == 0) {\n      pcVar1 = FUN_00156420;\n    }\n    FUN_00159fb0(pcVar1);\n    return;\n  }\n  return;\n}\n\n",
  "utf8_mbstrlen": "\nlong utf8_mbstrlen(char *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  ulong uVar3;\n  long lVar4;\n  ulong uVar5;\n  \n  __ctype_get_mb_cur_max();\n  lVar4 = 0;\n  cVar1 = *param_1;\n  uVar5 = 1;\n  while( true ) {\n    if (cVar1 == '\\0') {\n      return lVar4;\n    }\n    iVar2 = utf8_mblen(param_1);\n    uVar3 = (ulong)iVar2;\n    if (uVar3 == 0) break;\n    if (0xfffffffffffffffd < uVar3) {\n      uVar3 = uVar5;\n    }\n    lVar4 = lVar4 + 1;\n    param_1 = param_1 + uVar3;\n    cVar1 = *param_1;\n  }\n  return lVar4;\n}\n\n",
  "find_variable_noref": "\nvoid find_variable_noref(undefined8 param_1)\n\n{\n  bool bVar1;\n  \n  bVar1 = false;\n  if (expanding_redir == 0) {\n    bVar1 = (assigning_in_environment | executing_builtin) != 0;\n  }\n  FUN_00152c60(param_1,bVar1);\n  return;\n}\n\n",
  "where_history": "\nundefined4 where_history(void)\n\n{\n  return history_offset;\n}\n\n",
  "rl_restore_state": "\nundefined8 rl_restore_state(undefined4 *param_1)\n\n{\n  if (param_1 != (undefined4 *)0x0) {\n    rl_point = *param_1;\n    rl_end = param_1[1];\n    rl_mark = param_1[2];\n    rl_line_buffer = *(undefined8 *)(param_1 + 4);\n    rl_line_buffer_len = param_1[3];\n    rl_undo_list = *(undefined8 *)(param_1 + 6);\n    rl_prompt = *(undefined8 *)(param_1 + 8);\n    rl_readline_state = (long)(int)param_1[10];\n    rl_done = param_1[0xb];\n    _rl_keymap = *(undefined **)(param_1 + 0xc);\n    rl_last_func = *(undefined8 *)(param_1 + 0xe);\n    rl_insert_mode = param_1[0x10];\n    rl_editing_mode = param_1[0x11];\n    rl_executing_keyseq = *(undefined8 *)(param_1 + 0x12);\n    rl_key_sequence_length = param_1[0x14];\n    rl_instream = *(undefined8 *)(param_1 + 0x16);\n    rl_completer_word_break_characters = *(undefined8 *)(param_1 + 0x26);\n    rl_outstream = *(undefined8 *)(param_1 + 0x18);\n    rl_pending_input = param_1[0x15];\n    rl_executing_macro = *(undefined8 *)(param_1 + 0x1a);\n    rl_catch_signals = param_1[0x1c];\n    rl_catch_sigwinch = param_1[0x1d];\n    rl_completion_entry_function = *(undefined8 *)(param_1 + 0x1e);\n    rl_menu_completion_entry_function = *(undefined8 *)(param_1 + 0x20);\n    rl_ignore_some_completions_function = *(undefined8 *)(param_1 + 0x22);\n    rl_attempted_completion_function = *(undefined8 *)(param_1 + 0x24);\n    DAT_0024a320 = rl_line_buffer;\n    rl_deactivate_mark();\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
  "rl_stop_output": "\nundefined8 rl_stop_output(void)\n\n{\n  int __fd;\n  \n  __fd = fileno(rl_instream);\n  tcflow(__fd,0);\n  return 0;\n}\n\n",
  "quote_escapes": "\nvoid quote_escapes(undefined8 param_1)\n\n{\n  FUN_00167220(param_1,0);\n  return;\n}\n\n",
  "sh_getopt": "\n/* WARNING: Type propagation algorithm not settling */\n\nint sh_getopt(int param_1,undefined8 *param_2,char *param_3)\n\n{\n  char *pcVar1;\n  long lVar2;\n  char *pcVar3;\n  int __c;\n  int iVar4;\n  char cVar5;\n  \n  sh_optarg = (char *)0x0;\n  if ((param_1 <= sh_optind) || (sh_optind < 0)) {\n    sh_optind = param_1;\n    sh_optarg = (char *)0x0;\n    return -1;\n  }\n  if (sh_optind == 0) {\n    sh_optind = 1;\n    DAT_00248dd8 = (char *)0x0;\n    if (param_1 == 1) {\n      sh_optind = 1;\n      sh_optarg = (char *)0x0;\n      DAT_00248dd8 = (char *)0x0;\n      return -1;\n    }\n  }\n  else if ((DAT_00248dd8 != (char *)0x0) && (cVar5 = *DAT_00248dd8, cVar5 != '\\0')) {\n    DAT_00248dd0 = DAT_00248dd0 + 1;\n    pcVar3 = DAT_00248dd8;\n    goto LAB_001baf57;\n  }\n  pcVar3 = (char *)param_2[sh_optind];\n  if (*pcVar3 != '-') {\n    sh_optarg = (char *)0x0;\n    return -1;\n  }\n  cVar5 = pcVar3[1];\n  if (cVar5 == '-') {\n    if (pcVar3[2] == '\\0') {\n      sh_optind = sh_optind + 1;\n      sh_optarg = (char *)0x0;\n      return -1;\n    }\n  }\n  else if (cVar5 == '\\0') {\n    sh_optarg = (char *)0x0;\n    return -1;\n  }\n  pcVar3 = pcVar3 + 1;\n  DAT_00248dd0 = 2;\n  DAT_00248de0 = sh_optind;\nLAB_001baf57:\n  __c = (int)cVar5;\n  DAT_00248dd8 = pcVar3 + 1;\n  pcVar1 = strchr(param_3,__c);\n  if (pcVar3[1] == '\\0') {\n    sh_optind = sh_optind + 1;\n    DAT_00248dd8 = (char *)0x0;\n  }\n  sh_badopt = (uint)(pcVar1 == (char *)0x0 || cVar5 == ':');\n  sh_optopt = __c;\n  if (pcVar1 == (char *)0x0 || cVar5 == ':') {\n    if (sh_opterr != 0) {\n      __fprintf_chk(stderr,1,\"%s: illegal option -- %c\\n\",*param_2,__c);\n      return 0x3f;\n    }\n    return 0x3f;\n  }\n  if (pcVar1[1] == ':') {\n    lVar2 = (long)sh_optind;\n    iVar4 = __c;\n    if ((DAT_00248dd8 == (char *)0x0) || (*DAT_00248dd8 == '\\0')) {\n      if (param_1 == sh_optind) {\n        if (sh_opterr != 0) {\n          __fprintf_chk(stderr,1,\"%s: option requires an argument -- %c\\n\",*param_2,__c);\n        }\n        sh_optarg = \"\";\n        iVar4 = (uint)(*param_3 != ':') * 5 + 0x3a;\n      }\n      else {\n        sh_optind = sh_optind + 1;\n        sh_optarg = (char *)param_2[lVar2];\n      }\n    }\n    else {\n      sh_optind = sh_optind + 1;\n      sh_optarg = DAT_00248dd8;\n    }\n    sh_optopt = __c;\n    DAT_00248dd8 = (char *)0x0;\n    return iVar4;\n  }\n  return __c;\n}\n\n",
  "_rl_set_the_line": "\nvoid _rl_set_the_line(void)\n\n{\n  DAT_0024a320 = rl_line_buffer;\n  return;\n}\n\n",
  "malloc_usable_size": "\nundefined4 malloc_usable_size(long param_1)\n\n{\n  char *pcVar1;\n  \n  if (param_1 != 0) {\n    if (*(char *)(param_1 + -0x10) == -0x2a) {\n      pcVar1 = (char *)((param_1 - (ulong)*(uint *)(param_1 + -0xc)) + -0x10);\n    }\n    else {\n      pcVar1 = (char *)(param_1 + -0x10);\n    }\n    if (*pcVar1 != 'T') {\n      return *(undefined4 *)(pcVar1 + 4);\n    }\n  }\n  return 0;\n}\n\n",
  "_rl_overwrite_char": "\nundefined8 _rl_overwrite_char(int param_1,undefined4 param_2)\n\n{\n  size_t sVar1;\n  undefined8 uVar2;\n  int iVar3;\n  long in_FS_OFFSET;\n  undefined auStack_48 [24];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 < 1) {\n    rl_begin_undo_group();\n  }\n  else {\n    sVar1 = __ctype_get_mb_cur_max();\n    if ((1 < sVar1) && (rl_byte_oriented == 0)) {\n      iVar3 = _rl_read_mbstring(param_2,auStack_48,0x10);\n      uVar2 = 1;\n      if (iVar3 < 0) goto LAB_001ef992;\n    }\n    rl_begin_undo_group();\n    iVar3 = 0;\n    do {\n      while( true ) {\n        sVar1 = __ctype_get_mb_cur_max();\n        if ((sVar1 < 2) || (rl_byte_oriented != 0)) {\n          FUN_001ee210(1,param_2);\n        }\n        else {\n          rl_insert_text(auStack_48);\n        }\n        if (rl_end <= rl_point) break;\n        iVar3 = iVar3 + 1;\n        rl_delete(1,param_2);\n        if (param_1 == iVar3) goto LAB_001ef98b;\n      }\n      iVar3 = iVar3 + 1;\n    } while (param_1 != iVar3);\n  }\nLAB_001ef98b:\n  rl_end_undo_group();\n  uVar2 = 0;\nLAB_001ef992:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
  "string_list": "\nvoid string_list(undefined8 param_1)\n\n{\n  string_list_internal(param_1,&DAT_001fdb1c);\n  return;\n}\n\n",
  "FUN_0019b1b0": "\nvoid FUN_0019b1b0(void)\n\n{\n  char *pcVar1;\n  undefined2 *puVar2;\n  \n  pcVar1 = (char *)extract_colon_unit();\n  if ((pcVar1 != (char *)0x0) && (*pcVar1 == '\\0')) {\n    sh_xfree(pcVar1,\"findcmd.c\",0x141);\n    puVar2 = (undefined2 *)sh_xmalloc(2,\"findcmd.c\",0x142);\n    *puVar2 = 0x2e;\n    return;\n  }\n  return;\n}\n\n",
  "copy_redirect": "\nundefined8 * copy_redirect(undefined8 *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  ulong uVar4;\n  long lVar5;\n  size_t sVar6;\n  char *__dest;\n  char *__s;\n  \n  puVar3 = (undefined8 *)sh_xmalloc(0x30,\"copy_cmd.c\",0x7b);\n  uVar2 = param_1[1];\n  *puVar3 = *param_1;\n  puVar3[1] = uVar2;\n  uVar2 = param_1[3];\n  puVar3[2] = param_1[2];\n  puVar3[3] = uVar2;\n  uVar2 = param_1[5];\n  puVar3[4] = param_1[4];\n  puVar3[5] = uVar2;\n  if ((*(byte *)(param_1 + 2) & 1) != 0) {\n    puVar1 = (undefined8 *)param_1[1];\n    lVar5 = make_bare_word(*puVar1);\n    *(undefined4 *)(lVar5 + 8) = *(undefined4 *)(puVar1 + 1);\n    puVar3[1] = lVar5;\n  }\n  if (*(uint *)(param_1 + 3) < 0x14) {\n    uVar4 = 1L << ((byte)*(uint *)(param_1 + 3) & 0x3f);\n    if ((uVar4 & 0xe7c2f) == 0) {\n      if ((uVar4 & 0x110) == 0) {\n        return puVar3;\n      }\n      __s = (char *)param_1[5];\n      if (__s != (char *)0x0) {\n        sVar6 = strlen(__s);\n        __dest = (char *)sh_xmalloc(sVar6 + 1,\"copy_cmd.c\",0x89);\n        __s = strcpy(__dest,__s);\n      }\n      puVar3[5] = __s;\n    }\n    puVar1 = (undefined8 *)param_1[4];\n    lVar5 = make_bare_word(*puVar1);\n    *(undefined4 *)(lVar5 + 8) = *(undefined4 *)(puVar1 + 1);\n    puVar3[4] = lVar5;\n  }\n  return puVar3;\n}\n\n",
  "FUN_0019a310": "\nvoid FUN_0019a310(void)\n\n{\n  uint uVar1;\n  ushort **ppuVar2;\n  long lVar3;\n  uint uVar4;\n  uint *puVar5;\n  \n  if (sh_syntabsiz < 1) {\n    return;\n  }\n  puVar5 = &sh_syntaxtab;\n  uVar4 = 0;\n  ppuVar2 = __ctype_b_loc();\n  do {\n    if ((*(byte *)(*ppuVar2 + (uVar4 & 0xff)) & 1) == 0) {\n      if (uVar4 != 0) {\n        lVar3 = mbschr(&DAT_001ff6c9,uVar4);\n        if (lVar3 != 0) {\n          uVar1 = *puVar5 & 0xffffdfff | 2;\n          goto LAB_0019a350;\n        }\n      }\n      uVar1 = *puVar5 & 0xffffdffd;\n    }\n    else {\n      uVar1 = *puVar5 | 0x2002;\n    }\nLAB_0019a350:\n    *puVar5 = uVar1;\n    uVar4 = uVar4 + 1;\n    puVar5 = puVar5 + 1;\n    if (sh_syntabsiz <= (int)uVar4) {\n      return;\n    }\n  } while( true );\n}\n\n",
  "unset_bash_input": "\nvoid unset_bash_input(int param_1)\n\n{\n  if (param_1 == 0) {\n    if (default_buffered_input < 1) {\n      return;\n    }\n  }\n  else if (default_buffered_input < 0) {\n    return;\n  }\n  close_buffered_fd();\n  DAT_00240a70._0_4_ = 0xffffffff;\n  default_buffered_input = 0xffffffff;\n  bash_input = 0;\n  return;\n}\n\n",
  "FUN_001bbde0": "\nvoid FUN_001bbde0(undefined8 param_1,long param_2)\n\n{\n  ulong uVar1;\n  undefined *puVar2;\n  char *pcVar3;\n  undefined **ppuVar4;\n  \n  __printf_chk(1,\"compopt \");\n  uVar1 = *(ulong *)(param_2 + 0x10);\n  puVar2 = (undefined *)0x40;\n  pcVar3 = \"bashdefault\";\n  ppuVar4 = &PTR_s_bashdefault_00235400;\n  while( true ) {\n    if ((uVar1 & (ulong)puVar2) == 0) {\n      __printf_chk(1,\"+o %s \",pcVar3);\n      pcVar3 = ppuVar4[2];\n    }\n    else {\n      __printf_chk(1,\"-o %s \",pcVar3);\n      pcVar3 = ppuVar4[2];\n    }\n    if (pcVar3 == (char *)0x0) break;\n    puVar2 = ppuVar4[3];\n    ppuVar4 = ppuVar4 + 2;\n  }\n  FUN_001bb780(param_1);\n  putchar(10);\n  return;\n}\n\n",
  "rl_vi_fetch_history": "\nvoid rl_vi_fetch_history(void)\n\n{\n  rl_fetch_history();\n  return;\n}\n\n",
  "popd_builtin": "\nundefined8 popd_builtin(long *param_1)\n\n{\n  int iVar1;\n  bool bVar2;\n  int iVar3;\n  undefined8 uVar4;\n  char cVar5;\n  char cVar6;\n  int iVar7;\n  char *__s1;\n  undefined *puVar8;\n  long lVar9;\n  long in_FS_OFFSET;\n  long local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (long *)0x0) {\n    lVar9 = (long)DAT_00248b48;\n    local_38 = 0;\n    if (lVar9 < 0) {\n      puVar8 = &DAT_00213d70;\nLAB_001aec5a:\n      sh_erange(puVar8,\"directory stack index\");\n      uVar4 = 1;\n      goto LAB_001aec6b;\n    }\n    if (DAT_00248b48 != 0) {\n      bVar2 = false;\n      goto LAB_001aed2b;\n    }\n  }\n  else {\n    __s1 = *(char **)param_1[1];\n    if ((*__s1 == '-') && (iVar7 = strcmp(__s1,\"--help\"), iVar7 == 0)) {\n      builtin_help();\n      uVar4 = 0x102;\n      goto LAB_001aec6b;\n    }\n    local_38 = 0;\n    puVar8 = (undefined *)0x0;\n    bVar2 = false;\n    cVar6 = '+';\nLAB_001aeb3f:\n    cVar5 = *__s1;\n    if (cVar5 == '-') {\n      if (__s1[1] != 'n') {\n        if ((__s1[1] != '-') || (__s1[2] != '\\0')) goto LAB_001aeb12;\n        goto LAB_001aeb60;\n      }\n      if (__s1[2] != '\\0') goto LAB_001aeb12;\n      bVar2 = true;\n      cVar5 = cVar6;\nLAB_001aeb30:\n      param_1 = (long *)*param_1;\n      cVar6 = cVar5;\n      if (param_1 == (long *)0x0) goto LAB_001aeb60;\n      __s1 = *(char **)param_1[1];\n      goto LAB_001aeb3f;\n    }\n    if (cVar5 == '+') {\nLAB_001aeb12:\n      iVar7 = legal_number(__s1 + 1,&local_38);\n      puVar8 = *(undefined **)param_1[1];\n      if (iVar7 == 0) {\n        sh_invalidnum();\n        builtin_usage();\n        uVar4 = 0x102;\n        goto LAB_001aec6b;\n      }\n      goto LAB_001aeb30;\n    }\n    cVar6 = '\\0';\n    if (cVar5 != '\\0') {\n      builtin_error(\"%s: invalid argument\",__s1);\n      builtin_usage();\n      uVar4 = 0x102;\n      goto LAB_001aec6b;\n    }\nLAB_001aeb60:\n    lVar9 = (long)DAT_00248b48;\n    if ((local_38 <= lVar9) && (-DAT_00248b48 <= local_38)) {\n      if ((DAT_00248b48 == 0) && (local_38 == 0)) goto LAB_001aec9f;\n      iVar7 = (int)local_38;\n      if (cVar6 == '+') {\n        if (local_38 == 0) goto LAB_001aed2b;\n        iVar7 = DAT_00248b48 - iVar7;\nLAB_001aebb5:\n        if ((DAT_00248b48 < iVar7) || (iVar7 < 0)) {\n          if (puVar8 == (undefined *)0x0) {\n            puVar8 = &DAT_00213d70;\n          }\n          goto joined_r0x001aec58;\n        }\n        lVar9 = (long)iVar7 * 8;\n        sh_xfree(*(undefined8 *)(DAT_00248b50 + (long)iVar7 * 8),\"./pushd.def\",0x18b);\n        iVar1 = DAT_00248b48 + -1;\n        if (iVar7 < iVar1) {\n          iVar3 = DAT_00248b48 + -2;\n          DAT_00248b48 = iVar1;\n          memmove((void *)(DAT_00248b50 + lVar9),(void *)(DAT_00248b50 + 8 + lVar9),\n                  (ulong)(uint)(iVar3 - iVar7) * 8 + 8);\n          iVar1 = DAT_00248b48;\n        }\n      }\n      else {\n        if ((cVar6 != '-') || (lVar9 != local_38)) goto LAB_001aebb5;\nLAB_001aed2b:\n        if ((!bVar2) &&\n           (uVar4 = FUN_001ae4d0(*(undefined8 *)(DAT_00248b50 + -8 + lVar9 * 8)), (int)uVar4 != 0))\n        goto LAB_001aec6b;\n        DAT_00248b48 = DAT_00248b48 + -1;\n        sh_xfree(*(undefined8 *)(DAT_00248b50 + (long)DAT_00248b48 * 8),\"./pushd.def\",0x17e);\n        iVar1 = DAT_00248b48;\n      }\n      DAT_00248b48 = iVar1;\n      dirs_builtin(0);\n      uVar4 = 0;\n      goto LAB_001aec6b;\n    }\n    if (puVar8 == (undefined *)0x0) {\n      puVar8 = &DAT_00213d70;\n    }\njoined_r0x001aec58:\n    if (DAT_00248b48 != 0) goto LAB_001aec5a;\n  }\nLAB_001aec9f:\n  builtin_error(\"directory stack empty\");\n  uVar4 = 1;\nLAB_001aec6b:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001cf7e0": "\nvoid FUN_001cf7e0(void)\n\n{\n  int iVar1;\n  \n  iVar1 = rl_end;\n  rl_yank();\n  DAT_0024a410 = DAT_0024a410 + (rl_end - iVar1);\n  return;\n}\n\n",
  "unbind_function_def": "\nundefined8 unbind_function_def(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = hash_remove(param_1,shell_function_defs,0);\n  if (lVar1 == 0) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    if (*(long *)(lVar1 + 0x10) != 0) {\n      dispose_function_def();\n    }\n    sh_xfree(*(undefined8 *)(lVar1 + 8),\"variables.c\",0xf65);\n    sh_xfree(lVar1,\"variables.c\",0xf66);\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
  "FUN_00195330": "\nundefined8 FUN_00195330(void)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long lVar5;\n  long lVar6;\n  char *pcVar7;\n  char **ppcVar8;\n  size_t sVar9;\n  char *__dest;\n  \n  lVar5 = FUN_001942c0(rl_line_buffer);\n  if (lVar5 == 0) {\n    lVar6 = expand_string_dollar_quote(rl_line_buffer,0);\n  }\n  else {\n    lVar6 = expand_string_dollar_quote(lVar5,0);\n    sh_xfree(lVar5,\"bashline.c\",0xb4f);\n  }\n  if (lVar6 == 0) {\nLAB_001954d0:\n    FUN_001934f0();\n    return 1;\n  }\n  pcVar7 = (char *)alias_expand(lVar6);\n  sh_xfree(lVar6,\"bashline.c\",0xb58);\n  iVar2 = rl_point;\n  iVar1 = rl_end;\n  if (pcVar7 == (char *)0x0) goto LAB_001954d0;\n  lVar5 = (long)rl_point;\n  iVar3 = strcmp(pcVar7,rl_line_buffer);\n  if (iVar3 != 0) {\n    FUN_00194330(pcVar7);\n  }\n  sh_xfree(pcVar7,\"bashline.c\",0xb65);\n  ppcVar8 = (char **)alloc_word_desc();\n  pcVar7 = rl_line_buffer;\n  sVar9 = strlen(rl_line_buffer);\n  __dest = (char *)sh_xmalloc(sVar9 + 1,\"bashline.c\",0xb6c);\n  pcVar7 = strcpy(__dest,pcVar7);\n  iVar3 = rl_explicit_arg;\n  *ppcVar8 = pcVar7;\n  uVar4 = 0;\n  if (iVar3 != 0) {\n    uVar4 = 0x100400;\n    iVar3 = 2;\n  }\n  *(undefined4 *)(ppcVar8 + 1) = uVar4;\n  lVar6 = expand_word(ppcVar8,iVar3);\n  dispose_word(ppcVar8);\n  if (lVar6 == 0) {\n    pcVar7 = (char *)sh_xmalloc(1,\"bashline.c\",0xb78);\n    *pcVar7 = '\\0';\n  }\n  else {\n    pcVar7 = (char *)string_list(lVar6);\n    dispose_words(lVar6);\n    if (pcVar7 == (char *)0x0) goto LAB_00195472;\n  }\n  iVar3 = strcmp(pcVar7,rl_line_buffer);\n  if (iVar3 != 0) {\n    FUN_00194330(pcVar7);\n  }\nLAB_00195472:\n  sh_xfree(pcVar7,\"bashline.c\",0xb82);\n  if (iVar1 != iVar2) {\n    if (iVar2 < rl_end) {\n      rl_point = iVar2;\n      if ((rl_line_buffer[lVar5] != ' ') && (rl_line_buffer[lVar5] != '\\t')) {\n        rl_forward_word(1,0);\n      }\n    }\n    return 0;\n  }\n  rl_point = rl_end;\n  return 0;\n}\n\n",
  "mbtowc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbtowc(wchar_t *__pwc,char *__s,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_mbtowc_00237b58)();\n  return iVar1;\n}\n\n",
  "push_dollar_vars": "\nvoid push_dollar_vars(void)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  undefined8 *puVar8;\n  \n  lVar6 = (long)DAT_002422cc;\n  if (DAT_002422d0 <= DAT_002422cc + 1) {\n    DAT_002422d0 = DAT_002422d0 + 10;\n    DAT_002422d8 = sh_xrealloc(DAT_002422d8,(long)DAT_002422d0 * 0x18,\"variables.c\",0x161c);\n    lVar6 = (long)DAT_002422cc;\n  }\n  puVar1 = (undefined8 *)(DAT_002422d8 + lVar6 * 0x18);\n  *(undefined4 *)(puVar1 + 2) = posparam_count;\n  puVar3 = (undefined8 *)strvec_create(10);\n  puVar7 = &DAT_00242228;\n  puVar5 = puVar3;\n  do {\n    puVar5 = puVar5 + 1;\n    puVar8 = puVar7 + 1;\n    *puVar5 = *puVar7;\n    *puVar7 = 0;\n    puVar7 = puVar8;\n  } while (puVar8 != (undefined8 *)&tempenv_assign_error);\n  *puVar1 = puVar3;\n  lVar6 = DAT_002422d8;\n  uVar2 = rest_of_args;\n  lVar4 = (long)DAT_002422cc;\n  posparam_count = 0;\n  DAT_002422cc = DAT_002422cc + 1;\n  rest_of_args = 0;\n  *(undefined8 *)(DAT_002422d8 + 8 + lVar4 * 0x18) = uVar2;\n  puVar1 = (undefined8 *)(lVar6 + 0x18 + lVar4 * 0x18);\n  *puVar1 = 0;\n  puVar1[1] = 0;\n  return;\n}\n\n",
  "string_list_dollar_at": "\nvoid string_list_dollar_at(long *param_1,ulong param_2,uint param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined *puVar4;\n  size_t sVar5;\n  size_t sVar6;\n  undefined8 uVar7;\n  ulong uVar8;\n  long *plVar9;\n  undefined *puVar10;\n  long in_FS_OFFSET;\n  undefined auStack_58 [8];\n  undefined *local_50;\n  long local_40;\n  undefined *puVar11;\n  \n  puVar10 = auStack_58;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar6 = __ctype_get_mb_cur_max();\n  sVar5 = ifs_firstc_len;\n  puVar11 = auStack_58;\n  puVar4 = auStack_58;\n  while (puVar11 != auStack_58 + -(sVar6 + 0x10 & 0xfffffffffffff000)) {\n    puVar10 = puVar4 + -0x1000;\n    *(undefined8 *)(puVar4 + -8) = *(undefined8 *)(puVar4 + -8);\n    puVar11 = puVar4 + -0x1000;\n    puVar4 = puVar4 + -0x1000;\n  }\n  uVar8 = (ulong)((uint)(sVar6 + 0x10) & 0xff0);\n  lVar3 = -uVar8;\n  local_50 = puVar10 + lVar3;\n  if (uVar8 != 0) {\n    *(undefined8 *)(puVar10 + -8) = *(undefined8 *)(puVar10 + -8);\n  }\n  if ((((ifs_var == 0) || ((param_3 & 8) != 0)) || (*(char **)(ifs_var + 8) == (char *)0x0)) ||\n     (**(char **)(ifs_var + 8) == '\\0')) {\n    *(undefined2 *)(puVar10 + lVar3) = 0x20;\n    local_50 = puVar10 + lVar3;\n  }\n  else if (ifs_firstc_len == 1) {\n    puVar10[lVar3 + 1] = 0;\n    puVar10[lVar3] = ifs_firstc;\n    local_50 = puVar10 + lVar3;\n  }\n  else {\n    *(undefined8 *)(puVar10 + lVar3 + -8) = 0x17070a;\n    memcpy(puVar10 + lVar3,&ifs_firstc,ifs_firstc_len);\n    puVar10[sVar5 + lVar3] = 0;\n  }\n  if ((param_2 & 0xb) == 0) {\n    plVar9 = param_1;\n    if (param_1 != (long *)0x0) {\n      do {\n        puVar1 = (undefined8 *)plVar9[1];\n        uVar2 = *puVar1;\n        *(undefined8 *)(puVar10 + lVar3 + -8) = 0x170661;\n        uVar7 = FUN_00167220(uVar2,0);\n        *puVar1 = uVar7;\n        *(undefined8 *)(puVar10 + lVar3 + -8) = 0x170674;\n        sh_xfree(uVar2,\"subst.c\",0x127b);\n        plVar9 = (long *)*plVar9;\n      } while (plVar9 != (long *)0x0);\n    }\n  }\n  else {\n    *(undefined8 *)(puVar10 + lVar3 + -8) = 0x1706b8;\n    param_1 = (long *)FUN_00170510(param_1);\n  }\n  *(undefined8 *)(puVar10 + lVar3 + -8) = 0x170688;\n  string_list_internal(param_1,local_50);\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    *(undefined8 *)(puVar10 + lVar3 + -8) = 0x170719;\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "FUN_001805c0": "\nvoid FUN_001805c0(int param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  undefined auStack_a8 [48];\n  undefined8 local_78;\n  undefined8 local_60;\n  undefined8 local_50;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = mailstat(**(undefined8 **)(DAT_002478b8 + (long)param_1 * 8),auStack_a8);\n  lVar1 = *(long *)(DAT_002478b8 + (long)param_1 * 8);\n  if (iVar2 == 0) {\n    *(undefined8 *)(lVar1 + 0x10) = local_60;\n    *(undefined8 *)(lVar1 + 0x18) = local_50;\n    *(uint *)(lVar1 + 0x28) = *(uint *)(lVar1 + 0x28) | 1;\n    *(undefined8 *)(lVar1 + 0x20) = local_78;\n  }\n  else {\n    *(undefined8 *)(lVar1 + 0x18) = 0;\n    *(undefined8 *)(lVar1 + 0x10) = 0;\n    *(undefined8 *)(lVar1 + 0x20) = 0;\n    *(undefined4 *)(lVar1 + 0x28) = 0;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "find_or_make_array_variable": "\nlong find_or_make_array_variable(undefined8 param_1,ulong param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  uint uVar3;\n  \n  lVar2 = find_variable();\n  if (lVar2 == 0) {\n    lVar2 = find_variable_last_nameref(param_1,1);\n    if (lVar2 == 0) {\n      if ((param_2 & 2) == 0) {\nLAB_0018ac9d:\n        lVar2 = make_new_array_variable(param_1);\n        return lVar2;\n      }\nLAB_0018ace4:\n      lVar2 = make_new_assoc_variable(param_1);\n      return lVar2;\n    }\n    if ((*(uint *)(lVar2 + 0x28) & 0x1800) == 0x1800) {\n      internal_warning(\"%s: removing nameref attribute\",param_1);\n      *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) & 0xfffff7ff;\n    }\n    uVar3 = *(uint *)(lVar2 + 0x28);\n    if ((uVar3 & 0x800) == 0) goto LAB_0018abc7;\n    iVar1 = valid_nameref_value(*(undefined8 *)(lVar2 + 8),2);\n    if (iVar1 == 0) {\n      sh_invalidid(*(undefined8 *)(lVar2 + 8));\n      return 0;\n    }\n    if ((param_2 & 2) == 0) {\n      lVar2 = make_new_array_variable();\n      if (lVar2 == 0) goto LAB_0018ac9d;\n      uVar3 = *(uint *)(lVar2 + 0x28);\n      if ((param_2 & 1) == 0) goto LAB_0018ac20;\n    }\n    else {\n      lVar2 = make_new_assoc_variable();\n      if (lVar2 == 0) goto LAB_0018ace4;\n      uVar3 = *(uint *)(lVar2 + 0x28);\n      if ((param_2 & 1) == 0) goto LAB_0018abd9;\n    }\nLAB_0018abcc:\n    if ((uVar3 & 0x4002) != 0) {\n      if ((uVar3 & 2) == 0) {\n        return 0;\n      }\n      err_readonly(param_1);\n      return 0;\n    }\n  }\n  else {\n    uVar3 = *(uint *)(lVar2 + 0x28);\nLAB_0018abc7:\n    if ((param_2 & 1) != 0) goto LAB_0018abcc;\n  }\n  if ((param_2 & 2) == 0) {\nLAB_0018ac20:\n    if ((uVar3 & 0x44) != 0) {\n      return lVar2;\n    }\n    lVar2 = convert_var_to_array(lVar2);\n    return lVar2;\n  }\nLAB_0018abd9:\n  if ((uVar3 & 4) == 0) {\n    if ((uVar3 & 0x40) == 0) {\n      lVar2 = convert_var_to_assoc(lVar2);\n      return lVar2;\n    }\n  }\n  else {\n    lVar2 = 0;\n    set_exit_status(1);\n    report_error(\"%s: cannot convert indexed to associative array\",param_1);\n  }\n  return lVar2;\n}\n\n",
  "extract_command_subst": "\nvoid extract_command_subst(long param_1,int *param_2,uint param_3)\n\n{\n  if ((*(char *)(*param_2 + param_1) != '(') && ((param_3 & 0x400) == 0)) {\n    xparse_dolparen(param_1,(char *)(*param_2 + param_1),param_2,\n                    (uint)(no_longjmp_on_fatal_error != 0) << 6 | param_3);\n    return;\n  }\n  FUN_0016b780(param_1,param_2,&DAT_001fe090,&DAT_001fe091,&DAT_001fc61f,param_3 | 8);\n  return;\n}\n\n",
  "rl_operate_and_get_next": "\nundefined8 rl_operate_and_get_next(int param_1)\n\n{\n  int iVar1;\n  \n  rl_newline(1);\n  if (rl_explicit_arg == 0) {\n    iVar1 = where_history();\n    param_1 = iVar1 + history_base + 1;\n  }\n  DAT_00240558 = param_1;\n  DAT_0024b6c8 = _rl_internal_startup_hook;\n  _rl_internal_startup_hook = FUN_001f14b0;\n  return 0;\n}\n\n",
  "FUN_001903d0": "\nundefined8 FUN_001903d0(long *param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  int iVar3;\n  size_t sVar4;\n  long lVar5;\n  \n  iVar3 = strvec_len();\n  sVar4 = __ctype_get_mb_cur_max();\n  if ((2 < iVar3) && (1 < sVar4)) {\n    qsort(param_1 + 1,(long)(iVar3 + -1),8,FUN_0018ffd0);\n  }\n  lVar5 = FUN_00190000(param_1,1,iVar3,0);\n  lVar1 = *param_1;\n  plVar2 = param_1;\n  while (lVar1 != 0) {\n    sh_xfree(lVar1,\"bracecomp.c\",0xb4);\n    *plVar2 = 0;\n    lVar1 = plVar2[1];\n    plVar2 = plVar2 + 1;\n  }\n  *param_1 = lVar5;\n  return 0;\n}\n\n",
  "FUN_001de2b0": "\nundefined8 FUN_001de2b0(char *param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  \n  uVar3 = DAT_0024a7a8;\n  iVar2 = DAT_0024a7a4;\n  uVar1 = DAT_0024a7a0;\n  if (_rl_parsing_conditionalized_out == '\\0') {\n    pcVar4 = strchr(param_1,10);\n    if (pcVar4 != (char *)0x0) {\n      *pcVar4 = '\\0';\n    }\n    uVar5 = FUN_001ddf90(param_1,iVar2 + 1);\n    DAT_0024a7a8 = uVar3;\n    DAT_0024a7a0 = uVar1;\n    DAT_0024a7a4 = iVar2;\n    return uVar5;\n  }\n  return 0;\n}\n\n",
  "FUN_0019e1b0": "\nundefined8 FUN_0019e1b0(uint *param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  uint uVar5;\n  undefined8 *puVar6;\n  undefined8 *puVar7;\n  int iVar8;\n  \n  plVar2 = (long *)strlist_create(num_shell_builtins);\n  if (num_shell_builtins < 1) {\n    puVar7 = (undefined8 *)*plVar2;\n    iVar8 = 0;\n  }\n  else {\n    uVar5 = num_shell_builtins - 1;\n    lVar1 = *plVar2;\n    iVar8 = 0;\n    puVar7 = (undefined8 *)(shell_builtins + 0x30);\n    puVar3 = (undefined8 *)shell_builtins;\n    puVar6 = puVar7;\n    while( true ) {\n      if (puVar3[1] != 0) {\n        lVar4 = (long)iVar8;\n        iVar8 = iVar8 + 1;\n        *(undefined8 *)(lVar1 + lVar4 * 8) = *puVar3;\n      }\n      if (puVar6 == puVar7 + (ulong)uVar5 * 6) break;\n      puVar3 = puVar6;\n      puVar6 = puVar6 + 6;\n    }\n    puVar7 = (undefined8 *)(lVar1 + (long)iVar8 * 8);\n  }\n  *(int *)((long)plVar2 + 0xc) = iVar8;\n  *puVar7 = 0;\n  *(long **)(param_1 + 4) = plVar2;\n  *param_1 = *param_1 | 0x20;\n  return 0;\n}\n\n",
  "FUN_00148110": "\nundefined4 FUN_00148110(code *param_1,undefined8 *param_2,uint param_3,uint param_4)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  size_t sVar3;\n  char *__dest;\n  char *pcVar4;\n  uint uVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint uVar8;\n  bool bVar9;\n  int local_48;\n  \n  if (param_4 == 0) {\n    uVar5 = param_3 & 8;\n    if ((param_3 & 8) == 0) {\n      pcVar4 = (char *)0x0;\n      goto LAB_0014828d;\n    }\n    if (((param_1 == (code *)PTR_eval_builtin_00237f48) || ((param_3 & 0x800) != 0)) ||\n       (param_1 == source_builtin)) {\n      begin_unwind_frame(\"eval_builtin\");\n      unwind_protect_mem(&exit_immediately_on_error,4);\n      unwind_protect_mem(&builtin_ignoring_errexit,4);\n      iVar2 = signal_is_trapped(0x42);\n      if (((iVar2 == 0) || (iVar2 = signal_is_ignored(0x42), pcVar4 = DAT_00247c10, iVar2 != 0)) ||\n         (DAT_00247c10 == (char *)0x0)) {\n        pcVar4 = (char *)0x0;\n      }\n      else {\n        sVar3 = strlen(DAT_00247c10);\n        __dest = (char *)sh_xmalloc(sVar3 + 1,\"execute_cmd.c\",0x1315);\n        pcVar4 = strcpy(__dest,pcVar4);\n        add_unwind_protect(xfree,pcVar4);\n        add_unwind_protect(set_error_trap,pcVar4);\n        restore_default_signal(0x42);\n      }\n      local_48 = builtin_ignoring_errexit;\n      uVar5 = 1;\n      exit_immediately_on_error = 0;\n      builtin_ignoring_errexit = 1;\n      goto LAB_0014828d;\n    }\n    uVar5 = 0;\n    pcVar4 = (char *)0x0;\nLAB_00148180:\n    uVar8 = (uint)CONCAT71(0x1ade,param_1 == mapfile_builtin);\n    if ((param_1 == (code *)PTR_unset_builtin_00237f38) || (param_1 == mapfile_builtin))\n    goto LAB_001482ac;\n    uVar7 = 0;\n    uVar8 = uVar7;\n    if ((param_1 == (code *)PTR_fc_builtin_00237fb8) ||\n       (uVar8 = 0, param_1 == (code *)PTR_read_builtin_00237fc8)) goto LAB_001482cc;\n    if (param_4 != 0) goto LAB_001481c8;\njoined_r0x00148465:\n    if (param_1 == (code *)PTR_eval_builtin_00237f48) {\n      if ((0 < evalnest_max) && (evalnest_max <= evalnest)) {\n        internal_error(\"eval: maximum eval nesting level exceeded (%d)\");\n        evalnest = 0;\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level(2);\n      }\n      unwind_protect_mem(&evalnest,4);\n      evalnest = evalnest + 1;\n    }\n    else if (param_1 == source_builtin) {\n      if ((0 < sourcenest_max) && (sourcenest_max <= sourcenest)) {\n        internal_error(\"%s: maximum source nesting level exceeded (%d)\",this_command_name);\n        sourcenest = 0;\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level(2);\n      }\n      unwind_protect_mem(&sourcenest,4);\n      sourcenest = sourcenest + 1;\n    }\n    if (posixly_correct == 0) goto LAB_00148334;\n    bVar9 = param_1 == (code *)PTR_command_builtin_00237fe0;\n    if (param_1 == (code *)PTR_return_builtin_00237f60) {\n      if (((param_3 & 0x800) == 0) && (temporary_env != 0)) {\n        begin_unwind_frame(\"return_temp_env\");\n        add_unwind_protect(merge_temporary_env,0);\n      }\n      executing_builtin = executing_builtin + 1;\n      executing_command_builtin = executing_command_builtin | bVar9;\n      uVar1 = return_builtin(*param_2);\n      if (posixly_correct == 0) goto LAB_00148208;\nLAB_00148379:\n      if (temporary_env != 0) {\n        discard_unwind_frame(\"return_temp_env\");\n      }\n    }\n    else {\n      executing_builtin = executing_builtin + 1;\n      executing_command_builtin = executing_command_builtin | bVar9;\n      uVar1 = (*param_1)(*param_2);\n    }\n  }\n  else {\n    pcVar4 = (char *)0x0;\n    uVar5 = 0;\nLAB_0014828d:\n    uVar8 = (uint)(param_1 == mapfile_builtin);\n    if ((param_1 != source_builtin) && (param_1 != (code *)PTR_eval_builtin_00237f48))\n    goto LAB_00148180;\nLAB_001482ac:\n    uVar8 = (((param_1 == (code *)PTR_fc_builtin_00237fb8 ||\n              param_1 == (code *)PTR_read_builtin_00237fc8) | uVar8) ^ 1) & 0xff;\nLAB_001482cc:\n    if (param_4 == 0) {\n      begin_unwind_frame(\"builtin_env\");\n      if (temporary_env != 0) {\n        push_scope(8);\n        puVar6 = (undefined *)0x0;\n        if (((param_3 & 0x800) == 0) && (uVar8 != 0)) {\n          puVar6 = &DAT_001fea52;\n        }\n        add_unwind_protect(pop_scope,puVar6);\n        goto LAB_001482fb;\n      }\n      uVar7 = 1;\n      temporary_env = 0;\n      goto joined_r0x00148465;\n    }\n    uVar7 = param_4;\n    if (temporary_env != 0) {\n      push_scope(8);\nLAB_001482fb:\n      temporary_env = 0;\n      uVar7 = 1;\n      if (param_4 == 0) goto joined_r0x00148465;\n    }\nLAB_001481c8:\n    if (posixly_correct != 0) {\n      executing_builtin = executing_builtin + 1;\n      executing_command_builtin =\n           param_1 == (code *)PTR_command_builtin_00237fe0 | executing_command_builtin;\n      uVar1 = (*param_1)(*param_2);\n      goto LAB_00148208;\n    }\nLAB_00148334:\n    executing_builtin = executing_builtin + 1;\n    executing_command_builtin =\n         executing_command_builtin | param_1 == (code *)PTR_command_builtin_00237fe0;\n    uVar1 = (*param_1)(*param_2);\n    if (posixly_correct != 0) {\n      if (param_4 != 0) goto LAB_0014821c;\n      if (param_1 == (code *)PTR_return_builtin_00237f60) goto LAB_00148379;\n    }\n  }\nLAB_00148208:\n  if (((param_4 ^ 1) & uVar7) != 0) {\n    run_unwind_frame(\"builtin_env\");\n  }\nLAB_0014821c:\n  if (uVar5 != 0) {\n    builtin_ignoring_errexit = local_48;\n    exit_immediately_on_error = 0;\n    if (local_48 == 0) {\n      exit_immediately_on_error = errexit_flag;\n    }\n    if (pcVar4 != (char *)0x0) {\n      set_error_trap(pcVar4);\n      sh_xfree(pcVar4,\"execute_cmd.c\",0x137c);\n    }\n    discard_unwind_frame(\"eval_builtin\");\n  }\n  return uVar1;\n}\n\n",
  "delete_job": "\nvoid delete_job(void)\n\n{\n  if ((DAT_0023877c != 0) && (DAT_00247660 == 0)) {\n    FUN_0015f990();\n    return;\n  }\n  return;\n}\n\n",
  "shtimer_flush": "\nvoid shtimer_flush(undefined8 *param_1)\n\n{\n  ulong uVar1;\n  undefined8 *puVar2;\n  byte bVar3;\n  \n  bVar3 = 0;\n  if (param_1[0x20] != 0) {\n    sh_xfree(param_1[0x20],\"timers.c\",0x57);\n  }\n  *param_1 = 0;\n  param_1[2] = 0xffffffff;\n  param_1[1] = 0;\n  *(undefined4 *)(param_1 + 3) = 0;\n  param_1[5] = 0;\n  param_1[4] = 0;\n  param_1[6] = 0;\n  param_1[0x1e] = 0;\n  puVar2 = (undefined8 *)((ulong)(param_1 + 7) & 0xfffffffffffffff8);\n  for (uVar1 = (ulong)(((int)param_1 -\n                       (int)(undefined8 *)((ulong)(param_1 + 7) & 0xfffffffffffffff8)) + 0xf8U >> 3)\n      ; uVar1 != 0; uVar1 = uVar1 - 1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + (ulong)bVar3 * -2 + 1;\n  }\n  param_1[0x1f] = 0;\n  param_1[0x20] = 0;\n  return;\n}\n\n",
  "sv_comp_wordbreaks": "\nvoid sv_comp_wordbreaks(void)\n\n{\n  long lVar1;\n  \n  lVar1 = find_variable();\n  if (lVar1 != 0) {\n    return;\n  }\n  reset_completer_word_break_chars();\n  return;\n}\n\n",
  "FUN_001b3e10": "\nvoid FUN_001b3e10(void)\n\n{\n  ulong uVar1;\n  \n  if (variable_context == 0) {\n    uVar1 = dollar_vars_changed();\n    if ((uVar1 & 4) != 0) {\n      dispose_saved_dollar_vars();\n      goto LAB_001b3e30;\n    }\n  }\n  pop_dollar_vars();\nLAB_001b3e30:\n  if (debugging_mode == 0) {\n    set_dollar_vars_unchanged();\n    invalidate_cached_quoted_dollar_at();\n    return;\n  }\n  pop_args();\n  set_dollar_vars_unchanged();\n  invalidate_cached_quoted_dollar_at();\n  return;\n}\n\n",
  "fd_ispipe": "\nbool fd_ispipe(int param_1)\n\n{\n  int *piVar1;\n  __off_t _Var2;\n  bool bVar3;\n  \n  piVar1 = __errno_location();\n  *piVar1 = 0;\n  _Var2 = lseek(param_1,0,1);\n  bVar3 = false;\n  if (_Var2 < 0) {\n    bVar3 = *piVar1 == 0x1d;\n  }\n  return bVar3;\n}\n\n",
  "rl_on_new_line": "\nundefined8 rl_on_new_line(void)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR_DAT_00240520;\n  if (*(undefined **)PTR_DAT_00240520 != (undefined *)0x0) {\n    **(undefined **)PTR_DAT_00240520 = 0;\n  }\n  _rl_last_v_pos = 0;\n  _rl_last_c_pos = 0;\n  DAT_0024a8c0 = 0;\n  _rl_vis_botlin = 0;\n  if (*(undefined8 **)(puVar1 + 0x10) != (undefined8 *)0x0) {\n    **(undefined8 **)(puVar1 + 0x10) = 0;\n  }\n  DAT_0024a888 = 0;\n  return 0;\n}\n\n",
  "_rl_print_prefix_color": "\nundefined8 _rl_print_prefix_color(void)\n\n{\n  long **pplVar1;\n  char cVar2;\n  int iVar3;\n  undefined8 uVar4;\n  long *plVar5;\n  size_t *psVar6;\n  \n  psVar6 = (size_t *)&DAT_00240670;\n  plVar5 = _rl_color_ext_list;\n  if (_rl_color_ext_list != (long *)0x0) {\n    do {\n      if (((*plVar5 == 0x22) && (*(char *)plVar5[1] == 'r')) &&\n         (iVar3 = strncmp((char *)plVar5[1],\"readline-colored-completion-prefix\",0x22), iVar3 == 0))\n      {\n        psVar6 = (size_t *)(plVar5 + 2);\n        goto LAB_001f76f8;\n      }\n      pplVar1 = (long **)(plVar5 + 4);\n      plVar5 = *pplVar1;\n    } while (*pplVar1 != (long *)0x0);\n    psVar6 = (size_t *)&DAT_00240670;\n  }\nLAB_001f76f8:\n  uVar4 = 1;\n  if (psVar6[1] != 0) {\n    cVar2 = FUN_001f7550(4);\n    if (cVar2 != '\\0') {\n      fwrite(PTR_DAT_002405e8,_rl_color_indicator,1,rl_outstream);\n      fwrite(PTR_DAT_002405f8,DAT_002405f0,1,rl_outstream);\n    }\n    fwrite(PTR_DAT_002405e8,_rl_color_indicator,1,rl_outstream);\n    fwrite((void *)psVar6[1],*psVar6,1,rl_outstream);\n    fwrite(PTR_DAT_002405f8,DAT_002405f0,1,rl_outstream);\n    uVar4 = 0;\n  }\n  return uVar4;\n}\n\n",
  "rl_reset_screen_size": "\nvoid rl_reset_screen_size(void)\n\n{\n  int iVar1;\n  \n  iVar1 = fileno(rl_instream);\n  _rl_get_screen_size(iVar1,0);\n  return;\n}\n\n",
  "FUN_001b83b0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid * FUN_001b83b0(char *param_1,long param_2,long param_3)\n\n{\n  long lVar1;\n  char cVar2;\n  uint uVar3;\n  size_t sVar4;\n  void *pvVar5;\n  ulong uVar6;\n  \n  sVar4 = strlen(param_1);\n  lVar1 = sVar4 + param_3;\n  if (_DAT_00248d70 < lVar1 + 1U) {\n    _DAT_00248d70 = lVar1 + 0x400U & 0xfffffffffffffc00;\n    DAT_00248d78 = (void *)sh_xrealloc(DAT_00248d78,_DAT_00248d70,\"./printf.def\",0x47a);\n  }\n  pvVar5 = memcpy(DAT_00248d78,param_1,sVar4 - 1);\n  if ((uint)param_3 != 0) {\n    uVar3 = 0;\n    do {\n      uVar6 = (ulong)uVar3;\n      uVar3 = uVar3 + 1;\n      *(undefined *)((long)pvVar5 + uVar6 + (sVar4 - 1)) = *(undefined *)(param_2 + uVar6);\n    } while (uVar3 < (uint)param_3);\n  }\n  cVar2 = param_1[sVar4 - 1];\n  *(undefined *)((long)pvVar5 + lVar1) = 0;\n  *(char *)((long)pvVar5 + lVar1 + -1) = cVar2;\n  return pvVar5;\n}\n\n",
  "restore_parser_state": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid restore_parser_state(undefined4 *param_1)\n\n{\n  undefined4 *puVar1;\n  \n  if (param_1 != (undefined4 *)0x0) {\n    parser_state = *param_1;\n    puVar1 = *(undefined4 **)(param_1 + 2);\n    if (puVar1 != (undefined4 *)0x0) {\n      DAT_00240d70 = *puVar1;\n      DAT_00240d6c = puVar1[1];\n      DAT_00240d68 = puVar1[2];\n      current_token = puVar1[3];\n      sh_xfree(puVar1,\"/usr/local/src/chet/src/bash/src/parse.y\",0x19d7);\n    }\n    DAT_00240d8c = param_1[9];\n    eof_encountered = param_1[10];\n    DAT_00240b34 = param_1[0xb];\n    prompt_string_pointer = *(undefined8 *)(param_1 + 0xc);\n    current_command_line_count = param_1[0xe];\n    remember_on_history = param_1[0xf];\n    history_expansion_inhibited = param_1[0x10];\n    last_command_exit_value = param_1[0x11];\n    restore_pipestatus_array(*(undefined8 *)(param_1 + 0x12));\n    last_shell_builtin = *(undefined8 *)(param_1 + 0x14);\n    here_doc_first_line = param_1[0x1b];\n    this_shell_builtin = *(undefined8 *)(param_1 + 0x16);\n    DAT_00240b1c = param_1[0x1c];\n    expand_aliases = param_1[0x18];\n    DAT_00240b18 = param_1[0x1d];\n    echo_input_at_read = param_1[0x19];\n    need_here_doc = param_1[0x1a];\n    if (need_here_doc == 0) {\n      DAT_00240dc0 = 0;\n    }\n    else {\n      DAT_00240dc0 = *(undefined8 *)(param_1 + 0x20);\n      DAT_00240dc8 = *(undefined8 *)(param_1 + 0x22);\n      _DAT_00240dd0 = param_1[0x24];\n      uRam0000000000240dd4 = param_1[0x25];\n      uRam0000000000240dd8 = param_1[0x26];\n      uRam0000000000240ddc = param_1[0x27];\n      _DAT_00240de0 = param_1[0x28];\n      uRam0000000000240de4 = param_1[0x29];\n      uRam0000000000240de8 = param_1[0x2a];\n      uRam0000000000240dec = param_1[0x2b];\n      _DAT_00240df0 = param_1[0x2c];\n      uRam0000000000240df4 = param_1[0x2d];\n      uRam0000000000240df8 = param_1[0x2e];\n      uRam0000000000240dfc = param_1[0x2f];\n      _DAT_00240e00 = param_1[0x30];\n      uRam0000000000240e04 = param_1[0x31];\n      uRam0000000000240e08 = param_1[0x32];\n      uRam0000000000240e0c = param_1[0x33];\n      _DAT_00240e10 = param_1[0x34];\n      uRam0000000000240e14 = param_1[0x35];\n      uRam0000000000240e18 = param_1[0x36];\n      uRam0000000000240e1c = param_1[0x37];\n      _DAT_00240e20 = param_1[0x38];\n      uRam0000000000240e24 = param_1[0x39];\n      uRam0000000000240e28 = param_1[0x3a];\n      uRam0000000000240e2c = param_1[0x3b];\n      _DAT_00240e30 = param_1[0x3c];\n      uRam0000000000240e34 = param_1[0x3d];\n      uRam0000000000240e38 = param_1[0x3e];\n      uRam0000000000240e3c = param_1[0x3f];\n    }\n    pushed_string_list = *(undefined8 *)(param_1 + 0x1e);\n    if (DAT_00240b28 != 0) {\n      sh_xfree(DAT_00240b28,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1a07);\n    }\n    DAT_00240b28 = *(undefined8 *)(param_1 + 4);\n    DAT_00240b20 = *(undefined8 *)(param_1 + 6);\n    shell_eof_token = param_1[8];\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001da870": "\nint FUN_001da870(char *param_1)\n\n{\n  int iVar1;\n  \n  if ((param_1 == (char *)0x0) || (*param_1 == '\\0')) {\n    _rl_bell_preference = 1;\n    return 0;\n  }\n  iVar1 = strcasecmp(param_1,\"none\");\n  if ((iVar1 != 0) && (iVar1 = strcasecmp(param_1,\"off\"), iVar1 != 0)) {\n    iVar1 = strcasecmp(param_1,\"audible\");\n    if (iVar1 == 0) {\n      _rl_bell_preference = 1;\n      return 0;\n    }\n    iVar1 = strcasecmp(param_1,\"on\");\n    if (iVar1 == 0) {\n      _rl_bell_preference = 1;\n      return 0;\n    }\n    iVar1 = strcasecmp(param_1,\"visible\");\n    if (iVar1 != 0) {\n      return 1;\n    }\n    _rl_bell_preference = 2;\n    return iVar1;\n  }\n  _rl_bell_preference = 0;\n  return 0;\n}\n\n",
  "rl_macro_dumper": "\nvoid rl_macro_dumper(undefined8 param_1)\n\n{\n  FUN_001dc2f0(param_1,_rl_keymap,0);\n  return;\n}\n\n",
  "yyparse": "\nuint yyparse(void)\n\n{\n  undefined4 uVar1;\n  ulong *puVar2;\n  long lVar3;\n  short sVar4;\n  int iVar5;\n  short *psVar6;\n  ulong **ppuVar7;\n  ulong *puVar8;\n  undefined8 uVar9;\n  ulong **ppuVar10;\n  ulong uVar11;\n  ulong **ppuVar12;\n  uint uVar13;\n  long lVar14;\n  short *__src;\n  long lVar15;\n  short *psVar16;\n  int iVar17;\n  ulong **ppuVar18;\n  uint uVar19;\n  long lVar20;\n  ulong *puVar21;\n  long lVar22;\n  long in_FS_OFFSET;\n  ulong **local_e98;\n  ulong local_e78;\n  ulong local_e70;\n  short local_e58 [200];\n  ulong *local_cc8 [401];\n  long local_40;\n  \n  lVar22 = 0;\n  lVar14 = 200;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e98 = local_cc8;\n  yychar = -2;\n  local_e58[0] = 0;\n  iVar17 = 0;\n  psVar16 = local_e58;\n  ppuVar18 = local_e98;\n  __src = local_e58;\n  do {\n    uVar19 = (uint)(short)(&DAT_001fbfe0)[lVar22];\n    if (uVar19 != 0xffffff68) {\n      if (yychar == -2) {\n        iVar5 = DAT_00240b58;\n        if ((interactive == 0) || ((current_token != 0 && (current_token != 10)))) {\nLAB_0013e5aa:\n          DAT_00240d68 = DAT_00240d6c;\n          DAT_00240d6c = DAT_00240d70;\n          DAT_00240d70 = current_token;\n          if (iVar5 == 0) goto LAB_0013e5d0;\nLAB_0013e699:\n          uVar9 = DAT_00240b50;\n          if (iVar5 - 0x119U < 2) {\n            DAT_00240b50 = 0;\n            yylval = uVar9;\n          }\n          DAT_00240b58 = 0;\n        }\n        else {\n          if (((prompt_string_pointer != &ps1_prompt) &&\n              (prompt_string_pointer != (undefined8 *)0x0)) || (parse_and_execute_level != 0)) {\n            if (DAT_00240b58 != 0) goto LAB_0013e67b;\nLAB_00140860:\n            if ((bash_input - 1U < 2) &&\n               ((pushed_string_list == 0 || (*(long *)(pushed_string_list + 0x18) == 0)))) {\n              FUN_001373e0();\n              iVar5 = DAT_00240b58;\n            }\n            else {\n              iVar5 = 0;\n            }\n            goto LAB_0013e5aa;\n          }\n          iVar5 = time_to_check_mail();\n          if (iVar5 != 0) {\n            check_mail();\n            reset_mail_timer();\n          }\n          if (DAT_00240b58 != 0) {\nLAB_0013e67b:\n            DAT_00240d68 = DAT_00240d6c;\n            DAT_00240d6c = DAT_00240d70;\n            iVar5 = DAT_00240b58;\n            DAT_00240d70 = current_token;\n            goto LAB_0013e699;\n          }\n          if (interactive != 0) goto LAB_00140860;\n          DAT_00240d68 = DAT_00240d6c;\n          DAT_00240d6c = DAT_00240d70;\n          DAT_00240d70 = current_token;\nLAB_0013e5d0:\n          current_token = DAT_00240d70;\n          iVar5 = FUN_0013a230();\n        }\n        yychar = iVar5;\n        current_token = iVar5;\n        if ((((parser_state & 0x8000) != 0) && (shell_eof_token == iVar5)) || (-1 < iVar5))\n        goto LAB_0013e1df;\n        current_token = 0x100;\nLAB_0013e6ee:\n        yychar = 0x101;\n        goto LAB_0013e29f;\n      }\nLAB_0013e1df:\n      if (yychar < 1) {\n        yychar = 0;\n        iVar5 = 0;\n        uVar13 = uVar19;\n      }\n      else {\n        if (yychar == 0x100) goto LAB_0013e6ee;\n        if (yychar < 0x132) {\n          iVar5 = (int)(char)(&DAT_001fc2a0)[yychar];\n          uVar13 = uVar19 + iVar5;\n        }\n        else {\n          iVar5 = 2;\n          uVar13 = uVar19 + 2;\n        }\n      }\n      if ((0x2e4 < uVar13) || (*(short *)(&DAT_001fb200 + (long)(int)uVar13 * 2) != iVar5))\n      goto LAB_0013e220;\n      sVar4 = *(short *)(&DAT_001fb7e0 + (long)(int)uVar13 * 2);\n      lVar22 = (long)sVar4;\n      uVar13 = -(int)sVar4;\n      if (sVar4 < 1) goto LAB_0013e36c;\n      yychar = -2;\n      *(int *)(ppuVar18 + 2) = (int)yylval;\n      *(int *)((long)ppuVar18 + 0x14) = yylval._4_4_;\n      *(int *)(ppuVar18 + 3) = iRam0000000000240a98;\n      *(int *)((long)ppuVar18 + 0x1c) = iRam0000000000240a9c;\n      iVar17 = iVar17 + -1 + (uint)(iVar17 == 0);\n      ppuVar7 = ppuVar18 + 2;\n      goto LAB_0013e428;\n    }\nLAB_0013e220:\n    uVar13 = (uint)(byte)(&DAT_001fbe80)[lVar22];\n    if ((&DAT_001fbe80)[lVar22] == 0) {\n      if (iVar17 == 0) {\n        yynerrs = yynerrs + 1;\n        if ((parser_state & 0x800000) == 0) {\n          FUN_00135180();\n        }\n        reset_parser();\n      }\n      else if (iVar17 == 3) {\n        if (yychar < 1) {\n          if (yychar == 0) {\n            uVar19 = 1;\n            goto LAB_0013e2d2;\n          }\n        }\n        else {\n          yychar = -2;\n        }\n      }\nLAB_0013e29f:\n      while ((uVar19 == 0xffffff68 || (uVar19 = uVar19 + 1, 0x2e4 < uVar19))) {\nLAB_0013e288:\n        if (psVar16 == __src) goto LAB_0013e2cc;\nLAB_0013e28d:\n        psVar6 = psVar16 + -1;\n        psVar16 = psVar16 + -1;\n        ppuVar18 = ppuVar18 + -2;\n        uVar19 = (uint)(short)(&DAT_001fbfe0)[*psVar6];\n      }\n      if (*(short *)(&DAT_001fb200 + (long)(int)uVar19 * 2) == 1) {\n        sVar4 = *(short *)(&DAT_001fb7e0 + (long)(int)uVar19 * 2);\n        lVar22 = (long)sVar4;\n        if (sVar4 < 1) goto LAB_0013e288;\n        iVar17 = 3;\n        ppuVar7 = ppuVar18 + 2;\n        *(int *)ppuVar7 = (int)yylval;\n        *(int *)((long)ppuVar18 + 0x14) = yylval._4_4_;\n        *(int *)(ppuVar18 + 3) = iRam0000000000240a98;\n        *(int *)((long)ppuVar18 + 0x1c) = iRam0000000000240a9c;\n        goto LAB_0013e428;\n      }\n      if (psVar16 != __src) goto LAB_0013e28d;\nLAB_0013e2cc:\n      uVar19 = 1;\n      __src = psVar16;\n      goto LAB_0013e2d2;\n    }\nLAB_0013e36c:\n    lVar22 = (long)(char)(&DAT_001fb080)[(int)uVar13];\n    ppuVar7 = (ulong **)ppuVar18[(long)(1 - (char)(&DAT_001fb080)[(int)uVar13]) * 2];\n    puVar21 = (ppuVar18 + (long)(1 - (char)(&DAT_001fb080)[(int)uVar13]) * 2)[1];\n    switch(uVar13) {\n    case 2:\n      global_command = ppuVar18[-2];\n      eof_encountered = 0;\n      goto LAB_0013ed40;\n    case 3:\n      global_command = *ppuVar18;\n      uVar19 = 0;\n      eof_encountered = 0;\n      goto LAB_0013e2d2;\n    case 4:\n      global_command = (ulong *)0x0;\nLAB_0013ed40:\n      uVar19 = parser_state & 0x40;\n      if (uVar19 != 0) {\n        parser_state = parser_state | 0x8000;\n        uVar19 = 0;\n      }\n      goto LAB_0013e2d2;\n    case 5:\n      global_command = (ulong *)0x0;\n      eof_encountered = 0;\n      if (interactive == 0) goto LAB_0013f358;\n      uVar19 = (uint)(parse_and_execute_level != 0);\n      goto LAB_0013e2d2;\n    case 6:\n      global_command = (ulong *)0x0;\n      if (last_command_exit_value == 0) {\n        last_command_exit_value = 2;\n      }\n      if ((interactive == 0) || (parse_and_execute_level != 0)) {\nLAB_0013f358:\n        global_command = (ulong *)0x0;\n        uVar19 = 1;\n      }\n      else {\n        FUN_00137850();\n        uVar19 = 0;\n      }\n      goto LAB_0013e2d2;\n    case 7:\n      global_command = (ulong *)0x0;\n      uVar19 = 0;\n      FUN_00137850();\n      goto LAB_0013e2d2;\n    case 8:\n    case 0x87:\n      ppuVar7 = (ulong **)make_word_list(*ppuVar18,0);\n      break;\n    case 9:\n      ppuVar7 = (ulong **)make_word_list(*ppuVar18,ppuVar18[-2]);\n      break;\n    case 10:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,1);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0,DAT_00240b40,0);\n      break;\n    case 0xb:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)((ulong)DAT_00240b48._4_4_ << 0x20);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,1,DAT_00240b40,0);\n      break;\n    case 0xc:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0,DAT_00240b40,0);\n      break;\n    case 0xd:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,1,DAT_00240b40,0);\n      break;\n    case 0xe:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = *ppuVar18;\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0,DAT_00240b40,1);\n      break;\n    case 0xf:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = *ppuVar18;\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,1,DAT_00240b40,1);\n      break;\n    case 0x10:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,1);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,3,DAT_00240b40,0);\n      break;\n    case 0x11:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,3,DAT_00240b40,0);\n      break;\n    case 0x12:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = *ppuVar18;\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,3,DAT_00240b40,1);\n      break;\n    case 0x13:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,1);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xc,DAT_00240b40,0);\n      break;\n    case 0x14:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xc,DAT_00240b40,0);\n      break;\n    case 0x15:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = *ppuVar18;\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xc,DAT_00240b40,1);\n      break;\n    case 0x16:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)((ulong)DAT_00240b48._4_4_ << 0x20);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xb,DAT_00240b40,0);\n      break;\n    case 0x17:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xb,DAT_00240b40,0);\n      break;\n    case 0x18:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = *ppuVar18;\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xb,DAT_00240b40,1);\n      break;\n    case 0x19:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)((ulong)DAT_00240b48._4_4_ << 0x20);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,4,DAT_00240b40,0);\n      FUN_00136330(ppuVar7);\n      break;\n    case 0x1a:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,4,DAT_00240b40,0);\n      FUN_00136330(ppuVar7);\n      break;\n    case 0x1b:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = *ppuVar18;\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,4,DAT_00240b40,1);\n      FUN_00136330(ppuVar7);\n      break;\n    case 0x1c:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)((ulong)DAT_00240b48._4_4_ << 0x20);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,8,DAT_00240b40,0);\n      FUN_00136330(ppuVar7);\n      break;\n    case 0x1d:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,8,DAT_00240b40,0);\n      FUN_00136330(ppuVar7);\n      break;\n    case 0x1e:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = *ppuVar18;\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,8,DAT_00240b40,1);\n      FUN_00136330(ppuVar7);\n      break;\n    case 0x1f:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)((ulong)DAT_00240b48._4_4_ << 0x20);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,5,DAT_00240b40,0);\n      break;\n    case 0x20:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,5,DAT_00240b40,0);\n      break;\n    case 0x21:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = *ppuVar18;\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,5,DAT_00240b40,1);\n      break;\n    case 0x22:\n      DAT_00240b48 = (ulong *)((ulong)DAT_00240b48._4_4_ << 0x20);\n      DAT_00240b40 = (ulong *)CONCAT44(DAT_00240b40._4_4_,*(int *)ppuVar18);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,6,DAT_00240b40,0);\n      break;\n    case 0x23:\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      DAT_00240b40 = (ulong *)CONCAT44(DAT_00240b40._4_4_,*(int *)ppuVar18);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,6,DAT_00240b40,0);\n      break;\n    case 0x24:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = (ulong *)CONCAT44(DAT_00240b40._4_4_,*(int *)ppuVar18);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,6,DAT_00240b40,1);\n      break;\n    case 0x25:\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,1);\n      DAT_00240b40 = (ulong *)CONCAT44(DAT_00240b40._4_4_,*(int *)ppuVar18);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,7,DAT_00240b40,0);\n      break;\n    case 0x26:\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      DAT_00240b40 = (ulong *)CONCAT44(DAT_00240b40._4_4_,*(int *)ppuVar18);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,7,DAT_00240b40,0);\n      break;\n    case 0x27:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = (ulong *)CONCAT44(DAT_00240b40._4_4_,*(int *)ppuVar18);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,7,DAT_00240b40,1);\n      break;\n    case 0x28:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)((ulong)DAT_00240b48._4_4_ << 0x20);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xd,DAT_00240b40,0);\n      break;\n    case 0x29:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xd,DAT_00240b40,0);\n      break;\n    case 0x2a:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = *ppuVar18;\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xd,DAT_00240b40,1);\n      break;\n    case 0x2b:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,1);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xe,DAT_00240b40,0);\n      break;\n    case 0x2c:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xe,DAT_00240b40,0);\n      break;\n    case 0x2d:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = *ppuVar18;\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0xe,DAT_00240b40,1);\n      break;\n    case 0x2e:\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,1);\n      DAT_00240b40 = (ulong *)((ulong)DAT_00240b40._4_4_ << 0x20);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,9,DAT_00240b40,0);\n      break;\n    case 0x2f:\n      DAT_00240b40 = (ulong *)((ulong)DAT_00240b40._4_4_ << 0x20);\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,9,DAT_00240b40,0);\n      break;\n    case 0x30:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = (ulong *)((ulong)DAT_00240b40._4_4_ << 0x20);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,9,DAT_00240b40,1);\n      break;\n    case 0x31:\n      DAT_00240b48 = (ulong *)((ulong)DAT_00240b48._4_4_ << 0x20);\n      DAT_00240b40 = (ulong *)((ulong)DAT_00240b40._4_4_ << 0x20);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,9,DAT_00240b40,0);\n      break;\n    case 0x32:\n      DAT_00240b40 = (ulong *)((ulong)DAT_00240b40._4_4_ << 0x20);\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,*(int *)(ppuVar18 + -4));\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,9,DAT_00240b40,0);\n      break;\n    case 0x33:\n      DAT_00240b48 = ppuVar18[-4];\n      DAT_00240b40 = (ulong *)((ulong)DAT_00240b40._4_4_ << 0x20);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,9,DAT_00240b40,1);\n      break;\n    case 0x34:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,1);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,10,DAT_00240b40,0);\n      break;\n    case 0x35:\n      DAT_00240b40 = *ppuVar18;\n      DAT_00240b48 = (ulong *)CONCAT44(DAT_00240b48._4_4_,1);\n      ppuVar7 = (ulong **)make_redirection(DAT_00240b48,0x13,DAT_00240b40,0);\n      break;\n    case 0x36:\n      ppuVar7 = (ulong **)*ppuVar18;\n      puVar21 = (ulong *)0x0;\n      break;\n    case 0x37:\n      ppuVar7 = (ulong **)*ppuVar18;\n      puVar21 = (ulong *)0x0;\n      break;\n    case 0x38:\n      puVar21 = *ppuVar18;\n      ppuVar7 = (ulong **)0x0;\n      break;\n    case 0x39:\n      ppuVar7 = (ulong **)*ppuVar18;\n      break;\n    case 0x3a:\n      ppuVar7 = (ulong **)ppuVar18[-2];\n      ppuVar12 = ppuVar7;\n      do {\n        ppuVar10 = ppuVar12;\n        ppuVar12 = (ulong **)*ppuVar10;\n      } while (ppuVar12 != (ulong **)0x0);\n      *ppuVar10 = *ppuVar18;\n      break;\n    case 0x3b:\n      ppuVar7 = (ulong **)make_simple_command(*ppuVar18,ppuVar18[1],0);\n      break;\n    case 0x3c:\n      ppuVar7 = (ulong **)make_simple_command(*ppuVar18,ppuVar18[1],ppuVar18[-2]);\n      break;\n    case 0x3d:\n      ppuVar7 = (ulong **)clean_simple_command(*ppuVar18);\n      break;\n    case 0x3e:\n    case 0x40:\n    case 0x41:\n    case 0x42:\n    case 0x43:\n    case 0x46:\n    case 0x47:\n    case 0x48:\n    case 0x49:\n    case 0x4a:\n    case 0x4b:\n    case 0x4c:\n    case 0x68:\n    case 0x8a:\n    case 0x93:\n    case 0xa2:\n    case 0xa3:\n    case 0xaa:\n      ppuVar7 = (ulong **)*ppuVar18;\n      break;\n    case 0x3f:\n      ppuVar7 = (ulong **)ppuVar18[-2];\n      if (ppuVar7 != (ulong **)0x0) {\n        ppuVar12 = (ulong **)ppuVar7[2];\n        if ((ulong **)ppuVar7[2] == (ulong **)0x0) {\n          ppuVar7[2] = *ppuVar18;\n        }\n        else {\n          do {\n            ppuVar10 = ppuVar12;\n            ppuVar12 = (ulong **)*ppuVar10;\n          } while (ppuVar12 != (ulong **)0x0);\n          *ppuVar10 = *ppuVar18;\n        }\n      }\n      break;\n    case 0x44:\n      ppuVar7 = (ulong **)make_while_command(ppuVar18[-6],ppuVar18[-2]);\n      break;\n    case 0x45:\n      ppuVar7 = (ulong **)make_until_command(ppuVar18[-6],ppuVar18[-2]);\n      break;\n    case 0x4d:\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar8 = ppuVar18[-2];\n      uVar9 = make_word(&DAT_001faaed);\n      uVar9 = make_word_list(uVar9,0);\n      ppuVar7 = (ulong **)make_for_command(ppuVar18[-8],uVar9,puVar8,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x4e:\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar8 = ppuVar18[-2];\n      uVar9 = make_word(&DAT_001faaed);\n      uVar9 = make_word_list(uVar9,0);\n      ppuVar7 = (ulong **)make_for_command(ppuVar18[-8],uVar9,puVar8,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x4f:\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar8 = ppuVar18[-2];\n      uVar9 = make_word(&DAT_001faaed);\n      uVar9 = make_word_list(uVar9,0);\n      ppuVar7 = (ulong **)make_for_command(ppuVar18[-10],uVar9,puVar8,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x50:\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar8 = ppuVar18[-2];\n      uVar9 = make_word(&DAT_001faaed);\n      uVar9 = make_word_list(uVar9,0);\n      ppuVar7 = (ulong **)make_for_command(ppuVar18[-10],uVar9,puVar8,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x51:\n      puVar8 = ppuVar18[-10];\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar2 = ppuVar18[-2];\n      if ((puVar8 != (ulong *)0x0) && (*puVar8 != 0)) {\n        puVar8 = (ulong *)list_reverse(puVar8);\n      }\n      ppuVar7 = (ulong **)make_for_command(ppuVar18[-0x10],puVar8,puVar2,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x52:\n      puVar8 = ppuVar18[-10];\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar2 = ppuVar18[-2];\n      if ((puVar8 != (ulong *)0x0) && (*puVar8 != 0)) {\n        puVar8 = (ulong *)list_reverse(puVar8);\n      }\n      ppuVar7 = (ulong **)make_for_command(ppuVar18[-0x10],puVar8,puVar2,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x53:\n      ppuVar7 = (ulong **)\n                make_for_command(ppuVar18[-0xe],0,ppuVar18[-2],(&DAT_00240b60)[DAT_00238074]);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x54:\n      ppuVar7 = (ulong **)\n                make_for_command(ppuVar18[-0xe],0,ppuVar18[-2],(&DAT_00240b60)[DAT_00238074]);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x55:\n      ppuVar7 = (ulong **)make_arith_for_command(ppuVar18[-10],ppuVar18[-2],DAT_00240d80);\n      if (ppuVar7 == (ulong **)0x0) {\nLAB_0014091c:\n        yynerrs = yynerrs + 1;\n        psVar16 = psVar16 + -lVar22;\n        ppuVar18 = ppuVar18 + lVar22 * -2;\n        uVar19 = (uint)(short)(&DAT_001fbfe0)[*psVar16];\n        goto LAB_0013e29f;\n      }\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x56:\n      ppuVar7 = (ulong **)make_arith_for_command(ppuVar18[-10],ppuVar18[-2],DAT_00240d80);\n      if (ppuVar7 == (ulong **)0x0) goto LAB_0014091c;\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x57:\n      ppuVar7 = (ulong **)make_arith_for_command(ppuVar18[-6],ppuVar18[-2],DAT_00240d80);\n      if (ppuVar7 == (ulong **)0x0) goto LAB_0014091c;\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x58:\n      ppuVar7 = (ulong **)make_arith_for_command(ppuVar18[-6],ppuVar18[-2],DAT_00240d80);\n      if (ppuVar7 == (ulong **)0x0) goto LAB_0014091c;\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x59:\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar8 = ppuVar18[-2];\n      uVar9 = make_word(&DAT_001faaed);\n      uVar9 = make_word_list(uVar9,0);\n      ppuVar7 = (ulong **)make_select_command(ppuVar18[-8],uVar9,puVar8,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x5a:\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar8 = ppuVar18[-2];\n      uVar9 = make_word(&DAT_001faaed);\n      uVar9 = make_word_list(uVar9,0);\n      ppuVar7 = (ulong **)make_select_command(ppuVar18[-8],uVar9,puVar8,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x5b:\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar8 = ppuVar18[-2];\n      uVar9 = make_word(&DAT_001faaed);\n      uVar9 = make_word_list(uVar9,0);\n      ppuVar7 = (ulong **)make_select_command(ppuVar18[-10],uVar9,puVar8,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x5c:\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar8 = ppuVar18[-2];\n      uVar9 = make_word(&DAT_001faaed);\n      uVar9 = make_word_list(uVar9,0);\n      ppuVar7 = (ulong **)make_select_command(ppuVar18[-10],uVar9,puVar8,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x5d:\n      puVar8 = ppuVar18[-10];\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar2 = ppuVar18[-2];\n      if ((puVar8 != (ulong *)0x0) && (*puVar8 != 0)) {\n        puVar8 = (ulong *)list_reverse(puVar8);\n      }\n      ppuVar7 = (ulong **)make_select_command(ppuVar18[-0x10],puVar8,puVar2,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x5e:\n      puVar8 = ppuVar18[-10];\n      uVar1 = (&DAT_00240b60)[DAT_00238074];\n      puVar2 = ppuVar18[-2];\n      if ((puVar8 != (ulong *)0x0) && (*puVar8 != 0)) {\n        puVar8 = (ulong *)list_reverse(puVar8);\n      }\n      ppuVar7 = (ulong **)make_select_command(ppuVar18[-0x10],puVar8,puVar2,uVar1);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x5f:\n      ppuVar7 = (ulong **)\n                make_select_command(ppuVar18[-0xe],0,ppuVar18[-2],(&DAT_00240b60)[DAT_00238074]);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x60:\n      ppuVar7 = (ulong **)\n                make_select_command(ppuVar18[-0xe],0,ppuVar18[-2],(&DAT_00240b60)[DAT_00238074]);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x61:\n      ppuVar7 = (ulong **)make_case_command(ppuVar18[-8],0,(&DAT_00240b60)[DAT_00238074]);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 0x62:\n      ppuVar7 = (ulong **)\n                make_case_command(ppuVar18[-10],ppuVar18[-4],(&DAT_00240b60)[DAT_00238074]);\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 99:\n      ppuVar7 = (ulong **)make_case_command(ppuVar18[-8],ppuVar18[-2],(&DAT_00240b60)[DAT_00238074])\n      ;\n      if (0 < DAT_00238074) {\n        DAT_00238074 = DAT_00238074 + -1;\n      }\n      break;\n    case 100:\n    case 0x65:\n      ppuVar7 = (ulong **)make_function_def(ppuVar18[-8],*ppuVar18,DAT_00240d88,DAT_00240d84);\n      break;\n    case 0x66:\n      ppuVar7 = (ulong **)make_function_def(ppuVar18[-2],*ppuVar18,DAT_00240d88,DAT_00240d84);\n      break;\n    case 0x67:\n      ppuVar7 = (ulong **)make_function_def(ppuVar18[-6],*ppuVar18,DAT_00240d88,DAT_00240d84);\n      break;\n    case 0x69:\n      ppuVar7 = (ulong **)ppuVar18[-2];\n      if (ppuVar7 != (ulong **)0x0) {\n        ppuVar12 = (ulong **)ppuVar7[2];\n        if ((ulong **)ppuVar7[2] == (ulong **)0x0) {\n          ppuVar7[2] = *ppuVar18;\n        }\n        else {\n          do {\n            ppuVar10 = ppuVar12;\n            ppuVar12 = (ulong **)*ppuVar10;\n          } while (ppuVar12 != (ulong **)0x0);\n          *ppuVar10 = *ppuVar18;\n        }\n      }\n      break;\n    case 0x6a:\n      ppuVar7 = (ulong **)make_subshell_command(ppuVar18[-2]);\n      *(uint *)((long)ppuVar7 + 4) = *(uint *)((long)ppuVar7 + 4) | 1;\n      break;\n    case 0x6b:\n    case 0x77:\n      ppuVar7 = (ulong **)ppuVar18[-2];\n      break;\n    case 0x6c:\n      ppuVar7 = (ulong **)0x0;\n      break;\n    case 0x6d:\n      ppuVar7 = (ulong **)make_coproc_command(\"COPROC\",*ppuVar18);\n      *(uint *)((long)ppuVar7 + 4) = *(uint *)((long)ppuVar7 + 4) | 0x1001;\n      break;\n    case 0x6e:\n      puVar8 = ppuVar18[-2];\n      if (puVar8 != (ulong *)0x0) {\n        ppuVar7 = (ulong **)puVar8[2];\n        if ((ulong **)puVar8[2] == (ulong **)0x0) {\n          puVar8[2] = (ulong)*ppuVar18;\n        }\n        else {\n          do {\n            ppuVar12 = ppuVar7;\n            ppuVar7 = (ulong **)*ppuVar12;\n          } while (ppuVar7 != (ulong **)0x0);\n          *ppuVar12 = *ppuVar18;\n        }\n      }\n      ppuVar7 = (ulong **)make_coproc_command(\"COPROC\");\n      *(uint *)((long)ppuVar7 + 4) = *(uint *)((long)ppuVar7 + 4) | 0x1001;\n      break;\n    case 0x6f:\n      ppuVar7 = (ulong **)make_coproc_command(*ppuVar18[-2],*ppuVar18);\n      *(uint *)((long)ppuVar7 + 4) = *(uint *)((long)ppuVar7 + 4) | 0x1001;\n      break;\n    case 0x70:\n      puVar8 = ppuVar18[-2];\n      if (puVar8 != (ulong *)0x0) {\n        ppuVar7 = (ulong **)puVar8[2];\n        if ((ulong **)puVar8[2] == (ulong **)0x0) {\n          puVar8[2] = (ulong)*ppuVar18;\n        }\n        else {\n          do {\n            ppuVar12 = ppuVar7;\n            ppuVar7 = (ulong **)*ppuVar12;\n          } while (ppuVar7 != (ulong **)0x0);\n          *ppuVar12 = *ppuVar18;\n        }\n      }\n      ppuVar7 = (ulong **)make_coproc_command(*ppuVar18[-4]);\n      *(uint *)((long)ppuVar7 + 4) = *(uint *)((long)ppuVar7 + 4) | 0x1001;\n      break;\n    case 0x71:\n      uVar9 = clean_simple_command(*ppuVar18);\n      ppuVar7 = (ulong **)make_coproc_command(\"COPROC\",uVar9);\n      *(uint *)((long)ppuVar7 + 4) = *(uint *)((long)ppuVar7 + 4) | 0x1001;\n      break;\n    case 0x72:\n      ppuVar7 = (ulong **)make_if_command(ppuVar18[-6],ppuVar18[-2],0);\n      break;\n    case 0x73:\n      ppuVar7 = (ulong **)make_if_command(ppuVar18[-10],ppuVar18[-6],ppuVar18[-2]);\n      break;\n    case 0x74:\n      ppuVar7 = (ulong **)make_if_command(ppuVar18[-8],ppuVar18[-4],ppuVar18[-2]);\n      break;\n    case 0x75:\n      ppuVar7 = (ulong **)make_group_command(ppuVar18[-2]);\n      break;\n    case 0x76:\n      ppuVar7 = (ulong **)make_arith_command(*ppuVar18);\n      break;\n    case 0x78:\n      ppuVar7 = (ulong **)make_if_command(ppuVar18[-4],*ppuVar18,0);\n      break;\n    case 0x79:\n      ppuVar7 = (ulong **)make_if_command(ppuVar18[-8],ppuVar18[-4],*ppuVar18);\n      break;\n    case 0x7a:\n      ppuVar7 = (ulong **)make_if_command(ppuVar18[-6],ppuVar18[-2],*ppuVar18);\n      break;\n    case 0x7c:\n      ppuVar7 = (ulong **)*ppuVar18;\n      *ppuVar7 = ppuVar18[-2];\n      break;\n    case 0x7d:\n    case 0x7f:\n      ppuVar7 = (ulong **)make_pattern_list(ppuVar18[-4],*ppuVar18);\n      break;\n    case 0x7e:\n    case 0x80:\n      ppuVar7 = (ulong **)make_pattern_list(ppuVar18[-4],0);\n      break;\n    case 0x81:\n      ppuVar7 = (ulong **)ppuVar18[-2];\n      break;\n    case 0x82:\n      ppuVar7 = (ulong **)ppuVar18[-2];\n      *ppuVar7 = ppuVar18[-4];\n      break;\n    case 0x83:\n      ppuVar7 = (ulong **)ppuVar18[-2];\n      *(uint *)(ppuVar7 + 3) = *(uint *)(ppuVar7 + 3) | 1;\n      break;\n    case 0x84:\n      ppuVar7 = (ulong **)ppuVar18[-2];\n      puVar8 = ppuVar18[-4];\n      *(uint *)(ppuVar7 + 3) = *(uint *)(ppuVar7 + 3) | 1;\n      *ppuVar7 = puVar8;\n      break;\n    case 0x85:\n      ppuVar7 = (ulong **)ppuVar18[-2];\n      *(uint *)(ppuVar7 + 3) = *(uint *)(ppuVar7 + 3) | 2;\n      break;\n    case 0x86:\n      ppuVar7 = (ulong **)ppuVar18[-2];\n      puVar8 = ppuVar18[-4];\n      *(uint *)(ppuVar7 + 3) = *(uint *)(ppuVar7 + 3) | 2;\n      *ppuVar7 = puVar8;\n      break;\n    case 0x88:\n      ppuVar7 = (ulong **)make_word_list(*ppuVar18,ppuVar18[-4]);\n      break;\n    case 0x89:\n      ppuVar7 = (ulong **)*ppuVar18;\n      if ((need_here_doc != 0) && (DAT_00240d70 == 10)) {\n        gather_here_documents();\n      }\n      break;\n    case 0x8c:\n      if (*(int *)ppuVar18[-4] == 6) {\n        ppuVar7 = (ulong **)connect_async_list(ppuVar18[-4],0,0x26);\n      }\n      else {\n        ppuVar7 = (ulong **)command_connect();\n      }\n      break;\n    case 0x8e:\n    case 0x9e:\n      ppuVar7 = (ulong **)command_connect(ppuVar18[-6],*ppuVar18,0x120);\n      break;\n    case 0x8f:\n    case 0x9f:\n      ppuVar7 = (ulong **)command_connect(ppuVar18[-6],*ppuVar18,0x121);\n      break;\n    case 0x90:\n      if (*(int *)ppuVar18[-6] == 6) {\n        ppuVar7 = (ulong **)connect_async_list(ppuVar18[-6],*ppuVar18,0x26);\n      }\n      else {\n        ppuVar7 = (ulong **)command_connect();\n      }\n      break;\n    case 0x91:\n      ppuVar7 = (ulong **)command_connect(ppuVar18[-6],*ppuVar18,0x3b);\n      break;\n    case 0x92:\n      if ((parser_state & 0x40) == 0) {\n        ppuVar7 = (ulong **)command_connect(ppuVar18[-6],*ppuVar18,0x3b);\n      }\n      else {\n        ppuVar7 = (ulong **)command_connect(ppuVar18[-6],*ppuVar18,10);\n      }\n      break;\n    case 0x96:\n      ppuVar7 = (ulong **)((ulong)ppuVar7 & 0xffffffff00000000 | 10);\n      break;\n    case 0x97:\n      ppuVar7 = (ulong **)((ulong)ppuVar7 & 0xffffffff00000000 | 0x3b);\n      break;\n    case 0x98:\n      ppuVar7 = (ulong **)((ulong)ppuVar7 & 0xffffffff00000000 | 0x131);\n      break;\n    case 0x9b:\n      ppuVar7 = (ulong **)*ppuVar18;\n      if (need_here_doc != 0) {\n        gather_here_documents();\n      }\n      if (((parser_state & 0x40) == 0) || (current_token != shell_eof_token)) break;\n      global_command = *ppuVar18;\n      if (bash_input != 3) goto LAB_00140155;\n      goto LAB_001401e9;\n    case 0x9c:\n      if (*(int *)ppuVar18[-2] == 6) {\n        ppuVar7 = (ulong **)connect_async_list(ppuVar18[-2],0,0x26);\n      }\n      else {\n        ppuVar7 = (ulong **)command_connect();\n      }\n      goto LAB_00140103;\n    case 0x9d:\n      ppuVar7 = (ulong **)ppuVar18[-2];\nLAB_00140103:\n      if (need_here_doc != 0) {\n        gather_here_documents();\n      }\n      if (((parser_state & 0x40) != 0) && (current_token == shell_eof_token)) {\n        global_command = ppuVar18[-2];\n        if (bash_input == 3) {\nLAB_001401e9:\n          eof_encountered = 0;\n          rewind_input_string();\n          uVar19 = 0;\n        }\n        else {\nLAB_00140155:\n          eof_encountered = 0;\n          uVar19 = 0;\n        }\n        goto LAB_0013e2d2;\n      }\n      break;\n    case 0xa0:\n      if (*(int *)ppuVar18[-4] == 6) {\n        ppuVar7 = (ulong **)connect_async_list(ppuVar18[-4],*ppuVar18,0x26);\n      }\n      else {\n        ppuVar7 = (ulong **)command_connect();\n      }\n      break;\n    case 0xa1:\n      ppuVar7 = (ulong **)command_connect(ppuVar18[-4],*ppuVar18,0x3b);\n      break;\n    case 0xa4:\n      ppuVar7 = (ulong **)*ppuVar18;\n      if (ppuVar7 != (ulong **)0x0) {\n        *(uint *)((long)ppuVar7 + 4U) = *(uint *)((long)ppuVar7 + 4U) ^ 4;\n      }\n      break;\n    case 0xa5:\n      ppuVar7 = (ulong **)*ppuVar18;\n      if (ppuVar7 != (ulong **)0x0) {\n        *(uint *)((long)ppuVar7 + 4U) = *(uint *)((long)ppuVar7 + 4U) | *(uint *)(ppuVar18 + -2);\n      }\n      break;\n    case 0xa6:\n      ppuVar7 = (ulong **)make_simple_command(0,0,0);\n      *(uint *)((long)ppuVar7 + 4) = *(uint *)((long)ppuVar7 + 4) | *(uint *)(ppuVar18 + -2);\n      if (*(int *)ppuVar18 == 10) {\n        DAT_00240b58 = 10;\n      }\n      else if (*(int *)ppuVar18 == 0x3b) {\n        DAT_00240b58 = 0x3b;\n      }\n      parser_state = parser_state & 0xfff7ffff;\n      break;\n    case 0xa7:\n      ppuVar7 = (ulong **)make_simple_command(0,0,0);\n      *(uint *)((long)ppuVar7 + 4) = *(uint *)((long)ppuVar7 + 4) | 4;\n      if (*(int *)ppuVar18 == 10) {\n        DAT_00240b58 = 10;\n      }\n      else if (*(int *)ppuVar18 == 0x3b) {\n        DAT_00240b58 = 0x3b;\n      }\n      parser_state = parser_state & 0xfff7ffff;\n      break;\n    case 0xa8:\n      ppuVar7 = (ulong **)command_connect(ppuVar18[-6],*ppuVar18,0x7c);\n      break;\n    case 0xa9:\n      puVar8 = ppuVar18[-6];\n      if (*(int *)puVar8 == 4) {\n        puVar8 = (ulong *)puVar8[3];\n      }\n      local_e78 = local_e78 & 0xffffffff00000000 | 1;\n      local_e70 = local_e70 & 0xffffffff00000000 | 2;\n      uVar11 = make_redirection(local_e70,7,local_e78,0);\n      ppuVar7 = (ulong **)(ulong *)puVar8[2];\n      if ((ulong *)puVar8[2] == (ulong *)0x0) {\n        puVar8[2] = uVar11;\n      }\n      else {\n        do {\n          ppuVar12 = ppuVar7;\n          ppuVar7 = (ulong **)*ppuVar12;\n        } while (ppuVar7 != (ulong **)0x0);\n        *ppuVar12 = (ulong *)uVar11;\n      }\n      ppuVar7 = (ulong **)command_connect(ppuVar18[-6],*ppuVar18,0x7c);\n      break;\n    case 0xab:\n      ppuVar7 = (ulong **)CONCAT71((uint7)((ulong)ppuVar7 >> 8) & 0xffffffff000000,0x80);\n      break;\n    case 0xac:\n    case 0xad:\n    case 0xae:\n      ppuVar7 = (ulong **)((ulong)ppuVar7 & 0xffffffff00000000 | 0x180);\n    }\n    ppuVar18[lVar22 * -2 + 2] = (ulong *)ppuVar7;\n    ppuVar7 = ppuVar18 + lVar22 * -2 + 2;\n    psVar16 = psVar16 + -lVar22;\n    ppuVar18[lVar22 * -2 + 3] = puVar21;\n    uVar19 = (int)*(short *)(&DAT_001fbe20 + (long)((char)(&DAT_001fb140)[(int)uVar13] + -0x3e) * 2)\n             + (int)*psVar16;\n    if ((uVar19 < 0x2e5) && (*psVar16 == *(short *)(&DAT_001fb200 + (long)(int)uVar19 * 2))) {\n      sVar4 = *(short *)(&DAT_001fb7e0 + (long)(int)uVar19 * 2);\n      lVar22 = (long)sVar4;\n    }\n    else {\n      sVar4 = *(short *)(&DAT_001fbdc0 + (long)((char)(&DAT_001fb140)[(int)uVar13] + -0x3e) * 2);\n      lVar22 = (long)sVar4;\n    }\nLAB_0013e428:\n    psVar16[1] = sVar4;\n    lVar3 = lVar14 * 2;\n    psVar16 = psVar16 + 1;\n    psVar6 = __src;\n    if (__src + lVar14 + -1 <= psVar16) {\n      lVar15 = (long)psVar16 - (long)__src;\n      lVar20 = (lVar15 >> 1) + 1;\n      if (lVar14 < 10000) {\n        lVar14 = 10000;\n        if (lVar3 < 0x2711) {\n          lVar14 = lVar3;\n        }\n        psVar6 = (short *)sh_malloc(lVar14 * 0x12 + 0xf,\"y.tab.c\",0x70d);\n        if (psVar6 != (short *)0x0) {\n          memcpy(psVar6,__src,lVar15 + 2);\n          ppuVar18 = (ulong **)(psVar6 + lVar14);\n          memcpy(ppuVar18,local_e98,lVar20 * 0x10);\n          if (__src != local_e58) {\n            sh_xfree(__src,\"y.tab.c\",0x714);\n          }\n          psVar16 = (short *)(lVar15 + (long)psVar6);\n          ppuVar7 = ppuVar18 + lVar20 * 2 + -2;\n          local_e98 = ppuVar18;\n          if (psVar16 < psVar6 + lVar14 + -1) goto LAB_0013e517;\n          uVar19 = 1;\n          __src = psVar6;\n          goto LAB_0013e2d2;\n        }\n      }\n      if ((parser_state & 0x800000) == 0) {\n        FUN_00135180(0);\n      }\n      reset_parser();\n      uVar19 = 2;\n      goto LAB_0013e2d2;\n    }\nLAB_0013e517:\n    ppuVar18 = ppuVar7;\n    __src = psVar6;\n  } while ((int)lVar22 != 0x79);\n  uVar19 = 0;\nLAB_0013e2d2:\n  if (__src != local_e58) {\n    sh_xfree(__src,\"y.tab.c\",0xe52);\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar19;\n}\n\n",
  "string_rest_of_args": "\nundefined8 string_rest_of_args(int param_1)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = list_rest_of_args();\n  if (param_1 == 0) {\n    uVar2 = string_list_internal(uVar1,&DAT_001fdb1c);\n  }\n  else {\n    uVar2 = FUN_0016e2d0(uVar1);\n  }\n  dispose_words(uVar1);\n  return uVar2;\n}\n\n",
  "mbrtowc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_mbrtowc_002379f0)();\n  return sVar1;\n}\n\n",
  "history_expand": "\nulong history_expand(char *param_1,char **param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  char cVar3;\n  char cVar4;\n  char cVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  int iVar9;\n  char *pcVar10;\n  size_t sVar11;\n  char *pcVar12;\n  ulong uVar13;\n  char *pcVar14;\n  long lVar15;\n  undefined4 *puVar16;\n  undefined8 uVar17;\n  ulong uVar18;\n  char *pcVar19;\n  ulong uVar20;\n  long lVar21;\n  uint uVar22;\n  uint uVar23;\n  int iVar24;\n  int iVar25;\n  size_t __n;\n  byte bVar26;\n  uint uVar27;\n  uint uVar28;\n  int iVar29;\n  long in_FS_OFFSET;\n  bool bVar30;\n  bool bVar31;\n  uint local_ec;\n  char *local_e0;\n  char *local_d8;\n  uint local_c0;\n  int local_b8;\n  int local_b4;\n  char *local_b0;\n  int local_a0;\n  uint local_78;\n  uint local_74;\n  undefined4 local_70;\n  undefined8 local_6c;\n  undefined8 local_64;\n  char local_5b;\n  char local_5a;\n  undefined local_59;\n  undefined local_58 [16];\n  char local_48 [8];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 != (char **)0x0) {\n    if (history_expansion_char != '\\0') {\n      pcVar10 = (char *)xmalloc(0x100);\n      *pcVar10 = '\\0';\n      sVar11 = strlen(param_1);\n      local_ec = (uint)sVar11;\n      cVar5 = *param_1;\n      if (cVar5 == history_subst_char) {\n        pcVar12 = (char *)xmalloc((long)(int)(local_ec + 5));\n        cVar5 = history_expansion_char;\n        *(undefined2 *)(pcVar12 + 2) = 0x733a;\n        pcVar12[1] = cVar5;\n        *pcVar12 = cVar5;\n        strcpy(pcVar12 + 4,param_1);\n        local_ec = local_ec + 4;\n      }\n      else {\n        local_6c = 0;\n        local_78 = 0;\n        uVar22 = (uint)(history_quoting_state == 0x22);\n        pcVar12 = param_1;\n        if (history_quoting_state == 0x27) {\n          uVar13 = (ulong)history_quotes_inhibit_expansion;\n          if (history_quotes_inhibit_expansion == 0) {\n            lVar21 = 0;\n          }\n          else {\n            if ((cVar5 == '\\'') || (cVar5 == '\\0')) {\n              uVar13 = 0;\n            }\n            else {\n              uVar20 = 1;\n              do {\n                cVar5 = param_1[uVar20];\n                uVar13 = uVar20 & 0xffffffff;\n                uVar20 = uVar20 + 1;\n                if (cVar5 == '\\0') break;\n              } while (cVar5 != '\\'');\n            }\n            local_78 = (uint)uVar13;\n            if (cVar5 != '\\0') {\n              local_78 = local_78 + 1;\n              uVar13 = (ulong)local_78;\n            }\n            lVar21 = (long)(int)uVar13;\n            cVar5 = param_1[lVar21];\n            pcVar12 = param_1 + lVar21;\n          }\n        }\n        else {\n          lVar21 = 0;\n          uVar13 = 0;\n        }\n        while (cVar5 != '\\0') {\n          sVar11 = __ctype_get_mb_cur_max();\n          iVar6 = (int)uVar13;\n          if (((sVar11 < 2) || (rl_byte_oriented != 0)) ||\n             (iVar29 = _rl_get_char_len(pcVar12,&local_6c), iVar29 < 2)) {\n            cVar3 = history_expansion_char;\n            cVar5 = param_1[lVar21 + 1];\n            iVar29 = (int)cVar5;\n            cVar4 = *pcVar12;\n            if ((history_comment_char == '\\0') || (history_comment_char != cVar4)) {\n              if (cVar4 != history_expansion_char) {\n                if (uVar22 != 0) goto LAB_001f33c8;\nLAB_001f36f0:\n                if (history_quotes_inhibit_expansion == 0) {\n                  uVar22 = 0;\n                  uVar23 = local_78;\n                  goto LAB_001f33ec;\n                }\nLAB_001f36fe:\n                uVar23 = local_78;\n                if (cVar4 == '\\\"') {\n                  uVar22 = 1 - uVar22;\n                }\n                else if ((uVar22 == 0) && (cVar4 == '\\'')) {\n                  bVar30 = false;\n                  if (0 < iVar6) {\n                    bVar30 = param_1[lVar21 + -1] == '$';\n                  }\n                  local_78 = iVar6 + 1;\n                  FUN_001f22b0(param_1,&local_78,bVar30);\n                  uVar23 = local_78;\n                }\n                else if ((cVar4 == '\\\\') && ((iVar29 == 0x27 || (cVar5 == cVar3)))) {\n                  uVar23 = iVar6 + 1;\n                }\n                goto LAB_001f33ec;\n              }\n            }\n            else if (uVar22 == 0) {\n              if ((iVar6 == 0) ||\n                 ((param_1[lVar21 + -1] != '\\0' &&\n                  (pcVar12 = strchr(history_word_delimiters,(int)param_1[lVar21 + -1]),\n                  pcVar12 != (char *)0x0)))) {\n                cVar5 = param_1[(int)local_78];\n                lVar21 = (long)(int)(local_78 + 1);\n                if (cVar5 != '\\0') {\n                  do {\n                    local_78 = (uint)lVar21;\n                    pcVar12 = param_1 + lVar21;\n                    lVar21 = lVar21 + 1;\n                  } while (*pcVar12 != '\\0');\n                  cVar5 = '\\0';\n                }\n                break;\n              }\n              if (cVar4 != cVar3) goto LAB_001f36f0;\n            }\n            else if (cVar4 != history_expansion_char) {\nLAB_001f33c8:\n              if ((iVar29 == 0x22) && (cVar4 == '\\\\')) {\n                uVar22 = 1;\n                uVar23 = iVar6 + 1;\n              }\n              else {\n                uVar23 = local_78;\n                if (history_quotes_inhibit_expansion != 0) goto LAB_001f36fe;\n              }\n              goto LAB_001f33ec;\n            }\n            uVar23 = local_78;\n            lVar21 = (long)(int)local_78;\n            if ((cVar5 != '\\0') &&\n               (pcVar12 = strchr(history_no_expand_chars,iVar29), pcVar12 == (char *)0x0)) {\n              if ((iVar29 == 0x22) && ((uVar22 & 1) != 0)) {\n                uVar22 = 1;\n              }\n              else if ((history_inhibit_expansion_function == (code *)0x0) ||\n                      (iVar6 = (*history_inhibit_expansion_function)(param_1,uVar13), iVar6 == 0)) {\n                cVar5 = param_1[lVar21];\n                break;\n              }\n            }\n          }\n          else {\n            uVar23 = iVar6 + -1 + iVar29;\n          }\nLAB_001f33ec:\n          local_78 = uVar23 + 1;\n          uVar13 = (ulong)local_78;\n          lVar21 = (long)(int)local_78;\n          pcVar12 = param_1 + lVar21;\n          cVar5 = param_1[lVar21];\n        }\n        pcVar12 = param_1;\n        if (history_expansion_char != cVar5) {\n          xfree(pcVar10);\n          goto LAB_001f366f;\n        }\n      }\n      local_78 = 0;\n      local_c0 = (uint)(history_quoting_state == 0x22);\n      local_e0 = pcVar10;\n      if (history_quoting_state == 0x27) {\n        if (history_quotes_inhibit_expansion == 0) {\n          iVar6 = 0x100;\n          bVar30 = true;\n          uVar22 = 0;\n        }\n        else {\n          cVar5 = *pcVar12;\n          if (cVar5 == '\\0') goto LAB_001f34e2;\n          if (cVar5 == '\\'') {\n            iVar6 = 0x100;\n            lVar21 = 1;\n            uVar22 = 1;\n            cVar5 = '\\'';\n          }\n          else {\n            uVar23 = 0;\n            pcVar14 = pcVar12;\n            do {\n              uVar27 = uVar23;\n              pcVar14 = pcVar14 + 1;\n              uVar23 = uVar27 + 1;\n              if (*pcVar14 == '\\0') break;\n            } while (*pcVar14 != '\\'');\n            lVar21 = 1;\n            iVar6 = 0x100;\n            local_78 = uVar23;\n            while( true ) {\n              pcVar10 = local_e0 + lVar21;\n              local_e0[lVar21 + -1] = cVar5;\n              *pcVar10 = '\\0';\n              if ((int)(uVar27 + 1) == lVar21) break;\n              if (iVar6 + -1 <= (int)lVar21) {\n                iVar6 = iVar6 + 0x40;\n                local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n              }\n              cVar5 = pcVar12[lVar21];\n              lVar21 = lVar21 + 1;\n            }\n            cVar5 = *pcVar14;\n            bVar30 = false;\n            uVar22 = uVar23;\n            if (cVar5 == '\\0') goto LAB_001f34f4;\n            uVar22 = uVar27 + 2;\n            lVar21 = (long)(int)uVar22;\n            if (iVar6 + -1 <= (int)uVar23) {\n              iVar6 = iVar6 + 0x40;\n              local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n              cVar5 = *pcVar14;\n              pcVar10 = local_e0 + (int)(uVar27 + 1);\n            }\n          }\n          *pcVar10 = cVar5;\n          local_e0[lVar21] = '\\0';\n          bVar30 = false;\n          local_78 = uVar22;\n        }\n      }\n      else {\nLAB_001f34e2:\n        iVar6 = 0x100;\n        bVar30 = false;\n        uVar22 = 0;\n      }\nLAB_001f34f4:\n      if ((int)uVar22 < (int)local_ec) {\n        local_b8 = 0;\n        local_b4 = 0;\n        bVar2 = false;\n        uVar23 = uVar22;\nLAB_001f356d:\n        do {\n          cVar5 = pcVar12[(int)uVar22];\n          if (bVar2) {\n            if (iVar6 + -1 <= (int)uVar23) {\n              iVar6 = iVar6 + 0x40;\n              local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n            }\n            bVar2 = false;\n            local_e0[(int)uVar23] = cVar5;\n            local_e0[(int)(uVar23 + 1)] = '\\0';\n            uVar22 = local_78;\n            uVar23 = uVar23 + 1;\n          }\n          else {\n            sVar11 = __ctype_get_mb_cur_max();\n            uVar22 = local_78;\n            if ((1 < sVar11) && (rl_byte_oriented == 0)) {\n              lVar21 = (long)(int)local_78;\n              local_58 = (undefined  [16])0x0;\n              pcVar10 = local_58;\n              cVar4 = cVar5;\n              do {\n                *pcVar10 = cVar4;\n                uVar22 = (uint)lVar21;\n                local_6c = 0;\n                iVar29 = _rl_get_char_len(local_58,&local_6c);\n                if (iVar29 != -2) break;\n                uVar22 = uVar22 + 1;\n                cVar4 = pcVar12[lVar21 + 1];\n                pcVar10 = pcVar10 + 1;\n                lVar21 = lVar21 + 1;\n                local_78 = uVar22;\n              } while (local_48 != pcVar10);\n              sVar11 = strlen(local_58);\n              if (1 < sVar11) {\n                uVar27 = uVar23 + (int)sVar11;\n                if (iVar6 <= (int)uVar27) {\n                  iVar6 = iVar6 + 0x80 + (uVar27 - iVar6 & 0xffffff80);\n                  local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n                }\n                strcpy(local_e0 + (int)uVar23,local_58);\n                bVar2 = false;\n                uVar23 = uVar27;\n                goto LAB_001f3559;\n              }\n            }\n            if (cVar5 == history_expansion_char) {\nLAB_001f3780:\n              cVar5 = pcVar12[(long)(int)uVar22 + 1];\n              if (((cVar5 == '\\0') ||\n                  (pcVar10 = strchr(history_no_expand_chars,(int)cVar5), pcVar10 != (char *)0x0)) ||\n                 ((cVar5 == 0x22 && ((local_c0 & 1) != 0)))) {\n                if (iVar6 + -1 <= (int)uVar23) {\n                  iVar6 = iVar6 + 0x40;\n                  local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n                }\n                cVar5 = pcVar12[(int)uVar22];\nLAB_001f3608:\n                local_78 = uVar22 + 1;\n                local_e0[(int)uVar23] = cVar5;\n                local_e0[(int)(uVar23 + 1)] = '\\0';\n                uVar22 = local_78;\n                uVar23 = uVar23 + 1;\n                if ((int)local_ec <= (int)local_78) break;\n                goto LAB_001f356d;\n              }\n              if (history_inhibit_expansion_function != (code *)0x0) {\n                iVar7 = iVar6 + -1;\n                iVar29 = iVar6;\n                if (iVar7 <= (int)uVar23) {\n                  iVar29 = iVar6 + 0x40;\n                  local_e0 = (char *)xrealloc(local_e0,(long)iVar29);\n                  iVar7 = iVar6 + 0x3f;\n                }\n                uVar27 = uVar23 + 1;\n                pcVar10 = local_e0 + (int)uVar27;\n                local_e0[(int)uVar23] = pcVar12[(int)uVar22];\n                *pcVar10 = '\\0';\n                iVar6 = iVar29;\n                if (iVar7 <= (int)uVar27) {\n                  iVar6 = iVar29 + 0x40;\n                  local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n                  pcVar10 = local_e0 + (int)uVar27;\n                }\n                *pcVar10 = cVar5;\n                local_e0[(int)(uVar23 + 2)] = '\\0';\n                iVar29 = (*history_inhibit_expansion_function)(local_e0,uVar23);\n                if (iVar29 != 0) {\n                  *pcVar10 = '\\0';\n                  uVar23 = uVar27;\n                  goto LAB_001f3559;\n                }\n                local_e0[(int)uVar23] = '\\0';\n              }\n              bVar26 = 0x27;\n              if (!bVar30) {\n                bVar26 = -(local_c0 != 0) & 0x22;\n              }\n              local_64 = 0;\n              local_d8 = (char *)xmalloc(0x80);\n              cVar5 = pcVar12[(long)(int)uVar22 + 1];\n              local_74 = uVar22;\n              if (cVar5 == '\\0') {\nLAB_001f4609:\n                pcVar10 = (char *)get_history_event(pcVar12,&local_74,bVar26);\n                uVar13 = (ulong)local_74;\n              }\n              else {\n                pcVar10 = strchr(\":$*%^\",(int)cVar5);\n                if (pcVar10 == (char *)0x0) {\n                  if (cVar5 != '#') goto LAB_001f4609;\n                  local_74 = uVar22 + 2;\n                  uVar13 = (ulong)local_74;\n                  pcVar10 = local_e0;\n                }\n                else {\n                  local_74 = uVar22 + 1;\n                  local_70 = 0;\n                  local_5a = history_expansion_char;\n                  local_59 = 0;\n                  local_5b = history_expansion_char;\n                  pcVar10 = (char *)get_history_event(&local_5b,&local_70,0);\n                  uVar13 = (ulong)local_74;\n                }\n              }\n              pcVar14 = DAT_0024b708;\n              uVar27 = (uint)uVar13;\n              if (pcVar10 == (char *)0x0) {\n                uVar17 = 0;\n                uVar18 = (ulong)uVar22;\n                uVar20 = uVar13;\nLAB_001f4736:\n                pcVar10 = (char *)FUN_001f2310(pcVar12,uVar18,uVar20,uVar17);\n                xfree(local_d8);\nLAB_001f421f:\n                *param_2 = pcVar10;\n                xfree(local_e0);\n                uVar13 = 0xffffffff;\n                if (pcVar12 != param_1) {\n                  xfree(pcVar12);\n                  uVar13 = 0xffffffff;\n                }\n                goto LAB_001f3695;\n              }\n              cVar5 = pcVar12[(int)uVar27];\n              bVar31 = cVar5 == ':';\n              if (bVar31) {\n                uVar27 = uVar27 + 1;\n                cVar5 = pcVar12[(int)uVar27];\n              }\n              if (cVar5 == '%') {\n                local_74 = uVar27 + 1;\n                if (DAT_0024b708 == (char *)0x0) {\nLAB_001f4c22:\n                  pcVar14 = (char *)xmalloc(1);\n                  *pcVar14 = '\\0';\n                }\n                else {\n                  sVar11 = strlen(DAT_0024b708);\n                  pcVar10 = (char *)xmalloc(sVar11 + 1);\n                  pcVar14 = strcpy(pcVar10,pcVar14);\n                }\nLAB_001f40f5:\n                if (pcVar14 == &DAT_0024b730) {\nLAB_001f471f:\n                  uVar20 = (ulong)local_74;\nLAB_001f472e:\n                  uVar17 = 1;\n                  uVar18 = uVar13;\n                  goto LAB_001f4736;\n                }\nLAB_001f4105:\n                sVar11 = strlen(pcVar14);\n                pcVar10 = (char *)xmalloc(sVar11 + 1);\n                local_b0 = strcpy(pcVar10,pcVar14);\n                free(pcVar14);\n              }\n              else {\n                if (cVar5 == '-') {\n                  iVar29 = 0;\nLAB_001f4b04:\n                  cVar5 = pcVar12[(int)(uVar27 + 1)];\n                  if (9 < (byte)(cVar5 - 0x30U)) {\n                    if (cVar5 == '$') {\n                      local_74 = uVar27 + 2;\n                      iVar7 = 0x24;\n                    }\n                    else if (cVar5 == '^') {\n                      local_74 = uVar27 + 2;\n                      uVar20 = (ulong)local_74;\n                      if (1 < iVar29) goto LAB_001f472e;\n                      iVar7 = 1;\n                    }\n                    else {\n                      local_74 = uVar27 + 1;\n                      iVar7 = -1;\n                    }\nLAB_001f470b:\n                    pcVar14 = (char *)history_arg_extract(iVar29,iVar7,pcVar10);\n                    if (pcVar14 != (char *)0x0) goto LAB_001f40f5;\n                    goto LAB_001f471f;\n                  }\n                  iVar7 = 0;\n                  uVar18 = (ulong)(int)(uVar27 + 2);\n                  do {\n                    iVar7 = (int)(char)(cVar5 + -0x30) + iVar7 * 10;\n                    cVar5 = pcVar12[uVar18];\n                    uVar20 = uVar18 & 0xffffffff;\n                    uVar18 = uVar18 + 1;\n                  } while ((byte)(cVar5 - 0x30U) < 10);\n                  bVar31 = iVar29 <= iVar7 || iVar7 == 0x24;\nLAB_001f4b52:\n                  local_74 = (uint)uVar20;\n                  if (bVar31) goto LAB_001f470b;\n                  goto LAB_001f472e;\n                }\n                if (cVar5 < '.') {\n                  if (cVar5 != '$') {\n                    if (cVar5 == '*') {\n                      local_74 = uVar27 + 1;\n                      pcVar14 = (char *)history_arg_extract(1,0x24,pcVar10);\n                      if (pcVar14 == (char *)0x0) goto LAB_001f4c22;\n                      goto LAB_001f40f5;\n                    }\n                    goto LAB_001f46a9;\n                  }\n                  local_74 = uVar27 + 1;\n                  pcVar14 = (char *)history_arg_extract(0x24,0x24,pcVar10);\n                  if (pcVar14 == &DAT_0024b730) goto LAB_001f471f;\n                  if (pcVar14 == (char *)0x0) goto LAB_001f46a9;\n                  goto LAB_001f4105;\n                }\n                if (cVar5 < ':') {\n                  if (('/' < cVar5) && (bVar31)) {\n                    iVar29 = 0;\n                    lVar21 = (long)(int)(uVar27 + 1);\n                    do {\n                      iVar29 = (int)(char)(cVar5 + -0x30) + iVar29 * 10;\n                      cVar5 = pcVar12[lVar21];\n                      uVar27 = (uint)lVar21;\n                      lVar21 = lVar21 + 1;\n                    } while ((byte)(cVar5 - 0x30U) < 10);\nLAB_001f46ea:\n                    if (cVar5 != '^') {\n                      if (cVar5 == '*') {\n                        local_74 = uVar27 + 1;\n                        iVar7 = 0x24;\n                      }\n                      else {\n                        local_74 = uVar27;\n                        iVar7 = iVar29;\n                        if (cVar5 == '-') goto LAB_001f4b04;\n                      }\n                      goto LAB_001f470b;\n                    }\n                    iVar7 = 1;\n                    bVar31 = iVar29 < 2;\n                    uVar20 = (ulong)(uVar27 + 1);\n                    goto LAB_001f4b52;\n                  }\n                }\n                else if (cVar5 == '^') {\n                  uVar27 = uVar27 + 1;\n                  iVar29 = 1;\n                  cVar5 = pcVar12[(int)uVar27];\n                  goto LAB_001f46ea;\n                }\nLAB_001f46a9:\n                sVar11 = strlen(pcVar10);\n                pcVar14 = (char *)xmalloc(sVar11 + 1);\n                local_b0 = strcpy(pcVar14,pcVar10);\n              }\n              uVar22 = local_74;\n              lVar21 = (long)(int)local_74;\n              if (pcVar12[lVar21] == ':') {\n                local_a0 = 0;\n                iVar7 = 0;\n                bVar31 = false;\n                iVar29 = 0;\n                do {\n                  cVar5 = pcVar12[lVar21 + 1];\n                  if ((cVar5 == 'g') || (cVar5 == 'a')) {\n                    local_74 = local_74 + 1;\n                    iVar29 = 1;\n                    cVar5 = pcVar12[lVar21 + 2];\n                  }\n                  else if (cVar5 == 'G') {\n                    local_74 = local_74 + 1;\n                    bVar31 = true;\n                    cVar5 = pcVar12[lVar21 + 2];\n                  }\n                  if (cVar5 == '&') {\n                    local_74 = local_74 + 2;\nLAB_001f479b:\n                    iVar24 = DAT_0024b71c;\n                    if (DAT_0024b71c == 0) {\n                      uVar17 = 4;\n                      uVar23 = local_74;\n                    }\n                    else {\n                      sVar11 = strlen(local_b0);\n                      if (iVar24 <= (int)sVar11) {\n                        iVar8 = 0;\n                        __n = 0;\n                        iVar25 = 0;\n                        bVar1 = true;\n                        uVar13 = sVar11 & 0xffffffff;\n                        pcVar10 = local_b0;\n                        while( true ) {\n                          if ((iVar24 == 0) ||\n                             ((local_b0 = pcVar10, pcVar10[__n] == *DAT_0024b728 &&\n                              (iVar9 = strncmp(pcVar10 + __n,DAT_0024b728,(long)iVar24), iVar9 == 0)\n                              ))) {\n                            iVar24 = (DAT_0024b718 - iVar24) + (int)uVar13;\n                            local_b0 = (char *)xmalloc((long)(iVar24 + 1));\n                            strncpy(local_b0,pcVar10,__n);\n                            strncpy(local_b0 + __n,DAT_0024b720,(long)DAT_0024b718);\n                            strncpy(local_b0 + (long)DAT_0024b718 + __n,\n                                    pcVar10 + (long)DAT_0024b71c + __n,\n                                    (long)((int)uVar13 - (iVar25 + DAT_0024b71c)));\n                            local_b0[iVar24] = '\\0';\n                            xfree(pcVar10);\n                            if (iVar29 == 0) {\n                              uVar27 = local_74;\n                              if (!bVar31) goto LAB_001f4277;\n                              sVar11 = strlen(local_b0);\n                              bVar1 = false;\n                              uVar13 = sVar11 & 0xffffffff;\n                              iVar25 = iVar8;\n                            }\n                            else {\n                              iVar25 = iVar25 + -1 + DAT_0024b718;\n                              sVar11 = strlen(local_b0);\n                              iVar29 = iVar29 + 1;\n                              bVar1 = false;\n                              uVar13 = sVar11 & 0xffffffff;\n                            }\n                          }\n                          iVar24 = DAT_0024b71c;\n                          iVar25 = iVar25 + 1;\n                          if ((int)uVar13 < DAT_0024b71c + iVar25) break;\n                          __n = (size_t)iVar25;\n                          pcVar10 = local_b0;\n                          if ((iVar8 < iVar25) && (bVar31)) {\n                            pcVar14 = local_b0 + __n;\n                            cVar5 = *pcVar14;\n                            if (cVar5 != '\\0') {\n                              do {\n                                if ((1 < (byte)(cVar5 - 9U)) && (cVar5 != ' ')) break;\n                                cVar5 = pcVar14[1];\n                                pcVar14 = pcVar14 + 1;\n                                iVar25 = iVar25 + 1;\n                              } while (cVar5 != '\\0');\n                              __n = (size_t)iVar25;\n                            }\n                            iVar8 = FUN_001f23f0(local_b0,iVar25);\n                          }\n                        }\n                        uVar27 = local_74;\n                        if (iVar29 < 2) {\n                          if (bVar1) {\n                            uVar17 = 2;\n                            uVar23 = local_74;\n                            goto LAB_001f4202;\n                          }\n                        }\n                        else {\n                          iVar29 = 0;\n                        }\n                        goto LAB_001f4277;\n                      }\n                      uVar17 = 2;\n                      uVar23 = local_74;\n                    }\nLAB_001f4202:\n                    pcVar10 = (char *)FUN_001f2310(pcVar12,uVar22,uVar23,uVar17);\n                    xfree(local_d8);\n                    xfree(local_b0);\n                    goto LAB_001f421f;\n                  }\n                  switch(cVar5) {\n                  case 'e':\n                    pcVar10 = strrchr(local_b0,0x2e);\n                    if (pcVar10 == (char *)0x0) goto LAB_001f4455;\nLAB_001f4395:\n                    sVar11 = strlen(pcVar10);\n                    pcVar14 = (char *)xmalloc(sVar11 + 1);\n                    pcVar10 = strcpy(pcVar14,pcVar10);\n                    xfree(local_b0);\n                    local_b0 = pcVar10;\n                    uVar27 = local_74 + 2;\n                    break;\n                  default:\n                    uVar17 = 3;\n                    uVar22 = local_74 + 1;\n                    uVar23 = local_74 + 2;\n                    goto LAB_001f4202;\n                  case 'h':\n                    iVar24 = 0x2f;\n                    goto LAB_001f43da;\n                  case 'p':\n                    local_a0 = 1;\n                    uVar27 = local_74 + 2;\n                    break;\n                  case 'q':\n                    iVar7 = 0x71;\n                    uVar27 = local_74 + 2;\n                    break;\n                  case 'r':\n                    iVar24 = 0x2e;\nLAB_001f43da:\n                    pcVar10 = strrchr(local_b0,iVar24);\n                    if (pcVar10 == (char *)0x0) {\nLAB_001f4455:\n                      uVar27 = local_74 + 2;\n                    }\n                    else {\n                      *pcVar10 = '\\0';\n                      uVar27 = local_74 + 2;\n                    }\n                    break;\n                  case 's':\n                    uVar27 = local_74 + 2;\n                    sVar11 = strlen(pcVar12);\n                    if ((int)uVar27 < (int)sVar11) {\n                      sVar11 = __ctype_get_mb_cur_max();\n                      if ((sVar11 < 2) || (rl_byte_oriented != 0)) {\nLAB_001f44a8:\n                        iVar24 = (int)pcVar12[(long)(int)local_74 + 2];\n                      }\n                      else {\n                        _rl_adjust_point(pcVar12,local_74 + 2,&local_64);\n                        iVar24 = _rl_get_char_len(pcVar12 + (long)(int)local_74 + 2,&local_64);\n                        if (iVar24 < 2) goto LAB_001f44a8;\n                        iVar24 = 0;\n                      }\n                      local_74 = local_74 + 3;\n                      pcVar14 = (char *)FUN_001f2960(pcVar12,&local_74,iVar24,0,&DAT_0024b71c);\n                      pcVar10 = DAT_0024b710;\n                      if (pcVar14 == (char *)0x0) {\n                        pcVar14 = DAT_0024b728;\n                        if (DAT_0024b728 == (char *)0x0) {\n                          if ((DAT_0024b710 == (char *)0x0) || (*DAT_0024b710 == '\\0')) {\n                            DAT_0024b71c = 0;\n                          }\n                          else {\n                            sVar11 = strlen(DAT_0024b710);\n                            pcVar14 = (char *)xmalloc(sVar11 + 1);\n                            DAT_0024b728 = strcpy(pcVar14,pcVar10);\n                            sVar11 = strlen(DAT_0024b728);\n                            DAT_0024b71c = (int)sVar11;\n                            pcVar14 = DAT_0024b728;\n                          }\n                        }\n                      }\n                      else if (DAT_0024b728 != (char *)0x0) {\n                        free(DAT_0024b728);\n                      }\n                      DAT_0024b728 = pcVar14;\n                      if (DAT_0024b720 != (char *)0x0) {\n                        free(DAT_0024b720);\n                      }\n                      DAT_0024b720 = (char *)FUN_001f2960(pcVar12,&local_74,iVar24,1,&DAT_0024b718);\n                      pcVar10 = strchr(DAT_0024b720,0x26);\n                      if (pcVar10 != (char *)0x0) {\n                        iVar24 = DAT_0024b71c + DAT_0024b718;\n                        iVar8 = 0;\n                        pcVar14 = (char *)xmalloc();\n                        pcVar10 = DAT_0024b720;\n                        if (0 < DAT_0024b718) {\n                          iVar25 = 0;\n                          iVar8 = 0;\n                          do {\n                            lVar21 = (long)iVar25;\n                            if (pcVar10[lVar21] == '&') {\n                              if (iVar24 <= DAT_0024b71c + iVar8) {\n                                iVar24 = DAT_0024b71c + iVar24 * 2;\n                                pcVar14 = (char *)xrealloc(pcVar14,(long)iVar24);\n                                pcVar10 = DAT_0024b720;\n                              }\n                              strcpy(pcVar14 + iVar8,DAT_0024b728);\n                              iVar8 = iVar8 + DAT_0024b71c;\n                            }\n                            else {\n                              if ((pcVar10[lVar21] == '\\\\') && (pcVar10[lVar21 + 1] == '&')) {\n                                iVar25 = iVar25 + 1;\n                                lVar21 = lVar21 + 1;\n                              }\n                              if (iVar24 <= iVar8) {\n                                iVar24 = iVar24 * 2;\n                                pcVar14 = (char *)xrealloc(pcVar14,(long)iVar24);\n                                pcVar10 = DAT_0024b720;\n                              }\n                              lVar15 = (long)iVar8;\n                              iVar8 = iVar8 + 1;\n                              pcVar14[lVar15] = pcVar10[lVar21];\n                            }\n                            iVar25 = iVar25 + 1;\n                          } while (iVar25 < DAT_0024b718);\n                        }\n                        pcVar14[iVar8] = '\\0';\n                        xfree(pcVar10);\n                        DAT_0024b718 = iVar8;\n                        DAT_0024b720 = pcVar14;\n                      }\n                      goto LAB_001f479b;\n                    }\n                    break;\n                  case 't':\n                    pcVar14 = strrchr(local_b0,0x2f);\n                    pcVar10 = pcVar14 + 1;\n                    if (pcVar14 != (char *)0x0) goto LAB_001f4395;\n                    goto LAB_001f4455;\n                  case 'x':\n                    iVar7 = 0x78;\n                    uVar27 = local_74 + 2;\n                  }\nLAB_001f4277:\n                  local_74 = uVar27;\n                  lVar21 = (long)(int)local_74;\n                } while (pcVar12[lVar21] == ':');\n                local_74 = local_74 - 1;\n                local_b8 = local_b8 + local_a0;\n                if (iVar7 != 0) {\n                  if (iVar7 == 0x71) {\n                    pcVar10 = (char *)sh_single_quote(local_b0);\n                  }\n                  else if (iVar7 == 0x78) {\n                    iVar29 = 3;\n                    cVar5 = *local_b0;\n                    pcVar10 = local_b0;\n                    while (cVar5 != '\\0') {\n                      if (cVar5 == '\\'') {\n                        iVar29 = iVar29 + 3;\n                      }\n                      else if (((byte)(cVar5 - 9U) < 2) || (cVar5 == ' ')) {\n                        iVar29 = iVar29 + 2;\n                      }\n                      pcVar14 = pcVar10 + 1;\n                      pcVar10 = pcVar10 + 1;\n                      iVar29 = iVar29 + 1;\n                      cVar5 = *pcVar14;\n                    }\n                    pcVar10 = (char *)xmalloc((long)iVar29);\n                    *pcVar10 = '\\'';\n                    puVar16 = (undefined4 *)(pcVar10 + 1);\n                    pcVar14 = local_b0;\nLAB_001f4dd2:\n                    cVar5 = *pcVar14;\n                    pcVar19 = pcVar14;\n                    if (cVar5 != '\\0') {\n                      while (pcVar14 = pcVar19 + 1, cVar5 != '\\'') {\n                        if (((byte)(cVar5 - 9U) < 2) || (cVar5 == ' ')) {\n                          *(undefined *)puVar16 = 0x27;\n                          cVar5 = *pcVar19;\n                          *(undefined *)((long)puVar16 + 2) = 0x27;\n                          *(char *)((long)puVar16 + 1) = cVar5;\n                          puVar16 = (undefined4 *)((long)puVar16 + 3);\n                          goto LAB_001f4dd2;\n                        }\n                        *(char *)puVar16 = cVar5;\n                        cVar5 = *pcVar14;\n                        puVar16 = (undefined4 *)((long)puVar16 + 1);\n                        pcVar19 = pcVar14;\n                        if (cVar5 == '\\0') goto LAB_001f4dfd;\n                      }\n                      *puVar16 = 0x27275c27;\n                      puVar16 = puVar16 + 1;\n                      goto LAB_001f4dd2;\n                    }\nLAB_001f4dfd:\n                    *(undefined2 *)puVar16 = 0x27;\n                  }\n                  else {\n                    sVar11 = strlen(local_b0);\n                    pcVar10 = (char *)xmalloc(sVar11 + 1);\n                    pcVar10 = strcpy(pcVar10,local_b0);\n                  }\n                  xfree(local_b0);\n                  local_b0 = pcVar10;\n                }\n              }\n              else {\n                local_74 = local_74 - 1;\n              }\n              sVar11 = strlen(local_b0);\n              if (0x7f < (int)sVar11) {\n                local_d8 = (char *)xrealloc(local_d8,(long)((int)sVar11 + 2));\n              }\n              strcpy(local_d8,local_b0);\n              xfree(local_b0);\n              uVar22 = local_74;\n              local_b4 = local_b4 + 1;\n              uVar27 = uVar23;\n              if (*local_d8 != '\\0') {\n                sVar11 = strlen(local_d8);\n                uVar27 = uVar23 + (int)sVar11;\n                if (iVar6 <= (int)uVar27) {\n                  iVar6 = iVar6 + 0x80 + (uVar27 - iVar6 & 0xffffff80);\n                  local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n                }\n                strcpy(local_e0 + (int)uVar23,local_d8);\n              }\n              xfree(local_d8);\n              uVar23 = uVar27;\n            }\n            else if (cVar5 == history_comment_char) {\nLAB_001f35d6:\n              if (((local_c0 != 0) && (history_quotes_inhibit_expansion != 0)) ||\n                 ((uVar22 != 0 &&\n                  ((pcVar12[(long)(int)uVar22 + -1] == '\\0' ||\n                   (pcVar10 = strchr(history_word_delimiters,(int)pcVar12[(long)(int)uVar22 + -1]),\n                   pcVar10 == (char *)0x0)))))) {\n                if (iVar6 + -1 <= (int)uVar23) {\n                  iVar6 = iVar6 + 0x40;\n                  local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n                }\n                cVar5 = pcVar12[(int)uVar22];\n                goto LAB_001f3608;\n              }\n              pcVar10 = (char *)xmalloc((long)(int)((local_ec - uVar22) + 1));\n              pcVar14 = stpcpy(pcVar10,pcVar12 + (int)uVar22);\n              uVar27 = uVar23 + ((int)pcVar14 - (int)pcVar10);\n              if (iVar6 <= (int)uVar27) {\n                iVar6 = iVar6 + 0x80 + (uVar27 - iVar6 & 0xffffff80);\n                local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n              }\n              strcpy(local_e0 + (int)uVar23,pcVar10);\n              xfree(pcVar10);\n              uVar22 = local_ec;\n              uVar23 = uVar27;\n            }\n            else if (cVar5 == '\\\"') {\n              local_c0 = 1 - local_c0;\n              if (iVar6 + -1 <= (int)uVar23) {\n                iVar6 = iVar6 + 0x40;\n                local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n              }\n              local_e0[(int)uVar23] = '\\\"';\n              local_e0[(int)(uVar23 + 1)] = '\\0';\n              uVar23 = uVar23 + 1;\n            }\n            else {\n              if (cVar5 < '#') {\n                if (cVar5 == -3) goto LAB_001f3780;\n                if (cVar5 == -2) goto LAB_001f35d6;\nLAB_001f3a7d:\n                if (iVar6 + -1 <= (int)uVar23) {\n                  iVar6 = iVar6 + 0x40;\n                  local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n                }\n                cVar5 = pcVar12[(int)uVar22];\n                goto LAB_001f3608;\n              }\n              if (cVar5 == '\\'') {\n                if (bVar30) {\n                  if (iVar6 + -1 <= (int)uVar23) {\n                    iVar6 = iVar6 + 0x40;\n                    local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n                  }\n                  bVar30 = false;\n                  local_e0[(int)uVar23] = '\\'';\n                  local_e0[(int)(uVar23 + 1)] = '\\0';\n                  uVar23 = uVar23 + 1;\n                }\n                else if (local_c0 == 0) {\n                  if (history_quotes_inhibit_expansion == 0) {\n                    if (iVar6 + -1 <= (int)uVar23) {\n                      iVar6 = iVar6 + 0x40;\n                      local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n                    }\n                    local_c0 = 0;\n                    bVar30 = true;\n                    local_e0[(int)uVar23] = pcVar12[(int)uVar22];\n                    local_e0[(int)(uVar23 + 1)] = '\\0';\n                    bVar2 = false;\n                    uVar23 = uVar23 + 1;\n                  }\n                  else {\n                    bVar30 = false;\n                    if (0 < (int)uVar22) {\n                      bVar30 = pcVar12[(long)(int)uVar22 + -1] == '$';\n                    }\n                    local_78 = uVar22 + 1;\n                    FUN_001f22b0(pcVar12,&local_78,bVar30);\n                    uVar27 = local_78;\n                    sVar11 = (size_t)(int)((local_78 - uVar22) + 2);\n                    pcVar10 = (char *)xmalloc(sVar11);\n                    strncpy(pcVar10,pcVar12 + (int)uVar22,sVar11);\n                    pcVar10[sVar11 - 1] = '\\0';\n                    sVar11 = strlen(pcVar10);\n                    uVar28 = uVar23 + (int)sVar11;\n                    if (iVar6 <= (int)uVar28) {\n                      iVar6 = iVar6 + 0x80 + (uVar28 - iVar6 & 0xffffff80);\n                      local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n                    }\n                    strcpy(local_e0 + (int)uVar23,pcVar10);\n                    xfree(pcVar10);\n                    bVar30 = false;\n                    bVar2 = false;\n                    uVar22 = uVar27;\n                    uVar23 = uVar28;\n                  }\n                }\n                else {\n                  if (iVar6 + -1 <= (int)uVar23) {\n                    iVar6 = iVar6 + 0x40;\n                    local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n                  }\n                  bVar2 = false;\n                  local_e0[(int)uVar23] = pcVar12[(int)uVar22];\n                  local_e0[(int)(uVar23 + 1)] = '\\0';\n                  uVar23 = uVar23 + 1;\n                }\n              }\n              else {\n                if (cVar5 != '\\\\') goto LAB_001f3a7d;\n                if (iVar6 + -1 <= (int)uVar23) {\n                  iVar6 = iVar6 + 0x40;\n                  local_e0 = (char *)xrealloc(local_e0,(long)iVar6);\n                }\n                bVar2 = true;\n                local_e0[(int)uVar23] = '\\\\';\n                local_e0[(int)(uVar23 + 1)] = '\\0';\n                uVar23 = uVar23 + 1;\n              }\n            }\n          }\nLAB_001f3559:\n          local_78 = uVar22 + 1;\n          uVar22 = local_78;\n        } while ((int)local_78 < (int)local_ec);\n        *param_2 = local_e0;\n        if (pcVar12 != param_1) {\n          xfree(pcVar12);\n        }\n        uVar13 = 2;\n        if (local_b8 != 0) goto LAB_001f3695;\n      }\n      else {\n        *param_2 = local_e0;\n        uVar13 = 0;\n        if (pcVar12 == param_1) goto LAB_001f3695;\n        xfree(pcVar12);\n        local_b4 = 0;\n      }\n      uVar13 = (ulong)(local_b4 != 0);\n      goto LAB_001f3695;\n    }\nLAB_001f366f:\n    sVar11 = strlen(param_1);\n    pcVar10 = (char *)xmalloc(sVar11 + 1);\n    pcVar10 = strcpy(pcVar10,param_1);\n    *param_2 = pcVar10;\n  }\n  uVar13 = 0;\nLAB_001f3695:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar13;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "dup2": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint dup2(int __fd,int __fd2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_dup2_002379f8)();\n  return iVar1;\n}\n\n",
  "find_user_command": "\nvoid find_user_command(undefined8 param_1)\n\n{\n  FUN_0019b8d0(param_1,0x24);\n  return;\n}\n\n",
  "falarm": "\nint falarm(ulong param_1,ulong param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  itimerval local_58;\n  undefined local_38 [24];\n  long local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_58.it_value.tv_sec = param_1 & 0xffffffff;\n  local_58.it_value.tv_usec = param_2 & 0xffffffff;\n  local_58.it_interval.tv_sec = 0;\n  local_58.it_interval.tv_usec = 0;\n  iVar1 = setitimer(ITIMER_REAL,&local_58,(itimerval *)local_38);\n  if (iVar1 < 0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = (local_38._16_4_ + 1) - (uint)(local_20 == 0);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_pushed_input_available": "\nbool _rl_pushed_input_available(void)\n\n{\n  return DAT_0024b3e0 != DAT_0024b3e4;\n}\n\n",
  "maybe_save_shell_history": "\nundefined4 maybe_save_shell_history(void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  char *__file;\n  \n  if (history_lines_this_session < 1) {\n    return 0;\n  }\n  __file = (char *)get_string_value(\"HISTFILE\");\n  if ((__file == (char *)0x0) || (*__file == '\\0')) {\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = file_exists(__file);\n    if (iVar1 == 0) {\n      iVar1 = open(__file,0x241,0x180);\n      if (iVar1 != -1) {\n        close(iVar1);\n      }\n    }\n    using_history();\n    iVar1 = where_history();\n    if ((iVar1 < history_lines_this_session) && (force_append_history == 0)) {\n      uVar2 = write_history(__file);\n      history_lines_in_file = history_lines_written_to_file;\n    }\n    else {\n      uVar2 = append_history(history_lines_this_session,__file);\n      history_lines_in_file = history_lines_this_session + history_lines_in_file;\n    }\n    history_lines_this_session = 0;\n    sv_histsize(\"HISTFILESIZE\");\n  }\n  return uVar2;\n}\n\n",
  "sh_invalidoptname": "\nvoid sh_invalidoptname(undefined8 param_1)\n\n{\n  builtin_error(\"%s: invalid option name\",param_1);\n  return;\n}\n\n",
  "assoc_dispose": "\nvoid assoc_dispose(long param_1)\n\n{\n  if (param_1 != 0) {\n    hash_flush(param_1,0);\n    hash_dispose(param_1);\n    return;\n  }\n  return;\n}\n\n",
  "expand_words_no_vars": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 expand_words_no_vars(long param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  tempenv_assign_error = 0;\n  if (param_1 == 0) {\n    return 0;\n  }\n  _DAT_00247840 = copy_word_list();\n  if ((brace_expansion == 0) || (_DAT_00247840 == 0)) {\n    lVar1 = FUN_0017a460();\n  }\n  else {\n    uVar2 = FUN_00168ba0(_DAT_00247840);\n    lVar1 = FUN_0017a460(uVar2);\n  }\n  if (lVar1 != 0) {\n    if (disallow_filename_globbing == 0) {\n      uVar2 = FUN_00170ca0(lVar1);\n      return uVar2;\n    }\n    uVar2 = dequote_list();\n    return uVar2;\n  }\n  return 0;\n}\n\n",
  "FUN_001b8070": "\nint FUN_001b8070(char *param_1,char *param_2,int *param_3,undefined4 *param_4)\n\n{\n  byte bVar1;\n  byte bVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  char cVar5;\n  char cVar6;\n  long lVar7;\n  ulong uVar8;\n  int iVar9;\n  byte *pbVar10;\n  int iVar11;\n  bool bVar12;\n  \n  *param_3 = 1;\n  cVar5 = *param_1;\n  iVar11 = (int)cVar5;\n  pbVar10 = (byte *)(param_1 + 1);\n  iVar9 = (int)param_1;\n  switch(cVar5) {\n  case '\\\"':\n  case '\\'':\n  case '?':\n    if (param_4 == (undefined4 *)0x0) {\n      *param_2 = cVar5;\n      return 1;\n    }\n  default:\nswitchD_001b80ab_caseD_23:\n    *param_2 = '\\\\';\n    iVar9 = 0;\n    break;\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n    iVar11 = iVar11 + -0x30;\n    bVar12 = iVar11 == 0;\n    bVar1 = param_1[1];\n    if ((byte)(bVar1 - 0x30) < 8) {\n      do {\n        pbVar10 = pbVar10 + 1;\n        iVar11 = (int)(char)(bVar1 - 0x30) + iVar11 * 8;\n        bVar1 = *pbVar10;\n        if (7 < (byte)(bVar1 - 0x30)) break;\n      } while (pbVar10 != (byte *)(param_1 + (ulong)(param_4 != (undefined4 *)0x0 && bVar12) + 3));\n      iVar9 = (int)pbVar10 - iVar9;\n    }\n    else {\n      iVar9 = 1;\n    }\n    *param_2 = (char)iVar11;\n    break;\n  case 'E':\n  case 'e':\n    *param_2 = '\\x1b';\n    iVar9 = 1;\n    break;\n  case 'U':\n  case 'u':\n    ppuVar3 = __ctype_b_loc();\n    uVar8 = 0;\n    pbVar4 = pbVar10;\n    while( true ) {\n      bVar1 = *pbVar4;\n      if (((*(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1) & 0x10) == 0) ||\n         (pbVar4 == (byte *)(param_1 + (int)((uint)(iVar11 != 0x75) * 4 + 5)))) break;\n      if ((byte)(bVar1 + 0x9f) < 6) {\n        lVar7 = (long)(char)(bVar1 + 0xa9);\n      }\n      else if ((byte)(bVar1 + 0xbf) < 6) {\n        lVar7 = (long)(char)(bVar1 - 0x37);\n      }\n      else {\n        lVar7 = (long)((char)bVar1 + -0x30);\n      }\n      uVar8 = uVar8 * 0x10 + lVar7;\n      pbVar4 = pbVar4 + 1;\n    }\n    if (pbVar4 == pbVar10) {\n      iVar9 = 0;\n      builtin_error(\"missing unicode digit for \\\\%c\",iVar11);\n      *param_2 = '\\\\';\n    }\n    else {\n      iVar9 = (int)pbVar4 - iVar9;\n      if (uVar8 < 0x80) {\n        *param_2 = (char)uVar8;\n      }\n      else {\n        iVar11 = u32cconv(uVar8,param_2);\n        param_2[iVar11] = '\\0';\n        *param_3 = iVar11;\n      }\n    }\n    break;\n  case '\\\\':\n    *param_2 = '\\\\';\n    iVar9 = 1;\n    break;\n  case 'a':\n    *param_2 = '\\a';\n    iVar9 = 1;\n    break;\n  case 'b':\n    *param_2 = '\\b';\n    iVar9 = 1;\n    break;\n  case 'c':\n    if (param_4 != (undefined4 *)0x0) {\n      *param_4 = 1;\n      return 1;\n    }\n    goto switchD_001b80ab_caseD_23;\n  case 'f':\n    *param_2 = '\\f';\n    iVar9 = 1;\n    break;\n  case 'n':\n    *param_2 = '\\n';\n    iVar9 = 1;\n    break;\n  case 'r':\n    *param_2 = '\\r';\n    iVar9 = 1;\n    break;\n  case 't':\n    *param_2 = '\\t';\n    iVar9 = 1;\n    break;\n  case 'v':\n    *param_2 = '\\v';\n    iVar9 = 1;\n    break;\n  case 'x':\n    ppuVar3 = __ctype_b_loc();\n    cVar5 = '\\0';\n    bVar1 = *pbVar10;\n    bVar2 = *(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1);\n    pbVar4 = pbVar10;\n    while (((bVar2 & 0x10) != 0 && (pbVar4 != (byte *)(param_1 + 3)))) {\n      if ((byte)(bVar1 + 0x9f) < 6) {\n        cVar6 = bVar1 + 0xa9;\n      }\n      else if ((byte)(bVar1 + 0xbf) < 6) {\n        cVar6 = bVar1 - 0x37;\n      }\n      else {\n        cVar6 = bVar1 - 0x30;\n      }\n      pbVar4 = pbVar4 + 1;\n      cVar5 = cVar5 * '\\x10' + cVar6;\n      bVar1 = *pbVar4;\n      bVar2 = *(byte *)((long)*ppuVar3 + (ulong)bVar1 * 2 + 1);\n    }\n    if (pbVar4 == pbVar10) {\n      iVar9 = 0;\n      builtin_error(\"missing hex digit for \\\\x\");\n      *param_2 = '\\\\';\n    }\n    else {\n      *param_2 = cVar5;\n      iVar9 = (int)pbVar4 - iVar9;\n    }\n  }\n  return iVar9;\n}\n\n",
  "rl_vi_insert_beg": "\nundefined8 rl_vi_insert_beg(undefined8 param_1,undefined4 param_2)\n\n{\n  rl_beg_of_line(1);\n  DAT_0023b36c = 1;\n  DAT_0023b368 = rl_arg_sign;\n  _rl_vi_last_command = param_2;\n  rl_begin_undo_group();\n  DAT_0024a3c8 = param_2;\n  _rl_keymap = &vi_insertion_keymap;\n  if (_rl_show_mode_in_prompt == 0) {\n    return 0;\n  }\n  _rl_reset_prompt();\n  return 0;\n}\n\n",
  "bind_builtin": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid bind_builtin(undefined8 param_1)\n\n{\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  bool bVar7;\n  bool bVar8;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  bool bVar12;\n  bool bVar13;\n  bool bVar14;\n  int iVar15;\n  int iVar16;\n  int iVar17;\n  int iVar18;\n  long lVar19;\n  long lVar20;\n  char *pcVar21;\n  int *piVar22;\n  char *pcVar23;\n  long *plVar24;\n  size_t sVar25;\n  undefined8 uVar26;\n  undefined *puVar27;\n  long lVar28;\n  long *plVar29;\n  int iVar30;\n  char *pcVar31;\n  undefined8 *puVar32;\n  long in_FS_OFFSET;\n  char *local_70;\n  char *local_68;\n  char *local_60;\n  char *local_58;\n  long local_50;\n  int local_48;\n  int local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (no_line_editing != 0) {\n    builtin_warning(\"line editing not enabled\");\n  }\n  if (bash_readline_initialized == 0) {\n    initialize_readline();\n  }\n  bVar8 = false;\n  bVar7 = false;\n  bVar6 = false;\n  bVar14 = false;\n  bVar13 = false;\n  bVar12 = false;\n  bVar11 = false;\n  bVar10 = false;\n  bVar9 = false;\n  bVar5 = false;\n  bVar3 = false;\n  bVar2 = false;\n  bVar1 = false;\n  bVar4 = false;\n  begin_unwind_frame(\"bind_builtin\");\n  unwind_protect_mem(&rl_outstream,8);\n  rl_outstream = stdout;\n  reset_internal_getopt();\n  local_58 = (char *)0x0;\n  local_70 = (char *)0x0;\n  local_60 = (char *)0x0;\n  local_68 = (char *)0x0;\n  pcVar21 = (char *)0x0;\n  pcVar31 = (char *)0x0;\nLAB_001a1ec0:\n  iVar15 = internal_getopt(param_1,\"lvpVPsSXf:q:u:m:r:x:\");\n  if (iVar15 != -1) {\n    do {\n      switch(iVar15) {\n      case 0x50:\n        goto switchD_001a1ee4_caseD_50;\n      default:\n        builtin_usage();\n        run_unwind_frame(\"bind_builtin\");\n        iVar15 = 0x102;\n        goto LAB_001a1f09;\n      case 0x53:\n        bVar13 = true;\n        goto LAB_001a1ec0;\n      case 0x56:\n        bVar8 = true;\n        goto LAB_001a1ec0;\n      case 0x58:\n        bVar4 = true;\n        goto LAB_001a1ec0;\n      case 0x66:\n        bVar6 = true;\n        pcVar31 = list_optarg;\n        goto LAB_001a1ec0;\n      case 0x6c:\n        bVar9 = true;\n        goto LAB_001a1ec0;\n      case 0x6d:\n        local_68 = list_optarg;\n        bVar5 = true;\n        goto LAB_001a1ec0;\n      case 0x70:\n        bVar10 = true;\n        goto LAB_001a1ec0;\n      case 0x71:\n        bVar7 = true;\n        pcVar21 = list_optarg;\n        goto LAB_001a1ec0;\n      case 0x72:\n        local_70 = list_optarg;\n        bVar2 = true;\n        goto LAB_001a1ec0;\n      case 0x73:\n        bVar12 = true;\n        goto LAB_001a1ec0;\n      case 0x75:\n        local_60 = list_optarg;\n        bVar1 = true;\n        goto LAB_001a1ec0;\n      case 0x76:\n        bVar14 = true;\n        goto LAB_001a1ec0;\n      case 0x78:\n        bVar3 = true;\n        local_58 = list_optarg;\n        iVar15 = internal_getopt(param_1,\"lvpVPsSXf:q:u:m:r:x:\");\n        if (iVar15 == -1) goto LAB_001a1f60;\n      }\n    } while( true );\n  }\nLAB_001a1f60:\n  puVar32 = loptend;\n  if ((bVar5) && (local_68 != (char *)0x0)) {\n    lVar19 = rl_get_keymap_by_name();\n    if (lVar19 == 0) {\n      builtin_error(\"`%s\\': invalid keymap name\",local_68);\n      run_unwind_frame(\"bind_builtin\");\n      iVar15 = 1;\n      goto LAB_001a1f09;\n    }\n    local_50 = rl_get_keymap();\n    rl_set_keymap(lVar19);\n  }\n  else {\n    local_50 = 0;\n  }\n  if (bVar9) {\n    rl_list_funmap_names();\n  }\n  if (bVar10) {\n    rl_function_dumper(1);\n  }\n  if (bVar11) {\n    rl_function_dumper(0);\n  }\n  if (bVar12) {\n    rl_macro_dumper(1);\n  }\n  if (bVar13) {\n    rl_macro_dumper(0);\n  }\n  if (bVar14) {\n    rl_variable_dumper(1);\n  }\n  if (bVar8) {\n    rl_variable_dumper(0);\n  }\n  if (((bVar6) && (pcVar31 != (char *)0x0)) && (iVar15 = rl_read_init_file(pcVar31), iVar15 != 0)) {\n    pcVar21 = (char *)printable_filename(pcVar31,0);\n    piVar22 = __errno_location();\n    pcVar23 = strerror(*piVar22);\n    builtin_error(\"%s: cannot read: %s\",pcVar21,pcVar23);\n    if (pcVar31 != pcVar21) {\n      sh_xfree(pcVar21,\"./bind.def\",0xfe);\n    }\n  }\n  else {\n    if ((bVar7) && (pcVar21 != (char *)0x0)) {\n      lVar19 = rl_named_function(pcVar21);\n      if (lVar19 == 0) {\n        builtin_error(\"`%s\\': unknown function name\",pcVar21);\n        iVar15 = 1;\n      }\n      else {\n        plVar24 = (long *)rl_invoking_keyseqs(lVar19);\n        if (plVar24 == (long *)0x0) {\n          __printf_chk(1,\"%s is not bound to any keys.\\n\",pcVar21);\n          iVar15 = 1;\n        }\n        else {\n          __printf_chk(1,\"%s can be invoked via \",pcVar21);\n          plVar29 = plVar24;\n          do {\n            lVar19 = *plVar29;\n            if (lVar19 == 0) goto LAB_001a2484;\n            puVar27 = &DAT_0021366a;\n            if (plVar29[1] != 0) {\n              puVar27 = &DAT_0020f034;\n            }\n            plVar29 = plVar29 + 1;\n            __printf_chk(1,\"\\\"%s\\\"%s\",lVar19,puVar27);\n          } while (plVar24 + 5 != plVar29);\n          if (plVar24[5] != 0) {\n            puts(\"...\");\n          }\nLAB_001a2484:\n          strvec_dispose(plVar24);\n          iVar15 = 0;\n        }\n      }\n    }\n    else {\n      iVar15 = 0;\n    }\n    if ((bVar1) && (local_60 != (char *)0x0)) {\n      lVar19 = rl_named_function(local_60);\n      if (lVar19 == 0) {\n        builtin_error(\"`%s\\': unknown function name\",local_60);\n        iVar15 = 1;\n      }\n      else {\n        uVar26 = rl_get_keymap();\n        rl_unbind_function_in_map(lVar19,uVar26);\n        iVar15 = 0;\n      }\n    }\n    if ((!bVar2) || (local_70 == (char *)0x0)) {\n      if (bVar3) {\n        iVar15 = bind_keyseq_to_unix_command(local_58);\n      }\n      if (bVar4) {\n        iVar15 = print_unix_command_map();\n      }\n      do {\n        if (puVar32 == (undefined8 *)0x0) {\n          if (local_50 != 0) {\n            rl_set_keymap(local_50);\n          }\n          run_unwind_frame(\"bind_builtin\");\n          if (iVar15 < 0) {\n            iVar15 = 1;\n          }\n          goto LAB_001a1f09;\n        }\n        lVar19 = rl_invoking_keyseqs(bash_execute_unix_command);\n        if (lVar19 == 0) {\n          rl_parse_and_bind(*(undefined8 *)puVar32[1]);\n          lVar20 = rl_invoking_keyseqs(bash_execute_unix_command);\n          iVar16 = 0;\n          if (lVar20 != 0) {\nLAB_001a204f:\n            iVar17 = strvec_len(lVar20);\n            goto LAB_001a205a;\n          }\n        }\n        else {\n          iVar17 = 0;\n          iVar16 = strvec_len(lVar19);\n          rl_parse_and_bind(*(undefined8 *)puVar32[1]);\n          lVar20 = rl_invoking_keyseqs(bash_execute_unix_command);\n          if (lVar20 != 0) goto LAB_001a204f;\nLAB_001a205a:\n          if ((iVar17 < iVar16) && (iVar30 = iVar16 - iVar17, 0 < iVar16)) {\n            lVar28 = 1;\n            do {\n              if (iVar17 == 0) {\n                unbind_unix_command();\n                iVar30 = iVar30 + -1;\n              }\n              else {\n                iVar18 = strvec_search(lVar20,*(undefined8 *)(lVar19 + -8 + lVar28 * 8));\n                if (iVar18 < 0) {\n                  iVar30 = iVar30 + -1;\n                  unbind_unix_command(*(undefined8 *)(lVar19 + -8 + lVar28 * 8));\n                }\n              }\n              iVar18 = (int)lVar28;\n              lVar28 = lVar28 + 1;\n            } while (iVar18 < iVar16 && 0 < iVar30);\n          }\n        }\n        strvec_dispose(lVar19);\n        strvec_dispose(lVar20);\n        puVar32 = (undefined8 *)*puVar32;\n      } while( true );\n    }\n    sVar25 = strlen(local_70);\n    uVar26 = sh_xmalloc(sVar25 * 2 + 1,\"./bind.def\",0x176);\n    iVar15 = rl_translate_keyseq(local_70,uVar26,&local_48);\n    if (iVar15 == 0) {\n      puVar27 = (undefined *)rl_function_of_keyseq_len(uVar26,(long)local_48,0,&local_44);\n      if (puVar27 == (undefined *)0x0) {\n        sh_xfree(uVar26,\"./bind.def\",0x17f);\n        if (local_50 != 0) {\n          rl_set_keymap(local_50);\n          run_unwind_frame(\"bind_builtin\");\n          iVar15 = 0;\n          goto LAB_001a1f09;\n        }\n      }\n      else {\n        if (local_44 == 1) {\n          puVar27 = *(undefined **)(puVar27 + 0x1008);\n        }\n        iVar15 = rl_bind_keyseq(local_70,0);\n        if (iVar15 != 0) {\n          sh_xfree(uVar26,\"./bind.def\",0x18a);\n          builtin_error(\"`%s\\': cannot unbind\",local_70);\n          goto joined_r0x001a2382;\n        }\n        if (puVar27 == PTR_bash_execute_unix_command_00237fb0) {\n          unbind_unix_command(local_70);\n        }\n        sh_xfree(uVar26,\"./bind.def\",0x192);\n        if (local_50 != 0) {\n          rl_set_keymap(local_50);\n          run_unwind_frame(\"bind_builtin\");\n          iVar15 = 0;\n          goto LAB_001a1f09;\n        }\n      }\n      run_unwind_frame(\"bind_builtin\");\n      iVar15 = 0;\n      goto LAB_001a1f09;\n    }\n    sh_xfree(uVar26,\"./bind.def\",0x179);\n    builtin_error(\"`%s\\': cannot unbind\",local_70);\n  }\njoined_r0x001a2382:\n  if (local_50 != 0) {\n    rl_set_keymap(local_50);\n  }\n  run_unwind_frame(\"bind_builtin\");\n  iVar15 = 1;\nLAB_001a1f09:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    sh_chkwrite(iVar15);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\nswitchD_001a1ee4_caseD_50:\n  bVar11 = true;\n  goto LAB_001a1ec0;\n}\n\n",
  "find_special_builtin": "\nundefined8 find_special_builtin(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  current_builtin = builtin_address_internal(param_1,0);\n  uVar1 = 0;\n  if ((current_builtin != 0) && ((*(byte *)(current_builtin + 0x10) & 8) != 0)) {\n    uVar1 = *(undefined8 *)(current_builtin + 8);\n  }\n  return uVar1;\n}\n\n",
  "remove_unwind_protect": "\nvoid remove_unwind_protect(void)\n\n{\n  if (DAT_00248390 != 0) {\n    FUN_00184010();\n    return;\n  }\n  return;\n}\n\n",
  "export_builtin": "\nvoid export_builtin(undefined8 param_1)\n\n{\n  set_or_show_attributes(param_1,1,0);\n  return;\n}\n\n",
  "FUN_00151f00": "\nlong FUN_00151f00(long param_1)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  int local_24;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_002422c0 == 0) {\n    DAT_002422c0 = get_group_list(&local_24);\n    uVar1 = *(undefined8 *)(param_1 + 8);\n    if (0 < local_24) {\n      lVar2 = 0;\n      do {\n        lVar3 = lVar2 + 1;\n        array_insert(uVar1,lVar2,*(undefined8 *)(DAT_002422c0 + lVar2 * 8));\n        lVar2 = lVar3;\n      } while ((int)lVar3 < local_24);\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return param_1;\n}\n\n",
  "init_eltstate": "\nvoid init_eltstate(undefined4 *param_1)\n\n{\n  if (param_1 != (undefined4 *)0x0) {\n    *param_1 = 0xffff;\n    *(undefined8 *)(param_1 + 6) = 0;\n    *(undefined8 *)(param_1 + 4) = 0;\n    *(undefined8 *)(param_1 + 2) = 0x8000000000000000;\n  }\n  return;\n}\n\n",
  "FUN_0013a230": "\n/* WARNING: Type propagation algorithm not settling */\n\nulong FUN_0013a230(void)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  void *pvVar9;\n  ulong uVar10;\n  long lVar11;\n  char **ppcVar12;\n  char *pcVar13;\n  long *plVar14;\n  uint uVar15;\n  uint uVar16;\n  undefined8 uVar17;\n  char *pcVar18;\n  size_t sVar19;\n  bool bVar20;\n  uint uVar21;\n  char cVar22;\n  size_t sVar23;\n  undefined **ppuVar24;\n  int iVar25;\n  char cVar26;\n  ulong uVar27;\n  long in_FS_OFFSET;\n  bool bVar28;\n  bool bVar29;\n  bool bVar30;\n  bool bVar31;\n  uint local_a8;\n  int local_50;\n  int local_4c;\n  long local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((parser_state & 0x300) == 0x100) {\n    parser_state = parser_state | 0x200;\n    DAT_00240b3c = line_number;\n    DAT_00240d64 = extended_glob;\n    uVar17 = FUN_0013e0a0();\n    yylval = (char **)make_cond_command(uVar17);\n    if (DAT_00240b38 == 0x112) {\n      parser_state = parser_state & 0xfffffcff;\n      uVar27 = 0x11f;\n      DAT_00240b58 = 0x112;\n    }\n    else if ((EOF_Reached == 0) || (DAT_00240b38 == 0x113)) {\n      uVar27 = 0xffffffff;\n      if (DAT_00240b38 != 0x113) {\n        lVar11 = FUN_00135070();\n        if (lVar11 == 0) {\n          parser_error(DAT_00240b3c,\"syntax error in conditional expression\");\n        }\n        else {\n          parser_error(DAT_00240b3c,\"syntax error in conditional expression: unexpected token `%s\\'\"\n                       ,lVar11);\n          sh_xfree(lVar11,\"/usr/local/src/chet/src/bash/src/parse.y\",0x11c9);\n        }\n      }\n    }\n    else {\n      uVar27 = 0xffffffff;\n      parser_error(DAT_00240b3c,\"unexpected EOF while looking for `]]\\'\");\n    }\n  }\n  else {\nLAB_0013a270:\n    do {\n      uVar4 = FUN_00137960(1);\n      uVar27 = (ulong)uVar4;\n      if (uVar4 == 0xffffffff) {\nLAB_0013c250:\n        EOF_Reached = 1;\n        uVar27 = 0x131;\n        goto LAB_0013b2e7;\n      }\n    } while ((*(byte *)((long)&sh_syntaxtab + (ulong)(uVar4 & 0xff) * 4 + 1) & 0x20) != 0);\n    if (uVar4 == 0) {\n      if ((bash_input != 3) ||\n         ((pushed_string_list != 0 && (*(long *)(pushed_string_list + 0x18) != 0))))\n      goto LAB_0013a2ad;\n      goto LAB_0013c250;\n    }\n    if (uVar4 == 0x23) {\n      if (((interactive == 0) || (interactive_comments != 0)) &&\n         ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')))) {\n        parser_state = parser_state | 0x100000;\n        do {\n          iVar7 = FUN_00137960(0);\n          if (iVar7 == -1) goto LAB_0013b375;\n        } while (iVar7 != 10);\n        if ((DAT_00240da8 == 0) || (DAT_00240da0 == 0)) {\n          DAT_00240b34 = 10;\n        }\n        else {\n          *(undefined *)((DAT_00240da8 - 1) + DAT_00240da0) = 10;\n          DAT_00240da0 = DAT_00240da0 - 1;\n        }\nLAB_0013b375:\n        FUN_00137960(0);\n        parser_state = parser_state & 0xffefffff;\nLAB_0013b386:\n        if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n          if (need_here_doc != 0) {\n            gather_here_documents();\n          }\n          parser_state = parser_state & 0xffffbffd;\n          uVar27 = 10;\n          goto LAB_0013b2e7;\n        }\n        uVar27 = 10;\n      }\n    }\n    else if (uVar4 == 10) goto LAB_0013b386;\nLAB_0013a2ad:\n    uVar4 = (uint)uVar27;\n    if ((parser_state & 0x10000) == 0) {\n      if (((*(byte *)(&sh_syntaxtab + (uVar27 & 0xff)) & 1) != 0) &&\n         ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')))) {\n        bVar28 = uVar4 != 0x3c;\n        bVar29 = uVar4 == 0x3e;\n        uVar5 = parser_state;\n        if ((uVar4 & 0xfffffffd) == 0x3c) {\n          uVar5 = parser_state & 0xfffffffd;\n        }\n        parser_state = uVar5 & 0xffffbfff;\n        if (((uVar5 & 0x40) == 0) || (uVar4 != shell_eof_token)) {\n          uVar5 = FUN_00137960(1);\n        }\n        else {\n          uVar5 = FUN_00137960(0);\n        }\n        uVar3 = line_number;\n        if (uVar4 != uVar5) {\n          bVar30 = uVar5 == 0x26;\n          if ((bVar28) || (!bVar30)) {\n            if ((bVar29) && (bVar30)) {\n              if (1 < DAT_00240da0) goto LAB_0013c7a9;\nLAB_0013d03b:\n              uVar27 = 0x126;\n            }\n            else {\nLAB_0013c917:\n              if ((bVar28) || (uVar5 != 0x3e)) goto LAB_0013a38d;\n              if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n                uVar27 = 0x12d;\n              }\n              else {\nLAB_0013c7b9:\n                if ((uVar4 != 0x3b) || (!bVar30)) goto switchD_0013c98f_caseD_27;\n                if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))\n                goto joined_r0x0013c7f8;\n                uVar27 = 0x128;\n                parser_state = parser_state & 0xfffffffd | 1;\n              }\n            }\n          }\n          else {\n            if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))\n            goto LAB_0013a382;\n            uVar27 = 0x124;\n          }\n          goto LAB_0013b2e7;\n        }\n        if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n          if ((int)uVar4 < 0x3f) {\n            if (0x25 < (int)uVar4) {\n              switch(uVar4) {\n              case 0x26:\n                uVar27 = 0x120;\n                goto LAB_0013b2e7;\n              case 0x28:\n                if (DAT_00240d70 == 0x109) {\n                  if (DAT_00238074 < 0x80) {\n                    DAT_00238074 = DAT_00238074 + 1;\n                  }\n                  (&DAT_00240b60)[DAT_00238074] = line_number;\n                  DAT_00240d80 = uVar3;\n                  iVar7 = FUN_0013a0d0(&local_48);\n                  if (iVar7 == 1) {\n                    plVar14 = (long *)alloc_word_desc();\n                    uVar27 = 0x11e;\n                    *plVar14 = local_48;\n                    yylval = (char **)make_word_list(plVar14,0);\n                    goto LAB_0013b2e7;\n                  }\n                }\n                else {\n                  iVar7 = FUN_00134c60();\n                  if (iVar7 == 0) break;\n                  iVar7 = FUN_0013a0d0(&local_48);\n                  if (iVar7 == 1) {\n                    plVar14 = (long *)alloc_word_desc();\n                    uVar27 = 0x11d;\n                    *(undefined4 *)(plVar14 + 1) = 0x101032;\n                    *plVar14 = local_48;\n                    yylval = (char **)make_word_list(plVar14,0);\n                    goto LAB_0013b2e7;\n                  }\n                  if (iVar7 == 0) {\n                    FUN_001357c0(local_48,0,0);\n                    *(undefined4 *)(pushed_string_list + 0x3c) = 2;\n                    if ((parser_state & 1) == 0) {\n                      parser_state = parser_state | 0x20;\n                    }\n                    goto LAB_0013b2e7;\n                  }\n                }\n                uVar27 = 0xffffffff;\n                goto LAB_0013b2e7;\n              case 0x3b:\n                parser_state = parser_state & 0xfffffffd | 1;\n                uVar4 = FUN_00137960(1);\n                if (uVar4 == 0x26) {\n                  if (DAT_00240da0 < 2) {\n                    uVar27 = 0x129;\n                    goto LAB_0013b2e7;\n                  }\n                  uVar27 = 0x129;\n                  uVar10 = DAT_00240da8;\n                  if (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0') goto LAB_0013b2e7;\njoined_r0x0013d245:\n                  if (uVar10 != 0) {\n                    DAT_00240da0 = DAT_00240da0 - 1;\n                    uVar27 = 0x127;\n                    *(char *)(DAT_00240da8 + DAT_00240da0) = (char)uVar4;\n                    goto LAB_0013b2e7;\n                  }\n                }\n                else {\n                  uVar10 = DAT_00240da0;\n                  if (DAT_00240da8 != 0) goto joined_r0x0013d245;\n                }\n                uVar27 = 0x127;\n                DAT_00240b34 = uVar4;\n                goto LAB_0013b2e7;\n              case 0x3c:\n                uVar4 = FUN_00137960(1);\n                if (uVar4 == 0x2d) {\n                  uVar27 = 0x12a;\n                  if (DAT_00240da0 < 2) goto LAB_0013b2e7;\nLAB_0013cda5:\n                  uVar10 = DAT_00240da8;\n                  if (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0') goto LAB_0013b2e7;\njoined_r0x0013d18f:\n                  if (uVar10 != 0) {\n                    *(char *)((DAT_00240da8 - 1) + DAT_00240da0) = (char)uVar4;\n                    uVar27 = 0x123;\n                    DAT_00240da0 = DAT_00240da0 - 1;\n                    goto LAB_0013b2e7;\n                  }\n                }\n                else {\n                  if (uVar4 == 0x3c) {\n                    uVar27 = 0x125;\n                    if (1 < DAT_00240da0) goto LAB_0013cda5;\n                    goto LAB_0013b2e7;\n                  }\n                  uVar10 = DAT_00240da0;\n                  if (DAT_00240da8 != 0) goto joined_r0x0013d18f;\n                }\n                uVar27 = 0x123;\n                DAT_00240b34 = uVar4;\n                goto LAB_0013b2e7;\n              case 0x3e:\n                uVar27 = 0x122;\n                goto LAB_0013b2e7;\n              }\n            }\n          }\n          else if (uVar4 == 0x7c) {\n            uVar27 = 0x121;\n            goto LAB_0013b2e7;\n          }\nswitchD_0013c98f_caseD_27:\n          if ((DAT_00240da8 != 0) && (DAT_00240da0 != 0)) goto LAB_0013a3e2;\nLAB_0013c7fe:\n          DAT_00240b34 = uVar5;\n          if (uVar4 == 0x29) goto LAB_0013a402;\nLAB_0013c814:\n          if (uVar4 == 0x28) {\n            if ((parser_state & 1) == 0) {\n              if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))\n              goto LAB_0013c84a;\n              parser_state = parser_state | 0x20;\n            }\n          }\n          else {\nLAB_0013c84a:\n            if (((uVar4 & 0xfffffffd) == 0x3c) && (uVar5 == 0x28)) goto joined_r0x0013a472;\n          }\nLAB_0013a441:\n          if (DAT_00240da0 < 2) goto LAB_0013b2e7;\n        }\n        else {\n          bVar30 = uVar4 == 0x26;\n          if ((bVar28) || (!bVar30)) {\n            if ((!bVar29) || (!bVar30)) goto LAB_0013c917;\nLAB_0013c7a9:\n            if (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0') goto LAB_0013d03b;\n            bVar30 = true;\n            goto LAB_0013c7b9;\n          }\nLAB_0013a382:\n          bVar30 = true;\nLAB_0013a38d:\n          if ((uVar5 == 0x7c) && (bVar29)) {\n            if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))\n            goto switchD_0013c98f_caseD_27;\n            uVar27 = 0x12e;\n            goto LAB_0013b2e7;\n          }\n          if ((uVar4 == 0x26) && (uVar5 == 0x3e)) {\n            if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n              uVar4 = FUN_00137960(1);\n              if (uVar4 == 0x3e) {\n                if (DAT_00240da0 < 2) {\n                  uVar27 = 300;\n                  goto LAB_0013b2e7;\n                }\n                uVar27 = 300;\n                uVar10 = DAT_00240da8;\n                if (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0') goto LAB_0013b2e7;\njoined_r0x0013d369:\n                if (uVar10 != 0) {\n                  DAT_00240da0 = DAT_00240da0 - 1;\n                  uVar27 = 299;\n                  *(char *)(DAT_00240da8 + DAT_00240da0) = (char)uVar4;\n                  goto LAB_0013b2e7;\n                }\n              }\n              else {\n                uVar10 = DAT_00240da0;\n                if (DAT_00240da8 != 0) goto joined_r0x0013d369;\n              }\n              uVar27 = 299;\n              DAT_00240b34 = uVar4;\n              goto LAB_0013b2e7;\n            }\n          }\n          else {\n            if ((uVar4 != 0x7c) || (!bVar30)) goto LAB_0013c7b9;\n            if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n              uVar27 = 0x12f;\n              goto LAB_0013b2e7;\n            }\n          }\njoined_r0x0013c7f8:\n          if (DAT_00240da8 == 0) goto LAB_0013c7fe;\nLAB_0013a3e2:\n          uVar10 = DAT_00240da0 - 1;\n          *(char *)((DAT_00240da8 - 1) + DAT_00240da0) = (char)uVar5;\n          DAT_00240da0 = uVar10;\n          if (uVar4 != 0x29) goto LAB_0013c814;\nLAB_0013a402:\n          if ((DAT_00240d70 == 0x28) && (DAT_00240d6c == 0x119)) {\n            if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n              DAT_00240d88 = line_number;\n              parser_state = parser_state & 0xfffffffd | 4;\n              goto LAB_0013a416;\n            }\n            if ((parser_state & 1) != 0) goto LAB_0013cb7c;\nLAB_0013a41f:\n            if ((parser_state & 0x20) != 0) {\n              if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))\n              goto joined_r0x0013a472;\n              parser_state = parser_state & 0xffffffdf;\n            }\n            goto LAB_0013a441;\n          }\nLAB_0013a416:\n          if ((parser_state & 1) == 0) goto LAB_0013a41f;\n          if (DAT_00240da0 < 2) {\nLAB_0013cb87:\n            parser_state = parser_state & 0xfffffffe;\n            goto LAB_0013a441;\n          }\nLAB_0013cb7c:\n          if (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0') goto LAB_0013cb87;\n          if ((parser_state & 0x20) != 0) goto joined_r0x0013a472;\n        }\n        if (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0') goto LAB_0013b2e7;\n      }\n      if (((uVar4 == 0x2d) && ((DAT_00240d70 & 0xfffffffd) == 0x124)) &&\n         ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0'))))\n      goto LAB_0013b2e7;\n    }\njoined_r0x0013a472:\n    if (DAT_00240b20 < 0x1f0) {\n      DAT_00240b20 = 0x1f0;\n      DAT_00240b28 = (char *)sh_xrealloc(DAT_00240b28,0x1f0,\n                                         \"/usr/local/src/chet/src/bash/src/parse.y\",0x1301);\n    }\n    bVar1 = false;\n    bVar30 = false;\n    bVar28 = uVar4 - 0x30 < 10;\n    bVar2 = false;\n    bVar29 = false;\n    iVar7 = 0;\n    do {\n      cVar26 = (char)uVar27;\n      uVar4 = (uint)uVar27;\n      pcVar18 = DAT_00240b28;\n      if (bVar29) {\n        sVar23 = (size_t)iVar7;\n        bVar29 = false;\n        bVar20 = true;\nLAB_0013a65b:\n        iVar25 = iVar7 + 1;\n        if (DAT_00240b20 <= (ulong)(long)iVar25) {\n          do {\n            DAT_00240b20 = DAT_00240b20 + 0x200;\n          } while (DAT_00240b20 <= (ulong)(long)iVar25);\n          pcVar18 = (char *)sh_xrealloc(pcVar18,DAT_00240b20,\n                                        \"/usr/local/src/chet/src/bash/src/parse.y\",0x143e);\n          DAT_00240b28 = pcVar18;\n        }\nLAB_0013a671:\n        pcVar18[sVar23] = cVar26;\n        bVar28 = (bool)(bVar28 & uVar4 - 0x30 < 10);\n        bVar2 = (bool)(bVar2 | uVar4 == 0x24);\njoined_r0x0013a606:\n        if (uVar4 == 10) {\nLAB_0013a69a:\n          if (((interactive != 0) && (bash_input - 1U < 2)) &&\n             ((pushed_string_list == 0 || (*(long *)(pushed_string_list + 0x18) == 0)))) {\n            FUN_001373e0();\n          }\n        }\n      }\n      else {\n        lVar11 = (long)DAT_00240a18;\n        iVar25 = 0;\n        if (DAT_00240a18 != 0) {\n          iVar25 = (int)*(char *)(dstack + -1 + (long)DAT_00240a18);\n        }\n        if (uVar4 != 0x5c) {\n          local_a8 = uVar4 & 0xff;\n          uVar5 = local_a8;\n          if (((*(byte *)(&sh_syntaxtab + (uVar27 & 0xff)) & 8) == 0) ||\n             ((1 < DAT_00240da0 && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0')))) {\nLAB_0013a7b0:\n            local_a8 = uVar5;\n            if ((((parser_state & 0x10000) == 0) ||\n                (bVar20 = uVar4 == 0x28 || uVar4 == 0x7c, uVar4 != 0x28 && uVar4 != 0x7c)) ||\n               ((1 < DAT_00240da0 && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))))\n            goto LAB_0013a910;\n            sVar23 = (size_t)iVar7;\n            if (uVar4 == 0x7c) goto LAB_0013a65b;\n            if (DAT_00240a1c <= DAT_00240a18 + 1) {\n              DAT_00240a1c = DAT_00240a1c + 10;\n              dstack = sh_xrealloc(dstack,(long)DAT_00240a1c,\n                                   \"/usr/local/src/chet/src/bash/src/parse.y\",0x1354);\n              lVar11 = (long)DAT_00240a18;\n            }\n            *(undefined *)(dstack + lVar11) = 0x28;\n            DAT_00240a18 = DAT_00240a18 + 1;\n            pcVar18 = (char *)FUN_00138cc0(iVar25,0x28,0x29,&local_50,0);\n            DAT_00240a18 = DAT_00240a18 + -1;\n            if (pcVar18 == &DAT_00240b10) goto LAB_0013b8e7;\n            uVar27 = (ulong)(iVar7 + 2 + local_50);\n            if (DAT_00240b20 <= uVar27) {\n              do {\n                DAT_00240b20 = DAT_00240b20 + 0x200;\n              } while (DAT_00240b20 <= uVar27);\n              DAT_00240b28 = (char *)sh_xrealloc(DAT_00240b28,DAT_00240b20,\n                                                 \"/usr/local/src/chet/src/bash/src/parse.y\",0x1359);\n            }\n            pcVar13 = DAT_00240b28;\n            DAT_00240b28[iVar7] = '(';\n            strcpy(pcVar13 + (iVar7 + 1),pcVar18);\n            iVar25 = iVar7 + 1 + local_50;\n            uVar17 = 0x135e;\nLAB_0013a8ad:\n            bVar2 = false;\n            bVar28 = false;\n            sh_xfree(pcVar18,\"/usr/local/src/chet/src/bash/src/parse.y\",uVar17);\n            goto LAB_0013a610;\n          }\n          if (DAT_00240a1c <= DAT_00240a18 + 1) {\n            DAT_00240a1c = DAT_00240a1c + 10;\n            dstack = sh_xrealloc(dstack,(long)DAT_00240a1c,\n                                 \"/usr/local/src/chet/src/bash/src/parse.y\",0x1339);\n            lVar11 = (long)DAT_00240a18;\n          }\n          *(char *)(dstack + lVar11) = cVar26;\n          DAT_00240a18 = DAT_00240a18 + 1;\n          pcVar18 = (char *)FUN_00138cc0(uVar27,uVar27,uVar27,&local_50,(ulong)(uVar4 == 0x60) << 3)\n          ;\n          DAT_00240a18 = DAT_00240a18 + -1;\n          if (pcVar18 != &DAT_00240b10) {\n            uVar27 = (ulong)(iVar7 + 2 + local_50);\n            if (DAT_00240b20 <= uVar27) {\n              do {\n                DAT_00240b20 = DAT_00240b20 + 0x200;\n              } while (DAT_00240b20 <= uVar27);\n              DAT_00240b28 = (char *)sh_xrealloc(DAT_00240b28,DAT_00240b20,\n                                                 \"/usr/local/src/chet/src/bash/src/parse.y\",0x133e);\n            }\n            pcVar13 = DAT_00240b28;\n            DAT_00240b28[iVar7] = cVar26;\n            strcpy(pcVar13 + (iVar7 + 1),pcVar18);\n            iVar25 = iVar7 + 1 + local_50;\n            if (((uVar4 != 0x60) && (bVar1 = true, uVar4 == 0x22)) &&\n               (pcVar13 = strchr(pcVar18,0x24), pcVar13 != (char *)0x0)) {\n              bVar2 = true;\n            }\n            sh_xfree(pcVar18,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1347);\nLAB_0013a602:\n            bVar28 = false;\n            bVar20 = true;\n            goto joined_r0x0013a606;\n          }\nLAB_0013b8e7:\n          uVar5 = 0xffffffff;\n          goto LAB_0013bc11;\n        }\n        if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n          if ((parser_state & 0x400000) != 0) {\n            bVar1 = true;\n            sVar23 = (size_t)iVar7;\n            bVar20 = false;\n            bVar29 = true;\n            goto LAB_0013a65b;\n          }\n          uVar5 = FUN_00137960(0);\n          bVar29 = false;\n          if (uVar5 != 10) {\n            if ((DAT_00240da8 != 0) && (DAT_00240da0 != 0)) goto LAB_0013acbf;\nLAB_0013b13c:\n            DAT_00240b34 = uVar5;\n            if (iVar25 != 0) goto LAB_0013acd5;\n            goto LAB_0013b14e;\n          }\n          if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0')) {\n            if (DAT_00240da8 == 0) goto LAB_0013b13c;\nLAB_0013acbf:\n            DAT_00240da0 = DAT_00240da0 - 1;\n            *(char *)(DAT_00240da8 + DAT_00240da0) = (char)uVar5;\n            if (iVar25 == 0) {\nLAB_0013b14e:\n              sVar23 = (size_t)iVar7;\n              if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n                bVar20 = false;\n                bVar1 = true;\n                bVar29 = true;\n                pcVar18 = DAT_00240b28;\n                goto LAB_0013a65b;\n              }\n            }\n            else {\nLAB_0013acd5:\n              sVar23 = (size_t)iVar7;\n              if (iVar25 == 0x60) goto LAB_0013b14e;\n              bVar20 = (bool)(iVar25 == 0x22 & (byte)~(byte)(uVar5 >> 0x18) >> 7);\n              if (bVar20 != false) {\n                if ((*(byte *)(&sh_syntaxtab + (int)uVar5) & 0x40) == 0) {\n                  bVar1 = true;\n                  bVar29 = false;\n                  pcVar18 = DAT_00240b28;\n                  goto LAB_0013a65b;\n                }\n                goto LAB_0013b14e;\n              }\n            }\n            sVar23 = (size_t)iVar7;\n            bVar1 = true;\n            bVar20 = true;\n            pcVar18 = DAT_00240b28;\n            goto LAB_0013a65b;\n          }\n          bVar20 = true;\n          iVar25 = iVar7;\n          goto LAB_0013a69a;\n        }\n        local_a8 = 0x5c;\n        uVar5 = local_a8;\n        local_a8 = 0x5c;\n        if ((DAT_00239590 & 8) != 0) goto LAB_0013a7b0;\nLAB_0013a910:\n        if ((extended_glob != 0) && (uVar4 - 0x21 < 0x20)) {\n          uVar27 = 0xc0000601L >> ((byte)(uVar4 - 0x21) & 0x3f);\n          uVar5 = DAT_00240b34;\n          if ((uVar27 & 1) == 0) {\nLAB_0013abc0:\n            DAT_00240b34 = uVar5;\n            if (((uVar4 & 0xfffffffd) == 0x3c) || (uVar4 == 0x24)) goto LAB_0013aa68;\n          }\n          else if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n            uVar5 = FUN_00137960(1);\n            if (uVar5 == 0x28) {\n              if ((DAT_00240da0 < 2) ||\n                 (uVar10 = DAT_00240da8, *(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n                if (DAT_00240a1c <= DAT_00240a18 + 1) {\n                  DAT_00240a1c = DAT_00240a1c + 10;\n                  dstack = sh_xrealloc(dstack,(long)DAT_00240a1c,\n                                       \"/usr/local/src/chet/src/bash/src/parse.y\",0x136b);\n                }\n                *(undefined *)(dstack + DAT_00240a18) = 0x28;\n                DAT_00240a18 = DAT_00240a18 + 1;\n                pcVar18 = (char *)FUN_00138cc0(iVar25,0x28,0x29,&local_50,0);\n                DAT_00240a18 = DAT_00240a18 + -1;\n                if (pcVar18 == &DAT_00240b10) goto LAB_0013b8e7;\n                uVar10 = (ulong)(iVar7 + 3 + local_50);\n                if (DAT_00240b20 <= uVar10) {\n                  do {\n                    DAT_00240b20 = DAT_00240b20 + 0x200;\n                  } while (DAT_00240b20 <= uVar10);\n                  DAT_00240b28 = (char *)sh_xrealloc(DAT_00240b28,DAT_00240b20,\n                                                     \"/usr/local/src/chet/src/bash/src/parse.y\",\n                                                     0x1370);\n                }\n                pcVar13 = DAT_00240b28;\n                bVar20 = (bool)((byte)uVar27 & 1);\n                DAT_00240b28[iVar7] = cVar26;\n                pcVar13[iVar7 + 1] = '(';\n                strcpy(pcVar13 + (iVar7 + 2),pcVar18);\n                iVar25 = iVar7 + 2 + local_50;\n                uVar17 = 0x1377;\n                goto LAB_0013a8ad;\n              }\n            }\n            else {\n              uVar10 = DAT_00240da0;\n              if (DAT_00240da8 == 0) goto LAB_0013abc0;\n            }\n            if (uVar10 != 0) {\n              DAT_00240da0 = DAT_00240da0 - 1;\n              *(char *)(DAT_00240da8 + DAT_00240da0) = (char)uVar5;\n              uVar5 = DAT_00240b34;\n            }\n            goto LAB_0013abc0;\n          }\nLAB_0013abf0:\n          uVar5 = DAT_00240b34;\n          if ((uVar4 != 0x3d) || (iVar7 < 1)) {\nLAB_0013aae7:\n            DAT_00240b34 = uVar5;\n            sVar23 = (size_t)iVar7;\n            pcVar18 = DAT_00240b28;\n            if ((*(byte *)(&sh_syntaxtab + (int)local_a8) & 2) != 0) goto LAB_0013a9e5;\n            if ((uVar4 != 1) && (uVar4 != 0x7f)) {\nLAB_0013d374:\n              sVar23 = (size_t)iVar7;\n              bVar29 = false;\n              bVar20 = true;\n              pcVar18 = DAT_00240b28;\n              goto LAB_0013a65b;\n            }\n            if (1 < DAT_00240da0) goto LAB_0013aa14;\nLAB_0013ab27:\n            iVar25 = iVar7 + 2;\n            if (DAT_00240b20 <= (ulong)(long)iVar25) {\n              do {\n                DAT_00240b20 = DAT_00240b20 + 0x200;\n              } while (DAT_00240b20 <= (ulong)(long)iVar25);\n              pcVar18 = (char *)sh_xrealloc(pcVar18,DAT_00240b20,\n                                            \"/usr/local/src/chet/src/bash/src/parse.y\",0x1438);\n              DAT_00240b28 = pcVar18;\n            }\n            pcVar18[sVar23] = '\\x01';\n            bVar20 = true;\n            sVar23 = (size_t)(iVar7 + 1);\n            goto LAB_0013a671;\n          }\n          uVar27 = (ulong)parser_state;\n          if (DAT_00240d70 == 0x11a) {\nLAB_0013ac45:\n            if ((uVar27 & 1) != 0) goto LAB_0013ac4e;\n          }\n          else {\n            if ((parser_state & 0x80000) != 0) {\n              if ((int)DAT_00240d70 < 0x12f) {\n                if ((int)DAT_00240d70 < 0x122) {\n                  if ((DAT_00240d70 & 0xfffffffd) == 0x3c) goto LAB_0013b107;\n                }\n                else if ((0x1b1fUL >> ((ulong)(DAT_00240d70 - 0x122) & 0x3f) & 1) != 0)\n                goto LAB_0013b0f8;\n              }\n              goto LAB_0013ac45;\n            }\nLAB_0013b0f8:\n            if (2 < DAT_00240d70 - 0x127) {\nLAB_0013b107:\n              iVar25 = FUN_00134c60();\n              if (iVar25 != 0) goto LAB_0013ac45;\n            }\nLAB_0013ac4e:\n            if ((uVar27 & 0x4000) == 0) {\nLAB_0013ac57:\n              sVar23 = (size_t)iVar7;\n              pcVar18 = DAT_00240b28;\n              uVar5 = DAT_00240b34;\n              goto LAB_0013a9d0;\n            }\n          }\n          pcVar18 = DAT_00240b28;\n          iVar25 = iVar7 + 3;\n          pvVar9 = (void *)sh_xmalloc((long)iVar25,\"/usr/local/src/chet/src/bash/src/parse.y\",0x12bf\n                                     );\n          sVar23 = (size_t)iVar7;\n          pvVar9 = memcpy(pvVar9,pcVar18,sVar23);\n          *(undefined *)((long)pvVar9 + sVar23) = 0x3d;\n          *(undefined *)((long)pvVar9 + sVar23 + 1) = 0;\n          iVar6 = assignment(pvVar9,parser_state >> 0xd & 1);\n          sh_xfree(pvVar9,\"/usr/local/src/chet/src/bash/src/parse.y\",0x12c6);\n          bVar20 = 0 < iVar6 && iVar6 == iVar7;\n          pcVar18 = DAT_00240b28;\n          uVar5 = DAT_00240b34;\n          if (0 < iVar6 && iVar6 == iVar7) {\n            if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))\n            goto LAB_0013b659;\n            uVar5 = FUN_00137960(1);\n            pcVar18 = DAT_00240b28;\n            if (uVar5 == 0x28) {\n              if ((DAT_00240da0 < 2) ||\n                 (uVar27 = DAT_00240da8, *(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n                pcVar18 = (char *)FUN_0013d700(&local_50);\n                uVar27 = (ulong)(iVar7 + 4 + local_50);\n                if (DAT_00240b20 <= uVar27) {\n                  do {\n                    DAT_00240b20 = DAT_00240b20 + 0x200;\n                  } while (DAT_00240b20 <= uVar27);\n                  DAT_00240b28 = (char *)sh_xrealloc(DAT_00240b28,DAT_00240b20,\n                                                     \"/usr/local/src/chet/src/bash/src/parse.y\",\n                                                     0x1413);\n                }\n                pcVar13 = DAT_00240b28;\n                DAT_00240b28[sVar23] = '=';\n                pcVar13[sVar23 + 1] = '(';\n                if (pcVar18 == (char *)0x0) {\n                  pcVar13[iVar7 + 2] = ')';\n                  bVar28 = false;\n                  bVar30 = true;\n                }\n                else {\n                  strcpy(pcVar13 + (iVar7 + 2),pcVar18);\n                  iVar7 = local_50 + iVar7 + 2;\n                  iVar25 = iVar7 + 1;\n                  pcVar13[iVar7] = ')';\n                  bVar28 = false;\n                  sh_xfree(pcVar18,\"/usr/local/src/chet/src/bash/src/parse.y\",0x141f);\n                  bVar30 = true;\n                }\n                goto LAB_0013a610;\n              }\n            }\n            else {\n              uVar27 = DAT_00240da0;\n              if (DAT_00240da8 == 0) goto LAB_0013a9d0;\n            }\n            if (uVar27 != 0) {\n              DAT_00240da0 = DAT_00240da0 - 1;\n              *(char *)(DAT_00240da8 + DAT_00240da0) = (char)uVar5;\n              uVar5 = DAT_00240b34;\n            }\n          }\nLAB_0013a9d0:\n          DAT_00240b34 = uVar5;\n          if ((*(byte *)(&sh_syntaxtab + (int)local_a8) & 2) == 0) {\n            bVar29 = false;\n            bVar20 = true;\n            goto LAB_0013a65b;\n          }\nLAB_0013a9e5:\n          if (1 < DAT_00240da0) {\n            cVar22 = *(char *)(DAT_00240e48 + -1 + DAT_00240da0);\n            goto joined_r0x0013aa02;\n          }\nLAB_0013b680:\n          uVar5 = uVar4;\n          if ((DAT_00240da8 != 0) && (DAT_00240da0 != 0)) {\n            *(char *)((DAT_00240da8 - 1) + DAT_00240da0) = cVar26;\n            uVar5 = DAT_00240b34;\n            DAT_00240da0 = DAT_00240da0 - 1;\n          }\n          DAT_00240b34 = uVar5;\n          uVar27 = DAT_00240da0;\n          pcVar18[sVar23] = '\\0';\n          if (!bVar28) goto LAB_0013b1e3;\n          if ((uVar4 == 0x3e) || (uVar4 == 0x3c)) goto LAB_0013b6eb;\n          goto LAB_0013b6cc;\n        }\n        if (((uVar4 & 0xfffffffd) != 0x3c) && (uVar4 != 0x24)) {\nLAB_0013a94e:\n          if (uVar4 != 0x5b) goto LAB_0013abf0;\n          pcVar18 = DAT_00240b28;\n          uVar5 = DAT_00240b34;\n          if (0 < iVar7) {\n            uVar15 = parser_state;\n            if (DAT_00240d70 == 0x11a) {\nLAB_0013b480:\n              sVar19 = (long)iVar7;\n            }\n            else {\n              if ((parser_state & 0x80000) != 0) {\n                if ((int)DAT_00240d70 < 0x12f) {\n                  if ((int)DAT_00240d70 < 0x122) {\n                    sVar19 = (long)iVar7;\n                    if ((DAT_00240d70 & 0xfffffffd) == 0x3c) goto LAB_0013b86d;\n                    goto joined_r0x0013b490;\n                  }\n                  if ((0x1b1fUL >> ((ulong)(DAT_00240d70 - 0x122) & 0x3f) & 1) != 0)\n                  goto LAB_0013b850;\n                }\n                goto LAB_0013b480;\n              }\nLAB_0013b850:\n              sVar23 = (size_t)iVar7;\n              if (DAT_00240d70 - 0x127 < 3) goto LAB_0013a9d0;\nLAB_0013b86d:\n              sVar19 = (size_t)iVar7;\n              sVar23 = sVar19;\n              iVar6 = FUN_00134c60(DAT_00240d70);\n              pcVar18 = DAT_00240b28;\n              uVar5 = DAT_00240b34;\n              if (iVar6 == 0) goto LAB_0013a9d0;\n            }\njoined_r0x0013b490:\n            sVar23 = sVar19;\n            pcVar18 = DAT_00240b28;\n            uVar5 = DAT_00240b34;\n            if ((uVar15 & 1) == 0) {\n              pcVar18 = DAT_00240b28 + sVar23;\n              cVar22 = *pcVar18;\n              *pcVar18 = '\\0';\n              iVar6 = legal_identifier();\n              *pcVar18 = cVar22;\n              pcVar18 = DAT_00240b28;\n              uVar5 = DAT_00240b34;\n              if (iVar6 != 0) goto LAB_0013b630;\n            }\n            goto LAB_0013a9d0;\n          }\n          if (iVar7 != 0) goto LAB_0013ac57;\n          if ((parser_state & 0x2000) == 0) {\n            sVar23 = 0;\n            goto LAB_0013a9d0;\n          }\nLAB_0013b630:\n          if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n            pcVar18 = (char *)FUN_00138cc0(iVar25,0x5b,0x5d,&local_50,0x20);\n            if (pcVar18 == &DAT_00240b10) goto LAB_0013b8e7;\n            uVar27 = (ulong)(iVar7 + 2 + local_50);\n            if (DAT_00240b20 <= uVar27) {\n              do {\n                DAT_00240b20 = DAT_00240b20 + 0x200;\n              } while (DAT_00240b20 <= uVar27);\n              DAT_00240b28 = (char *)sh_xrealloc(DAT_00240b28,DAT_00240b20,\n                                                 \"/usr/local/src/chet/src/bash/src/parse.y\",0x1401);\n            }\n            pcVar13 = DAT_00240b28;\n            DAT_00240b28[iVar7] = '[';\n            strcpy(pcVar13 + (iVar7 + 1),pcVar18);\n            iVar25 = iVar7 + 1 + local_50;\n            bVar28 = false;\n            sh_xfree(pcVar18,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1407);\n            bVar20 = true;\n            goto LAB_0013a610;\n          }\nLAB_0013b659:\n          sVar23 = (size_t)iVar7;\n          if ((*(byte *)(&sh_syntaxtab + (int)local_a8) & 2) == 0) goto LAB_0013d374;\n          cVar22 = *(char *)(DAT_00240e48 + -1 + DAT_00240da0);\n          pcVar18 = DAT_00240b28;\njoined_r0x0013aa02:\n          if (cVar22 == '\\0') {\n            if ((uVar4 == 0x7f) || (uVar4 == 1)) {\nLAB_0013aa14:\n              if (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0') goto LAB_0013ab27;\n            }\n            bVar20 = true;\n            goto LAB_0013a65b;\n          }\n          goto LAB_0013b680;\n        }\nLAB_0013aa68:\n        if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))\n        goto LAB_0013a94e;\n        uVar5 = FUN_00137960(1);\n        uVar3 = line_number;\n        cVar22 = (char)uVar5;\n        if (uVar5 != 0x28) {\n          if ((uVar5 & 0xffffffdf) != 0x5b) goto LAB_0013af23;\n          if (uVar4 == 0x24) {\n            if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n              if (uVar5 == 0x7b) {\n                pcVar18 = (char *)FUN_00138cc0(iVar25,0x7b,0x7d,&local_50,0x41);\n              }\n              else {\n                pcVar18 = (char *)FUN_00138cc0(iVar25,0x5b,0x5d,&local_50,0);\n              }\n              goto joined_r0x0013b798;\n            }\n            goto LAB_0013af2b;\n          }\nLAB_0013aac4:\n          uVar27 = DAT_00240da0;\n          if (DAT_00240da8 != 0) {\njoined_r0x0013d02c:\n            if (uVar27 != 0) {\nLAB_0013af88:\n              DAT_00240da0 = DAT_00240da0 - 1;\n              *(char *)(DAT_00240da8 + DAT_00240da0) = cVar22;\n              uVar5 = DAT_00240b34;\n            }\n          }\n          goto LAB_0013aae7;\n        }\n        if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n          if (DAT_00240a1c <= DAT_00240a18 + 1) {\n            DAT_00240a1c = DAT_00240a1c + 10;\n            dstack = sh_xrealloc(dstack,(long)DAT_00240a1c,\n                                 \"/usr/local/src/chet/src/bash/src/parse.y\",0x1392);\n          }\n          *(undefined *)(dstack + DAT_00240a18) = 0x28;\n          DAT_00240a18 = DAT_00240a18 + 1;\n          pcVar18 = (char *)FUN_00138940(iVar25,&local_50);\n          DAT_00240a18 = DAT_00240a18 + -1;\njoined_r0x0013b798:\n          if (pcVar18 != &DAT_00240b10) {\n            uVar27 = (ulong)(iVar7 + 3 + local_50);\n            if (DAT_00240b20 <= uVar27) {\n              do {\n                DAT_00240b20 = DAT_00240b20 + 0x200;\n              } while (DAT_00240b20 <= uVar27);\n              DAT_00240b28 = (char *)sh_xrealloc(DAT_00240b28,DAT_00240b20,\n                                                 \"/usr/local/src/chet/src/bash/src/parse.y\",0x139a);\n            }\n            pcVar13 = DAT_00240b28;\n            DAT_00240b28[iVar7] = cVar26;\n            pcVar13[iVar7 + 1] = cVar22;\n            strcpy(pcVar13 + (iVar7 + 2),pcVar18);\n            iVar25 = iVar7 + 2 + local_50;\n            bVar2 = true;\n            sh_xfree(pcVar18,\"/usr/local/src/chet/src/bash/src/parse.y\",0x13a1);\n            goto LAB_0013a602;\n          }\n          goto LAB_0013b8e7;\n        }\nLAB_0013af23:\n        if (uVar4 != 0x24) goto LAB_0013aac4;\nLAB_0013af2b:\n        bVar31 = uVar5 == 0x27;\n        bVar20 = uVar5 == 0x22 || bVar31;\n        if (uVar5 == 0x22 || bVar31) {\n          if ((DAT_00240da0 < 2) || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')) {\n            if (DAT_00240a1c <= DAT_00240a18 + 1) {\n              DAT_00240a1c = DAT_00240a1c + 10;\n              dstack = sh_xrealloc(dstack,(long)DAT_00240a1c,\n                                   \"/usr/local/src/chet/src/bash/src/parse.y\",0x13b0);\n            }\n            *(char *)(dstack + DAT_00240a18) = cVar22;\n            DAT_00240a18 = DAT_00240a18 + 1;\n            pcVar18 = (char *)FUN_00138cc0(uVar5,uVar5,uVar5,&local_50,bVar31 * '\\x02');\n            DAT_00240a18 = DAT_00240a18 + -1;\n            if (pcVar18 == &DAT_00240b10) goto LAB_0013b8e7;\n            if (uVar5 == 0x27) {\n              uVar17 = ansiexpand(pcVar18,0,local_50 + -1,&local_4c);\n              sh_xfree(pcVar18,\"/usr/local/src/chet/src/bash/src/parse.y\",0x13bb);\n              pcVar18 = (char *)sh_single_quote(uVar17);\n              sh_xfree(uVar17,\"/usr/local/src/chet/src/bash/src/parse.y\",0x13c1);\n              sVar23 = strlen(pcVar18);\n              local_4c = (int)sVar23;\n            }\n            else {\n              pcVar13 = (char *)locale_expand(pcVar18,0,local_50 + -1,uVar3,&local_4c);\n              sh_xfree(pcVar18,\"/usr/local/src/chet/src/bash/src/parse.y\",0x13cb);\n              iVar25 = local_4c;\n              if ((singlequote_translations == 0) ||\n                 ((local_50 + -1 == local_4c &&\n                  ((local_4c == 0 ||\n                   ((*pcVar18 == *pcVar13 &&\n                    (iVar6 = strncmp(pcVar18,pcVar13,(long)local_4c), iVar6 == 0)))))))) {\n                pcVar18 = (char *)sh_mkdoublequoted(pcVar13,iVar25,0);\n              }\n              else {\n                pcVar18 = (char *)sh_single_quote(pcVar13);\n              }\n              sh_xfree(pcVar13,\"/usr/local/src/chet/src/bash/src/parse.y\",0x13d5);\n              sVar23 = strlen(pcVar18);\n              local_4c = (int)sVar23;\n            }\n            uVar27 = (ulong)(local_4c + 1 + iVar7);\n            if (DAT_00240b20 <= uVar27) {\n              do {\n                DAT_00240b20 = DAT_00240b20 + 0x200;\n              } while (DAT_00240b20 <= uVar27);\n              DAT_00240b28 = (char *)sh_xrealloc(DAT_00240b28,DAT_00240b20,\n                                                 \"/usr/local/src/chet/src/bash/src/parse.y\",0x13db);\n            }\n            bVar28 = false;\n            strcpy(DAT_00240b28 + iVar7,pcVar18);\n            iVar25 = iVar7 + local_4c;\n            sh_xfree(pcVar18,\"/usr/local/src/chet/src/bash/src/parse.y\",0x13e0);\n            bVar1 = true;\n            goto LAB_0013a610;\n          }\n          uVar27 = DAT_00240da8;\n          if (uVar5 != 0x24) goto joined_r0x0013d02c;\nLAB_0013af78:\n          if (DAT_00240da8 == 0) goto LAB_0013aae7;\n          goto LAB_0013af88;\n        }\n        if (uVar5 != 0x24) goto LAB_0013aac4;\n        if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))\n        goto LAB_0013af78;\n        if (DAT_00240b20 <= (ulong)(long)(iVar7 + 3)) {\n          do {\n            DAT_00240b20 = DAT_00240b20 + 0x200;\n          } while (DAT_00240b20 <= (ulong)(long)(iVar7 + 3));\n          DAT_00240b28 = (char *)sh_xrealloc(DAT_00240b28,DAT_00240b20,\n                                             \"/usr/local/src/chet/src/bash/src/parse.y\",0x13e9);\n        }\n        pcVar18 = DAT_00240b28;\n        bVar28 = false;\n        iVar25 = iVar7 + 2;\n        DAT_00240b28[iVar7] = '$';\n        bVar20 = true;\n        bVar2 = true;\n        pcVar18[iVar7 + 1] = '$';\n      }\nLAB_0013a610:\n      if (DAT_00240a18 != 0) {\n        bVar20 = (bool)(bVar20 & *(char *)(dstack + -1 + (long)DAT_00240a18) != '\\'');\n      }\n      uVar4 = FUN_00137960(bVar20);\n      pcVar18 = DAT_00240b28;\n      uVar27 = (ulong)uVar4;\n      iVar7 = iVar25;\n    } while (uVar4 != 0xffffffff);\n    sVar23 = (size_t)iVar25;\n    DAT_00240b28[sVar23] = '\\0';\n    uVar4 = 0xffffffff;\n    if (!bVar28) {\nLAB_0013b1e3:\n      uVar27 = DAT_00240da0;\n      uVar15 = DAT_00240d70;\n      pcVar18 = DAT_00240b28;\n      iVar25 = DAT_00240b1c;\n      if ((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0'))\n      goto LAB_0013b9ce;\n      if (DAT_00240d70 == 0x119) {\n        if ((DAT_00240d6c == 0x107) || (DAT_00240d6c - 0x109U < 2)) {\n          if ((*DAT_00240b28 == 'i') && ((DAT_00240b28[1] == 'n' && (DAT_00240b28[2] == '\\0')))) {\n            if (DAT_00240d6c == 0x107) {\n              parser_state = parser_state | 1;\n              DAT_00240b1c = DAT_00240b1c + 1;\n            }\n            if (DAT_00240b18 == 0) {\n              uVar27 = 0x114;\n            }\n            else {\nLAB_0013c8ab:\n              DAT_00240b18 = DAT_00240b18 + -1;\n              uVar27 = 0x114;\n            }\n          }\n          else {\n            if (DAT_00240b18 != 0) goto LAB_0013c648;\n            if (1 < DAT_00240d6c - 0x109U) goto LAB_0013b246;\nLAB_0013c29e:\n            if (((*DAT_00240b28 != 'd') || (DAT_00240b28[1] != 'o')) || (DAT_00240b28[2] != '\\0'))\n            goto LAB_0013b246;\n            if (DAT_00240b18 != 0) goto LAB_0013c2c7;\nLAB_0013c684:\n            uVar27 = 0x10d;\n          }\n          goto LAB_0013b2e7;\n        }\n        if (DAT_00240b18 != 0) {\nLAB_0013c648:\n          if (((*DAT_00240b28 == 'i') && (DAT_00240b28[1] == 'n')) && (DAT_00240b28[2] == '\\0'))\n          goto LAB_0013cadc;\n          if (DAT_00240d6c - 0x109U < 2) goto LAB_0013c29e;\n        }\nLAB_0013b246:\n        if (((parser_state & 4) == 0) ||\n           (parser_state = parser_state & 0xfffffffb, *DAT_00240b28 != '{')) {\n          if (DAT_00240d70 != 0x11e) goto LAB_0013b270;\n          if (*DAT_00240b28 == 'd') {\n            if ((DAT_00240b28[1] == 'o') && (DAT_00240b28[2] == '\\0')) goto LAB_0013c684;\n          }\n          else if (*DAT_00240b28 == '{') goto LAB_0013c9f4;\n        }\n        else {\nLAB_0013c9dd:\n          if (pcVar18[1] == '\\0') {\n            DAT_00240d84 = line_number;\n            DAT_00240b14 = DAT_00240b14 + 1;\n            uVar27 = 0x7b;\n            goto LAB_0013b2e7;\n          }\n          if (uVar15 != 0x11e) goto LAB_0013b270;\nLAB_0013c9f4:\n          if (pcVar18[1] == '\\0') {\n            DAT_00240b14 = DAT_00240b14 + 1;\n            uVar27 = 0x7b;\n            goto LAB_0013b2e7;\n          }\n        }\n        iVar25 = DAT_00240b14;\n        if (DAT_00240b14 != 0) goto LAB_0013b27c;\nLAB_0013b2b7:\n        if (((parser_state & 0x200) != 0) &&\n           (((*pcVar18 == ']' && (pcVar18[1] == ']')) && (pcVar18[2] == '\\0')))) {\n          uVar27 = 0x112;\n          goto LAB_0013b2e7;\n        }\n      }\n      else {\n        if (DAT_00240b18 != 0) {\n          if (DAT_00240d70 == 10) {\n            cVar26 = *DAT_00240b28;\n            if (cVar26 == 'i') {\n              if ((DAT_00240b28[1] != 'n') || (DAT_00240b28[2] != '\\0')) goto LAB_0013b230;\nLAB_0013cadc:\n              if ((parser_state & 0x80) != 0) {\n                parser_state = parser_state | 1;\n                DAT_00240b1c = DAT_00240b1c + 1;\n              }\n              goto LAB_0013c8ab;\n            }\n          }\n          else {\n            if (DAT_00240d70 != 0x3b) goto LAB_0013b230;\n            cVar26 = *DAT_00240b28;\n          }\n          if (((cVar26 == 'd') && (DAT_00240b28[1] == 'o')) && (DAT_00240b28[2] == '\\0')) {\nLAB_0013c2c7:\n            DAT_00240b18 = DAT_00240b18 + -1;\n            uVar27 = 0x10d;\n            goto LAB_0013b2e7;\n          }\n        }\nLAB_0013b230:\n        if ((DAT_00240b1c == 0) || (DAT_00240d70 != 0x114)) goto LAB_0013b246;\n        if ((*DAT_00240b28 == 'e') && (iVar6 = strcmp(DAT_00240b28,\"esac\"), iVar6 == 0)) {\n          DAT_00240b1c = iVar25 + -1;\n          parser_state = parser_state & 0xfffffffe;\n          uVar27 = 0x108;\n          goto LAB_0013b2e7;\n        }\n        if ((parser_state & 4) == 0) {\n          iVar25 = DAT_00240b14;\n          if (DAT_00240b14 == 0) goto LAB_0013b2b7;\nLAB_0013b27c:\n          iVar25 = DAT_00240b14;\n          iVar6 = FUN_00134c60(uVar15);\n          if ((iVar6 == 0) || (*pcVar18 != '}')) goto LAB_0013b292;\n          if (pcVar18[1] == '\\0') {\n            DAT_00240b14 = iVar25 + -1;\n            uVar27 = 0x7d;\n            goto LAB_0013b2e7;\n          }\n          if (uVar15 == 0x116) goto LAB_0013b2b7;\nLAB_0013b29e:\n          if ((uVar15 != 0x117) || (*pcVar18 != '-')) goto LAB_0013b2b7;\n          if (pcVar18[1] == '-') {\nLAB_0013c394:\n            if (pcVar18[2] == '\\0') {\n              uVar27 = 0x118;\n              goto LAB_0013b2e7;\n            }\n          }\n        }\n        else {\n          parser_state = parser_state & 0xfffffffb;\n          if (*pcVar18 == '{') goto LAB_0013c9dd;\nLAB_0013b270:\n          iVar25 = DAT_00240b14;\n          if (DAT_00240b14 != 0) goto LAB_0013b27c;\nLAB_0013b292:\n          if (uVar15 != 0x116) goto LAB_0013b29e;\n          if (*pcVar18 != '-') goto LAB_0013b2b7;\n          if (pcVar18[1] != 'p') {\n            if (pcVar18[1] != '-') goto LAB_0013be03;\n            goto LAB_0013c394;\n          }\n          if (pcVar18[2] == '\\0') {\n            uVar27 = 0x117;\n            goto LAB_0013b2e7;\n          }\n        }\n      }\nLAB_0013be03:\n      if (posixly_correct == 0) goto LAB_0013bcc6;\n      if (((1 < uVar27) && (*(char *)(DAT_00240e48 + -1 + uVar27) == '\\0')) ||\n         (bVar28 = (bool)(bVar2 | bVar1), bVar28)) goto LAB_0013b9dc;\n      iVar6 = FUN_00134c60(uVar15);\n      bVar2 = bVar28;\n      if ((iVar6 == 0) || (word_token_alist == (undefined *)0x0)) {\nLAB_0013be3d:\n        if (expand_aliases == 0) goto LAB_0013be4b;\n        goto LAB_0013c032;\n      }\n      cVar26 = *pcVar18;\n      ppuVar24 = &PTR_DAT_00238290;\n      iVar6 = 0;\n      pcVar13 = word_token_alist;\n      do {\n        if ((cVar26 == *pcVar13) && (iVar8 = strcmp(pcVar18,pcVar13), iVar8 == 0)) {\n          uVar5 = (&DAT_00238288)[(long)iVar6 * 4];\n          if ((parser_state & 1) != 0) {\n            if (((uVar5 != 0x108) || (uVar15 == 0x7c)) || (uVar15 == 0x28)) goto LAB_0013be3d;\n            goto LAB_0013cd48;\n          }\n          if (uVar5 == 0x116) {\n            iVar25 = FUN_00134b60();\n            if (iVar25 == 0) goto LAB_0013be3d;\n            goto LAB_0013bc11;\n          }\n          if (uVar5 == 0x108) goto LAB_0013cd48;\n          if (uVar5 == 0x107) goto LAB_0013cfec;\n          if (uVar5 == 0x112) goto LAB_0013d1af;\n          if (uVar5 == 0x111) goto LAB_0013d212;\n          if (uVar5 == 0x7b) goto LAB_0013bde7;\n          if (uVar5 != 0x7d) goto LAB_0013d150;\n          if (iVar25 == 0) goto LAB_0013d16b;\n          DAT_00240b14 = iVar25 + -1;\n          goto LAB_0013bc11;\n        }\n        pcVar13 = *ppuVar24;\n        ppuVar24 = ppuVar24 + 2;\n        iVar6 = iVar6 + 1;\n      } while (pcVar13 != (char *)0x0);\n      if (expand_aliases != 0) goto LAB_0013c032;\n      goto LAB_0013be4b;\n    }\nLAB_0013b6cc:\n    uVar27 = DAT_00240da0;\n    if ((DAT_00240d70 & 0xfffffffd) != 0x124) goto LAB_0013b1e3;\nLAB_0013b6eb:\n    if ((uVar27 < 2) || (*(char *)(DAT_00240e48 + -1 + uVar27) != '\\0')) {\n      iVar25 = legal_number(pcVar18,&local_48);\n      if ((iVar25 == 0) || (local_48 != (int)local_48)) goto LAB_0013b1e3;\n      yylval = (char **)CONCAT44(yylval._4_4_,(int)local_48);\n      uVar27 = 0x11c;\n      goto LAB_0013b2e7;\n    }\nLAB_0013b9ce:\n    if (posixly_correct == 0) {\nLAB_0013bcc6:\n      if ((expand_aliases != 0) && (pcVar18 = DAT_00240b28, !bVar1)) goto LAB_0013c032;\nLAB_0013bcdb:\n      uVar15 = DAT_00240d70;\n      if (((1 < DAT_00240da0) && (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) == '\\0')) ||\n         ((bool)(bVar2 | bVar1))) goto LAB_0013ba01;\n      iVar25 = FUN_00134c60(DAT_00240d70);\n      pcVar18 = DAT_00240b28;\n      if ((iVar25 == 0) || (word_token_alist == (undefined *)0x0)) {\nLAB_0013be4b:\n        ppcVar12 = (char **)alloc_word_desc();\n        pcVar13 = (char *)sh_xmalloc((long)(iVar7 + 1),\"/usr/local/src/chet/src/bash/src/parse.y\",\n                                     0x1483);\n        *(undefined4 *)(ppcVar12 + 1) = 0;\n        *ppcVar12 = pcVar13;\n        pcVar18 = DAT_00240b28;\n        strcpy(pcVar13,DAT_00240b28);\n        goto LAB_0013ba60;\n      }\n      ppuVar24 = &PTR_DAT_00238290;\n      cVar26 = *DAT_00240b28;\n      iVar25 = 0;\n      pcVar13 = word_token_alist;\n      while ((cVar26 != *pcVar13 || (iVar6 = strcmp(pcVar18,pcVar13), iVar6 != 0))) {\n        pcVar13 = *ppuVar24;\n        ppuVar24 = ppuVar24 + 2;\n        iVar25 = iVar25 + 1;\n        if (pcVar13 == (char *)0x0) goto LAB_0013be4b;\n      }\n      uVar5 = (&DAT_00238288)[(long)iVar25 * 4];\n      if ((parser_state & 1) != 0) {\n        if (((uVar5 != 0x108) || (uVar15 == 0x7c)) || (uVar15 == 0x28)) goto LAB_0013be4b;\nLAB_0013cd48:\n        parser_state = parser_state & 0xffffff7e;\n        DAT_00240b1c = DAT_00240b1c + -1;\n        uVar5 = 0x108;\n        goto LAB_0013bc11;\n      }\n      if (uVar5 == 0x116) {\n        iVar25 = FUN_00134b60();\n        if (iVar25 == 0) goto LAB_0013be4b;\n        uVar27 = 0x116;\n        goto LAB_0013b2e7;\n      }\n      if (uVar5 == 0x108) goto LAB_0013cd48;\n      if (uVar5 == 0x107) {\nLAB_0013cfec:\n        parser_state = parser_state | 0x80;\n        goto LAB_0013bc11;\n      }\n      if (uVar5 == 0x112) {\nLAB_0013d1af:\n        parser_state = parser_state & 0xfffffcff;\n        goto LAB_0013bc11;\n      }\n      if (uVar5 == 0x111) {\nLAB_0013d212:\n        parser_state = parser_state | 0x100;\n        goto LAB_0013bc11;\n      }\n      if (uVar5 == 0x7b) {\nLAB_0013bde7:\n        DAT_00240b14 = DAT_00240b14 + 1;\n        goto LAB_0013bc11;\n      }\n      if (uVar5 == 0x7d) {\n        if (DAT_00240b14 == 0) {\nLAB_0013d16b:\n          uVar5 = 0x7d;\n        }\n        else {\n          DAT_00240b14 = DAT_00240b14 + -1;\n        }\n        goto LAB_0013bc11;\n      }\nLAB_0013d150:\n      if (uVar5 != 0xffffff9d) goto LAB_0013bc11;\n      goto LAB_0013a270;\n    }\nLAB_0013b9dc:\n    if ((expand_aliases != 0) && (pcVar18 = DAT_00240b28, !bVar1)) {\nLAB_0013c032:\n      uVar27 = (ulong)parser_state;\n      if ((parser_state & 2) == 0) {\n        if (DAT_00240d70 == 0x11a) {\nLAB_0013c079:\n          uVar5 = (uint)uVar27;\n          if ((uVar27 & 1) == 0) goto LAB_0013c082;\n        }\n        else {\n          if ((parser_state & 0x80000) != 0) {\n            if ((int)DAT_00240d70 < 0x12f) {\n              if ((int)DAT_00240d70 < 0x122) {\n                if ((DAT_00240d70 & 0xfffffffd) == 0x3c) goto LAB_0013cc14;\n              }\n              else if ((0x1b1fUL >> ((ulong)(DAT_00240d70 - 0x122) & 0x3f) & 1) != 0)\n              goto LAB_0013cbaa;\n            }\n            goto LAB_0013c079;\n          }\nLAB_0013cbaa:\n          uVar5 = parser_state;\n          if (2 < DAT_00240d70 - 0x127) {\nLAB_0013cc14:\n            iVar25 = FUN_00134c60();\n            uVar5 = (uint)uVar27;\n            if (iVar25 != 0) goto LAB_0013c079;\n          }\n        }\n      }\n      else {\nLAB_0013c082:\n        lVar11 = find_alias(pcVar18);\n        uVar5 = parser_state;\n        if ((lVar11 != 0) && ((*(byte *)(lVar11 + 0x10) & 2) == 0)) {\n          pcVar18 = *(char **)(lVar11 + 8);\n          sVar23 = strlen(pcVar18);\n          pcVar13 = (char *)sh_xmalloc((long)((int)sVar23 + 2),\n                                       \"/usr/local/src/chet/src/bash/src/parse.y\",0xbdd);\n          pcVar18 = strcpy(pcVar13,pcVar18);\n          pcVar18[(int)sVar23] = '\\0';\n          FUN_001357c0(pcVar18,*(byte *)(lVar11 + 0x10) & 1,lVar11);\n          goto LAB_0013a270;\n        }\n      }\n      parser_state = uVar5 & 0xfffffffd;\n      bVar1 = false;\n    }\n    if (posixly_correct == 0) goto LAB_0013bcdb;\nLAB_0013ba01:\n    ppcVar12 = (char **)alloc_word_desc();\n    pcVar13 = (char *)sh_xmalloc((long)(iVar7 + 1),\"/usr/local/src/chet/src/bash/src/parse.y\",0x1483\n                                );\n    pcVar18 = DAT_00240b28;\n    *(undefined4 *)(ppcVar12 + 1) = 0;\n    *ppcVar12 = pcVar13;\n    strcpy(pcVar13,pcVar18);\n    if (bVar2) {\n      *(uint *)(ppcVar12 + 1) = *(uint *)(ppcVar12 + 1) | 1;\n    }\n    if (bVar1) {\n      *(uint *)(ppcVar12 + 1) = *(uint *)(ppcVar12 + 1) | 2;\n    }\nLAB_0013ba60:\n    if ((bVar30) && (pcVar18[sVar23 - 1] == ')')) {\n      *(uint *)(ppcVar12 + 1) = *(uint *)(ppcVar12 + 1) | 0x8000;\n    }\n    iVar7 = assignment(pcVar18,parser_state >> 0xd & 1);\n    uVar15 = DAT_00240d70;\n    uVar5 = parser_state;\n    uVar27 = (ulong)DAT_00240d70;\n    if (iVar7 == 0) {\nLAB_0013bb18:\n      pcVar18 = DAT_00240b28;\n      if ((int)uVar27 != 0x11a) {\n        if ((parser_state & 0x80000) == 0) goto LAB_0013bc74;\nLAB_0013bb39:\n        uVar5 = (uint)uVar27;\n        pcVar18 = DAT_00240b28;\n        if ((int)uVar5 < 0x12f) {\n          if ((int)uVar5 < 0x122) {\n            if ((uVar5 & 0xfffffffd) == 0x3c) goto LAB_0013bc8e;\n          }\n          else if ((0x1b1fUL >> ((ulong)(uVar5 - 0x122) & 0x3f) & 1) != 0) goto LAB_0013bc74;\n        }\n      }\nLAB_0013bb69:\n      lVar11 = builtin_address_internal(pcVar18,0);\n      pcVar13 = DAT_00240b28;\n      if ((lVar11 != 0) && ((*(byte *)(lVar11 + 0x10) & 0x10) != 0)) {\nLAB_0013bb95:\n        parser_state = parser_state | 0x4000;\n        goto LAB_0013bb9f;\n      }\n      if (*DAT_00240b28 == 'e') {\n        pcVar18 = \"eval\";\n      }\n      else {\n        if (*DAT_00240b28 != 'l') goto LAB_0013bb9f;\n        pcVar18 = \"let\";\n      }\n      iVar7 = strcmp(DAT_00240b28,pcVar18);\n      if (iVar7 == 0) goto LAB_0013bb95;\n      cVar26 = *pcVar13;\n    }\n    else {\n      uVar21 = *(uint *)(ppcVar12 + 1);\n      uVar27 = (ulong)DAT_00240d70;\n      *(uint *)(ppcVar12 + 1) = uVar21 | 4;\n      if (uVar15 == 0x11a) {\njoined_r0x0013bb07:\n        if ((uVar5 & 1) == 0) {\n          *(uint *)(ppcVar12 + 1) = uVar21 | 0x14;\n        }\n        if ((uVar5 & 0x2000) != 0) {\nLAB_0013bc31:\n          *(uint *)(ppcVar12 + 1) = uVar21 | 0x34;\n        }\n        goto LAB_0013bb18;\n      }\n      uVar16 = uVar5 & 0x80000;\n      if (uVar16 != 0) {\n        if ((int)uVar15 < 0x12f) {\n          if ((int)uVar15 < 0x122) {\n            if ((uVar15 & 0xfffffffd) == 0x3c) goto LAB_0013c690;\n          }\n          else if ((0x1b1fUL >> ((ulong)(uVar15 - 0x122) & 0x3f) & 1) != 0) goto LAB_0013bc54;\n        }\n        goto joined_r0x0013bb07;\n      }\nLAB_0013bc54:\n      if (2 < uVar15 - 0x127) {\nLAB_0013c690:\n        iVar7 = FUN_00134c60(uVar27);\n        if (iVar7 != 0) goto joined_r0x0013bb07;\n      }\n      if ((uVar5 & 0x2000) != 0) goto LAB_0013bc31;\n      if (uVar16 != 0) goto LAB_0013bb39;\nLAB_0013bc74:\n      pcVar13 = DAT_00240b28;\n      if (2 < (int)uVar27 - 0x127U) {\nLAB_0013bc8e:\n        pcVar13 = DAT_00240b28;\n        pcVar18 = DAT_00240b28;\n        iVar7 = FUN_00134c60(uVar27 & 0xffffffff);\n        if (iVar7 != 0) goto LAB_0013bb69;\n      }\nLAB_0013bb9f:\n      cVar26 = *pcVar13;\n    }\n    if ((((cVar26 == '{') && (pcVar13[sVar23 - 1] == '}')) && ((uVar4 & 0xfffffffd) == 0x3c)) &&\n       ((DAT_00240da0 < 2 || (*(char *)(DAT_00240e48 + -1 + DAT_00240da0) != '\\0')))) {\n      yylval = ppcVar12;\n      pcVar13[sVar23 - 1] = '\\0';\n      iVar7 = legal_identifier(pcVar13 + 1);\n      if ((iVar7 != 0) || (iVar7 = valid_array_reference(DAT_00240b28 + 1,0), iVar7 != 0)) {\n        uVar27 = 0x11b;\n        strcpy(*ppcVar12,DAT_00240b28 + 1);\n        yylval = ppcVar12;\n        goto LAB_0013b2e7;\n      }\n    }\n    uVar5 = ((*(uint *)(ppcVar12 + 1) & 0x14) == 0x14) + 0x119;\n    if ((int)DAT_00240d70 < 0x10b) {\n      if ((0x108 < (int)DAT_00240d70) || (yylval = ppcVar12, DAT_00240d70 == 0x107)) {\n        if (DAT_00238074 < 0x80) {\n          DAT_00238074 = DAT_00238074 + 1;\n        }\n        DAT_00240b18 = DAT_00240b18 + 1;\n        yylval = ppcVar12;\n        (&DAT_00240b60)[DAT_00238074] = line_number;\n      }\n    }\n    else {\n      yylval = ppcVar12;\n      if (DAT_00240d70 == 0x10f) {\n        DAT_00240d88 = line_number;\n        parser_state = parser_state | 4;\n      }\n    }\nLAB_0013bc11:\n    uVar27 = (ulong)uVar5;\n  }\nLAB_0013b2e7:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar27;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "get_dollar_var_value": "\nchar * get_dollar_var_value(long param_1)\n\n{\n  size_t sVar1;\n  char *__dest;\n  char *pcVar2;\n  long lVar3;\n  undefined8 uVar4;\n  long *plVar5;\n  bool bVar6;\n  \n  if (param_1 < 10) {\n    pcVar2 = (char *)(&dollar_vars)[param_1];\n    if (pcVar2 == (char *)0x0) {\n      return (char *)0x0;\n    }\n    sVar1 = strlen(pcVar2);\n    uVar4 = 0xe8c;\n  }\n  else {\n    if (rest_of_args == (long *)0x0) {\n      return (char *)0x0;\n    }\n    lVar3 = param_1 + -0xb;\n    plVar5 = rest_of_args;\n    if (param_1 != 10) {\n      do {\n        plVar5 = (long *)*plVar5;\n        if (plVar5 == (long *)0x0) {\n          return (char *)0x0;\n        }\n        bVar6 = lVar3 != 0;\n        lVar3 = lVar3 + -1;\n      } while (bVar6);\n    }\n    pcVar2 = *(char **)plVar5[1];\n    sVar1 = strlen(pcVar2);\n    uVar4 = 0xe92;\n  }\n  __dest = (char *)sh_xmalloc(sVar1 + 1,\"subst.c\",uVar4);\n  pcVar2 = strcpy(__dest,pcVar2);\n  return pcVar2;\n}\n\n",
  "jump_to_top_level": "\nvoid jump_to_top_level_noreturn_(undefined4 param_1)\n\n{\n                    /* WARNING: Subroutine does not return */\n  __longjmp_chk(top_level,param_1);\n}\n\n",
  "FUN_001c0390": "\n/* WARNING: Type propagation algorithm not settling */\n\nulong FUN_001c0390(byte *param_1,byte *param_2,byte *param_3,byte *param_4,byte **param_5,\n                  uint param_6)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  bool bVar3;\n  byte bVar4;\n  byte bVar5;\n  byte bVar6;\n  char cVar7;\n  int iVar8;\n  uint uVar9;\n  ushort **ppuVar10;\n  __int32_t **pp_Var11;\n  byte *pbVar12;\n  char *pcVar13;\n  void *pvVar14;\n  uint uVar15;\n  ushort *puVar16;\n  long lVar17;\n  byte *pbVar18;\n  uint uVar19;\n  char *__s2;\n  uint uVar20;\n  ulong uVar21;\n  uint uVar22;\n  char cVar23;\n  byte *pbVar24;\n  byte bVar25;\n  ulong uVar26;\n  byte bVar27;\n  long lVar28;\n  long in_FS_OFFSET;\n  bool bVar29;\n  bool bVar30;\n  byte *local_b0;\n  byte *local_a8;\n  undefined8 local_68;\n  byte *local_60;\n  byte local_4a;\n  undefined local_49;\n  undefined2 local_48;\n  undefined local_46;\n  byte local_45;\n  undefined4 local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_b0 = param_1;\n  if (param_3 < param_4) {\n    uVar19 = param_6 & 0x10;\n    bVar2 = (byte)(param_6 >> 1);\n    bVar4 = (bVar2 ^ 1) & 1;\nLAB_001c03f7:\n    pbVar12 = param_3 + 1;\n    uVar21 = (ulong)*param_3;\n    if ((uVar19 != 0) &&\n       (ppuVar10 = __ctype_b_loc(), (*(byte *)((long)*ppuVar10 + uVar21 * 2 + 1) & 1) != 0)) {\n      pp_Var11 = __ctype_tolower_loc();\n      uVar21 = (ulong)(uint)(*pp_Var11)[uVar21];\n    }\n    uVar9 = (uint)uVar21;\n    uVar15 = 0;\n    if (local_b0 < param_2) {\n      uVar15 = (uint)*local_b0;\n    }\n    if ((interrupt_state | terminating_signal) != 0) goto LAB_001c0508;\n    uVar20 = param_6 & 0x20;\n    if (((uVar20 == 0) || (param_3[1] != 0x28)) || (0x1f < uVar9 - 0x21)) {\n      if (uVar9 == 0x5b) {\n        if ((uVar15 == 0) || (param_2 == local_b0)) goto LAB_001c0508;\n        if (((param_6 & 4) == 0) || (uVar15 != 0x2e)) {\n          if ((param_6 & 0x80) == 0) goto LAB_001c05ae;\n          if (((param_1 == local_b0) && (*param_1 == 0x2e)) &&\n             ((param_1[1] == 0 || ((param_1[1] == 0x2e && (param_1[2] == 0)))))) goto LAB_001c0508;\n          uVar9 = param_6 & 1;\n        }\n        else {\n          if (param_1 == local_b0) goto LAB_001c0508;\n          if ((param_6 & 1) == 0) goto LAB_001c05ae;\n          if (local_b0[-1] == 0x2f) goto LAB_001c0508;\n          uVar9 = param_6 & 0x80;\n        }\n        if ((((uVar9 == 0) || (local_b0[-1] != 0x2f)) || (*local_b0 != 0x2e)) ||\n           (((bVar25 = local_b0[1], bVar25 != 0x2f && (bVar25 != 0)) &&\n            ((bVar25 != 0x2e || ((local_b0[2] != 0x2f && (local_b0[2] != 0)))))))) {\nLAB_001c05ae:\n          lVar17 = (long)(int)uVar15;\n          bVar25 = (byte)uVar15;\n          if ((uVar19 != 0) &&\n             (ppuVar10 = __ctype_b_loc(), (*(byte *)((long)*ppuVar10 + lVar17 * 2 + 1) & 1) != 0)) {\n            pp_Var11 = __ctype_tolower_loc();\n            bVar25 = *(byte *)(*pp_Var11 + lVar17);\n          }\n          bVar5 = param_3[1];\n          bVar29 = bVar5 == 0x21;\n          bVar30 = bVar5 == 0x5e;\n          pbVar18 = pbVar12;\n          if (bVar29 || bVar30) {\n            bVar5 = param_3[2];\n            pbVar18 = param_3 + 2;\n          }\n          uVar21 = (ulong)bVar5;\n          local_a8 = pbVar18 + 1;\nLAB_001c0628:\n          cVar23 = (char)uVar21;\n          if (cVar23 == '[') {\n            bVar5 = *local_a8;\n            if (bVar5 != 0x3d) {\n              if (bVar5 != 0x3a) {\n                bVar3 = false;\n                uVar21 = 0x5b;\n                if (bVar5 == 0x2e) {\n                  bVar3 = true;\n                  local_a8 = (byte *)FUN_001bf860(local_a8,&local_68);\n                  uVar9 = (uint)local_68;\n                  if ((uint)local_68 == 0xffffffff) {\n                    uVar9 = bVar25 + 1;\n                  }\n                  uVar21 = (ulong)uVar9;\n                }\n                goto LAB_001c0735;\n              }\n              local_68 = (byte *)((ulong)local_68 & 0xffffffff00000000);\n              pbVar24 = local_a8 + 1;\n              bVar5 = local_a8[1];\n              pbVar18 = pbVar24;\n              while (bVar5 != 0) {\n                pbVar1 = pbVar18 + 1;\n                if ((bVar5 == 0x3a) && (*pbVar1 == 0x5d)) {\n                  lVar28 = (long)pbVar18 - (long)local_a8;\n                  pcVar13 = (char *)sh_malloc(lVar28,\"sm_loop.c\",0x1e4);\n                  if (pcVar13 == (char *)0x0) {\n                    local_68 = (byte *)((ulong)local_68 & 0xffffffff00000000);\n                    goto LAB_001c15ec;\n                  }\n                  uVar21 = 1;\n                  memmove(pcVar13,pbVar24,lVar28 - 1);\n                  pcVar13[lVar28 + -1] = '\\0';\n                  udequote_pathname(pcVar13);\n                  cVar23 = *pcVar13;\n                  cVar7 = 'a';\n                  __s2 = \"ascii\";\n                  goto LAB_001c1015;\n                }\n                pbVar18 = pbVar18 + 1;\n                bVar5 = *pbVar1;\n              }\n              goto LAB_001c1048;\n            }\n            bVar3 = false;\n            uVar21 = 0x5b;\n            if ((local_a8[2] != 0x3d) || (local_a8[3] != 0x5d)) {\nLAB_001c0735:\n              bVar27 = (byte)uVar21;\n              bVar5 = (bVar2 ^ 1) & 1;\n              cVar23 = '[';\n              pbVar18 = local_a8;\njoined_r0x001c0c26:\n              if (uVar19 != 0) goto LAB_001c0662;\n              do {\n                uVar21 = (ulong)*pbVar18;\n                pbVar24 = pbVar18 + 1;\nLAB_001c06b5:\n                cVar23 = (char)uVar21;\n                if (cVar23 == '\\0') goto joined_r0x001c146f;\n                if ((cVar23 == '/') && ((param_6 & 1) != 0)) goto LAB_001c0508;\n                if (cVar23 != '-') {\n                  if (bVar25 == bVar27) {\nLAB_001c0b80:\n                    local_a8 = pbVar24 + -1;\n                    goto LAB_001c0b92;\n                  }\nLAB_001c06e3:\n                  local_a8 = pbVar24;\n                  if ((char)uVar21 != ']') goto LAB_001c0628;\n                  goto LAB_001c06fa;\n                }\n                bVar6 = pbVar18[1];\n                uVar26 = (ulong)bVar6;\n                if (bVar6 != 0x5d) {\n                  local_a8 = pbVar18 + 2;\n                  if ((bVar6 == 0x5c) && (bVar5 != 0)) {\n                    local_a8 = pbVar18 + 3;\n                    uVar26 = (ulong)pbVar18[2];\n                  }\n                  if ((char)uVar26 == '\\0') goto LAB_001c0508;\n                  uVar21 = (ulong)*local_a8;\n                  if (((char)uVar26 == '[') && (*local_a8 == 0x2e)) {\n                    local_a8 = (byte *)FUN_001bf860(local_a8,&local_68);\n                    if ((uint)local_68 == -1) {\n                      bVar3 = true;\n                      uVar26 = (ulong)(bVar25 - 1);\n                      uVar21 = (ulong)*local_a8;\n                    }\n                    else {\n                      uVar26 = (ulong)local_68 & 0xffffffff;\n                      bVar3 = true;\n                      uVar21 = (ulong)*local_a8;\n                    }\n                  }\n                  uVar9 = (uint)uVar26;\n                  if (uVar19 != 0) {\n                    ppuVar10 = __ctype_b_loc();\n                    if ((*(byte *)((long)*ppuVar10 + (uVar26 & 0xff) * 2 + 1) & 1) != 0) {\n                      pp_Var11 = __ctype_tolower_loc();\n                      uVar9 = (uint)*(byte *)(*pp_Var11 + (uVar26 & 0xff));\n                    }\n                  }\n                  uVar20 = uVar9 & 0xff;\n                  pbVar24 = local_a8 + 1;\n                  if (uVar20 == bVar27) {\nLAB_001c081b:\n                    iVar8 = bVar27 - uVar20;\n                  }\n                  else {\n                    if ((bVar3) || (iVar8 = bVar27 - uVar20, glob_asciirange == 0)) {\n                      DAT_0023a6e0 = (byte)uVar9;\n                      DAT_0023a6e2 = bVar27;\n                      iVar8 = strcoll((char *)&DAT_0023a6e2,(char *)&DAT_0023a6e0);\n                    }\n                    if (iVar8 == 0) goto LAB_001c081b;\n                  }\n                  uVar22 = (uint)bVar27;\n                  if (0 < iVar8) {\n                    local_a8 = pbVar24;\n                    if ((char)uVar21 != ']') goto joined_r0x001c0834;\n                    goto LAB_001c06fa;\n                  }\n                  if (uVar22 == bVar25) {\nLAB_001c08b8:\n                    iVar8 = bVar25 - uVar22;\n                  }\n                  else {\n                    if ((bVar3) || (iVar8 = bVar25 - uVar22, glob_asciirange == 0)) {\n                      DAT_0023a6e0 = bVar27;\n                      DAT_0023a6e2 = bVar25;\n                      iVar8 = strcoll((char *)&DAT_0023a6e2,(char *)&DAT_0023a6e0);\n                    }\n                    if (iVar8 == 0) goto LAB_001c08b8;\n                  }\n                  uVar22 = (uint)bVar25;\n                  if (iVar8 < 0) goto LAB_001c06e3;\n                  if (uVar20 == uVar22) {\nLAB_001c0905:\n                    iVar8 = uVar22 - uVar20;\n                  }\n                  else {\n                    if ((bVar3) || (iVar8 = uVar22 - uVar20, glob_asciirange == 0)) {\n                      DAT_0023a6e0 = (byte)uVar9;\n                      DAT_0023a6e2 = bVar25;\n                      iVar8 = strcoll((char *)&DAT_0023a6e2,(char *)&DAT_0023a6e0);\n                    }\n                    if (iVar8 == 0) goto LAB_001c0905;\n                  }\n                  if (0 < iVar8) goto LAB_001c06e3;\n                  goto LAB_001c0b92;\n                }\n                if (bVar25 == bVar27) goto LAB_001c0b80;\n                uVar21 = 0x2d;\n                cVar23 = '-';\n                pbVar18 = pbVar24;\nLAB_001c064f:\n                bVar5 = (bVar2 ^ 1) & 1;\n                bVar27 = (byte)uVar21;\n                if (uVar19 != 0) {\n                  bVar3 = false;\nLAB_001c0662:\n                  bVar27 = (byte)uVar21;\n                  ppuVar10 = __ctype_b_loc();\n                  puVar16 = *ppuVar10;\n                  if ((*(byte *)((long)puVar16 + (uVar21 & 0xff) * 2 + 1) & 1) != 0) {\n                    pp_Var11 = __ctype_tolower_loc();\n                    bVar27 = *(byte *)(*pp_Var11 + (uVar21 & 0xff));\n                  }\n                  if (cVar23 == '\\0') goto joined_r0x001c146f;\n                  uVar21 = (ulong)*pbVar18;\n                  pbVar24 = pbVar18 + 1;\n                  if ((*(byte *)((long)puVar16 + uVar21 * 2 + 1) & 1) != 0) {\n                    pp_Var11 = __ctype_tolower_loc();\n                    uVar21 = (ulong)*(byte *)(*pp_Var11 + uVar21);\n                  }\n                  goto LAB_001c06b5;\n                }\n                if (cVar23 == '\\0') goto joined_r0x001c146f;\n                bVar3 = false;\n              } while( true );\n            }\n            bVar5 = local_a8[1];\n            uVar9 = (uint)bVar5;\n            if ((uVar19 != 0) &&\n               (ppuVar10 = __ctype_b_loc(),\n               (*(byte *)((long)*ppuVar10 + (ulong)bVar5 * 2 + 1) & 1) != 0)) {\n              pp_Var11 = __ctype_tolower_loc();\n              uVar9 = (*pp_Var11)[bVar5];\n            }\n            local_68 = (byte *)CONCAT44(local_68._4_4_,uVar9);\n            pbVar24 = local_a8 + 5;\n            bVar5 = (byte)uVar9;\n            if ((bVar25 == bVar5) ||\n               (DAT_0023a6e0 = bVar5, DAT_0023a6e2 = bVar25,\n               iVar8 = strcoll((char *)&DAT_0023a6e2,(char *)&DAT_0023a6e0), iVar8 == 0)) {\nLAB_001c169c:\n              local_a8 = local_a8 + 4;\n              goto LAB_001c0b92;\n            }\n            local_49 = 0;\n            local_48 = 0x5b5b;\n            local_46 = 0x3d;\n            local_44 = 0x5d5d3d;\n            local_4a = bVar25;\n            local_45 = bVar5;\n            iVar8 = fnmatch((char *)&local_48,(char *)&local_4a,0);\n            if (iVar8 == 0) goto LAB_001c169c;\n            bVar5 = local_a8[4];\n            if (bVar5 != 0) goto joined_r0x001c1321;\n            goto joined_r0x001c146f;\n          }\n          bVar5 = cVar23 == '\\\\' & bVar4;\n          pbVar18 = local_a8;\n          if (bVar5 == 0) goto LAB_001c064f;\n          bVar27 = *local_a8;\n          uVar21 = (ulong)bVar27;\n          if (bVar27 != 0) {\n            bVar3 = false;\n            cVar23 = '\\\\';\n            pbVar18 = local_a8 + 1;\n            goto joined_r0x001c0c26;\n          }\n        }\n        goto LAB_001c0508;\n      }\n      if ((int)uVar9 < 0x5c) goto LAB_001c0472;\n      if (uVar9 != 0x5c) goto LAB_001c0948;\n      if (pbVar12 == param_4) {\n        if (uVar15 == 0x5c) {\n          if (param_2 != local_b0 + 1) goto LAB_001c0508;\n          goto LAB_001c0569;\n        }\n        if (pbVar12 == param_4) goto LAB_001c0508;\n      }\n      if ((param_6 & 2) == 0) {\n        pbVar12 = param_3 + 2;\n        bVar25 = param_3[1];\n        uVar9 = (uint)bVar25;\n        if (param_4 < pbVar12) goto LAB_001c0508;\n        if (uVar19 != 0) {\n          ppuVar10 = __ctype_b_loc();\n          puVar16 = *ppuVar10;\n          uVar9 = (uint)bVar25;\n          if ((*(byte *)((long)puVar16 + (ulong)bVar25 * 2 + 1) & 1) != 0) {\n            pp_Var11 = __ctype_tolower_loc();\n            uVar9 = (uint)*(byte *)(*pp_Var11 + bVar25);\n          }\nLAB_001c0e75:\n          if ((*(byte *)((long)puVar16 + (long)(int)uVar15 * 2 + 1) & 1) != 0) {\n            pp_Var11 = __ctype_tolower_loc();\n            uVar15 = (*pp_Var11)[(int)uVar15];\n          }\n        }\n      }\n      else {\n        uVar9 = 0x5c;\n        if (uVar19 != 0) {\n          ppuVar10 = __ctype_b_loc();\n          puVar16 = *ppuVar10;\n          goto LAB_001c0e75;\n        }\n      }\n      if (uVar15 == uVar9) goto LAB_001c0705;\n      goto LAB_001c0508;\n    }\n    if ((0xc0000601UL >> ((ulong)(uVar9 - 0x21) & 0x3f) & 1) != 0) {\n      uVar19 = param_6 & 0xffffff7b;\n      if (param_1 == local_b0) {\n        uVar19 = param_6;\n      }\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        uVar21 = FUN_001bfde0(uVar21,local_b0,param_2,pbVar12,param_4,uVar19);\n        return uVar21;\n      }\n      goto LAB_001c192b;\n    }\nLAB_001c0472:\n    if (uVar9 != 0x2a) {\n      if (uVar9 == 0x3f) {\n        if (uVar15 == 0) goto LAB_001c0508;\n        if ((uVar15 == 0x2f) && ((param_6 & 1) != 0)) goto LAB_001c0508;\n        if (((param_6 & 4) == 0) || (uVar15 != 0x2e)) {\n          if (((param_6 & 0x80) != 0) &&\n             ((((param_1 == local_b0 && (*param_1 == 0x2e)) &&\n               ((param_1[1] == 0 || ((param_1[1] == 0x2e && (param_1[2] == 0)))))) ||\n              ((((param_6 & 1) != 0 && ((local_b0[-1] == 0x2f && (*local_b0 == 0x2e)))) &&\n               (((bVar25 = local_b0[1], bVar25 == 0x2f || (bVar25 == 0)) ||\n                ((bVar25 == 0x2e && ((local_b0[2] == 0x2f || (local_b0[2] == 0))))))))))))\n          goto LAB_001c0508;\n        }\n        else if ((param_1 == local_b0) || (((param_6 & 1) != 0 && (local_b0[-1] == 0x2f))))\n        goto LAB_001c0508;\n      }\n      else {\nLAB_001c0948:\n        if (uVar19 != 0) {\n          ppuVar10 = __ctype_b_loc();\n          if ((*(byte *)((long)*ppuVar10 + (long)(int)uVar15 * 2 + 1) & 1) != 0) {\n            pp_Var11 = __ctype_tolower_loc();\n            uVar15 = (*pp_Var11)[(int)uVar15];\n          }\n        }\n        if ((uVar9 & 0xff) != uVar15) goto LAB_001c0508;\n      }\n      param_3 = pbVar12;\n      local_b0 = local_b0 + 1;\n      goto LAB_001c04e1;\n    }\n    if (param_5 != (byte **)0x0) {\n      uVar21 = 0;\n      *param_5 = param_3;\n      param_5[1] = local_b0;\n      goto LAB_001c050e;\n    }\n    if (((param_6 & 4) == 0) || (uVar15 != 0x2e)) {\n      if (((param_6 & 0x80) != 0) &&\n         ((((param_1 == local_b0 && (*param_1 == 0x2e)) &&\n           ((param_1[1] == 0 || ((param_1[1] == 0x2e && (param_1[2] == 0)))))) ||\n          ((((param_6 & 1) != 0 && ((local_b0[-1] == 0x2f && (*local_b0 == 0x2e)))) &&\n           (((bVar25 = local_b0[1], bVar25 == 0x2f || (bVar25 == 0)) ||\n            ((bVar25 == 0x2e && ((local_b0[2] == 0x2f || (local_b0[2] == 0))))))))))))\n      goto LAB_001c0508;\n    }\n    else if ((param_1 == local_b0) || (((param_6 & 1) != 0 && (local_b0[-1] == 0x2f))))\n    goto LAB_001c0508;\n    if (pbVar12 == param_4) {\nLAB_001c0b72:\n      uVar21 = 0;\n      goto LAB_001c050e;\n    }\n    bVar25 = param_3[1];\n    param_3 = param_3 + 2;\n    if ((bVar25 == 0x2a) || (bVar25 == 0x3f)) {\n      if ((uVar15 == 0x2f) && ((param_6 & 1) != 0)) goto LAB_001c0508;\n      pbVar12 = local_b0;\nLAB_001c0a7b:\n      local_b0 = pbVar12;\n      if (uVar20 == 0) {\n        if (bVar25 == 0x3f) {\nLAB_001c0a84:\n          if (uVar15 == 0) goto LAB_001c0508;\n          local_b0 = pbVar12 + 1;\n          uVar15 = 0;\n          if (local_b0 < param_2) {\n            uVar15 = (uint)pbVar12[1];\n          }\n        }\n      }\n      else if (bVar25 == 0x3f) {\n        if (*param_3 != 0x28) goto LAB_001c0a84;\n        iVar8 = FUN_001bfde0(0x3f,pbVar12,param_2,param_3,param_4,param_6);\n        if (iVar8 == 0) goto LAB_001c0b72;\n        if (param_4 == param_3 + 1) goto LAB_001c0569;\n        param_3 = (byte *)FUN_001bfab0(param_3 + 1,param_4,0);\n        if (param_3 == (byte *)0x0) {\n          uVar21 = 0;\n          goto LAB_001c050e;\n        }\n      }\n      else if ((bVar25 == 0x2a) && (*param_3 == 0x28)) {\n        if (pbVar12 < param_2) {\n          do {\n            iVar8 = FUN_001bfde0(0x2a,pbVar12,param_2,param_3,param_4,param_6);\n            if (iVar8 == 0) goto LAB_001c0b72;\n            pbVar12 = pbVar12 + 1;\n          } while (param_2 != pbVar12);\n        }\n        if ((param_4 == param_3 + 1) ||\n           (param_3 = (byte *)FUN_001bfab0(param_3 + 1,param_4,0), param_3 == (byte *)0x0))\n        goto LAB_001c0b72;\n      }\n      if (param_4 == param_3) {\n        if (bVar25 != 0) goto LAB_001c0569;\n        goto LAB_001c14cd;\n      }\n      bVar25 = *param_3;\n      param_3 = param_3 + 1;\n      if ((bVar25 == 0x3f) || (bVar25 == 0x2a)) {\n        pbVar12 = local_b0;\n        if ((uVar15 == 0x2f) && ((param_6 & 1) != 0)) goto LAB_001c0508;\n        goto LAB_001c0a7b;\n      }\n    }\n    if (bVar25 == 0) {\nLAB_001c14cd:\n      uVar21 = 0;\n      if (((param_6 & 1) != 0) && ((param_6 & 8) == 0)) {\n        pvVar14 = memchr(local_b0,0x2f,(long)param_2 - (long)local_b0);\n        uVar21 = (ulong)(pvVar14 != (void *)0x0);\n      }\n      goto LAB_001c050e;\n    }\n    bVar5 = bVar25;\n    if (((uVar20 == 0) || (param_2 != local_b0)) || (bVar25 != 0x21)) {\n      if (bVar25 != 0x2f) goto LAB_001c10a4;\n      if ((param_6 & 1) != 0) {\n        if (local_b0 < param_2) goto LAB_001c1897;\n        goto LAB_001c0508;\n      }\n      local_68 = (byte *)0x0;\n      pbVar12 = (byte *)memchr(local_b0,0,(long)param_2 - (long)local_b0);\n      if (pbVar12 == (byte *)0x0) {\n        pbVar12 = param_2;\n      }\n    }\n    else {\n      if (*param_3 == 0x28) {\n        iVar8 = FUN_001bfde0(0x21,local_b0,param_2,param_3 + -1,param_4,param_6);\n        uVar21 = (ulong)(iVar8 == 0);\n        goto LAB_001c050e;\n      }\nLAB_001c10a4:\n      uVar15 = param_6 & 1;\n      local_68 = (byte *)0x0;\n      if (uVar15 != 0) {\n        uVar15 = 0x2f;\n      }\n      pbVar12 = (byte *)memchr(local_b0,uVar15,(long)param_2 - (long)local_b0);\n      if (pbVar12 == (byte *)0x0) {\n        pbVar12 = param_2;\n      }\n      if ((bVar4 != 0) && (bVar25 == 0x5c)) {\n        bVar5 = *param_3;\n      }\n    }\n    if (uVar19 != 0) {\n      ppuVar10 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar10 + (ulong)bVar5 * 2 + 1) & 1) != 0) {\n        pp_Var11 = __ctype_tolower_loc();\n        bVar5 = *(byte *)(*pp_Var11 + bVar5);\n      }\n    }\n    if (pbVar12 <= local_b0) goto LAB_001c0508;\n    do {\n      if (uVar20 == 0) {\n        if (bVar25 != 0x5b) goto LAB_001c1185;\nLAB_001c11d0:\n        iVar8 = FUN_001c0390(local_b0,param_2,param_3 + -1,param_4,&local_68,param_6 & 0xffffff7b);\n        if (iVar8 == 0) {\n          param_3 = local_68;\n          local_b0 = local_60;\n          if (local_68 != (byte *)0x0) goto LAB_001c04e1;\n          uVar21 = 0;\n          goto LAB_001c050e;\n        }\n      }\n      else {\n        if (((*param_3 == 0x28) || (pcVar13 = strchr(\"?*+@!\",(uint)param_3[-1]), bVar25 == 0x5b)) ||\n           (pcVar13 != (char *)0x0)) goto LAB_001c11d0;\nLAB_001c1185:\n        bVar27 = *local_b0;\n        uVar15 = (uint)bVar27;\n        if (uVar19 != 0) {\n          uVar15 = (uint)bVar27;\n          ppuVar10 = __ctype_b_loc();\n          if ((*(byte *)((long)*ppuVar10 + (ulong)bVar27 * 2 + 1) & 1) != 0) {\n            pp_Var11 = __ctype_tolower_loc();\n            uVar15 = (*pp_Var11)[bVar27];\n          }\n        }\n        if (bVar5 == uVar15) goto LAB_001c11d0;\n      }\n      local_b0 = local_b0 + 1;\n    } while (local_b0 != pbVar12);\n    param_3 = local_68;\n    local_b0 = local_60;\n    if (local_68 == (byte *)0x0) goto LAB_001c0508;\n    goto LAB_001c04e1;\n  }\nLAB_001c04ef:\n  if (param_2 == local_b0) {\nLAB_001c0569:\n    uVar21 = 0;\n    goto LAB_001c050e;\n  }\n  if ((param_6 & 8) != 0) {\n    uVar21 = (ulong)(*local_b0 != 0x2f);\n    goto LAB_001c050e;\n  }\n  goto LAB_001c0508;\nLAB_001c1015:\n  if ((cVar7 == cVar23) && (iVar8 = strcmp(pcVar13,__s2), iVar8 == 0)) {\n    switch(uVar21 & 0xffffffff) {\n    default:\n      uVar9 = (uint)((uVar15 & 0xffffff80) == 0);\n      break;\n    case 2:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (*ppuVar10)[lVar17] >> 3 & 1;\n      break;\n    case 3:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (*ppuVar10)[lVar17] >> 10 & 1;\n      break;\n    case 4:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (*ppuVar10)[lVar17] & 1;\n      break;\n    case 5:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (*ppuVar10)[lVar17] >> 1 & 1;\n      break;\n    case 6:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (*ppuVar10)[lVar17] >> 0xb & 1;\n      break;\n    case 7:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (uint)(int)(short)(*ppuVar10)[lVar17] >> 0x1f;\n      break;\n    case 8:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (*ppuVar10)[lVar17] >> 9 & 1;\n      break;\n    case 9:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (*ppuVar10)[lVar17] >> 0xe & 1;\n      break;\n    case 10:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (*ppuVar10)[lVar17] >> 2 & 1;\n      break;\n    case 0xb:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (*ppuVar10)[lVar17] >> 0xd & 1;\n      break;\n    case 0xc:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = *(byte *)((long)*ppuVar10 + lVar17 * 2 + 1) & 1;\n      break;\n    case 0xd:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (*ppuVar10)[lVar17] >> 3 & 1 | (uint)(uVar15 == 0x5f);\n      break;\n    case 0xe:\n      ppuVar10 = __ctype_b_loc();\n      uVar9 = (*ppuVar10)[lVar17] >> 0xc & 1;\n    }\n    local_68 = (byte *)CONCAT44(local_68._4_4_,uVar9);\n    goto LAB_001c15ec;\n  }\n  uVar21 = uVar21 + 1;\n  if (uVar21 == 0xf) goto LAB_001c184e;\n  __s2 = (&PTR_DAT_00235700)[uVar21];\n  cVar7 = *__s2;\n  goto LAB_001c1015;\nLAB_001c184e:\n  local_68 = (byte *)((ulong)local_68 & 0xffffffff00000000);\nLAB_001c15ec:\n  local_a8 = pbVar18 + 2;\n  pbVar24 = pbVar18 + 3;\n  sh_xfree(pcVar13,\"sm_loop.c\",0x200);\n  if ((uint)local_68 != 0) {\nLAB_001c0b92:\n    bVar5 = pbVar24[-1];\n    if (bVar5 == 0) goto joined_r0x001c146f;\n    iVar8 = 1;\n    pbVar18 = (byte *)0x0;\n    bVar27 = bVar5;\n    goto LAB_001c0bb8;\n  }\nLAB_001c1048:\n  bVar5 = *local_a8;\n  if (bVar5 == 0) goto joined_r0x001c146f;\n  if (bVar5 == 0x5d) goto LAB_001c06fa;\njoined_r0x001c1321:\n  uVar21 = (ulong)bVar5;\n  local_a8 = pbVar24;\njoined_r0x001c0834:\n  if ((uVar19 != 0) &&\n     (ppuVar10 = __ctype_b_loc(), (*(byte *)((long)*ppuVar10 + uVar21 * 2 + 1) & 1) != 0)) {\n    pp_Var11 = __ctype_tolower_loc();\n    uVar21 = (ulong)*(byte *)(*pp_Var11 + uVar21);\n  }\n  goto LAB_001c0628;\nLAB_001c06fa:\n  pbVar12 = pbVar24;\n  if (!bVar29 && !bVar30) goto LAB_001c0508;\n  goto LAB_001c0705;\n  while( true ) {\n    bVar5 = pbVar24[2];\n    iVar8 = iVar8 + 1;\n    pbVar18 = local_a8;\n    local_a8 = pbVar24 + 2;\n    bVar27 = bVar5;\n    if (bVar5 == 0) break;\nLAB_001c0bb8:\n    do {\n      bVar6 = bVar27;\n      pbVar24 = local_a8;\n      local_a8 = pbVar24 + 1;\n      if (bVar6 != 0x5b) {\n        if (bVar6 == 0x5d) {\n          if (iVar8 < 2) {\n            if (pbVar18 != (byte *)0x0) {\n              bVar27 = *pbVar18;\nLAB_001c0be5:\n              if (bVar27 == 0x2e) goto LAB_001c13f0;\n            }\n          }\n          else if (pbVar18 != (byte *)0x0) {\n            bVar27 = *pbVar18;\n            if (bVar27 != bVar5) goto LAB_001c0be5;\n            iVar8 = iVar8 + -1;\n            pbVar18 = (byte *)0x0;\n            bVar5 = 0x5d;\n            goto LAB_001c15a5;\n          }\n          pbVar12 = local_a8;\n          if (!bVar29 && !bVar30) goto LAB_001c0705;\n          goto LAB_001c0508;\n        }\nLAB_001c13f0:\n        if ((bVar4 == 0) || (bVar6 != 0x5c)) {\n          if (bVar6 == 0) goto joined_r0x001c146f;\n          bVar5 = bVar6;\n          bVar27 = pbVar24[1];\n        }\n        else {\n          if (pbVar24[1] == 0) goto LAB_001c0508;\n          local_a8 = pbVar24 + 2;\n          bVar5 = 0x5c;\nLAB_001c15a5:\n          bVar27 = *local_a8;\n        }\n        goto LAB_001c0bb8;\n      }\n      bVar27 = pbVar24[1];\n      bVar5 = bVar6;\n    } while ((0x3d < bVar27) || ((0xdbffbfffffffffffU >> ((ulong)bVar27 & 0x3f) & 1) != 0));\n  }\njoined_r0x001c146f:\n  if (bVar25 != 0x5b) goto LAB_001c0508;\nLAB_001c0705:\n  param_3 = pbVar12;\n  local_b0 = local_b0 + 1;\nLAB_001c04e1:\n  if (param_4 <= param_3) goto LAB_001c04ef;\n  goto LAB_001c03f7;\n  while (local_b0 = local_b0 + 1, param_2 != local_b0) {\nLAB_001c1897:\n    if (*local_b0 == 0x2f) {\n      if (local_b0 < param_2) {\n        iVar8 = FUN_001c0390(local_b0 + 1,param_2,param_3,param_4,0,param_6);\n        uVar21 = (ulong)(iVar8 != 0);\n        goto LAB_001c050e;\n      }\n      break;\n    }\n  }\nLAB_001c0508:\n  uVar21 = 1;\nLAB_001c050e:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar21;\n  }\nLAB_001c192b:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_bind_key_in_map": "\nvoid rl_bind_key_in_map(undefined8 param_1,undefined8 param_2,undefined *param_3)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = _rl_keymap;\n  _rl_keymap = param_3;\n  rl_bind_key();\n  _rl_keymap = puVar1;\n  return;\n}\n\n",
  "history_list": "\nundefined8 history_list(void)\n\n{\n  return DAT_0024b6e8;\n}\n\n",
  "find_variable_for_assignment": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid find_variable_for_assignment(undefined8 param_1)\n\n{\n  long lVar1;\n  bool bVar2;\n  \n  bVar2 = false;\n  _DAT_002422f8 = 0;\n  if (expanding_redir == 0) {\n    bVar2 = (assigning_in_environment | executing_builtin) != 0;\n  }\n  lVar1 = FUN_00152c60(param_1,bVar2);\n  if ((lVar1 != 0) && ((*(byte *)(lVar1 + 0x29) & 8) != 0)) {\n    find_variable_nameref(lVar1);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00194030": "\nundefined8 FUN_00194030(int param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  int local_3c;\n  \n  local_3c = param_1;\n  if (param_1 != 0) {\n    while( true ) {\n      FUN_001936e0(1,param_2);\n      iVar1 = rl_point;\n      FUN_00193990(1,param_2);\n      iVar2 = rl_point;\n      if (rl_point < iVar1) break;\n      uVar3 = rl_copy_text(iVar1,rl_point);\n      pcVar4 = (char *)dirspell(uVar3);\n      if (pcVar4 != (char *)0x0) {\n        rl_begin_undo_group();\n        rl_delete_text(iVar1,iVar2);\n        rl_point = iVar1;\n        if (*pcVar4 != '\\0') {\n          rl_insert_text(pcVar4);\n        }\n        rl_mark = iVar1;\n        rl_end_undo_group();\n      }\n      sh_xfree(uVar3,\"bashline.c\",0x55e);\n      sh_xfree(pcVar4,\"bashline.c\",0x55f);\n      if (rl_end <= rl_point) {\n        return 0;\n      }\n      local_3c = local_3c + -1;\n      if (local_3c == 0) {\n        return 0;\n      }\n      FUN_00193990(1,param_2);\n    }\n  }\n  return 0;\n}\n\n",
  "make_variable_value": "\nchar * make_variable_value(long param_1,char *param_2,ulong param_3)\n\n{\n  long lVar1;\n  long lVar2;\n  char *pcVar3;\n  char *pcVar4;\n  size_t sVar5;\n  char cVar6;\n  long in_FS_OFFSET;\n  int local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_3 & 0x100) == 0) {\n    if ((*(uint *)(param_1 + 0x28) & 0x10) == 0) {\n      if ((*(uint *)(param_1 + 0x28) & 0x700) != 0) {\n        if ((param_3 & 1) == 0) {\n          if (*param_2 == '\\0') {\n            pcVar4 = (char *)sh_xmalloc(1,\"variables.c\",0xbb1);\n            *pcVar4 = '\\0';\n          }\n          else {\n            sVar5 = strlen(param_2);\n            pcVar3 = (char *)sh_xmalloc(sVar5 + 1,\"variables.c\",0xbae);\n            pcVar4 = strcpy(pcVar3,param_2);\n          }\n        }\n        else {\n          pcVar3 = (char *)get_variable_value();\n          if (pcVar3 == (char *)0x0) {\n            lVar1 = 1;\n            lVar2 = 0;\n            pcVar3 = \"\";\n          }\n          else if (*pcVar3 == '\\0') {\n            lVar1 = 1;\n            lVar2 = 0;\n          }\n          else if (pcVar3[1] == '\\0') {\n            lVar1 = 2;\n            lVar2 = 1;\n          }\n          else if (pcVar3[2] == '\\0') {\n            lVar1 = 3;\n            lVar2 = 2;\n          }\n          else {\n            sVar5 = strlen(pcVar3);\n            lVar2 = (long)(int)sVar5;\n            lVar1 = lVar2 + 1;\n          }\n          if (param_2 == (char *)0x0) {\n            pcVar4 = (char *)sh_xmalloc(lVar1,\"variables.c\",0xba8);\n            strcpy(pcVar4,pcVar3);\n          }\n          else {\n            if (*param_2 != '\\0') {\n              if (param_2[1] == '\\0') {\n                lVar1 = lVar1 + 1;\n              }\n              else if (param_2[2] == '\\0') {\n                lVar1 = lVar1 + 2;\n              }\n              else {\n                sVar5 = strlen(param_2);\n                lVar1 = lVar1 + sVar5;\n              }\n            }\n            pcVar4 = (char *)sh_xmalloc(lVar1,\"variables.c\",0xba8);\n            strcpy(pcVar4,pcVar3);\n            strcpy(pcVar4 + lVar2,param_2);\n          }\n        }\n        cVar6 = '\\x04';\n        if ((*(uint *)(param_1 + 0x28) & 0x400) == 0) {\n          cVar6 = ((*(uint *)(param_1 + 0x28) & 0x100) != 0) + '\\x01';\n        }\n        pcVar3 = (char *)sh_modcase(pcVar4,0,cVar6);\n        sh_xfree(pcVar4,\"variables.c\",2999);\n        goto LAB_00154a3c;\n      }\n      goto LAB_001549f9;\n    }\n    if ((param_3 & 1) == 0) {\n      lVar1 = evalexp(param_2,0,&local_44);\n      if (local_44 != 0) {\nLAB_001549df:\n        pcVar3 = (char *)itos(lVar1);\n        goto LAB_00154a3c;\n      }\n      if ((param_3 & 0x200) == 0) goto LAB_00154b37;\nLAB_00154a0b:\n      if (*param_2 == '\\0') {\n        pcVar3 = (char *)sh_xmalloc(1,\"variables.c\",0xbcd);\n        *pcVar3 = '\\0';\n      }\n      else {\n        sVar5 = strlen(param_2);\n        pcVar3 = (char *)sh_xmalloc(sVar5 + 1,\"variables.c\",0xbca);\n        pcVar3 = strcpy(pcVar3,param_2);\n      }\n      goto LAB_00154a3c;\n    }\n    lVar1 = evalexp(*(undefined8 *)(param_1 + 8),0,&local_44);\n    if (local_44 != 0) {\n      lVar2 = evalexp(param_2,0,&local_44);\n      lVar1 = lVar1 + lVar2;\n      if (local_44 != 0) goto LAB_001549df;\n    }\n    if ((param_3 & 0x200) == 0) {\nLAB_00154b37:\n      top_level_cleanup();\n                    /* WARNING: Subroutine does not return */\n      jump_to_top_level(2);\n    }\n    pcVar4 = (char *)get_variable_value(param_1);\n    if (pcVar4 != (char *)0x0) goto LAB_00154b79;\n    lVar1 = 1;\n    lVar2 = 0;\n    pcVar4 = \"\";\nLAB_00154ca3:\n    if (param_2 == (char *)0x0) {\n      pcVar3 = (char *)sh_xmalloc(lVar1,\"variables.c\",0xbc4);\n      strcpy(pcVar3,pcVar4);\n      goto LAB_00154a3c;\n    }\n  }\n  else {\nLAB_001549f9:\n    if (param_2 == (char *)0x0) {\n      pcVar3 = (char *)0x0;\n      goto LAB_00154a3c;\n    }\n    if ((param_3 & 1) == 0) goto LAB_00154a0b;\n    pcVar4 = (char *)get_variable_value(param_1);\n    if (pcVar4 != (char *)0x0) {\nLAB_00154b79:\n      if (*pcVar4 == '\\0') {\n        lVar1 = 1;\n        lVar2 = 0;\n      }\n      else if (pcVar4[1] == '\\0') {\n        lVar1 = 2;\n        lVar2 = 1;\n      }\n      else if (pcVar4[2] == '\\0') {\n        lVar1 = 3;\n        lVar2 = 2;\n      }\n      else {\n        sVar5 = strlen(pcVar4);\n        lVar2 = (long)(int)sVar5;\n        lVar1 = lVar2 + 1;\n      }\n      goto LAB_00154ca3;\n    }\n    pcVar4 = \"\";\n    lVar1 = 1;\n    lVar2 = 0;\n  }\n  if (*param_2 != '\\0') {\n    if (param_2[1] == '\\0') {\n      lVar1 = lVar1 + 1;\n    }\n    else if (param_2[2] == '\\0') {\n      lVar1 = lVar1 + 2;\n    }\n    else {\n      sVar5 = strlen(param_2);\n      lVar1 = lVar1 + sVar5;\n    }\n  }\n  pcVar3 = (char *)sh_xmalloc(lVar1,\"variables.c\",0xbc4);\n  strcpy(pcVar3,pcVar4);\n  strcpy(pcVar3 + lVar2,param_2);\nLAB_00154a3c:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pcVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "getifs": "\nundefined8 getifs(void)\n\n{\n  return ifs_value;\n}\n\n",
  "sh_quote_reusable": "\nundefined2 * sh_quote_reusable(char *param_1,int param_2)\n\n{\n  int iVar1;\n  undefined2 *puVar2;\n  \n  if (param_1 == (char *)0x0) {\n    return (undefined2 *)0x0;\n  }\n  if (*param_1 == '\\0') {\n    puVar2 = (undefined2 *)sh_xmalloc(3,\"shquote.c\",0x173);\n    *puVar2 = 0x2727;\n    *(undefined *)(puVar2 + 1) = 0;\n    return puVar2;\n  }\n  iVar1 = ansic_shouldquote();\n  if (iVar1 != 0) {\n    puVar2 = (undefined2 *)ansic_quote(param_1,0,0);\n    return puVar2;\n  }\n  if (param_2 != 0) {\n    puVar2 = (undefined2 *)sh_backslash_quote(param_1,0,1);\n    return puVar2;\n  }\n  puVar2 = (undefined2 *)sh_single_quote(param_1);\n  return puVar2;\n}\n\n",
  "FUN_001a9d90": "\nundefined8 FUN_001a9d90(long param_1)\n\n{\n  uint uVar1;\n  int iVar2;\n  long *plVar3;\n  undefined4 uVar4;\n  uint uVar5;\n  long *plVar6;\n  long *plVar7;\n  char cVar8;\n  \n  if ((((interactive != 0) &&\n       (last_shell_builtin != logout_builtin && last_shell_builtin != exit_builtin)) &&\n      (last_shell_builtin != (code *)PTR_jobs_builtin_00237fa8)) && (0 < DAT_0023877c)) {\n    cVar8 = '\\0';\n    plVar3 = jobs + 1;\n    plVar7 = jobs;\n    while( true ) {\n      plVar6 = plVar3;\n      if (*plVar7 != 0) {\n        iVar2 = *(int *)(*plVar7 + 0x14);\n        if (iVar2 == 2) {\n          cVar8 = '\\x02';\n        }\n        else if ((cVar8 == '\\0') && (check_jobs_at_exit != 0)) {\n          cVar8 = iVar2 == 1;\n        }\n      }\n      if (plVar6 == jobs + 1 + (DAT_0023877c - 1)) break;\n      plVar3 = plVar6 + 1;\n      plVar7 = plVar6;\n    }\n    if (cVar8 == '\\x02') {\n      fwrite(\"There are stopped jobs.\\n\",1,0x18,stderr);\n    }\n    else {\n      if (cVar8 != '\\x01') goto LAB_001a9e4b;\n      fwrite(\"There are running jobs.\\n\",1,0x18,stderr);\n    }\n    if (check_jobs_at_exit != 0) {\n      list_all_jobs(0);\n    }\n    last_shell_builtin = exit_builtin;\n    this_shell_builtin = exit_builtin;\n    return 1;\n  }\nLAB_001a9e4b:\n  if ((running_trap != 1) || (uVar4 = trap_saved_exit_value, param_1 != 0)) {\n    uVar4 = get_exitstat(param_1);\n  }\n  if ((login_shell != 0) &&\n     (uVar1 = DAT_00248aac + 1, uVar5 = DAT_00248aac | subshell_environment, DAT_00248aac = uVar1,\n     uVar5 == 0)) {\n    maybe_execute_file(\"~/.bash_logout\",1);\n  }\n  last_command_exit_value = uVar4;\n                    /* WARNING: Subroutine does not return */\n  jump_to_top_level(6);\n}\n\n",
  "initialize_readline": "\nvoid initialize_readline(void)\n\n{\n  code *pcVar1;\n  undefined *puVar2;\n  ulong uVar3;\n  long lVar4;\n  ulong uVar5;\n  undefined8 *puVar6;\n  long in_FS_OFFSET;\n  byte bVar7;\n  undefined2 local_42;\n  long local_40;\n  \n  bVar7 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (bash_readline_initialized == 0) {\n    rl_terminal_name = get_string_value(\"TERM\");\n    rl_instream = stdin;\n    rl_outstream = stderr;\n    rl_readline_name = &DAT_001ff43b;\n    rl_add_defun(\"shell-expand-line\",FUN_00195330,0xffffffff);\n    rl_add_defun(\"history-expand-line\",FUN_00194e70,0xffffffff);\n    rl_add_defun(\"magic-space\",FUN_00194eb0,0xffffffff);\n    rl_add_defun(\"shell-forward-word\",FUN_00193990,0xffffffff);\n    rl_add_defun(\"shell-backward-word\",FUN_001936e0,0xffffffff);\n    rl_add_defun(\"shell-kill-word\",FUN_001943a0,0xffffffff);\n    rl_add_defun(\"shell-backward-kill-word\",FUN_00194410,0xffffffff);\n    rl_add_defun(\"shell-transpose-words\",FUN_00194150,0xffffffff);\n    rl_add_defun(\"spell-correct-word\",FUN_00194030,0xffffffff);\n    rl_bind_key_if_unbound_in_map(0x73,FUN_00194030,emacs_ctlx_keymap);\n    rl_add_defun(\"alias-expand-line\",FUN_00194e30,0xffffffff);\n    rl_add_defun(\"history-and-alias-expand-line\",FUN_00194dc0,0xffffffff);\n    rl_add_defun(\"insert-last-argument\",rl_yank_last_arg,0xffffffff);\n    rl_add_defun(\"display-shell-version\",FUN_00193440,0xffffffff);\n    rl_add_defun(\"edit-and-execute-command\",FUN_00193420,0xffffffff);\n    rl_add_defun(\"vi-edit-and-execute-command\",FUN_00194290,0xffffffff);\n    rl_add_defun(\"complete-into-braces\",bash_brace_completion,0xffffffff);\n    rl_add_defun(\"complete-filename\",FUN_00192960,0xffffffff);\n    rl_add_defun(\"possible-filename-completions\",FUN_00192770,0xffffffff);\n    rl_add_defun(\"complete-username\",FUN_001952c0,0xffffffff);\n    rl_add_defun(\"possible-username-completions\",FUN_00194f90,0xffffffff);\n    rl_add_defun(\"complete-hostname\",FUN_00195250,0xffffffff);\n    rl_add_defun(\"possible-hostname-completions\",FUN_00194f30,0xffffffff);\n    rl_add_defun(\"complete-variable\",FUN_001951e0,0xffffffff);\n    rl_add_defun(\"possible-variable-completions\",FUN_00195110,0xffffffff);\n    rl_add_defun(\"complete-command\",FUN_00195170,0xffffffff);\n    rl_add_defun(\"possible-command-completions\",FUN_00194ff0,0xffffffff);\n    rl_add_defun(\"glob-complete-word\",FUN_00195580,0xffffffff);\n    rl_add_defun(\"glob-expand-word\",FUN_00195050,0xffffffff);\n    rl_add_defun(\"glob-list-expansions\",FUN_001950b0,0xffffffff);\n    rl_add_defun(\"dynamic-complete-history\",FUN_00192600,0xffffffff);\n    rl_add_defun(\"dabbrev-expand\",FUN_00192280,0xffffffff);\n    if (((byte)rl_readline_state & 2) == 0) {\n      rl_initialize();\n    }\n    rl_bind_key_if_unbound_in_map(5,FUN_00195330,emacs_meta_keymap);\n    rl_bind_key_if_unbound_in_map(0x5e,FUN_00194e70,emacs_meta_keymap);\n    rl_bind_key_if_unbound_in_map(0x16,FUN_00193440,emacs_ctlx_keymap);\n    local_42 = 10;\n    pcVar1 = (code *)rl_function_of_keyseq(&local_42,emacs_meta_keymap,0);\n    if (pcVar1 == rl_vi_editing_mode) {\n      rl_unbind_key_in_map(10,emacs_meta_keymap);\n    }\n    local_42 = CONCAT11(local_42._1_1_,0xd);\n    pcVar1 = (code *)rl_function_of_keyseq(&local_42,emacs_meta_keymap,0);\n    if (pcVar1 == rl_vi_editing_mode) {\n      rl_unbind_key_in_map(0xd,emacs_meta_keymap);\n    }\n    local_42 = CONCAT11(local_42._1_1_,5);\n    puVar2 = (undefined *)rl_function_of_keyseq(&local_42,vi_movement_keymap,0);\n    if (puVar2 == PTR_rl_emacs_editing_mode_00237ef8) {\n      rl_unbind_key_in_map(5,vi_movement_keymap);\n    }\n    rl_bind_key_if_unbound_in_map(0x7b,bash_brace_completion,emacs_meta_keymap);\n    rl_bind_key_if_unbound_in_map(0x2f,FUN_00192960,emacs_meta_keymap);\n    rl_bind_key_if_unbound_in_map(0x2f,FUN_00192770,emacs_ctlx_keymap);\n    local_42 = 0x7e;\n    puVar2 = (undefined *)rl_function_of_keyseq(&local_42,emacs_meta_keymap,0);\n    if ((puVar2 == (undefined *)0x0) || (puVar2 == PTR_rl_tilde_expand_00237ef0)) {\n      rl_bind_keyseq_in_map(&local_42,FUN_001952c0,emacs_meta_keymap);\n    }\n    rl_bind_key_if_unbound_in_map(0x7e,FUN_00194f90,emacs_ctlx_keymap);\n    rl_bind_key_if_unbound_in_map(0x40,FUN_00195250,emacs_meta_keymap);\n    rl_bind_key_if_unbound_in_map(0x40,FUN_00194f30,emacs_ctlx_keymap);\n    rl_bind_key_if_unbound_in_map(0x24,FUN_001951e0,emacs_meta_keymap);\n    rl_bind_key_if_unbound_in_map(0x24,FUN_00195110,emacs_ctlx_keymap);\n    rl_bind_key_if_unbound_in_map(0x21,FUN_00195170,emacs_meta_keymap);\n    rl_bind_key_if_unbound_in_map(0x21,FUN_00194ff0,emacs_ctlx_keymap);\n    rl_bind_key_if_unbound_in_map(0x67,FUN_00195580,emacs_meta_keymap);\n    rl_bind_key_if_unbound_in_map(0x2a,FUN_00195050,emacs_ctlx_keymap);\n    rl_bind_key_if_unbound_in_map(0x67,FUN_001950b0,emacs_ctlx_keymap);\n    local_42 = 9;\n    puVar2 = (undefined *)rl_function_of_keyseq(&local_42,emacs_meta_keymap,0);\n    if ((puVar2 == (undefined *)0x0) || (puVar2 == PTR_rl_tab_insert_00237f80)) {\n      rl_bind_key_in_map(9,FUN_00192600,emacs_meta_keymap);\n    }\n    rl_attempted_completion_function = FUN_001987b0;\n    if (dircomplete_expand == 0) {\n      rl_directory_rewrite_hook = FUN_00195b80;\n      rl_directory_completion_hook = (code *)0x0;\n    }\n    else {\n      rl_directory_completion_hook = FUN_00195b80;\n      rl_directory_rewrite_hook = (code *)0x0;\n    }\n    rl_filename_rewrite_hook = FUN_00192130;\n    rl_filename_stat_hook = FUN_00191f40;\n    rl_ignore_some_completions_function = FUN_00191d90;\n    rl_bind_key_if_unbound_in_map(5,FUN_00193420,emacs_ctlx_keymap);\n    rl_bind_key_if_unbound_in_map(0x76,FUN_00194290,vi_movement_keymap);\n    rl_bind_key_if_unbound_in_map(0x40,FUN_00191640,vi_movement_keymap);\n    rl_bind_key_in_map(0x5c,FUN_00196050,vi_movement_keymap);\n    rl_bind_key_in_map(0x2a,FUN_00196050,vi_movement_keymap);\n    rl_bind_key_in_map(0x3d,FUN_00196050,vi_movement_keymap);\n    rl_completer_quote_characters = &DAT_001ff6b4;\n    enable_hostname_completion(perform_hostname_completion);\n    rl_filename_quote_characters = &DAT_001ff3ee;\n    puVar6 = &DAT_00248880;\n    for (lVar4 = 0x20; lVar4 != 0; lVar4 = lVar4 + -1) {\n      *puVar6 = 0;\n      puVar6 = puVar6 + (ulong)bVar7 * -2 + 1;\n    }\n    uVar3 = 0x20;\n    uVar5 = 9;\n    puVar2 = &DAT_001ff3ee;\n    while( true ) {\n      *(undefined *)((long)&DAT_00248880 + uVar3) = 1;\n      if ((char)uVar5 == '\\0') break;\n      uVar3 = uVar5;\n      uVar5 = (ulong)(byte)puVar2[2];\n      puVar2 = puVar2 + 1;\n    }\n    rl_filename_quoting_function = FUN_00195700;\n    rl_filename_dequoting_function = FUN_00191560;\n    rl_char_is_quoted_p = char_is_quoted;\n    rl_bind_key_if_unbound_in_map(2,FUN_001936e0,emacs_meta_keymap);\n    rl_bind_key_if_unbound_in_map(4,FUN_001943a0,emacs_meta_keymap);\n    rl_bind_key_if_unbound_in_map(6,FUN_00193990,emacs_meta_keymap);\n    rl_bind_key_if_unbound_in_map(0x14,FUN_00194150,emacs_meta_keymap);\n    bash_readline_initialized = 1;\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001bf9c0": "\nwchar_t * FUN_001bf9c0(long param_1,wchar_t *param_2)\n\n{\n  wchar_t *pwVar1;\n  wchar_t wVar2;\n  int iVar3;\n  wchar_t wVar4;\n  size_t __n;\n  wchar_t *pwVar5;\n  undefined **ppuVar6;\n  \n  wVar4 = *(wchar_t *)(param_1 + 4);\n  pwVar5 = (wchar_t *)(param_1 + 4);\n  if (wVar4 != L'\\0') {\n    __n = 0;\n    pwVar1 = (wchar_t *)(param_1 + 8);\n    wVar2 = wVar4;\n    do {\n      pwVar5 = pwVar1;\n      if ((wVar2 == L'.') && (*pwVar5 == L']')) {\n        ppuVar6 = &PTR_DAT_0023a700;\n        pwVar5 = (wchar_t *)PTR_DAT_0023a700;\n        if (PTR_DAT_0023a700 == (undefined *)0x0) goto LAB_001bfa70;\n        goto LAB_001bfa3d;\n      }\n      wVar2 = *pwVar5;\n      __n = __n + 1;\n      pwVar1 = pwVar5 + 1;\n    } while (wVar2 != L'\\0');\n  }\n  wVar4 = L'\\xffffffff';\n  goto LAB_001bfa81;\n  while( true ) {\n    pwVar5 = (wchar_t *)ppuVar6[2];\n    ppuVar6 = ppuVar6 + 2;\n    if (pwVar5 == (wchar_t *)0x0) break;\nLAB_001bfa3d:\n    if (((*pwVar5 == wVar4) && (iVar3 = wcsncmp(pwVar5,(wchar_t *)(param_1 + 4),__n), iVar3 == 0))\n       && (pwVar5[__n] == L'\\0')) {\n      wVar4 = *(wchar_t *)(ppuVar6 + 1);\n      goto LAB_001bfa7c;\n    }\n  }\nLAB_001bfa70:\n  if ((int)__n != 1) {\n    wVar4 = L'\\xffffffff';\n  }\nLAB_001bfa7c:\n  pwVar5 = (wchar_t *)(param_1 + 0xc + __n * 4);\nLAB_001bfa81:\n  *param_2 = wVar4;\n  return pwVar5;\n}\n\n",
  "num_fifos": "\nundefined4 num_fifos(void)\n\n{\n  return DAT_00247834;\n}\n\n",
  "zgetline": "\nlong zgetline(undefined4 param_1,long *param_2,ulong *param_3,int param_4,int param_5)\n\n{\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  long lVar4;\n  ulong uVar5;\n  long lVar6;\n  long in_FS_OFFSET;\n  char local_41;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((param_2 == (long *)0x0) || (param_3 == (ulong *)0x0)) ||\n     ((lVar2 = *param_2, lVar2 == 0 && (*param_3 != 0)))) {\n    lVar4 = -1;\n  }\n  else {\n    lVar4 = 0;\n    do {\n      lVar6 = lVar4;\n      if (param_5 == 0) {\n        iVar1 = zreadc(param_1,&local_41);\n      }\n      else {\n        iVar1 = zread(param_1,&local_41,1);\n      }\n      if (iVar1 < 1) {\n        lVar4 = lVar6 + -1;\n        if ((lVar2 != 0) && (lVar6 != 0)) {\n          *(undefined *)(lVar2 + lVar6) = 0;\n        }\n        goto LAB_001cb238;\n      }\n      uVar3 = *param_3;\n      if (uVar3 <= lVar6 + 2U) {\n        if (uVar3 == 0) {\n          uVar5 = 0x10;\nLAB_001cb1ba:\n          lVar2 = sh_xrealloc(*param_2,uVar5,\"zgetline.c\",0x61);\n          if (lVar2 != 0) {\n            *param_2 = lVar2;\n            *param_3 = uVar5;\n            goto LAB_001cb1ec;\n          }\n          uVar3 = *param_3;\n          if (uVar3 == 0) {\n            lVar4 = lVar6 + -1;\n            goto LAB_001cb238;\n          }\n        }\n        else {\n          uVar5 = uVar3 * 2;\n          if (uVar3 < uVar5) goto LAB_001cb1ba;\n        }\n        *(undefined *)(*param_2 + -1 + uVar3) = 0;\n        lVar4 = *param_3 - 3;\n        goto LAB_001cb238;\n      }\nLAB_001cb1ec:\n      *(char *)(lVar2 + lVar6) = local_41;\n      lVar4 = lVar6 + 1;\n    } while (local_41 != param_4);\n    *(undefined *)(lVar2 + lVar6 + 1) = 0;\n    lVar4 = lVar6;\n  }\nLAB_001cb238:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "discard_pipeline": "\nint discard_pipeline(long *param_1)\n\n{\n  long *plVar1;\n  long *plVar2;\n  int iVar3;\n  \n  iVar3 = 0;\n  plVar2 = param_1;\n  do {\n    plVar1 = (long *)*plVar2;\n    if (plVar2[3] != 0) {\n      sh_xfree(plVar2[3],\"jobs.c\",0x5c2);\n    }\n    iVar3 = iVar3 + 1;\n    sh_xfree(plVar2,\"jobs.c\",0x5c3);\n    plVar2 = plVar1;\n  } while (param_1 != plVar1);\n  return iVar3;\n}\n\n",
  "FUN_001871c0": "\nulong FUN_001871c0(void)\n\n{\n  char cVar1;\n  char cVar2;\n  char *pcVar3;\n  uint uVar4;\n  bool bVar5;\n  int iVar6;\n  int iVar7;\n  long lVar8;\n  ulong uVar9;\n  ulong uVar10;\n  uint uVar11;\n  long lVar12;\n  char *pcVar13;\n  long lVar14;\n  \n  lVar8 = (long)(int)DAT_0024856c;\n  pcVar13 = *(char **)(DAT_00248560 + (lVar8 + 1) * 8);\n  lVar14 = (lVar8 + 1) * 8;\n  lVar12 = DAT_00248560;\n  uVar9 = test_binop(pcVar13);\n  if ((int)uVar9 != 0) {\n    uVar9 = FUN_00187050();\n    DAT_0024856c = DAT_00248568;\n    return uVar9;\n  }\n  pcVar3 = *(char **)(lVar12 + -8 + lVar14);\n  cVar1 = *pcVar3;\n  if ((*pcVar13 == '-') &&\n     (((cVar2 = pcVar13[1], cVar2 == 'a' || (cVar2 == 'o')) && (pcVar13[2] == '\\0')))) {\n    if (cVar2 == 'a') {\n      if (cVar1 == '\\0') {\n        DAT_0024856c = DAT_00248568;\n        return uVar9;\n      }\n    }\n    else if (cVar1 != '\\0') {\n      DAT_0024856c = DAT_00248568;\n      return 1;\n    }\n    DAT_0024856c = DAT_00248568;\n    return (ulong)(**(char **)(lVar12 + 8 + lVar14) != '\\0');\n  }\n  if (cVar1 == '!') {\n    if (pcVar3[1] == '\\0') {\n      DAT_0024856c = (int)lVar8 + 1;\n      if ((int)DAT_0024856c < DAT_00248568) {\n        iVar6 = FUN_00187140();\n        DAT_0024856c = DAT_00248568;\n        return (ulong)(iVar6 == 0);\n      }\n      FUN_00186440();\n      uVar9 = (ulong)DAT_0024856c;\n      bVar5 = false;\n      do {\n        uVar11 = (uint)uVar9;\n        if (DAT_00248568 <= (int)uVar11) {\n          uVar4 = DAT_0024856c;\n          if (bVar5) {\n            uVar4 = uVar11;\n          }\nLAB_00187460:\n          DAT_0024856c = uVar4;\n          FUN_00186440();\nLAB_00187465:\n                    /* WARNING: Subroutine does not return */\n          FUN_00186410(\"`)\\' expected\");\n        }\n        pcVar13 = *(char **)(DAT_00248560 + (long)(int)uVar11 * 8);\n        cVar1 = *pcVar13;\n        if (cVar1 != '!') {\n          if (bVar5) {\n            DAT_0024856c = uVar11;\n          }\n          if ((cVar1 != '(') || (pcVar13[1] != '\\0')) goto LAB_00187415;\n          DAT_0024856c = uVar11 + 1;\n          uVar4 = DAT_0024856c;\n          if ((int)DAT_0024856c < DAT_00248568) {\n            uVar9 = FUN_00187510();\n            pcVar13 = *(char **)(DAT_00248560 + (long)(int)DAT_0024856c * 8);\n            if (pcVar13 != (char *)0x0) {\n              if ((*pcVar13 == ')') && (pcVar13[1] == '\\0')) {\n                DAT_0024856c = DAT_0024856c + 1;\n                return uVar9;\n              }\n                    /* WARNING: Subroutine does not return */\n              FUN_00186410(\"`)\\' expected, found %s\");\n            }\n            goto LAB_00187465;\n          }\n          goto LAB_00187460;\n        }\n        if (pcVar13[1] != '\\0') {\n          if (bVar5) {\n            DAT_0024856c = uVar11;\n          }\nLAB_00187415:\n          iVar6 = DAT_00248568;\n          if (((int)(uVar11 + 2) < DAT_00248568) &&\n             (iVar7 = test_binop(*(undefined8 *)(DAT_00248560 + 8 + (long)(int)uVar11 * 8)),\n             iVar7 != 0)) {\n            uVar9 = FUN_00187050();\n            return uVar9;\n          }\n          iVar7 = uVar11 + 1;\n          if ((iVar7 < iVar6) && (iVar6 = test_unop(pcVar13), iVar6 != 0)) {\n            uVar9 = FUN_00186e30();\n            return uVar9;\n          }\n          DAT_0024856c = iVar7;\n          return (ulong)(cVar1 != '\\0');\n        }\n        iVar6 = 0;\n        uVar10 = (ulong)(int)(uVar11 + 1);\n        cVar1 = '\\0';\n        while( true ) {\n          uVar4 = (uint)uVar10;\n          uVar9 = (ulong)(uVar4 - 1);\n          if (cVar1 != '\\0') break;\n          uVar9 = uVar10 & 0xffffffff;\n          if (DAT_00248568 <= (int)uVar4) goto LAB_00187460;\n          pcVar13 = *(char **)(DAT_00248560 + uVar10 * 8);\n          uVar10 = uVar10 + 1;\n          iVar6 = 1 - iVar6;\n          if (*pcVar13 != '!') {\n            bVar5 = true;\n            break;\n          }\n          cVar1 = pcVar13[1];\n          bVar5 = true;\n        }\n        if (iVar6 != 0) {\n          if (bVar5) {\n            DAT_0024856c = (uint)uVar9;\n          }\n          iVar6 = FUN_00187300();\n          return (ulong)(iVar6 == 0);\n        }\n      } while( true );\n    }\n  }\n  else if ((cVar1 == '(') && (**(char **)(lVar12 + 8 + lVar14) == ')')) {\n    DAT_0024856c = DAT_00248568;\n    return (ulong)(*pcVar13 != '\\0');\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00186410(\"%s: binary operator expected\",pcVar13);\n}\n\n",
  "shtimer_set": "\nvoid shtimer_set(ulong *param_1,ulong param_2,ulong param_3)\n\n{\n  int iVar1;\n  ulong uVar2;\n  long in_FS_OFFSET;\n  timeval local_38;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((*(byte *)((long)param_1 + 0x14) & 1) == 0) {\n    iVar1 = gettimeofday(&local_38,(__timezone_ptr_t)0x0);\n    if (-1 < iVar1) {\n      param_2 = param_2 + local_38.tv_sec;\n      param_3 = param_3 + local_38.tv_usec;\n    }\n    *param_1 = param_2;\n    param_1[1] = param_3;\n    if (1000000 < (long)param_3) {\n      *param_1 = param_2 + 1;\n      param_1[1] = param_3 - 1000000;\n    }\n  }\n  else {\n    *(undefined4 *)(param_1 + 3) = 0;\n    uVar2 = set_signal_handler(0xe,param_1[4]);\n    param_1[1] = param_3;\n    *(uint *)((long)param_1 + 0x14) = *(uint *)((long)param_1 + 0x14) | 0x100;\n    param_1[5] = uVar2;\n    *param_1 = param_2;\n    falarm(param_2 & 0xffffffff,param_3 & 0xffffffff);\n    *(uint *)((long)param_1 + 0x14) = *(uint *)((long)param_1 + 0x14) | 0x200;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_callback_data_alloc": "\nvoid _rl_callback_data_alloc(undefined4 param_1)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = (undefined4 *)xmalloc(0xc);\n  *puVar1 = param_1;\n  *(undefined8 *)(puVar1 + 1) = 0;\n  return;\n}\n\n",
  "iswprint": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswprint_00237e58)();\n  return iVar1;\n}\n\n",
  "reset_parser": "\nvoid reset_parser(void)\n\n{\n  DAT_00240a18 = 0;\n  DAT_00240b14 = 0;\n  if ((parser_state & 0x1040) != 0) {\n    extended_glob = DAT_00240d64;\n  }\n  parser_state = 0;\n  here_doc_first_line = 0;\n  if (pushed_string_list != 0) {\n    FUN_00134d00();\n  }\n  if (DAT_00240da8 != 0) {\n    sh_xfree(DAT_00240da8,\"/usr/local/src/chet/src/bash/src/parse.y\",0xcf9);\n    DAT_00240da8 = 0;\n    DAT_00240da0 = 0;\n    DAT_00240d98 = 0;\n  }\n  if (DAT_00240b50 != 0) {\n    sh_xfree(DAT_00240b50,\"/usr/local/src/chet/src/bash/src/parse.y\",0xcfe);\n  }\n  DAT_00240b50 = 0;\n  DAT_00240b34 = 0;\n  need_here_doc = 0;\n  DAT_00240dc0 = 0;\n  DAT_00240b18 = 0;\n  DAT_00240b1c = 0;\n  current_token = 10;\n  DAT_00240d70 = 10;\n  DAT_00240b58 = 10;\n  return;\n}\n\n",
  "dispose_used_env_vars": "\nvoid dispose_used_env_vars(void)\n\n{\n  if (temporary_env == 0) {\n    return;\n  }\n  FUN_00159fb0(FUN_001565c0);\n  if (array_needs_making != 0) {\n    FUN_00156bc0();\n    return;\n  }\n  return;\n}\n\n",
  "FUN_0017d6c0": "\nlong FUN_0017d6c0(undefined8 param_1,long param_2,undefined8 param_3,char *param_4,uint param_5,\n                 uint param_6)\n\n{\n  char *pcVar1;\n  undefined8 uVar2;\n  mbstate_t mVar3;\n  byte bVar4;\n  char cVar5;\n  uint uVar6;\n  int iVar7;\n  size_t sVar8;\n  char *pcVar9;\n  long *plVar10;\n  undefined *puVar11;\n  undefined8 *puVar12;\n  long *plVar13;\n  byte **ppbVar14;\n  undefined2 *__s;\n  long lVar15;\n  size_t sVar16;\n  size_t sVar17;\n  uint uVar18;\n  undefined2 *puVar19;\n  undefined2 *puVar20;\n  undefined8 uVar21;\n  byte *pbVar22;\n  byte *pbVar23;\n  long in_FS_OFFSET;\n  char *local_b8;\n  byte *local_b0;\n  uint local_a8;\n  long local_a0;\n  long local_58;\n  long local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  uVar2 = this_command_name;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 0) {\n    local_a0 = 0;\n    goto LAB_0017d94a;\n  }\n  this_command_name = param_1;\n  uVar6 = FUN_0017c800();\n  if (uVar6 == 0xffffffff) {\n    local_a0 = 0;\n    goto LAB_0017d94a;\n  }\n  uVar18 = 0;\n  local_a8 = uVar6 & 0xffffff7f;\n  if (*param_4 == '/') {\n    param_4 = param_4 + 1;\n    uVar18 = 0x10;\n  }\n  sVar8 = strlen(param_4);\n  pcVar9 = (char *)sh_xmalloc(sVar8 + 1,\"subst.c\",0x23a8);\n  pcVar9 = strcpy(pcVar9,param_4);\n  if ((param_5 & 3) != 0) {\n    uVar18 = uVar18 | 0x20;\n  }\n  if ((uVar6 & 0x80) != 0) {\n    uVar18 = uVar18 | 0x80;\n  }\n  if ((param_6 & 8) != 0) {\n    uVar18 = uVar18 | 0x40;\n  }\n  iVar7 = skip_to_delim(pcVar9,*param_4 == '/',&DAT_001fe10e,0);\n  if (pcVar9[iVar7] == '/') {\n    pcVar1 = pcVar9 + (long)iVar7 + 1;\n    pcVar9[iVar7] = '\\0';\n    if (*pcVar1 == '\\0') {\n      local_b8 = (char *)FUN_0017b240(pcVar9,param_5);\n      __s = (undefined2 *)0x0;\n    }\n    else {\n      local_b8 = (char *)FUN_0017b240(pcVar9,param_5);\n      if (shell_compatibility_level < 0x2b) {\n        if ((uVar18 & 0x20) != 0) {\n          if (*pcVar1 == '\\0') {\n            __s = (undefined2 *)0x0;\n          }\n          else {\n            __s = (undefined2 *)0x0;\n            lVar15 = expand_string_unsplit(pcVar1,param_5);\n            if (lVar15 != 0) {\n              __s = (undefined2 *)string_list_internal(lVar15,&DAT_001fdb1c);\n              goto LAB_0017dd55;\n            }\n          }\n          goto LAB_0017d7e3;\n        }\n        __s = (undefined2 *)FUN_001738e0(pcVar1,param_5,expand_string_unsplit);\n      }\n      else if (patsub_replacement == 0) {\n        __s = (undefined2 *)FUN_001738e0(pcVar1,param_5 & 0xfffffffc,expand_string_unsplit);\n      }\n      else {\n        __s = (undefined2 *)0x0;\n        if ((*pcVar1 == '\\0') || (plVar13 = (long *)FUN_0017b140(pcVar1), plVar13 == (long *)0x0))\n        goto LAB_0017d7e3;\n        ppbVar14 = (byte **)plVar13[1];\n        if (ppbVar14 != (byte **)0x0) {\n          remove_quoted_nulls(*ppbVar14);\n          ppbVar14 = (byte **)plVar13[1];\n          *(uint *)(ppbVar14 + 1) = *(uint *)(ppbVar14 + 1) & 0xfffbffff;\n        }\n        if (*plVar13 == 0) {\n          local_b0 = *ppbVar14;\n        }\n        else {\n          local_b0 = (byte *)string_list_internal(plVar13,&DAT_001fdb1c);\n        }\n        local_48.__count = 0;\n        local_48.__value = (_union_27)0x0;\n        sVar8 = strlen((char *)local_b0);\n        __s = (undefined2 *)sh_xmalloc(sVar8 * 2 + 1,\"subst.c\",0xf55);\n        bVar4 = *local_b0;\n        puVar19 = __s;\n        pbVar22 = local_b0;\n        if (bVar4 == 1) {\n          if (local_b0[1] != 0) goto LAB_0017daed;\n          *__s = 1;\n        }\n        else {\n          while (bVar4 != 0) {\nLAB_0017daed:\n            mVar3 = local_48;\n            if (bVar4 == 1) {\n              bVar4 = pbVar22[1];\n              if ((bVar4 != 0x26) && (bVar4 != 0x5c)) {\n                pbVar22 = pbVar22 + 1;\n                if (bVar4 != 0) goto LAB_0017dac5;\n                break;\n              }\n              *(undefined *)puVar19 = 0x5c;\n              puVar20 = puVar19 + 1;\n              pbVar23 = pbVar22 + 2;\n              *(byte *)((long)puVar19 + 1) = pbVar22[1];\n              local_48 = mVar3;\n            }\n            else {\n              bVar4 = *pbVar22;\nLAB_0017dac5:\n              pbVar23 = pbVar22 + 1;\n              puVar20 = (undefined2 *)((long)puVar19 + 1);\n              if (locale_mb_cur_max < 2) {\n                *(byte *)puVar19 = bVar4;\n                local_48 = mVar3;\n              }\n              else {\n                if (((*(uint *)(is_basic_table + (ulong)(bVar4 >> 5) * 4) >> (bVar4 & 0x1f) & 1) ==\n                     0) && ((locale_utf8locale == 0 || ((char)bVar4 < '\\0')))) {\n                  sVar16 = mbrtowc((wchar_t *)0x0,(char *)pbVar22,\n                                   (size_t)(local_b0 + (sVar8 - (long)pbVar22)),&local_48);\n                  if (0xfffffffffffffffd < sVar16) {\n                    *(byte *)puVar19 = *pbVar22;\n                    local_48 = mVar3;\n                    goto LAB_0017dae4;\n                  }\n                  bVar4 = *pbVar22;\n                  sVar17 = 1;\n                  if (sVar16 != 0) {\n                    sVar17 = sVar16;\n                  }\n                  sVar16 = 0;\n                  while( true ) {\n                    *(byte *)((long)puVar19 + sVar16) = bVar4;\n                    sVar16 = sVar16 + 1;\n                    if (sVar16 == sVar17) break;\n                    bVar4 = pbVar22[sVar16];\n                  }\n                }\n                else {\n                  *(byte *)puVar19 = bVar4;\n                  sVar17 = 1;\n                }\n                pbVar23 = pbVar22 + sVar17;\n                puVar20 = (undefined2 *)((long)puVar19 + sVar17);\n              }\n            }\nLAB_0017dae4:\n            puVar19 = puVar20;\n            pbVar22 = pbVar23;\n            bVar4 = *pbVar23;\n          }\n          *(undefined *)puVar19 = 0;\n        }\n        if (local_b0 != *(byte **)plVar13[1]) {\n          sh_xfree(local_b0,\"subst.c\",0xf9d);\n        }\nLAB_0017dd55:\n        dispose_words();\n      }\n      if (((patsub_replacement != 0) && (__s != (undefined2 *)0x0)) && (*(char *)__s != '\\0')) {\n        local_48.__count = 0;\n        local_48.__value = (_union_27)0x0;\n        cVar5 = *(char *)__s;\n        if (cVar5 != '\\0') {\n          local_b0 = (byte *)0x1;\n          if ((*(char *)((long)__s + 1) != '\\0') &&\n             (local_b0 = (byte *)0x2, *(char *)(__s + 1) != '\\0')) {\n            local_b0 = (byte *)strlen((char *)__s);\n          }\n          if (cVar5 != '\\0') {\n            iVar7 = 0;\n            do {\n              mVar3 = local_48;\n              if (cVar5 == '\\\\') {\n                iVar7 = iVar7 + 1;\n                cVar5 = *(char *)((long)__s + (long)iVar7);\n                if (cVar5 == '\\0') break;\n                if ((cVar5 == '&') || (cVar5 == '\\\\')) {\nLAB_0017dca1:\n                  uVar18 = uVar18 | 0x100;\n                  break;\n                }\n              }\n              else if (cVar5 == '&') goto LAB_0017dca1;\n              if (locale_mb_cur_max < 2) {\nLAB_0017dc68:\n                iVar7 = iVar7 + 1;\n              }\n              else {\n                pbVar22 = (byte *)((long)__s + (long)iVar7);\n                bVar4 = *pbVar22;\n                if ((*(uint *)(is_basic_table + (ulong)(bVar4 >> 5) * 4) >> (bVar4 & 0x1f) & 1) == 0\n                   ) {\n                  if ((locale_utf8locale != 0) && (-1 < (char)bVar4)) {\n                    if (bVar4 == 0) goto LAB_0017dc68;\n                    goto LAB_0017e088;\n                  }\n                  sVar8 = mbrtowc((wchar_t *)0x0,(char *)pbVar22,(long)local_b0 - (long)iVar7,\n                                  &local_48);\n                  if (0xfffffffffffffffd < sVar8) {\n                    iVar7 = iVar7 + 1;\n                    local_48 = mVar3;\n                    goto LAB_0017dc6c;\n                  }\n                  if (sVar8 == 0) goto LAB_0017dc68;\n                }\n                else {\nLAB_0017e088:\n                  sVar8 = 1;\n                }\n                iVar7 = iVar7 + (int)sVar8;\n              }\nLAB_0017dc6c:\n              cVar5 = *(char *)((long)__s + (long)iVar7);\n            } while (cVar5 != '\\0');\n          }\n        }\n      }\n    }\n  }\n  else {\n    __s = (undefined2 *)0x0;\n    local_b8 = (char *)FUN_0017b240(pcVar9,param_5);\n  }\nLAB_0017d7e3:\n  if ((uVar18 & 0x10) == 0) {\n    if (local_b8 != (char *)0x0) {\n      if (*local_b8 == '#') {\n        uVar18 = uVar18 | 1;\n        local_b0 = (byte *)(local_b8 + 1);\n      }\n      else {\n        local_b0 = (byte *)local_b8;\n        if (*local_b8 == '%') {\n          uVar18 = uVar18 | 2;\n          local_b0 = (byte *)(local_b8 + 1);\n        }\n      }\n      if (local_a8 == 2) goto LAB_0017dde1;\n      if ((int)local_a8 < 3) {\n        if (local_a8 == 0) goto LAB_0017df69;\n        if (local_a8 == 1) goto LAB_0017d819;\n      }\n      else if (local_a8 == 3) goto LAB_0017dcc1;\n      goto LAB_0017d908;\n    }\n    if (local_a8 == 2) {\n      local_b0 = (byte *)0x0;\nLAB_0017dde1:\n      if (((uVar18 & 0xc0) == 0xc0) && (ifs_is_null != 0)) {\n        uVar18 = uVar18 | 0x20;\n      }\n      if ((*(byte *)(local_50 + 0x28) & 0x40) == 0) {\n        local_a0 = array_patsub(*(undefined8 *)(local_50 + 8),local_b0,__s,uVar18);\n      }\n      else {\n        local_a0 = assoc_patsub();\n      }\n      if (local_a0 != 0) {\n        if (param_5 == 0) {\n          if (ifs_is_null != 0) goto joined_r0x0017dd0c;\n        }\n        else if (local_a0 == 0) goto LAB_0017df40;\n        if ((uVar18 & 0x20) == 0) {\n          lVar15 = FUN_00167220(local_a0,0);\n          sh_xfree(local_a0,\"subst.c\",0x2436);\n          local_a0 = lVar15;\n        }\n        goto joined_r0x0017dd0c;\n      }\nLAB_0017df40:\n      local_a0 = 0;\n      goto joined_r0x0017dd0c;\n    }\n    if ((int)local_a8 < 3) {\n      if (local_a8 == 0) {\n        local_b0 = (byte *)0x0;\nLAB_0017df69:\n        lVar15 = pat_subst(local_58,local_b0,__s,uVar18);\n        if (local_58 != 0) {\n          sh_xfree(local_58,\"subst.c\",0x2402);\n        }\n        goto LAB_0017dcd8;\n      }\n      if (local_a8 != 1) goto LAB_0017d919;\n      local_b0 = (byte *)0x0;\nLAB_0017d819:\n      if (((param_6 & 4) != 0) && ((uVar18 & 0x80) != 0)) {\n        uVar18 = uVar18 | 0x40;\n      }\n      plVar10 = (long *)list_rest_of_args();\n      plVar13 = plVar10;\n      if (plVar10 != (long *)0x0) {\n        do {\n          puVar11 = (undefined *)pat_subst(*(undefined8 *)plVar13[1],local_b0,__s,uVar18);\n          puVar12 = (undefined8 *)alloc_word_desc();\n          if (puVar11 == (undefined *)0x0) {\n            puVar11 = (undefined *)sh_xmalloc(1,\"subst.c\",0x236b);\n            *puVar11 = 0;\n          }\n          *puVar12 = puVar11;\n          dispose_word(plVar13[1]);\n          plVar13[1] = (long)puVar12;\n          plVar13 = (long *)*plVar13;\n        } while (plVar13 != (long *)0x0);\n        uVar21 = 0x40;\n        uVar6 = (int)uVar18 >> 5 & 1;\n        if (((((uVar18 & 0x80) != 0) && (uVar21 = 0x2a, (uVar18 & 0x40) != 0)) &&\n            (DAT_00247848 != 0)) && (ifs_is_null != 0)) {\n          uVar6 = 1;\n        }\n        local_a0 = string_list_pos_params(uVar21,plVar10,uVar6,(int)uVar18 >> 3 & 8);\n        dispose_words(plVar10);\n        if (local_a0 != 0) {\n          if (param_5 == 0) {\n            if ((param_6 & 8 | ifs_is_null) != 0) goto joined_r0x0017dd0c;\n          }\n          else if (local_a0 == 0) goto LAB_0017df40;\n          if ((uVar18 & 0x20) == 0) {\n            lVar15 = FUN_00167220(local_a0,0);\n            sh_xfree(local_a0,\"subst.c\",0x241d);\n            local_a0 = lVar15;\n          }\n          goto joined_r0x0017dd0c;\n        }\n      }\n      goto LAB_0017df40;\n    }\n    if (local_a8 == 3) {\n      local_b0 = (byte *)0x0;\nLAB_0017dcc1:\n      lVar15 = pat_subst(local_58,local_b0,__s,uVar18);\nLAB_0017dcd8:\n      if (lVar15 != 0) {\n        if ((uVar18 & 0x20) == 0) {\n          local_a0 = FUN_00167220(lVar15,0);\n        }\n        else {\n          local_a0 = quote_string(lVar15);\n        }\n        sh_xfree(lVar15,\"subst.c\",0x2406);\n        goto joined_r0x0017dd0c;\n      }\n      goto LAB_0017df40;\n    }\n  }\n  else {\n    if (local_a8 == 2) {\n      local_b0 = (byte *)local_b8;\n      goto LAB_0017dde1;\n    }\n    if ((int)local_a8 < 3) {\n      if (local_a8 == 0) {\n        local_b0 = (byte *)local_b8;\n        goto LAB_0017df69;\n      }\n      if (local_a8 == 1) {\n        local_b0 = (byte *)local_b8;\n        goto LAB_0017d819;\n      }\n    }\n    else if (local_a8 == 3) {\n      local_b0 = (byte *)local_b8;\n      goto LAB_0017dcc1;\n    }\njoined_r0x0017dd0c:\n    if (local_b8 != (char *)0x0) {\nLAB_0017d908:\n      sh_xfree(local_b8,\"subst.c\",0x243d);\n    }\n  }\nLAB_0017d919:\n  if (__s != (undefined2 *)0x0) {\n    sh_xfree(__s,\"subst.c\",0x243e);\n  }\n  sh_xfree(pcVar9,\"subst.c\",0x243f);\nLAB_0017d94a:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n    this_command_name = uVar2;\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  this_command_name = uVar2;\n  return local_a0;\n}\n\n",
  "sh_closepipe": "\nundefined8 sh_closepipe(undefined8 *param_1)\n\n{\n  if (-1 < *(int *)param_1) {\n    close(*(int *)param_1);\n  }\n  if (-1 < *(int *)((long)param_1 + 4)) {\n    close(*(int *)((long)param_1 + 4));\n  }\n  *param_1 = 0xffffffffffffffff;\n  return 0;\n}\n\n",
  "throw_to_top_level": "\nvoid throw_to_top_level(void)\n\n{\n  int iVar1;\n  uint uVar2;\n  \n  uVar2 = interrupt_state;\n  if (interrupt_state != 0) {\n    if ((int)last_command_exit_value < 0x80) {\n      last_command_exit_value = 0x82;\n    }\n    uVar2 = 1;\n    set_pipestatus_from_exit(last_command_exit_value);\n    interrupt_state = interrupt_state - 1;\n  }\n  if (interrupt_state != 0) {\n    return;\n  }\n  last_command_exit_signal = 0;\n  if (0x80 < (int)last_command_exit_value) {\n    last_command_exit_signal = last_command_exit_value - 0x80;\n  }\n  last_command_exit_value = last_command_exit_value | 0x80;\n  set_pipestatus_from_exit(last_command_exit_value);\n  iVar1 = signal_is_trapped(2);\n  if ((iVar1 != 0) && (iVar1 = signal_is_pending(2), iVar1 != 0)) {\n    run_interrupt_trap(1);\n  }\n  while (parse_and_execute_level != 0) {\n    parse_and_execute_cleanup(0xffffffff);\n  }\n  if (0 < running_trap) {\n    run_trap_cleanup(running_trap + -1);\n    running_trap = 0;\n  }\n  give_terminal_to(shell_pgrp,0);\n  sigprocmask(2,(sigset_t *)top_level_mask,(sigset_t *)0x0);\n  reset_parser();\n  if (interactive != 0) {\n    bashline_reset();\n  }\n  unlink_fifo_list();\n  run_unwind_protects();\n  funcnest = 0;\n  breaking = 0;\n  continuing = 0;\n  loop_level = 0;\n  wait_intr_flag = 0;\n  return_catch_flag = 0;\n  comsub_ignore_return = 0;\n  executing_list = 0;\n  if (interactive != 0) {\n    if ((uVar2 & 1) != 0) {\n      fflush(stdout);\n      fputc(10,stderr);\n      fflush(stderr);\n    }\n    if (interactive != 0) goto LAB_00185ba2;\n  }\n  if (((interactive_shell == 0) || (shell_initialized != 0)) &&\n     ((uVar2 == 0 || (iVar1 = signal_is_trapped(2), iVar1 == 0)))) {\n                    /* WARNING: Subroutine does not return */\n    jump_to_top_level(3);\n  }\nLAB_00185ba2:\n                    /* WARNING: Subroutine does not return */\n  jump_to_top_level(2);\n}\n\n",
  "FUN_00171b00": "\nlong ** FUN_00171b00(long **param_1)\n\n{\n  long *plVar1;\n  char **ppcVar2;\n  char *__s1;\n  char *__s2;\n  int iVar3;\n  long **pplVar4;\n  undefined8 *puVar5;\n  undefined *puVar6;\n  long **pplVar7;\n  long **pplVar8;\n  long **unaff_R14;\n  long **pplVar9;\n  long **pplVar10;\n  \n  if (param_1 == (long **)0x0) {\n    return (long **)0x0;\n  }\n  pplVar4 = (long **)0x0;\nLAB_00171b3e:\n  while (pplVar10 = param_1, pplVar9 = unaff_R14, pplVar8 = pplVar4, plVar1 = pplVar10[1],\n        plVar1 == (long *)0x0) {\nLAB_00171bbf:\n    pplVar4 = (long **)0x0;\nLAB_00171b7b:\n    if (pplVar8 != (long **)0x0) goto LAB_00171b80;\n    unaff_R14 = pplVar4;\n    param_1 = (long **)*pplVar10;\n    if (*pplVar10 == (long *)0x0) {\n      return pplVar4;\n    }\n  }\n  if ((ifs_value == (undefined *)0x0) || (puVar6 = ifs_value, (*(uint *)(plVar1 + 1) & 2) != 0)) {\n    puVar6 = &DAT_00213d70;\n  }\n  pplVar4 = (long **)list_string(*plVar1,puVar6);\n  if (pplVar4 == (long **)0x0) {\n    if ((pplVar10[1] == (long *)0x0) || ((*(byte *)((long)pplVar10[1] + 10) & 0x20) == 0))\n    goto LAB_00171bbf;\n    puVar5 = (undefined8 *)alloc_word_desc();\n    puVar6 = (undefined *)sh_xmalloc(1,\"subst.c\",0x2f3a);\n    *puVar5 = puVar6;\n    *puVar6 = 0;\n    pplVar4 = (long **)make_word_list(puVar5,0);\n    if (pplVar4 != (long **)0x0) goto LAB_00171b75;\n    pplVar4 = (long **)0x0;\n    goto LAB_00171b7b;\n  }\nLAB_00171b75:\n  if (*pplVar4 != (long *)0x0) goto LAB_00171b7b;\n  if ((long **)*pplVar10 == (long **)0x0) {\n    if ((*(byte *)((long)pplVar10[1] + 9) & 2) != 0) {\n      ppcVar2 = (char **)pplVar4[1];\n      __s1 = (char *)*pplVar10[1];\n      __s2 = *ppcVar2;\n      if ((*__s1 == *__s2) && (iVar3 = strcmp(__s1,__s2), iVar3 == 0)) {\n        ppcVar2 = ppcVar2 + 1;\n        *(uint *)ppcVar2 = *(uint *)ppcVar2 | 0x200;\n      }\n    }\n    if (pplVar8 == (long **)0x0) {\n      return pplVar4;\n    }\n  }\n  else {\n    unaff_R14 = pplVar4;\n    param_1 = (long **)*pplVar10;\n    if (pplVar8 == (long **)0x0) goto LAB_00171b3e;\n  }\nLAB_00171b80:\n  *pplVar9 = (long *)pplVar4;\n  while (pplVar7 = pplVar4, pplVar7 != (long **)0x0) {\n    pplVar9 = pplVar7;\n    pplVar4 = (long **)*pplVar7;\n  }\n  pplVar4 = pplVar8;\n  unaff_R14 = pplVar9;\n  param_1 = (long **)*pplVar10;\n  if ((long **)*pplVar10 == (long **)0x0) {\n    return pplVar8;\n  }\n  goto LAB_00171b3e;\n}\n\n",
  "rl_unbind_function_in_map": "\nundefined8 rl_unbind_function_in_map(long param_1,long param_2)\n\n{\n  int iVar1;\n  long *plVar2;\n  undefined8 uVar3;\n  \n  uVar3 = 0;\n  plVar2 = (long *)(param_2 + 8);\n  do {\n    if (*(char *)(plVar2 + -1) == '\\0') {\n      if (*plVar2 == param_1) {\n        *plVar2 = 0;\n        uVar3 = 1;\n      }\n    }\n    else if ((*(char *)(plVar2 + -1) == '\\x01') &&\n            (iVar1 = rl_unbind_function_in_map(param_1,*plVar2), iVar1 == 1)) {\n      uVar3 = 1;\n    }\n    plVar2 = plVar2 + 2;\n  } while ((long *)(param_2 + 0x1018) != plVar2);\n  return uVar3;\n}\n\n",
  "strpbrk": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strpbrk(char *__s,char *__accept)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strpbrk_00237c38)();\n  return pcVar1;\n}\n\n",
  "count_all_jobs": "\nint count_all_jobs(void)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long *plVar3;\n  int iVar4;\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_128);\n  sigaddset(&sStack_128,0x11);\n  sigemptyset(&local_a8);\n  sigprocmask(0,&sStack_128,&local_a8);\n  if (DAT_0023877c < 1) {\n    iVar4 = 0;\n  }\n  else {\n    iVar4 = 0;\n    plVar1 = jobs + 1;\n    plVar3 = jobs;\n    while( true ) {\n      plVar2 = plVar1;\n      if (*plVar3 != 0) {\n        iVar4 = iVar4 + (uint)(*(int *)(*plVar3 + 0x14) != 4);\n      }\n      if (plVar2 == jobs + 1 + (DAT_0023877c - 1)) break;\n      plVar1 = plVar2 + 1;\n      plVar3 = plVar2;\n    }\n  }\n  sigprocmask(2,&local_a8,(sigset_t *)0x0);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "sh_exit": "\nvoid sh_exit_noreturn_(int param_1)\n\n{\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n",
  "hash_create": "\nvoid ** hash_create(int param_1)\n\n{\n  void **ppvVar1;\n  void *__s;\n  size_t __n;\n  long lVar2;\n  \n  ppvVar1 = (void **)sh_xmalloc(0x10,\"hashlib.c\",0x44);\n  if (param_1 == 0) {\n    param_1 = 0x80;\n    __s = (void *)sh_xmalloc(0x400,\"hashlib.c\",0x49);\n    lVar2 = 0x80;\n    ppvVar1[1] = (void *)0x80;\n    *ppvVar1 = __s;\n  }\n  else {\n    lVar2 = (long)param_1;\n    __s = (void *)sh_xmalloc(lVar2 * 8,\"hashlib.c\",0x49);\n    *(int *)(ppvVar1 + 1) = param_1;\n    *ppvVar1 = __s;\n    *(undefined4 *)((long)ppvVar1 + 0xc) = 0;\n    if (param_1 < 1) {\n      return ppvVar1;\n    }\n  }\n  __n = lVar2 * 8;\n  if (param_1 < 1) {\n    __n = 8;\n  }\n  memset(__s,0,__n);\n  return ppvVar1;\n}\n\n",
  "set_pipestatus_from_exit": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid set_pipestatus_from_exit(undefined4 param_1)\n\n{\n  _DAT_00238448 = param_1;\n  set_pipestatus_array(&DAT_00238448,1);\n  return;\n}\n\n",
  "flush_temporary_env": "\nvoid flush_temporary_env(void)\n\n{\n  if (temporary_env != 0) {\n    hash_flush(temporary_env,dispose_variable);\n    hash_dispose(temporary_env);\n    temporary_env = 0;\n    return;\n  }\n  return;\n}\n\n",
  "_rl_disable_meta_key": "\nvoid _rl_disable_meta_key(void)\n\n{\n  if (((DAT_0024b658 != 0) && (DAT_0024b648 != 0)) && (DAT_0024b5bc != 0)) {\n    tputs(DAT_0024b648,1,_rl_output_character_function);\n    DAT_0024b5bc = 0;\n    return;\n  }\n  return;\n}\n\n",
  "set_exit_status": "\nvoid set_exit_status(undefined4 param_1)\n\n{\n  last_command_exit_value = param_1;\n  set_pipestatus_from_exit();\n  return;\n}\n\n",
  "tt_setcbreak": "\nundefined8 tt_setcbreak(uint *param_1)\n\n{\n  *param_1 = *param_1 & 0xffffffbf | 0x100;\n  param_1[1] = param_1[1] & 0xffffffc7 | 5;\n  *(undefined2 *)((long)param_1 + 0x16) = 0x100;\n  param_1[3] = param_1[3] & 0xffffff95 | 0x8001;\n  return 0;\n}\n\n",
  "bind_keyseq_to_unix_command": "\nundefined8 bind_keyseq_to_unix_command(long param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long lVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  long in_FS_OFFSET;\n  undefined4 local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar3 = rl_get_keymap();\n  iVar2 = FUN_001935c0(param_1,0,1,&local_34);\n  if (-1 < iVar2) {\n    lVar4 = substring(param_1,local_34,iVar2);\n    cVar1 = *(char *)(param_1 + iVar2);\n    if (cVar1 != ':') {\n      if (cVar1 == '\\0') {\nLAB_00199998:\n        if (cVar1 != ':') {\n          builtin_error(\"%s: missing colon separator\",param_1);\n          if (lVar4 != 0) {\n            sh_xfree(lVar4,\"bashline.c\",0x125b);\n          }\n          goto LAB_001999cb;\n        }\n      }\n      else {\n        lVar5 = (long)(iVar2 + 1);\n        do {\n          cVar1 = *(char *)(param_1 + lVar5);\n          iVar2 = (int)lVar5;\n          lVar5 = lVar5 + 1;\n          if (cVar1 == '\\0') goto LAB_00199998;\n        } while (cVar1 != ':');\n      }\n    }\n    iVar2 = FUN_001935c0(param_1,iVar2 + 1,0,&local_34);\n    if (-1 < iVar2) {\n      uVar6 = substring(param_1,local_34,iVar2);\n      uVar7 = FUN_001944d0(uVar3);\n      rl_generic_bind(2,lVar4,uVar6,uVar7);\n      rl_bind_keyseq_in_map(lVar4,bash_execute_unix_command,uVar3);\n      sh_xfree(lVar4,\"bashline.c\",0x1271);\n      uVar3 = 0;\n      goto LAB_00199975;\n    }\n    if (lVar4 != 0) {\n      sh_xfree(lVar4,\"bashline.c\",0x1262);\n      uVar3 = 0xffffffff;\n      goto LAB_00199975;\n    }\n  }\nLAB_001999cb:\n  uVar3 = 0xffffffff;\nLAB_00199975:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0018a950": "\nlong FUN_0018a950(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  \n  lVar1 = make_array_variable_value(param_1,0);\n  if (*(code **)(param_1 + 0x20) == (code *)0x0) {\n    assoc_insert(param_2,param_3,lVar1);\n  }\n  else {\n    (**(code **)(param_1 + 0x20))(param_1,lVar1,0,param_3);\n  }\n  if (lVar1 != 0) {\n    sh_xfree(lVar1,\"arrayfunc.c\",0xd7);\n  }\n  *(uint *)(param_1 + 0x28) = *(uint *)(param_1 + 0x28) & 0xffffefff;\n  return param_1;\n}\n\n",
  "FUN_00186410": "\nvoid FUN_00186410_noreturn_(void)\n\n{\n  builtin_error();\n  DAT_00248570 = 2;\n                    /* WARNING: Subroutine does not return */\n  __longjmp_chk(&DAT_00248580,1);\n}\n\n",
  "string_quote_removal": "\nbyte * string_quote_removal(byte *param_1,uint param_2)\n\n{\n  mbstate_t mVar1;\n  byte bVar2;\n  uint uVar3;\n  size_t sVar4;\n  byte *pbVar5;\n  long lVar6;\n  size_t sVar7;\n  char *__src;\n  byte *__dest;\n  size_t __n;\n  byte *__s;\n  ulong uVar8;\n  uint uVar9;\n  long in_FS_OFFSET;\n  int local_74;\n  uint local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar4 = strlen((char *)param_1);\n  pbVar5 = (byte *)sh_xmalloc(sVar4 + 1,\"subst.c\",0x2e6d);\n  bVar2 = *param_1;\n  __dest = pbVar5;\n  if (bVar2 != 0) {\n    uVar8 = 0;\n    uVar3 = 0;\n    do {\n      mVar1 = local_48;\n      uVar9 = (uint)uVar8;\n      if (bVar2 == 0x27) {\n        uVar9 = uVar9 + 1;\n        uVar8 = (ulong)uVar9;\n        if ((param_2 & 3 | uVar3) == 0) {\n          local_4c = uVar9;\n          __src = (char *)FUN_001674a0(param_1,&local_4c,0);\n          if (__src != (char *)0x0) {\n            __dest = (byte *)stpcpy((char *)__dest,__src);\n            sh_xfree(__src,\"subst.c\",0x2e8f);\n          }\n          uVar8 = (ulong)(int)local_4c;\n          uVar3 = 0;\n          __s = param_1 + uVar8;\n        }\n        else {\n          *__dest = 0x27;\n          __dest = __dest + 1;\n          __s = param_1 + (int)uVar9;\n        }\n      }\n      else if (bVar2 == 0x5c) {\n        uVar9 = uVar9 + 1;\n        uVar8 = (ulong)uVar9;\n        lVar6 = (long)(int)uVar9;\n        __s = param_1 + lVar6;\n        bVar2 = *__s;\n        if (bVar2 != 0) {\n          if (((param_2 & 3 | uVar3) != 0) && ((*(byte *)(&sh_syntaxtab + bVar2) & 0x40) == 0)) {\n            *__dest = 0x5c;\n            __dest = __dest + 1;\n            bVar2 = *__s;\n          }\n          goto LAB_00173694;\n        }\n        *__dest = 0x5c;\n        __dest = __dest + 1;\n      }\n      else if (bVar2 == 0x22) {\n        uVar8 = (ulong)(uVar9 + 1);\n        uVar3 = 1 - uVar3;\n        __s = param_1 + (int)(uVar9 + 1);\n      }\n      else {\n        lVar6 = (long)(int)uVar9;\n        __s = param_1 + lVar6;\n        bVar2 = *__s;\nLAB_00173694:\n        if (locale_mb_cur_max < 2) {\n          uVar8 = (ulong)(uVar9 + 1);\n          *__dest = bVar2;\n          __dest = __dest + 1;\n          __s = param_1 + (int)(uVar9 + 1);\n        }\n        else {\n          if ((*(uint *)(is_basic_table + (ulong)(bVar2 >> 5) * 4) >> (bVar2 & 0x1f) & 1) == 0) {\n            if (locale_utf8locale != 0) {\n              local_74 = 1;\n              __n = 1;\n              local_48 = mVar1;\n              if (-1 < (char)bVar2) goto LAB_001736e0;\n            }\n            sVar7 = mbrtowc((wchar_t *)0x0,(char *)__s,sVar4 - lVar6,&local_48);\n            if (sVar7 < 0xfffffffffffffffe) {\n              __n = 1;\n              if (sVar7 != 0) {\n                __n = sVar7;\n              }\n              local_74 = (int)__n;\n            }\n            else {\n              __n = 1;\n              local_74 = 1;\n              local_48 = mVar1;\n            }\n          }\n          else {\n            local_74 = 1;\n            __n = 1;\n            local_48 = mVar1;\n          }\nLAB_001736e0:\n          memcpy(__dest,__s,__n);\n          uVar8 = (ulong)(uVar9 + local_74);\n          __s = param_1 + (int)(uVar9 + local_74);\n          __dest = __dest + __n;\n        }\n      }\n      bVar2 = *__s;\n    } while (bVar2 != 0);\n  }\n  *__dest = 0;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pbVar5;\n}\n\n",
  "dispose_var_context": "\nvoid dispose_var_context(long *param_1)\n\n{\n  if (*param_1 != 0) {\n    sh_xfree(*param_1,\"variables.c\",0x147c);\n  }\n  if (param_1[4] != 0) {\n    hash_flush(param_1[4],dispose_variable);\n    hash_dispose(param_1[4]);\n  }\n  sh_xfree(param_1,\"variables.c\",0x1484);\n  return;\n}\n\n",
  "print_rlimtype": "\nvoid print_rlimtype(ulong param_1,int param_2)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  char local_15 [5];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_15[1] = 0;\n  pcVar3 = local_15 + 1;\n  do {\n    pcVar3 = pcVar3 + -1;\n    *pcVar3 = (char)param_1 + (char)(param_1 / 10) * -10 + '0';\n    bVar1 = 9 < param_1;\n    param_1 = param_1 / 10;\n  } while (bVar1);\n  puVar2 = &DAT_001ff6d2;\n  if (param_2 == 0) {\n    puVar2 = &DAT_00213d70;\n  }\n  __printf_chk(1,&DAT_001fc632,pcVar3,puVar2);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_bind_keyseq": "\nvoid rl_bind_keyseq(undefined8 param_1,undefined8 param_2)\n\n{\n  rl_generic_bind(0,param_1,param_2,_rl_keymap);\n  return;\n}\n\n",
  "set_jobs_list_frozen": "\nvoid set_jobs_list_frozen(void)\n\n{\n  set_jobs_list_frozen();\n  return;\n}\n\n",
  "_rl_vi_domove_motion_cleanup": "\nundefined8 _rl_vi_domove_motion_cleanup(int param_1,long param_2)\n\n{\n  ushort uVar1;\n  uint uVar2;\n  int iVar3;\n  ushort **ppuVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  __int32_t **pp_Var7;\n  long lVar8;\n  size_t sVar9;\n  int iVar10;\n  int iVar11;\n  byte bVar12;\n  bool bVar13;\n  \n  rl_end = *(int *)(param_2 + 0x18);\n  *(undefined *)(rl_line_buffer + rl_end) = 0;\n  _rl_fix_point(0);\n  iVar3 = rl_point;\n  iVar11 = rl_mark;\n  ppuVar4 = __ctype_b_loc();\n  if (iVar11 == iVar3) {\n    uVar2 = *(uint *)(param_2 + 0x1c);\n    if ((*(byte *)((long)*ppuVar4 + (ulong)(uVar2 & 0xff) * 2 + 1) & 2) != 0) {\n      pp_Var7 = __ctype_toupper_loc();\n      uVar2 = (*pp_Var7)[uVar2 & 0xff];\n    }\n    if (((param_1 == 0) || (uVar2 != 0x43)) ||\n       (pcVar6 = strchr(\" hl^$0ftFT;,%wbeWBE|`\",param_1), pcVar6 == (char *)0x0)) {\n      rl_readline_state = rl_readline_state & 0xffffffffffefffff;\n      return 0xffffffff;\n    }\n    goto LAB_001d216d;\n  }\n  bVar12 = (byte)param_1;\n  uVar1 = (*ppuVar4)[bVar12];\n  if ((uVar1 & 0x200) == 0) {\n    bVar13 = param_1 == 0x57;\n  }\n  else {\n    pp_Var7 = __ctype_toupper_loc();\n    bVar13 = (*pp_Var7)[bVar12] == 0x57;\n  }\n  if (((bVar13) && (iVar3 < rl_end)) && (iVar11 < iVar3)) {\n    if ((*(char *)(rl_line_buffer + iVar3) != ' ') && (*(char *)(rl_line_buffer + iVar3) != '\\t')) {\n      iVar3 = iVar3 + -1;\n      rl_point = iVar3;\n      goto LAB_001d2143;\n    }\n    if (*(int *)(param_2 + 0x1c) == 99) {\nLAB_001d2209:\n      if ((uVar1 & 0x200) == 0) {\n        if (param_1 == 0x57) goto LAB_001d2226;\n      }\n      else {\n        pp_Var7 = __ctype_toupper_loc();\n        if ((*pp_Var7)[bVar12] == 0x57) {\nLAB_001d2226:\n          iVar10 = iVar3;\n          if (iVar11 < iVar3) {\n            lVar8 = (long)iVar3;\n            do {\n              iVar10 = (int)lVar8;\n              if ((*(char *)(rl_line_buffer + lVar8) != ' ') &&\n                 (*(char *)(rl_line_buffer + lVar8) != '\\t')) break;\n              iVar10 = iVar10 + -1;\n              lVar8 = lVar8 + -1;\n              rl_point = iVar10;\n            } while (iVar11 < (int)lVar8);\n          }\n          iVar3 = rl_point;\n          if (iVar11 == iVar10) {\n            if (iVar11 < rl_end) {\n              sVar9 = __ctype_get_mb_cur_max();\n              iVar11 = rl_point;\n              if ((sVar9 != 1) && (rl_byte_oriented == 0)) {\n                iVar3 = _rl_forward_char_internal(1);\n                if (iVar11 != iVar3) goto LAB_001d238f;\n                goto LAB_001d2397;\n              }\nLAB_001d2342:\n              iVar11 = rl_mark;\n              iVar3 = rl_point + 1;\n              rl_point = rl_point + 1;\n            }\n          }\n          else if ((((-1 < iVar10) && (iVar10 < rl_end + -1)) &&\n                   (*(char *)(rl_line_buffer + iVar10) != ' ' &&\n                    *(char *)(rl_line_buffer + iVar10) != '\\t')) && (iVar10 < rl_end)) {\n            sVar9 = __ctype_get_mb_cur_max();\n            iVar11 = rl_point;\n            if ((sVar9 == 1) || (rl_byte_oriented != 0)) goto LAB_001d2342;\n            iVar3 = _rl_forward_char_internal(1);\n            if (iVar3 != iVar11) {\nLAB_001d238f:\n              iVar11 = rl_mark;\n              rl_point = iVar3;\n              if (iVar3 <= rl_end) goto LAB_001d214c;\n            }\nLAB_001d2397:\n            rl_point = rl_end;\n            iVar11 = rl_mark;\n            iVar3 = rl_end;\n          }\n        }\n      }\nLAB_001d214c:\n      if (iVar3 <= iVar11) goto LAB_001d215e;\n    }\n    rl_mark = iVar3;\n    rl_point = iVar11;\n  }\n  else {\nLAB_001d2143:\n    if (*(int *)(param_2 + 0x1c) != 99) goto LAB_001d214c;\n    if (iVar11 <= iVar3) goto LAB_001d2209;\n  }\nLAB_001d215e:\n  if ((rl_readline_state & 0x80000) != 0) {\n    (*(code *)rl_redisplay_function)();\n  }\nLAB_001d216d:\n  uVar5 = FUN_001cff80(param_2);\n  return uVar5;\n}\n\n",
  "FUN_0019e5f0": "\nvoid FUN_0019e5f0(long param_1,code *param_2)\n\n{\n  long lVar1;\n  int iVar2;\n  long *plVar3;\n  size_t sVar4;\n  char *__dest;\n  char *pcVar5;\n  long lVar6;\n  char **ppcVar7;\n  long lVar8;\n  int iVar9;\n  int iVar10;\n  long *local_50;\n  \n  plVar3 = (long *)(*param_2)();\n  if (plVar3 != (long *)0x0) {\n    iVar10 = 0;\n    lVar6 = 8;\n    iVar2 = 0;\n    if (*plVar3 == 0) {\n      lVar8 = 0;\n      local_50 = (long *)strlist_create(1);\n    }\n    else {\n      do {\n        iVar9 = iVar2;\n        lVar8 = lVar6;\n        iVar10 = iVar9 + 1;\n        lVar6 = lVar8 + 8;\n        iVar2 = iVar10;\n      } while (*(long *)((long)plVar3 + lVar8) != 0);\n      lVar6 = 0;\n      local_50 = (long *)strlist_create(iVar9 + 2);\n      do {\n        pcVar5 = **(char ***)((long)plVar3 + lVar6);\n        sVar4 = strlen(pcVar5);\n        __dest = (char *)sh_xmalloc(sVar4 + 1,\"pcomplete.c\",0x19e);\n        lVar1 = *local_50;\n        pcVar5 = strcpy(__dest,pcVar5);\n        ppcVar7 = (char **)(lVar1 + lVar6);\n        lVar6 = lVar6 + 8;\n        *ppcVar7 = pcVar5;\n      } while ((long)(iVar9 + 1) * 8 != lVar6);\n    }\n    *(int *)((long)local_50 + 0xc) = iVar10;\n    *(undefined8 *)(*local_50 + lVar8) = 0;\n    *(long **)(param_1 + 0x10) = local_50;\n    sh_xfree(plVar3,\"pcomplete.c\",0x1a1);\n    return;\n  }\n  *(undefined8 *)(param_1 + 0x10) = 0;\n  return;\n}\n\n",
  "free_history_entry": "\nvoid * free_history_entry(void **param_1)\n\n{\n  void *pvVar1;\n  \n  if (param_1 == (void **)0x0) {\n    pvVar1 = (void *)0x0;\n  }\n  else {\n    if (*param_1 != (void *)0x0) {\n      free(*param_1);\n    }\n    if (param_1[1] != (void *)0x0) {\n      free(param_1[1]);\n    }\n    pvVar1 = param_1[2];\n    xfree(param_1);\n  }\n  return pvVar1;\n}\n\n",
  "rl_display_match_list": "\nvoid rl_display_match_list(char **param_1,int param_2,int param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  char *pcVar5;\n  size_t sVar6;\n  long lVar7;\n  long lVar8;\n  int iVar9;\n  ulong uVar10;\n  int local_74;\n  int local_60;\n  int local_5c;\n  long local_58;\n  long local_50;\n  int local_40;\n  \n  if (_rl_completion_prefix_display_length < 1) {\n    if (0 < _rl_colored_completion_prefix) {\n      uVar10 = (ulong)rl_filename_completion_desired;\n      pcVar4 = *param_1;\n      if (rl_filename_completion_desired == 0) {\n        iVar2 = FUN_001d7840(pcVar4);\n        if (pcVar4 != (char *)0x0) goto LAB_001d8a4b;\n      }\n      else {\n        pcVar4 = (char *)FUN_001d6140();\n        pcVar5 = strrchr(pcVar4,0x2f);\n        if (pcVar5 == (char *)0x0) {\n          iVar2 = FUN_001d7840(pcVar4);\nLAB_001d8a4b:\n          uVar10 = 0;\n          if (((*pcVar4 != '\\0') && (uVar10 = 1, pcVar4[1] != '\\0')) &&\n             (uVar10 = 2, pcVar4[2] != '\\0')) {\n            sVar6 = strlen(pcVar4);\n            uVar10 = sVar6 & 0xffffffff;\n          }\n        }\n        else {\n          uVar10 = 0;\n          iVar2 = FUN_001d7840(pcVar5);\n          if (((pcVar5[1] != '\\0') && (uVar10 = 1, pcVar5[2] != '\\0')) &&\n             (uVar10 = 2, pcVar5[3] != '\\0')) {\n            sVar6 = strlen(pcVar5 + 1);\n            uVar10 = sVar6 & 0xffffffff;\n          }\n        }\n      }\n      if (iVar2 <= (int)uVar10) {\n        iVar2 = (int)uVar10;\n      }\n      if (iVar2 <= param_3) goto LAB_001d8502;\n    }\nLAB_001d8711:\n    uVar10 = 0;\n    if (_rl_completion_columns < 0) goto LAB_001d871f;\nLAB_001d8510:\n    iVar3 = _rl_completion_columns;\n    iVar2 = _rl_completion_columns;\n    if (_rl_completion_columns <= _rl_screenwidth) goto LAB_001d853f;\n    pcVar4 = getenv(\"COLUMNS\");\n    if ((pcVar4 != (char *)0x0) && (*pcVar4 != '\\0')) goto LAB_001d8735;\n  }\n  else {\n    pcVar4 = *param_1;\n    if (rl_filename_completion_desired == 0) {\nLAB_001d86d5:\n      iVar2 = FUN_001d7840(pcVar4);\n      sVar6 = strlen(pcVar4);\n      uVar10 = sVar6 & 0xffffffff;\n      iVar3 = iVar2;\n      if (iVar2 <= (int)uVar10) {\n        iVar3 = (int)uVar10;\n      }\n    }\n    else {\n      pcVar4 = (char *)FUN_001d6140(pcVar4);\n      pcVar5 = strrchr(pcVar4,0x2f);\n      if (pcVar5 == (char *)0x0) goto LAB_001d86d5;\n      iVar2 = FUN_001d7840(pcVar5);\n      sVar6 = strlen(pcVar5);\n      uVar10 = sVar6 & 0xffffffff;\n      iVar3 = iVar2;\n      if (iVar2 <= (int)uVar10) {\n        iVar3 = (int)uVar10;\n      }\n    }\n    if (param_3 < iVar3) {\n      uVar10 = 0;\njoined_r0x001d8708:\n      if (_rl_colored_completion_prefix < 1) goto LAB_001d8711;\n    }\n    else {\n      iVar3 = _rl_completion_prefix_display_length;\n      if (_rl_completion_prefix_display_length < 3) {\n        iVar3 = 3;\n      }\n      if (iVar2 <= iVar3) goto joined_r0x001d8708;\n      param_3 = param_3 - (iVar2 + -3);\n    }\nLAB_001d8502:\n    if (-1 < _rl_completion_columns) goto LAB_001d8510;\nLAB_001d871f:\n    pcVar4 = getenv(\"COLUMNS\");\n    iVar2 = _rl_screenwidth;\n    if ((pcVar4 == (char *)0x0) || (*pcVar4 == '\\0')) goto LAB_001d853f;\nLAB_001d8735:\n    lVar8 = strtol(pcVar4,(char **)0x0,10);\n    iVar3 = (int)lVar8;\n    iVar2 = _rl_screenwidth;\n    if (iVar3 < 0) goto LAB_001d853f;\n  }\n  iVar2 = _rl_screenwidth;\n  if (iVar3 < _rl_screenwidth) {\n    iVar2 = iVar3;\n  }\nLAB_001d853f:\n  param_3 = param_3 + 2;\n  iVar3 = iVar2 / param_3;\n  local_74 = iVar3;\n  local_40 = param_2;\n  if (iVar3 != 1) {\n    local_74 = iVar3 + -1;\n    if (param_3 * iVar3 != iVar2) {\n      local_74 = iVar3;\n    }\n    if (((iVar2 < _rl_screenwidth) && (local_74 < 0)) || (local_74 == 0)) {\n      local_74 = 1;\n    }\n    else {\n      local_40 = (local_74 + -1 + param_2) / local_74;\n    }\n  }\n  if ((rl_ignore_completion_duplicates == 0) && (rl_sort_completion_matches != 0)) {\n    qsort(param_1 + 1,(long)param_2,8,_rl_qsort_string_compare);\n  }\n  rl_crlf();\n  if (_rl_print_completions_horizontally == 0) {\n    if (0 < local_40) {\n      local_5c = 0;\n      local_60 = 1;\n      local_58 = ~(long)local_40 << 3;\n      local_50 = 8;\n      do {\n        if ((local_60 <= param_2) && (0 < local_74)) {\n          iVar2 = 0;\n          lVar8 = (long)(local_40 + local_60);\n          do {\n            lVar1 = *(long *)((long)param_1 + lVar8 * 8 + local_58 + local_50);\n            if (lVar1 == 0) break;\n            lVar7 = lVar1;\n            if (rl_filename_completion_desired != 0) {\n              lVar7 = FUN_001d6140(lVar1);\n            }\n            iVar2 = iVar2 + 1;\n            iVar3 = FUN_001d7970(lVar7,lVar1,uVar10);\n            if (local_74 <= iVar2) break;\n            if (iVar3 < param_3) {\n              iVar9 = 0;\n              do {\n                iVar9 = iVar9 + 1;\n                putc(0x20,rl_outstream);\n              } while (iVar9 != param_3 - iVar3);\n            }\n            else {\n              putc(0x20,rl_outstream);\n            }\n            iVar3 = (int)lVar8;\n            lVar8 = lVar8 + local_40;\n          } while (iVar3 <= param_2);\n        }\n        rl_crlf();\n        if ((_rl_caught_signal != 0) && (_rl_caught_signal != 0x1c)) {\n          return;\n        }\n        local_5c = local_5c + 1;\n        if ((((_rl_page_completions != 0) && (_rl_screenheight + -1 <= local_5c)) &&\n            (local_60 < local_40)) && (local_5c = FUN_001d77b0(local_5c), local_5c < 0)) {\n          return;\n        }\n        local_60 = local_60 + 1;\n        local_50 = local_50 + 8;\n        local_58 = local_58 + -8;\n      } while (local_60 <= local_40);\n    }\n    return;\n  }\n  lVar8 = 1;\n  pcVar4 = param_1[1];\n  if (pcVar4 != (char *)0x0) {\n    iVar2 = 0;\n    do {\n      while( true ) {\n        pcVar5 = pcVar4;\n        if (rl_filename_completion_desired != 0) {\n          pcVar5 = (char *)FUN_001d6140(pcVar4);\n        }\n        iVar3 = FUN_001d7970(pcVar5,pcVar4,uVar10);\n        if ((_rl_caught_signal != 0) && (_rl_caught_signal != 0x1c)) {\n          return;\n        }\n        if (param_1[lVar8 + 1] != (char *)0x0) break;\nLAB_001d8628:\n        lVar8 = lVar8 + 1;\n        pcVar4 = param_1[lVar8];\n        if (pcVar4 == (char *)0x0) goto LAB_001d86c2;\n      }\n      if ((local_74 == 1) || ((1 < local_74 && ((int)lVar8 % local_74 == 0)))) {\n        rl_crlf();\n        iVar2 = iVar2 + 1;\n        if ((_rl_page_completions != 0) &&\n           ((_rl_screenheight + -1 <= iVar2 && (iVar2 = FUN_001d77b0(iVar2), iVar2 < 0)))) {\n          return;\n        }\n        goto LAB_001d8628;\n      }\n      if (iVar3 < param_3) {\n        iVar9 = 0;\n        do {\n          iVar9 = iVar9 + 1;\n          putc(0x20,rl_outstream);\n        } while (param_3 - iVar3 != iVar9);\n        goto LAB_001d8628;\n      }\n      lVar8 = lVar8 + 1;\n      putc(0x20,rl_outstream);\n      pcVar4 = param_1[lVar8];\n    } while (pcVar4 != (char *)0x0);\n  }\nLAB_001d86c2:\n  rl_crlf();\n  return;\n}\n\n",
  "rl_bind_keyseq_in_map": "\nvoid rl_bind_keyseq_in_map(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  rl_generic_bind(0,param_1,param_2,param_3);\n  return;\n}\n\n",
  "map_over_funcs": "\nlong map_over_funcs(undefined8 param_1)\n\n{\n  int iVar1;\n  long *plVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  \n  lVar4 = shell_functions;\n  if (shell_functions != 0) {\n    iVar1 = *(int *)(shell_functions + 0xc);\n    lVar4 = 0;\n    if (iVar1 != 0) {\n      plVar2 = (long *)sh_xmalloc(0x10,\"variables.c\",0x104b);\n      puVar3 = (undefined8 *)sh_xmalloc((long)(iVar1 + 1) << 3,\"variables.c\",0x104c);\n      *(int *)(plVar2 + 1) = iVar1;\n      *plVar2 = (long)puVar3;\n      lVar4 = shell_functions;\n      *(undefined4 *)((long)plVar2 + 0xc) = 0;\n      *puVar3 = 0;\n      FUN_00152050(lVar4,param_1,plVar2);\n      lVar4 = *plVar2;\n      sh_xfree(plVar2,\"variables.c\",0x10a4);\n    }\n  }\n  return lVar4;\n}\n\n",
  "dirs_builtin": "\nundefined8 dirs_builtin(undefined8 *param_1)\n\n{\n  long lVar1;\n  char cVar2;\n  bool bVar3;\n  bool bVar4;\n  undefined8 uVar5;\n  int iVar6;\n  undefined8 uVar7;\n  undefined8 *puVar8;\n  undefined8 *puVar9;\n  undefined *puVar10;\n  long lVar11;\n  char *__s1;\n  char *pcVar12;\n  uint uVar13;\n  long in_FS_OFFSET;\n  bool bVar14;\n  int local_4c;\n  long local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (undefined8 *)0x0) {\n    local_4c = 0;\n    uVar13 = 0;\n    puVar9 = (undefined8 *)get_working_directory(\"dirs\");\n    if (puVar9 == (undefined8 *)0x0) {\n      bVar4 = false;\nLAB_001aea69:\n      puVar8 = (undefined8 *)sh_xmalloc(0x17,\"./pushd.def\",0x1e0);\n      uVar5 = s_<no_current_direersa:d:i:n:p:t:u_00210310._8_8_;\n      uVar7 = s_<no_current_direersa:d:i:n:p:t:u_00210310._0_8_;\n      *(undefined4 *)(puVar8 + 2) = 0x726f7463;\n      *(undefined2 *)((long)puVar8 + 0x14) = 0x3e79;\n      *(undefined *)((long)puVar8 + 0x16) = 0;\n      *puVar8 = uVar7;\n      puVar8[1] = uVar5;\nLAB_001ae827:\n      puVar9 = puVar8;\n      if ((uVar13 & 2) == 0) {\n        if (!bVar4) goto LAB_001aea56;\n        goto LAB_001aea15;\n      }\n      if (!bVar4) {\n        puVar8 = (undefined8 *)polite_directory_format(puVar8);\n      }\n      __printf_chk(1,&DAT_002102d5,0,puVar8);\n    }\n    else {\nLAB_001aea56:\n      bVar4 = false;\n      puVar8 = (undefined8 *)polite_directory_format(puVar9);\nLAB_001aea15:\n      __printf_chk(1,&DAT_002102da,puVar8);\n    }\n    sh_xfree(puVar9,\"./pushd.def\",0x1e5);\n    if ((local_4c == 0) && (local_48 = (long)(DAT_00248b48 + -1), -1 < DAT_00248b48 + -1)) {\n      puVar10 = &DAT_001ff6d2;\n      if (uVar13 == 0) {\n        puVar10 = &DAT_001fdb1c;\n      }\n      do {\n        uVar7 = *(undefined8 *)(DAT_00248b50 + local_48 * 8);\n        if (uVar13 < 2) {\n          if (!bVar4) {\n            uVar7 = polite_directory_format(uVar7);\n          }\n          __printf_chk(1,&DAT_001fc632,puVar10,uVar7);\n        }\n        else {\n          if (!bVar4) {\n            uVar7 = polite_directory_format(uVar7);\n          }\n          __printf_chk(1,&DAT_002102d4,DAT_00248b48 - (int)local_48,uVar7);\n        }\n        local_48 = local_48 + -1;\n      } while (-1 < local_48);\n    }\n  }\n  else {\n    __s1 = *(char **)param_1[1];\n    if ((*__s1 == '-') && (iVar6 = strcmp(__s1,\"--help\"), iVar6 == 0)) {\n      builtin_help();\n      uVar7 = 0x102;\n      goto LAB_001ae7a2;\n    }\n    uVar13 = 0;\n    iVar6 = -1;\n    bVar3 = false;\n    bVar4 = false;\n    local_4c = 0;\n    pcVar12 = \"\";\nLAB_001ae653:\n    if (*__s1 != '-') {\n      if (*__s1 == '+') goto LAB_001ae608;\n      sh_invalidopt(__s1);\n      builtin_usage();\n      uVar7 = 0x102;\n      goto LAB_001ae7a2;\n    }\n    cVar2 = __s1[1];\n    if (cVar2 == 'l') {\n      if (__s1[2] != '\\0') goto LAB_001ae608;\n      bVar4 = true;\nLAB_001ae644:\n      param_1 = (undefined8 *)*param_1;\njoined_r0x001ae64a:\n      if (param_1 == (undefined8 *)0x0) goto LAB_001ae698;\n      __s1 = *(char **)param_1[1];\n      goto LAB_001ae653;\n    }\n    if (cVar2 == 'c') {\n      if (__s1[2] == '\\0') {\n        bVar3 = true;\n        goto LAB_001ae644;\n      }\nLAB_001ae608:\n      pcVar12 = __s1 + 1;\n      iVar6 = legal_number(pcVar12,&local_48);\n      if (iVar6 != 0) {\n        bVar14 = **(char **)param_1[1] == '+';\n        iVar6 = FUN_001ae530(local_48,(bVar14 - 1) + (uint)bVar14,&local_4c);\n        goto LAB_001ae644;\n      }\n      sh_invalidnum(*(char **)param_1[1]);\n      builtin_usage();\n      uVar7 = 0x102;\n      goto LAB_001ae7a2;\n    }\n    if (cVar2 == 'v') {\n      if (__s1[2] == '\\0') {\n        uVar13 = uVar13 | 2;\n        goto LAB_001ae644;\n      }\n      goto LAB_001ae608;\n    }\n    if (cVar2 == 'p') {\n      if (__s1[2] != '\\0') goto LAB_001ae608;\n      param_1 = (undefined8 *)*param_1;\n      uVar13 = uVar13 | 1;\n      goto joined_r0x001ae64a;\n    }\n    if ((cVar2 != '-') || (__s1[2] != '\\0')) goto LAB_001ae608;\nLAB_001ae698:\n    if (bVar3) {\n      lVar11 = 0;\n      if (0 < DAT_00248b48) {\n        do {\n          lVar1 = lVar11 * 8;\n          lVar11 = lVar11 + 1;\n          sh_xfree(*(undefined8 *)(DAT_00248b50 + lVar1),\"./pushd.def\",0x217);\n        } while ((int)lVar11 < DAT_00248b48);\n      }\n      DAT_00248b48 = 0;\n      uVar7 = 0;\n      goto LAB_001ae7a2;\n    }\n    if (local_4c == 0) {\nLAB_001ae808:\n      puVar8 = (undefined8 *)get_working_directory(\"dirs\");\n      if (puVar8 == (undefined8 *)0x0) goto LAB_001aea69;\n      goto LAB_001ae827;\n    }\n    if ((iVar6 < 0) || (DAT_00248b48 < iVar6)) {\n      if (DAT_00248b48 == 0) {\n        builtin_error(\"directory stack empty\");\n        uVar7 = 1;\n      }\n      else {\n        sh_erange(pcVar12,\"directory stack index\");\n        uVar7 = 1;\n      }\n      goto LAB_001ae7a2;\n    }\n    if ((local_4c == 1) && (iVar6 == 0)) goto LAB_001ae808;\n    uVar7 = *(undefined8 *)(DAT_00248b50 + (long)iVar6 * 8);\n    if ((uVar13 & 2) == 0) {\n      if (!bVar4) {\n        uVar7 = polite_directory_format(uVar7);\n      }\n      __printf_chk(1,&DAT_002102da,uVar7);\n    }\n    else {\n      if (!bVar4) {\n        uVar7 = polite_directory_format(uVar7);\n      }\n      __printf_chk(1,&DAT_002102d5,DAT_00248b48 - iVar6,uVar7);\n    }\n  }\n  putc(10,stdout);\n  uVar7 = sh_chkwrite(0);\nLAB_001ae7a2:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar7;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0017e5e0": "\nchar ** FUN_0017e5e0(char *param_1,char *param_2,int param_3,uint param_4,ulong param_5,\n                    undefined4 *param_6,uint *param_7)\n\n{\n  byte bVar1;\n  int iVar2;\n  char **ppcVar3;\n  undefined *puVar4;\n  ushort **ppuVar5;\n  char *pcVar6;\n  long lVar7;\n  size_t sVar8;\n  char *__dest;\n  long **pplVar9;\n  undefined2 *puVar10;\n  long *plVar11;\n  undefined8 uVar12;\n  uint uVar13;\n  bool bVar14;\n  long **pplVar15;\n  long in_FS_OFFSET;\n  undefined *local_80;\n  int local_70;\n  undefined4 local_6c;\n  char *local_68;\n  uint local_60;\n  undefined *local_50;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar6 = param_2;\n  if ((param_4 & 3) == 0) {\n    ppcVar3 = (char **)alloc_word_desc();\n    uVar13 = DAT_00247848;\n    local_70 = 0;\n    if (*param_2 != '\\0') {\n      if (param_3 == 0x3d) {\n        DAT_00247848 = 1;\n        local_60 = 0x6840;\n      }\n      else {\n        local_60 = 0x4040;\n        DAT_00247848 = (uint)(ifs_is_null == 0);\n      }\n      if ((param_5 & 8) != 0) goto LAB_0017eb26;\n      goto LAB_0017eb39;\n    }\n    if (param_7 != (uint *)0x0) {\n      uVar13 = 0;\n      pplVar9 = (long **)0x0;\n      goto LAB_0017e6fb;\n    }\n    uVar13 = param_3 - 0x2bU & 0xfffffffd;\nLAB_0017e69a:\n    if (uVar13 == 0) {\n      puVar10 = (undefined2 *)0x0;\nLAB_0017e961:\n      *ppcVar3 = (char *)puVar10;\n      goto LAB_0017e964;\n    }\nLAB_0017e6a2:\n    puVar10 = (undefined2 *)0x0;\n    puVar4 = (undefined *)sh_xmalloc(1,\"subst.c\",0x1e8f);\n    *puVar4 = 0;\n  }\n  else {\n    if (*param_2 != '\\0') {\n      local_6c = 0;\n      pcVar6 = (char *)FUN_0016aa90(param_2,&local_6c,0x800);\n    }\n    ppcVar3 = (char **)alloc_word_desc();\n    uVar13 = DAT_00247848;\n    local_70 = 0;\n    if (*pcVar6 != '\\0') {\n      local_60 = 0x4040;\n      DAT_00247848 = 1;\n      if ((param_5 & 8) != 0) {\nLAB_0017eb26:\n        local_60 = 0x4840;\n      }\n      if (param_3 == 0x3d) {\n        local_60 = local_60 | 0x2800;\n      }\nLAB_0017eb39:\n      local_70 = 0;\n      sVar8 = strlen(pcVar6);\n      __dest = (char *)sh_xmalloc(sVar8 + 1,\"subst.c\",0x11b8);\n      local_68 = strcpy(__dest,pcVar6);\n      pplVar9 = (long **)FUN_00177e80(&local_68,param_4,1,&local_70,0);\n      if (pplVar9 == (long **)&DAT_00247880) {\n        local_68 = (char *)0x0;\n        uVar12 = 2;\n        goto LAB_0017ec87;\n      }\n      if (pplVar9 == (long **)&DAT_00247870) {\n        local_68 = (char *)0x0;\n        uVar12 = 1;\n        goto LAB_0017ec87;\n      }\n      DAT_00247848 = uVar13;\n      sh_xfree(local_68,\"subst.c\",0x11bb);\n      if (param_7 != (uint *)0x0) {\n        if (local_70 == 0) {\n          uVar13 = 0;\n          if (pplVar9 != (long **)0x0) {\n            uVar13 = (uint)(*pplVar9 != (long *)0x0);\n          }\n        }\n        else {\n          uVar13 = 1;\n        }\n        goto LAB_0017e6fb;\n      }\nLAB_0017e701:\n      if (param_2 != pcVar6) {\n        sh_xfree(pcVar6,\"subst.c\",0x1e2e);\n      }\n      pplVar15 = pplVar9;\n      if (pplVar9 == (long **)0x0) {\n        uVar13 = param_3 - 0x2bU & 0xfffffffd;\n        if ((param_4 & 3) == 0) goto LAB_0017e69a;\n        goto LAB_0017e68e;\n      }\n      do {\n        if (((char **)pplVar15[1] != (char **)0x0) &&\n           ((pcVar6 = (char *)*pplVar15[1], pcVar6 == (char *)0x0 || (*pcVar6 == '\\0')))) {\n          puVar10 = (undefined2 *)sh_xmalloc(3,\"subst.c\",0x12cd);\n          *puVar10 = 0x7f;\n          plVar11 = pplVar15[1];\n          if (*plVar11 != 0) {\n            sh_xfree(*plVar11,\"subst.c\",0x1e39);\n            plVar11 = pplVar15[1];\n          }\n          *plVar11 = (long)puVar10;\n          *(uint *)(plVar11 + 1) = *(uint *)(plVar11 + 1) & 0xffdfffff | 0x40002;\n        }\n        pplVar15 = (long **)*pplVar15;\n      } while (pplVar15 != (long **)0x0);\n      plVar11 = *pplVar9;\n      if (param_6 != (undefined4 *)0x0) {\n        if (((local_70 != 0) && (param_4 != 0)) || (plVar11 != (long *)0x0)) {\n          *param_6 = 1;\n          goto LAB_0017e7d4;\n        }\nLAB_0017ea50:\n        if (local_70 != 0) goto LAB_0017e7ef;\n        puVar10 = (undefined2 *)string_list_internal(pplVar9,&DAT_001fdb1c);\n        if (puVar10 == (undefined2 *)0x0) goto LAB_0017e7fa;\n        if ((*(char *)puVar10 != '\\x7f') || (*(char *)((long)puVar10 + 1) != '\\0')) {\n          if ((*(byte *)((long)pplVar9[1] + 10) & 0x20) != 0) {\n            *(uint *)(ppcVar3 + 1) = *(uint *)(ppcVar3 + 1) | 0x200000;\n          }\n          goto LAB_0017e7fa;\n        }\n        if ((*pplVar9 == (long *)0x0) && ((param_4 & 3) != 0)) goto LAB_0017ee6a;\nLAB_0017ed69:\n        dispose_words(pplVar9);\n        uVar13 = param_3 - 0x2bU & 0xfffffffd;\n        goto joined_r0x0017ed7b;\n      }\nLAB_0017e7d4:\n      if (plVar11 == (long *)0x0) goto LAB_0017ea50;\n      if (ifs_is_null != 0) {\n        puVar10 = (undefined2 *)string_list_internal(pplVar9,&DAT_001fdb1c);\n        *(uint *)(ppcVar3 + 1) = *(uint *)(ppcVar3 + 1) | 8;\n        goto LAB_0017e7fa;\n      }\nLAB_0017e7ef:\n      puVar10 = (undefined2 *)FUN_0016e2d0(pplVar9);\nLAB_0017e7fa:\n      if ((*pplVar9 == (long *)0x0) && ((param_4 & 3) != 0)) {\n        if ((*(char *)puVar10 == '\\x7f') && (*(char *)((long)puVar10 + 1) == '\\0')) {\nLAB_0017ee6a:\n          pcVar6 = (char *)*pplVar9[1];\n          if ((((*pcVar6 == '\\x7f') && (pcVar6[1] == '\\0')) &&\n              ((*(byte *)((long)pplVar9[1] + 10) & 4) != 0)) &&\n             ((*(uint *)(ppcVar3 + 1) = *(uint *)(ppcVar3 + 1) | 0x40000,\n              param_6 != (undefined4 *)0x0 && (local_70 != 0)))) {\n            *param_6 = 0;\n          }\n        }\n        goto LAB_0017ed69;\n      }\n      dispose_words(pplVar9);\n      if ((param_3 - 0x2bU & 0xfffffffd) == 0) goto LAB_0017e961;\n      if (puVar10 != (undefined2 *)0x0) goto LAB_0017e835;\n      goto LAB_0017e6a2;\n    }\n    pplVar9 = (long **)0x0;\n    uVar13 = 0;\n    if (param_7 != (uint *)0x0) {\nLAB_0017e6fb:\n      *param_7 = uVar13;\n      goto LAB_0017e701;\n    }\n    if (param_2 != pcVar6) {\n      sh_xfree(pcVar6,\"subst.c\",0x1e2e);\n    }\n    uVar13 = param_3 - 0x2bU & 0xfffffffd;\nLAB_0017e68e:\n    if (local_70 == 0) goto LAB_0017e69a;\n    puVar10 = (undefined2 *)sh_xmalloc(3,\"subst.c\",0x12cd);\n    *puVar10 = 0x7f;\n    *(uint *)(ppcVar3 + 1) = *(uint *)(ppcVar3 + 1) | 0x40000;\njoined_r0x0017ed7b:\n    if (uVar13 == 0) goto LAB_0017e961;\nLAB_0017e835:\n    puVar4 = (undefined *)dequote_string(puVar10);\n  }\n  sh_xfree(puVar10,\"subst.c\",0x1e90);\n  pcVar6 = param_1;\n  if (*param_1 == '!') {\n    ppuVar5 = __ctype_b_loc();\n    bVar1 = param_1[1];\n    if ((*(byte *)((long)*ppuVar5 + (ulong)bVar1 * 2 + 1) & 4) == 0) {\n      if (bVar1 != 0x5f) {\n        if (((9 < (byte)(bVar1 - 0x30)) &&\n            (((posixly_correct != 0 || ((bVar1 != 0x23 && (bVar1 != 0x3f)))) && (bVar1 != 0x2a))))\n           && (bVar1 != 0x40)) goto LAB_0017e993;\n        goto LAB_0017e8b0;\n      }\nLAB_0017e930:\n      bVar14 = false;\n      if (param_1[2] == '\\0') {\n        if ((posixly_correct == 0) && ((bVar1 == 0x23 || (bVar1 == 0x3f)))) {\n          bVar14 = true;\n        }\n        else {\n          bVar14 = bVar1 == 0x40 || bVar1 == 0x2a;\n        }\n      }\n    }\n    else {\nLAB_0017e8b0:\n      if ((bVar1 != 0) || (bVar14 = true, (DAT_002394a4._1_1_ & 8) == 0)) goto LAB_0017e930;\n    }\n    pcVar6 = (char *)FUN_0017c6a0(param_1 + 1,bVar14,param_4,1);\n    if ((pcVar6 == (char *)0x0) || (*pcVar6 == '\\0')) {\n      report_error(\"%s: invalid indirect expansion\",param_1);\n      sh_xfree(pcVar6,\"subst.c\",0x1e9b);\n      uVar12 = 0x1e9c;\n    }\n    else {\n      iVar2 = legal_identifier(pcVar6);\n      if (iVar2 != 0) goto LAB_0017e993;\n      report_error(\"%s: invalid variable name\",pcVar6);\n      sh_xfree(pcVar6,\"subst.c\",0x1ea3);\n      uVar12 = 0x1ea4;\n    }\n    sh_xfree(puVar4,\"subst.c\",uVar12);\n    dispose_word(ppcVar3);\n    ppcVar3 = (char **)&DAT_00247860;\n    goto LAB_0017e964;\n  }\nLAB_0017e993:\n  iVar2 = valid_array_reference(pcVar6,0);\n  if (iVar2 == 0) {\n    lVar7 = bind_variable(pcVar6,puVar4,0);\n  }\n  else {\n    init_eltstate(&local_68);\n    lVar7 = assign_array_element(pcVar6,puVar4,0x800,&local_68);\n    local_80 = local_50;\n  }\n  if (lVar7 != 0) {\n    if ((*(uint *)(lVar7 + 0x28) & 0x4002) == 0) {\n      stupidly_hack_special_variables(pcVar6);\n      if (0x33 < shell_compatibility_level) {\n        if (puVar4 != (undefined *)0x0) {\n          sh_xfree(puVar4,\"subst.c\",0x1ecc);\n        }\n        if (iVar2 == 0) {\n          puVar4 = (undefined *)get_variable_value(lVar7);\n        }\n        else {\n          flush_eltstate(&local_68);\n          puVar4 = local_80;\n        }\n      }\n      if (pcVar6 != param_1) {\n        sh_xfree(pcVar6,\"subst.c\",0x1edb);\n      }\n      if ((param_4 & 3) == 0) {\n        pcVar6 = (char *)FUN_00167220(puVar4,0);\n        *ppcVar3 = pcVar6;\n        if (pcVar6 == (char *)0x0) goto LAB_0017e964;\nLAB_0017ed17:\n        if (*pcVar6 == '\\0') goto LAB_0017e964;\n        if ((*pcVar6 != '\\x7f') || (pcVar6[1] != '\\0')) {\n          *(uint *)(ppcVar3 + 1) = *(uint *)(ppcVar3 + 1) & 0xffdfffff;\n          if ((param_4 & 3) == 0) goto LAB_0017e964;\n          goto LAB_0017ed3f;\n        }\n        if ((param_4 & 3) == 0) goto LAB_0017e964;\n      }\n      else {\n        pcVar6 = (char *)quote_string(puVar4);\n        *ppcVar3 = pcVar6;\n        if (pcVar6 != (char *)0x0) goto LAB_0017ed17;\nLAB_0017ed3f:\n        if ((*pcVar6 != '\\x7f') || (pcVar6[1] != '\\0')) goto LAB_0017e964;\n      }\n      *(uint *)(ppcVar3 + 1) = *(uint *)(ppcVar3 + 1) | 0x40000;\nLAB_0017e964:\n      if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return ppcVar3;\n    }\n    if ((*(uint *)(lVar7 + 0x28) & 2) == 0) goto LAB_0017ea0c;\n  }\n  if ((interactive_shell == 0) && (posixly_correct != 0)) {\n    uVar12 = 1;\nLAB_0017ec87:\n    last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n    FUN_001667f0(uVar12);\n  }\nLAB_0017ea0c:\n  if (pcVar6 != param_1) {\n    sh_xfree(pcVar6,\"subst.c\",0x1ec1);\n  }\n  last_command_exit_value = 2;\n                    /* WARNING: Subroutine does not return */\n  FUN_001667f0(2);\n}\n\n",
  "FUN_0019f4a0": "\n/* WARNING: Type propagation algorithm not settling */\n\nlong * FUN_0019f4a0(uint *param_1,undefined8 param_2)\n\n{\n  byte bVar1;\n  long *plVar2;\n  int iVar3;\n  long *plVar4;\n  char *__s;\n  size_t sVar5;\n  char *__dest;\n  char *__s1;\n  int iVar6;\n  long lVar7;\n  long lVar8;\n  int iVar9;\n  \n  if ((*param_1 & 7) != 4) {\n    if ((*param_1 & 3) == 0) {\n      bVar1 = *(byte *)param_1;\n    }\n    else {\n      clean_itemlist();\n      bVar1 = *(byte *)param_1;\n    }\n    if ((bVar1 & 4) == 0) {\n      (**(code **)(param_1 + 2))(param_1);\n      *param_1 = *param_1 & 0xfffffffd | 4;\n    }\n  }\n  if (*(long *)(param_1 + 4) == 0) {\n    return (long *)0x0;\n  }\n  plVar4 = (long *)strlist_create(*(int *)(*(long *)(param_1 + 4) + 0xc) + 1);\n  plVar2 = *(long **)(param_1 + 4);\n  __s = (char *)bash_dequote_text(param_2);\n  if (__s == (char *)0x0) {\n    iVar6 = 0;\n    if (*(int *)((long)plVar2 + 0xc) < 1) {\n      *(undefined4 *)((long)plVar4 + 0xc) = 0;\n      *(undefined8 *)*plVar4 = 0;\n      return plVar4;\n    }\n  }\n  else {\n    if (*__s == '\\0') {\n      iVar6 = 0;\nLAB_0019f510:\n      iVar9 = *(int *)((long)plVar2 + 0xc);\n    }\n    else {\n      if (__s[1] == '\\0') {\n        iVar6 = 1;\n        goto LAB_0019f510;\n      }\n      if (__s[2] == '\\0') {\n        iVar6 = 2;\n        goto LAB_0019f510;\n      }\n      sVar5 = strlen(__s);\n      iVar9 = *(int *)((long)plVar2 + 0xc);\n      iVar6 = (int)sVar5;\n    }\n    if (iVar9 < 1) {\n      *(undefined4 *)((long)plVar4 + 0xc) = 0;\n      *(undefined8 *)*plVar4 = 0;\n      goto LAB_0019f583;\n    }\n  }\n  lVar8 = 0;\n  iVar9 = 0;\nLAB_0019f53f:\n  do {\n    __s1 = *(char **)(*plVar2 + lVar8 * 8);\n    if (iVar6 == 0) {\n      if (__s1 != (char *)0x0) goto LAB_0019f646;\n    }\n    else {\n      if ((*__s1 != *__s) || (iVar3 = strncmp(__s1,__s,(long)iVar6), iVar3 != 0)) {\n        lVar8 = lVar8 + 1;\n        if (*(int *)((long)plVar2 + 0xc) == (int)lVar8 || *(int *)((long)plVar2 + 0xc) < (int)lVar8)\n        break;\n        goto LAB_0019f53f;\n      }\nLAB_0019f646:\n      sVar5 = strlen(__s1);\n      __dest = (char *)sh_xmalloc(sVar5 + 1,\"pcomplete.c\",0x2cf);\n      __s1 = strcpy(__dest,__s1);\n    }\n    lVar7 = (long)iVar9;\n    lVar8 = lVar8 + 1;\n    iVar9 = iVar9 + 1;\n    *(char **)(*plVar4 + lVar7 * 8) = __s1;\n  } while (*(int *)((long)plVar2 + 0xc) != (int)lVar8 && (int)lVar8 <= *(int *)((long)plVar2 + 0xc))\n  ;\n  *(int *)((long)plVar4 + 0xc) = iVar9;\n  *(undefined8 *)(*plVar4 + (long)iVar9 * 8) = 0;\n  if (__s == (char *)0x0) {\n    return plVar4;\n  }\nLAB_0019f583:\n  sh_xfree(__s,\"pcomplete.c\",0x2d3);\n  return plVar4;\n}\n\n",
  "maybe_make_restricted": "\nundefined8 maybe_make_restricted(void)\n\n{\n  int iVar1;\n  char *pcVar2;\n  \n  pcVar2 = (char *)base_pathname();\n  if (restricted == 0) {\n    if (pcVar2[*pcVar2 == '-'] == 'r') {\n      iVar1 = strcmp(pcVar2 + (*pcVar2 == '-'),\"rbash\");\n      if (iVar1 == 0) goto LAB_00134198;\n    }\n    return 0;\n  }\nLAB_00134198:\n  set_var_read_only(\"PATH\");\n  set_var_read_only(\"SHELL\");\n  set_var_read_only(\"ENV\");\n  set_var_read_only(\"BASH_ENV\");\n  set_var_read_only(\"HISTFILE\");\n  restricted = 1;\n  return 1;\n}\n\n",
  "builtin_error": "\nvoid builtin_error(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                  undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                  undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                  undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  FUN_001a3980();\n  local_d0 = &stack0x00000008;\n  local_d8 = 8;\n  local_c8 = local_b8;\n  local_d4 = 0x30;\n  __vfprintf_chk(stderr,1,param_9,&local_d8);\n  fputc(10,stderr);\n  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_funmap_names": "\nvoid * rl_funmap_names(void)\n\n{\n  size_t sVar1;\n  long *plVar2;\n  void *__base;\n  char **ppcVar3;\n  long lVar4;\n  int iVar5;\n  code *pcVar6;\n  char *pcVar7;\n  size_t __nmemb;\n  \n  if (DAT_0024a438 == 0) {\n    pcVar6 = rl_abort;\n    pcVar7 = \"abort\";\n    iVar5 = 0;\n    ppcVar3 = &PTR_s_accept_line_002369b0;\n    while( true ) {\n      rl_add_funmap_entry(pcVar7,pcVar6);\n      pcVar7 = *ppcVar3;\n      iVar5 = iVar5 + 1;\n      if (pcVar7 == (char *)0x0) break;\n      pcVar6 = (code *)ppcVar3[1];\n      ppcVar3 = ppcVar3 + 2;\n    }\n    DAT_0024a438 = 1;\n    funmap_program_specific_entry_start = iVar5;\n  }\n  if (*funmap == 0) {\n    __nmemb = 0;\n    __base = (void *)0x0;\n  }\n  else {\n    iVar5 = 0;\n    __base = (void *)0x0;\n    lVar4 = 0;\n    plVar2 = funmap;\n    sVar1 = 1;\n    do {\n      __nmemb = sVar1;\n      if (iVar5 <= (int)__nmemb) {\n        iVar5 = iVar5 + 0x14;\n        __base = (void *)xrealloc(__base,(long)iVar5 << 3);\n        plVar2 = funmap;\n      }\n      *(undefined8 *)((long)__base + lVar4) = **(undefined8 **)((long)plVar2 + lVar4);\n      lVar4 = lVar4 + 8;\n      *(undefined8 *)((long)__base + lVar4) = 0;\n      sVar1 = __nmemb + 1;\n    } while (*(long *)((long)plVar2 + lVar4) != 0);\n  }\n  qsort(__base,__nmemb,8,_rl_qsort_string_compare);\n  return __base;\n}\n\n",
  "fsleep": "\nint fsleep(uint param_1,int param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  long in_FS_OFFSET;\n  timespec local_b8;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_a8);\n  sigaddset(&local_a8,0x11);\n  local_b8.tv_sec = (__time_t)param_1;\n  local_b8.tv_nsec = (long)(uint)(param_2 * 1000);\n  iVar1 = pselect(0,(fd_set *)0x0,(fd_set *)0x0,(fd_set *)0x0,&local_b8,&local_a8);\n  piVar2 = __errno_location();\n  if ((iVar1 < 0) && (*piVar2 == 4)) {\n    iVar1 = -1;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "unlink_fifo_list": "\nvoid unlink_fifo_list(void)\n\n{\n  if (DAT_00247834 != 0) {\n    FUN_00168fd0();\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001bd040": "\nint FUN_001bd040(char *param_1,uint param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  stat sStack_a8;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_2 & 0x10) == 0) {\n    iVar1 = stat(param_1,&sStack_a8);\n  }\n  else {\n    iVar1 = lstat(param_1,&sStack_a8);\n  }\n  if (iVar1 < 0) {\n    iVar1 = -1;\n  }\n  else if ((sStack_a8.st_mode & 0xf000) == 0xa000) {\n    iVar1 = -2;\n  }\n  else {\n    iVar1 = -(uint)((sStack_a8.st_mode & 0xf000) != 0x4000);\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_unix_filename_rubout": "\nundefined8 rl_unix_filename_rubout(int param_1)\n\n{\n  char cVar1;\n  uint uVar2;\n  int iVar3;\n  ulong uVar4;\n  ulong uVar5;\n  long lVar6;\n  ulong uVar7;\n  uint uVar8;\n  \n  uVar2 = rl_point;\n  uVar7 = (ulong)rl_point;\n  if (rl_point == 0) {\n    rl_ding();\n    return 0;\n  }\n  if (param_1 < 1) {\n    param_1 = 1;\n  }\nLAB_001e9ae0:\n  param_1 = param_1 + -1;\n  uVar4 = (ulong)(int)uVar7;\n  uVar5 = (ulong)(uint)(int)*(char *)(rl_line_buffer + -1 + uVar4);\n  if ((int)uVar7 != 0) {\nLAB_001e9b11:\n    uVar4 = uVar4 - 1;\n    iVar3 = (int)uVar5;\n    if ((iVar3 == 0x20) || (iVar3 == 9)) goto LAB_001e9af8;\n    if (iVar3 != 0x2f) goto LAB_001e9bb1;\n    uVar8 = (int)uVar7 - 1;\n    if (0 < (int)uVar8) {\n      lVar6 = (long)((int)uVar7 + -2);\n      do {\n        cVar1 = *(char *)(rl_line_buffer + lVar6);\n        iVar3 = (int)lVar6;\n        lVar6 = lVar6 + -1;\n      } while (0 < iVar3 && cVar1 == '/');\n      if (iVar3 != 0) {\n        if (cVar1 == ' ' || cVar1 == '\\t') {\n          uVar7 = (ulong)(iVar3 + 1);\n          goto LAB_001e9b73;\n        }\n        goto LAB_001e9bb1;\n      }\n      uVar7 = (ulong)(cVar1 == ' ' || cVar1 == '\\t');\nLAB_001e9b73:\n      rl_point = (uint)uVar7;\n      goto LAB_001e9b80;\n    }\n    uVar7 = (ulong)uVar8;\n    if (uVar8 == 0) goto LAB_001e9b73;\n    goto LAB_001e9c7c;\n  }\nLAB_001e9ba8:\n  if ((int)uVar5 == 0x2f) {\nLAB_001e9c7c:\n    uVar5 = 0x2f;\n  }\nLAB_001e9bb1:\n  uVar7 = (ulong)(int)rl_point;\n  if (rl_point != 0) {\n    uVar8 = rl_point - 1;\n    lVar6 = uVar7 - 2;\n    uVar4 = (ulong)(int)uVar8;\n    do {\n      if ((0x2f < (uint)uVar5) || ((0x800100000200U >> (uVar5 & 0x3f) & 1) == 0)) {\n        uVar7 = (ulong)(int)rl_point;\n        if (rl_point != 0) {\n          uVar8 = rl_point - 1;\n          lVar6 = uVar7 - 2;\n          uVar4 = (ulong)(int)uVar8;\n          goto LAB_001e9c1a;\n        }\n        break;\n      }\n      rl_point = (uint)uVar4;\n      uVar7 = uVar4 & 0xffffffff;\n      uVar5 = (ulong)(uint)(int)*(char *)(rl_line_buffer + -1 + uVar4);\n      uVar4 = uVar4 - 1;\n    } while (lVar6 - (ulong)uVar8 != uVar4);\n  }\n  goto LAB_001e9b80;\nLAB_001e9af8:\n  rl_point = (uint)uVar4;\n  uVar7 = uVar4 & 0xffffffff;\n  uVar5 = (ulong)(uint)(int)*(char *)(rl_line_buffer + -1 + uVar4);\n  if (rl_point == 0) goto LAB_001e9ba8;\n  goto LAB_001e9b11;\n  while( true ) {\n    rl_point = (uint)uVar4;\n    uVar7 = uVar4 & 0xffffffff;\n    uVar5 = (ulong)(uint)(int)*(char *)(rl_line_buffer + -1 + uVar4);\n    uVar4 = uVar4 - 1;\n    if (lVar6 - (ulong)uVar8 == uVar4) break;\nLAB_001e9c1a:\n    if (((uint)uVar5 < 0x30) && ((0x800100000200U >> (uVar5 & 0x3f) & 1) != 0)) {\n      uVar7 = (ulong)rl_point;\n      break;\n    }\n  }\nLAB_001e9b80:\n  if (param_1 == 0) {\n    rl_kill_text(uVar2);\n    if (rl_editing_mode == 1) {\n      rl_mark = rl_point;\n      return 0;\n    }\n    return 0;\n  }\n  goto LAB_001e9ae0;\n}\n\n",
  "_rl_region_color_on": "\nvoid _rl_region_color_on(void)\n\n{\n  if ((_rl_active_region_start_color != 0) && (_rl_active_region_end_color != 0)) {\n    tputs(_rl_active_region_start_color,1,_rl_output_character_function);\n    return;\n  }\n  return;\n}\n\n",
  "string_list_pos_params": "\nvoid string_list_pos_params(int param_1,undefined8 param_2,uint param_3,uint param_4)\n\n{\n  long *plVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  \n  if (param_1 == 0x2a) {\n    if ((param_3 & 1) != 0) {\n      puVar3 = (undefined8 *)FUN_00170510(param_2);\n      puVar2 = puVar3;\n      while (puVar2 != (undefined8 *)0x0) {\n        remove_quoted_nulls(*(undefined8 *)puVar2[1]);\n        plVar1 = puVar2 + 1;\n        puVar2 = (undefined8 *)*puVar2;\n        *(uint *)(*plVar1 + 8) = *(uint *)(*plVar1 + 8) & 0xfffbffff;\n      }\n      FUN_0016e2d0(puVar3);\n      return;\n    }\n    if ((param_3 & 2) != 0) {\n      puVar3 = (undefined8 *)FUN_00170510(param_2);\n      puVar2 = puVar3;\n      while (puVar2 != (undefined8 *)0x0) {\n        remove_quoted_nulls(*(undefined8 *)puVar2[1]);\n        plVar1 = puVar2 + 1;\n        puVar2 = (undefined8 *)*puVar2;\n        *(uint *)(*plVar1 + 8) = *(uint *)(*plVar1 + 8) & 0xfffbffff;\n      }\n      string_list_internal(puVar3,&DAT_001fdb1c);\n      return;\n    }\n    if (((param_3 == 0) && ((param_4 & 8 | ifs_is_null) != 0)) && (DAT_00247848 == 0)) {\nLAB_00171d00:\n      string_list_dollar_at(param_2,0,0);\n      return;\n    }\n  }\n  else {\n    if (param_1 != 0x40) {\n      if ((param_3 & 3) != 0) {\n        param_2 = FUN_00170510(param_2);\n      }\n      string_list_internal(param_2,&DAT_001fdb1c);\n      return;\n    }\n    if ((param_3 & 3) != 0) {\n      string_list_dollar_at(param_2,param_3,0);\n      return;\n    }\n    if (param_3 == 0) {\n      if (ifs_is_null != 0) goto LAB_00171d00;\n      if ((param_4 & 8) != 0) {\n        string_list_dollar_at(param_2,0,param_4);\n        return;\n      }\n    }\n  }\n  FUN_0016e2d0();\n  return;\n}\n\n",
  "rl_set_paren_blink_timeout": "\nint rl_set_paren_blink_timeout(int param_1)\n\n{\n  int iVar1;\n  \n  iVar1 = DAT_00240760;\n  if (0 < param_1) {\n    DAT_00240760 = param_1;\n  }\n  return iVar1;\n}\n\n",
  "rl_vi_eWord": "\nundefined8 rl_vi_eWord(int param_1)\n\n{\n  size_t sVar1;\n  int iVar2;\n  int iVar3;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  do {\n    if (rl_end + -1 <= rl_point) {\n      return 0;\n    }\n    if (*(char *)(rl_line_buffer + rl_point) == ' ' || *(char *)(rl_line_buffer + rl_point) == '\\t')\n    {\nLAB_001d0c9e:\n      iVar2 = rl_point;\n      if (rl_point < rl_end) {\n        while ((*(char *)(rl_line_buffer + rl_point) == ' ' ||\n               (*(char *)(rl_line_buffer + rl_point) == '\\t'))) {\n          sVar1 = __ctype_get_mb_cur_max();\n          iVar3 = rl_point;\n          if ((sVar1 == 1) || (rl_byte_oriented != 0)) {\n            rl_point = rl_point + 1;\n          }\n          else {\n            rl_point = _rl_forward_char_internal(1);\n            iVar2 = rl_end;\n            if ((rl_point == iVar3) || (iVar2 = rl_end, rl_end < rl_point)) goto joined_r0x001d0d1d;\n          }\n          iVar2 = rl_point;\n          if (rl_end <= rl_point) goto joined_r0x001d0d1d;\n        }\n        iVar2 = rl_point;\n        if ((rl_point != 0) && (rl_point < rl_end)) break;\n      }\n    }\n    else {\n      iVar2 = rl_point;\n      if (rl_point < rl_end) {\n        sVar1 = __ctype_get_mb_cur_max();\n        iVar3 = rl_point;\n        if ((sVar1 == 1) || (rl_byte_oriented != 0)) {\n          rl_point = rl_point + 1;\n        }\n        else {\n          rl_point = _rl_forward_char_internal(1);\n          iVar2 = rl_end;\n          if ((rl_point == iVar3) || (iVar2 = rl_end, rl_end < rl_point)) goto joined_r0x001d0d1d;\n        }\n        goto LAB_001d0c9e;\n      }\n    }\njoined_r0x001d0d1d:\n    rl_point = iVar2;\n    param_1 = param_1 + -1;\n    if (param_1 == 0) {\n      return 0;\n    }\n  } while( true );\nLAB_001d0d77:\n  iVar3 = rl_point;\n  if ((*(char *)(rl_line_buffer + rl_point) != ' ') &&\n     (*(char *)(rl_line_buffer + rl_point) != '\\t')) {\n    if (rl_point < rl_end) goto LAB_001d0e0f;\n    goto joined_r0x001d0d1d;\n  }\n  sVar1 = __ctype_get_mb_cur_max();\n  iVar2 = rl_point;\n  if ((sVar1 == 1) || (rl_byte_oriented != 0)) {\n    rl_point = rl_point + 1;\n    iVar2 = iVar3;\n  }\n  else {\n    rl_point = _rl_forward_char_internal(1);\n    if ((rl_point == iVar2) || (rl_end < rl_point)) goto joined_r0x001d0d1d;\n  }\n  if (rl_end <= rl_point) goto joined_r0x001d0d1d;\n  goto LAB_001d0d77;\nLAB_001d0e0f:\n  iVar3 = rl_point;\n  if ((*(char *)(rl_line_buffer + rl_point) == ' ') ||\n     (*(char *)(rl_line_buffer + rl_point) == '\\t')) goto joined_r0x001d0d1d;\n  sVar1 = __ctype_get_mb_cur_max();\n  iVar2 = rl_point;\n  if ((sVar1 == 1) || (rl_byte_oriented != 0)) {\n    rl_point = rl_point + 1;\n  }\n  else {\n    rl_point = _rl_forward_char_internal(1);\n    if ((rl_point == iVar2) || (iVar3 = iVar2, rl_end < rl_point)) goto joined_r0x001d0d1d;\n  }\n  iVar2 = iVar3;\n  if (rl_end <= rl_point) goto joined_r0x001d0d1d;\n  goto LAB_001d0e0f;\n}\n\n",
  "FUN_00151320": "\nuint FUN_00151320(long param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = *(uint *)(param_1 + 0x28) & 0x20;\n  if (uVar1 != 0) {\n    uVar1 = (uint)(*(int *)(param_1 + 0x2c) == variable_context);\n  }\n  return uVar1;\n}\n\n",
  "sh_canonpath": "\nundefined2 * sh_canonpath(undefined2 *param_1,uint param_2)\n\n{\n  char cVar1;\n  undefined uVar2;\n  char cVar3;\n  int iVar4;\n  int *piVar5;\n  undefined2 *puVar6;\n  char *__dest;\n  undefined2 *__file;\n  size_t sVar7;\n  undefined2 *puVar8;\n  undefined2 *puVar9;\n  uint uVar10;\n  undefined2 *puVar11;\n  long lVar12;\n  undefined2 *puVar13;\n  undefined2 *puVar14;\n  long in_FS_OFFSET;\n  bool bVar15;\n  undefined local_e5;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar10 = param_2 & 8;\n  __file = param_1;\n  if (uVar10 == 0) {\n    sVar7 = strlen((char *)param_1);\n    __dest = (char *)sh_xmalloc(sVar7 + 1,\"pathcanon.c\",0x71);\n    __file = (undefined2 *)strcpy(__dest,(char *)param_1);\n  }\n  cVar1 = *(char *)param_1;\n  if (cVar1 == '/') {\n    bVar15 = false;\n    lVar12 = 1;\n    if (*(char *)((long)param_1 + 1) == '/') {\n      lVar12 = (ulong)(*(char *)(param_1 + 1) != '/') + 1;\n      bVar15 = *(char *)(param_1 + 1) != '/';\n    }\n    puVar14 = (undefined2 *)((long)__file + lVar12);\n    local_e5 = 0x2f;\n    cVar3 = *(char *)puVar14;\n    puVar13 = puVar14;\n    if (cVar3 != '\\0') goto LAB_001c64ce;\nLAB_001c6526:\n    puVar14 = puVar13;\n    if (__file != puVar13) goto LAB_001c652f;\n  }\n  else {\n    cVar3 = *(char *)__file;\n    local_e5 = 0x2e;\n    bVar15 = false;\n    puVar14 = __file;\n    puVar13 = __file;\n    if (cVar3 != '\\0') {\nLAB_001c64ce:\n      puVar8 = puVar14;\n      puVar11 = puVar14;\n      puVar13 = puVar14;\n      do {\n        if (cVar3 == '/') {\n          cVar3 = *(char *)((long)puVar8 + 1);\n          puVar9 = (undefined2 *)((long)puVar8 + 1);\n        }\n        else if (cVar3 == '.') {\n          cVar3 = *(char *)((long)puVar8 + 1);\n          if ((cVar3 == '/') || (cVar3 == '\\0')) {\n            puVar9 = (undefined2 *)((long)puVar8 + 1);\n          }\n          else {\n            if ((cVar3 != '.') || ((cVar3 = *(char *)(puVar8 + 1), cVar3 != '/' && (cVar3 != '\\0')))\n               ) goto LAB_001c64f0;\n            puVar9 = puVar8 + 1;\n            if (puVar13 <= puVar11) {\n              if (cVar1 != '/') {\n                puVar6 = puVar14;\n                if (puVar14 != puVar13) {\n                  *(undefined *)puVar13 = 0x2f;\n                  puVar6 = (undefined2 *)((long)puVar13 + 1);\n                }\n                puVar11 = puVar6 + 1;\n                *puVar6 = 0x2e2e;\n                cVar3 = *(char *)(puVar8 + 1);\n                puVar13 = puVar11;\n              }\n              goto LAB_001c6522;\n            }\n            if ((param_2 & 1) != 0) {\n              uVar2 = *(undefined *)puVar13;\n              *(undefined *)puVar13 = 0;\n              piVar5 = __errno_location();\n              *piVar5 = 0;\n              iVar4 = stat((char *)__file,&local_d8);\n              if ((iVar4 != 0) || ((local_d8.st_mode & 0xf000) != 0x4000)) {\n                if (uVar10 != 0) goto LAB_001c6638;\n                puVar14 = (undefined2 *)0x0;\n                sh_xfree(__file,\"pathcanon.c\",0xab);\n                goto LAB_001c6540;\n              }\n              *(undefined *)puVar13 = uVar2;\n              cVar3 = *(char *)(puVar8 + 1);\n            }\n            do {\n              puVar13 = (undefined2 *)((long)puVar13 + -1);\n              if (puVar13 == puVar11) break;\n            } while (*(char *)puVar13 != '/');\n          }\n        }\n        else {\nLAB_001c64f0:\n          puVar9 = puVar8;\n          if (puVar14 != puVar13) {\n            *(undefined *)puVar13 = 0x2f;\n            puVar13 = (undefined2 *)((long)puVar13 + 1);\n          }\n          for (; (cVar3 = *(char *)puVar9, cVar3 != '\\0' && (cVar3 != '/'));\n              puVar9 = (undefined2 *)((long)puVar9 + 1)) {\n            *(char *)puVar13 = cVar3;\n            puVar13 = (undefined2 *)((long)puVar13 + 1);\n          }\n          if ((param_2 & 2) != 0) {\n            uVar2 = *(undefined *)puVar13;\n            *(undefined *)puVar13 = 0;\n            piVar5 = __errno_location();\n            *piVar5 = 0;\n            iVar4 = stat((char *)__file,&local_d8);\n            if ((iVar4 != 0) || ((local_d8.st_mode & 0xf000) != 0x4000)) {\n              if (uVar10 == 0) {\n                sh_xfree(__file,\"pathcanon.c\",0xd1);\n              }\nLAB_001c6638:\n              puVar14 = (undefined2 *)0x0;\n              goto LAB_001c6540;\n            }\n            *(undefined *)puVar13 = uVar2;\n          }\n          cVar3 = *(char *)puVar9;\n        }\nLAB_001c6522:\n        puVar8 = puVar9;\n      } while (cVar3 != '\\0');\n      goto LAB_001c6526;\n    }\n  }\n  puVar14 = (undefined2 *)((long)puVar13 + 1);\n  *(undefined *)puVar13 = local_e5;\nLAB_001c652f:\n  *(undefined *)puVar14 = 0;\n  puVar14 = __file;\n  if ((((*(char *)__file == '/') && (*(char *)((long)__file + 1) == '/')) &&\n      (*(char *)(__file + 1) != '/')) && (!bVar15)) {\n    if (*(char *)(__file + 1) == '\\0') {\n      *(undefined *)((long)__file + 1) = 0;\n    }\n    else {\n      sVar7 = strlen((char *)((long)__file + 1));\n      memmove(__file,(char *)((long)__file + 1),sVar7 + 1);\n    }\n  }\nLAB_001c6540:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar14;\n}\n\n",
  "assoc_dequote": "\nlong * assoc_dequote(long *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long lVar3;\n  \n  if (param_1 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  if (*(int *)((long)param_1 + 0xc) == 0) {\n    return (long *)0x0;\n  }\n  lVar3 = 0;\n  if (0 < *(int *)(param_1 + 1)) {\n    do {\n      for (puVar1 = *(undefined8 **)(*param_1 + lVar3 * 8); puVar1 != (undefined8 *)0x0;\n          puVar1 = (undefined8 *)*puVar1) {\n        uVar2 = dequote_string(puVar1[2]);\n        if (puVar1[2] != 0) {\n          sh_xfree(puVar1[2],\"assoc.c\",0xce);\n        }\n        puVar1[2] = uVar2;\n      }\n      lVar3 = lVar3 + 1;\n    } while (*(int *)(param_1 + 1) != (int)lVar3 && (int)lVar3 <= *(int *)(param_1 + 1));\n  }\n  return param_1;\n}\n\n",
  "rl_deactivate_mark": "\nvoid rl_deactivate_mark(void)\n\n{\n  DAT_0024b688 = 0;\n  return;\n}\n\n",
  "builtin_help": "\nvoid builtin_help(void)\n\n{\n  int iVar1;\n  \n  current_builtin = builtin_address_internal(this_command_name,0);\n  if (current_builtin != 0) {\n    iVar1 = (int)(current_builtin - (long)shell_builtins >> 4) * -0x55555555;\n    __printf_chk(1,\"%s: %s\\n\",this_command_name,\n                 *(undefined8 *)(shell_builtins + (long)iVar1 * 0x30 + 0x20));\n    FUN_001aba30(iVar1);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00192280": "\nvoid FUN_00192280(void)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  \n  uVar5 = rl_menu_completion_entry_function;\n  uVar4 = rl_attempted_completion_function;\n  uVar3 = rl_ignore_some_completions_function;\n  uVar2 = rl_completion_suppress_append;\n  uVar1 = rl_sort_completion_matches;\n  rl_menu_completion_entry_function = FUN_00192370;\n  rl_attempted_completion_function = 0;\n  rl_ignore_some_completions_function = FUN_00191d90;\n  rl_filename_completion_desired = 0;\n  rl_completion_suppress_append = 1;\n  rl_sort_completion_matches = 0;\n  DAT_00248870 = 1;\n  if (rl_last_func == FUN_00192280) {\n    rl_last_func = rl_menu_complete;\n  }\n  rl_menu_complete();\n  rl_last_func = FUN_00192280;\n  rl_menu_completion_entry_function = (code *)uVar5;\n  rl_attempted_completion_function = uVar4;\n  rl_ignore_some_completions_function = (code *)uVar3;\n  rl_completion_suppress_append = uVar2;\n  rl_sort_completion_matches = uVar1;\n  DAT_00248870 = 0;\n  return;\n}\n\n",
  "FUN_0019b620": "\nchar * FUN_0019b620(char *param_1,char *param_2,uint param_3,uint *param_4)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  int local_e0;\n  uint local_dc;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  dot_found_in_search = 0;\n  if (param_4 != (uint *)0x0) {\n    *param_4 = 0;\n  }\n  iVar1 = absolute_program(param_1);\n  if (iVar1 == 0) {\n    if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\n      sVar2 = strlen(param_1);\n      pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"findcmd.c\",0x279);\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        pcVar3 = strcpy(pcVar3,param_1);\n        return pcVar3;\n      }\n    }\n    else {\n      DAT_002489e8 = (char *)0x0;\n      iVar1 = stat(\".\",&local_d8);\n      if (iVar1 < 0) {\n        local_d8.st_ino = 0;\n        local_d8.st_dev = 0;\n      }\n      local_e0 = 0;\n      if (*param_2 != '\\0') {\n        while( true ) {\n          if (terminating_signal != 0) {\n            termsig_handler(terminating_signal);\n          }\n          if (interrupt_state != 0) {\n            throw_to_top_level();\n          }\n          lVar4 = FUN_0019b1b0(param_2,&local_e0);\n          if (lVar4 == 0) break;\n          pcVar3 = (char *)FUN_0019b360(param_1,lVar4,param_3,&local_d8,&local_dc);\n          sh_xfree(lVar4,\"findcmd.c\",0x28d);\n          if (pcVar3 != (char *)0x0) {\n            if ((local_dc & 0x10) == 0) {\n              if (param_4 != (uint *)0x0) {\n                *param_4 = local_dc;\n              }\n              if (DAT_002489e8 != (char *)0x0) {\n                sh_xfree(DAT_002489e8,\"findcmd.c\",0x29b);\n              }\n              goto LAB_0019b7c8;\n            }\n            sh_xfree(pcVar3,\"findcmd.c\",0x293);\n          }\n          if (param_2[local_e0] == '\\0') break;\n        }\n      }\n      pcVar3 = DAT_002489e8;\n      if ((DAT_002489e8 != (char *)0x0) && ((param_3 & 0x20) != 0)) {\n        iVar1 = file_isdir(DAT_002489e8);\n        pcVar3 = DAT_002489e8;\n        if (iVar1 != 0) {\n          pcVar3 = (char *)0x0;\n          sh_xfree(DAT_002489e8,\"findcmd.c\",0x2a8);\n          DAT_002489e8 = (char *)0x0;\n        }\n      }\nLAB_0019b7c8:\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return pcVar3;\n      }\n    }\n  }\n  else if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    pcVar3 = (char *)FUN_0019b300(param_1,param_3);\n    return pcVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "describe_command": "\n/* WARNING: Type propagation algorithm not settling */\n\nulong describe_command(char *param_1,ulong param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  long lVar4;\n  char *pcVar5;\n  ulong uVar6;\n  char *pcVar7;\n  undefined8 uVar8;\n  ulong local_58;\n  \n  if ((param_2 & 0x20) == 0) {\n    if ((expand_aliases == 0) || (lVar4 = find_alias(), lVar4 == 0)) {\n      local_58 = 0;\n    }\n    else {\n      if ((param_2 & 8) == 0) {\n        if ((param_2 & 2) == 0) {\n          if ((param_2 & 4) != 0) {\n            uVar8 = sh_single_quote(*(undefined8 *)(lVar4 + 8));\n            __printf_chk(1,\"alias %s=%s\\n\",param_1,uVar8);\n            sh_xfree(uVar8,\"./type.def\",0xf0);\n          }\n        }\n        else {\n          __printf_chk(1,\"%s is aliased to `%s\\'\\n\",param_1,*(undefined8 *)(lVar4 + 8));\n        }\n      }\n      else {\n        puts(\"alias\");\n      }\n      local_58 = param_2 & 1;\n      if ((param_2 & 1) == 0) {\n        return 1;\n      }\n    }\n    iVar2 = find_reserved_word(param_1);\n    if (-1 < iVar2) {\n      if ((param_2 & 8) == 0) {\n        if ((param_2 & 2) == 0) {\n          if ((param_2 & 4) != 0) {\n            puts(param_1);\n          }\n        }\n        else {\n          __printf_chk(1,\"%s is a shell keyword\\n\",param_1);\n        }\n      }\n      else {\n        puts(\"keyword\");\n      }\n      if ((param_2 & 1) == 0) {\n        return 1;\n      }\n      local_58 = param_2 & 1;\n    }\n    if (((param_2 & 0x60) != 0) || (lVar4 = find_function(param_1), lVar4 == 0)) {\nLAB_001b4ac9:\n      lVar4 = find_shell_builtin(param_1);\n      if (lVar4 != 0) {\n        if ((param_2 & 8) == 0) {\n          if ((param_2 & 2) == 0) {\n            if ((param_2 & 4) != 0) {\n              puts(param_1);\n            }\n          }\n          else if ((posixly_correct == 0) || (lVar4 = find_special_builtin(param_1), lVar4 == 0)) {\n            __printf_chk(1,\"%s is a shell builtin\\n\",param_1);\n          }\n          else {\n            __printf_chk(1,\"%s is a special shell builtin\\n\",param_1);\n          }\n        }\n        else {\n          puts(\"builtin\");\n        }\n        if ((param_2 & 1) == 0) {\n          return 1;\n        }\n        iVar2 = absolute_program(param_1);\n        if ((iVar2 != 0) && (uVar6 = file_status(param_1), (uVar6 & 2) != 0)) goto LAB_001b4f67;\n        local_58 = param_2 & 1;\n        goto LAB_001b4be7;\n      }\n      goto LAB_001b4b45;\n    }\nLAB_001b4eb9:\n    if ((param_2 & 8) == 0) {\n      if ((param_2 & 2) == 0) {\n        if ((param_2 & 4) != 0) {\n          puts(param_1);\n        }\n      }\n      else {\n        __printf_chk(1,\"%s is a function\\n\",param_1);\n        pcVar5 = (char *)named_function_string(param_1,*(undefined8 *)(lVar4 + 8),3);\n        puts(pcVar5);\n      }\n    }\n    else {\n      puts(\"function\");\n    }\n    if ((param_2 & 1) == 0) {\n      return 1;\n    }\n    if ((param_2 & 0x20) == 0) {\n      local_58 = param_2 & 1;\n      goto LAB_001b4ac9;\n    }\n    iVar2 = absolute_program(param_1);\n    local_58 = param_2 & 1;\n    if (iVar2 != 0) goto LAB_001b4f50;\nLAB_001b4b59:\n    if ((param_2 & 0x20) == 0) goto LAB_001b4be7;\n  }\n  else {\n    local_58 = param_2 & 0x60;\n    if ((param_2 & 0x60) == 0) {\n      lVar4 = find_function();\n      if (lVar4 != 0) goto LAB_001b4eb9;\n    }\n    else {\n      local_58 = 0;\n    }\nLAB_001b4b45:\n    iVar2 = absolute_program(param_1);\n    if (iVar2 != 0) {\nLAB_001b4f50:\n      uVar6 = file_status(param_1);\n      if ((uVar6 & 2) != 0) {\nLAB_001b4f67:\n        if ((param_2 & 8) == 0) {\n          if ((param_2 & 2) != 0) {\n            __printf_chk(1,\"%s is %s\\n\",param_1,param_1);\n            return 1;\n          }\n          if ((param_2 & 0x14) != 0) {\n            puts(param_1);\n            return 1;\n          }\n        }\n        else {\n          puts(\"file\");\n        }\n        return 1;\n      }\n    }\n    if ((param_2 & 1) != 0) goto LAB_001b4b59;\n  }\n  pcVar5 = (char *)phash_search(param_1);\n  if (pcVar5 != (char *)0x0) {\n    if ((param_2 & 8) == 0) {\n      if ((param_2 & 2) == 0) {\n        if ((param_2 & 0x14) != 0) {\n          puts(pcVar5);\n        }\n      }\n      else {\n        __printf_chk(1,\"%s is hashed (%s)\\n\",param_1,pcVar5);\n      }\n    }\n    else {\n      puts(\"file\");\n    }\n    sh_xfree(pcVar5,\"./type.def\",0x15b);\n    return 1;\n  }\nLAB_001b4be7:\n  iVar2 = 0;\n  do {\n    if ((param_2 & 0x100) == 0) {\n      if ((param_2 & 1) == 0) {\n        pcVar5 = (char *)find_user_command(param_1);\n      }\n      else {\n        pcVar5 = (char *)user_command_matches(param_1,8,iVar2);\n      }\n    }\n    else {\n      uVar8 = conf_standard_path();\n      pcVar5 = (char *)find_in_path(param_1,uVar8,0x24);\n      sh_xfree(uVar8,\"./type.def\",0x167);\n    }\n    if (pcVar5 == (char *)0x0) {\n      return local_58;\n    }\n    cVar1 = *pcVar5;\n    pcVar7 = pcVar5;\n    if ((cVar1 == *param_1) && (iVar3 = strcmp(pcVar5,param_1), iVar3 == 0)) {\n      uVar6 = file_status(pcVar5);\njoined_r0x001b4ce0:\n      if ((uVar6 & 2) == 0) {\n        sh_xfree(pcVar5,\"./type.def\",0x17b);\n        if ((param_2 & 1) == 0) {\n          return local_58;\n        }\n        pcVar7 = (char *)0x0;\n        goto LAB_001b4c58;\n      }\n      if ((*pcVar5 == '/') || ((param_2 & 0x16) == 0)) goto LAB_001b4c58;\n      pcVar7 = (char *)sh_makepath(0,pcVar5,(int)(param_2 & 0xffffffff) >> 5 & 4U | 2);\n      sh_xfree(pcVar5,\"./type.def\",0x186);\n      if ((param_2 & 8) != 0) goto LAB_001b4d30;\nLAB_001b4c65:\n      if ((param_2 & 2) == 0) {\n        if ((param_2 & 0x14) != 0) {\n          puts(pcVar7);\n        }\n      }\n      else {\n        __printf_chk(1,\"%s is %s\\n\",param_1,pcVar7);\n      }\n    }\n    else {\n      if (posixly_correct != 0) {\n        uVar6 = file_status(pcVar5);\n        goto joined_r0x001b4ce0;\n      }\n      if ((((param_2 & 0xffffffff) >> 7 & 1) != 0) && (cVar1 != '/')) {\n        pcVar7 = (char *)sh_makepath(0,pcVar5,6);\n        sh_xfree(pcVar5,\"./type.def\",0x18e);\n      }\nLAB_001b4c58:\n      if ((param_2 & 8) == 0) goto LAB_001b4c65;\nLAB_001b4d30:\n      puts(\"file\");\n    }\n    iVar2 = iVar2 + 1;\n    sh_xfree(pcVar7,\"./type.def\",0x19c);\n    if ((param_2 & 1) == 0) {\n      return 1;\n    }\n    local_58 = param_2 & 1;\n  } while( true );\n}\n\n",
  "_rl_restore_tty_signals": "\nint _rl_restore_tty_signals(void)\n\n{\n  int __fd;\n  int iVar1;\n  int *piVar2;\n  \n  if (DAT_0024a4a0 == 0) {\n    return DAT_0024a4a0;\n  }\n  __fd = fileno(rl_instream);\n  while( true ) {\n    iVar1 = tcsetattr(__fd,1,(termios *)&DAT_0024a500);\n    if (-1 < iVar1) {\n      DAT_0024a4a0 = 0;\n      return 0;\n    }\n    piVar2 = __errno_location();\n    if (*piVar2 != 4) break;\n    *piVar2 = 0;\n  }\n  return -1;\n}\n\n",
  "xparse_dolparen": "\nundefined * xparse_dolparen(long param_1,char *param_2,int *param_3,ulong param_4)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined *puVar3;\n  char *pcVar4;\n  uint uVar5;\n  int iVar6;\n  long in_FS_OFFSET;\n  char *local_180;\n  undefined local_178 [48];\n  undefined local_148 [264];\n  long local_40;\n  \n  uVar1 = line_number;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*param_2 == '\\0') {\n    if ((param_4 & 1) == 0) {\n      puVar3 = (undefined *)sh_xmalloc(1,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1095);\n      *puVar3 = 0;\n      goto LAB_00140bc9;\n    }\n  }\n  else {\n    save_parser_state(local_148);\n    save_input_line_state(local_178);\n    pushed_string_list = 0;\n    shell_eof_token = 0x29;\n    expand_aliases = 0;\n    uVar5 = parser_state | 0x8040;\n    DAT_00240b58 = 0x130;\n    parser_state = parser_state | 0x808040;\n    if ((param_4 & 0x400) == 0) {\n      parser_state = uVar5;\n    }\n    DAT_00240d64 = extended_glob;\n    iVar2 = parse_string(param_2,\"command substitution\",\n                         (-(uint)((param_4 & 0x40) == 0) & 0xffffffc0) + 0x4d,0,&local_180);\n    if (current_token == shell_eof_token) {\n      yychar = 0xfffffffe;\n    }\n    reset_parser();\n    restore_input_line_state(local_178);\n    restore_parser_state(local_148);\n    DAT_00240b58 = 0;\n    if (iVar2 < 0) {\n      if (DAT_00240da8 != (undefined *)0x0) {\n        DAT_00240da0 = 0;\n        *DAT_00240da8 = 0;\n      }\n      if (bash_input != 3) {\n        parser_state = parser_state & 0xffff7fbf;\n      }\n      if ((param_4 & 0x40) == 0) {\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level(-iVar2);\n      }\n      if (local_180[-1] != ')') goto LAB_00140cf0;\n      iVar2 = (int)local_180 - (int)param_2;\n      *param_3 = ((int)local_180 - (int)param_1) + -1;\n    }\n    else {\n      if (local_180[-1] != ')') {\nLAB_00140cf0:\n        if (param_2 < local_180) {\n          do {\n            pcVar4 = local_180 + -1;\n            if (*pcVar4 != '\\n') break;\n            local_180 = pcVar4;\n          } while (param_2 != pcVar4);\n        }\n      }\n      iVar6 = ((int)local_180 - (int)param_1) + -1;\n      iVar2 = (int)local_180 - (int)param_2;\n      *param_3 = iVar6;\n      if ((*(char *)(param_1 + iVar6) != ')') && ((param_4 & 0x40) == 0)) {\n        if ((param_4 & 0x1000) == 0) {\n          parser_error(uVar1,\"unexpected EOF while looking for matching `%c\\'\",0x29);\n        }\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level(2);\n      }\n    }\n    if ((param_4 & 1) == 0) {\n      if (iVar2 == 0) {\n        puVar3 = (undefined *)sh_xmalloc(1,\"/usr/local/src/chet/src/bash/src/parse.y\",0x10fa);\n        *puVar3 = 0;\n      }\n      else {\n        puVar3 = (undefined *)substring(param_2,0,iVar2 + -1);\n      }\n      goto LAB_00140bc9;\n    }\n  }\n  puVar3 = (undefined *)0x0;\nLAB_00140bc9:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar3;\n}\n\n",
  "kill_all_local_variables": "\nvoid kill_all_local_variables(void)\n\n{\n  long *plVar1;\n  long lVar2;\n  \n  lVar2 = shell_variables;\n  if (shell_variables != 0) {\n    do {\n      if (((*(uint *)(lVar2 + 0xc) & 4) != 0) && (*(int *)(lVar2 + 8) == variable_context)) {\n        if ((*(long *)(lVar2 + 0x20) == 0) || ((*(uint *)(lVar2 + 0xc) & 1) == 0)) {\n          *(undefined8 *)(lVar2 + 0x20) = 0;\n        }\n        else {\n          hash_flush(*(long *)(lVar2 + 0x20),dispose_variable);\n          hash_dispose(*(undefined8 *)(lVar2 + 0x20));\n          *(undefined8 *)(lVar2 + 0x20) = 0;\n        }\n        return;\n      }\n      plVar1 = (long *)(lVar2 + 0x18);\n      lVar2 = *plVar1;\n    } while (*plVar1 != 0);\n  }\n  return;\n}\n\n",
  "FUN_00160a10": "\nvoid FUN_00160a10(void)\n\n{\n  uint uVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  uint uVar4;\n  \n  puVar3 = procsubs;\n  DAT_00242518 = 0;\n  procsubs = (undefined8 *)0x0;\n  DAT_00242520 = 0;\n  if (puVar3 != (undefined8 *)0x0) {\n    do {\n      while( true ) {\n        puVar2 = (undefined8 *)*puVar3;\n        *puVar3 = 0;\n        if (*(int *)(puVar3 + 2) == 0) break;\n        procsub_add(puVar3);\n        puVar3 = puVar2;\n        if (puVar2 == (undefined8 *)0x0) {\n          return;\n        }\n      }\n      uVar1 = *(uint *)((long)puVar3 + 0xc);\n      if ((char)(((byte)uVar1 & 0x7f) + 1) < '\\x02') {\n        uVar4 = 0;\n        if ((byte)uVar1 != 0x7f) {\n          uVar4 = uVar1 >> 8 & 0xff;\n        }\n      }\n      else {\n        uVar4 = (uVar1 & 0x7f) + 0x80;\n      }\n      FUN_0015ed20(*(undefined4 *)(puVar3 + 1),uVar4);\n      if (puVar3[3] != 0) {\n        sh_xfree(puVar3[3],\"jobs.c\",0x3ea);\n      }\n      sh_xfree(puVar3,\"jobs.c\",0x3eb);\n      puVar3 = puVar2;\n    } while (puVar2 != (undefined8 *)0x0);\n  }\n  return;\n}\n\n",
  "source_builtin": "\nundefined4 source_builtin(void)\n\n{\n  char **ppcVar1;\n  long *plVar2;\n  int iVar3;\n  undefined4 uVar4;\n  char *pcVar5;\n  size_t sVar6;\n  char *pcVar7;\n  long lVar8;\n  char *__dest;\n  undefined8 uVar9;\n  \n  iVar3 = no_options();\n  plVar2 = loptend;\n  if (iVar3 != 0) {\n    return 0x102;\n  }\n  if (loptend == (long *)0x0) {\n    builtin_error(\"filename argument required\");\n    builtin_usage();\n    return 0x102;\n  }\n  pcVar7 = *(char **)loptend[1];\n  if (restricted == 0) {\n    if ((posixly_correct != 0) && (pcVar5 = strchr(pcVar7,0x2f), pcVar5 != (char *)0x0)) {\n      sVar6 = strlen(pcVar7);\n      pcVar5 = (char *)sh_xmalloc(sVar6 + 1,\"./source.def\",0x90);\n      pcVar7 = strcpy(pcVar5,pcVar7);\n      goto LAB_001b3f03;\n    }\n  }\n  else {\n    pcVar5 = strchr(pcVar7,0x2f);\n    if (pcVar5 != (char *)0x0) {\n      sh_restricted(pcVar7);\n      return 1;\n    }\n  }\n  iVar3 = absolute_pathname(pcVar7);\n  ppcVar1 = (char **)plVar2[1];\n  if (iVar3 == 0) {\n    if (source_uses_path == 0) {\n      pcVar7 = *ppcVar1;\n    }\n    else {\n      pcVar7 = (char *)find_path_file(*ppcVar1);\n      if (pcVar7 != (char *)0x0) goto LAB_001b3f03;\n      pcVar7 = *(char **)plVar2[1];\n    }\n    if (source_searches_cwd == 0) {\n      lVar8 = printable_filename(pcVar7,0);\n      builtin_error(\"%s: file not found\",lVar8);\n      if (*(long *)plVar2[1] != lVar8) {\n        sh_xfree(lVar8,\"./source.def\",0x9c);\n      }\n      if ((posixly_correct != 0) && ((interactive_shell | executing_command_builtin) == 0)) {\n        last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level(3);\n      }\n      return 1;\n    }\n    sVar6 = strlen(pcVar7);\n    uVar9 = 0xa5;\n  }\n  else {\n    pcVar7 = *ppcVar1;\n    sVar6 = strlen(pcVar7);\n    uVar9 = 0x92;\n  }\n  pcVar5 = (char *)sh_xmalloc(sVar6 + 1,\"./source.def\",uVar9);\n  pcVar7 = strcpy(pcVar5,pcVar7);\nLAB_001b3f03:\n  begin_unwind_frame(\"source\");\n  add_unwind_protect(xfree,pcVar7);\n  if (*plVar2 != 0) {\n    push_dollar_vars();\n    add_unwind_protect(FUN_001b3e10,0);\n    if ((debugging_mode != 0) || (shell_compatibility_level < 0x2d)) {\n      init_bash_argv();\n    }\n    remember_args(*plVar2,1);\n    if (debugging_mode != 0) {\n      push_args(*plVar2);\n    }\n  }\n  set_dollar_vars_unchanged();\n  iVar3 = signal_is_trapped(0x41);\n  if ((((iVar3 != 0) && (iVar3 = signal_is_ignored(0x41), pcVar5 = DAT_00247c08, iVar3 == 0)) &&\n      (DAT_00247c08 != (char *)0x0)) && (function_trace_mode == 0)) {\n    sVar6 = strlen(DAT_00247c08);\n    __dest = (char *)sh_xmalloc(sVar6 + 1,\"./source.def\",0xbd);\n    pcVar5 = strcpy(__dest,pcVar5);\n    add_unwind_protect(xfree,pcVar5);\n    add_unwind_protect(maybe_set_debug_trap,pcVar5);\n    restore_default_signal(0x41);\n  }\n  uVar4 = source_file(pcVar7,*plVar2 != 0);\n  run_unwind_frame(\"source\");\n  return uVar4;\n}\n\n",
  "make_here_document": "\nvoid make_here_document(long param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  size_t sVar6;\n  char *pcVar7;\n  char *pcVar8;\n  size_t sVar9;\n  undefined *puVar10;\n  long lVar11;\n  long lVar12;\n  int iVar13;\n  char cVar14;\n  int iVar15;\n  bool bVar16;\n  char *local_68;\n  \n  iVar1 = *(int *)(param_1 + 0x18);\n  if ((iVar1 - 4U & 0xfffffffb) != 0) {\n    internal_error(\"make_here_document: bad instruction type %d\",iVar1);\n    return;\n  }\n  bVar16 = (*(byte *)(*(char ***)(param_1 + 0x20) + 1) & 2) == 0;\n  pcVar8 = **(char ***)(param_1 + 0x20);\n  if (bVar16) {\n    sVar6 = strlen(pcVar8);\n    pcVar7 = (char *)sh_xmalloc(sVar6 + 1,\"make_cmd.c\",0x24b);\n    local_68 = strcpy(pcVar7,pcVar8);\nLAB_00143c40:\n    lVar12 = 0;\n    sVar6 = strlen(local_68);\n    iVar4 = (int)sVar6;\n    sh_xfree(**(undefined8 **)(param_1 + 0x20),\"make_cmd.c\",0x259);\n    sVar6 = (size_t)iVar4;\n    *(char **)(param_1 + 0x28) = local_68;\n    lVar11 = 0;\n    puVar10 = (undefined *)0x0;\nLAB_00143c88:\n    pcVar8 = (char *)read_secondary_line(bVar16);\n    if (pcVar8 != (char *)0x0) {\n      do {\n        line_number = line_number + 1;\n        here_doc_first_line = 0;\n        if (echo_input_at_read != 0) {\n          fputs(pcVar8,stderr);\n        }\n        cVar14 = *pcVar8;\n        if (iVar1 == 8) {\n          if (cVar14 == '\\0') goto LAB_00143c88;\n          if (((iVar4 == 0) ||\n              ((*local_68 == cVar14 && (iVar5 = strncmp(pcVar8,local_68,sVar6), iVar5 == 0)))) &&\n             (pcVar8[sVar6] == '\\n')) goto LAB_00143d71;\n          if (cVar14 == '\\t') {\n            do {\n              cVar14 = pcVar8[1];\n              pcVar8 = pcVar8 + 1;\n            } while (cVar14 == '\\t');\n            goto LAB_00143cca;\n          }\n        }\n        else {\nLAB_00143cca:\n          if (cVar14 == '\\0') goto LAB_00143c88;\n        }\n        if (iVar4 == 0) {\n          if (*pcVar8 == '\\n') goto LAB_00143d71;\nLAB_00143e7a:\n          if (((parser_state._1_1_ & 0x80) != 0) && (shell_eof_token != 0)) {\n            pcVar7 = strchr(pcVar8 + sVar6,shell_eof_token);\n            if (pcVar7 != (char *)0x0) {\n              shell_ungets(pcVar8 + sVar6);\n              break;\n            }\n          }\n        }\n        else if ((*local_68 == cVar14) && (iVar5 = strncmp(pcVar8,local_68,sVar6), iVar5 == 0)) {\n          if (pcVar8[sVar6] != '\\n') goto LAB_00143e7a;\n          goto LAB_00143d71;\n        }\n        sVar9 = strlen(pcVar8);\n        iVar5 = (int)lVar11;\n        iVar2 = (int)sVar9;\n        iVar15 = iVar5 + iVar2;\n        iVar13 = (int)lVar12;\n        if (iVar13 <= iVar15) {\n          iVar3 = (iVar13 + iVar2) * 2;\n          if (iVar13 == 0) {\n            iVar3 = iVar2 + 2;\n          }\n          lVar12 = (long)iVar3;\n          puVar10 = (undefined *)sh_xrealloc(puVar10,lVar12,\"make_cmd.c\",0x292);\n        }\n        lVar11 = (long)iVar15;\n        memcpy(puVar10 + iVar5,pcVar8,(long)iVar2);\n        pcVar8 = (char *)read_secondary_line(bVar16);\n        if (pcVar8 == (char *)0x0) break;\n      } while( true );\n    }\n    internal_warning(\"here-document at line %d delimited by end-of-file (wanted `%s\\')\",param_2,\n                     local_68);\nLAB_00143d71:\n    if (puVar10 != (undefined *)0x0) {\n      puVar10[lVar11] = 0;\n      goto LAB_00143d7b;\n    }\n  }\n  else {\n    local_68 = (char *)string_quote_removal(pcVar8,0);\n    if (local_68 != (char *)0x0) goto LAB_00143c40;\n    puVar10 = (undefined *)sh_xmalloc(1,\"make_cmd.c\",0x254);\n    *(undefined **)(param_1 + 0x28) = puVar10;\n    *puVar10 = 0;\n  }\n  puVar10 = (undefined *)sh_xmalloc(1,\"make_cmd.c\",0x2a3);\n  *puVar10 = 0;\nLAB_00143d7b:\n  **(undefined8 **)(param_1 + 0x20) = puVar10;\n  here_doc_first_line = 0;\n  return;\n}\n\n",
  "word_list_remove_quoted_nulls": "\nvoid word_list_remove_quoted_nulls(long *param_1)\n\n{\n  long *plVar1;\n  \n  if (param_1 == (long *)0x0) {\n    return;\n  }\n  do {\n    remove_quoted_nulls(*(undefined8 *)param_1[1]);\n    plVar1 = param_1 + 1;\n    param_1 = (long *)*param_1;\n    *(uint *)(*plVar1 + 8) = *(uint *)(*plVar1 + 8) & 0xfffbffff;\n  } while (param_1 != (long *)0x0);\n  return;\n}\n\n",
  "free_mail_files": "\nvoid free_mail_files(void)\n\n{\n  undefined8 *puVar1;\n  long lVar2;\n  \n  if (0 < DAT_002478b0) {\n    lVar2 = 0;\n    do {\n      puVar1 = *(undefined8 **)(DAT_002478b8 + lVar2 * 8);\n      sh_xfree(*puVar1,\"mailcheck.c\",0xe4);\n      if (puVar1[1] != 0) {\n        sh_xfree(puVar1[1],\"mailcheck.c\",0xe5);\n      }\n      lVar2 = lVar2 + 1;\n      sh_xfree(puVar1,\"mailcheck.c\",0xe6);\n    } while ((int)lVar2 < DAT_002478b0);\n  }\n  if (DAT_002478b8 != 0) {\n    sh_xfree(DAT_002478b8,\"mailcheck.c\",0xf3);\n  }\n  DAT_002478b0 = 0;\n  DAT_002478b8 = 0;\n  return;\n}\n\n",
  "rl_vi_insert_mode": "\nundefined8 rl_vi_insert_mode(undefined8 param_1,undefined4 param_2)\n\n{\n  DAT_0023b36c = 1;\n  DAT_0023b368 = rl_arg_sign;\n  _rl_vi_last_command = param_2;\n  rl_begin_undo_group();\n  DAT_0024a3c8 = param_2;\n  _rl_keymap = &vi_insertion_keymap;\n  if (_rl_show_mode_in_prompt == 0) {\n    return 0;\n  }\n  _rl_reset_prompt();\n  return 0;\n}\n\n",
  "iconv_close": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iconv_close(iconv_t __cd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iconv_close_00237cd0)();\n  return iVar1;\n}\n\n",
  "FUN_001dc4f0": "\nchar * FUN_001dc4f0(char *param_1)\n\n{\n  int iVar1;\n  char *pcVar2;\n  long *plVar3;\n  undefined4 uVar4;\n  \n  iVar1 = strcasecmp(param_1,\"comment-begin\");\n  if (iVar1 == 0) {\n    if (_rl_comment_begin != (char *)0x0) {\n      return _rl_comment_begin;\n    }\n    return \"#\";\n  }\n  iVar1 = strcasecmp(param_1,\"completion-display-width\");\n  uVar4 = _rl_completion_columns;\n  if (((iVar1 == 0) ||\n      (iVar1 = strcasecmp(param_1,\"completion-prefix-display-length\"),\n      uVar4 = _rl_completion_prefix_display_length, iVar1 == 0)) ||\n     (iVar1 = strcasecmp(param_1,\"completion-query-items\"), uVar4 = rl_completion_query_items,\n     iVar1 == 0)) {\nLAB_001dc61f:\n    __sprintf_chk(&DAT_0024a760,1,0x20,\"%d\",uVar4);\n    return &DAT_0024a760;\n  }\n  iVar1 = strcasecmp(param_1,\"editing-mode\");\n  if (iVar1 != 0) {\n    iVar1 = strcasecmp(param_1,\"history-size\");\n    if (iVar1 == 0) {\n      iVar1 = history_is_stifled();\n      if (iVar1 != 0) {\n        iVar1 = history_max_entries;\n      }\n      __sprintf_chk(&DAT_0024a760,1,0x20,\"%d\",iVar1);\n      return &DAT_0024a760;\n    }\n    iVar1 = strcasecmp(param_1,\"isearch-terminators\");\n    if (iVar1 == 0) {\n      if (_rl_isearch_terminators == 0) {\n        return (char *)0x0;\n      }\n      pcVar2 = (char *)_rl_untranslate_macro_value(_rl_isearch_terminators,0);\n      if (pcVar2 != (char *)0x0) {\n        strncpy(&DAT_0024a760,pcVar2,0x1f);\n        xfree(pcVar2);\n        DAT_0024a77f = 0;\n        return &DAT_0024a760;\n      }\n      DAT_0024a760 = 0;\n      return &DAT_0024a760;\n    }\n    iVar1 = strcasecmp(param_1,\"keymap\");\n    if (iVar1 != 0) {\n      iVar1 = strcasecmp(param_1,\"keyseq-timeout\");\n      uVar4 = _rl_keyseq_timeout;\n      if (iVar1 != 0) {\n        iVar1 = strcasecmp(param_1,\"emacs-mode-string\");\n        if (iVar1 == 0) {\n          if (_rl_emacs_mode_str != (char *)0x0) {\n            return _rl_emacs_mode_str;\n          }\n          return \"@\";\n        }\n        iVar1 = strcasecmp(param_1,\"vi-cmd-mode-string\");\n        if (iVar1 == 0) {\n          if (_rl_vi_cmd_mode_str != (char *)0x0) {\n            return _rl_vi_cmd_mode_str;\n          }\n          return \"(cmd)\";\n        }\n        iVar1 = strcasecmp(param_1,\"vi-ins-mode-string\");\n        if (iVar1 != 0) {\n          return (char *)0x0;\n        }\n        if (_rl_vi_ins_mode_str != (char *)0x0) {\n          return _rl_vi_ins_mode_str;\n        }\n        return \"(ins)\";\n      }\n      goto LAB_001dc61f;\n    }\n    if (*(long *)PTR_PTR_s_emacs_00240468 != 0) {\n      iVar1 = 0;\n      plVar3 = (long *)PTR_PTR_s_emacs_00240468;\n      do {\n        if (_rl_keymap == (undefined *)plVar3[1]) {\n          if (*(char **)(PTR_PTR_s_emacs_00240468 + (long)iVar1 * 0x10) != (char *)0x0) {\n            return *(char **)(PTR_PTR_s_emacs_00240468 + (long)iVar1 * 0x10);\n          }\n          break;\n        }\n        plVar3 = plVar3 + 2;\n        iVar1 = iVar1 + 1;\n      } while (*plVar3 != 0);\n    }\n  }\n  pcVar2 = \"emacs\";\n  if ((rl_editing_mode != 1) && (pcVar2 = \"none\", rl_editing_mode == 0)) {\n    pcVar2 = \"vi\";\n  }\n  return pcVar2;\n}\n\n",
  "termsig_handler": "\nvoid termsig_handler(void)\n\n{\n  if (DAT_00248538 == 0) {\n    FUN_00185df0();\n  }\n  return;\n}\n\n",
  "bash_history_disable": "\nvoid bash_history_disable(void)\n\n{\n  remember_on_history = 0;\n  history_expansion_inhibited = 1;\n  return;\n}\n\n",
  "FUN_001916e0": "\nint FUN_001916e0(char *param_1)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char **ppcVar3;\n  char *__s1;\n  \n  sVar2 = strlen(param_1);\n  __s1 = *DAT_00238d68;\n  if (__s1 != (char *)0x0) {\n    ppcVar3 = DAT_00238d68;\n    do {\n      iVar1 = *(int *)(ppcVar3 + 1);\n      if (((iVar1 < (int)sVar2) && (0 < iVar1)) && (*__s1 == param_1[(int)sVar2 - iVar1])) {\n        iVar1 = strcmp(__s1,param_1 + ((int)sVar2 - iVar1));\n        if (iVar1 == 0) {\n          return iVar1;\n        }\n      }\n      __s1 = ppcVar3[2];\n      ppcVar3 = ppcVar3 + 2;\n    } while (__s1 != (char *)0x0);\n  }\n  return 1;\n}\n\n",
  "iconv_open": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\niconv_t iconv_open(char *__tocode,char *__fromcode)\n\n{\n  iconv_t pvVar1;\n  \n  pvVar1 = (iconv_t)(*(code *)PTR_iconv_open_00237ec0)();\n  return pvVar1;\n}\n\n",
  "_rl_init_locale": "\nchar * _rl_init_locale(void)\n\n{\n  int iVar1;\n  char *pcVar2;\n  size_t sVar3;\n  char *pcVar4;\n  \n  pcVar2 = (char *)sh_get_env_value();\n  if ((((pcVar2 == (char *)0x0) || (*pcVar2 == '\\0')) &&\n      ((pcVar2 = (char *)sh_get_env_value(), pcVar2 == (char *)0x0 || (*pcVar2 == '\\0')))) &&\n     (((pcVar2 = (char *)sh_get_env_value(), pcVar2 == (char *)0x0 || (*pcVar2 == '\\0')) &&\n      (pcVar2 = setlocale(0,(char *)0x0), pcVar2 == (char *)0x0)))) {\n    pcVar2 = \"\";\n  }\n  pcVar2 = setlocale(0,pcVar2);\n  if ((pcVar2 != (char *)0x0) && (*pcVar2 != '\\0')) {\n    pcVar4 = nl_langinfo(0xe);\n    if (*pcVar4 == 'U') {\n      iVar1 = strcmp(pcVar4,\"UTF-8\");\n      _rl_utf8locale = (uint)(iVar1 == 0);\n      goto LAB_001f0459;\n    }\n    if (*pcVar4 == 'u') {\n      iVar1 = strcmp(pcVar4,\"utf8\");\n      _rl_utf8locale = 1;\n      if (iVar1 == 0) goto LAB_001f0459;\n    }\n  }\n  _rl_utf8locale = 0;\nLAB_001f0459:\n  sVar3 = strlen(pcVar2);\n  pcVar4 = (char *)xmalloc(sVar3 + 1);\n  DAT_0024b6b0 = strcpy(pcVar4,pcVar2);\n  return pcVar2;\n}\n\n",
  "unstifle_history": "\nint unstifle_history(void)\n\n{\n  if (DAT_0024b6e4 != 0) {\n    DAT_0024b6e4 = 0;\n    return history_max_entries;\n  }\n  return -history_max_entries;\n}\n\n",
  "rl_make_bare_keymap": "\nvoid rl_make_bare_keymap(void)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  \n  puVar1 = (undefined *)xmalloc(0x1010);\n  puVar2 = puVar1;\n  do {\n    *puVar2 = 0;\n    puVar3 = puVar2 + 0x10;\n    *(undefined8 *)(puVar2 + 8) = 0;\n    puVar2 = puVar3;\n  } while (puVar3 != puVar1 + 0x1010);\n  return;\n}\n\n",
  "FUN_001da820": "\nundefined8 FUN_001da820(void)\n\n{\n  if (DAT_0024a794 != 0) {\n    DAT_0024a794 = DAT_0024a794 + -1;\n    _rl_parsing_conditionalized_out = *(undefined *)(DAT_0024a798 + DAT_0024a794);\n    return 0;\n  }\n  FUN_001da6e0(\"$endif without matching $if\");\n  return 0;\n}\n\n",
  "set_shellopts": "\nvoid set_shellopts(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  int *piVar4;\n  undefined *puVar5;\n  size_t sVar6;\n  undefined *puVar7;\n  long lVar8;\n  int **ppiVar9;\n  char **ppcVar10;\n  char *pcVar11;\n  char *pcVar12;\n  char *pcVar13;\n  int iVar14;\n  long in_FS_OFFSET;\n  char local_68 [40];\n  long local_40;\n  \n  iVar14 = 0x61;\n  iVar3 = 0;\n  pcVar13 = \"allexport\";\n  pcVar11 = local_68;\n  pcVar12 = local_68;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  ppiVar9 = (int **)&DAT_00235fd0;\n  do {\n    *pcVar11 = 0;\n    if (iVar14 == 0) {\n      if (ppiVar9[2] == (int *)0x0) {\n        piVar4 = *ppiVar9;\n        goto LAB_001b20b9;\n      }\n      iVar14 = (*(code *)ppiVar9[2])(pcVar13);\n      if (iVar14 == 0) goto LAB_001b2093;\nLAB_001b2082:\n      sVar6 = strlen(pcVar13);\n      *pcVar11 = 1;\n      iVar3 = iVar3 + 1 + (int)sVar6;\n    }\n    else {\n      piVar4 = (int *)find_flag();\n      if (piVar4 != (int *)0x0) {\nLAB_001b20b9:\n        if (*piVar4 != 0) goto LAB_001b2082;\n      }\n    }\nLAB_001b2093:\n    pcVar13 = (char *)ppiVar9[3];\n    pcVar11 = pcVar11 + 1;\n    if ((int *)pcVar13 == (int *)0x0) break;\n    iVar14 = *(int *)(ppiVar9 + 4);\n    ppiVar9 = ppiVar9 + 5;\n  } while( true );\n  iVar14 = 0;\n  puVar5 = (undefined *)sh_xmalloc((long)(iVar3 + 1),\"./set.def\",0x239);\n  pcVar13 = \"allexport\";\n  ppcVar10 = &PTR_s_braceexpand_00235fe8;\n  do {\n    while (*pcVar12 == '\\0') {\n      pcVar13 = *ppcVar10;\n      pcVar12 = pcVar12 + 1;\n      ppcVar10 = ppcVar10 + 5;\n      if (pcVar13 == (char *)0x0) goto LAB_001b2154;\n    }\n    pcVar12 = pcVar12 + 1;\n    strcpy(puVar5 + iVar14,pcVar13);\n    sVar6 = strlen(pcVar13);\n    iVar3 = (int)sVar6 + iVar14;\n    iVar14 = iVar3 + 1;\n    puVar5[iVar3] = 0x3a;\n    pcVar13 = *ppcVar10;\n    ppcVar10 = ppcVar10 + 5;\n  } while (pcVar13 != (char *)0x0);\nLAB_001b2154:\n  puVar7 = puVar5;\n  if (iVar14 != 0) {\n    puVar7 = puVar5 + (iVar14 + -1);\n  }\n  *puVar7 = 0;\n  lVar8 = find_variable(\"SHELLOPTS\");\n  if (lVar8 == 0) {\n    lVar8 = bind_variable(\"SHELLOPTS\",puVar5,0);\n    uVar2 = *(uint *)(lVar8 + 0x28);\n    *(uint *)(lVar8 + 0x28) = uVar2 | 2;\n    if (mark_modified_vars == 0) goto LAB_001b21b0;\n  }\n  else {\n    uVar1 = *(uint *)(lVar8 + 0x28);\n    *(uint *)(lVar8 + 0x28) = uVar1 & 0xfffffffd;\n    lVar8 = bind_variable(\"SHELLOPTS\",puVar5,0);\n    iVar14 = mark_modified_vars;\n    uVar2 = *(uint *)(lVar8 + 0x28);\n    *(uint *)(lVar8 + 0x28) = uVar2 | 2;\n    if ((iVar14 == 0) || ((uVar1 & 1) != 0)) goto LAB_001b21b0;\n  }\n  if ((uVar2 & 1) != 0) {\n    *(uint *)(lVar8 + 0x28) = uVar2 & 0xfffffffe | 2;\n  }\nLAB_001b21b0:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  sh_xfree(puVar5,\"./set.def\",0x25e);\n  return;\n}\n\n",
  "FUN_0015fd20": "\nvoid FUN_0015fd20(void)\n\n{\n  uint *puVar1;\n  long lVar2;\n  long *plVar3;\n  uint uVar4;\n  int iVar5;\n  long *plVar6;\n  char *__s;\n  undefined8 uVar7;\n  char *__s1;\n  ulong uVar8;\n  uint uVar9;\n  ulong uVar10;\n  uint __sig;\n  char **ppcVar11;\n  ulong uVar12;\n  long in_FS_OFFSET;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00247680 == 0) {\n    iVar5 = DAT_00247690 + 1;\n    if (DAT_0023877c < 1) goto LAB_0015fed5;\nLAB_0015fda6:\n    DAT_00247690 = iVar5;\n    uVar8 = 0;\n    __s1 = (char *)0x0;\nLAB_0015fdc8:\n    do {\n      uVar12 = uVar8 & 0xffffffff;\n      lVar2 = uVar8 * 8;\n      ppcVar11 = *(char ***)(jobs + uVar8 * 8);\n      if ((ppcVar11 == (char **)0x0) ||\n         (uVar10 = (ulong)*(uint *)(ppcVar11 + 3), (*(uint *)(ppcVar11 + 3) & 2) != 0))\n      goto LAB_0015fdb8;\n      uVar4 = FUN_0015e730(uVar8 & 0xffffffff);\n      uVar9 = (uint)uVar10;\n      iVar5 = *(int *)((long)ppcVar11 + 0x14);\n      if (startup_state != 0) {\n        if ((job_control == 0) && (interactive_shell != 0)) {\nLAB_0015ffd8:\n          if (iVar5 == 4) goto LAB_0015ffa0;\n          goto LAB_0015fdb8;\n        }\n        if ((startup_state != 2) || ((subshell_environment & 4 | posixly_correct) == 0))\n        goto LAB_0015fe2b;\n        if (iVar5 != 4) goto LAB_0015fdb8;\n        if (interactive_shell == 0) {\n          plVar3 = (long *)ppcVar11[1];\n          do {\n            plVar6 = plVar3;\n            if (plVar6 == (long *)0x0) {\n              do {\n                invalidInstructionException();\n              } while( true );\n            }\n            plVar3 = (long *)*plVar6;\n          } while ((long *)ppcVar11[1] != (long *)*plVar6);\n          if (*(int *)(plVar6 + 1) == last_asynchronous_pid) goto LAB_0015fdb8;\n        }\nLAB_0015ffa0:\n        uVar9 = uVar9 | 2;\nLAB_0015ffa3:\n        *(uint *)(ppcVar11 + 3) = uVar9;\n        goto LAB_0015fdb8;\n      }\n      if ((char)(((byte)uVar4 & 0x7f) + 1) < '\\x02') {\n        if (iVar5 == 4) {\n          if ((uVar10 & 1) != 0) {\n            if ((job_control == 0) && (interactive_shell != 0)) goto LAB_0015ffa0;\n            goto LAB_00160060;\n          }\n        }\n        else if (iVar5 != 2) {\n          if (job_control != 0) goto LAB_0015fe34;\n          if (interactive_shell == 0) goto LAB_0015fe2b;\n        }\n        goto LAB_0015fdb8;\n      }\n      if ((job_control == 0) && (interactive_shell != 0)) goto LAB_0015ffd8;\nLAB_0015fe2b:\n      if (iVar5 == 4) {\nLAB_00160060:\n        __sig = uVar4 & 0x7f;\n        if (interactive_shell == 0) {\n          if ((__sig == 0) || ((char)((char)__sig + '\\x01') < '\\x02')) {\n            if ((uVar10 & 1) != 0) goto LAB_0015ffa0;\n          }\n          else {\n            if (((uVar4 & 0x7d) != 0xd) && (__sig != 2)) {\n              iVar5 = signal_is_trapped(__sig);\n              if (iVar5 != 0) {\n                uVar9 = *(uint *)(*(long *)(jobs + lVar2) + 0x18);\n                goto LAB_001600a6;\n              }\n              iVar5 = line_number;\n              if (line_number == 0) {\n                iVar5 = 1;\n              }\n              uVar7 = get_name_for_error();\n              __fprintf_chk(stderr,1,\"%s: line %d: \",uVar7,iVar5);\n              FUN_0015ef00(*(undefined8 *)(*(long *)(jobs + lVar2) + 8),uVar12,1,stderr);\n              ppcVar11 = *(char ***)(jobs + lVar2);\n              uVar9 = *(uint *)(ppcVar11 + 3) | 2;\n              *(uint *)(ppcVar11 + 3) = uVar9;\n              goto LAB_0015ffa3;\n            }\nLAB_001600a6:\n            if ((uVar9 & 1) != 0) goto LAB_001600af;\n          }\nLAB_001601ca:\n          if (job_control != 0) {\n            if (__s1 == (char *)0x0) {\n              __s1 = (char *)FUN_0015eb60();\n              FUN_0015f5f0(uVar12,0,stderr);\n              if (__s1 == (char *)0x0) goto LAB_00160230;\n            }\n            else {\n              FUN_0015f5f0(uVar12,0,stderr);\n            }\n            ppcVar11 = *(char ***)(jobs + lVar2);\n            iVar5 = strcmp(__s1,*ppcVar11);\n            if (iVar5 == 0) {\n              uVar9 = *(uint *)(ppcVar11 + 3);\n              goto LAB_0015ffa0;\n            }\n            uVar7 = polite_directory_format(__s1);\n            __fprintf_chk(stderr,1,\"(wd now: %s)\\n\",uVar7);\n          }\nLAB_00160230:\n          ppcVar11 = *(char ***)(jobs + lVar2);\n          uVar9 = *(uint *)(ppcVar11 + 3);\n          goto LAB_0015ffa0;\n        }\n        if ((uVar10 & 1) == 0) goto LAB_001601ca;\n        if ((__sig == 0) || ((char)((char)__sig + '\\x01') < '\\x02')) goto LAB_0015ffa0;\nLAB_001600af:\n        if ((__sig == 0xd) || (__sig == 2)) goto LAB_00160230;\n        __s = strsignal(__sig);\n        if (__s == (char *)0x0) {\n          __snprintf_chk(&DAT_00247620,0x40,1,0x40,\"Signal %d\",__sig);\n          __s = &DAT_00247620;\n        }\n        fputs(__s,stderr);\n        if ((uVar4 & 0x80) != 0) {\n          fwrite(\" (core dumped)\",1,0xe,stderr);\n        }\n        fputc(10,stderr);\n        ppcVar11 = *(char ***)(jobs + lVar2);\n        uVar9 = *(uint *)(ppcVar11 + 3) | 2;\n        goto LAB_0015ffa3;\n      }\nLAB_0015fe34:\n      if (4 < iVar5) {\n        if (iVar5 != 8) {\nLAB_0015ff09:\n                    /* WARNING: Subroutine does not return */\n          programming_error(\"notify_of_job_status\");\n        }\nLAB_0015fdb8:\n        uVar8 = uVar8 + 1;\n        if (DAT_0023877c <= (int)uVar8) break;\n        goto LAB_0015fdc8;\n      }\n      if (iVar5 == 1) goto LAB_0015fdb8;\n      if (iVar5 != 2) goto LAB_0015ff09;\n      fputc(10,stderr);\n      if (__s1 == (char *)0x0) {\n        __s1 = (char *)FUN_0015eb60();\n        FUN_0015f5f0(uVar12,0,stderr);\n        if (__s1 != (char *)0x0) goto LAB_0015fe7a;\nLAB_00160185:\n        puVar1 = (uint *)(*(long *)(jobs + lVar2) + 0x18);\n        *puVar1 = *puVar1 | 2;\n      }\n      else {\n        FUN_0015f5f0(uVar12,0,stderr);\nLAB_0015fe7a:\n        ppcVar11 = *(char ***)(jobs + lVar2);\n        iVar5 = strcmp(__s1,*ppcVar11);\n        if (iVar5 != 0) {\n          uVar7 = polite_directory_format(__s1);\n          __fprintf_chk(stderr,1,\"(wd now: %s)\\n\",uVar7);\n          goto LAB_00160185;\n        }\n        ppcVar11 = ppcVar11 + 3;\n        *(uint *)ppcVar11 = *(uint *)ppcVar11 | 2;\n      }\n      uVar8 = uVar8 + 1;\n    } while ((int)uVar8 < DAT_0023877c);\n    if (DAT_00247680 == 0) {\n      DAT_00247690 = DAT_00247690 + -1;\n      goto LAB_0015fed5;\n    }\n  }\n  else {\n    sigemptyset(&local_148);\n    sigaddset(&local_148,0x11);\n    sigaddset(&local_148,0x16);\n    sigemptyset(&local_c8);\n    sigprocmask(0,&local_148,&local_c8);\n    iVar5 = DAT_00247690;\n    if (0 < DAT_0023877c) goto LAB_0015fda6;\n  }\n  sigprocmask(2,&local_c8,(sigset_t *)0x0);\nLAB_0015fed5:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "FUN_00194470": "\nulong FUN_00194470(long *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  \n  iVar1 = absolute_program(*param_1);\n  if (iVar1 == 0) {\n    lVar2 = search_for_command(*param_1,0);\n    if (lVar2 != 0) {\n      *param_1 = lVar2;\n    }\n    return (ulong)(lVar2 != 0);\n  }\n  uVar3 = FUN_00191f40(param_1);\n  return uVar3;\n}\n\n",
  "clear_shell_input_line": "\nvoid clear_shell_input_line(void)\n\n{\n  if (DAT_00240da8 != (undefined *)0x0) {\n    DAT_00240da0 = 0;\n    *DAT_00240da8 = 0;\n  }\n  return;\n}\n\n",
  "progcomp_dispose": "\nvoid progcomp_dispose(void)\n\n{\n  if (prog_completes != 0) {\n    hash_dispose();\n    prog_completes = 0;\n    return;\n  }\n  prog_completes = 0;\n  return;\n}\n\n",
  "sh_invalidnum": "\nvoid sh_invalidnum(char *param_1)\n\n{\n  ushort **ppuVar1;\n  char *pcVar2;\n  \n  pcVar2 = \"invalid number\";\n  if (*param_1 == '0') {\n    ppuVar1 = __ctype_b_loc();\n    pcVar2 = \"invalid octal number\";\n    if (((*(byte *)((long)*ppuVar1 + (ulong)(byte)param_1[1] * 2 + 1) & 8) == 0) &&\n       (pcVar2 = \"invalid number\", param_1[1] == 0x78)) {\n      pcVar2 = \"invalid hex number\";\n    }\n  }\n  builtin_error(\"%s: %s\",param_1,pcVar2);\n  return;\n}\n\n",
  "FUN_0019a780": "\nundefined8 FUN_0019a780(void)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  size_t sVar3;\n  undefined8 uVar4;\n  \n  if (((DAT_002489a8 == (char *)0x0) || (pcVar1 = DAT_002489a8, *DAT_002489a8 == '\\0')) &&\n     (maybe_make_export_env(), pcVar1 = DAT_002489a8, DAT_002489a8 == (char *)0x0)) {\n    pcVar1 = \"\";\n  }\n  pcVar1 = setlocale(6,pcVar1);\n  uVar4 = 0;\n  if (pcVar1 != (char *)0x0) {\n    pcVar1 = (char *)get_locale_var();\n    pcVar1 = setlocale(0,pcVar1);\n    pcVar2 = (char *)get_locale_var(\"LC_COLLATE\");\n    setlocale(3,pcVar2);\n    pcVar2 = (char *)get_locale_var(\"LC_MESSAGES\");\n    setlocale(5,pcVar2);\n    pcVar2 = (char *)get_locale_var(\"LC_NUMERIC\");\n    setlocale(1,pcVar2);\n    pcVar2 = (char *)get_locale_var(\"LC_TIME\");\n    setlocale(2,pcVar2);\n    FUN_0019a310();\n    sVar3 = __ctype_get_mb_cur_max();\n    locale_mb_cur_max = (undefined4)sVar3;\n    if (pcVar1 != (char *)0x0) {\n      locale_utf8locale = FUN_0019a3c0();\n    }\n    locale_shiftstates = mblen((char *)0x0,0);\n    u32reset();\n    uVar4 = 1;\n  }\n  return uVar4;\n}\n\n",
  "make_funcname_visible": "\nvoid make_funcname_visible(int param_1)\n\n{\n  long lVar1;\n  uint uVar2;\n  \n  lVar1 = find_variable(\"FUNCNAME\");\n  if ((lVar1 != 0) && (*(long *)(lVar1 + 0x18) != 0)) {\n    uVar2 = *(uint *)(lVar1 + 0x28) & 0xffffefff;\n    if (param_1 == 0) {\n      uVar2 = *(uint *)(lVar1 + 0x28) | 0x1000;\n    }\n    *(uint *)(lVar1 + 0x28) = uVar2;\n  }\n  return;\n}\n\n",
  "strvec_flush": "\nvoid strvec_flush(long *param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  \n  if ((param_1 != (long *)0x0) && (lVar2 = *param_1, lVar2 != 0)) {\n    plVar1 = param_1 + 1;\n    do {\n      sh_xfree(lVar2,\"stringvec.c\",0x59);\n      lVar2 = *plVar1;\n      plVar1 = plVar1 + 1;\n    } while (lVar2 != 0);\n    return;\n  }\n  return;\n}\n\n",
  "file_exists": "\nbool file_exists(char *param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  stat sStack_a8;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = stat(param_1,&sStack_a8);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 == 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00149470": "\nundefined8 FUN_00149470(long param_1)\n\n{\n  undefined4 uVar1;\n  char *__src;\n  int iVar2;\n  uint uVar3;\n  size_t sVar4;\n  char *__dest;\n  undefined8 uVar5;\n  \n  uVar1 = line_number;\n  line_number = *(int *)(param_1 + 4);\n  iVar2 = signal_in_progress(0x42);\n  if ((iVar2 == 0) && (running_trap != 0x43)) {\n    line_number_for_err_trap = line_number;\n  }\n  if ((((variable_context != 0) && (interactive_shell != 0)) && (sourcelevel == 0)) &&\n     (line_number = line_number - (DAT_00242170 + -1), line_number < 1)) {\n    line_number = 1;\n  }\n  command_string_index = 0;\n  print_cond_command(param_1);\n  uVar3 = signal_in_progress(0x41);\n  if ((uVar3 | running_trap) == 0) {\n    if (the_printed_command_except_trap != (char *)0x0) {\n      sh_xfree(the_printed_command_except_trap,\"execute_cmd.c\",0xfc9);\n    }\n    __src = the_printed_command;\n    sVar4 = strlen(the_printed_command);\n    __dest = (char *)sh_xmalloc(sVar4 + 1,\"execute_cmd.c\",0xfca);\n    the_printed_command_except_trap = strcpy(__dest,__src);\n  }\n  iVar2 = run_debug_trap();\n  if ((debugging_mode == 0) || (uVar5 = 0, iVar2 == 0)) {\n    this_command_name = &DAT_001fab64;\n    uVar5 = FUN_00148e00(param_1);\n    last_command_exit_value = (undefined4)uVar5;\n  }\n  line_number = uVar1;\n  return uVar5;\n}\n\n",
  "rl_tty_set_echoing": "\nundefined4 rl_tty_set_echoing(undefined4 param_1)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = _rl_echoing_p;\n  _rl_echoing_p = param_1;\n  return uVar1;\n}\n\n",
  "setrlimit": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint setrlimit(__rlimit_resource_t __resource,rlimit *__rlimits)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_setrlimit_00237c78)();\n  return iVar1;\n}\n\n",
  "initialize_shell_options": "\nvoid initialize_shell_options(int param_1)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *__dest;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  undefined4 local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    lVar1 = find_variable(\"SHELLOPTS\");\n    if (lVar1 != 0) {\n      if (((*(uint *)(lVar1 + 0x28) & 0x8000) != 0) && ((*(uint *)(lVar1 + 0x28) & 0x44) == 0)) {\n        pcVar3 = *(char **)(lVar1 + 8);\n        sVar2 = strlen(pcVar3);\n        __dest = (char *)sh_xmalloc(sVar2 + 1,\"./set.def\",0x27d);\n        pcVar3 = strcpy(__dest,pcVar3);\n        local_34 = 0;\n        while( true ) {\n          lVar1 = extract_colon_unit(pcVar3,&local_34);\n          if (lVar1 == 0) break;\n          set_minus_o_option(0x2d,lVar1);\n          sh_xfree(lVar1,\"./set.def\",0x26c);\n        }\n        sh_xfree(pcVar3,\"./set.def\",0x281);\n      }\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    set_shellopts();\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "__memmove_chk": "\nvoid __memmove_chk(void)\n\n{\n  (*(code *)PTR___memmove_chk_00237b20)();\n  return;\n}\n\n",
  "_rl_cr": "\nvoid _rl_cr(void)\n\n{\n  tputs(_rl_term_cr,1,_rl_output_character_function);\n  return;\n}\n\n",
  "xbcopy": "\nvoid xbcopy(void *param_1,void *param_2,int param_3)\n\n{\n  memcpy(param_2,param_1,(long)param_3);\n  return;\n}\n\n",
  "FUN_00186460": "\nbool FUN_00186460(undefined8 param_1,undefined8 param_2,undefined4 param_3,uint param_4)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  bool bVar2;\n  int local_44;\n  long local_40;\n  long local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_4 & 2) == 0) {\n    iVar1 = legal_number(param_1,&local_40);\n    if (iVar1 == 0) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00186410(\"%s: integer expression expected\",param_1);\n    }\n    iVar1 = legal_number(param_2,&local_38);\n    if (iVar1 == 0) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00186410(\"%s: integer expression expected\",param_2);\n    }\n  }\n  else {\n    bVar2 = shell_compatibility_level < 0x34;\n    local_40 = evalexp(param_1,bVar2,&local_44);\n    if ((local_44 == 0) || (local_38 = evalexp(param_2,bVar2,&local_44), local_44 == 0)) {\n      bVar2 = false;\n      goto LAB_001864b6;\n    }\n  }\n  switch(param_3) {\n  default:\n    bVar2 = local_38 == local_40;\n    break;\n  case 1:\n    bVar2 = local_38 != local_40;\n    break;\n  case 2:\n    bVar2 = local_40 < local_38;\n    break;\n  case 3:\n    bVar2 = local_38 < local_40;\n    break;\n  case 4:\n    bVar2 = local_40 <= local_38;\n    break;\n  case 5:\n    bVar2 = local_38 <= local_40;\n  }\nLAB_001864b6:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "posix_memalign": "\nint posix_memalign(void **__memptr,size_t __alignment,size_t __size)\n\n{\n  ulong uVar1;\n  int iVar2;\n  void *pvVar3;\n  void *pvVar4;\n  \n  if ((__alignment & 7) == 0) {\n    iVar2 = 0x16;\n    if (__alignment != 0) {\n      uVar1 = __alignment - 1;\n      iVar2 = 0x16;\n      if ((uVar1 & __alignment) == 0) {\n        pvVar3 = (void *)FUN_001f85f0(__alignment + __size,0,0);\n        if (pvVar3 == (void *)0x0) {\n          iVar2 = 0xc;\n        }\n        else {\n          pvVar4 = pvVar3;\n          if (((ulong)pvVar3 & uVar1) != 0) {\n            pvVar4 = (void *)(uVar1 + (long)pvVar3 & -__alignment);\n            *(undefined *)((long)pvVar4 - 0x10) = 0xd6;\n            *(int *)((long)pvVar4 - 0xc) = (int)pvVar4 - (int)pvVar3;\n          }\n          *__memptr = pvVar4;\n          iVar2 = 0;\n        }\n      }\n    }\n    return iVar2;\n  }\n  return 0x16;\n}\n\n",
  "FUN_00152680": "\nlong FUN_00152680(long param_1,char *param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_2 != (char *)0x0) && (*param_2 != '\\0')) {\n    iVar2 = legal_number(param_2,&local_28);\n    if (iVar2 != 0) {\n      line_number_base = (int)local_28;\n      lVar4 = (long)line_number_base;\n      goto LAB_001526b8;\n    }\n  }\n  local_28 = 0;\n  lVar4 = 0;\n  line_number_base = 0;\nLAB_001526b8:\n  uVar1 = *(uint *)(param_1 + 0x28);\n  line_number = line_number_base;\n  uVar3 = itos(lVar4);\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x527);\n  }\n  *(undefined8 *)(param_1 + 8) = uVar3;\n  if ((uVar1 & 0x10) != 0) {\n    *(uint *)(param_1 + 0x28) = *(uint *)(param_1 + 0x28) | 0x10;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "delete_all_aliases": "\nvoid delete_all_aliases(void)\n\n{\n  if (aliases != 0) {\n    hash_flush(aliases,FUN_00187930);\n    hash_dispose(aliases);\n    aliases = 0;\n    set_itemlist_dirty(it_aliases);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00195b80": "\nbool FUN_00195b80(char **param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  char *__s;\n  size_t sVar7;\n  long lVar8;\n  char *pcVar9;\n  char cVar10;\n  size_t __n;\n  long in_FS_OFFSET;\n  bool bVar11;\n  undefined4 local_48;\n  undefined4 local_44;\n  long local_40;\n  \n  pcVar9 = *param_1;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_44 = 0;\n  local_48 = 0;\n  iVar2 = FUN_00194bb0(pcVar9,1,&local_48,&local_44);\n  if ((iVar2 == 0) || (iVar3 = FUN_00191e10(pcVar9,1), iVar3 != 0)) {\n    bVar11 = true;\n    pcVar4 = (char *)FUN_00191560(pcVar9,rl_completion_quote_character);\n    if (*pcVar9 == *pcVar4) {\n      iVar2 = strcmp(pcVar9,pcVar4);\n      bVar11 = iVar2 != 0;\n    }\n    sh_xfree(pcVar9,\"bashline.c\",0xdad);\n    *param_1 = pcVar4;\n  }\n  else {\n    sVar7 = strlen(pcVar9);\n    pcVar4 = (char *)sh_xmalloc(sVar7 + 1,\"bashline.c\",0xd90);\n    pcVar4 = strcpy(pcVar4,pcVar9);\n    lVar8 = expand_prompt_string(pcVar4,0,0x8100400);\n    if (lVar8 == 0) {\n      bVar11 = true;\n      sh_xfree(pcVar4,\"bashline.c\",0xda1);\n      sh_xfree(pcVar9,\"bashline.c\",0xda2);\n      pcVar9 = (char *)sh_xmalloc(1,\"bashline.c\",0xda3);\n      *param_1 = pcVar9;\n      *pcVar9 = '\\0';\n      goto LAB_00195ce6;\n    }\n    bVar11 = true;\n    pcVar6 = (char *)string_list(lVar8);\n    *param_1 = pcVar6;\n    if (*pcVar9 == *pcVar6) {\n      iVar3 = strcmp(pcVar9,pcVar6);\n      bVar11 = iVar3 != 0;\n    }\n    sh_xfree(pcVar9,\"bashline.c\",0xd98);\n    sh_xfree(pcVar4,\"bashline.c\",0xd99);\n    dispose_words(lVar8);\n    pcVar4 = *param_1;\n    FUN_00195620(iVar2,local_48,local_44);\n  }\n  if ((no_symbolic_links != 0) || ((*pcVar4 == '.' && (pcVar4[1] == '\\0')))) goto LAB_00195ce6;\n  uVar5 = get_working_directory(\"symlink-hook\");\n  pcVar6 = (char *)make_absolute(pcVar4,uVar5);\n  sh_xfree(uVar5,\"bashline.c\",0xdcc);\n  __s = (char *)sh_canonpath(pcVar6,3);\n  pcVar9 = pcVar6;\n  if (__s == (char *)0x0) {\n    if (((dircomplete_spelling != 0) && (dircomplete_expand != 0)) &&\n       (pcVar9 = (char *)dirspell(pcVar6), pcVar9 != (char *)0x0)) {\n      cVar1 = *pcVar9;\n      sVar7 = strlen(pcVar6);\n      if (cVar1 == '\\0') {\n        if (sVar7 != 0) {\nLAB_00195efd:\n          sh_xfree(pcVar9,\"bashline.c\",0xddb);\n          goto LAB_00195e82;\n        }\n      }\n      else if (pcVar9[1] == '\\0') {\n        if (1 < sVar7) {\n          __n = 1;\n          goto LAB_00195f9b;\n        }\n      }\n      else if (pcVar9[2] == '\\0') {\n        if (2 < sVar7) {\n          __n = 2;\nLAB_00195f9b:\n          if ((cVar1 == *pcVar6) && (iVar2 = strncmp(pcVar6,pcVar9,__n), iVar2 == 0))\n          goto LAB_00195efd;\n        }\n      }\n      else {\n        __n = strlen(pcVar9);\n        if (__n < sVar7) {\n          if (__n == 0) goto LAB_00195efd;\n          goto LAB_00195f9b;\n        }\n      }\n      sh_xfree(pcVar6,\"bashline.c\",0xde0);\n      __s = (char *)sh_canonpath(pcVar9,3);\n      bVar11 = (bool)(bVar11 | __s != (char *)0x0);\n      pcVar6 = pcVar9;\n      if (__s != (char *)0x0) goto LAB_00195c78;\n    }\nLAB_00195e82:\n    sh_xfree(pcVar6,\"bashline.c\",0xde9);\n    goto LAB_00195ce6;\n  }\nLAB_00195c78:\n  sVar7 = strlen(pcVar9);\n  if (pcVar9[(long)(int)sVar7 + -1] == '/') {\n    sVar7 = strlen(__s);\n    iVar2 = (int)sVar7;\n    if (2 < iVar2) {\n      __s = (char *)sh_xrealloc(__s,(long)(iVar2 + 2),\"bashline.c\",0xdf2);\n      __s[iVar2] = '/';\n      __s[(long)iVar2 + 1] = '\\0';\n    }\n  }\n  cVar1 = *pcVar4;\n  if (dircomplete_expand_relpath == 0) {\n    if ((1 < (byte)(cVar1 - 0x2eU)) &&\n       ((cVar10 = *__s, *pcVar9 != cVar10 || (iVar2 = strcmp(pcVar9,__s), iVar2 != 0))))\n    goto LAB_00195cb5;\n  }\n  else {\n    cVar10 = *__s;\nLAB_00195cb5:\n    if (cVar1 == cVar10) {\n      iVar2 = strcmp(pcVar4,__s);\n      if (iVar2 != 0) {\n        bVar11 = true;\n      }\n    }\n    else {\n      bVar11 = true;\n    }\n  }\n  sh_xfree(pcVar4,\"bashline.c\",0xe00);\n  *param_1 = __s;\n  sh_xfree(pcVar9,\"bashline.c\",0xe02);\nLAB_00195ce6:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return bVar11;\n}\n\n",
  "FUN_001dbb00": "\nundefined8 FUN_001dbb00(char *param_1)\n\n{\n  char cVar1;\n  bool bVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  size_t sVar5;\n  char *pcVar6;\n  char *pcVar7;\n  int unaff_EBX;\n  int iVar8;\n  char *pcVar9;\n  long in_FS_OFFSET;\n  int local_24;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar4 = 1;\n  if (param_1 != (char *)0x0) {\n    sVar5 = strlen(param_1);\n    pcVar6 = (char *)xmalloc(sVar5 + 1);\n    pcVar6 = strcpy(pcVar6,param_1);\n    if (_rl_isearch_terminators != (void *)0x0) {\n      free(_rl_isearch_terminators);\n    }\n    cVar1 = *pcVar6;\n    bVar2 = cVar1 == '\\\"' || cVar1 == '\\'';\n    if (cVar1 == '\\\"' || cVar1 == '\\'') {\n      local_24 = 1;\n      pcVar9 = pcVar6 + 1;\n      pcVar7 = pcVar9;\n      iVar8 = local_24;\n      if ((cVar1 != pcVar6[1]) && (pcVar6[1] != '\\0')) {\n        pcVar3 = pcVar6 + 2;\n        do {\n          pcVar7 = pcVar3;\n          iVar8 = (int)pcVar7 - (int)pcVar6;\n          if (cVar1 == *pcVar7) break;\n          pcVar3 = pcVar7 + 1;\n        } while (*pcVar7 != '\\0');\n      }\n    }\n    else {\n      local_24 = 0;\n      pcVar9 = pcVar6 + 1;\n      pcVar7 = pcVar6;\n      iVar8 = local_24;\n      while (pcVar3 = pcVar9, pcVar9 = pcVar6, cVar1 != '\\0') {\n        if ((cVar1 == ' ') || (cVar1 == '\\t')) {\n          pcVar7 = pcVar6;\n          iVar8 = local_24;\n          if (bVar2) {\n            pcVar7 = pcVar6 + unaff_EBX;\n            iVar8 = unaff_EBX;\n          }\n          break;\n        }\n        iVar8 = (1 - (int)(pcVar6 + 1)) + (int)pcVar3;\n        bVar2 = true;\n        pcVar9 = pcVar3 + 1;\n        pcVar7 = pcVar3;\n        unaff_EBX = iVar8;\n        cVar1 = *pcVar3;\n      }\n    }\n    local_24 = iVar8;\n    *pcVar7 = '\\0';\n    sVar5 = strlen(pcVar6);\n    _rl_isearch_terminators = (void *)xmalloc(sVar5 * 2 + 1);\n    rl_translate_keyseq(pcVar9,_rl_isearch_terminators,&local_24);\n    *(undefined *)((long)_rl_isearch_terminators + (long)local_24) = 0;\n    xfree(pcVar6);\n    uVar4 = 0;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_quoted_insert": "\nundefined8 rl_quoted_insert(int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (((rl_readline_state._2_1_ & 8) == 0) &&\n     (_rl_disable_tty_signals(), (rl_readline_state._2_1_ & 8) == 0)) {\n    if (-1 < param_1) {\n      uVar1 = FUN_001ee5e0(param_1);\n      return uVar1;\n    }\n    do {\n      uVar1 = FUN_001ee5e0(1);\n      if ((int)uVar1 != 0) {\n        return uVar1;\n      }\n      param_1 = param_1 + 1;\n    } while (param_1 != 0);\n    return uVar1;\n  }\n  _rl_callback_data = _rl_callback_data_alloc(param_1);\n  _rl_callback_func = FUN_001ee680;\n  return 0;\n}\n\n",
  "FUN_001497c0": "\nvoid FUN_001497c0(int param_1,int param_2)\n\n{\n  int iVar1;\n  \n  if (param_1 != -1) {\n    iVar1 = dup2(param_1,0);\n    if (iVar1 < 0) {\n      sys_error(\"cannot duplicate fd %d to fd %d\",param_1,0);\n    }\n    if (0 < param_1) {\n      close(param_1);\n    }\n  }\n  if (param_2 != -1) {\n    if (param_2 == -2) {\n      iVar1 = dup2(1,2);\n      if (iVar1 < 0) {\n        sys_error(\"cannot duplicate fd %d to fd %d\",1,2);\n        return;\n      }\n    }\n    else {\n      iVar1 = dup2(param_2,1);\n      if (iVar1 < 0) {\n        sys_error(\"cannot duplicate fd %d to fd %d\",param_2,1);\n      }\n      if ((param_2 == 0) || (1 < param_2)) {\n        close(param_2);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
  "FUN_00152200": "\nlong FUN_00152200(long param_1)\n\n{\n  char cVar1;\n  char *pcVar2;\n  size_t sVar3;\n  char *__dest;\n  \n  if (rl_completer_word_break_characters == (char *)0x0) {\n    if ((bash_readline_initialized == 0) &&\n       (enable_hostname_completion(perform_hostname_completion),\n       rl_completer_word_break_characters != (char *)0x0)) {\n      cVar1 = *rl_completer_word_break_characters;\n      pcVar2 = rl_completer_word_break_characters;\n      goto joined_r0x00152295;\n    }\n  }\n  else {\n    cVar1 = *rl_completer_word_break_characters;\n    pcVar2 = rl_completer_word_break_characters;\njoined_r0x00152295:\n    rl_completer_word_break_characters = pcVar2;\n    if (cVar1 != '\\0') {\n      sVar3 = strlen(pcVar2);\n      __dest = (char *)sh_xmalloc(sVar3 + 1,\"variables.c\",0x534);\n      pcVar2 = strcpy(__dest,pcVar2);\n      goto LAB_00152242;\n    }\n  }\n  pcVar2 = (char *)sh_xmalloc(1,\"variables.c\",0x537);\n  *pcVar2 = '\\0';\nLAB_00152242:\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x53a);\n  }\n  *(char **)(param_1 + 8) = pcVar2;\n  return param_1;\n}\n\n",
  "expand_string_unsplit_to_string": "\nundefined8 expand_string_unsplit_to_string(char *param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    lVar1 = expand_string_unsplit();\n    if (lVar1 != 0) {\n      uVar2 = string_list_internal(lVar1,&DAT_001fdb1c);\n      dispose_words(lVar1);\n      return uVar2;\n    }\n  }\n  return 0;\n}\n\n",
  "sh_invalidsig": "\nvoid sh_invalidsig(undefined8 param_1)\n\n{\n  builtin_error(\"%s: invalid signal specification\",param_1);\n  return;\n}\n\n",
  "FUN_0019ef10": "\nvoid FUN_0019ef10(char *param_1,int param_2,undefined8 param_3,int param_4,uint param_5)\n\n{\n  char cVar1;\n  uint uVar2;\n  long lVar3;\n  size_t sVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  size_t sVar7;\n  long in_FS_OFFSET;\n  undefined local_4c [12];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar3 = bind_variable(\"COMP_LINE\",param_1,0);\n  if ((lVar3 != 0) && ((param_5 & 1) != 0)) {\n    *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | 1;\n  }\n  pcVar6 = param_1 + param_2;\n  cVar1 = *pcVar6;\n  *pcVar6 = '\\0';\n  sVar4 = __ctype_get_mb_cur_max();\n  sVar7 = 0;\n  if (sVar4 < 2) {\n    if ((((param_1 != (char *)0x0) && (*param_1 != '\\0')) && (sVar7 = 1, param_1[1] != '\\0')) &&\n       (sVar7 = 2, param_1[2] != '\\0')) {\n      sVar7 = strlen(param_1);\n    }\n  }\n  else {\n    sVar7 = 0;\n    if (((param_1 != (char *)0x0) && (*param_1 != '\\0')) && (sVar7 = 1, param_1[1] != '\\0')) {\n      sVar7 = mbstrlen(param_1);\n    }\n  }\n  *pcVar6 = cVar1;\n  uVar5 = inttostr(sVar7,local_4c,0xc);\n  lVar3 = bind_int_variable(\"COMP_POINT\",uVar5,0);\n  if ((lVar3 != 0) && ((param_5 & 1) != 0)) {\n    *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | 1;\n  }\n  uVar5 = inttostr((long)rl_completion_type,local_4c,0xc);\n  lVar3 = bind_int_variable(\"COMP_TYPE\",uVar5,0);\n  if ((lVar3 == 0) || ((param_5 & 1) == 0)) {\n    uVar5 = inttostr((long)rl_completion_invoking_key,local_4c,0xc);\n    lVar3 = bind_int_variable(\"COMP_KEY\",uVar5,0);\n    if ((lVar3 != 0) && ((param_5 & 1) != 0)) goto LAB_0019f031;\n    if (param_5 == 0) {\n      lVar3 = find_variable_noref(\"COMP_WORDS\");\n      if (lVar3 == 0) {\n        lVar3 = make_new_array_variable(\"COMP_WORDS\");\n      }\n      uVar2 = *(uint *)(lVar3 + 0x28);\n      if ((uVar2 & 0x800) != 0) {\n        *(uint *)(lVar3 + 0x28) = uVar2 & 0xfffff7ff;\n      }\n      if ((uVar2 & 4) == 0) {\n        lVar3 = convert_var_to_array();\n      }\n      lVar3 = assign_array_var_from_word_list(lVar3,param_3,0);\n      *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) & 0xffffefff;\n      uVar5 = inttostr((long)param_4,local_4c,0xc);\n      bind_int_variable(\"COMP_CWORD\",uVar5,0);\n      goto LAB_0019f03f;\n    }\n  }\n  else {\n    *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | 1;\n    uVar5 = inttostr((long)rl_completion_invoking_key,local_4c,0xc);\n    lVar3 = bind_int_variable(\"COMP_KEY\",uVar5,0);\n    if (lVar3 != 0) {\nLAB_0019f031:\n      *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | 1;\n    }\n  }\n  array_needs_making = 1;\nLAB_0019f03f:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001b6f20": "\nundefined8 FUN_001b6f20(char *param_1,int param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined **ppuVar5;\n  int iVar6;\n  int *__s2;\n  long lVar7;\n  int unaff_R13D;\n  \n  if (param_2 == 0) {\n    unaff_R13D = shell_compatibility_level;\n    if (DAT_00248d64 == 0) {\nLAB_001b705a:\n      if (DAT_00248d60 == 0) {\n        if (DAT_00248d5c == 0) {\n          if (DAT_00248d58 == 0) {\n            if (DAT_00248d54 == 0) {\n              if (DAT_00248d50 == 0) {\n                if (DAT_00248d4c == 0) {\n                  if ((unaff_R13D < 0x2d) ||\n                     (lVar7 = (long)shell_compatibility_level, 0x33 < shell_compatibility_level)) {\n                    shell_compatibility_level = 0x34;\n                    lVar7 = 0x34;\n                  }\n                }\n                else {\n                  shell_compatibility_level = 0x2c;\n                  lVar7 = 0x2c;\n                }\n              }\n              else {\n                shell_compatibility_level = 0x2b;\n                lVar7 = 0x2b;\n              }\n            }\n            else {\n              shell_compatibility_level = 0x2a;\n              lVar7 = 0x2a;\n            }\n          }\n          else {\n            shell_compatibility_level = 0x29;\n            lVar7 = 0x29;\n          }\n        }\n        else {\n          shell_compatibility_level = 0x28;\n          lVar7 = 0x28;\n        }\n      }\n      else {\n        shell_compatibility_level = 0x20;\n        lVar7 = 0x20;\n      }\n      goto LAB_001b6f5c;\n    }\n  }\n  else {\n    DAT_00248d60 = 0;\n    iVar6 = 0;\n    DAT_00248d64 = 0;\n    cVar2 = 'a';\n    ppuVar5 = &PTR_s_assoc_expand_once_00236438;\n    __s2 = (int *)&DAT_00210a30;\n    DAT_00248d50 = 0;\n    DAT_00248d54 = 0;\n    DAT_00248d58 = 0;\n    DAT_00248d5c = 0;\n    DAT_00248d4c = 0;\n    cVar1 = *param_1;\nLAB_001b7022:\n    if (cVar1 != cVar2) {\nLAB_001b7010:\n      __s2 = (int *)*ppuVar5;\n      ppuVar5 = (undefined **)((int **)ppuVar5 + 3);\n      iVar6 = iVar6 + 1;\n      if (__s2 == (int *)0x0) goto LAB_001b7047;\n      cVar2 = *(char *)__s2;\n      goto LAB_001b7022;\n    }\n    iVar3 = strcmp(param_1,(char *)__s2);\n    if (iVar3 != 0) goto LAB_001b7010;\n    __s2 = (int *)(&PTR_autocd_00236428)[(long)iVar6 * 3];\nLAB_001b7047:\n    *__s2 = param_2;\n    if (DAT_00248d64 == 0) goto LAB_001b705a;\n  }\n  shell_compatibility_level = 0x1f;\n  lVar7 = 0x1f;\nLAB_001b6f5c:\n  uVar4 = itos(lVar7);\n  bind_variable(\"BASH_COMPAT\",uVar4,0);\n  sh_xfree(uVar4,\"./shopt.def\",0x2b4);\n  return 0;\n}\n\n",
  "_rl_output_some_chars": "\nvoid _rl_output_some_chars(void *param_1,int param_2)\n\n{\n  fwrite(param_1,1,(long)param_2,_rl_out_stream);\n  return;\n}\n\n",
  "FUN_001edde0": "\nundefined8 FUN_001edde0(int param_1,int param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  bool bVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  bool bVar5;\n  int local_3c;\n  \n  iVar2 = rl_point;\n  if (param_2 < 0) {\n    if (param_1 != 0) {\n      local_3c = -1;\n      bVar1 = true;\n      if (0 < rl_point) goto LAB_001ede21;\nLAB_001edebd:\n      rl_ding();\n      return 1;\n    }\n  }\n  else {\n    local_3c = 1;\n    bVar1 = false;\n    iVar3 = rl_point;\njoined_r0x001ede1b:\n    rl_point = iVar3;\n    if (param_1 != 0) {\nLAB_001ede21:\n      do {\n        if ((0 < param_2) && (rl_end <= iVar2)) break;\n        if (local_3c == 1) {\n          iVar2 = _rl_find_next_mbchar(rl_line_buffer,iVar2,1,0);\n        }\n        else {\n          iVar2 = _rl_find_prev_mbchar(rl_line_buffer,iVar2,0);\n        }\n        do {\n          while( true ) {\n            iVar3 = _rl_is_mbchar_matched(rl_line_buffer,iVar2,rl_end,param_3,param_4);\n            if (iVar3 != 0) {\n              param_1 = param_1 + -1;\n              if (!bVar1) {\n                iVar3 = iVar2;\n                if (param_2 == 1) {\n                  iVar3 = _rl_find_prev_mbchar(rl_line_buffer,iVar2,0);\n                }\n                goto joined_r0x001ede1b;\n              }\n              iVar3 = iVar2;\n              if (param_2 == -1) {\n                iVar3 = _rl_find_next_mbchar(rl_line_buffer,iVar2,1,0);\n              }\n              goto LAB_001edea8;\n            }\n            if (bVar1) break;\n            iVar4 = _rl_find_next_mbchar(rl_line_buffer,iVar2,1,0);\n            bVar5 = iVar2 == iVar4;\n            iVar3 = rl_point;\n            iVar2 = iVar4;\n            if (bVar5) goto joined_r0x001ede1b;\n          }\n          iVar4 = _rl_find_prev_mbchar(rl_line_buffer,iVar2,0);\n          bVar5 = iVar2 != iVar4;\n          iVar3 = rl_point;\n          iVar2 = iVar4;\n        } while (bVar5);\nLAB_001edea8:\n        rl_point = iVar3;\n        if (param_1 == 0) {\n          return 0;\n        }\n      } while ((0 < iVar2) || (!bVar1));\n      goto LAB_001edebd;\n    }\n  }\n  return 0;\n}\n\n",
  "FUN_00187300": "\nulong FUN_00187300(void)\n\n{\n  char cVar1;\n  uint uVar2;\n  bool bVar3;\n  int iVar4;\n  ulong uVar5;\n  ulong uVar6;\n  int iVar7;\n  uint uVar8;\n  char *pcVar9;\n  \n  uVar6 = (ulong)DAT_0024856c;\n  bVar3 = false;\n  do {\n    uVar8 = (uint)uVar6;\n    if (DAT_00248568 <= (int)uVar8) {\n      uVar2 = DAT_0024856c;\n      if (bVar3) {\n        uVar2 = uVar8;\n      }\nLAB_00187460:\n      DAT_0024856c = uVar2;\n      FUN_00186440();\nLAB_00187465:\n                    /* WARNING: Subroutine does not return */\n      FUN_00186410(\"`)\\' expected\");\n    }\n    pcVar9 = *(char **)(DAT_00248560 + (long)(int)uVar8 * 8);\n    cVar1 = *pcVar9;\n    if (cVar1 != '!') {\n      if (bVar3) {\n        DAT_0024856c = uVar8;\n      }\n      if ((cVar1 != '(') || (pcVar9[1] != '\\0')) goto LAB_00187415;\n      DAT_0024856c = uVar8 + 1;\n      uVar2 = DAT_0024856c;\n      if ((int)DAT_0024856c < DAT_00248568) {\n        uVar6 = FUN_00187510();\n        pcVar9 = *(char **)(DAT_00248560 + (long)(int)DAT_0024856c * 8);\n        if (pcVar9 != (char *)0x0) {\n          if ((*pcVar9 == ')') && (pcVar9[1] == '\\0')) {\n            DAT_0024856c = DAT_0024856c + 1;\n            return uVar6;\n          }\n                    /* WARNING: Subroutine does not return */\n          FUN_00186410(\"`)\\' expected, found %s\");\n        }\n        goto LAB_00187465;\n      }\n      goto LAB_00187460;\n    }\n    if (pcVar9[1] != '\\0') {\n      if (bVar3) {\n        DAT_0024856c = uVar8;\n      }\nLAB_00187415:\n      iVar7 = DAT_00248568;\n      if (((int)(uVar8 + 2) < DAT_00248568) &&\n         (iVar4 = test_binop(*(undefined8 *)(DAT_00248560 + 8 + (long)(int)uVar8 * 8)), iVar4 != 0))\n      {\n        uVar6 = FUN_00187050();\n        return uVar6;\n      }\n      iVar4 = uVar8 + 1;\n      if ((iVar4 < iVar7) && (iVar7 = test_unop(pcVar9), iVar7 != 0)) {\n        uVar6 = FUN_00186e30();\n        return uVar6;\n      }\n      DAT_0024856c = iVar4;\n      return (ulong)(cVar1 != '\\0');\n    }\n    iVar7 = 0;\n    uVar5 = (ulong)(int)(uVar8 + 1);\n    cVar1 = '\\0';\n    while( true ) {\n      uVar2 = (uint)uVar5;\n      uVar6 = (ulong)(uVar2 - 1);\n      if (cVar1 != '\\0') break;\n      uVar6 = uVar5 & 0xffffffff;\n      if (DAT_00248568 <= (int)uVar2) goto LAB_00187460;\n      pcVar9 = *(char **)(DAT_00248560 + uVar5 * 8);\n      uVar5 = uVar5 + 1;\n      iVar7 = 1 - iVar7;\n      if (*pcVar9 != '!') {\n        bVar3 = true;\n        break;\n      }\n      cVar1 = pcVar9[1];\n      bVar3 = true;\n    }\n    if (iVar7 != 0) {\n      if (bVar3) {\n        DAT_0024856c = (uint)uVar6;\n      }\n      iVar7 = FUN_00187300();\n      return (ulong)(iVar7 == 0);\n    }\n  } while( true );\n}\n\n",
  "ulimit_builtin": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nulong ulimit_builtin(undefined8 param_1)\n\n{\n  undefined8 *puVar1;\n  undefined **ppuVar2;\n  char cVar3;\n  __rlimit_resource_t __resource;\n  undefined auVar4 [16];\n  undefined auVar5 [16];\n  undefined8 uVar6;\n  int iVar7;\n  int iVar8;\n  uint uVar9;\n  undefined1 *puVar10;\n  char *pcVar11;\n  int iVar12;\n  long lVar13;\n  int *piVar14;\n  int *piVar15;\n  ulong uVar16;\n  uint uVar17;\n  int *piVar18;\n  ulong uVar19;\n  uint uVar20;\n  undefined8 *puVar21;\n  ulong uVar22;\n  undefined **ppuVar23;\n  long in_FS_OFFSET;\n  ulong local_68;\n  ulong local_60;\n  rlimit local_58;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00248c20 == '\\0') {\n    DAT_00248c22 = 0x48;\n    piVar18 = &DAT_00235200;\n    _DAT_00248c20 = 0x5361;\n    puVar10 = &DAT_00248c23;\n    iVar7 = 99;\n    iVar12 = 0x52;\n    while( true ) {\n      iVar8 = iVar7;\n      *puVar10 = (char)iVar12;\n      puVar10[1] = 0x3b;\n      if (iVar8 < 1) break;\n      iVar7 = *piVar18;\n      piVar18 = piVar18 + 8;\n      puVar10 = puVar10 + 2;\n      iVar12 = iVar8;\n    }\n    puVar10[2] = 0;\n  }\n  if (DAT_00248c48 == 0) {\n    DAT_00248c48 = 0x10;\n    DAT_00248c50 = (int *)sh_xmalloc(0x100,\"./ulimit.def\",0x165);\n  }\n  DAT_00248c4c = 0;\n  uVar22 = 0;\n  uVar17 = 0;\n  reset_internal_getopt();\n  while( true ) {\n    iVar7 = internal_getopt(param_1,&DAT_00248c20);\n    puVar21 = loptend;\n    piVar18 = DAT_00248c50;\n    if (iVar7 == -1) break;\n    if (iVar7 == 0x48) {\n      uVar17 = uVar17 | 1;\n    }\n    else if (iVar7 < 0x49) {\n      if (iVar7 == -99) {\n        builtin_help();\n        uVar22 = 0x102;\n        goto LAB_001b5641;\n      }\n      if (iVar7 == 0x3f) {\n        builtin_usage();\n        uVar22 = 0x102;\n        goto LAB_001b5641;\n      }\nLAB_001b569d:\n      if (DAT_00248c48 <= (int)DAT_00248c4c) {\n        DAT_00248c48 = DAT_00248c48 * 2;\n        DAT_00248c50 = (int *)sh_xrealloc(DAT_00248c50,(long)DAT_00248c48 << 4,\"./ulimit.def\");\n      }\n      uVar6 = list_optarg;\n      lVar13 = (long)(int)DAT_00248c4c;\n      DAT_00248c4c = DAT_00248c4c + 1;\n      piVar18 = DAT_00248c50 + lVar13 * 4;\n      *piVar18 = iVar7;\n      *(undefined8 *)(piVar18 + 2) = uVar6;\n    }\n    else if (iVar7 == 0x53) {\n      uVar17 = uVar17 | 2;\n    }\n    else {\n      if (iVar7 != 0x61) goto LAB_001b569d;\n      uVar22 = (ulong)((int)uVar22 + 1);\n    }\n  }\n  if ((int)uVar22 != 0) {\n    if (uVar17 == 0) {\n      uVar17 = 2;\n    }\n    ppuVar23 = &PTR_s_real_time_non_blocking_time_002351d0;\n    iVar7 = 0;\n    do {\n      iVar12 = FUN_001b54b0(iVar7,&local_60,&local_58);\n      if (iVar12 == 0) {\n        uVar22 = local_58.rlim_cur;\n        if ((uVar17 & 2) != 0) {\n          uVar22 = local_60;\n        }\n        FUN_001b5380(iVar7,uVar22,1);\n      }\n      else {\n        piVar18 = __errno_location();\n        if (*piVar18 != 0x16) {\n          pcVar11 = strerror(*piVar18);\n          builtin_error(\"%s: cannot get limit: %s\",*ppuVar23,pcVar11);\n        }\n      }\n      ppuVar2 = ppuVar23 + 2;\n      ppuVar23 = ppuVar23 + 4;\n      iVar7 = iVar7 + 1;\n    } while (0 < *(int *)ppuVar2);\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar22 = sh_chkwrite(0);\n      return uVar22;\n    }\n    goto LAB_001b5cdf;\n  }\n  uVar16 = (ulong)(int)DAT_00248c4c;\n  if (DAT_00248c4c == 0) {\n    *DAT_00248c50 = 0x66;\n    if (puVar21 == (undefined8 *)0x0) {\n      DAT_00248c4c = 1;\n      iVar7 = 0x66;\n      uVar16 = 1;\n      *(undefined8 *)(piVar18 + 2) = 0;\n    }\n    else {\n      puVar1 = puVar21 + 1;\n      iVar7 = 0x66;\n      puVar21 = (undefined8 *)*puVar21;\n      uVar16 = 1;\n      DAT_00248c4c = 1;\n      *(undefined8 *)(piVar18 + 2) = *(undefined8 *)*puVar1;\n    }\nLAB_001b5775:\n    iVar12 = 0;\n    piVar15 = piVar18;\n    while( true ) {\n      piVar15 = piVar15 + 4;\n      piVar14 = &DAT_002351e0;\n      iVar8 = 0x52;\n      while (iVar7 != iVar8) {\n        iVar8 = *piVar14;\n        piVar14 = piVar14 + 8;\n        if (iVar8 < 1) {\n          uVar22 = 0x102;\n          builtin_error(\"`%c\\': bad command\");\n          goto LAB_001b5641;\n        }\n      }\n      iVar12 = iVar12 + 1;\n      if ((int)uVar16 <= iVar12) break;\n      iVar7 = *piVar15;\n    }\n    if (puVar21 != (undefined8 *)0x0) {\nLAB_001b58d4:\n      uVar9 = DAT_00248c4c;\n      if (((undefined8 *)puVar21[1] != (undefined8 *)0x0) &&\n         (*(long *)(DAT_00248c50 + uVar16 * 4 + -2) == 0)) {\n        *(undefined8 *)(DAT_00248c50 + uVar16 * 4 + -2) = *(undefined8 *)puVar21[1];\n      }\n      uVar16 = (ulong)uVar9;\n      piVar18 = DAT_00248c50;\n      if ((int)uVar9 < 1) goto LAB_001b5641;\n    }\n    uVar9 = 3;\n    if (uVar17 != 0) {\n      uVar9 = uVar17;\n    }\n    uVar16 = uVar16 & 0xffffffff;\n    uVar20 = uVar9 & 2;\n    lVar13 = 0;\n    do {\n      iVar12 = 0;\n      piVar15 = &DAT_002351e0;\n      pcVar11 = *(char **)(piVar18 + lVar13 * 4 + 2);\n      iVar7 = 0x52;\n      do {\n        if (piVar18[lVar13 * 4] == iVar7) goto LAB_001b5985;\n        iVar7 = *piVar15;\n        piVar15 = piVar15 + 8;\n        iVar12 = iVar12 + 1;\n      } while (0 < iVar7);\n      iVar12 = -1;\nLAB_001b5985:\n      if (uVar17 == 0) {\n        if (pcVar11 == (char *)0x0) {\n          iVar7 = FUN_001b54b0(iVar12,&local_68,&local_60);\n          if (-1 < iVar7) {\nLAB_001b5be8:\n            uVar19 = local_68;\n            goto LAB_001b5abe;\n          }\n        }\n        else {\n          iVar7 = FUN_001b54b0(iVar12,&local_68,&local_60);\n          if (-1 < iVar7) goto LAB_001b59b1;\n        }\nLAB_001b5b9c:\n        piVar18 = __errno_location();\n        uVar22 = 1;\n        pcVar11 = strerror(*piVar18);\n        builtin_error(\"%s: cannot get limit: %s\",\n                      (&PTR_s_real_time_non_blocking_time_002351d0)[(long)iVar12 * 4],pcVar11);\n        break;\n      }\n      iVar7 = FUN_001b54b0(iVar12,&local_68,&local_60);\n      if (iVar7 < 0) goto LAB_001b5b9c;\n      if (pcVar11 != (char *)0x0) {\nLAB_001b59b1:\n        cVar3 = *pcVar11;\n        if (cVar3 == 'h') {\n          iVar7 = strcmp(pcVar11,\"hard\");\n          uVar16 = local_60;\njoined_r0x001b5b61:\n          if (iVar7 != 0) {\nLAB_001b5ae0:\n            iVar7 = all_digits(pcVar11);\n            if (iVar7 == 0) {\n              uVar22 = 1;\n              sh_invalidnum(pcVar11);\n              break;\n            }\n            uVar16 = string_to_rlimtype(pcVar11);\n            uVar19 = (ulong)(int)(&DAT_002351c8)[(long)iVar12 * 8];\n            if ((&DAT_002351c8)[(long)iVar12 * 8] == -2) {\n              uVar19 = (ulong)(-(uint)(posixly_correct == 0) & 0x200) + 0x200;\n            }\n            auVar4._8_8_ = 0;\n            auVar4._0_8_ = uVar16;\n            auVar5._8_8_ = 0;\n            auVar5._0_8_ = uVar19;\n            uVar16 = SUB168(auVar4 * auVar5,0);\n            if (SUB168(auVar4 * auVar5,8) != 0) {\n              uVar22 = 1;\n              sh_erange(pcVar11,\"limit\");\n              break;\n            }\n          }\n        }\n        else {\n          if (cVar3 == 's') {\n            iVar7 = strcmp(pcVar11,\"soft\");\n            uVar16 = local_68;\n            goto joined_r0x001b5b61;\n          }\n          if ((cVar3 != 'u') || (iVar7 = strcmp(pcVar11,\"unlimited\"), iVar7 != 0))\n          goto LAB_001b5ae0;\n          uVar16 = 0xffffffffffffffff;\n        }\n        __resource = (&DAT_002351c4)[(long)iVar12 * 8];\n        if ((int)__resource < 0x100) {\n          iVar7 = getrlimit(__resource,&local_58);\n          if (-1 < iVar7) {\n            if ((DAT_00238044 == 0) || (uVar16 != 0xffffffffffffffff)) {\n              if (uVar20 != 0) goto LAB_001b5a48;\nLAB_001b5a4d:\n              if ((uVar9 & 1) != 0) {\nLAB_001b5a55:\n                local_58.rlim_max = uVar16;\n              }\n            }\n            else {\n              if ((uVar9 & 1) != 0) {\n                uVar16 = 0xffffffffffffffff;\n                if (uVar20 != 0) goto LAB_001b5a48;\n                goto LAB_001b5a55;\n              }\n              uVar16 = local_58.rlim_max;\n              if (local_58.rlim_max < local_58.rlim_cur) {\n                uVar16 = 0xffffffffffffffff;\n              }\n              if (uVar20 != 0) {\nLAB_001b5a48:\n                local_58.rlim_cur = uVar16;\n                goto LAB_001b5a4d;\n              }\n            }\n            iVar7 = setrlimit(__resource,&local_58);\n            if (-1 < iVar7) goto LAB_001b5a69;\n          }\n          piVar18 = __errno_location();\n          iVar7 = *piVar18;\n        }\n        else {\n          piVar18 = __errno_location();\n          iVar7 = 0x16;\n          *piVar18 = 0x16;\n        }\n        pcVar11 = strerror(iVar7);\n        uVar22 = 1;\n        builtin_error(\"%s: cannot modify limit: %s\",\n                      (&PTR_s_real_time_non_blocking_time_002351d0)[(long)iVar12 * 4],pcVar11);\n        break;\n      }\n      uVar19 = local_60;\n      if ((uVar17 & 2) != 0) goto LAB_001b5be8;\nLAB_001b5abe:\n      FUN_001b5380(iVar12,uVar19,1 < (int)uVar16);\nLAB_001b5a69:\n      uVar16 = (ulong)DAT_00248c4c;\n      lVar13 = lVar13 + 1;\n      piVar18 = DAT_00248c50;\n    } while ((int)lVar13 < (int)DAT_00248c4c);\n  }\n  else {\n    if (0 < (int)DAT_00248c4c) {\n      iVar7 = *DAT_00248c50;\n      goto LAB_001b5775;\n    }\n    if (loptend != (undefined8 *)0x0) goto LAB_001b58d4;\n  }\nLAB_001b5641:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar22;\n  }\nLAB_001b5cdf:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "restore_pipestatus_array": "\nvoid restore_pipestatus_array(undefined8 param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = find_variable(\"PIPESTATUS\");\n  if (((lVar1 != 0) && ((*(byte *)(lVar1 + 0x28) & 4) != 0)) && (*(long *)(lVar1 + 8) != 0)) {\n    *(undefined8 *)(lVar1 + 8) = param_1;\n    array_dispose();\n    return;\n  }\n  return;\n}\n\n",
  "__libc_current_sigrtmin": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __libc_current_sigrtmin(void)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___libc_current_sigrtmin_00237de0)();\n  return iVar1;\n}\n\n",
  "_rl_release_sigwinch": "\nvoid _rl_release_sigwinch(void)\n\n{\n  if (DAT_0024aa84 == 0) {\n    return;\n  }\n  sigprocmask(2,(sigset_t *)&DAT_0024aaa0,(sigset_t *)0x0);\n  DAT_0024aa84 = 0;\n  return;\n}\n\n",
  "seedrand32": "\nvoid seedrand32(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  long in_FS_OFFSET;\n  uint local_38;\n  uint local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  gettimeofday((timeval *)&local_38,(__timezone_ptr_t)0x0);\n  uVar1 = getpid();\n  uVar2 = getppid();\n  DAT_0023b314 = current_user ^ local_30 ^ local_38 ^ 0x1cce30 ^ uVar1 ^ uVar2;\n  DAT_0024a118 = DAT_0023b314;\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "sh_malloc": "\nvoid sh_malloc(void)\n\n{\n  FUN_001f85f0();\n  return;\n}\n\n",
  "maybe_add_history": "\nvoid maybe_add_history(undefined8 param_1)\n\n{\n  int iVar1;\n  \n  hist_last_line_added = 0;\n  iVar1 = FUN_00190710();\n  if (current_command_line_count < 2) {\n    current_command_line_comment = current_command_line_count;\n    if (iVar1 == 0) {\n      current_command_line_comment = -2;\n    }\n    current_command_first_line_saved = check_add_history(param_1,0);\n    return;\n  }\n  if (current_command_first_line_saved != 0) {\n    if (((literal_history | DAT_00240a18 | parser_state & 0x20000) == 0) && (iVar1 == 1)) {\n      current_command_line_comment = current_command_line_count;\n      return;\n    }\n    bash_add_history(param_1);\n  }\n  current_command_line_comment = -2;\n  if (iVar1 != 0) {\n    current_command_line_comment = current_command_line_count;\n  }\n  return;\n}\n\n",
  "FUN_00133bd0": "\nvoid FUN_00133bd0(void)\n\n{\n  char *pcVar1;\n  passwd *ppVar2;\n  size_t sVar3;\n  char *pcVar4;\n  \n  ppVar2 = getpwuid(current_user);\n  if (ppVar2 != (passwd *)0x0) {\n    pcVar1 = ppVar2->pw_name;\n    sVar3 = strlen(pcVar1);\n    pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"shell.c\",0x772);\n    DAT_00238050 = strcpy(pcVar4,pcVar1);\n    pcVar1 = ppVar2->pw_shell;\n    if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\\0')) {\n      DAT_00238058 = (undefined8 *)sh_xmalloc(8,\"shell.c\",0x775);\n      *DAT_00238058 = 0x68732f6e69622f;\n    }\n    else {\n      sVar3 = strlen(pcVar1);\n      pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"shell.c\",0x774);\n      DAT_00238058 = (undefined8 *)strcpy(pcVar4,pcVar1);\n    }\n    pcVar1 = ppVar2->pw_dir;\n    sVar3 = strlen(pcVar1);\n    pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"shell.c\",0x776);\n    DAT_00238060 = (undefined2 *)strcpy(pcVar4,pcVar1);\n    endpwent();\n    return;\n  }\n  DAT_00238050 = \"I have no name!\";\n  DAT_00238050 = (char *)sh_xmalloc(0x10,\"shell.c\",0x77b);\n  *(char (*) [16])DAT_00238050 = s_I_have_no_name__001fa5d0;\n  DAT_00238058 = (undefined8 *)sh_xmalloc(8,\"shell.c\",0x77c);\n  *DAT_00238058 = 0x68732f6e69622f;\n  DAT_00238060 = (undefined2 *)sh_xmalloc(2,\"shell.c\",0x77d);\n  *DAT_00238060 = 0x2f;\n  endpwent();\n  return;\n}\n\n",
  "FUN_0019e760": "\nundefined8 FUN_0019e760(undefined8 param_1)\n\n{\n  FUN_0019e5f0(param_1,all_exported_variables);\n  return 0;\n}\n\n",
  "make_new_assoc_variable": "\nlong make_new_assoc_variable(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = FUN_00152bf0(param_1,*(undefined8 *)(global_variables + 0x20));\n  uVar2 = hash_create(0x400);\n  *(uint *)(lVar1 + 0x28) = *(uint *)(lVar1 + 0x28) | 0x40;\n  *(undefined8 *)(lVar1 + 8) = uVar2;\n  return lVar1;\n}\n\n",
  "FUN_001943a0": "\nundefined8 FUN_001943a0(int param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = rl_point;\n  if (param_1 < 0) {\n    uVar2 = FUN_00194410(-param_1);\n    return uVar2;\n  }\n  FUN_00193990();\n  if (rl_point != iVar1) {\n    rl_kill_text(iVar1);\n  }\n  if (rl_editing_mode == 1) {\n    rl_mark = iVar1;\n    rl_point = rl_mark;\n    return 0;\n  }\n  rl_point = iVar1;\n  return 0;\n}\n\n",
  "shtimer_unset": "\nvoid shtimer_unset(undefined8 *param_1)\n\n{\n  long lVar1;\n  \n  *param_1 = 0;\n  param_1[1] = 0;\n  if ((*(uint *)((long)param_1 + 0x14) & 1) == 0) {\n    return;\n  }\n  *(undefined4 *)(param_1 + 3) = 0;\n  if ((*(uint *)((long)param_1 + 0x14) & 0x200) == 0) {\n    lVar1 = param_1[5];\n  }\n  else {\n    falarm(0,0);\n    lVar1 = param_1[5];\n  }\n  if ((lVar1 != 0) && ((*(byte *)((long)param_1 + 0x15) & 1) != 0)) {\n    set_signal_handler(0xe);\n    *(uint *)((long)param_1 + 0x14) = *(uint *)((long)param_1 + 0x14) & 0xfffffeff;\n    param_1[5] = 0;\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00151370": "\nbool FUN_00151370(long param_1)\n\n{\n  bool bVar1;\n  \n  bVar1 = false;\n  if ((*(uint *)(param_1 + 0x28) & 0x1000) == 0) {\n    bVar1 = (*(uint *)(param_1 + 0x28) & 0x44) != 0;\n  }\n  return bVar1;\n}\n\n",
  "clear_fifo": "\nvoid clear_fifo(int param_1)\n\n{\n  int *piVar1;\n  \n  piVar1 = (int *)(DAT_00247838 + (long)param_1 * 4);\n  if (*piVar1 != 0) {\n    DAT_00247834 = DAT_00247834 + -1;\n    *piVar1 = 0;\n  }\n  return;\n}\n\n",
  "FUN_00186440": "\nvoid FUN_00186440(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  FUN_00186410(\"argument expected\",0);\n}\n\n",
  "FUN_001934f0": "\nvoid FUN_001934f0(void)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  \n  uVar1 = hist_verify;\n  hist_verify = 0;\n  fwrite(&DAT_001ff375,1,2,rl_outstream);\n  lVar2 = pre_process_line(rl_line_buffer,1,0);\n  hist_verify = uVar1;\n  if ((rl_line_buffer != lVar2) && (lVar2 != 0)) {\n    sh_xfree(lVar2,\"bashline.c\",0xaa3);\n  }\n  putc(0xd,rl_outstream);\n  rl_forced_update_display();\n  return;\n}\n\n",
  "sv_locale": "\nvoid sv_locale(char *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  lVar2 = find_variable();\n  if (lVar2 != 0) {\n    lVar2 = get_variable_value(lVar2,lVar2);\n  }\n  if ((*param_1 == 'L') && (param_1[1] == 'A')) {\n    iVar1 = set_lang(param_1,lVar2);\n  }\n  else {\n    iVar1 = set_locale_var();\n  }\n  if ((iVar1 == 0) && (posixly_correct != 0)) {\n    set_exit_status(1);\n    return;\n  }\n  return;\n}\n\n",
  "maybe_execute_file": "\nundefined4 maybe_execute_file(undefined8 param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  \n  uVar2 = bash_tilde_expand(param_1,0);\n  uVar1 = FUN_001a7e10(uVar2,(-(uint)(param_2 == 0) & 0xfffffff8) + 9);\n  sh_xfree(uVar2,\"evalfile.c\",0x14b);\n  return uVar1;\n}\n\n",
  "find_variable_nameref_for_create": "\nundefined1 * find_variable_nameref_for_create(undefined8 param_1,uint param_2)\n\n{\n  byte bVar1;\n  int iVar2;\n  undefined1 *puVar3;\n  undefined *puVar4;\n  \n  puVar3 = (undefined1 *)find_variable_last_nameref(param_1,1);\n  if ((param_2 & 1) == 0) {\n    if (puVar3 == (undefined1 *)0x0) {\n      return (undefined1 *)0x0;\n    }\n    bVar1 = puVar3[0x29];\n  }\n  else {\n    if (puVar3 == (undefined1 *)0x0) {\n      return (undefined1 *)0x0;\n    }\n    if ((*(uint *)(puVar3 + 0x28) & 0x1800) == 0x1800) {\n      internal_warning(\"%s: removing nameref attribute\",param_1);\n      *(uint *)(puVar3 + 0x28) = *(uint *)(puVar3 + 0x28) & 0xfffff7ff;\n    }\n    bVar1 = puVar3[0x29];\n  }\n  if (((bVar1 & 8) != 0) && (iVar2 = legal_identifier(*(undefined8 *)(puVar3 + 8)), iVar2 == 0)) {\n    puVar4 = *(undefined **)(puVar3 + 8);\n    puVar3 = nameref_invalid_value;\n    if (puVar4 == (undefined *)0x0) {\n      puVar4 = &DAT_00213d70;\n    }\n    sh_invalidid(puVar4);\n  }\n  return puVar3;\n}\n\n",
  "FUN_00166850": "\nchar * FUN_00166850(char *param_1,undefined8 param_2,int param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  size_t sVar3;\n  char *pcVar4;\n  char *pcVar5;\n  char *pcVar6;\n  \n  pcVar4 = param_1;\n  if (param_1 == (char *)0x0) {\n    pcVar5 = (char *)0x0;\njoined_r0x00166995:\n    if (param_3 == 3) {\nLAB_001669a9:\n      do {\n        iVar2 = strmatch(param_2,pcVar4,(ulong)(extended_glob != 0) << 5);\n        if (iVar2 != 1) {\n          cVar1 = *pcVar4;\n          *pcVar4 = '\\0';\n          sVar3 = strlen(param_1);\n          pcVar5 = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",0x143e);\n          pcVar5 = strcpy(pcVar5,param_1);\n          *pcVar4 = cVar1;\n          return pcVar5;\n        }\n        pcVar4 = pcVar4 + 1;\n      } while (pcVar4 <= pcVar5);\n      return param_1;\n    }\n    if (param_3 == 4) goto LAB_00166960;\n    pcVar6 = pcVar5;\n    if (param_3 != 2) {\nLAB_001668a5:\n      while( true ) {\n        cVar1 = *pcVar5;\n        *pcVar5 = '\\0';\n        iVar2 = strmatch(param_2,param_1,(ulong)(extended_glob != 0) << 5);\n        *pcVar5 = cVar1;\n        if (iVar2 != 1) break;\n        pcVar5 = pcVar5 + -1;\n        if (pcVar5 < param_1) {\n          return param_1;\n        }\n      }\n      sVar3 = strlen(pcVar5);\n      pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",0x1424);\n      goto LAB_001668f5;\n    }\n  }\n  else {\n    pcVar5 = param_1;\n    if (*param_1 == '\\0') goto joined_r0x00166995;\n    sVar3 = 1;\n    if ((param_1[1] != '\\0') && (sVar3 = 2, param_1[2] != '\\0')) {\n      sVar3 = strlen(param_1);\n    }\n    pcVar5 = param_1 + sVar3;\n    if (param_3 == 3) {\n      if (pcVar5 < param_1) {\n        return param_1;\n      }\n      goto LAB_001669a9;\n    }\n    if (param_3 == 4) {\n      while( true ) {\n        if (pcVar5 < param_1) {\n          return param_1;\n        }\nLAB_00166960:\n        iVar2 = strmatch(param_2,pcVar5,(ulong)(extended_glob != 0) << 5);\n        if (iVar2 != 1) break;\n        pcVar5 = pcVar5 + -1;\n      }\n      cVar1 = *pcVar5;\n      *pcVar5 = '\\0';\n      sVar3 = strlen(param_1);\n      pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",0x144b);\n      pcVar4 = strcpy(pcVar4,param_1);\n      *pcVar5 = cVar1;\n      return pcVar4;\n    }\n    if (param_3 != 2) {\n      if (pcVar5 < param_1) {\n        return param_1;\n      }\n      goto LAB_001668a5;\n    }\n    pcVar6 = pcVar5;\n    if (pcVar5 < param_1) {\n      return param_1;\n    }\n  }\n  while( true ) {\n    pcVar5 = pcVar4;\n    cVar1 = *pcVar5;\n    *pcVar5 = '\\0';\n    iVar2 = strmatch(param_2,param_1,(ulong)(extended_glob != 0) << 5);\n    *pcVar5 = cVar1;\n    if (iVar2 != 1) break;\n    pcVar4 = pcVar5 + 1;\n    if (pcVar6 < pcVar5 + 1) {\n      return param_1;\n    }\n  }\n  sVar3 = strlen(pcVar5);\n  pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",0x1432);\nLAB_001668f5:\n  pcVar4 = strcpy(pcVar4,pcVar5);\n  return pcVar4;\n}\n\n",
  "_rl_block_sigwinch": "\nvoid _rl_block_sigwinch(void)\n\n{\n  if (DAT_0024aa84 != 0) {\n    return;\n  }\n  sigemptyset((sigset_t *)&DAT_0024ab20);\n  sigemptyset((sigset_t *)&DAT_0024aaa0);\n  sigaddset((sigset_t *)&DAT_0024ab20,0x1c);\n  sigprocmask(0,(sigset_t *)&DAT_0024ab20,(sigset_t *)&DAT_0024aaa0);\n  DAT_0024aa84 = 1;\n  return;\n}\n\n",
  "rl_macro_bind": "\nundefined8 rl_macro_bind(undefined8 param_1,char *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  size_t sVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  undefined local_34 [4];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar2 = strlen(param_2);\n  uVar3 = xmalloc(sVar2 * 2 + 1);\n  iVar1 = rl_translate_keyseq(param_2,uVar3,local_34);\n  if (iVar1 == 0) {\n    uVar4 = 0;\n    rl_generic_bind(2,param_1,uVar3,param_3);\n  }\n  else {\n    uVar4 = 0xffffffff;\n    xfree(uVar3);\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "print_comsub": "\nundefined8 print_comsub(void)\n\n{\n  DAT_00241f20 = DAT_00241f20 + 1;\n  DAT_00241f28 = 0;\n  command_string_index = 0;\n  DAT_00241f18 = 0;\n  FUN_00146230();\n  DAT_00241f20 = DAT_00241f20 + -1;\n  return the_printed_command;\n}\n\n",
  "set_signal_hard_ignored": "\nvoid set_signal_hard_ignored(int param_1)\n\n{\n  (&DAT_00247e40)[param_1] = (&DAT_00247e40)[param_1] | 2;\n  *(undefined8 *)(original_signals + (long)param_1 * 8) = 1;\n  return;\n}\n\n",
  "FUN_001f6f50": "\nchar * FUN_001f6f50(char *param_1,long param_2,int param_3)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *__dest;\n  size_t sVar3;\n  char *__dest_00;\n  \n  sVar2 = strlen((char *)(param_2 + param_3));\n  if ((param_1 == (char *)0x0) || (*param_1 == '\\0')) {\n    __dest = (char *)xmalloc((long)((int)sVar2 + 1));\n    __dest_00 = __dest;\n  }\n  else {\n    sVar3 = strlen(param_1);\n    iVar1 = (int)sVar3;\n    __dest = (char *)xmalloc((long)((int)sVar2 + 1 + iVar1));\n    __dest_00 = __dest;\n    if (iVar1 != 0) {\n      strcpy(__dest,param_1);\n      __dest_00 = __dest + iVar1;\n    }\n  }\n  strcpy(__dest_00,(char *)(param_2 + param_3));\n  return __dest;\n}\n\n",
  "FUN_00194ff0": "\nvoid FUN_00194ff0(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  uVar3 = rl_completion_entry_function;\n  uVar2 = rl_attempted_completion_function;\n  uVar1 = rl_ignore_some_completions_function;\n  rl_completion_entry_function = command_word_completion_function;\n  rl_attempted_completion_function = 0;\n  rl_complete_internal(0x3f);\n  rl_completion_entry_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar2;\n  rl_ignore_some_completions_function = uVar1;\n  return;\n}\n\n",
  "rl_emacs_editing_mode": "\nundefined8 rl_emacs_editing_mode(void)\n\n{\n  rl_editing_mode = 1;\n  _rl_keymap = emacs_standard_keymap;\n  rl_insert_mode = 1;\n  if (_rl_show_mode_in_prompt == 0) {\n    return 0;\n  }\n  _rl_reset_prompt();\n  return 0;\n}\n\n",
  "FUN_0018a8b0": "\nlong FUN_0018a8b0(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  \n  lVar1 = make_array_variable_value();\n  if (*(code **)(param_1 + 0x20) == (code *)0x0) {\n    if ((*(byte *)(param_1 + 0x28) & 0x40) == 0) {\n      array_insert(*(undefined8 *)(param_1 + 8),param_2,lVar1);\n    }\n    else {\n      assoc_insert(*(undefined8 *)(param_1 + 8),param_3);\n    }\n  }\n  else {\n    (**(code **)(param_1 + 0x20))(param_1,lVar1,param_2,param_3);\n  }\n  if (lVar1 != 0) {\n    sh_xfree(lVar1,\"arrayfunc.c\",0xf3);\n  }\n  *(uint *)(param_1 + 0x28) = *(uint *)(param_1 + 0x28) & 0xffffefff;\n  return param_1;\n}\n\n",
  "FUN_00191ae0": "\nvoid FUN_00191ae0(undefined8 *param_1,code *param_2)\n\n{\n  long *plVar1;\n  undefined8 uVar2;\n  int iVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  undefined8 uVar6;\n  int iVar7;\n  long *plVar8;\n  long lVar9;\n  long unaff_R14;\n  int local_44;\n  long *local_40;\n  \n  if (param_1[1] == 0) {\n    if ((force_fignore != 0) && (iVar7 = (*param_2)(*param_1), iVar7 == 0)) {\n      sh_xfree(*param_1,\"bashline.c\",0xbba);\n      *param_1 = 0;\n    }\n    return;\n  }\n  local_40 = param_1 + 1;\n  lVar9 = 2;\n  do {\n    iVar7 = (int)lVar9;\n    plVar8 = param_1 + lVar9;\n    lVar9 = lVar9 + 1;\n  } while (*plVar8 != 0);\n  puVar4 = (undefined8 *)strvec_create(iVar7 + 1);\n  if (force_fignore == 0) {\n    unaff_R14 = strvec_create(iVar7 + -1);\n  }\n  *puVar4 = *param_1;\n  if (param_1[1] == 0) {\n    puVar4[1] = 0;\n  }\n  else {\n    local_44 = 0;\n    iVar7 = 1;\n    plVar8 = local_40;\nLAB_00191b8d:\n    do {\n      iVar3 = (*param_2)();\n      if (iVar3 == 0) {\n        lVar9 = *plVar8;\n        if (force_fignore == 0) {\n          plVar8 = plVar8 + 1;\n          *(long *)(unaff_R14 + (long)local_44 * 8) = lVar9;\n          local_44 = local_44 + 1;\n          if (*plVar8 == 0) break;\n          goto LAB_00191b8d;\n        }\n        sh_xfree(lVar9,\"bashline.c\",0xbd5);\n      }\n      else {\n        lVar9 = (long)iVar7;\n        iVar7 = iVar7 + 1;\n        puVar4[lVar9] = *plVar8;\n      }\n      plVar1 = plVar8 + 1;\n      plVar8 = plVar8 + 1;\n    } while (*plVar1 != 0);\n    puVar4[iVar7] = 0;\n    if (iVar7 != 1) {\n      if (force_fignore == 0) {\n        lVar9 = (long)local_44;\n        while (local_44 != 0) {\n          lVar5 = lVar9 * 8;\n          lVar9 = lVar9 + -1;\n          sh_xfree(*(undefined8 *)(unaff_R14 + -8 + lVar5),\"bashline.c\",0xbec);\n          local_44 = (int)lVar9;\n        }\n        sh_xfree(unaff_R14,\"bashline.c\",0xbed);\n      }\n      if (iVar7 == 2) {\n        sh_xfree(*param_1,\"bashline.c\",0xbf3);\n        uVar2 = puVar4[1];\n        uVar6 = 0xbf6;\n        param_1[1] = 0;\n        *param_1 = uVar2;\n      }\n      else {\n        lVar9 = puVar4[1];\n        lVar5 = 8;\n        if (lVar9 != 0) {\n          do {\n            *(long *)((long)param_1 + lVar5) = lVar9;\n            lVar5 = lVar5 + 8;\n            lVar9 = *(long *)((long)puVar4 + lVar5);\n          } while (lVar9 != 0);\n          local_40 = (long *)(lVar5 + (long)param_1);\n        }\n        uVar6 = 0xbff;\n        *local_40 = 0;\n      }\n      goto LAB_00191c2b;\n    }\n  }\n  if (force_fignore == 0) {\n    sh_xfree(unaff_R14,\"bashline.c\",0xbe3);\n  }\n  else {\n    sh_xfree(*param_1,\"bashline.c\",0xbdf);\n    *param_1 = 0;\n  }\n  uVar6 = 0xbe5;\nLAB_00191c2b:\n  sh_xfree(puVar4,\"bashline.c\",uVar6);\n  return;\n}\n\n",
  "array_from_word_list": "\nundefined8 array_from_word_list(long *param_1)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  \n  if (param_1 != (long *)0x0) {\n    uVar1 = array_create();\n    lVar2 = 0;\n    do {\n      array_insert(uVar1,lVar2,*(undefined8 *)param_1[1]);\n      param_1 = (long *)*param_1;\n      lVar2 = lVar2 + 1;\n    } while (param_1 != (long *)0x0);\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "_hs_at_end_of_history": "\nbool _hs_at_end_of_history(void)\n\n{\n  return DAT_0024b6e8 == 0 || history_offset == history_length;\n}\n\n",
  "run_unwind_protects": "\nvoid run_unwind_protects(void)\n\n{\n  if (DAT_00248390 != 0) {\n    FUN_001840b0(0);\n    return;\n  }\n  return;\n}\n\n",
  "rl_reset_terminal": "\nundefined8 rl_reset_terminal(void)\n\n{\n  _rl_screenheight = 0;\n  _rl_screenwidth = 0;\n  _rl_init_terminal_io();\n  return 0;\n}\n\n",
  "wcswidth": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcswidth(wchar_t *__s,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wcswidth_00237900)();\n  return iVar1;\n}\n\n",
  "FUN_001921d0": "\nundefined4 FUN_001921d0(char *param_1)\n\n{\n  undefined4 uVar1;\n  size_t sVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  char *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*param_1 == '~') {\n    local_28 = (char *)bash_tilde_expand(param_1,0);\n  }\n  else {\n    sVar2 = strlen(param_1);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"bashline.c\",0xc44);\n    local_28 = strcpy(pcVar3,param_1);\n  }\n  FUN_00191f40(&local_28);\n  pcVar3 = local_28;\n  uVar1 = file_isdir(local_28);\n  sh_xfree(pcVar3,\"bashline.c\",0xc47);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_vi_change_to": "\nint rl_vi_change_to(undefined8 param_1,ulong param_2)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  ushort **ppuVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  \n  puVar1 = _rl_vimvcxt;\n  uVar7 = (undefined4)(param_2 & 0xffffffff);\n  if (_rl_vi_redoing == 0) {\n    if (_rl_vimvcxt == (undefined8 *)0x0) {\n      puVar4 = (undefined8 *)xmalloc(0x24);\n      *puVar4 = 2;\n      rl_mark = rl_point;\n      uVar6 = rl_end;\n      puVar4[1] = 0;\n      *(undefined4 *)(puVar4 + 2) = 0xffffffff;\n      *(undefined4 *)((long)puVar4 + 0x14) = rl_mark;\n      *(undefined4 *)(puVar4 + 3) = uVar6;\n      *(undefined4 *)((long)puVar4 + 0x1c) = uVar7;\n      *(undefined4 *)(puVar4 + 4) = 0xffffffff;\n      puVar5 = (undefined8 *)0x0;\n      _rl_vimvcxt = puVar4;\n    }\n    else {\n      *_rl_vimvcxt = 2;\n      rl_mark = rl_point;\n      uVar6 = rl_end;\n      puVar1[1] = 0;\n      *(undefined4 *)(puVar1 + 2) = 0xffffffff;\n      *(undefined4 *)((long)puVar1 + 0x14) = rl_mark;\n      *(undefined4 *)(puVar1 + 3) = uVar6;\n      *(int *)((long)puVar1 + 0x1c) = (int)param_2;\n      *(undefined4 *)(puVar1 + 4) = 0xffffffff;\n      puVar5 = (undefined8 *)0x0;\n      puVar4 = puVar1;\n    }\n  }\n  else {\n    puVar4 = (undefined8 *)xmalloc(0x24);\n    *puVar4 = 2;\n    rl_mark = rl_point;\n    uVar6 = rl_end;\n    puVar4[1] = 0;\n    *(undefined4 *)(puVar4 + 2) = 0xffffffff;\n    *(undefined4 *)((long)puVar4 + 0x14) = rl_mark;\n    *(undefined4 *)(puVar4 + 3) = uVar6;\n    *(undefined4 *)((long)puVar4 + 0x1c) = uVar7;\n    *(undefined4 *)(puVar4 + 4) = 0xffffffff;\n    puVar5 = puVar1;\n    _rl_vimvcxt = puVar4;\n  }\n  *(undefined4 *)((long)puVar4 + 0x14) = rl_mark;\n  ppuVar3 = __ctype_b_loc();\n  if ((*(byte *)((long)*ppuVar3 + (param_2 & 0xff) * 2 + 1) & 1) == 0) {\n    if (_rl_vi_redoing != 0) {\n      if (DAT_0024a400 == 99) {\n        *(undefined4 *)(puVar4 + 4) = 99;\n        rl_mark = uVar6;\n        rl_beg_of_line(1,param_2 & 0xffffffff);\n        rl_readline_state = rl_readline_state & 0xffffffffffefffff;\n        iVar2 = FUN_001cff80(_rl_vimvcxt);\n      }\n      else {\n        *(int *)(puVar4 + 4) = DAT_0024a400;\n        iVar2 = FUN_001d23d0(puVar4);\n      }\n      goto joined_r0x001d2a75;\n    }\n    if ((rl_readline_state & 0x80000) != 0) {\n      rl_readline_state = rl_readline_state | 0x100000;\n      return 0;\n    }\n    iVar2 = _rl_bracketed_read_key();\n    *(int *)(puVar4 + 4) = iVar2;\n    if (-1 < iVar2) {\n      iVar2 = FUN_001d2470(puVar4);\n      goto joined_r0x001d2a75;\n    }\n    *(undefined4 *)(puVar4 + 4) = 0;\n  }\n  else {\n    *(undefined4 *)(puVar4 + 4) = 0x24;\n    iVar2 = FUN_001d23d0(puVar4);\njoined_r0x001d2a75:\n    if (-1 < iVar2) goto LAB_001d2a77;\n  }\n  rl_ding();\n  iVar2 = -1;\nLAB_001d2a77:\n  xfree(_rl_vimvcxt);\n  _rl_vimvcxt = puVar5;\n  return iVar2;\n}\n\n",
  "readdir": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ndirent * readdir(DIR *__dirp)\n\n{\n  dirent *pdVar1;\n  \n  pdVar1 = (dirent *)(*(code *)PTR_readdir_00237bc8)();\n  return pdVar1;\n}\n\n",
  "_rl_insert_typein": "\nvoid _rl_insert_typein(undefined param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  undefined *puVar4;\n  long lVar5;\n  \n  puVar4 = (undefined *)xmalloc(0x200);\n  iVar2 = DAT_0024b3e4;\n  iVar3 = DAT_0024b3e0;\n  lVar5 = 1;\n  *puVar4 = param_1;\n  if (iVar3 != iVar2) {\n    do {\n      DAT_0024b3e4 = iVar2 + 1;\n      if (0x1ff < DAT_0024b3e4) {\n        DAT_0024b3e4 = 0;\n      }\n      if ((_rl_keymap[(ulong)(byte)(&DAT_0024b1e0)[iVar2] * 0x10] != '\\0') ||\n         (*(code **)(_rl_keymap + (ulong)(byte)(&DAT_0024b1e0)[iVar2] * 0x10 + 8) != rl_insert)) {\n        _rl_unget_char();\n        goto LAB_001eb21e;\n      }\n      puVar4[lVar5] = (&DAT_0024b1e0)[iVar2];\n      iVar1 = (int)lVar5;\n      lVar5 = lVar5 + 1;\n      iVar2 = DAT_0024b3e4;\n    } while (DAT_0024b3e4 != iVar3);\n    lVar5 = (long)(iVar1 + 1);\n  }\nLAB_001eb21e:\n  puVar4[lVar5] = 0;\n  rl_insert_text(puVar4);\n  xfree(puVar4);\n  return;\n}\n\n",
  "read_history_range": "\nint read_history_range(undefined8 param_1,int param_2,int param_3)\n\n{\n  bool bVar1;\n  bool bVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  int iVar6;\n  char *__file;\n  char *__buf;\n  ssize_t sVar7;\n  ushort **ppuVar8;\n  int *piVar9;\n  ulong uVar10;\n  char *pcVar11;\n  char *pcVar12;\n  char *pcVar13;\n  char *pcVar14;\n  char cVar15;\n  char cVar16;\n  long in_FS_OFFSET;\n  char *local_108;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  history_lines_read_from_file = 0;\n  __file = (char *)FUN_001f5180();\n  if (__file == (char *)0x0) {\n    piVar9 = __errno_location();\n    iVar6 = *piVar9;\n    if (iVar6 == 0) {\n      iVar6 = 5;\n    }\n    goto LAB_001f5881;\n  }\n  iVar5 = open(__file,0,0x1b6);\n  if (iVar5 < 0) {\n    piVar9 = __errno_location();\n    iVar6 = *piVar9;\n    if (iVar6 == 0) {\n      iVar6 = 5;\n      free(__file);\n      goto LAB_001f5881;\n    }\n    __buf = (char *)0x0;\n  }\n  else {\n    iVar6 = fstat(iVar5,&local_d8);\n    if (iVar6 == -1) {\n      piVar9 = __errno_location();\n      iVar6 = *piVar9;\n      if (iVar6 == 0) {\n        close(iVar5);\n        __buf = (char *)0x0;\n        iVar6 = 5;\n      }\n      else {\n        close(iVar5);\n        __buf = (char *)0x0;\n      }\n    }\n    else if ((local_d8.st_mode & 0xf000) == 0x8000) {\n      if (local_d8.st_size == 0xffffffffffffffff) {\n        piVar9 = __errno_location();\n        __buf = (char *)0x0;\n        iVar6 = 0x1b;\n        *piVar9 = 0x1b;\n        close(iVar5);\n      }\n      else {\n        if (local_d8.st_size == 0) {\n          iVar6 = 0;\n          xfree(__file);\n          close(iVar5);\n          goto LAB_001f5881;\n        }\n        __buf = (char *)malloc(local_d8.st_size + 1);\n        if (__buf == (char *)0x0) {\n          piVar9 = __errno_location();\n          iVar6 = 0x1b;\n          *piVar9 = 0x1b;\n          close(iVar5);\n        }\n        else {\n          sVar7 = read(iVar5,__buf,local_d8.st_size);\n          iVar6 = (int)sVar7;\n          if (-1 < iVar6) {\n            close(iVar5);\n            cVar16 = history_comment_char;\n            if (param_3 < 0) {\n              param_3 = iVar6;\n            }\n            pcVar11 = __buf + iVar6;\n            *pcVar11 = '\\0';\n            if ((cVar16 == '\\0') && (*__buf == '#')) {\n              ppuVar8 = __ctype_b_loc();\n              uVar10 = (ulong)(byte)__buf[1];\n              if ((*(byte *)((long)*ppuVar8 + uVar10 * 2 + 1) & 8) == 0) goto LAB_001f577e;\n              history_comment_char = '#';\n              cVar16 = '#';\n              bVar2 = true;\nLAB_001f5b5c:\n              if (((*ppuVar8)[uVar10] & 0x800) == 0) {\n                local_108 = (char *)0x0;\n                bVar1 = false;\n              }\n              else {\n                bVar1 = true;\n                history_multiline_entries =\n                     (history_multiline_entries + 1) - (uint)(history_write_timestamps == 0);\n                local_108 = __buf;\n              }\n            }\n            else {\n              if (cVar16 == *__buf) {\n                ppuVar8 = __ctype_b_loc();\n                uVar10 = (ulong)(byte)__buf[1];\n                bVar2 = false;\n                goto LAB_001f5b5c;\n              }\nLAB_001f577e:\n              bVar2 = false;\n              bVar1 = false;\n              local_108 = (char *)0x0;\n            }\n            pcVar13 = __buf;\n            if ((__buf < pcVar11) && (0 < param_2)) {\n              iVar5 = 0;\n              pcVar14 = __buf;\n              do {\n                pcVar12 = pcVar14 + 1;\n                pcVar3 = local_108;\n                if ((*pcVar14 == '\\n') &&\n                   ((((cVar15 = pcVar14[1], pcVar13 = pcVar12, cVar15 != cVar16 ||\n                      (ppuVar8 = __ctype_b_loc(), pcVar3 = pcVar12,\n                      (*(byte *)((long)*ppuVar8 + (ulong)(byte)pcVar14[2] * 2 + 1) & 8) == 0)) &&\n                     (iVar5 = iVar5 + 1, pcVar3 = local_108, param_2 <= iVar5)) && (bVar1)))) {\n                  if (pcVar12 < pcVar11) {\n                    do {\n                      pcVar12 = pcVar12 + 1;\n                      if (cVar15 == '\\n') goto LAB_001f5829;\n                      cVar15 = *pcVar12;\n                      pcVar13 = pcVar11;\n                    } while (pcVar11 != pcVar12);\n                  }\n                  pcVar12 = pcVar13 + 1;\n                  if (cVar15 == '\\n') {\nLAB_001f5829:\n                    pcVar13 = pcVar12;\n                  }\n                }\n                local_108 = pcVar3;\n                pcVar4 = pcVar13;\n                pcVar3 = local_108;\n              } while ((pcVar12 < pcVar11) && (pcVar14 = pcVar12, iVar5 < param_2));\n            }\n            else {\n              iVar5 = 0;\n              pcVar4 = __buf;\n              pcVar3 = local_108;\n            }\n            do {\n              do {\n                local_108 = pcVar4;\n                pcVar14 = pcVar13;\n                if (pcVar11 <= pcVar14) goto LAB_001f5990;\n                pcVar13 = pcVar14 + 1;\n                pcVar4 = local_108;\n              } while (*pcVar14 != '\\n');\n              if ((local_108 < pcVar14) && (pcVar14[-1] == '\\r')) {\n                pcVar14[-1] = '\\0';\n              }\n              else {\n                *pcVar14 = '\\0';\n              }\n              if (*local_108 == '\\0') {\n                iVar5 = iVar5 + 1;\n                local_108 = pcVar3;\n              }\n              else if ((*local_108 != history_comment_char) ||\n                      (ppuVar8 = __ctype_b_loc(),\n                      (*(byte *)((long)*ppuVar8 + (ulong)(byte)local_108[1] * 2 + 1) & 8) == 0)) {\n                iVar5 = iVar5 + 1;\n                if (pcVar3 == (char *)0x0) {\n                  if ((history_length < 1) || (history_multiline_entries == 0)) {\n                    add_history(local_108);\n                    local_108 = pcVar3;\n                  }\n                  else {\n                    _hs_append_history_line(history_length + -1,local_108);\n                    local_108 = pcVar3;\n                  }\n                }\n                else {\n                  add_history(local_108);\n                  add_history_time(pcVar3);\n                  local_108 = (char *)0x0;\n                }\n              }\n              pcVar4 = pcVar13;\n              pcVar3 = local_108;\n            } while (iVar5 < param_3);\nLAB_001f5990:\n            if (bVar2) {\n              history_comment_char = '\\0';\n            }\n            iVar6 = 0;\n            history_lines_read_from_file = iVar5;\n            free(__file);\n            free(__buf);\n            goto LAB_001f5881;\n          }\n          piVar9 = __errno_location();\n          iVar6 = *piVar9;\n          if (iVar6 == 0) {\n            iVar6 = 5;\n          }\n          close(iVar5);\n        }\n      }\n    }\n    else {\n      piVar9 = __errno_location();\n      __buf = (char *)0x0;\n      iVar6 = 0x16;\n      *piVar9 = 0x16;\n      close(iVar5);\n    }\n  }\n  free(__file);\n  if (__buf != (char *)0x0) {\n    free(__buf);\n  }\nLAB_001f5881:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar6;\n}\n\n",
  "save_bash_argv": "\nvoid save_bash_argv(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = list_rest_of_args();\n  push_args(uVar1);\n  dispose_words(uVar1);\n  return;\n}\n\n",
  "FUN_0015e9f0": "\nvoid FUN_0015e9f0(void)\n\n{\n  bool bVar1;\n  int iVar2;\n  long lVar3;\n  long lVar4;\n  int iVar5;\n  int iVar6;\n  ulong uVar7;\n  \n  iVar2 = DAT_0024253c;\n  iVar6 = (int)js;\n  uVar7 = js & 0xffffffff;\n  iVar5 = DAT_0024253c;\n  if ((iVar6 <= DAT_0024253c) && (DAT_00242538 < DAT_0024253c)) goto LAB_0015ea7f;\n  if (DAT_0024253c == 0) {\n    memset(pidstat_table,0xff,0x4000);\n    DAT_00242538 = 0;\n    if (-1 < iVar6) {\n      bVar1 = true;\n      iVar5 = 0x200;\n      goto LAB_0015ea31;\n    }\n    uVar7 = 0x8000;\n    iVar5 = 0x200;\nLAB_0015ea40:\n    do {\n      iVar6 = (int)uVar7;\n      iVar5 = iVar5 * 2;\n      if (iVar5 < 1) break;\n    } while (iVar5 < iVar6);\n  }\n  else {\n    bVar1 = 0 < DAT_0024253c;\n    if (iVar6 < 0) {\n      uVar7 = 0x8000;\n    }\nLAB_0015ea31:\n    iVar6 = (int)uVar7;\n    if ((iVar5 < iVar6) && (bVar1)) goto LAB_0015ea40;\n  }\n  if ((0x7fff < iVar5 - 1U) && (iVar5 = 0x8000, 0x8000 < iVar6)) {\n    iVar6 = 0x8000;\n  }\n  if (iVar2 < iVar6) {\n    bgpids = sh_xrealloc(bgpids,(long)iVar5 << 4,\"jobs.c\",0x315);\n    if (DAT_0024253c < iVar5) {\n      lVar4 = (long)DAT_0024253c * 0x10 + bgpids;\n      lVar3 = bgpids + ((long)DAT_0024253c + 1 + (ulong)((iVar5 - DAT_0024253c) - 1)) * 0x10;\n      do {\n        *(undefined4 *)(lVar4 + 8) = 0xffffffff;\n        lVar4 = lVar4 + 0x10;\n      } while (lVar4 != lVar3);\n    }\n  }\n  else {\n    iVar5 = DAT_0024253c;\n    if (iVar2 <= DAT_00242538) {\n      DAT_00242538 = 0;\n    }\n  }\nLAB_0015ea7f:\n  DAT_0024253c = iVar5;\n  FUN_0015e640(DAT_00242538);\n  DAT_00242538 = DAT_00242538 + 1;\n  return;\n}\n\n",
  "print_word_list": "\nvoid print_word_list(long *param_1,undefined *param_2)\n\n{\n  undefined *puVar1;\n  \n  if (param_1 == (long *)0x0) {\n    return;\n  }\n  do {\n    puVar1 = &DAT_00213d70;\n    if (*param_1 != 0) {\n      puVar1 = param_2;\n    }\n    FUN_00144560(&DAT_001fc632,*(undefined8 *)param_1[1],puVar1);\n    param_1 = (long *)*param_1;\n  } while (param_1 != (long *)0x0);\n  return;\n}\n\n",
  "evalstring": "\nundefined4 evalstring(undefined8 param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  int local_10;\n  \n  iVar3 = running_trap;\n  iVar1 = return_catch_flag;\n  local_10 = 0;\n  if (return_catch_flag != 0) {\n    begin_unwind_frame(\"evalstring\");\n    unwind_protect_mem(&return_catch_flag,4);\n    unwind_protect_mem(return_catch,200);\n    return_catch_flag = return_catch_flag + 1;\n    local_10 = __sigsetjmp(return_catch,0);\n  }\n  if (local_10 == 0) {\n    uVar2 = parse_and_execute(param_1,param_2,param_3);\n  }\n  else {\n    if (0 < running_trap) {\n      if (iVar3 != running_trap) {\n        run_trap_cleanup(running_trap + -1);\n      }\n      unfreeze_jobs_list();\n    }\n    iVar3 = have_unwind_protects();\n    if (iVar3 == 0) {\n      parse_and_execute_level = 0;\n      uVar2 = return_catch_value;\n    }\n    else {\n      run_unwind_frame(\"parse_and_execute top\");\n      uVar2 = return_catch_value;\n    }\n  }\n  if (((iVar1 != 0) && (run_unwind_frame(\"evalstring\"), local_10 != 0)) && (return_catch_flag != 0))\n  {\n    return_catch_value = uVar2;\n                    /* WARNING: Subroutine does not return */\n    __longjmp_chk(return_catch,1);\n  }\n  return uVar2;\n}\n\n",
  "execute_variable_command": "\nvoid execute_variable_command(char *param_1,undefined8 param_2)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  undefined auStack_148 [264];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  save_parser_state(auStack_148);\n  pcVar1 = (char *)get_string_value(\"_\");\n  if (pcVar1 == (char *)0x0) {\n    sVar2 = strlen(param_1);\n    pcVar1 = (char *)sh_xmalloc(sVar2 + 1,\"/usr/local/src/chet/src/bash/src/parse.y\",0xb0e);\n    pcVar1 = strcpy(pcVar1,param_1);\n    parse_and_execute(pcVar1,param_2,5);\n    restore_parser_state(auStack_148);\n    bind_variable(\"_\",0,0);\n  }\n  else {\n    sVar2 = strlen(pcVar1);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"/usr/local/src/chet/src/bash/src/parse.y\",0xb0c);\n    pcVar1 = strcpy(pcVar3,pcVar1);\n    sVar2 = strlen(param_1);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"/usr/local/src/chet/src/bash/src/parse.y\",0xb0e);\n    pcVar3 = strcpy(pcVar3,param_1);\n    parse_and_execute(pcVar3,param_2,5);\n    restore_parser_state(auStack_148);\n    bind_variable(\"_\",pcVar1,0);\n    sh_xfree(pcVar1,\"/usr/local/src/chet/src/bash/src/parse.y\",0xb12);\n  }\n  if (DAT_00240b58 == 10) {\n    DAT_00240b58 = 0;\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_forward_byte": "\nundefined8 rl_forward_byte(int param_1)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  \n  if (param_1 < 0) {\n    uVar1 = rl_backward_byte(-param_1);\n    return uVar1;\n  }\n  iVar2 = rl_point;\n  if (param_1 != 0) {\n    iVar2 = param_1 + rl_point;\n    if ((rl_end < 1) || (rl_editing_mode != 0)) {\n      rl_point = rl_end;\n      if (rl_end < iVar2) goto LAB_001eebab;\n    }\n    else {\n      rl_point = rl_end - (uint)(_rl_keymap == vi_movement_keymap);\n      if (rl_point < iVar2) {\nLAB_001eebab:\n        rl_ding();\n        if (rl_end < 0) {\n          rl_end = 0;\n        }\n        return 0;\n      }\n    }\n  }\n  rl_point = iVar2;\n  if (rl_end < 0) {\n    rl_end = 0;\n    return 0;\n  }\n  return 0;\n}\n\n",
  "rl_yank_nth_arg": "\nvoid rl_yank_nth_arg(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_001e9190(param_1,param_2,0);\n  return;\n}\n\n",
  "sv_strict_posix": "\nvoid sv_strict_posix(void)\n\n{\n  long lVar1;\n  \n  lVar1 = find_variable();\n  posixly_correct = 0;\n  if (lVar1 != 0) {\n    posixly_correct = (uint)(*(long *)(lVar1 + 8) != 0);\n  }\n  posix_initialize();\n  if (interactive_shell == 0) {\n    set_shellopts();\n    return;\n  }\n  posix_readline_initialize(posixly_correct);\n  set_shellopts();\n  return;\n}\n\n",
  "FUN_00151340": "\nbool FUN_00151340(long param_1)\n\n{\n  bool bVar1;\n  \n  bVar1 = false;\n  if ((*(uint *)(param_1 + 0x28) & 0x1020) == 0x20) {\n    bVar1 = *(int *)(param_1 + 0x2c) == variable_context;\n  }\n  return bVar1;\n}\n\n",
  "FUN_0019e780": "\nundefined8 FUN_0019e780(undefined8 param_1)\n\n{\n  FUN_0019e5f0(param_1,all_visible_functions);\n  return 0;\n}\n\n",
  "FUN_001b6f00": "\nundefined8 FUN_001b6f00(void)\n\n{\n  set_directory_hook();\n  return 0;\n}\n\n",
  "FUN_00133930": "\nint FUN_00133930(long param_1,int param_2,int param_3,int param_4)\n\n{\n  undefined8 *puVar1;\n  char *pcVar2;\n  undefined8 *puVar3;\n  undefined8 uVar4;\n  undefined8 *puVar5;\n  size_t sVar6;\n  char *pcVar7;\n  undefined8 *puVar8;\n  undefined8 *puVar9;\n  \n  if (param_3 <= param_2) {\n    return param_2;\n  }\n  puVar5 = (undefined8 *)0x0;\n  puVar8 = (undefined8 *)(param_1 + (long)param_2 * 8);\n  puVar1 = (undefined8 *)\n           (param_1 + 8 + ((ulong)(uint)((param_3 + -1) - param_2) + (long)param_2) * 8);\n  puVar9 = (undefined8 *)0x0;\n  do {\n    while (puVar5 != (undefined8 *)0x0) {\n      uVar4 = make_word(*puVar8);\n      puVar8 = puVar8 + 1;\n      puVar3 = (undefined8 *)make_word_list(uVar4,0);\n      *puVar9 = puVar3;\n      puVar9 = puVar3;\n      if (puVar8 == puVar1) goto LAB_001339b4;\n    }\n    uVar4 = make_word(*puVar8);\n    puVar8 = puVar8 + 1;\n    puVar5 = (undefined8 *)make_word_list(uVar4,0);\n    puVar9 = puVar5;\n  } while (puVar8 != puVar1);\nLAB_001339b4:\n  if (puVar5 != (undefined8 *)0x0) {\n    if (param_4 == 0) {\n      pcVar2 = *(char **)puVar5[1];\n      sVar6 = strlen(pcVar2);\n      pcVar7 = (char *)sh_xmalloc(sVar6 + 1,\"shell.c\",0x5de);\n      shell_name = strcpy(pcVar7,pcVar2);\n      if (dollar_vars != (char *)0x0) {\n        sh_xfree(dollar_vars,\"shell.c\",0x5df);\n      }\n      pcVar2 = *(char **)puVar5[1];\n      sVar6 = strlen(pcVar2);\n      pcVar7 = (char *)sh_xmalloc(sVar6 + 1,\"shell.c\",0x5e0);\n      dollar_vars = strcpy(pcVar7,pcVar2);\n      remember_args(*puVar5,1);\n      if (debugging_mode != 0) {\n        push_args(*puVar5);\n        bash_argv_initialized = 1;\n      }\n    }\n    else {\n      remember_args(puVar5,1);\n      if (debugging_mode != 0) {\n        push_args(puVar5);\n        bash_argv_initialized = 1;\n      }\n    }\n    dispose_words(puVar5);\n  }\n  return param_3;\n}\n\n",
  "kill": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint kill(__pid_t __pid,int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_kill_00237b88)();\n  return iVar1;\n}\n\n",
  "sigprocmask": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigprocmask(int __how,sigset_t *__set,sigset_t *__oset)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigprocmask_00237818)();\n  return iVar1;\n}\n\n",
  "history_get_time": "\nlong history_get_time(long param_1)\n\n{\n  char *pcVar1;\n  int *piVar2;\n  long lVar3;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  pcVar1 = *(char **)(param_1 + 8);\n  if ((pcVar1 != (char *)0x0) && (*pcVar1 == history_comment_char)) {\n    piVar2 = __errno_location();\n    *piVar2 = 0;\n    lVar3 = strtol(pcVar1 + 1,(char **)0x0,10);\n    if (*piVar2 != 0x22) {\n      return lVar3;\n    }\n  }\n  return 0;\n}\n\n",
  "maybe_call_trap_handler": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nuint maybe_call_trap_handler(int param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = (&DAT_00247e40)[param_1] & 1;\n  if (uVar1 != 0) {\n    if (((&DAT_00247e40)[param_1] & 0x40) != 0) {\n      return 0;\n    }\n    if (param_1 == 0x41) {\n      run_debug_trap();\n    }\n    else {\n      if (param_1 < 0x42) {\n        if (param_1 == 0) {\n          run_exit_trap();\n          return uVar1;\n        }\n        if (param_1 == 2) {\n          pending_traps._8_4_ = 0;\n          DAT_00247e28 = 0;\n          FUN_001811f0(2,\"interrupt trap\");\n          return uVar1;\n        }\n      }\n      else if (param_1 == 0x42) {\n        if ((_DAT_00247f48 & 0x51) != 1) {\n          return uVar1;\n        }\n        FUN_001811f0(0x42,\"error trap\");\n        return uVar1;\n      }\n      trap_handler();\n    }\n  }\n  return uVar1;\n}\n\n",
  "_rl_print_color_indicator": "\nundefined8 _rl_print_color_indicator(char *param_1)\n\n{\n  size_t __n;\n  char cVar1;\n  int iVar2;\n  uint uVar3;\n  size_t sVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  long lVar7;\n  size_t *psVar8;\n  ulong uVar9;\n  long in_FS_OFFSET;\n  char *local_160;\n  stat local_158;\n  stat local_c8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_160 = (char *)0x0;\n  if (rl_filename_stat_hook != (code *)0x0) {\n    sVar4 = strlen(param_1);\n    pcVar5 = (char *)xmalloc(sVar4 + 1);\n    local_160 = strcpy(pcVar5,param_1);\n    (*rl_filename_stat_hook)(&local_160);\n    param_1 = local_160;\n  }\n  iVar2 = lstat(param_1,&local_158);\n  if (iVar2 == 0) {\n    uVar3 = local_158.st_mode & 0xf000;\n    if (uVar3 == 0xa000) {\n      iVar2 = stat(param_1,&local_c8);\n      if (iVar2 == 0) {\n        iVar2 = strncmp(PTR_s_01_36_00240658,\"target\",6);\n        if (iVar2 == 0) {\n          uVar3 = local_c8.st_mode & 0xf000;\n          local_158.st_mode = local_c8.st_mode;\n          goto LAB_001f792e;\n        }\n      }\n      else if (DAT_002406b8 != 0) {\nLAB_001f7b1f:\n        free(local_160);\n        lVar7 = 0xd0;\n        goto LAB_001f786d;\n      }\n    }\n    else {\nLAB_001f792e:\n      pcVar5 = local_160;\n      uVar9 = (ulong)local_158.st_mode;\n      if (uVar3 == 0x8000) {\n        if (((local_158.st_mode & 0x800) != 0) && (cVar1 = FUN_001f7550(0x10), cVar1 != '\\0')) {\n          lVar7 = 0x100;\n          free(pcVar5);\n          goto LAB_001f786d;\n        }\n        uVar3 = (uint)uVar9;\n        if (((uVar9 & 0x400) != 0) && (cVar1 = FUN_001f7550(0x11), cVar1 != '\\0')) {\n          lVar7 = 0x110;\n          free(pcVar5);\n          goto LAB_001f786d;\n        }\n        if (((uVar3 & 0x49) != 0) && (cVar1 = FUN_001f7550(0xe), cVar1 != '\\0')) {\n          lVar7 = 0xe0;\n          free(pcVar5);\n          goto LAB_001f786d;\n        }\n        if ((1 < local_158.st_nlink) && (cVar1 = FUN_001f7550(0x16), cVar1 != '\\0')) {\n          lVar7 = 0x160;\n          free(pcVar5);\n          goto LAB_001f786d;\n        }\n        goto LAB_001f79e0;\n      }\n      if (uVar3 == 0x4000) {\n        if (((local_158.st_mode & 0x202) == 0x202) && (cVar1 = FUN_001f7550(0x14), cVar1 != '\\0')) {\n          lVar7 = 0x140;\n          free(pcVar5);\n        }\n        else {\n          uVar3 = (uint)uVar9;\n          if (((uVar9 & 2) == 0) || (cVar1 = FUN_001f7550(0x13), cVar1 == '\\0')) {\n            if ((uVar3 & 0x200) == 0) {\n              lVar7 = 0x60;\n              free(pcVar5);\n            }\n            else {\n              cVar1 = FUN_001f7550(0x12);\n              if (cVar1 == '\\0') {\n                free(pcVar5);\n                lVar7 = 0x60;\n              }\n              else {\n                free(pcVar5);\n                lVar7 = 0x120;\n              }\n            }\n          }\n          else {\n            lVar7 = 0x130;\n            free(pcVar5);\n          }\n        }\n        goto LAB_001f786d;\n      }\n      if (uVar3 != 0xa000) {\n        if (uVar3 == 0x1000) {\n          free(local_160);\n          lVar7 = 0x80;\n          goto LAB_001f786d;\n        }\n        if (uVar3 == 0xc000) {\n          free(local_160);\n          lVar7 = 0x90;\n          goto LAB_001f786d;\n        }\n        if (uVar3 == 0x6000) {\n          free(local_160);\n          lVar7 = 0xa0;\n          goto LAB_001f786d;\n        }\n        if (uVar3 == 0x2000) {\n          free(local_160);\n          lVar7 = 0xb0;\n          goto LAB_001f786d;\n        }\n        goto LAB_001f7b1f;\n      }\n    }\n    free(local_160);\n    lVar7 = 0x70;\n  }\n  else {\n    pcVar5 = local_160;\n    if (DAT_002406a8 != 0) {\n      lVar7 = 0xc0;\n      free(local_160);\n      goto LAB_001f786d;\n    }\nLAB_001f79e0:\n    sVar4 = strlen(param_1);\n    for (psVar8 = _rl_color_ext_list; psVar8 != (size_t *)0x0; psVar8 = (size_t *)psVar8[4]) {\n      __n = *psVar8;\n      if ((__n <= sVar4) &&\n         (iVar2 = strncmp(param_1 + (sVar4 - __n),(char *)psVar8[1],__n), iVar2 == 0)) {\n        psVar8 = psVar8 + 2;\n        free(pcVar5);\n        goto LAB_001f7877;\n      }\n    }\n    lVar7 = 0x50;\n    free(pcVar5);\n  }\nLAB_001f786d:\n  psVar8 = (size_t *)((long)&_rl_color_indicator + lVar7);\nLAB_001f7877:\n  uVar6 = 1;\n  if (psVar8[1] != 0) {\n    cVar1 = FUN_001f7550(4);\n    if (cVar1 != '\\0') {\n      fwrite(PTR_DAT_002405e8,_rl_color_indicator,1,rl_outstream);\n      fwrite(PTR_DAT_002405f8,DAT_002405f0,1,rl_outstream);\n    }\n    fwrite(PTR_DAT_002405e8,_rl_color_indicator,1,rl_outstream);\n    fwrite((void *)psVar8[1],*psVar8,1,rl_outstream);\n    fwrite(PTR_DAT_002405f8,DAT_002405f0,1,rl_outstream);\n    uVar6 = 0;\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar6;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "make_word_list": "\nvoid make_word_list(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 *puVar1;\n  \n  if (0 < DAT_00241ebc) {\n    DAT_00241ebc = DAT_00241ebc + -1;\n    puVar1 = *(undefined8 **)(wlcache + (long)DAT_00241ebc * 8);\n    puVar1[1] = param_1;\n    *puVar1 = param_2;\n    return;\n  }\n  puVar1 = (undefined8 *)sh_xmalloc(0x10,\"make_cmd.c\",0xa3);\n  puVar1[1] = param_1;\n  *puVar1 = param_2;\n  return;\n}\n\n",
  "__sprintf_chk": "\nvoid __sprintf_chk(void)\n\n{\n  (*(code *)PTR___sprintf_chk_00237ed0)();\n  return;\n}\n\n",
  "trap_builtin": "\nulong trap_builtin(undefined8 param_1)\n\n{\n  char *pcVar1;\n  int iVar2;\n  int iVar3;\n  long **pplVar4;\n  long **pplVar5;\n  ulong uVar6;\n  uint uVar7;\n  char cVar8;\n  \n  uVar7 = 0;\n  uVar6 = 0;\n  reset_internal_getopt();\n  while( true ) {\n    iVar2 = internal_getopt(param_1,&DAT_0020f1c0);\n    pplVar5 = loptend;\n    if (iVar2 == -1) break;\n    if (iVar2 == 0x6c) {\n      uVar6 = (ulong)((int)uVar6 + 1);\n    }\n    else {\n      if (iVar2 != 0x70) {\n        if (iVar2 == -99) {\n          builtin_help();\n          return 0x102;\n        }\n        goto LAB_001b46c0;\n      }\n      uVar7 = uVar7 + 1;\n    }\n  }\n  if ((int)uVar6 != 0) {\n    uVar7 = display_signal_list(0,1);\n    uVar6 = (ulong)uVar7;\nLAB_001b4875:\n    uVar6 = sh_chkwrite(uVar6);\n    return uVar6;\n  }\n  if ((uVar7 != 0) || (loptend == (long **)0x0)) {\n    initialize_terminating_signals();\n    get_all_original_signals();\n    if ((uVar7 == 0) || (uVar7 = (uint)(posixly_correct != 0), pplVar5 == (long **)0x0)) {\n      iVar2 = 0;\n      do {\n        iVar3 = iVar2 + 1;\n        FUN_001b44d0(iVar2,uVar7);\n        iVar2 = iVar3;\n      } while (iVar3 != 0x44);\n    }\n    else {\n      do {\n        iVar2 = decode_signal(*pplVar5[1],3);\n        if (iVar2 == -1) {\n          uVar6 = 1;\n          sh_invalidsig(*pplVar5[1]);\n        }\n        else {\n          FUN_001b44d0(iVar2,uVar7);\n        }\n        pplVar5 = (long **)*pplVar5;\n      } while (pplVar5 != (long **)0x0);\n    }\n    goto LAB_001b4875;\n  }\n  pcVar1 = (char *)*loptend[1];\n  if (pcVar1 == (char *)0x0) {\nLAB_001b4766:\n    pplVar4 = (long **)*pplVar5;\n    if (pplVar4 == (long **)0x0) {\nLAB_001b46c0:\n      builtin_usage();\n      return 0x102;\n    }\nLAB_001b4772:\n    cVar8 = '\\x02';\n    pplVar5 = pplVar4;\n    if ((*pcVar1 == '\\0') || (cVar8 = '\\0', *pcVar1 != '-')) goto LAB_001b478b;\n    cVar8 = pcVar1[1];\n  }\n  else {\n    if (*pcVar1 == '\\0') {\n      if (posixly_correct == 0) {\nLAB_001b49de:\n        pplVar5 = (long **)*pplVar5;\n        if (pplVar5 != (long **)0x0) {\n          cVar8 = '\\x02';\n          goto LAB_001b478b;\n        }\n        goto LAB_001b46c0;\n      }\n      goto LAB_001b4766;\n    }\n    iVar2 = all_digits(pcVar1);\n    if (iVar2 != 0) {\n      cVar8 = '\\x01';\n      iVar2 = decode_signal(pcVar1,3);\n      if (iVar2 != -1) goto LAB_001b478b;\n    }\n    if (posixly_correct != 0) goto LAB_001b4766;\n    if (*pcVar1 == '\\0') goto LAB_001b49de;\n    if ((*pcVar1 != '-') || (pcVar1[1] != '\\0')) {\n      iVar2 = decode_signal(pcVar1,3);\n      if (iVar2 == -1) goto LAB_001b4766;\n      pplVar4 = (long **)*pplVar5;\n      cVar8 = '\\x01';\n      if (pplVar4 == (long **)0x0) goto LAB_001b478b;\n      goto LAB_001b4772;\n    }\n    pplVar4 = (long **)*pplVar5;\n    cVar8 = '\\0';\n    if (pplVar4 == (long **)0x0) goto LAB_001b46c0;\n  }\n  cVar8 = cVar8 == '\\0';\n  pplVar5 = pplVar4;\nLAB_001b478b:\n  if ((subshell_environment & 0x80) != 0) {\n    free_trap_strings();\n    subshell_environment = subshell_environment & 0xffffff7f;\n  }\n  do {\n    iVar2 = decode_signal(*pplVar5[1],3);\n    if (iVar2 == -1) {\n      uVar6 = 1;\n      sh_invalidsig(*pplVar5[1]);\n    }\n    else if (cVar8 == '\\x01') {\n      restore_default_signal(iVar2);\n      if (iVar2 == 3) {\n        set_signal_handler(3,1);\n      }\n      else if (iVar2 < 4) {\n        if (iVar2 == 2) {\n          if ((interactive == 0) &&\n             ((interactive_shell == 0 ||\n              ((sourcelevel | running_trap | parse_and_execute_level) == 0)))) {\n            set_signal_handler(2,termsig_sighandler);\n          }\n          else {\n            set_signal_handler(2,sigint_sighandler);\n          }\n        }\n      }\n      else if (((iVar2 == 0xf) || (iVar2 - 0x14U < 3)) && (interactive != 0)) {\n        set_signal_handler(iVar2,1);\n      }\n    }\n    else if (cVar8 == '\\x02') {\n      ignore_signal(iVar2);\n    }\n    else {\n      set_signal(iVar2,pcVar1);\n    }\n    pplVar5 = (long **)*pplVar5;\n  } while (pplVar5 != (long **)0x0);\n  return uVar6;\n}\n\n",
  "set_bashopts": "\nvoid set_bashopts(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int *piVar3;\n  size_t sVar4;\n  undefined *puVar5;\n  undefined *puVar6;\n  long lVar7;\n  int iVar8;\n  char **ppcVar9;\n  char *pcVar10;\n  char *pcVar11;\n  undefined **ppuVar12;\n  char *pcVar13;\n  int iVar14;\n  long in_FS_OFFSET;\n  char local_88 [72];\n  long local_40;\n  \n  pcVar11 = \"autocd\";\n  iVar14 = 0;\n  ppuVar12 = &PTR_s_assoc_expand_once_00236438;\n  pcVar10 = local_88;\n  pcVar13 = local_88;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar3 = &autocd;\n  ppcVar9 = &PTR_s_assoc_expand_once_00236438;\n  while( true ) {\n    iVar8 = *piVar3;\n    *pcVar10 = 0;\n    if (iVar8 != 0) {\n      sVar4 = strlen(pcVar11);\n      *pcVar10 = 1;\n      iVar14 = iVar14 + 1 + (int)sVar4;\n    }\n    pcVar11 = *ppcVar9;\n    pcVar10 = pcVar10 + 1;\n    if (pcVar11 == (char *)0x0) break;\n    piVar3 = (int *)ppcVar9[1];\n    ppcVar9 = ppcVar9 + 3;\n  }\n  iVar8 = 0;\n  pcVar11 = \"autocd\";\n  puVar5 = (undefined *)sh_xmalloc((long)(iVar14 + 1),\"./shopt.def\",0x347);\n  do {\n    if (*pcVar13 != '\\0') {\n      strcpy(puVar5 + iVar8,pcVar11);\n      sVar4 = strlen(pcVar11);\n      iVar14 = (int)sVar4 + iVar8;\n      iVar8 = iVar14 + 1;\n      puVar5[iVar14] = 0x3a;\n    }\n    pcVar11 = *ppuVar12;\n    pcVar13 = pcVar13 + 1;\n    ppuVar12 = ppuVar12 + 3;\n  } while (pcVar11 != (char *)0x0);\n  puVar6 = puVar5;\n  if (iVar8 != 0) {\n    puVar6 = puVar5 + (iVar8 + -1);\n  }\n  *puVar6 = 0;\n  lVar7 = find_variable(\"BASHOPTS\");\n  if (lVar7 == 0) {\n    lVar7 = bind_variable(\"BASHOPTS\",puVar5,0);\n    uVar2 = *(uint *)(lVar7 + 0x28);\n    *(uint *)(lVar7 + 0x28) = uVar2 | 2;\n    if (mark_modified_vars == 0) goto LAB_001b77ba;\n  }\n  else {\n    uVar1 = *(uint *)(lVar7 + 0x28);\n    *(uint *)(lVar7 + 0x28) = uVar1 & 0xfffffffd;\n    lVar7 = bind_variable(\"BASHOPTS\",puVar5,0);\n    iVar14 = mark_modified_vars;\n    uVar2 = *(uint *)(lVar7 + 0x28);\n    *(uint *)(lVar7 + 0x28) = uVar2 | 2;\n    if ((iVar14 == 0) || ((uVar1 & 1) != 0)) goto LAB_001b77ba;\n  }\n  if ((uVar2 & 1) != 0) {\n    *(uint *)(lVar7 + 0x28) = uVar2 & 0xfffffffe | 2;\n  }\nLAB_001b77ba:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    sh_xfree(puVar5,\"./shopt.def\",0x36c);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001aa0a0": "\nulong FUN_001aa0a0(char *param_1,long *param_2,uint param_3)\n\n{\n  long *plVar1;\n  char cVar2;\n  char *__nptr;\n  char cVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  ulong uVar7;\n  size_t sVar8;\n  long lVar9;\n  uint uVar10;\n  ulong uVar11;\n  \n  if (*param_2 == 0) {\n    uVar11 = 0;\n  }\n  else {\n    uVar7 = 1;\n    do {\n      uVar11 = uVar7 & 0xffffffff;\n      plVar1 = param_2 + uVar7;\n      uVar7 = uVar7 + 1;\n    } while (*plVar1 != 0);\n  }\n  uVar6 = (uint)uVar11;\n  uVar10 = uVar6 - 1;\n  if ((remember_on_history == 0) && (uVar10 = uVar6, ((byte)subshell_environment & 4) != 0)) {\n    uVar10 = ((uVar6 - 1) + (uint)(enable_history_list == 0)) - hist_last_line_added;\n    if (uVar10 != uVar6) goto LAB_001aa105;\nLAB_001aa1f9:\n    if (param_2[(int)uVar6] == 0) {\n      lVar9 = (long)(int)(uVar6 - 1);\n      do {\n        uVar10 = (uint)lVar9;\n        if (uVar10 == 0xffffffff) {\n          return 0xffffffff;\n        }\n        plVar1 = param_2 + lVar9;\n        lVar9 = lVar9 + -1;\n      } while (*plVar1 == 0);\n      goto LAB_001aa105;\n    }\n    if (param_1 == (char *)0x0) {\n      return uVar11;\n    }\nLAB_001aa158:\n    cVar2 = *param_1;\n  }\n  else {\n    uVar10 = uVar10 - hist_last_line_added;\n    if (uVar10 == uVar6) goto LAB_001aa1f9;\nLAB_001aa105:\n    if ((int)uVar10 < 0) {\n      return 0xffffffff;\n    }\n    if (param_1 == (char *)0x0) goto LAB_001aa2f8;\n    if ((param_2[(int)uVar6] != 0) || (uVar6 == 0)) goto LAB_001aa158;\n    uVar7 = (ulong)(int)(uVar6 - 1);\n    do {\n      uVar11 = uVar7 & 0xffffffff;\n      if (param_2[uVar7] != 0) goto LAB_001aa158;\n      uVar7 = uVar7 - 1;\n    } while (((long)(int)uVar6 + -2) - (ulong)(uVar6 - 1) != uVar7);\n    cVar2 = *param_1;\n    uVar11 = 0;\n  }\n  if (cVar2 == '-') {\n    iVar4 = -1;\n    __nptr = param_1 + 1;\n    cVar3 = param_1[1];\n  }\n  else {\n    iVar4 = 1;\n    __nptr = param_1;\n    cVar3 = cVar2;\n  }\n  if (9 < (byte)(cVar3 - 0x30U)) {\n    uVar11 = (ulong)(int)uVar10;\n    sVar8 = strlen(param_1);\n    while( true ) {\n      if ((int)sVar8 == 0) {\n        return uVar11 & 0xffffffff;\n      }\n      if ((cVar2 == **(char **)param_2[uVar11]) &&\n         (iVar4 = strncmp(param_1,*(char **)param_2[uVar11],(long)(int)sVar8), iVar4 == 0)) break;\n      uVar11 = uVar11 - 1;\n      if ((int)uVar11 == -1) {\n        return 0x80000002;\n      }\n    }\n    return uVar11 & 0xffffffff;\n  }\n  lVar9 = strtol(__nptr,(char **)0x0,10);\n  iVar5 = (int)lVar9 * iVar4;\n  if (iVar5 < 0) {\n    uVar6 = uVar10 + 1 + iVar5;\n    if ((int)uVar6 < 0) {\n      uVar6 = 0;\n    }\n    return (ulong)uVar6;\n  }\n  if (iVar5 != 0) {\n    uVar6 = iVar5 - history_base;\n    if ((-1 < (int)uVar6) && ((int)uVar6 < (int)uVar10)) {\n      return (ulong)uVar6;\n    }\n    if ((param_3 & 2) == 0) {\n      return (ulong)uVar10;\n    }\n    return 0;\n  }\n  if (iVar4 == -1) {\n    if ((param_3 & 1) == 0) {\n      return 0x80000000;\n    }\n    return uVar11;\n  }\nLAB_001aa2f8:\n  return (ulong)uVar10;\n}\n\n",
  "_rl_digit_p": "\nbool _rl_digit_p(int param_1)\n\n{\n  return param_1 - 0x30U < 10;\n}\n\n",
  "rl_restart_output": "\nundefined8 rl_restart_output(void)\n\n{\n  int __fd;\n  \n  __fd = fileno(rl_outstream);\n  tcflow(__fd,1);\n  return 0;\n}\n\n",
  "rl_set_key": "\nvoid rl_set_key(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  rl_generic_bind(0,param_1,param_2,param_3);\n  return;\n}\n\n",
  "tcflow": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint tcflow(int __fd,int __action)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_tcflow_00237d70)();\n  return iVar1;\n}\n\n",
  "FUN_00171ef0": "\nchar * FUN_00171ef0(int param_1,long param_2,int param_3,uint param_4)\n\n{\n  uint uVar1;\n  int iVar2;\n  long lVar3;\n  char *pcVar4;\n  size_t sVar5;\n  undefined8 uVar6;\n  char cVar7;\n  long in_FS_OFFSET;\n  char acStack_48 [24];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar7 = (-(param_3 == 0) & 0x16U) + 0x2a;\n  if (param_1 == 0x41) {\n    if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar6 = 1;\nLAB_001720a5:\n      pcVar4 = (char *)FUN_00170720(param_2,param_4,uVar6);\n      return pcVar4;\n    }\n    goto LAB_00172115;\n  }\n  if (param_1 == 0x4b) {\n    if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar6 = 2;\n      goto LAB_001720a5;\n    }\n    goto LAB_00172115;\n  }\n  if (param_1 == 0x61) {\n    uVar1 = *(uint *)(param_2 + 0x28);\n    if (((uVar1 & 0x1000) == 0) && (*(long *)(param_2 + 8) != 0)) goto LAB_00171f46;\n    pcVar4 = (char *)0x0;\n    iVar2 = var_attribute_string(param_2,0,acStack_48);\n    if (0 < iVar2) {\n      sVar5 = strlen(acStack_48);\n      pcVar4 = (char *)sh_xmalloc(sVar5 + 1,\"subst.c\",0x2183);\n      pcVar4 = strcpy(pcVar4,acStack_48);\n    }\n  }\n  else {\n    if (param_2 != 0) {\n      uVar1 = *(uint *)(param_2 + 0x28);\nLAB_00171f46:\n      if ((uVar1 & 4) == 0) {\n        if ((uVar1 & 0x40) == 0) {\n          if (param_1 == 0x6b) {\n            lVar3 = 0;\nLAB_001720e2:\n            uVar6 = assoc_to_kvpair_list(lVar3);\n            goto LAB_00172060;\n          }\n        }\n        else {\n          lVar3 = *(long *)(param_2 + 8);\n          if (param_1 == 0x6b) goto LAB_001720e2;\n          if (lVar3 != 0) {\n            lVar3 = assoc_to_word_list();\n            goto LAB_00171f69;\n          }\n        }\n      }\n      else {\n        if (param_1 == 0x6b) {\n          uVar6 = array_to_kvpair_list();\nLAB_00172060:\n          if (((cVar7 == '*') && (DAT_00247848 != 0)) && (ifs_is_null != 0)) {\n            param_4 = param_4 | 1;\n          }\n          pcVar4 = (char *)string_list_pos_params(cVar7,uVar6,param_4,0);\n          dispose_words(uVar6);\n          goto LAB_00171fa4;\n        }\n        if (*(long *)(param_2 + 8) != 0) {\n          lVar3 = array_to_word_list();\nLAB_00171f69:\n          if (lVar3 != 0) {\n            pcVar4 = (char *)FUN_00171de0(param_1,param_2,lVar3,cVar7,param_4);\n            dispose_words(lVar3);\n            goto LAB_00171fa4;\n          }\n        }\n      }\n    }\n    pcVar4 = (char *)0x0;\n  }\nLAB_00171fa4:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pcVar4;\n  }\nLAB_00172115:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_vi_done_inserting": "\nvoid _rl_vi_done_inserting(void)\n\n{\n  long *plVar1;\n  int iVar2;\n  int iVar3;\n  \n  if (DAT_0024a420 == 0) {\n    if ((rl_undo_list == (long *)0x0) || ((DAT_0024a3c8 & 0xffffffd7) != 0x41)) {\n      if (DAT_0024a3c8 == 0x43) goto LAB_001d1e30;\n      goto LAB_001d1e35;\n    }\n    iVar2 = *(int *)(rl_undo_list + 3);\n    plVar1 = rl_undo_list;\njoined_r0x001d1e7b:\n    if (iVar2 == 1) {\n      iVar3 = *(int *)(plVar1 + 1);\n      iVar2 = (*(int *)((long)plVar1 + 0xc) - iVar3) + 1;\nLAB_001d1e88:\n      FUN_001cf760(iVar3,iVar2);\n      goto LAB_001d1e35;\n    }\n  }\n  else {\n    rl_end_undo_group();\n    DAT_0024a420 = 0;\n    if (DAT_0024a3c8 == 0x52) {\n      if (((rl_undo_list != (long *)0x0) && (*(int *)(rl_undo_list + 3) == 3)) && (0 < DAT_0024a410)\n         ) {\n        iVar2 = DAT_0024a410 + 1;\n        iVar3 = (rl_point - DAT_0024a410) + 1;\n        if (iVar3 < 0) {\n          iVar2 = rl_point + 1;\n          iVar3 = 0;\n        }\n        goto LAB_001d1e88;\n      }\n    }\n    else {\n      plVar1 = (long *)*rl_undo_list;\n      if (plVar1 != (long *)0x0) {\n        iVar2 = *(int *)(plVar1 + 3);\n        goto joined_r0x001d1e7b;\n      }\n    }\n  }\n  if (0 < DAT_0024a404) {\n    *DAT_0024a408 = 0;\n  }\nLAB_001d1e35:\n  while (0 < _rl_undo_group_level) {\nLAB_001d1e30:\n    rl_end_undo_group();\n  }\n  return;\n}\n\n",
  "isatty": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_isatty_002378d0)();\n  return iVar1;\n}\n\n",
  "assoc_keys_to_word_list": "\nvoid assoc_keys_to_word_list(undefined8 param_1)\n\n{\n  FUN_0018d590(param_1,1);\n  return;\n}\n\n",
  "clear_pending_traps": "\nvoid clear_pending_traps(void)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  \n  pending_traps._4_8_ = 0;\n  pending_traps._252_8_ = 0;\n  puVar2 = (undefined8 *)(pending_traps + 8);\n  for (lVar1 = 0x1f; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  return;\n}\n\n",
  "rl_unix_word_rubout": "\nundefined8 rl_unix_word_rubout(int param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  uint uVar3;\n  long lVar4;\n  bool bVar5;\n  \n  iVar1 = rl_point;\n  if (rl_point == 0) {\n    rl_ding();\n    return 0;\n  }\n  lVar4 = (long)rl_point;\n  if (param_1 < 1) {\n    param_1 = 1;\n  }\n  param_1 = param_1 + -1;\nLAB_001e99b0:\n  do {\n    if ((int)lVar4 != 0) {\n      uVar3 = (int)lVar4 - 1;\n      lVar2 = (long)(int)uVar3;\n      do {\n        if ((*(char *)(rl_line_buffer + lVar2) != ' ') &&\n           (*(char *)(rl_line_buffer + lVar2) != '\\t')) {\n          lVar4 = (long)rl_point;\n          if (rl_point == 0) goto LAB_001e9a89;\n          uVar3 = rl_point - 1;\n          lVar2 = (long)(int)uVar3;\n          goto LAB_001e9a10;\n        }\n        rl_point = (int)lVar2;\n        lVar2 = lVar2 + -1;\n      } while ((lVar4 + -2) - (ulong)uVar3 != lVar2);\n      goto LAB_001e9a30;\n    }\nLAB_001e9a89:\n  } while ((param_1 != 0) && (bVar5 = param_1 != 1, param_1 = param_1 + -2, bVar5));\n  goto LAB_001e9a3a;\n  while( true ) {\n    rl_point = (int)lVar2;\n    lVar2 = lVar2 + -1;\n    if ((lVar4 + -2) - (ulong)uVar3 == lVar2) break;\nLAB_001e9a10:\n    if ((*(char *)(rl_line_buffer + lVar2) == ' ') || (*(char *)(rl_line_buffer + lVar2) == '\\t')) {\n      lVar4 = (long)rl_point;\n      bVar5 = param_1 != 0;\n      param_1 = param_1 + -1;\n      if (bVar5) goto LAB_001e99b0;\n      goto LAB_001e9a3a;\n    }\n  }\nLAB_001e9a30:\n  lVar4 = (long)rl_point;\n  bVar5 = param_1 == 0;\n  param_1 = param_1 + -1;\n  if (bVar5) {\nLAB_001e9a3a:\n    rl_kill_text(iVar1);\n    if (rl_editing_mode == 1) {\n      rl_mark = rl_point;\n      return 0;\n    }\n    return 0;\n  }\n  goto LAB_001e99b0;\n}\n\n",
  "rl_variable_value": "\nchar * rl_variable_value(char *param_1)\n\n{\n  int iVar1;\n  undefined **ppuVar2;\n  int iVar3;\n  char *pcVar4;\n  \n  pcVar4 = \"bind-tty-special-chars\";\n  iVar3 = 0;\n  ppuVar2 = &PTR_s_blink_matching_paren_002372b8;\n  do {\n    iVar1 = strcasecmp(param_1,pcVar4);\n    if (iVar1 == 0) {\n      if (*(int *)(&PTR__rl_bind_stty_chars_002372a8)[(long)iVar3 * 3] != 0) {\n        return \"on\";\n      }\n      return \"off\";\n    }\n    pcVar4 = *ppuVar2;\n    ppuVar2 = ppuVar2 + 3;\n    iVar3 = iVar3 + 1;\n  } while (pcVar4 != (char *)0x0);\n  ppuVar2 = &PTR_s_active_region_start_color_00235858;\n  iVar3 = 0;\n  pcVar4 = \"active-region-end-color\";\n  while (iVar1 = strcasecmp(param_1,pcVar4), iVar1 != 0) {\n    pcVar4 = *ppuVar2;\n    ppuVar2 = ppuVar2 + 3;\n    iVar3 = iVar3 + 1;\n    if (pcVar4 == (char *)0x0) {\n      return (char *)0x0;\n    }\n  }\n  pcVar4 = (&PTR_s_active_region_end_color_00235840)[(long)iVar3 * 3];\n  iVar3 = strcasecmp(pcVar4,\"bell-style\");\n  if (iVar3 != 0) {\n    pcVar4 = (char *)FUN_001dc4f0(pcVar4);\n    return pcVar4;\n  }\n  if (_rl_bell_preference == 0) {\n    return \"none\";\n  }\n  pcVar4 = \"audible\";\n  if (_rl_bell_preference == 2) {\n    pcVar4 = \"visible\";\n  }\n  return pcVar4;\n}\n\n",
  "_rl_walphabetic": "\nuint _rl_walphabetic(wint_t param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  char *pcVar3;\n  \n  iVar1 = iswalnum(param_1);\n  uVar2 = 1;\n  if ((iVar1 == 0) &&\n     (uVar2 = _rl_allow_pathname_alphabetic_chars, _rl_allow_pathname_alphabetic_chars != 0)) {\n    pcVar3 = strchr(\"/-_=~.#$\",param_1 & 0x7f);\n    uVar2 = (uint)(pcVar3 != (char *)0x0);\n  }\n  return uVar2;\n}\n\n",
  "_rl_with_macro_input": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid _rl_with_macro_input(undefined8 param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  \n  if (_DAT_0024b180 < 0x11) {\n    puVar2 = (undefined8 *)xmalloc(0x18);\n    _DAT_0024b180 = _DAT_0024b180 + 1;\n    puVar1 = puVar2;\n    *puVar2 = DAT_0024b188;\n    DAT_0024b188 = puVar1;\n    rl_readline_state = rl_readline_state | 0x800;\n    *(undefined4 *)(puVar2 + 2) = DAT_0024b1a0;\n    DAT_0024b1a0 = 0;\n    puVar2[1] = rl_executing_macro;\n    rl_executing_macro = param_1;\n    return;\n  }\n  _rl_errmsg(\"maximum macro execution nesting level exceeded\");\n                    /* WARNING: Subroutine does not return */\n  _rl_abort_internal();\n}\n\n",
  "readonly_builtin": "\nvoid readonly_builtin(undefined8 param_1)\n\n{\n  set_or_show_attributes(param_1,2,0);\n  return;\n}\n\n",
  "parser_expanding_alias": "\nbool parser_expanding_alias(void)\n\n{\n  bool bVar1;\n  \n  bVar1 = false;\n  if (pushed_string_list != 0) {\n    bVar1 = *(long *)(pushed_string_list + 0x18) != 0;\n  }\n  return bVar1;\n}\n\n",
  "phash_search": "\nundefined2 * phash_search(char *param_1)\n\n{\n  uint uVar1;\n  char *__s;\n  int iVar2;\n  long lVar3;\n  size_t sVar4;\n  undefined2 *puVar5;\n  char *pcVar6;\n  undefined8 uVar7;\n  \n  if (((hashing_enabled == 0) || (hashed_filenames == 0)) ||\n     (lVar3 = hash_search(param_1,hashed_filenames,0), lVar3 == 0)) {\n    return (undefined2 *)0x0;\n  }\n  __s = **(char ***)(lVar3 + 0x10);\n  uVar1 = *(uint *)(*(char ***)(lVar3 + 0x10) + 1);\n  if ((uVar1 & 3) != 0) {\n    if ((uVar1 & 1) != 0) {\n      param_1 = __s;\n    }\n    sVar4 = strlen(param_1);\n    if ((*param_1 == '.') && (param_1[1] == '/')) {\n      pcVar6 = (char *)sh_xmalloc(sVar4 + 1,\"hashcmd.c\",0x9d);\n      puVar5 = (undefined2 *)strcpy(pcVar6,param_1);\n    }\n    else {\n      puVar5 = (undefined2 *)sh_xmalloc(sVar4 + 3,\"hashcmd.c\",0x98);\n      *puVar5 = 0x2f2e;\n      strcpy((char *)(puVar5 + 1),param_1);\n    }\n    iVar2 = executable_file(puVar5);\n    if (iVar2 != 0) {\n      return puVar5;\n    }\n    sh_xfree(puVar5,\"hashcmd.c\",0xa2);\n    if (*__s == '.') {\n      pcVar6 = strrchr(__s,0x2f);\n      if (pcVar6 != (char *)0x0) {\n        *pcVar6 = '\\0';\n        iVar2 = same_file(\".\",__s,0,0);\n        *pcVar6 = '/';\n        if (iVar2 != 0) {\n          return (undefined2 *)0x0;\n        }\n      }\n      sVar4 = strlen(__s);\n      uVar7 = 0xbe;\n      goto LAB_0017facd;\n    }\n  }\n  sVar4 = strlen(__s);\n  uVar7 = 0xc2;\nLAB_0017facd:\n  pcVar6 = (char *)sh_xmalloc(sVar4 + 1,\"hashcmd.c\",uVar7);\n  puVar5 = (undefined2 *)strcpy(pcVar6,__s);\n  return puVar5;\n}\n\n",
  "flush_eltstate": "\nvoid flush_eltstate(long param_1)\n\n{\n  if ((param_1 != 0) && (*(long *)(param_1 + 0x10) != 0)) {\n    sh_xfree(*(long *)(param_1 + 0x10),\"arrayfunc.c\",0x151);\n    return;\n  }\n  return;\n}\n\n",
  "expand_word_unsplit": "\nundefined8 expand_word_unsplit(undefined8 *param_1,undefined8 param_2)\n\n{\n  uint uVar1;\n  undefined *puVar2;\n  undefined8 uVar3;\n  \n  DAT_00247848 = 1;\n  uVar1 = *(uint *)(param_1 + 1);\n  if (ifs_is_null != 0) {\n    uVar1 = uVar1 | 0x10;\n  }\n  *(uint *)(param_1 + 1) = uVar1 | 0x40;\n  puVar2 = (undefined *)FUN_00177e80(param_1,param_2,0,0,0);\n  if (puVar2 == &DAT_00247880) {\n    *param_1 = 0;\n    uVar3 = 2;\n  }\n  else {\n    if (puVar2 != &DAT_00247870) {\n      DAT_00247848 = 0;\n      if (puVar2 != (undefined *)0x0) {\n        uVar3 = dequote_list();\n        return uVar3;\n      }\n      return 0;\n    }\n    *param_1 = 0;\n    uVar3 = 1;\n  }\n  last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n  FUN_001667f0(uVar3);\n}\n\n",
  "print_var_value": "\nvoid print_var_value(long param_1,int param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined8 uVar4;\n  \n  lVar3 = *(long *)(param_1 + 8);\n  if (lVar3 == 0) {\n    return;\n  }\n  if (param_2 != 0) {\n    if (posixly_correct == 0) {\n      iVar1 = ansic_shouldquote(lVar3);\n      if (iVar1 != 0) {\n        uVar2 = ansic_quote(*(undefined8 *)(param_1 + 8),0,0);\n        __printf_chk(1,&DAT_002102da,uVar2);\n        uVar4 = 0x47a;\n        goto LAB_00152ee7;\n      }\n      lVar3 = *(long *)(param_1 + 8);\n    }\n    iVar1 = sh_contains_shell_metas(lVar3);\n    if (iVar1 != 0) {\n      uVar2 = sh_single_quote(*(undefined8 *)(param_1 + 8));\n      __printf_chk(1,&DAT_002102da,uVar2);\n      uVar4 = 0x480;\nLAB_00152ee7:\n      sh_xfree(uVar2,\"variables.c\",uVar4);\n      return;\n    }\n    lVar3 = *(long *)(param_1 + 8);\n  }\n  __printf_chk(1,&DAT_002102da,lVar3);\n  return;\n}\n\n",
  "bash_groupname_completion_function": "\nchar * bash_groupname_completion_function(char *param_1,int param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  group *pgVar4;\n  char *__dest;\n  \n  if (param_2 == 0) {\n    if (DAT_00248700 != (char *)0x0) {\n      sh_xfree(DAT_00248700,\"bashline.c\",0xa62);\n    }\n    sVar2 = strlen(param_1);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"bashline.c\",0xa63);\n    DAT_00248700 = strcpy(pcVar3,param_1);\n    sVar2 = strlen(DAT_00248700);\n    DAT_002486f8 = (int)sVar2;\n    setgrent();\n  }\n  do {\n    do {\n      pgVar4 = getgrent();\n      if (pgVar4 == (group *)0x0) {\n        endgrent();\n        return (char *)0x0;\n      }\n      pcVar3 = pgVar4->gr_name;\n      if (DAT_002486f8 == 0) goto LAB_00199793;\n    } while (*DAT_00248700 != *pcVar3);\n    iVar1 = strncmp(DAT_00248700,pcVar3,(long)DAT_002486f8);\n  } while (iVar1 != 0);\nLAB_00199793:\n  sVar2 = strlen(pcVar3);\n  __dest = (char *)sh_xmalloc(sVar2 + 1,\"bashline.c\",0xa75);\n  pcVar3 = strcpy(__dest,pcVar3);\n  return pcVar3;\n}\n\n",
  "FUN_001a1200": "\nvoid FUN_001a1200(int *param_1)\n\n{\n  *param_1 = *param_1 + -1;\n  if (*param_1 == 0) {\n    FUN_001a1120();\n    return;\n  }\n  return;\n}\n\n",
  "sigdelset": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigdelset(sigset_t *__set,int __signo)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigdelset_00237d58)();\n  return iVar1;\n}\n\n",
  "_rl_output_character_function": "\nvoid _rl_output_character_function(int param_1)\n\n{\n  putc(param_1,_rl_out_stream);\n  return;\n}\n\n",
  "set_pwd": "\nvoid set_pwd(void)\n\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  char *pcVar4;\n  \n  lVar2 = find_variable(&DAT_001faa94);\n  if (lVar2 == 0) {\n    lVar2 = find_variable(&DAT_001fc3d5);\n    if ((((lVar2 == 0) || ((*(byte *)(lVar2 + 0x29) & 0x80) == 0)) ||\n        (pcVar4 = *(char **)(lVar2 + 8), pcVar4 == (char *)0x0)) ||\n       ((*pcVar4 != '/' || (iVar1 = same_file(pcVar4,\".\",0,0), iVar1 == 0)))) goto LAB_00155a93;\n  }\n  else {\n    lVar2 = *(long *)(lVar2 + 8);\n    lVar3 = find_variable(&DAT_001fc3d5);\n    if ((((lVar3 == 0) ||\n         (((*(byte *)(lVar3 + 0x29) & 0x80) == 0 ||\n          (pcVar4 = *(char **)(lVar3 + 8), pcVar4 == (char *)0x0)))) || (*pcVar4 != '/')) ||\n       (iVar1 = same_file(pcVar4,\".\",0,0), iVar1 == 0)) {\n      if ((((lVar2 != 0) && (interactive_shell != 0)) && (login_shell != 0)) &&\n         (iVar1 = same_file(lVar2,\".\",0,0), iVar1 != 0)) {\n        set_working_directory(lVar2);\n        lVar2 = bind_variable(&DAT_001fc3d5,lVar2,0);\n        array_needs_making = 1;\n        *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) | 1;\n        goto LAB_00155ad6;\n      }\nLAB_00155a93:\n      lVar2 = get_working_directory(\"shell-init\");\n      if (lVar2 != 0) {\n        lVar3 = bind_variable(&DAT_001fc3d5,lVar2,0);\n        *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | 1;\n        array_needs_making = 1;\n        sh_xfree(lVar2,\"variables.c\",0x3b7);\n      }\n      goto LAB_00155ad6;\n    }\n  }\n  lVar2 = sh_canonpath(pcVar4,3);\n  if (lVar2 == 0) {\n    lVar2 = get_working_directory(\"shell_init\");\n    if ((posixly_correct != 0) && (lVar2 != 0)) goto LAB_00155c4e;\n  }\n  else {\n    set_working_directory(lVar2);\n    if (posixly_correct != 0) {\nLAB_00155c4e:\n      lVar3 = bind_variable(&DAT_001fc3d5,lVar2,0);\n      array_needs_making = 1;\n      *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | 1;\n    }\n  }\n  sh_xfree(lVar2,\"variables.c\",0x3a7);\nLAB_00155ad6:\n  lVar2 = find_variable(&DAT_001fc3d2);\n  if (((lVar2 == 0) || (*(long *)(lVar2 + 8) == 0)) || (iVar1 = file_isdir(), iVar1 == 0)) {\n    lVar2 = bind_variable(&DAT_001fc3d2,0,0);\n    *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) | 0x1001;\n  }\n  return;\n}\n\n",
  "show_localname_attributes": "\nundefined8 show_localname_attributes(undefined8 param_1,undefined4 param_2)\n\n{\n  long lVar1;\n  \n  lVar1 = find_variable_noref();\n  if (lVar1 == 0) {\n    return 1;\n  }\n  if (((*(byte *)(lVar1 + 0x28) & 0x20) != 0) && (*(int *)(lVar1 + 0x2c) == variable_context)) {\n    show_var_attributes(lVar1,this_shell_builtin == export_builtin ||\n                              this_shell_builtin == readonly_builtin,param_2);\n    return 0;\n  }\n  return 1;\n}\n\n",
  "default_columns": "\nulong default_columns(void)\n\n{\n  char *__nptr;\n  ulong uVar1;\n  long in_FS_OFFSET;\n  uint local_14;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_14 = 0xffffffff;\n  __nptr = (char *)get_string_value(\"COLUMNS\");\n  if ((__nptr == (char *)0x0) || (*__nptr == '\\0')) {\n    if (check_window_size != 0) {\nLAB_00142cb0:\n      get_new_window_size(0,0,&local_14);\n    }\n    uVar1 = (ulong)local_14;\n    if (0 < (int)local_14) goto LAB_00142c68;\n  }\n  else {\n    uVar1 = strtol(__nptr,(char **)0x0,10);\n    local_14 = (uint)uVar1;\n    if (0 < (int)local_14) goto LAB_00142c68;\n    if (check_window_size != 0) goto LAB_00142cb0;\n  }\n  uVar1 = 0x50;\nLAB_00142c68:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "continue_builtin": "\nundefined4 continue_builtin(long param_1)\n\n{\n  char *__s1;\n  long lVar1;\n  int iVar2;\n  undefined4 uVar3;\n  long in_FS_OFFSET;\n  long local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((((param_1 == 0) || (*(char ***)(param_1 + 8) == (char **)0x0)) ||\n      (__s1 = **(char ***)(param_1 + 8), *__s1 != '-')) ||\n     (iVar2 = strcmp(__s1,\"--help\"), iVar2 != 0)) {\n    if ((loop_level != 0) ||\n       ((uVar3 = 0, posixly_correct == 0 &&\n        (builtin_error(\"only meaningful in a `for\\', `while\\', or `until\\' loop\"), loop_level != 0))\n       )) {\n      get_numeric_arg(param_1,1,&local_28);\n      if (local_28 < 1) {\n        uVar3 = 1;\n        sh_erange(**(undefined8 **)(param_1 + 8),\"loop count\");\n        breaking = loop_level;\n      }\n      else {\n        lVar1 = (long)loop_level;\n        if (local_28 <= loop_level) {\n          lVar1 = local_28;\n        }\n        continuing = (undefined4)lVar1;\n        uVar3 = 0;\n      }\n    }\n  }\n  else {\n    builtin_help();\n    uVar3 = 0x102;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
  "_rl_term_executing_keyseq": "\nvoid _rl_term_executing_keyseq(void)\n\n{\n  *(undefined *)(rl_executing_keyseq + rl_key_sequence_length) = 0;\n  return;\n}\n\n",
  "divtimeval": "\nlong * divtimeval(long *param_1,int param_2)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  lVar1 = *param_1;\n  lVar2 = (long)param_2;\n  *param_1 = lVar1 / lVar2;\n  param_1[1] = ((lVar1 % lVar2) * 1000000 + param_1[1]) / lVar2;\n  return param_1;\n}\n\n",
  "u32cconv": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint u32cconv(ulong param_1,char *param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  long in_FS_OFFSET;\n  char *local_78;\n  size_t local_70;\n  char *local_68;\n  size_t local_60;\n  char local_58 [40];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((0x7fffffff < param_1) || (iVar1 = wctomb(param_2,(wchar_t)param_1), iVar1 == -1)) {\n    if (DAT_0024a114 == 0) {\n      DAT_0024a108 = &DAT_ffffffffffffffff;\n      DAT_0024a110 = locale_utf8locale;\n      if (locale_utf8locale == 0) {\n        pcVar3 = (char *)get_locale_var(\"LC_CTYPE\");\n        if ((pcVar3 == (char *)0x0) || (*pcVar3 == '\\0')) {\n          _DAT_0024a0e0 = 0x49435341;\n          _DAT_0024a0e4 = 0x49;\n        }\n        else {\n          pcVar4 = strrchr(pcVar3,0x2e);\n          if (pcVar4 == (char *)0x0) {\n            strncpy(&DAT_0024a0e0,pcVar3,0x27);\n            DAT_0024a107 = 0;\n          }\n          else {\n            strncpy(&DAT_0024a0e0,pcVar4 + 1,0x27);\n            DAT_0024a107 = 0;\n            pcVar3 = strchr(&DAT_0024a0e0,0x40);\n            if (pcVar3 != (char *)0x0) {\n              *pcVar3 = '\\0';\n            }\n          }\n        }\n        DAT_0024a108 = (undefined *)iconv_open(&DAT_0024a0e0,\"UTF-8\");\n        if (DAT_0024a108 == &DAT_ffffffffffffffff) {\n          DAT_0024a108 = (undefined *)iconv_open(\"ASCII\",\"UTF-8\");\n        }\n      }\n      DAT_0024a114 = 1;\n    }\n    iVar5 = DAT_0024a110;\n    iVar1 = u32toutf8(param_1);\n    if ((iVar5 == 0) && (DAT_0024a108 != &DAT_ffffffffffffffff)) {\n      local_60 = (size_t)iVar1;\n      local_70 = 0x19;\n      local_78 = local_58;\n      local_68 = param_2;\n      iconv(DAT_0024a108,(char **)0x0,(size_t *)0x0,(char **)0x0,(size_t *)0x0);\n      sVar2 = iconv(DAT_0024a108,&local_68,&local_60,&local_78,&local_70);\n      if (sVar2 == 0xffffffffffffffff) {\n        if ((uint)(wchar_t)param_1 < 0x10000) {\n          __sprintf_chk(param_2,1,0xffffffffffffffff,\"\\\\u%04X\",param_1 & 0xffffffff);\n          iVar1 = 6;\n        }\n        else {\n          __sprintf_chk(param_2,1,0xffffffffffffffff,\"\\\\U%08X\",param_1 & 0xffffffff);\n          iVar1 = 10;\n        }\n      }\n      else {\n        *local_78 = '\\0';\n        strcpy(param_2,local_58);\n        iVar1 = (int)local_78 - (int)local_58;\n      }\n    }\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar1;\n}\n\n",
  "set_return_trap": "\nvoid set_return_trap(char *param_1)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  \n  sVar1 = strlen(param_1);\n  pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"trap.c\",0x31a);\n  pcVar2 = strcpy(pcVar2,param_1);\n  FUN_001815b0(0x43,pcVar2);\n  return;\n}\n\n",
  "initialize_shell_variables": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid initialize_shell_variables(char **param_1,uint param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char cVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  undefined8 uVar8;\n  undefined *puVar9;\n  long lVar10;\n  char *pcVar11;\n  long lVar12;\n  undefined8 uVar13;\n  undefined8 *puVar14;\n  void *__dest;\n  ulong uVar15;\n  size_t sVar16;\n  size_t sVar17;\n  int iVar18;\n  uint uVar19;\n  char *pcVar20;\n  long in_FS_OFFSET;\n  undefined4 local_80 [3];\n  undefined local_74 [12];\n  char local_68 [40];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  FUN_00152b20();\n  if (param_1 != (char **)0x0) {\n    pcVar11 = *param_1;\n    while (pcVar20 = pcVar11, pcVar11 != (char *)0x0) {\n      do {\n        cVar4 = *pcVar20;\n        pcVar20 = pcVar20 + 1;\n        if (cVar4 == '\\0') goto LAB_00158d51;\n      } while (cVar4 != '=');\n      iVar18 = (int)pcVar20 - (int)pcVar11;\n      iVar5 = iVar18 + -1;\n      if (iVar5 != 0) {\n        pcVar3 = pcVar11 + iVar5;\n        *pcVar3 = '\\0';\n        if (((param_2 | read_but_dont_execute) == 0) && (*pcVar11 == 'B')) {\n          iVar7 = strncmp(\"BASH_FUNC_\",pcVar11,10);\n          if (((((iVar7 == 0) && (pcVar2 = pcVar11 + (long)iVar5 + -2, *pcVar2 == '%')) &&\n               (pcVar2[1] == '%')) && ((pcVar2[2] == '\\0' && (*pcVar20 == '(')))) &&\n             (iVar5 = strncmp(\"() {\",pcVar20,4), iVar5 == 0)) {\n            pcVar1 = pcVar11 + 10;\n            sVar17 = (size_t)(iVar18 + -0xd);\n            *pcVar2 = '\\0';\n            sVar16 = strlen(pcVar20);\n            __dest = (void *)sh_xmalloc(sVar17 + 2 + (long)(int)sVar16,\"variables.c\",0x19b);\n            memcpy(__dest,pcVar11 + 10,sVar17);\n            *(undefined *)((long)__dest + sVar17) = 0x20;\n            memcpy((void *)((long)__dest + sVar17 + 1),pcVar20,(long)((int)sVar16 + 1));\n            iVar5 = absolute_program(pcVar1);\n            if ((iVar5 == 0) &&\n               ((posixly_correct == 0 || (iVar5 = legal_identifier(pcVar1), iVar5 != 0)))) {\n              parse_and_execute(__dest,pcVar1,0x185);\n            }\n            else {\n              sh_xfree(__dest,\"variables.c\",0x1a7);\n            }\n            uVar8 = shell_functions;\n            lVar10 = hash_search(pcVar1,shell_functions,0);\n            if (lVar10 != 0) {\n              lVar10 = *(long *)(lVar10 + 0x10);\n              _DAT_002422f8 = uVar8;\n              if (lVar10 != 0) {\n                *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x8001;\n                array_needs_making = 1;\n                *pcVar2 = '%';\n                *pcVar3 = '=';\n                goto LAB_00159609;\n              }\n            }\n            if (invalid_env == 0) {\n              invalid_env = hash_create(0x40);\n            }\n            lVar10 = FUN_00154e30(pcVar11,pcVar20,invalid_env,1);\n            if (lVar10 != 0) {\n              *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x9001;\n              array_needs_making = 1;\n              last_command_exit_value = 1;\n              report_error(\"error importing function definition for `%s\\'\",pcVar1);\n              *pcVar2 = '%';\n              *pcVar3 = '=';\n              goto LAB_00159609;\n            }\n            last_command_exit_value = 1;\n            report_error(\"error importing function definition for `%s\\'\",pcVar1);\n            *pcVar2 = '%';\n          }\n          else {\nLAB_001595b6:\n            uVar19 = 0;\n            iVar5 = legal_identifier(pcVar11);\n            if (iVar5 == 0) goto LAB_001596a0;\nLAB_001595c8:\n            lVar10 = bind_variable(pcVar11,pcVar20,0);\n            if (lVar10 != 0) {\n              uVar6 = *(uint *)(lVar10 + 0x28) | 0x8003;\n              if (uVar19 == 0) {\n                uVar6 = *(uint *)(lVar10 + 0x28) | 0x8001;\n              }\n              *(uint *)(lVar10 + 0x28) = uVar6;\n              goto LAB_001595fa;\n            }\n          }\n        }\n        else {\n          if ((*pcVar11 != 'S') ||\n             ((iVar5 = strcmp(pcVar11,\"SHELLOPTS\"), iVar5 != 0 ||\n              (lVar10 = find_variable(\"SHELLOPTS\"), lVar10 == 0)))) goto LAB_001595b6;\n          uVar19 = *(uint *)(lVar10 + 0x28);\n          *(uint *)(lVar10 + 0x28) = uVar19 & 0xfffffffd;\n          uVar19 = uVar19 >> 1 & 1;\n          iVar5 = legal_identifier(pcVar11);\n          if (iVar5 != 0) goto LAB_001595c8;\nLAB_001596a0:\n          if (invalid_env == 0) {\n            invalid_env = hash_create(0x40);\n          }\n          lVar10 = FUN_00154e30(pcVar11,pcVar20,invalid_env,1);\n          if (lVar10 != 0) {\n            *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x9001;\nLAB_001595fa:\n            array_needs_making = 1;\n            *pcVar3 = '=';\nLAB_00159609:\n            if ((*(byte *)(lVar10 + 0x28) & 8) == 0) {\n              sVar16 = strlen(pcVar11);\n              pcVar20 = (char *)sh_xmalloc(sVar16 + 1,\"variables.c\",0x21a);\n              pcVar11 = strcpy(pcVar20,pcVar11);\n              *(char **)(lVar10 + 0x10) = pcVar11;\n            }\n            goto LAB_00158d51;\n          }\n        }\n        *pcVar3 = '=';\n      }\nLAB_00158d51:\n      param_1 = param_1 + 1;\n      pcVar11 = *param_1;\n    }\n  }\n  set_pwd();\n  set_if_not(\"_\",dollar_vars);\n  dollar_dollar_pid = getpid();\n  set_if_not(\"PATH\",\"/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:.\");\n  set_if_not(\"TERM\",&DAT_001fa141);\n  if (interactive_shell != 0) {\n    set_if_not(&DAT_001fa152,primary_prompt);\n    set_if_not(&DAT_001fa156,secondary_prompt);\n  }\n  if (DAT_00238044 == 0) {\n    bind_variable(&DAT_001fc70b,&DAT_001fcf7d,0);\n  }\n  else {\n    set_if_not(&DAT_001fc70b,&DAT_001fcf7d);\n  }\n  uVar8 = bind_variable(&DAT_001fce6e,&DAT_001ff6d0,0);\n  setifs(uVar8);\n  set_if_not(\"HOSTTYPE\",\"x86_64\");\n  set_if_not(\"OSTYPE\",\"linux-gnu\");\n  set_if_not(\"MACHTYPE\",\"x86_64-pc-linux-gnu\");\n  set_if_not(\"HOSTNAME\",current_host_name);\n  if (interactive_shell != 0) {\n    puVar9 = &DAT_001fcf42;\n    if (posixly_correct != 0) {\n      puVar9 = &DAT_001fcf3e;\n    }\n    if (shell_variables == 0) {\n      FUN_00152b20();\n    }\n    lVar10 = find_variable(\"MAILCHECK\");\n    if (lVar10 == 0) {\n      lVar10 = FUN_00154e30(\"MAILCHECK\",puVar9,*(undefined8 *)(global_variables + 0x20),1);\n    }\n    *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x10;\n  }\n  adjust_shell_level(1);\n  set_ppid();\n  lVar10 = find_variable(\"BASH_ARGV0\");\n  if ((lVar10 != 0) && ((*(byte *)(lVar10 + 0x29) & 0x80) != 0)) {\n    FUN_00151500(lVar10,*(undefined8 *)(lVar10 + 8),0,0);\n  }\n  lVar10 = bind_variable(\"OPTIND\",&DAT_001fea52,0);\n  *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x10;\n  getopts_reset(0);\n  bind_variable(\"OPTERR\",&DAT_001fea52,0);\n  sh_opterr = 1;\n  if (login_shell == 1) {\n    if (posixly_correct == 0) {\n      lVar10 = find_variable(&DAT_001faa94);\n      if (lVar10 == 0) {\n        if (DAT_00238060 == 0) {\n          get_current_user_info();\n        }\n        bind_variable(&DAT_001faa94,DAT_00238060,0);\n      }\n      if (login_shell != 1) goto LAB_00158f0e;\n    }\n    if (*shell_name == '/') goto LAB_00159dbf;\n    if (DAT_00238058 == (char *)0x0) {\n      get_current_user_info();\n    }\n    pcVar11 = DAT_00238058;\n    sVar16 = strlen(DAT_00238058);\n    uVar8 = 0x312;\n    lVar10 = sVar16 + 1;\n  }\n  else {\nLAB_00158f0e:\n    if (*shell_name == '/') {\nLAB_00159dbf:\n      pcVar11 = shell_name;\n      sVar16 = strlen(shell_name);\n      uVar8 = 0x315;\n      lVar10 = sVar16 + 1;\n    }\n    else if ((*shell_name == '.') && (shell_name[1] == '/')) {\n      lVar10 = find_variable(&DAT_001fc3d5);\n      if ((lVar10 != 0) && (pcVar20 = (char *)get_variable_value(lVar10), pcVar20 != (char *)0x0)) {\n        sVar16 = strlen(pcVar20);\n        sVar17 = strlen(shell_name);\n        pcVar11 = (char *)sh_xmalloc((long)(int)sVar16 + 1 + sVar17,\"variables.c\",800);\n        strcpy(pcVar11,pcVar20);\n        strcpy(pcVar11 + (int)sVar16,shell_name + 1);\n        goto LAB_00158f63;\n      }\n      pcVar11 = shell_name;\n      sVar16 = strlen(shell_name);\n      uVar8 = 0x325;\n      lVar10 = sVar16 + 1;\n    }\n    else {\n      lVar10 = find_user_command(shell_name);\n      if (lVar10 != 0) {\n        pcVar11 = (char *)full_pathname(lVar10);\n        sh_xfree(lVar10,\"variables.c\",0x34b);\n        goto LAB_00158f63;\n      }\n      uVar15 = file_status(shell_name);\n      if ((uVar15 & 2) != 0) {\n        lVar10 = find_variable(&DAT_001fc3d5);\n        if (lVar10 != 0) {\n          lVar10 = get_variable_value(lVar10,lVar10);\n        }\n        pcVar11 = (char *)make_absolute(shell_name,lVar10);\n        if ((*shell_name == '.') &&\n           (pcVar20 = (char *)sh_canonpath(pcVar11,3), pcVar20 != (char *)0x0)) {\n          sh_xfree(pcVar11,\"variables.c\",0x33c);\n          pcVar11 = pcVar20;\n        }\n        goto LAB_00158f63;\n      }\n      if (DAT_00238058 == (char *)0x0) {\n        get_current_user_info();\n      }\n      pcVar11 = DAT_00238058;\n      sVar16 = strlen(DAT_00238058);\n      uVar8 = 0x345;\n      lVar10 = sVar16 + 1;\n    }\n  }\n  pcVar20 = (char *)sh_xmalloc(lVar10,\"variables.c\",uVar8);\n  pcVar11 = strcpy(pcVar20,pcVar11);\nLAB_00158f63:\n  bind_variable(&DAT_001fcfbe,pcVar11,0);\n  sh_xfree(pcVar11,\"variables.c\",0x272);\n  lVar10 = find_variable(\"SHELL\");\n  if (lVar10 == 0) {\n    if (DAT_00238058 == (char *)0x0) {\n      get_current_user_info();\n    }\n    bind_variable(\"SHELL\",DAT_00238058,0);\n  }\n  uVar8 = shell_version_string();\n  bind_variable(\"BASH_VERSION\",uVar8,0);\n  lVar10 = shell_variables;\n  do {\n    if (lVar10 == 0) {\nLAB_00159001:\n      lVar10 = FUN_00152bf0(\"BASH_VERSINFO\",*(undefined8 *)(global_variables + 0x20));\n      uVar8 = array_create();\n      *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 4;\n      *(undefined8 *)(lVar10 + 8) = uVar8;\n      __strcpy_chk(local_68,dist_version,0x20);\n      pcVar20 = strchr(local_68,0x2e);\n      pcVar11 = (char *)0x0;\n      if (pcVar20 != (char *)0x0) {\n        *pcVar20 = '\\0';\n        pcVar11 = pcVar20 + 1;\n      }\n      array_insert(uVar8,0,local_68);\n      array_insert(uVar8,1,pcVar11);\n      uVar13 = inttostr((long)patch_level,local_74,0xc);\n      array_insert(uVar8,2,uVar13);\n      uVar13 = inttostr((long)build_version,local_74,0xc);\n      array_insert(uVar8,3,uVar13);\n      array_insert(uVar8,4,release_status);\n      array_insert(uVar8,5,\"x86_64-pc-linux-gnu\");\n      lVar12 = command_execution_string;\n      *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 2;\n      if (lVar12 != 0) {\n        bind_variable(\"BASH_EXECUTION_STRING\",lVar12,0);\n      }\n      puVar14 = (undefined8 *)find_variable(\"POSIXLY_CORRECT\");\n      if (((puVar14 != (undefined8 *)0x0) ||\n          (puVar14 = (undefined8 *)find_variable(\"POSIX_PEDANTIC\"), puVar14 != (undefined8 *)0x0))\n         && ((*(byte *)((long)puVar14 + 0x29) & 0x80) != 0)) {\n        sv_strict_posix(*puVar14);\n      }\n      if (remember_on_history != 0) {\n        pcVar11 = \"~/.sh_history\";\n        if (posixly_correct == 0) {\n          pcVar11 = \"~/.bash_history\";\n        }\n        uVar8 = bash_tilde_expand(pcVar11,0);\n        set_if_not(\"HISTFILE\",uVar8);\n        sh_xfree(uVar8,\"variables.c\",0x294);\n      }\n      seedrand();\n      seedrand32();\n      if (interactive_shell != 0) {\n        puVar14 = (undefined8 *)find_variable(\"IGNOREEOF\");\n        if (((puVar14 != (undefined8 *)0x0) ||\n            (puVar14 = (undefined8 *)find_variable(\"ignoreeof\"), puVar14 != (undefined8 *)0x0)) &&\n           ((*(byte *)((long)puVar14 + 0x29) & 0x80) != 0)) {\n          sv_ignoreeof(*puVar14);\n        }\n        if ((interactive_shell != 0) && (remember_on_history != 0)) {\n          sv_history_control(\"HISTCONTROL\");\n          setup_history_ignore(\"HISTIGNORE\");\n          lVar10 = find_variable(\"HISTTIMEFORMAT\");\n          if ((lVar10 != 0) && (history_comment_char == '\\0')) {\n            history_comment_char = '#';\n          }\n          history_write_timestamps = (uint)(lVar10 != 0);\n        }\n      }\n      uVar8 = inttostr(current_user,local_68,0xb);\n      lVar10 = find_variable(&DAT_001fd02f);\n      if (lVar10 == 0) {\n        lVar10 = bind_variable(&DAT_001fd02f,uVar8,0);\n        *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x12;\n      }\n      if (DAT_00238044 != current_user) {\n        uVar8 = inttostr(DAT_00238044,local_68,0xb);\n      }\n      lVar10 = find_variable(&DAT_001fd02e);\n      if (lVar10 == 0) {\n        lVar10 = bind_variable(&DAT_001fd02e,uVar8,0);\n        *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x12;\n      }\n      set_if_not(\"BASH_LOADABLES_PATH\",\n                 \"/usr/local/lib/bash:/usr/lib/bash:/opt/local/lib/bash:/usr/pkg/lib/bash:/opt/pkg/lib/bash:.\"\n                );\n      puVar14 = (undefined8 *)find_variable(\"BASH_XTRACEFD\");\n      if ((puVar14 != (undefined8 *)0x0) && ((*(byte *)((long)puVar14 + 0x29) & 0x80) != 0)) {\n        sv_xtracefd(*puVar14);\n      }\n      sv_shcompat(\"BASH_COMPAT\");\n      lVar10 = find_variable(\"FUNCNEST\");\n      if ((lVar10 == 0) || (iVar5 = legal_number(*(undefined8 *)(lVar10 + 8),local_80), iVar5 == 0))\n      {\n        local_80[0] = 0;\n      }\n      funcnest_max = local_80[0];\n      lVar10 = find_variable(\"SECONDS\");\n      if (lVar10 != 0) {\n        iVar5 = legal_number(*(undefined8 *)(lVar10 + 8),&DAT_002422f0);\n        if (iVar5 == 0) {\n          _DAT_002422f0 = 0;\n        }\n        lVar10 = *(long *)(lVar10 + 8);\n      }\n      lVar10 = bind_variable(\"SECONDS\",lVar10,0);\n      *(code **)(lVar10 + 0x18) = FUN_00152550;\n      *(code **)(lVar10 + 0x20) = FUN_00152740;\n      lVar10 = bind_variable(\"BASH_ARGV0\",0,0);\n      *(code **)(lVar10 + 0x18) = FUN_001528d0;\n      *(code **)(lVar10 + 0x20) = FUN_00151500;\n      lVar10 = bind_variable(\"BASH_COMMAND\",0,0);\n      *(code **)(lVar10 + 0x18) = FUN_00152a70;\n      *(undefined8 *)(lVar10 + 0x20) = 0;\n      lVar10 = bind_variable(\"BASH_SUBSHELL\",0,0);\n      *(code **)(lVar10 + 0x18) = FUN_00152370;\n      *(code **)(lVar10 + 0x20) = FUN_00151920;\n      lVar10 = bind_variable(\"RANDOM\",0,0);\n      *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x10;\n      *(code **)(lVar10 + 0x18) = FUN_001525e0;\n      *(code **)(lVar10 + 0x20) = FUN_00151990;\n      lVar10 = bind_variable(\"SRANDOM\",0,0);\n      *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x10;\n      *(code **)(lVar10 + 0x18) = FUN_001524b0;\n      *(undefined8 *)(lVar10 + 0x20) = 0;\n      lVar10 = bind_variable(\"LINENO\",0,0);\n      *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x40000;\n      *(code **)(lVar10 + 0x18) = FUN_001523c0;\n      *(code **)(lVar10 + 0x20) = FUN_00152680;\n      lVar10 = bind_variable(\"BASHPID\",0,0);\n      *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x10;\n      *(code **)(lVar10 + 0x18) = FUN_00152500;\n      *(code **)(lVar10 + 0x20) = FUN_00151260;\n      lVar10 = bind_variable(\"EPOCHSECONDS\",0,0);\n      *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x40000;\n      *(code **)(lVar10 + 0x18) = FUN_00152410;\n      *(code **)(lVar10 + 0x20) = FUN_00151260;\n      lVar10 = bind_variable(\"EPOCHREALTIME\",0,0);\n      *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x40000;\n      *(code **)(lVar10 + 0x18) = FUN_00152970;\n      *(code **)(lVar10 + 0x20) = FUN_00151260;\n      lVar10 = bind_variable(\"HISTCMD\",0,0);\n      *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x10;\n      *(code **)(lVar10 + 0x18) = FUN_00152460;\n      *(undefined8 *)(lVar10 + 0x20) = 0;\n      lVar10 = bind_variable(\"COMP_WORDBREAKS\",0,0);\n      *(code **)(lVar10 + 0x18) = FUN_00152200;\n      *(code **)(lVar10 + 0x20) = FUN_00151490;\n      lVar10 = find_variable(\"DIRSTACK\");\n      if (lVar10 == 0) {\n        lVar10 = FUN_00152bf0(\"DIRSTACK\",*(undefined8 *)(global_variables + 0x20));\n        uVar8 = array_create();\n        *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 4;\n        *(undefined8 *)(lVar10 + 8) = uVar8;\n        *(code **)(lVar10 + 0x18) = FUN_001518e0;\n        *(code **)(lVar10 + 0x20) = FUN_001518c0;\n      }\n      lVar10 = find_variable(\"GROUPS\");\n      if (lVar10 == 0) {\n        lVar10 = FUN_00152bf0(\"GROUPS\",*(undefined8 *)(global_variables + 0x20));\n        uVar8 = array_create();\n        *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x4004;\n        *(undefined8 *)(lVar10 + 8) = uVar8;\n        *(code **)(lVar10 + 0x18) = FUN_00151f00;\n        *(code **)(lVar10 + 0x20) = FUN_001522e0;\n      }\n      lVar10 = find_variable(\"BASH_ARGC\");\n      if (lVar10 == 0) {\n        lVar10 = FUN_00152bf0(\"BASH_ARGC\",*(undefined8 *)(global_variables + 0x20));\n        uVar8 = array_create();\n        *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x6004;\n        *(undefined8 *)(lVar10 + 8) = uVar8;\n        *(code **)(lVar10 + 0x18) = FUN_001580f0;\n        *(code **)(lVar10 + 0x20) = FUN_001522e0;\n      }\n      lVar10 = find_variable(\"BASH_ARGV\");\n      if (lVar10 == 0) {\n        lVar10 = FUN_00152bf0(\"BASH_ARGV\",*(undefined8 *)(global_variables + 0x20));\n        uVar8 = array_create();\n        *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x6004;\n        *(undefined8 *)(lVar10 + 8) = uVar8;\n        *(code **)(lVar10 + 0x18) = FUN_001580f0;\n        *(code **)(lVar10 + 0x20) = FUN_001522e0;\n      }\n      lVar10 = find_variable(\"BASH_SOURCE\");\n      if (lVar10 == 0) {\n        lVar10 = FUN_00152bf0(\"BASH_SOURCE\",*(undefined8 *)(global_variables + 0x20));\n        uVar8 = array_create();\n        *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x6004;\n        *(undefined8 *)(lVar10 + 8) = uVar8;\n        *(code **)(lVar10 + 0x18) = FUN_00151270;\n        *(code **)(lVar10 + 0x20) = FUN_001522e0;\n      }\n      lVar10 = find_variable(\"BASH_LINENO\");\n      if (lVar10 == 0) {\n        lVar10 = FUN_00152bf0(\"BASH_LINENO\",*(undefined8 *)(global_variables + 0x20));\n        uVar8 = array_create();\n        *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x6004;\n        *(undefined8 *)(lVar10 + 8) = uVar8;\n        *(code **)(lVar10 + 0x18) = FUN_00151270;\n        *(code **)(lVar10 + 0x20) = FUN_001522e0;\n      }\n      lVar10 = find_variable(\"BASH_CMDS\");\n      if (lVar10 == 0) {\n        lVar10 = FUN_00152bf0(\"BASH_CMDS\",*(undefined8 *)(global_variables + 0x20));\n        uVar8 = hash_create(0x400);\n        *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x20040;\n        *(undefined8 *)(lVar10 + 8) = uVar8;\n        *(code **)(lVar10 + 0x18) = FUN_001517c0;\n        *(code **)(lVar10 + 0x20) = FUN_001517e0;\n      }\n      lVar10 = find_variable(\"BASH_ALIASES\");\n      if (lVar10 == 0) {\n        lVar10 = FUN_00152bf0(\"BASH_ALIASES\",*(undefined8 *)(global_variables + 0x20));\n        uVar8 = hash_create(0x400);\n        *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x20040;\n        *(undefined8 *)(lVar10 + 8) = uVar8;\n        *(code **)(lVar10 + 0x18) = FUN_001516c0;\n        *(code **)(lVar10 + 0x20) = FUN_00151ea0;\n      }\n      lVar10 = find_variable(\"FUNCNAME\");\n      if (lVar10 == 0) {\n        lVar10 = FUN_00152bf0(\"FUNCNAME\",*(undefined8 *)(global_variables + 0x20));\n        uVar8 = array_create();\n        *(uint *)(lVar10 + 0x28) = *(uint *)(lVar10 + 0x28) | 0x5004;\n        *(undefined8 *)(lVar10 + 8) = uVar8;\n        *(code **)(lVar10 + 0x18) = FUN_00152360;\n        *(code **)(lVar10 + 0x20) = FUN_001522e0;\n      }\n      if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return;\n    }\n    uVar8 = *(undefined8 *)(lVar10 + 0x20);\n    lVar12 = hash_search(\"BASH_VERSINFO\",uVar8,0);\n    if ((lVar12 != 0) && (_DAT_002422f8 = uVar8, *(long *)(lVar12 + 0x10) != 0)) {\n      makunbound(\"BASH_VERSINFO\",shell_variables);\n      goto LAB_00159001;\n    }\n    lVar10 = *(long *)(lVar10 + 0x18);\n  } while( true );\n}\n\n",
  "rl_generic_bind": "\nundefined4 rl_generic_bind(int param_1,char *param_2,code *param_3,long param_4,uint param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  size_t sVar3;\n  byte *pbVar4;\n  undefined8 uVar5;\n  uint uVar6;\n  uint uVar7;\n  char *pcVar8;\n  undefined *puVar9;\n  long lVar10;\n  char in_R11B;\n  bool bVar11;\n  long lVar12;\n  byte *pbVar13;\n  long in_FS_OFFSET;\n  char local_98;\n  undefined4 local_5c;\n  int local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\n    local_5c = 0xffffffff;\n    if (param_1 == 2) {\n      xfree(param_3);\n    }\n    goto LAB_001db437;\n  }\n  sVar3 = strlen(param_2);\n  pbVar4 = (byte *)xmalloc(sVar3 * 2 + 1);\n  iVar2 = rl_translate_keyseq(param_2,pbVar4,&local_44);\n  if (iVar2 != 0) {\n    xfree(pbVar4);\n    local_5c = 0xffffffff;\n    goto LAB_001db437;\n  }\n  uVar6 = (uint)(char)*pbVar4;\n  if (0 < local_44) {\n    iVar2 = 0;\n    puVar9 = (undefined *)0x0;\n    lVar10 = param_4;\n    pbVar13 = pbVar4;\n    uVar7 = uVar6;\n    do {\n      pbVar13 = pbVar13 + 1;\n      if (iVar2 != 0) {\n        uVar7 = param_5;\n      }\n      param_5 = uVar6 & 0xff;\n      iVar2 = iVar2 + 1;\n      pcVar8 = (char *)((ulong)(uVar6 & 0xff) * 0x10 + param_4);\n      cVar1 = *pcVar8;\n      bVar11 = param_3 == (code *)0x0 && param_1 == 0;\n      if (iVar2 < local_44) {\n        if (cVar1 != '\\x01') {\n          *pcVar8 = '\\x01';\n          puVar9 = *(undefined **)(pcVar8 + 8);\n          uVar5 = rl_make_bare_keymap();\n          *(undefined8 *)(pcVar8 + 8) = uVar5;\n          in_R11B = cVar1;\n        }\n        lVar12 = *(long *)(pcVar8 + 8);\n        if (puVar9 != (undefined *)0x0) {\n          if (in_R11B == '\\0') {\n            if (puVar9 != PTR_rl_do_lowercase_version_00237fa0) {\nLAB_001db3ab:\n              *(char *)(lVar12 + 0x1000) = in_R11B;\n              *(undefined **)(lVar12 + 0x1008) = puVar9;\n              puVar9 = (undefined *)0x0;\n            }\n          }\n          else if (in_R11B == '\\x02') goto LAB_001db3ab;\n        }\n      }\n      else {\n        lVar12 = param_4;\n        if (cVar1 == '\\x01') {\n          lVar12 = *(long *)(pcVar8 + 8);\n          cVar1 = *(char *)(lVar12 + 0x1000);\n          pcVar8 = (char *)(lVar12 + 0x1000);\n          lVar10 = param_4;\n          if (bVar11) {\n            param_3 = _rl_null_function;\n            bVar11 = false;\n            param_5 = 0x100;\n          }\n          else {\n            param_5 = 0x100;\n          }\n        }\n        param_4 = lVar10;\n        if (cVar1 == '\\x02') {\n          xfree(*(undefined8 *)(pcVar8 + 8));\n        }\n        *(code **)(pcVar8 + 8) = param_3;\n        local_98 = (char)param_1;\n        *pcVar8 = local_98;\n        if (iVar2 == local_44) goto code_r0x001db424;\n      }\n      uVar6 = (uint)*pbVar13;\n      lVar10 = param_4;\n      param_4 = lVar12;\n      rl_binding_keymap = lVar12;\n    } while( true );\n  }\n  if (param_3 == (code *)0x0 && param_1 == 0) goto LAB_001db520;\nLAB_001db42d:\n  xfree(pbVar4);\n  local_5c = 0;\nLAB_001db437:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_5c;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\ncode_r0x001db424:\n  rl_binding_keymap = lVar12;\n  uVar6 = uVar7;\n  if (bVar11) {\nLAB_001db520:\n    pcVar8 = (char *)(param_4 + (long)(int)uVar6 * 0x10);\n    if ((((*pcVar8 == '\\x01') && (*(long *)(pcVar8 + 8) == rl_binding_keymap)) &&\n        (*(char *)(rl_binding_keymap + 0x1000) == '\\0')) &&\n       (iVar2 = rl_empty_keymap(), lVar10 = rl_binding_keymap, iVar2 != 0)) {\n      *pcVar8 = *(char *)(rl_binding_keymap + 0x1000);\n      *(undefined8 *)(pcVar8 + 8) = *(undefined8 *)(lVar10 + 0x1008);\n      rl_discard_keymap();\n      rl_binding_keymap = param_4;\n    }\n  }\n  goto LAB_001db42d;\n}\n\n",
  "save_posix_options": "\nvoid save_posix_options(void)\n\n{\n  undefined4 *puVar1;\n  undefined4 *puVar2;\n  long lVar3;\n  undefined4 *puVar4;\n  \n  if (DAT_00241ea0 == 0) {\n    DAT_00241ea0 = sh_xmalloc(5,\"general.c\",0x8f);\n  }\n  lVar3 = 0;\n  puVar1 = &source_uses_path;\n  puVar4 = &interactive_comments;\n  while( true ) {\n    puVar2 = puVar1;\n    *(char *)(DAT_00241ea0 + lVar3) = (char)*puVar4;\n    lVar3 = lVar3 + 1;\n    if (puVar2 == (undefined4 *)0x0) break;\n    puVar1 = (undefined4 *)(&PTR_source_uses_path_00235f88)[lVar3];\n    puVar4 = puVar2;\n  }\n  return;\n}\n\n",
  "setvbuf": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint setvbuf(FILE *__stream,char *__buf,int __modes,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_setvbuf_00237ce0)();\n  return iVar1;\n}\n\n",
  "FUN_0015b0b0": "\nvoid FUN_0015b0b0(int param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = get_name_for_error();\n  if ((param_1 != 0) && (interactive_shell == 0)) {\n    iVar1 = executing_line_number();\n    if (0 < iVar1) {\n      pcVar3 = \"\";\n      if (gnu_error_format == 0) {\n        pcVar3 = \" line \";\n      }\n      __fprintf_chk(stderr,1,\"%s:%s%d: \",uVar2,pcVar3,iVar1);\n      return;\n    }\n  }\n  __fprintf_chk(stderr,1,&DAT_001fd57b,uVar2);\n  return;\n}\n\n",
  "_rl_strindex": "\nchar * _rl_strindex(char *param_1,char *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  size_t sVar4;\n  \n  sVar4 = strlen(param_2);\n  iVar2 = (int)sVar4;\n  sVar4 = strlen(param_1);\n  if (iVar2 <= (int)sVar4) {\n    iVar1 = (int)param_1;\n    do {\n      iVar3 = strncasecmp(param_1,param_2,(long)iVar2);\n      if (iVar3 == 0) {\n        return param_1;\n      }\n      param_1 = param_1 + 1;\n    } while (iVar2 <= ((int)sVar4 + iVar1) - (int)param_1);\n  }\n  return (char *)0x0;\n}\n\n",
  "stpcpy": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * stpcpy(char *__dest,char *__src)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_stpcpy_002379a0)();\n  return pcVar1;\n}\n\n",
  "dequote_list": "\nlong * dequote_list(long *param_1)\n\n{\n  char **ppcVar1;\n  long *plVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  long *plVar5;\n  \n  plVar5 = param_1;\n  if (param_1 != (long *)0x0) {\n    do {\n      uVar4 = dequote_string(*(undefined8 *)plVar5[1]);\n      pcVar3 = *(char **)plVar5[1];\n      if ((*pcVar3 == '\\x7f') && (pcVar3[1] == '\\0')) {\n        ppcVar1 = (char **)plVar5[1] + 1;\n        *(uint *)ppcVar1 = *(uint *)ppcVar1 & 0xfffbffff;\n      }\n      sh_xfree(pcVar3,\"subst.c\",0x1365);\n      plVar2 = (long *)*plVar5;\n      *(undefined8 *)plVar5[1] = uVar4;\n      plVar5 = plVar2;\n    } while (plVar2 != (long *)0x0);\n  }\n  return param_1;\n}\n\n",
  "pop_var_context": "\nvoid pop_var_context(void)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  \n  lVar3 = shell_variables;\n  if ((*(byte *)(shell_variables + 0xc) & 4) == 0) {\n    internal_error(\"pop_var_context: head of shell_variables not a function context\");\n    return;\n  }\n  lVar1 = *(long *)(shell_variables + 0x18);\n  if (lVar1 != 0) {\n    lVar2 = *(long *)(shell_variables + 0x20);\n    *(undefined8 *)(lVar1 + 0x10) = 0;\n    shell_variables = lVar1;\n    if (lVar2 != 0) {\n      hash_flush(lVar2,FUN_0015a300);\n    }\n    dispose_var_context(lVar3);\n    return;\n  }\n  internal_error(\"pop_var_context: no global_variables context\");\n  return;\n}\n\n",
  "FUN_001e0800": "\nvoid FUN_001e0800(long param_1,long param_2,int param_3)\n\n{\n  byte bVar1;\n  int iVar2;\n  long lVar3;\n  char cVar4;\n  int iVar5;\n  \n  if (param_3 < 1) {\n    return;\n  }\n  iVar5 = 0x30;\n  lVar3 = 0;\n  do {\n    iVar2 = (int)*(char *)(param_2 + lVar3);\n    bVar1 = *(byte *)(param_1 + lVar3);\n    cVar4 = (char)iVar5;\n    if (cVar4 == *(char *)(param_2 + lVar3)) {\nLAB_001e0870:\n      putc((uint)bVar1,rl_outstream);\n    }\n    else if (((byte)(cVar4 - 0x30U) < 2) && (iVar2 - 0x30U < 2)) {\n      if ((iVar2 == 0x31) && (cVar4 == '0')) {\n        _rl_region_color_on();\n        iVar5 = 0x31;\n      }\n      else {\n        iVar5 = iVar2;\n        if ((iVar2 == 0x30) && (cVar4 == '1')) {\n          _rl_region_color_off();\n          iVar5 = 0x30;\n        }\n      }\n      goto LAB_001e0870;\n    }\n    lVar3 = lVar3 + 1;\n    if (param_3 == lVar3) {\n      if ((char)iVar5 != '1') {\n        return;\n      }\n      _rl_region_color_off();\n      return;\n    }\n  } while( true );\n}\n\n",
  "_rl_scxt_alloc": "\nundefined4 * _rl_scxt_alloc(undefined4 param_1,undefined4 param_2)\n\n{\n  undefined *puVar1;\n  undefined4 uVar2;\n  undefined4 *puVar3;\n  \n  puVar3 = (undefined4 *)xmalloc(0xa8);\n  *puVar3 = param_1;\n  puVar3[1] = param_2;\n  *(undefined8 *)(puVar3 + 2) = 0;\n  *(undefined8 *)(puVar3 + 4) = 0;\n  *(undefined8 *)(puVar3 + 6) = 0;\n  *(undefined8 *)(puVar3 + 8) = 0;\n  *(undefined8 *)(puVar3 + 10) = 0;\n  puVar3[0xc] = rl_point;\n  puVar3[0xd] = rl_mark;\n  uVar2 = where_history();\n  *(undefined8 *)(puVar3 + 0x10) = 0;\n  puVar3[0xe] = uVar2;\n  puVar3[0xf] = uVar2;\n  puVar1 = _rl_keymap;\n  *(undefined8 *)(puVar3 + 0x12) = 0;\n  *(undefined **)(puVar3 + 0x14) = puVar1;\n  *(undefined **)(puVar3 + 0x16) = puVar1;\n  *(undefined8 *)(puVar3 + 0x18) = 0;\n  *(undefined8 *)(puVar3 + 0x1a) = 0;\n  *(undefined8 *)(puVar3 + 0x24) = 0;\n  *(undefined8 *)(puVar3 + 0x26) = 0;\n  *(undefined8 *)(puVar3 + 0x28) = 0;\n  return puVar3;\n}\n\n",
  "_rl_strip_prompt": "\nvoid _rl_strip_prompt(undefined8 param_1)\n\n{\n  FUN_001e0bd0(param_1,0,0,0,0,0);\n  return;\n}\n\n",
  "rl_vi_redo": "\nundefined4 rl_vi_redo(int param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  \n  if (rl_explicit_arg == 0) {\n    rl_numeric_arg = DAT_0023b36c;\n    rl_arg_sign = DAT_0023b368;\n  }\n  _rl_vi_redoing = 1;\n  if (_rl_vi_last_command == 0x69) {\n    if ((DAT_0024a408 != (char *)0x0) && (*DAT_0024a408 != '\\0')) {\n      rl_begin_undo_group();\n      if (param_1 != 0) {\n        do {\n          rl_insert_text(DAT_0024a408);\n          param_1 = param_1 + -1;\n        } while (param_1 != 0);\n      }\nLAB_001d05c8:\n      rl_end_undo_group();\n      if (rl_point < 1) {\n        _rl_vi_redoing = 0;\n        return 0;\n      }\n      sVar3 = __ctype_get_mb_cur_max();\n      if ((1 < sVar3) && (rl_byte_oriented == 0)) {\n        rl_point = _rl_find_prev_mbchar(rl_line_buffer,rl_point,1);\n        _rl_vi_redoing = 0;\n        return 0;\n      }\n      rl_point = rl_point + -1;\n      _rl_vi_redoing = 0;\n      return 0;\n    }\n  }\n  else if (_rl_vi_last_command == 0x52) {\n    if ((DAT_0024a408 != (char *)0x0) && (*DAT_0024a408 != '\\0')) {\n      sVar3 = strlen(DAT_0024a408);\n      rl_begin_undo_group();\n      if (param_1 != 0) {\n        do {\n          _rl_replace_text(DAT_0024a408,rl_point,(int)sVar3 + -1 + rl_point);\n          param_1 = param_1 + -1;\n        } while (param_1 != 0);\n      }\n      goto LAB_001d05c8;\n    }\n  }\n  else if (_rl_vi_last_command == 0x49) {\n    if ((DAT_0024a408 != (char *)0x0) && (*DAT_0024a408 != '\\0')) {\n      rl_beg_of_line(1,0x49);\n      rl_begin_undo_group();\n      if (param_1 != 0) {\n        do {\n          rl_insert_text(DAT_0024a408);\n          param_1 = param_1 + -1;\n        } while (param_1 != 0);\n      }\n      goto LAB_001d05c8;\n    }\n  }\n  else if (_rl_vi_last_command == 0x61) {\n    if ((DAT_0024a408 != (char *)0x0) && (*DAT_0024a408 != '\\0')) {\n      if (rl_point < rl_end) {\n        sVar3 = __ctype_get_mb_cur_max();\n        iVar1 = rl_point;\n        if ((sVar3 == 1) || (rl_byte_oriented != 0)) {\n          rl_point = rl_point + 1;\n        }\n        else {\n          rl_point = _rl_forward_char_internal(1);\n          if ((rl_point == iVar1) || (rl_end < rl_point)) {\n            rl_point = rl_end;\n          }\n        }\n      }\n      rl_begin_undo_group();\n      if (param_1 != 0) {\n        do {\n          rl_insert_text(DAT_0024a408);\n          param_1 = param_1 + -1;\n        } while (param_1 != 0);\n      }\n      goto LAB_001d05c8;\n    }\n  }\n  else if (_rl_vi_last_command == 0x41) {\n    if ((DAT_0024a408 != (char *)0x0) && (*DAT_0024a408 != '\\0')) {\n      rl_end_of_line(1,0x41);\n      rl_begin_undo_group();\n      if (param_1 != 0) {\n        do {\n          rl_insert_text(DAT_0024a408);\n          param_1 = param_1 + -1;\n        } while (param_1 != 0);\n      }\n      goto LAB_001d05c8;\n    }\n  }\n  else if ((_rl_vi_last_command == 0x2e) && (_rl_keymap == vi_movement_keymap)) {\n    rl_ding();\n    _rl_vi_redoing = 0;\n    return 0;\n  }\n  uVar2 = _rl_dispatch(_rl_vi_last_command,_rl_keymap);\n  _rl_vi_redoing = 0;\n  return uVar2;\n}\n\n",
  "rl_replace_line": "\nvoid rl_replace_line(char *param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  size_t sVar3;\n  \n  sVar3 = strlen(param_1);\n  iVar2 = (int)sVar3;\n  if (rl_line_buffer_len <= iVar2) {\n    rl_extend_line_buffer(sVar3 & 0xffffffff);\n  }\n  strcpy(rl_line_buffer,param_1);\n  rl_end = iVar2;\n  if (param_2 != 0) {\n    rl_free_undo_list();\n  }\n  iVar2 = rl_end;\n  if ((rl_point <= rl_end) && (iVar2 = rl_point, rl_point < 0)) {\n    rl_point = 0;\n    iVar2 = rl_point;\n  }\n  iVar1 = rl_end;\n  if ((rl_mark <= rl_end) && (rl_point = iVar2, iVar1 = rl_mark, rl_mark < 0)) {\n    rl_mark = 0;\n    return;\n  }\n  rl_mark = iVar1;\n  rl_point = iVar2;\n  return;\n}\n\n",
  "FUN_00144630": "\nvoid FUN_00144630(int param_1)\n\n{\n  if (the_printed_command == 0) {\n    the_printed_command_size = param_1 + 0x3fU & 0xffffffc0;\n    the_printed_command = sh_xmalloc((long)(int)the_printed_command_size,\"print_cmd.c\",0x648);\n    command_string_index = 0;\n    return;\n  }\n  if (param_1 + command_string_index < (int)the_printed_command_size) {\n    return;\n  }\n  the_printed_command_size = param_1 + command_string_index + 0x80U & 0xffffff80;\n  the_printed_command =\n       sh_xrealloc(the_printed_command,(long)(int)the_printed_command_size,\"print_cmd.c\",0x654);\n  return;\n}\n\n",
  "new_var_context": "\nchar ** new_var_context(char *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  char **ppcVar2;\n  size_t sVar3;\n  char *__dest;\n  \n  ppcVar2 = (char **)sh_xmalloc(0x28,\"variables.c\",0x146b);\n  if (param_1 != (char *)0x0) {\n    sVar3 = strlen(param_1);\n    __dest = (char *)sh_xmalloc(sVar3 + 1,\"variables.c\",0x146c);\n    param_1 = strcpy(__dest,param_1);\n  }\n  uVar1 = variable_context;\n  *ppcVar2 = param_1;\n  *(undefined4 *)((long)ppcVar2 + 0xc) = param_2;\n  *(undefined4 *)(ppcVar2 + 1) = uVar1;\n  ppcVar2[3] = (char *)0x0;\n  ppcVar2[2] = (char *)0x0;\n  ppcVar2[4] = (char *)0x0;\n  return ppcVar2;\n}\n\n",
  "rl_complete": "\nvoid rl_complete(undefined8 param_1,undefined4 param_2)\n\n{\n  rl_completion_invoking_key = param_2;\n  if (rl_inhibit_completion != 0) {\n    _rl_insert_char();\n    return;\n  }\n  if ((rl_last_func == rl_complete) && (DAT_0024a730 == 0)) {\n    rl_complete_internal(0x3f);\n    return;\n  }\n  if (_rl_complete_show_all != 0) {\n    rl_complete_internal(0x21);\n    return;\n  }\n  if (_rl_complete_show_unmodified != 0) {\n    rl_complete_internal(0x40);\n    return;\n  }\n  rl_complete_internal(9);\n  return;\n}\n\n",
  "rl_abort": "\nvoid rl_abort(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  _rl_abort_internal();\n}\n\n",
  "assignment": "\nulong assignment(byte *param_1,uint param_2)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint uVar3;\n  ushort **ppuVar4;\n  ulong uVar5;\n  \n  bVar1 = *param_1;\n  if ((param_2 & 1) == 0) {\n    ppuVar4 = __ctype_b_loc();\n    if (((*(byte *)((long)*ppuVar4 + (ulong)bVar1 * 2 + 1) & 4) != 0) || (bVar1 == 0x5f)) {\n      uVar5 = 0;\n      while (bVar1 != 0) {\n        iVar2 = (int)(uVar5 & 0xffffffff);\n        if (bVar1 == 0x3d) {\n          return uVar5 & 0xffffffff;\n        }\n        if (bVar1 == 0x5b) goto LAB_00141a52;\n        if ((bVar1 == 0x2b) && (param_1[uVar5 + 1] == 0x3d)) {\n          return (ulong)(iVar2 + 1);\n        }\n        ppuVar4 = __ctype_b_loc();\n        if (((*(byte *)(*ppuVar4 + bVar1) & 8) == 0) && (bVar1 != 0x5f)) {\n          return 0;\n        }\n        uVar5 = uVar5 + 1;\n        bVar1 = param_1[uVar5];\n      }\n    }\n  }\n  else if (bVar1 == 0x5b) {\n    iVar2 = 0;\nLAB_00141a52:\n    iVar2 = skipsubscript(param_1,iVar2,(int)param_2 >> 1 & 1);\n    if (param_1[iVar2] == 0x5d) {\n      uVar3 = iVar2 + 1;\n      bVar1 = param_1[(int)uVar3];\n      if (bVar1 == 0x2b) {\n        bVar1 = param_1[(long)(int)uVar3 + 1];\n        uVar3 = iVar2 + 2;\n      }\n      if (bVar1 == 0x3d) {\n        return (ulong)uVar3;\n      }\n    }\n  }\n  return 0;\n}\n\n",
  "_rl_init_eightbit": "\nundefined4 _rl_init_eightbit(void)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  int iVar3;\n  char *__s1;\n  \n  uVar2 = DAT_0024b6b0;\n  __s1 = (char *)_rl_init_locale();\n  xfree(uVar2);\n  if ((__s1 == (char *)0x0) || (cVar1 = *__s1, cVar1 == '\\0')) {\n    return 0;\n  }\n  if (cVar1 == 'C') {\n    if (__s1[1] == '\\0') {\n      return 0;\n    }\n  }\n  else if ((cVar1 == 'P') && (iVar3 = strcmp(__s1,\"POSIX\"), iVar3 == 0)) {\n    return 0;\n  }\n  _rl_meta_flag = 1;\n  _rl_convert_meta_chars_to_ascii = 0;\n  _rl_output_meta_chars = 1;\n  return 1;\n}\n\n",
  "_rl_get_char_len": "\nulong _rl_get_char_len(char *param_1,mbstate_t *param_2)\n\n{\n  size_t __n;\n  ulong uVar1;\n  size_t sVar2;\n  \n  __n = strlen(param_1);\n  if (((_rl_utf8locale == 0) || (__n == 0)) || (*param_1 < '\\0')) {\n    sVar2 = __ctype_get_mb_cur_max();\n    if ((ulong)(long)(int)sVar2 <= __n) {\n      __n = (long)(int)sVar2;\n    }\n    if (param_2 == (mbstate_t *)0x0) {\n      uVar1 = __mbrlen(param_1,__n,(mbstate_t *)0x0);\n      if (uVar1 == 0xfffffffffffffffe) {\n        return 0xfffffffe;\n      }\n      if (uVar1 == 0xffffffffffffffff) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      uVar1 = mbrtowc((wchar_t *)0x0,param_1,__n,param_2);\n      if (uVar1 == 0xfffffffffffffffe) {\n        param_2->__count = 0;\n        param_2->__value = (_union_27)0x0;\n        return 0xfffffffe;\n      }\n      if (uVar1 == 0xffffffffffffffff) {\n        param_2->__count = 0;\n        param_2->__value = (_union_27)0x0;\n        return 0xffffffff;\n      }\n    }\n    if (uVar1 == 0) {\n      return 0;\n    }\n  }\n  else {\n    uVar1 = 1;\n    if (*param_1 == '\\0') {\n      return 0;\n    }\n  }\n  return uVar1 & 0xffffffff;\n}\n\n",
  "print_case_command_head": "\nvoid print_case_command_head(long param_1)\n\n{\n  FUN_001446d0(\"case %s in \",**(undefined8 **)(param_1 + 8));\n  return;\n}\n\n",
  "rl_add_funmap_entry": "\nvoid rl_add_funmap_entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long lVar4;\n  \n  lVar4 = (long)DAT_0024a43c;\n  if (DAT_0024a440 <= DAT_0024a43c + 2) {\n    DAT_0024a440 = DAT_0024a440 + 0x40;\n    funmap = xrealloc(funmap,(long)DAT_0024a440 << 3);\n    lVar4 = (long)DAT_0024a43c;\n  }\n  puVar1 = (undefined8 *)(funmap + lVar4 * 8);\n  uVar2 = xmalloc(0x10);\n  lVar4 = funmap;\n  lVar3 = (long)DAT_0024a43c;\n  *puVar1 = uVar2;\n  puVar1 = *(undefined8 **)(lVar4 + lVar3 * 8);\n  DAT_0024a43c = DAT_0024a43c + 1;\n  *puVar1 = param_1;\n  puVar1[1] = param_2;\n  *(undefined8 *)(lVar4 + 8 + lVar3 * 8) = 0;\n  return;\n}\n\n",
  "FUN_001d4590": "\nvoid FUN_001d4590(undefined8 *param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = _rl_saved_line_for_history;\n  if (_rl_saved_line_for_history != 0) {\n    lVar1 = *(long *)(_rl_saved_line_for_history + 0x10);\n  }\n  if (((rl_undo_list != 0) && (param_1[2] != rl_undo_list)) && (rl_undo_list != lVar1)) {\n    rl_free_undo_list();\n  }\n  _rl_replace_text(*param_1,0,rl_end);\n  _rl_fix_point(1);\n  if (rl_editing_mode == 0) {\n    rl_free_undo_list();\n  }\n  if (_rl_saved_line_for_history != 0) {\n    _rl_free_history_entry();\n  }\n  _rl_saved_line_for_history = 0;\n  return;\n}\n\n",
  "FUN_00134ae0": "\nundefined4 FUN_00134ae0(undefined4 param_1)\n\n{\n  if ((current_readline_line_index != 0) && (current_readline_line != 0)) {\n    current_readline_line_index = current_readline_line_index + -1;\n    *(char *)(current_readline_line + current_readline_line_index) = (char)param_1;\n  }\n  return param_1;\n}\n\n",
  "FUN_0015bcf0": "\nvoid FUN_0015bcf0_noreturn_(undefined8 param_1)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  pcVar1 = DAT_00242460;\n  pcVar4 = DAT_00242450;\n  if (DAT_00242460 == (char *)0x0) {\n    if ((DAT_00242450 == (char *)0x0) || (pcVar1 = \"\", *DAT_00242450 == '\\0')) {\n      pcVar1 = \"\";\n      pcVar4 = pcVar1;\n    }\n  }\n  else {\n    for (; (*pcVar1 == ' ' || (*pcVar1 == '\\t')); pcVar1 = pcVar1 + 1) {\n    }\n    if ((DAT_00242450 == (char *)0x0) || (*DAT_00242450 == '\\0')) {\n      pcVar4 = \"\";\n    }\n  }\n  pcVar2 = \": \";\n  pcVar3 = this_command_name;\n  if (this_command_name == (char *)0x0) {\n    pcVar2 = \"\";\n    pcVar3 = pcVar2;\n  }\n  internal_error(\"%s%s%s: %s (error token is \\\"%s\\\")\",pcVar3,pcVar2,pcVar1,param_1,pcVar4);\n                    /* WARNING: Subroutine does not return */\n  __longjmp_chk(&DAT_00242360,1);\n}\n\n",
  "all_visible_functions": "\nvoid * all_visible_functions(void)\n\n{\n  int iVar1;\n  void *__base;\n  \n  __base = (void *)map_over_funcs(FUN_00151280);\n  if (__base != (void *)0x0) {\n    iVar1 = strvec_len(__base);\n    qsort(__base,(long)iVar1,8,FUN_001513a0);\n  }\n  return __base;\n}\n\n",
  "FUN_0019e740": "\nundefined8 FUN_0019e740(undefined8 param_1)\n\n{\n  FUN_0019e5f0(param_1,all_array_variables);\n  return 1;\n}\n\n",
  "FUN_001b61f0": "\nvoid FUN_001b61f0(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  long *plVar4;\n  long *plVar5;\n  long *plVar6;\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_128);\n  sigaddset(&sStack_128,0x11);\n  sigemptyset(&local_a8);\n  sigprocmask(0,&sStack_128,&local_a8);\n  if (0 < DAT_0023877c) {\n    uVar1 = DAT_0023877c - 1;\n    plVar2 = jobs + 1;\n    plVar4 = plVar2;\n    plVar6 = jobs;\n    while( true ) {\n      plVar5 = plVar4;\n      lVar3 = *plVar6;\n      if ((lVar3 != 0) && ((*(uint *)(lVar3 + 0x18) & 0x80) != 0)) {\n        *(uint *)(lVar3 + 0x18) = *(uint *)(lVar3 + 0x18) & 0xffffff7f;\n      }\n      if (plVar5 == plVar2 + uVar1) break;\n      plVar4 = plVar5 + 1;\n      plVar6 = plVar5;\n    }\n  }\n  sigprocmask(2,&local_a8,(sigset_t *)0x0);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "maybe_append_history": "\nundefined8 maybe_append_history(char *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  long in_FS_OFFSET;\n  stat sStack_b8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (history_lines_this_session < 1) {\n    history_lines_this_session = 0;\n    uVar3 = 0;\n  }\n  else {\n    iVar1 = stat(param_1,&sStack_b8);\n    if (iVar1 == -1) {\n      piVar2 = __errno_location();\n      if (*piVar2 == 2) {\n        iVar1 = open(param_1,0x41,0x180);\n        if (iVar1 < 0) {\n          pcVar4 = strerror(*piVar2);\n          builtin_error(\"%s: cannot create: %s\",param_1,pcVar4);\n          uVar3 = 1;\n          goto LAB_00190af6;\n        }\n        close(iVar1);\n      }\n    }\n    iVar1 = where_history();\n    if ((0 < iVar1) && (iVar1 < history_lines_this_session)) {\n      history_lines_this_session = iVar1;\n    }\n    uVar3 = append_history(history_lines_this_session,param_1);\n    iVar1 = history_lines_this_session;\n    history_lines_this_session = 0;\n    history_lines_in_file = history_lines_in_file + iVar1;\n  }\nLAB_00190af6:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00151390": "\nvoid FUN_00151390(long param_1)\n\n{\n  *(undefined4 *)(param_1 + 0x2c) = variable_context;\n  return;\n}\n\n",
  "get_job_by_pid": "\nulong get_job_by_pid(ulong param_1,int param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long in_FS_OFFSET;\n  sigset_t sStack_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 0) {\n    if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar2 = FUN_0015e6b0(param_1,0);\n      return uVar2;\n    }\n  }\n  else {\n    sigemptyset(&sStack_138);\n    sigaddset(&sStack_138,0x11);\n    sigemptyset(&local_b8);\n    sigprocmask(0,&sStack_138,&local_b8);\n    uVar1 = FUN_0015e6b0(param_1 & 0xffffffff,0,param_3);\n    sigprocmask(2,&local_b8,(sigset_t *)0x0);\n    if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return (ulong)uVar1;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "zread": "\nssize_t zread(int param_1,void *param_2,size_t param_3)\n\n{\n  int iVar1;\n  int *piVar2;\n  ssize_t sVar3;\n  \n  check_signals();\n  while( true ) {\n    iVar1 = read_builtin_timeout(param_1);\n    sVar3 = (ssize_t)iVar1;\n    if ((-1 < sVar3) && (sVar3 = read(param_1,param_2,param_3), -1 < sVar3)) break;\n    piVar2 = __errno_location();\n    if (*piVar2 != 4) {\n      return sVar3;\n    }\n    if (executing_builtin == 0) {\n      check_signals();\n    }\n    else {\n      check_signals_and_traps();\n    }\n    *piVar2 = 4;\n  }\n  return sVar3;\n}\n\n",
  "_rl_replace_text": "\nundefined4 _rl_replace_text(char *param_1,int param_2,int param_3)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  \n  rl_begin_undo_group();\n  if (param_3 < param_2) {\n    cVar1 = *param_1;\n  }\n  else {\n    rl_delete_text(param_2,param_3 + 1);\n    cVar1 = *param_1;\n  }\n  uVar2 = 0;\n  rl_point = param_2;\n  if (cVar1 != '\\0') {\n    uVar2 = rl_insert_text(param_1);\n  }\n  rl_end_undo_group();\n  return uVar2;\n}\n\n",
  "FUN_001f22b0": "\nvoid FUN_001f22b0(long param_1,uint *param_2,uint param_3)\n\n{\n  char cVar1;\n  uint uVar2;\n  ulong uVar3;\n  ulong uVar4;\n  \n  uVar2 = *param_2;\n  uVar3 = (ulong)(int)uVar2;\n  cVar1 = *(char *)(param_1 + uVar3);\n  if ((cVar1 != '\\0') && (cVar1 != '\\'')) {\n    uVar4 = uVar3;\n    do {\n      if ((cVar1 == '\\\\') && ((param_3 & 1) != 0)) {\n        uVar2 = ((int)uVar3 - (uint)(*(char *)(param_1 + 1 + uVar4) == '\\0')) + 2;\n        uVar4 = (ulong)(int)uVar2;\n        cVar1 = *(char *)(param_1 + uVar4);\n      }\n      else {\n        uVar2 = (int)uVar3 + 1;\n        uVar4 = (ulong)(int)uVar2;\n        cVar1 = *(char *)(param_1 + uVar4);\n      }\n    } while ((cVar1 != '\\0') && (uVar3 = (ulong)uVar2, cVar1 != '\\''));\n  }\n  *param_2 = uVar2;\n  return;\n}\n\n",
  "FUN_001738e0": "\nchar * FUN_001738e0(byte *param_1,uint param_2,code *param_3)\n\n{\n  byte bVar1;\n  bool bVar2;\n  mbstate_t mVar3;\n  size_t sVar4;\n  size_t sVar5;\n  ulong uVar6;\n  char *pcVar7;\n  long lVar8;\n  byte *__s;\n  int iVar9;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  sVar5 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar4 = __ctype_get_mb_cur_max();\n  if (1 < sVar4) {\n    sVar5 = strlen((char *)param_1);\n  }\n  bVar1 = *param_1;\n  if (bVar1 != 0) {\n    bVar2 = false;\n    iVar9 = 0;\n    lVar8 = 0;\n    __s = param_1;\n    do {\n      mVar3 = local_48;\n      if ((char)bVar1 < '?') {\n        if ('\\0' < (char)bVar1) {\n          uVar6 = 1L << (bVar1 & 0x3f);\n          if ((uVar6 & 0x5000001000000002) != 0) goto LAB_001739ba;\n          if ((uVar6 & 0x8400000000) != 0) {\n            bVar2 = true;\n          }\n        }\n        if (locale_mb_cur_max < 2) goto LAB_00173a22;\nLAB_00173990:\n        if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n          if ((locale_utf8locale != 0) && (sVar4 = 1, -1 < (char)bVar1)) goto LAB_001739ab;\n          sVar4 = mbrtowc((wchar_t *)0x0,(char *)__s,sVar5 - lVar8,&local_48);\n          if (sVar4 < 0xfffffffffffffffe) {\n            if (sVar4 == 0) goto LAB_00173a22;\n            goto LAB_001739ab;\n          }\n          iVar9 = iVar9 + 1;\n          local_48 = mVar3;\n        }\n        else {\n          sVar4 = 1;\nLAB_001739ab:\n          iVar9 = iVar9 + (int)sVar4;\n        }\n      }\n      else {\n        if ((bVar1 == 0x60) || (bVar1 == 0x7e)) {\nLAB_001739ba:\n          pcVar7 = (char *)0x0;\n          lVar8 = (*param_3)(param_1,param_2);\n          if (lVar8 != 0) {\n            pcVar7 = (char *)string_list_internal(lVar8,&DAT_001fdb1c);\n            dispose_words(lVar8);\n          }\n          goto LAB_001739e8;\n        }\n        if (bVar1 == 0x5c) {\n          bVar2 = true;\n        }\n        if (1 < locale_mb_cur_max) goto LAB_00173990;\nLAB_00173a22:\n        iVar9 = iVar9 + 1;\n      }\n      lVar8 = (long)iVar9;\n      __s = param_1 + lVar8;\n      bVar1 = *__s;\n    } while (bVar1 != 0);\n    if ((bVar2) && ((param_2 & 3) == 0)) {\n      pcVar7 = (char *)string_quote_removal(param_1,param_2);\n      goto LAB_001739e8;\n    }\n  }\n  sVar4 = strlen((char *)param_1);\n  pcVar7 = (char *)sh_xmalloc(sVar4 + 1,\"subst.c\",0xf0f);\n  pcVar7 = strcpy(pcVar7,(char *)param_1);\nLAB_001739e8:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pcVar7;\n}\n\n",
  "rl_tty_status": "\nundefined8 rl_tty_status(void)\n\n{\n  rl_ding();\n  return 0;\n}\n\n",
  "FUN_001da5d0": "\nundefined8 FUN_001da5d0(char *param_1)\n\n{\n  long lVar1;\n  \n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    lVar1 = strtol(param_1,(char **)0x0,10);\n    _rl_completion_columns = (int)lVar1;\n    return 0;\n  }\n  _rl_completion_columns = 0xffffffff;\n  return 0;\n}\n\n",
  "rl_re_read_init_file": "\nvoid rl_re_read_init_file(void)\n\n{\n  int iVar1;\n  char *pcVar2;\n  \n  pcVar2 = DAT_0024a7b0;\n  if (((DAT_0024a7b0 == (char *)0x0) &&\n      (pcVar2 = (char *)sh_get_env_value(\"INPUTRC\"), pcVar2 == (char *)0x0)) || (*pcVar2 == '\\0')) {\n    iVar1 = FUN_001ddf90(\"~/.inputrc\",0);\n    pcVar2 = \"/etc/inputrc\";\n    if (iVar1 == 0) goto joined_r0x001de3ae;\n  }\n  FUN_001ddf90(pcVar2,0);\njoined_r0x001de3ae:\n  if (rl_editing_mode == 1) {\n    _rl_keymap = emacs_standard_keymap;\n    return;\n  }\n  if (rl_editing_mode == 0) {\n    _rl_keymap = &vi_insertion_keymap;\n  }\n  return;\n}\n\n",
  "rl_dump_functions": "\nundefined8 rl_dump_functions(void)\n\n{\n  if (rl_dispatching != 0) {\n    fwrite(&DAT_001ff375,1,2,rl_outstream);\n  }\n  rl_function_dumper(rl_explicit_arg);\n  rl_on_new_line();\n  return 0;\n}\n\n",
  "_rl_timeout_init": "\nint _rl_timeout_init(void)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  int iVar3;\n  \n  uVar2 = DAT_0024b3f8;\n  uVar1 = DAT_0024b3f0;\n  DAT_0024b408 = 0;\n  rl_readline_state = rl_readline_state & 0xfffffffffbffffff;\n  DAT_0024b400 = 0;\n  if ((DAT_0024b3f0 | DAT_0024b3f8) != 0) {\n    iVar3 = gettimeofday((timeval *)&DAT_0024b400,(__timezone_ptr_t)0x0);\n    if (iVar3 != 0) {\n      DAT_0024b400 = 0;\n      DAT_0024b408 = 0;\n      return -1;\n    }\n    DAT_0024b400 = (uVar1 & 0xffffffff) + DAT_0024b400;\n    DAT_0024b408 = (uVar2 & 0xffffffff) + DAT_0024b408;\n    if (999999 < DAT_0024b408) {\n      DAT_0024b400 = DAT_0024b400 + 1;\n      DAT_0024b408 = DAT_0024b408 + -1000000;\n      return iVar3;\n    }\n  }\n  return 0;\n}\n\n",
  "dispose_variable": "\nvoid dispose_variable(undefined8 *param_1)\n\n{\n  if (param_1 != (undefined8 *)0x0) {\n    if ((*(uint *)(param_1 + 5) & 0x20000) == 0) {\n      FUN_001522f0(param_1[1]);\n    }\n    if (param_1[2] != 0) {\n      sh_xfree(param_1[2],\"variables.c\",0xed1);\n    }\n    sh_xfree(*param_1,\"variables.c\",0xed3);\n    if ((*(byte *)(param_1 + 5) & 1) != 0) {\n      array_needs_making = 1;\n    }\n    sh_xfree(param_1,\"variables.c\",0xed8);\n    return;\n  }\n  return;\n}\n\n",
  "make_pattern_list": "\nundefined8 * make_pattern_list(long *param_1,undefined8 param_2)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0x178);\n  if ((param_1 != (long *)0x0) && (*param_1 != 0)) {\n    param_1 = (long *)list_reverse(param_1);\n  }\n  puVar1[1] = param_1;\n  puVar1[2] = param_2;\n  *puVar1 = 0;\n  *(undefined4 *)(puVar1 + 3) = 0;\n  return puVar1;\n}\n\n",
  "FUN_00131c1b": "\nvoid FUN_00131c1b(void)\n\n{\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n",
  "FUN_001f8ee0": "\nvoid FUN_001f8ee0(undefined2 *param_1,char *param_2,undefined4 param_3)\n\n{\n  char cVar1;\n  ulong __len;\n  int iVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  char *pcVar6;\n  long lVar7;\n  ulong uVar8;\n  undefined2 *puVar9;\n  undefined *puVar10;\n  undefined2 *__addr;\n  undefined2 *puVar11;\n  undefined2 *local_58;\n  undefined2 *local_48;\n  \n  if (param_1 == (undefined2 *)0x0) {\n    return;\n  }\n  if (*(char *)(param_1 + -8) == -0x2a) {\n    local_48 = (undefined2 *)((long)param_1 - (ulong)*(uint *)(param_1 + -6));\n    __addr = local_48 + -8;\n  }\n  else {\n    __addr = param_1 + -8;\n    local_48 = param_1;\n  }\n  if (*(char *)__addr != -9) {\n    pcVar6 = \"unknown\";\n    if (param_2 != (char *)0x0) {\n      pcVar6 = param_2;\n    }\n    if (*(char *)__addr != 'T') {\n      __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar6,param_3);\n      fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n      programming_error(\"free: called with unallocated block argument\",param_2,param_3);\n    }\n    __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar6,param_3);\n    fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"free: called with already freed block argument\",param_2,param_3);\n  }\n  if (__addr[1] != 0x5555) {\n    pcVar6 = \"unknown\";\n    if (param_2 != (char *)0x0) {\n      pcVar6 = param_2;\n    }\n    __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar6,param_3);\n    fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"p->minfo.mi_magic2 == 0x5555\",param_2,param_3);\n  }\n  cVar1 = *(char *)((long)__addr + 1);\n  __len = (&DAT_00214400)[cVar1];\n  iVar2 = (int)cVar1;\n  if (__len < (*(int *)(__addr + 2) + 0x23U & 0xfffffff0)) {\n    pcVar6 = \"unknown\";\n    if (param_2 != (char *)0x0) {\n      pcVar6 = param_2;\n    }\n    __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar6,param_3);\n    fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"free: underflow detected; mh_nbytes out of range\",param_2,param_3);\n  }\n  puVar9 = __addr + 4;\n  pcVar6 = \"unknown\";\n  if (param_2 != (char *)0x0) {\n    pcVar6 = param_2;\n  }\n  do {\n    puVar11 = (undefined2 *)((long)puVar9 + 1);\n    if (*(char *)puVar9 != 'U') {\n      __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar6,param_3);\n      fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n      programming_error(\"free: underflow detected; magic8 corrupted\",param_2,param_3);\n    }\n    puVar9 = puVar11;\n  } while (puVar11 != __addr + 8);\n  if (*(uint *)(__addr + 2) != *(uint *)((long)local_48 + (ulong)*(uint *)(__addr + 2))) {\n    pcVar6 = \"unknown\";\n    if (param_2 != (char *)0x0) {\n      pcVar6 = param_2;\n    }\n    __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar6,param_3);\n    fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"free: start and end chunk sizes differ\",param_2,param_3);\n  }\n  if (malloc_mmap_threshold < iVar2) {\n    munmap(__addr,__len);\n    return;\n  }\n  if ((7 < iVar2) && (DAT_0024b790 == (undefined *)(__len + (long)__addr))) {\n    if ((10 < iVar2) || (((&DAT_0024b7b0)[cVar1] != '\\0' || ((&DAT_0024b7e0)[cVar1] != 0)))) {\n      puVar10 = DAT_0024b790 + -__len;\n      sbrk(-__len);\n      DAT_0024b790 = puVar10;\n      return;\n    }\n    uVar3 = *(uint *)(__addr + 2);\n    if (uVar3 != 0) goto LAB_001f91c0;\n    goto LAB_001f908d;\n  }\n  uVar3 = *(uint *)(__addr + 2);\n  if (uVar3 == 0) goto LAB_001f906c;\nLAB_001f91c0:\n  uVar8 = (ulong)uVar3;\n  local_58 = param_1;\n  switch(uVar8) {\n  case 0:\n  case 1:\n    *(undefined *)param_1 = 0xcf;\n    break;\n  case 2:\n    *param_1 = 0xcfcf;\n    break;\n  case 3:\n    *param_1 = 0xcfcf;\n    *(undefined *)(param_1 + 1) = 0xcf;\n    break;\n  case 4:\n    uVar8 = 0;\n    goto LAB_001f92f6;\n  case 5:\n    uVar8 = 0;\n    goto switchD_001f91ed_caseD_5;\n  case 6:\n    uVar8 = 0;\n    goto switchD_001f91ed_caseD_6;\n  case 7:\n    uVar8 = 0;\n    goto switchD_001f91ed_caseD_7;\n  case 0xbad1abe1:\n    uVar8 = uVar8 - 1 >> 3;\n    switch(uVar3 & 7) {\n    case 0:\n      goto LAB_001f9333;\n    case 1:\n      goto switchD_001f91ed_caseD_1;\n    case 2:\n      goto LAB_001f930e;\n    case 3:\n      goto switchD_001f91ed_caseD_3;\n    case 4:\n      break;\n    case 5:\n      goto switchD_001f91ed_caseD_5;\n    case 6:\n      goto switchD_001f91ed_caseD_6;\n    case 7:\n      goto switchD_001f91ed_caseD_7;\n    }\nLAB_001f92f6:\n    while( true ) {\n      local_58 = (undefined2 *)((long)param_1 + 1);\n      *(undefined *)param_1 = 0xcf;\nswitchD_001f91ed_caseD_3:\n      *(undefined *)local_58 = 0xcf;\n      param_1 = (undefined2 *)((long)local_58 + 1);\nLAB_001f930e:\n      local_58 = (undefined2 *)((long)param_1 + 1);\n      *(undefined *)param_1 = 0xcf;\nswitchD_001f91ed_caseD_1:\n      *(undefined *)local_58 = 0xcf;\n      if (uVar8 == 0) break;\n      param_1 = (undefined2 *)((long)local_58 + 1);\n      uVar8 = uVar8 - 1;\nLAB_001f9333:\n      local_58 = (undefined2 *)((long)param_1 + 1);\n      *(undefined *)param_1 = 0xcf;\nswitchD_001f91ed_caseD_7:\n      *(undefined *)local_58 = 0xcf;\n      local_58 = (undefined2 *)((long)local_58 + 1);\nswitchD_001f91ed_caseD_6:\n      *(undefined *)local_58 = 0xcf;\n      local_58 = (undefined2 *)((long)local_58 + 1);\nswitchD_001f91ed_caseD_5:\n      *(undefined *)local_58 = 0xcf;\n      param_1 = (undefined2 *)((long)local_58 + 1);\n    }\n    break;\n  default:\n    memset(param_1,0xcf,uVar8);\n  }\nLAB_001f906c:\n  if (0x1b < iVar2) {\n    pcVar6 = \"unknown\";\n    if (param_2 != (char *)0x0) {\n      pcVar6 = param_2;\n    }\n    __fprintf_chk(stderr,1,\"\\r\\nmalloc: %s:%d: assertion botched\\r\\n\",pcVar6,param_3);\n    fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n    programming_error(\"nunits < 28\",param_2,param_3);\n  }\n  if ((&DAT_0024b7b0)[cVar1] == '\\x01') {\n    if (0 < iVar2 + -1) {\n      lVar7 = (long)(iVar2 + -1);\n      do {\n        if ((&DAT_0024b7b0)[lVar7] == '\\0') {\n          iVar4 = (int)lVar7;\n          *(char *)((long)__addr + 1) = (char)lVar7;\n          uVar8 = (&DAT_00214400)[iVar4];\n          *(undefined *)__addr = 0x54;\n          iVar2 = (int)(__len / uVar8);\n          iVar5 = iVar2 + -1;\n          puVar9 = __addr;\n          if (0 < iVar5) {\n            do {\n              puVar9 = (undefined2 *)((long)puVar9 + uVar8);\n              *(undefined2 **)((long)puVar9 + (8 - uVar8)) = puVar9;\n              *(undefined *)puVar9 = 0x54;\n              *(char *)((long)puVar9 + 1) = (char)lVar7;\n              iVar5 = iVar5 + -1;\n            } while (iVar5 != 0);\n            puVar9 = (undefined2 *)(((ulong)(iVar2 - 2) + 1) * uVar8 + (long)__addr);\n          }\n          *(undefined8 *)(puVar9 + 4) = (&DAT_0024b7e0)[iVar4];\n          (&DAT_0024b7e0)[iVar4] = __addr;\n          (&DAT_0024b7b0)[iVar4] = 0;\n          return;\n        }\n        lVar7 = lVar7 + -1;\n      } while (0 < (int)lVar7);\n    }\n  }\n  else {\nLAB_001f908d:\n    *(undefined *)__addr = 0x54;\n    *(undefined8 *)(__addr + 4) = (&DAT_0024b7e0)[cVar1];\n    (&DAT_0024b7e0)[cVar1] = __addr;\n    (&DAT_0024b7b0)[cVar1] = 0;\n  }\n  return;\n}\n\n",
  "FUN_00133640": "\nvoid FUN_00133640(void)\n\n{\n  if (enable_history_list == -1) {\n    enable_history_list = 0;\n  }\n  bash_history_reinit(0);\n  interactive = 0;\n  startup_state = 0;\n  expand_aliases = posixly_correct;\n  interactive_shell = 0;\n  no_line_editing = 1;\n  set_job_control((forced_interactive | jobs_m_flag) != 0);\n  return;\n}\n\n",
  "mapfile_builtin": "\nundefined4 mapfile_builtin(undefined8 param_1)\n\n{\n  bool bVar1;\n  int iVar2;\n  int iVar3;\n  long lVar4;\n  ulong uVar5;\n  long lVar6;\n  char *pcVar7;\n  size_t sVar8;\n  size_t sVar9;\n  undefined8 uVar10;\n  __off_t _Var11;\n  int *piVar12;\n  undefined4 uVar13;\n  int iVar14;\n  uint uVar15;\n  ulong uVar16;\n  ulong uVar17;\n  long in_FS_OFFSET;\n  bool bVar18;\n  char *local_140;\n  ulong local_138;\n  ulong local_130;\n  ulong local_128;\n  char **local_120;\n  undefined8 *local_118;\n  char local_100;\n  ulong local_f0;\n  char *local_e8;\n  undefined8 local_e0;\n  stat local_d8;\n  long local_40;\n  \n  uVar17 = 0;\n  bVar1 = false;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  DAT_00248b40 = 10;\n  reset_internal_getopt();\n  local_140 = (char *)0x0;\n  local_128 = 5000;\n  local_130 = 0;\n  local_138 = 0;\n  uVar16 = 0;\nLAB_001ade98:\n  iVar2 = internal_getopt(param_1,\"d:u:n:O:tC:c:s:\");\n  if (iVar2 == -1) {\n    if (loptend == 0) {\n      pcVar7 = \"MAPFILE\";\n    }\n    else {\n      if ((*(char ***)(loptend + 8) == (char **)0x0) ||\n         (pcVar7 = **(char ***)(loptend + 8), pcVar7 == (char *)0x0)) {\n        uVar13 = 1;\n        builtin_error(\"internal error: getting variable name\");\n        goto LAB_001adeda;\n      }\n      if (*pcVar7 == '\\0') {\n        uVar13 = 0x102;\n        builtin_error(\"empty array variable name\");\n        goto LAB_001adeda;\n      }\n    }\n    iVar3 = legal_identifier(pcVar7);\n    iVar2 = DAT_00248b40;\n    if (iVar3 == 0) {\n      uVar13 = 1;\n      sh_invalidid(pcVar7);\n      goto LAB_001adeda;\n    }\n    local_e8 = (char *)0x0;\n    local_e0 = 0;\n    lVar4 = builtin_find_indexed_array(pcVar7);\n    if (lVar4 == 0) {\n      uVar13 = 1;\n      goto LAB_001adeda;\n    }\n    if (iVar2 == 10) {\n      bVar18 = false;\n      _Var11 = lseek((int)uVar17,0,1);\n      if ((_Var11 < 0) && (piVar12 = __errno_location(), *piVar12 == 0x1d)) goto LAB_001ae472;\n    }\n    else {\n      iVar3 = fstat((int)uVar17,&local_d8);\n      if (iVar3 == 0) {\n        bVar18 = (local_d8.st_mode & 0xf000) != 0x8000;\n      }\n      else {\nLAB_001ae472:\n        bVar18 = true;\n      }\n    }\n    zreset();\n    if (local_130 == 0) goto LAB_001ae219;\n    uVar5 = 0;\n    goto LAB_001ae1f6;\n  }\n  if (iVar2 == -99) {\n    builtin_help();\n    uVar13 = 0x102;\n    goto LAB_001adeda;\n  }\n  switch(iVar2) {\n  case 0x43:\n    local_140 = list_optarg;\n    goto LAB_001ade98;\n  default:\n    builtin_usage();\n    uVar13 = 0x102;\n    goto LAB_001adeda;\n  case 0x4f:\n    iVar2 = legal_number(list_optarg,&local_f0);\n    if (((iVar2 == 0) || ((long)local_f0 < 0)) ||\n       (uVar16 = local_f0, local_f0 != (local_f0 & 0xffffffff))) {\n      uVar13 = 1;\n      builtin_error(\"%s: invalid array origin\",list_optarg);\n      goto LAB_001adeda;\n    }\n    goto LAB_001ade98;\n  case 99:\n    iVar2 = legal_number(list_optarg,&local_f0);\n    if (((iVar2 == 0) || ((long)local_f0 < 1)) ||\n       (local_128 = local_f0 & 0xffffffff, local_f0 != local_128)) {\n      uVar13 = 1;\n      builtin_error(\"%s: invalid callback quantum\",list_optarg);\n      goto LAB_001adeda;\n    }\n    goto LAB_001ade98;\n  case 100:\n    DAT_00248b40 = (int)*list_optarg;\n    goto LAB_001ade98;\n  case 0x6e:\n    iVar2 = legal_number(list_optarg,&local_f0);\n    if (((iVar2 != 0) && (-1 < (long)local_f0)) &&\n       (local_138 = local_f0 & 0xffffffff, local_f0 == local_138)) goto LAB_001ade98;\n    break;\n  case 0x73:\n    iVar2 = legal_number(list_optarg,&local_f0);\n    if (((iVar2 != 0) && (-1 < (long)local_f0)) &&\n       (local_130 = local_f0 & 0xffffffff, local_f0 == local_130)) goto LAB_001ade98;\n    break;\n  case 0x74:\n    bVar1 = true;\n    goto LAB_001ade98;\n  case 0x75:\n    iVar2 = legal_number(list_optarg,&local_f0);\n    if (((iVar2 != 0) && (-1 < (long)local_f0)) &&\n       (uVar17 = local_f0 & 0xffffffff, local_f0 == (long)(int)local_f0)) goto code_r0x001adf3e;\n    uVar13 = 1;\n    builtin_error(\"%s: invalid file descriptor specification\",list_optarg);\n    goto LAB_001adeda;\n  }\n  uVar13 = 1;\n  builtin_error(\"%s: invalid line count\",list_optarg);\n  goto LAB_001adeda;\ncode_r0x001adf3e:\n  iVar2 = sh_validfd(local_f0 & 0xffffffff);\n  if (iVar2 == 0) goto code_r0x001adf4d;\n  goto LAB_001ade98;\ncode_r0x001adf4d:\n  piVar12 = __errno_location();\n  uVar13 = 1;\n  pcVar7 = strerror(*piVar12);\n  builtin_error(\"%d: invalid file descriptor: %s\",uVar17,pcVar7);\n  goto LAB_001adeda;\n  while (uVar5 = (ulong)((int)uVar5 + 1), uVar5 < local_130) {\nLAB_001ae1f6:\n    lVar6 = zgetline(uVar17,&local_e8,&local_e0,iVar2,bVar18);\n    if (lVar6 < 0) break;\n  }\nLAB_001ae219:\n  local_118 = &local_e0;\n  local_120 = &local_e8;\n  uVar15 = 1;\n  local_e8 = (char *)0x0;\n  local_e0 = 0;\n  do {\n    iVar3 = (int)uVar16 + -1 + uVar15;\n    lVar6 = zgetline(uVar17,local_120,local_118,iVar2,bVar18);\n    pcVar7 = local_e8;\n    if (lVar6 == -1) break;\n    if (bVar1) {\n      sVar8 = strlen(local_e8);\n      if ((int)sVar8 != 0) {\n        local_100 = (char)iVar2;\n        if (pcVar7[(long)(int)sVar8 + -1] == local_100) {\n          pcVar7[(long)(int)sVar8 + -1] = '\\0';\n        }\n      }\n    }\n    if (((local_140 != (char *)0x0) && (uVar15 != 0)) && ((ulong)uVar15 % local_128 == 0)) {\n      if (bVar18 == false) {\n        zsyncfd(uVar17);\n      }\n      pcVar7 = (char *)sh_single_quote(local_e8);\n      sVar8 = strlen(local_140);\n      sVar9 = strlen(pcVar7);\n      iVar14 = (int)sVar8 + 0xd + (int)sVar9;\n      uVar10 = sh_xmalloc(iVar14,\"./mapfile.def\",0x7c);\n      __snprintf_chk(uVar10,iVar14,1,0xffffffffffffffff,\"%s %d %s\",local_140,iVar3,pcVar7);\n      sh_xfree(pcVar7,\"./mapfile.def\",0x84);\n      evalstring(uVar10,0,4);\n    }\n    uVar15 = uVar15 + 1;\n    bind_array_element(lVar4,iVar3,local_e8,0);\n  } while ((local_138 == 0) || (uVar15 <= local_138));\n  sh_xfree(local_e8,\"./mapfile.def\",0xe1);\n  if (bVar18 == false) {\n    zsyncfd(uVar17);\n    uVar13 = 0;\n  }\n  else {\n    uVar13 = 0;\n  }\nLAB_001adeda:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar13;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_set_timeout": "\nundefined8 rl_set_timeout(int param_1,uint param_2)\n\n{\n  DAT_0024b3f0 = (ulong)(param_1 + param_2 / 1000000);\n  DAT_0024b3f8 = (ulong)(param_2 % 1000000);\n  return 0;\n}\n\n",
  "__memcpy_chk": "\nvoid __memcpy_chk(void)\n\n{\n  (*(code *)PTR___memcpy_chk_00237b30)();\n  return;\n}\n\n",
  "ttfd_noecho": "\nvoid ttfd_noecho(int param_1,termios *param_2)\n\n{\n  param_2->c_lflag = param_2->c_lflag & 0xffffff97;\n  tcsetattr(param_1,1,param_2);\n  return;\n}\n\n",
  "__mbsnrtowcs_chk": "\nvoid __mbsnrtowcs_chk(void)\n\n{\n  (*(code *)PTR___mbsnrtowcs_chk_002378e8)();\n  return;\n}\n\n",
  "FUN_00131c36": "\nvoid FUN_00131c36(void)\n\n{\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n",
  "copy_history_entry": "\nlong copy_history_entry(undefined8 *param_1)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  size_t sVar3;\n  char *__dest;\n  char *__s;\n  \n  if (param_1 != (undefined8 *)0x0) {\n    lVar2 = alloc_history_entry(*param_1,0);\n    __s = (char *)param_1[1];\n    if (__s != (char *)0x0) {\n      sVar3 = strlen(__s);\n      __dest = (char *)xmalloc(sVar3 + 1);\n      __s = strcpy(__dest,__s);\n    }\n    uVar1 = param_1[2];\n    *(char **)(lVar2 + 8) = __s;\n    *(undefined8 *)(lVar2 + 0x10) = uVar1;\n    return lVar2;\n  }\n  return 0;\n}\n\n",
  "FUN_001ee020": "\nundefined8 FUN_001ee020(int *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  undefined auStack_48 [24];\n  long local_30;\n  \n  iVar1 = param_1[2];\n  iVar2 = param_1[1];\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar3 = *param_1;\n  _rl_callback_func = 0;\n  _rl_want_redisplay = 1;\n  iVar4 = _rl_read_mbchar(auStack_48,0x10);\n  uVar5 = 1;\n  if (0 < iVar4) {\n    if (iVar3 < 0) {\n      if (iVar1 != 0) {\n        uVar5 = FUN_001edde0(-iVar3,iVar1,auStack_48);\n      }\n    }\n    else if (iVar2 != 0) {\n      uVar5 = FUN_001edde0(iVar3,iVar2,auStack_48);\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "extract_arithmetic_subst": "\nvoid extract_arithmetic_subst(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0016b780(param_1,param_2,&DAT_001fe093,&DAT_0021404a,\"]\",0);\n  return;\n}\n\n",
  "subshell_exit": "\nvoid subshell_exit(int param_1)\n\n{\n  int iVar1;\n  \n  fflush(stdout);\n  fflush(stderr);\n  last_command_exit_value = param_1;\n  iVar1 = signal_is_trapped(0);\n  if (iVar1 != 0) {\n    param_1 = run_exit_trap();\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n",
  "reset_terminating_signals": "\nvoid reset_terminating_signals(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  long in_FS_OFFSET;\n  sigaction local_b8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_0024853c != 0) {\n    piVar2 = &DAT_00238b60;\n    local_b8.sa_flags = 0;\n    sigemptyset(&local_b8.sa_mask);\n    do {\n      iVar1 = signal_is_trapped(*piVar2);\n      if (iVar1 == 0) {\n        iVar1 = signal_is_special(*piVar2);\n        if (iVar1 == 0) {\n          local_b8.__sigaction_handler = *(_union_1457 *)(piVar2 + 2);\n          local_b8.sa_flags = piVar2[4];\n          sigaction(*piVar2,&local_b8,(sigaction *)0x0);\n        }\n      }\n      piVar2 = piVar2 + 6;\n    } while (piVar2 != &shell_compatibility_level);\n    DAT_0024853c = 0;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001daa90": "\nint FUN_001daa90(char *param_1)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  int iVar3;\n  char *__s2;\n  char **ppcVar4;\n  \n  puVar1 = PTR_PTR_s_emacs_00240468;\n  __s2 = *(char **)PTR_PTR_s_emacs_00240468;\n  if (__s2 != (char *)0x0) {\n    iVar3 = 0;\n    ppcVar4 = (char **)PTR_PTR_s_emacs_00240468;\n    do {\n      ppcVar4 = ppcVar4 + 2;\n      iVar2 = strcasecmp(param_1,__s2);\n      if (iVar2 == 0) {\n        if (*(undefined **)(puVar1 + (long)iVar3 * 0x10 + 8) == (undefined *)0x0) {\n          return 1;\n        }\n        _rl_keymap = *(undefined **)(puVar1 + (long)iVar3 * 0x10 + 8);\n        return iVar2;\n      }\n      __s2 = *ppcVar4;\n      iVar3 = iVar3 + 1;\n    } while (__s2 != (char *)0x0);\n  }\n  return 1;\n}\n\n",
  "FUN_001504d0": "\nulong FUN_001504d0(long param_1,int param_2,undefined4 param_3,undefined4 param_4,undefined8 param_5\n                  )\n\n{\n  uint *puVar1;\n  uint uVar2;\n  long lVar3;\n  undefined4 uVar4;\n  int iVar5;\n  int iVar6;\n  ulong uVar7;\n  uint uVar8;\n  \n  iVar5 = subshell_environment;\n  lVar3 = *(long *)(param_1 + 0x18);\n  iVar6 = *(int *)(lVar3 + 0x18);\n  uVar8 = *(uint *)(param_1 + 4) & 8;\n  if (iVar6 == 0x3b) {\nLAB_001506f0:\n    if (uVar8 != 0) {\n      if (*(long *)(lVar3 + 8) != 0) {\n        puVar1 = (uint *)(*(long *)(lVar3 + 8) + 4);\n        *puVar1 = *puVar1 | 8;\n      }\n      if (*(long *)(lVar3 + 0x10) != 0) {\n        puVar1 = (uint *)(*(long *)(lVar3 + 0x10) + 4);\n        *puVar1 = *puVar1 | 8;\n      }\n    }\n    executing_list = executing_list + 1;\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      throw_to_top_level();\n    }\n    execute_command(*(undefined8 *)(*(long *)(param_1 + 0x18) + 8));\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      throw_to_top_level();\n    }\n    optimize_connection_fork(param_1);\n    uVar7 = execute_command_internal\n                      (*(undefined8 *)(*(long *)(param_1 + 0x18) + 0x10),param_2,param_3,param_4,\n                       param_5);\n    executing_list = executing_list + -1;\n    return uVar7;\n  }\n  if (iVar6 < 0x3c) {\n    if (iVar6 == 10) goto LAB_001506f0;\n    if (iVar6 == 0x26) {\n      lVar3 = *(long *)(lVar3 + 8);\n      if (lVar3 == 0) {\n        return 0;\n      }\n      uVar2 = *(uint *)(lVar3 + 4);\n      if (uVar8 != 0) {\n        uVar2 = *(uint *)(lVar3 + 4) | 8;\n      }\n      *(uint *)(lVar3 + 4) = uVar2 | 0x200;\n      if (((iVar5 != 0) || (job_control == 0)) && (stdin_redir == 0)) {\n        *(uint *)(lVar3 + 4) = uVar2 | 0x600;\n      }\n      uVar7 = execute_command_internal(lVar3,1,param_3,param_4,param_5);\n      if (terminating_signal != 0) {\n        termsig_handler(terminating_signal);\n        uVar7 = uVar7 & 0xffffffff;\n      }\n      if (interrupt_state != 0) {\n        throw_to_top_level();\n        uVar7 = uVar7 & 0xffffffff;\n      }\n      if ((*(uint *)(lVar3 + 4) & 0x400) != 0) {\n        *(uint *)(lVar3 + 4) = *(uint *)(lVar3 + 4) & 0xfffffbff;\n      }\n      param_1 = *(long *)(*(long *)(param_1 + 0x18) + 0x10);\n      if (param_1 == 0) {\n        return uVar7;\n      }\n      if (uVar8 != 0) {\n        *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 8;\n      }\n      goto LAB_00150601;\n    }\nLAB_00150520:\n    command_error(\"execute_connection\",2,iVar6,0);\n                    /* WARNING: Subroutine does not return */\n    jump_to_top_level(2);\n  }\n  if (iVar6 == 0x7c) {\n    uVar8 = signal_is_trapped(0x42);\n    if (uVar8 != 0) {\n      iVar6 = signal_is_ignored(0x42);\n      uVar8 = (uint)(iVar6 == 0);\n    }\n    uVar2 = *(uint *)(param_1 + 4);\n    iVar6 = signal_in_progress(0x42);\n    if ((iVar6 == 0) && (running_trap != 0x43)) {\n      line_number_for_err_trap = line_number;\n    }\n    uVar7 = FUN_0014fdd0(param_1,param_2,param_3,param_4,param_5);\n    uVar4 = line_number;\n    if (param_2 != 0) {\n      return 0;\n    }\n    if (uVar8 != 0) {\n      if ((uVar2 & 0xc) != 0) {\n        return uVar7;\n      }\n      if ((int)uVar7 != 0) {\n        line_number = line_number_for_err_trap;\n        last_command_exit_value = (int)uVar7;\n        run_error_trap();\n        uVar7 = uVar7 & 0xffffffff;\n      }\n    }\n    if ((uVar2 & 0xc) == 0) {\n      if (exit_immediately_on_error == 0) {\n        line_number = uVar4;\n        return uVar7;\n      }\n      if ((int)uVar7 == 0) {\n        line_number = uVar4;\n        return 0;\n      }\n      line_number = uVar4;\n      last_command_exit_value = (int)uVar7;\n      run_pending_traps();\n                    /* WARNING: Subroutine does not return */\n      jump_to_top_level(4);\n    }\n    line_number = uVar4;\n    return uVar7;\n  }\n  if (1 < iVar6 - 0x120U) goto LAB_00150520;\n  if (param_2 != 0) {\n    param_2 = 1;\n    *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 2;\nLAB_00150601:\n    uVar7 = execute_command_internal(param_1,param_2,param_3,param_4,param_5);\n    return uVar7;\n  }\n  executing_list = executing_list + 1;\n  if (*(long *)(lVar3 + 8) != 0) {\n    puVar1 = (uint *)(*(long *)(lVar3 + 8) + 4);\n    *puVar1 = *puVar1 | 8;\n  }\n  uVar7 = execute_command();\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n    uVar7 = uVar7 & 0xffffffff;\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n    uVar7 = uVar7 & 0xffffffff;\n  }\n  iVar6 = *(int *)(*(long *)(param_1 + 0x18) + 0x18);\n  if (iVar6 == 0x120) {\n    if ((int)uVar7 != 0) goto LAB_00150674;\n  }\n  else if ((iVar6 != 0x121) || ((int)uVar7 == 0)) goto LAB_00150674;\n  optimize_connection_fork(param_1);\n  lVar3 = *(long *)(*(long *)(param_1 + 0x18) + 0x10);\n  if ((uVar8 != 0) && (lVar3 != 0)) {\n    puVar1 = (uint *)(lVar3 + 4);\n    *puVar1 = *puVar1 | 8;\n  }\n  uVar7 = execute_command();\nLAB_00150674:\n  executing_list = executing_list + -1;\n  return uVar7;\n}\n\n",
  "importable_function_name": "\nulong importable_function_name(byte *param_1,long param_2)\n\n{\n  long lVar1;\n  ulong uVar2;\n  \n  lVar1 = mbschr(param_1,0x2f);\n  uVar2 = 0;\n  if ((lVar1 == 0) && (*param_1 != 10)) {\n    uVar2 = (ulong)((&sh_syntaxtab)[*param_1] & 0x2000);\n    if (((&sh_syntaxtab)[*param_1] & 0x2000) != 0) {\n      return 0;\n    }\n    if ((*(byte *)((long)&sh_syntaxtab + (ulong)param_1[param_2 + -1] * 4 + 1) & 0x20) == 0) {\n      uVar2 = 1;\n      if (posixly_correct != 0) {\n        uVar2 = legal_identifier(param_1);\n        return uVar2;\n      }\n    }\n  }\n  return uVar2;\n}\n\n",
  "expand_string_assignment": "\nundefined * expand_string_assignment(char *param_1,undefined4 param_2)\n\n{\n  size_t sVar1;\n  char *__dest;\n  undefined *puVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  char *local_38;\n  undefined4 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    local_30 = 0x8a0;\n    DAT_00247848 = 1;\n    sVar1 = strlen(param_1);\n    __dest = (char *)sh_xmalloc(sVar1 + 1,\"subst.c\",0x113a);\n    local_38 = strcpy(__dest,param_1);\n    puVar2 = (undefined *)FUN_00177e80(&local_38,param_2,0,0,0);\n    if (puVar2 == &DAT_00247880) {\n      uVar3 = 2;\n    }\n    else {\n      if (puVar2 != &DAT_00247870) {\n        if (local_38 != (char *)0x0) {\n          sh_xfree(local_38,\"subst.c\",0x113c);\n        }\n        DAT_00247848 = 0;\n        if (puVar2 != (undefined *)0x0) {\n          if (*(undefined8 **)(puVar2 + 8) != (undefined8 *)0x0) {\n            remove_quoted_nulls(**(undefined8 **)(puVar2 + 8));\n            *(uint *)(*(long *)(puVar2 + 8) + 8) = *(uint *)(*(long *)(puVar2 + 8) + 8) & 0xfffbffff\n            ;\n          }\n          dequote_list(puVar2);\n        }\n        goto LAB_0017b3dd;\n      }\n      uVar3 = 1;\n    }\n    last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n    FUN_001667f0(uVar3);\n  }\n  puVar2 = (undefined *)0x0;\nLAB_0017b3dd:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "free_pushed_string_input": "\nvoid free_pushed_string_input(void)\n\n{\n  FUN_00134d00();\n  return;\n}\n\n",
  "array_shift_element": "\nvoid array_shift_element(undefined8 param_1,undefined8 param_2)\n\n{\n  array_rshift(param_1,1,param_2);\n  return;\n}\n\n",
  "FUN_001c1950": "\nbool FUN_001c1950(uint param_1,wchar_t *param_2,wchar_t *param_3,int *param_4,int *param_5,\n                 uint param_6)\n\n{\n  wchar_t wVar1;\n  int iVar2;\n  int iVar3;\n  int *piVar4;\n  int *piVar5;\n  wchar_t *pwVar6;\n  uint uVar7;\n  wchar_t *pwVar8;\n  int *piVar9;\n  int *local_50;\n  int *local_48;\n  \n  if ((param_4 + (*param_4 == 0x28) != param_5) &&\n     (piVar4 = (int *)FUN_001bfc60(param_4 + (*param_4 == 0x28),param_5,0), piVar4 != (int *)0x0)) {\n    if (param_1 < 0x2c) {\n      if (param_1 < 0x2a) {\n        if ((param_1 == 0x21) && (param_2 <= param_3)) {\n          pwVar8 = param_2;\n          do {\n            piVar9 = param_4 + 1;\n            do {\n              while (piVar9 == param_5) {\n                if ((piVar9 != (int *)0x0 && param_2 != (wchar_t *)0x0) &&\n                   (iVar2 = FUN_001c1f10(param_2,pwVar8,param_5,0xfffffffffffffffc,0,param_6),\n                   iVar2 == 0)) goto LAB_001c1c6b;\n                piVar9 = (int *)0x0;\n              }\n              piVar5 = (int *)FUN_001bfc60(piVar9,param_5,0x7c);\n              if ((piVar9 != (int *)0x0 && param_2 != (wchar_t *)0x0) &&\n                 (iVar2 = FUN_001c1f10(param_2,pwVar8,piVar9,piVar5 + -1,0,param_6), iVar2 == 0))\n              goto LAB_001c1c6b;\n              piVar9 = piVar5;\n            } while (piVar4 != piVar5);\n            if ((param_6 & 4) == 0) {\n              if (((param_6 & 0x80) != 0) && (*param_2 == L'.')) {\n                wVar1 = param_2[1];\n                if (wVar1 == L'\\0') {\n                  return true;\n                }\n                if ((wVar1 == L'.') && (param_2[2] == L'\\0')) {\n                  return true;\n                }\n                if (((param_6 & 1) != 0) && (param_2[-1] == L'/')) {\n                  if (wVar1 == L'/') {\n                    return true;\n                  }\n                  if (wVar1 == L'\\0') {\n                    return true;\n                  }\n                  if (wVar1 == L'.') {\n                    if (param_2[2] == L'/') {\n                      return true;\n                    }\n                    if (param_2[2] == L'\\0') {\n                      return true;\n                    }\n                  }\n                }\n              }\n            }\n            else if (*param_2 == L'.') {\n              return true;\n            }\n            uVar7 = param_6 & 0xffffff7b;\n            if (pwVar8 <= param_2) {\n              uVar7 = param_6;\n            }\n            if ((pwVar8 != (wchar_t *)0x0) &&\n               (iVar2 = FUN_001c1f10(pwVar8,param_3,piVar5,param_5,0,uVar7), iVar2 == 0)) {\n              return false;\n            }\nLAB_001c1c6b:\n            pwVar8 = pwVar8 + 1;\n          } while (pwVar8 <= param_3);\n        }\n      }\n      else {\n        if (((param_1 == 0x2a) && (param_2 != (wchar_t *)0x0)) &&\n           (iVar2 = FUN_001c1f10(param_2,param_3,piVar4,param_5,0,param_6), iVar2 == 0)) {\n          return false;\n        }\n        local_50._0_4_ = param_6 & 0xffffff7b;\n        local_48 = param_4 + 1;\nLAB_001c1ca4:\n        do {\n          piVar9 = local_48;\n          if (piVar9 == param_5) {\n            local_48 = (int *)0x0;\n            piVar5 = (int *)0xfffffffffffffffc;\n            if (param_3 < param_2) goto LAB_001c1ca4;\nLAB_001c1cd1:\n            pwVar8 = param_2;\n            do {\n              if ((piVar9 != (int *)0x0 && param_2 != (wchar_t *)0x0) &&\n                 (iVar2 = FUN_001c1f10(param_2,pwVar8,piVar9,piVar5,0,param_6), iVar2 == 0)) {\n                uVar7 = (uint)local_50;\n                if (pwVar8 <= param_2) {\n                  uVar7 = param_6;\n                }\n                if (pwVar8 != (wchar_t *)0x0) {\n                  iVar2 = FUN_001c1f10(pwVar8,param_3,piVar4,param_5,0);\n                  if (iVar2 == 0) {\n                    return false;\n                  }\n                  if ((param_2 != pwVar8) &&\n                     (iVar2 = FUN_001c1f10(pwVar8,param_3,param_4 + -1,param_5,0,uVar7), iVar2 == 0)\n                     ) {\n                    return false;\n                  }\n                }\n              }\n              pwVar8 = pwVar8 + 1;\n            } while (pwVar8 <= param_3);\n          }\n          else {\n            local_48 = (int *)FUN_001bfc60(piVar9,param_5,0x7c);\n            if (param_2 <= param_3) {\n              piVar5 = local_48 + -1;\n              goto LAB_001c1cd1;\n            }\n          }\n        } while (piVar4 != local_48);\n      }\n    }\n    else if (param_1 - 0x3f < 2) {\n      if (((param_1 == 0x3f) && (param_2 != (wchar_t *)0x0)) &&\n         (iVar2 = FUN_001c1f10(param_2,param_3,piVar4,param_5,0,param_6), iVar2 == 0)) {\n        return false;\n      }\n      param_4 = param_4 + 1;\n      pwVar8 = param_3;\n      if (param_5 != piVar4) {\n        pwVar8 = param_2;\n      }\n      do {\n        if (param_4 == param_5) {\n          local_50 = (int *)0x0;\n        }\n        else {\n          local_50 = (int *)FUN_001bfc60(param_4,param_5,0x7c);\n        }\n        if ((param_5 == piVar4) || (param_2 <= param_3)) {\n          pwVar6 = pwVar8;\n          do {\n            uVar7 = param_6 & 0xffffff7b;\n            if (pwVar6 <= param_2) {\n              uVar7 = param_6;\n            }\n            if (((param_2 != (wchar_t *)0x0 && param_4 != (int *)0x0) &&\n                (iVar2 = FUN_001c1f10(param_2,pwVar6,param_4,local_50 + -1,0,param_6), iVar2 == 0))\n               && ((pwVar6 != (wchar_t *)0x0 &&\n                   (iVar2 = FUN_001c1f10(pwVar6,param_3,piVar4,param_5,0,uVar7), iVar2 == 0)))) {\n              return false;\n            }\n            pwVar6 = pwVar6 + 1;\n          } while (pwVar6 <= param_3);\n        }\n        param_4 = local_50;\n      } while (piVar4 != local_50);\n    }\n    return true;\n  }\n  pwVar8 = param_4 + -1;\n  if ((int)((long)param_5 - (long)pwVar8 >> 2) != (int)((long)param_3 - (long)param_2 >> 2)) {\n    return true;\n  }\n  iVar2 = *param_5;\n  wVar1 = *param_3;\n  if (iVar2 == 0) {\n    if (wVar1 == L'\\0') {\n      iVar3 = wcscoll(pwVar8,param_2);\n      goto LAB_001c1e99;\n    }\n    *param_3 = L'\\0';\n    iVar3 = wcscoll(pwVar8,param_2);\n  }\n  else {\n    *param_5 = 0;\n    if (wVar1 == L'\\0') {\n      iVar3 = wcscoll(pwVar8,param_2);\n      *param_5 = iVar2;\n      goto LAB_001c1e99;\n    }\n    *param_3 = L'\\0';\n    iVar3 = wcscoll(pwVar8,param_2);\n    *param_5 = iVar2;\n  }\n  *param_3 = wVar1;\nLAB_001c1e99:\n  return iVar3 != 0;\n}\n\n",
  "getservent": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nservent * getservent(void)\n\n{\n  servent *psVar1;\n  \n  psVar1 = (servent *)(*(code *)PTR_getservent_00237830)();\n  return psVar1;\n}\n\n",
  "rl_save_state": "\nundefined8 rl_save_state(undefined4 *param_1)\n\n{\n  if (param_1 != (undefined4 *)0x0) {\n    *param_1 = rl_point;\n    param_1[1] = rl_end;\n    param_1[2] = rl_mark;\n    *(undefined8 *)(param_1 + 4) = rl_line_buffer;\n    param_1[3] = rl_line_buffer_len;\n    *(undefined8 *)(param_1 + 6) = rl_undo_list;\n    *(undefined8 *)(param_1 + 8) = rl_prompt;\n    param_1[10] = (int)rl_readline_state;\n    param_1[0xb] = rl_done;\n    *(undefined **)(param_1 + 0xc) = _rl_keymap;\n    *(undefined8 *)(param_1 + 0xe) = rl_last_func;\n    param_1[0x10] = rl_insert_mode;\n    param_1[0x11] = rl_editing_mode;\n    *(undefined8 *)(param_1 + 0x12) = rl_executing_keyseq;\n    param_1[0x14] = rl_key_sequence_length;\n    *(undefined8 *)(param_1 + 0x16) = rl_instream;\n    *(undefined8 *)(param_1 + 0x18) = rl_outstream;\n    param_1[0x15] = rl_pending_input;\n    *(undefined8 *)(param_1 + 0x1a) = rl_executing_macro;\n    param_1[0x1c] = rl_catch_signals;\n    param_1[0x1d] = rl_catch_sigwinch;\n    *(undefined8 *)(param_1 + 0x1e) = rl_completion_entry_function;\n    *(undefined8 *)(param_1 + 0x20) = rl_menu_completion_entry_function;\n    *(undefined8 *)(param_1 + 0x22) = rl_ignore_some_completions_function;\n    *(undefined8 *)(param_1 + 0x24) = rl_attempted_completion_function;\n    *(undefined8 *)(param_1 + 0x26) = rl_completer_word_break_characters;\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
  "rl_noninc_reverse_search": "\nvoid rl_noninc_reverse_search(undefined8 param_1,int param_2)\n\n{\n  if (param_2 != 0x2f) {\n    param_2 = 0;\n  }\n  FUN_001d4e70(0xffffffff,param_2);\n  return;\n}\n\n",
  "rl_end_of_line": "\nundefined8 rl_end_of_line(void)\n\n{\n  rl_point = rl_end;\n  return 0;\n}\n\n",
  "history_get": "\nlong history_get(int param_1)\n\n{\n  long lVar1;\n  \n  param_1 = param_1 - history_base;\n  if ((param_1 < history_length) && (-1 < param_1)) {\n    lVar1 = DAT_0024b6e8;\n    if (DAT_0024b6e8 != 0) {\n      return *(long *)(DAT_0024b6e8 + (long)param_1 * 8);\n    }\n  }\n  else {\n    lVar1 = 0;\n  }\n  return lVar1;\n}\n\n",
  "find_path_file": "\nvoid find_path_file(undefined8 param_1)\n\n{\n  FUN_0019b8d0(param_1,0x40);\n  return;\n}\n\n",
  "xfree": "\nvoid xfree(void *param_1)\n\n{\n  if (param_1 != (void *)0x0) {\n    free(param_1);\n    return;\n  }\n  return;\n}\n\n",
  "readline_internal_setup": "\nvoid readline_internal_setup(void)\n\n{\n  char *__s;\n  \n  _rl_in_stream = rl_instream;\n  _rl_out_stream = rl_outstream;\n  if (((long)_rl_enable_meta & rl_readline_state & 4) != 0) {\n    _rl_enable_meta_key();\n  }\n  if (rl_startup_hook != (code *)0x0) {\n    (*rl_startup_hook)();\n  }\n  if (_rl_internal_startup_hook != (code *)0x0) {\n    (*_rl_internal_startup_hook)();\n  }\n  rl_deactivate_mark();\n  if (rl_editing_mode == 0) {\n    rl_vi_insertion_mode(1,0x69);\n  }\n  else if (_rl_show_mode_in_prompt != 0) {\n    _rl_reset_prompt();\n  }\n  if ((_rl_echoing_p == 0) && ((code *)rl_redisplay_function == rl_redisplay)) {\n    if ((rl_prompt != 0) && (rl_already_prompted == 0)) {\n      __s = (char *)_rl_strip_prompt();\n      fputs(__s,_rl_out_stream);\n      fflush(_rl_out_stream);\n      xfree(__s);\n    }\n  }\n  else {\n    if ((rl_prompt == 0) || (rl_already_prompted == 0)) {\n      rl_on_new_line();\n    }\n    else {\n      rl_on_new_line_with_prompt();\n    }\n    (*(code *)rl_redisplay_function)();\n  }\n  if (rl_pre_input_hook != (code *)0x0) {\n    (*rl_pre_input_hook)();\n  }\n  if (_rl_caught_signal == 0) {\n    return;\n  }\n  _rl_signal_handler(_rl_caught_signal);\n  return;\n}\n\n",
  "set_default_locale_vars": "\nvoid set_default_locale_vars(void)\n\n{\n  long lVar1;\n  char *pcVar2;\n  size_t sVar3;\n  char *pcVar4;\n  \n  lVar1 = get_string_value();\n  if (((lVar1 == 0) && (DAT_002489b0 != (char *)0x0)) && (*DAT_002489b0 != '\\0')) {\n    setlocale(0,DAT_002489b0);\n    FUN_0019a310();\n    sVar3 = __ctype_get_mb_cur_max();\n    locale_mb_cur_max = (undefined4)sVar3;\n    locale_utf8locale = FUN_0019a3c0();\n    locale_shiftstates = mblen((char *)0x0,0);\n    u32reset();\n  }\n  lVar1 = get_string_value(\"LC_COLLATE\");\n  if (((lVar1 == 0) && (DAT_002489b0 != (char *)0x0)) && (*DAT_002489b0 != '\\0')) {\n    setlocale(3,DAT_002489b0);\n  }\n  lVar1 = get_string_value(\"LC_MESSAGES\");\n  if (((lVar1 == 0) && (DAT_002489b0 != (char *)0x0)) && (*DAT_002489b0 != '\\0')) {\n    setlocale(5,DAT_002489b0);\n  }\n  lVar1 = get_string_value(\"LC_NUMERIC\");\n  if (((lVar1 == 0) && (DAT_002489b0 != (char *)0x0)) && (*DAT_002489b0 != '\\0')) {\n    setlocale(1,DAT_002489b0);\n  }\n  lVar1 = get_string_value(\"LC_TIME\");\n  if (((lVar1 == 0) && (DAT_002489b0 != (char *)0x0)) && (*DAT_002489b0 != '\\0')) {\n    setlocale(2,DAT_002489b0);\n  }\n  pcVar2 = (char *)get_string_value(\"TEXTDOMAIN\");\n  if ((pcVar2 != (char *)0x0) && (*pcVar2 != '\\0')) {\n    if (DAT_002489c0 != (char *)0x0) {\n      sh_xfree(DAT_002489c0,\"locale.c\",0x9e);\n    }\n    sVar3 = strlen(pcVar2);\n    pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"locale.c\",0x9f);\n    DAT_002489c0 = strcpy(pcVar4,pcVar2);\n  }\n  pcVar2 = (char *)get_string_value(\"TEXTDOMAINDIR\");\n  if ((pcVar2 != (char *)0x0) && (*pcVar2 != '\\0')) {\n    if (DAT_002489b8 != (char *)0x0) {\n      sh_xfree(DAT_002489b8,\"locale.c\",0xa7);\n    }\n    sVar3 = strlen(pcVar2);\n    pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"locale.c\",0xa8);\n    DAT_002489b8 = strcpy(pcVar4,pcVar2);\n  }\n  return;\n}\n\n",
  "FUN_001ddf90": "\nint FUN_001ddf90(char *param_1,int param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  char *__buf;\n  ssize_t sVar5;\n  char *pcVar6;\n  char *pcVar7;\n  size_t sVar8;\n  int *piVar9;\n  char *pcVar10;\n  long in_FS_OFFSET;\n  stat sStack_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  DAT_0024a7a4 = param_2;\n  DAT_0024a7a8 = param_1;\n  pcVar4 = (char *)tilde_expand();\n  iVar2 = open(pcVar4,0,0x1b6);\n  if (iVar2 < 0) {\n    piVar9 = __errno_location();\n  }\n  else {\n    iVar3 = fstat(iVar2,&sStack_d8);\n    if (iVar3 < 0) {\n      close(iVar2);\n      piVar9 = __errno_location();\n    }\n    else if (sStack_d8.st_size == 0xffffffffffffffff) {\n      close(iVar2);\n      piVar9 = __errno_location();\n      *piVar9 = 0x1b;\n    }\n    else {\n      __buf = (char *)xmalloc(sStack_d8.st_size + 1);\n      sVar5 = read(iVar2,__buf,sStack_d8.st_size);\n      close(iVar2);\n      if (-1 < (int)sVar5) {\n        if (_rl_caught_signal != 0) {\n          _rl_signal_handler(_rl_caught_signal);\n        }\n        pcVar10 = __buf + (int)sVar5;\n        *pcVar10 = '\\0';\n        xfree(pcVar4);\n        if (_rl_caught_signal != 0) {\n          _rl_signal_handler(_rl_caught_signal);\n        }\n        if (__buf == (char *)0x0) {\n          piVar9 = __errno_location();\n          iVar2 = *piVar9;\n        }\n        else {\n          if ((param_2 == 0) && (DAT_0024a7b0 != param_1)) {\n            if (DAT_0024a7b0 != (char *)0x0) {\n              free(DAT_0024a7b0);\n            }\n            sVar8 = strlen(param_1);\n            pcVar4 = (char *)xmalloc(sVar8 + 1);\n            DAT_0024a7b0 = strcpy(pcVar4,param_1);\n          }\n          DAT_0024a7b8 = 1;\n          DAT_0024a7a0 = 1;\n          for (pcVar4 = __buf; pcVar4 < pcVar10; pcVar4 = pcVar4 + (long)iVar2 + 1) {\n            if (pcVar10 == pcVar4) {\n              iVar2 = 0;\n              pcVar7 = pcVar10;\n            }\n            else {\n              iVar2 = 0;\n              pcVar6 = pcVar4;\n              do {\n                pcVar7 = pcVar6;\n                if (*pcVar6 == '\\n') break;\n                pcVar6 = pcVar6 + 1;\n                iVar2 = iVar2 + 1;\n                pcVar7 = pcVar10;\n              } while (pcVar10 != pcVar6);\n            }\n            *pcVar7 = '\\0';\n            cVar1 = *pcVar4;\n            while (cVar1 != '\\0') {\n              if ((cVar1 != ' ') && (cVar1 != '\\t')) {\n                if (cVar1 != '#') {\n                  rl_parse_and_bind(pcVar4);\n                }\n                break;\n              }\n              pcVar7 = pcVar4 + 1;\n              pcVar4 = pcVar4 + 1;\n              iVar2 = iVar2 + -1;\n              cVar1 = *pcVar7;\n            }\n            DAT_0024a7a0 = DAT_0024a7a0 + 1;\n          }\n          xfree(__buf);\n          iVar2 = 0;\n          DAT_0024a7b8 = 0;\n        }\n        goto LAB_001de125;\n      }\n      xfree(__buf);\n      piVar9 = __errno_location();\n    }\n  }\n  xfree(pcVar4);\n  if (_rl_caught_signal != 0) {\n    _rl_signal_handler(_rl_caught_signal);\n  }\n  iVar2 = *piVar9;\nLAB_001de125:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar2;\n}\n\n",
  "strvec_from_word_list": "\nvoid * strvec_from_word_list(long *param_1,int param_2,int param_3,int *param_4)\n\n{\n  int iVar1;\n  void *__s;\n  size_t sVar2;\n  char *__dest;\n  char *__s_00;\n  long lVar3;\n  \n  iVar1 = list_length();\n  __s = (void *)sh_xmalloc((long)(param_3 + 1 + iVar1) << 3,\"stringvec.c\",0xe4);\n  if (0 < param_3) {\n    memset(__s,0,(long)param_3 << 3);\n  }\n  lVar3 = (long)(param_3 + 1);\n  if (param_1 != (long *)0x0) {\n    do {\n      __s_00 = *(char **)param_1[1];\n      if (param_2 != 0) {\n        sVar2 = strlen(__s_00);\n        __dest = (char *)sh_xmalloc(sVar2 + 1,\"stringvec.c\",0xe9);\n        __s_00 = strcpy(__dest,__s_00);\n      }\n      param_1 = (long *)*param_1;\n      *(char **)((long)__s + lVar3 * 8 + -8) = __s_00;\n      param_3 = (int)lVar3;\n      lVar3 = lVar3 + 1;\n    } while (param_1 != (long *)0x0);\n  }\n  *(undefined8 *)((long)__s + (long)param_3 * 8) = 0;\n  if (param_4 != (int *)0x0) {\n    *param_4 = param_3;\n  }\n  return __s;\n}\n\n",
  "shtimer_chktimeout": "\nuint shtimer_chktimeout(long *param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  long in_FS_OFFSET;\n  timeval local_38;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((*(uint *)((long)param_1 + 0x14) & 1) == 0) {\n    uVar2 = 0;\n    if ((*param_1 != 0) || (param_1[1] != 0)) {\n      iVar1 = gettimeofday(&local_38,(__timezone_ptr_t)0x0);\n      if (-1 < iVar1) {\n        if (*param_1 < local_38.tv_sec) {\n          uVar2 = 1;\n        }\n        else if (local_38.tv_sec == *param_1) {\n          uVar2 = (uint)(param_1[1] <= local_38.tv_usec);\n        }\n      }\n    }\n  }\n  else {\n    uVar2 = *(uint *)(param_1 + 3);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00131c24": "\nvoid FUN_00131c24(void)\n\n{\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n",
  "_rl_arg_getchar": "\nvoid _rl_arg_getchar(void)\n\n{\n  rl_message(\"(arg: %d) \",rl_arg_sign * rl_numeric_arg);\n  rl_readline_state = rl_readline_state | 0x40;\n  rl_read_key();\n  rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n  return;\n}\n\n",
  "FUN_0016b540": "\nundefined * FUN_0016b540(long param_1,int *param_2,char *param_3,uint param_4)\n\n{\n  byte *__s;\n  byte bVar1;\n  mbstate_t mVar2;\n  int iVar3;\n  size_t sVar4;\n  long lVar5;\n  undefined *puVar6;\n  char *__s_00;\n  char cVar7;\n  int iVar8;\n  uint uVar9;\n  ulong uVar10;\n  ulong uVar11;\n  long in_FS_OFFSET;\n  long local_60;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar4 = __ctype_get_mb_cur_max();\n  if (sVar4 < 2) {\n    local_60 = 0;\n    uVar10 = (ulong)*param_2;\n    __s_00 = (char *)(param_1 + uVar10);\n  }\n  else {\n    uVar10 = (ulong)*param_2;\n    __s_00 = (char *)(param_1 + uVar10);\n    sVar4 = strlen(__s_00);\n    local_60 = sVar4 + uVar10;\n  }\n  cVar7 = *__s_00;\n  if (cVar7 != '\\0') {\n    uVar11 = uVar10;\n    do {\n      while( true ) {\n        iVar8 = (int)uVar10;\n        if (cVar7 == '\\\\') {\n          if (*(char *)(param_1 + 1 + uVar11) == '\\0') goto LAB_0016b690;\n          iVar8 = iVar8 + 1;\n        }\n        else if (((param_4 >> 1 & 1) == 0) || (cVar7 != '[')) {\n          if (((*param_3 == cVar7) && (param_3[1] == '\\0')) || (lVar5 = mbschr(), lVar5 != 0))\n          goto LAB_0016b69e;\n        }\n        else {\n          iVar3 = FUN_0016af90(param_1,uVar10 & 0xffffffff,0);\n          if (*(char *)(param_1 + iVar3) == ']') {\n            iVar8 = iVar3;\n          }\n        }\n        mVar2 = local_48;\n        if (locale_mb_cur_max < 2) goto LAB_0016b644;\n        __s = (byte *)(param_1 + iVar8);\n        bVar1 = *__s;\n        if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) != 0) break;\n        if ((locale_utf8locale == 0) || ((char)bVar1 < '\\0')) {\n          sVar4 = mbrtowc((wchar_t *)0x0,(char *)__s,local_60 - iVar8,&local_48);\n          if ((sVar4 < 0xfffffffffffffffe) && (mVar2 = local_48, sVar4 != 0)) goto LAB_0016b675;\n        }\n        else if (bVar1 != 0) break;\nLAB_0016b644:\n        local_48 = mVar2;\n        uVar10 = (ulong)(iVar8 + 1U);\n        uVar11 = (ulong)(int)(iVar8 + 1U);\n        cVar7 = *(char *)(param_1 + uVar11);\n        if (cVar7 == '\\0') goto LAB_0016b690;\n      }\n      sVar4 = 1;\nLAB_0016b675:\n      uVar9 = iVar8 + (int)sVar4;\n      uVar10 = (ulong)uVar9;\n      uVar11 = (ulong)(int)uVar9;\n      cVar7 = *(char *)(param_1 + uVar11);\n    } while (cVar7 != '\\0');\n  }\nLAB_0016b690:\n  iVar8 = (int)uVar10;\n  puVar6 = &DAT_0024784d;\n  if ((param_4 & 4) == 0) {\nLAB_0016b69e:\n    iVar8 = (int)uVar10;\n    puVar6 = (undefined *)0x0;\n    if ((param_4 & 1) == 0) {\n      puVar6 = (undefined *)substring(param_1,*param_2,uVar10 & 0xffffffff);\n    }\n  }\n  *param_2 = iVar8;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar6;\n}\n\n",
  "hash_dispose": "\nvoid hash_dispose(undefined8 *param_1)\n\n{\n  sh_xfree(*param_1,\"hashlib.c\",0x19c);\n  sh_xfree(param_1,\"hashlib.c\",0x19d);\n  return;\n}\n\n",
  "buffered_getchar": "\nulong buffered_getchar(void)\n\n{\n  int *piVar1;\n  long lVar2;\n  __off_t __offset;\n  __off_t _Var3;\n  int __fd;\n  \n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (((int)DAT_00240a70 < 0) ||\n     (piVar1 = *(int **)(DAT_00247f68 + (long)(int)DAT_00240a70 * 8), piVar1 == (int *)0x0)) {\n    return 0xffffffff;\n  }\n  lVar2 = *(long *)(piVar1 + 10);\n  if ((*(long *)(piVar1 + 6) != 0) && (lVar2 != *(long *)(piVar1 + 6))) {\n    *(long *)(piVar1 + 10) = lVar2 + 1;\n    return (ulong)*(byte *)(*(long *)(piVar1 + 2) + lVar2);\n  }\n  if (terminating_signal == 0) {\n    __fd = *piVar1;\n    if ((piVar1[8] & 0x14U) != 0x10) goto LAB_0018355b;\nLAB_00183590:\n    __offset = lseek(__fd,0,1);\n    lVar2 = zread(*piVar1,*(undefined8 *)(piVar1 + 2),*(undefined8 *)(piVar1 + 4));\n    if (lVar2 < 1) goto LAB_001835b6;\n    _Var3 = lseek(*piVar1,0,1);\n    if (_Var3 - __offset <= lVar2) goto LAB_00183570;\n    lseek(*piVar1,__offset,0);\n    piVar1[8] = piVar1[8] | 4;\n    *(undefined8 *)(piVar1 + 4) = 1;\n    lVar2 = zread(*piVar1,*(undefined8 *)(piVar1 + 2),1);\n  }\n  else {\n    termsig_handler(terminating_signal);\n    __fd = *piVar1;\n    if ((piVar1[8] & 0x14U) == 0x10) goto LAB_00183590;\nLAB_0018355b:\n    lVar2 = zread(__fd,*(undefined8 *)(piVar1 + 2),*(undefined8 *)(piVar1 + 4));\n  }\n  if (0 < lVar2) {\nLAB_00183570:\n    *(long *)(piVar1 + 6) = lVar2;\n    *(undefined8 *)(piVar1 + 10) = 1;\n    return (ulong)**(byte **)(piVar1 + 2);\n  }\nLAB_001835b6:\n  *(undefined8 *)(piVar1 + 10) = 0;\n  *(undefined8 *)(piVar1 + 6) = 0;\n  **(undefined **)(piVar1 + 2) = 0;\n  if (lVar2 == 0) {\n    piVar1[8] = piVar1[8] | 1;\n  }\n  else {\n    piVar1[8] = piVar1[8] | 2;\n  }\n  return 0xffffffff;\n}\n\n",
  "conf_standard_path": "\nundefined4 * conf_standard_path(void)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  size_t __len;\n  undefined4 *puVar4;\n  \n  __len = confstr(0,(char *)0x0,0);\n  if (__len != 0) {\n    puVar4 = (undefined4 *)sh_xmalloc(__len + 2,\"general.c\",0x585);\n    *(char *)puVar4 = '\\0';\n    confstr(0,(char *)puVar4,__len);\n    return puVar4;\n  }\n  puVar4 = (undefined4 *)sh_xmalloc(0x2c,\"general.c\",0x58b);\n  uVar3 = s__bin__usr_bin__sbin__usr_sbin__e_001fc460._12_4_;\n  uVar2 = s__bin__usr_bin__sbin__usr_sbin__e_001fc460._8_4_;\n  uVar1 = s__bin__usr_bin__sbin__usr_sbin__e_001fc460._4_4_;\n  *puVar4 = s__bin__usr_bin__sbin__usr_sbin__e_001fc460._0_4_;\n  puVar4[1] = uVar1;\n  puVar4[2] = uVar2;\n  puVar4[3] = uVar3;\n  uVar3 = s__bin__usr_bin__sbin__usr_sbin__e_001fc460._28_4_;\n  uVar2 = s__bin__usr_bin__sbin__usr_sbin__e_001fc460._24_4_;\n  uVar1 = s__bin__usr_bin__sbin__usr_sbin__e_001fc460._20_4_;\n  puVar4[4] = s__bin__usr_bin__sbin__usr_sbin__e_001fc460._16_4_;\n  puVar4[5] = uVar1;\n  puVar4[6] = uVar2;\n  puVar4[7] = uVar3;\n  *(undefined8 *)(puVar4 + 8) = 0x2f7273752f3a6374;\n  puVar4[10] = 0x637465;\n  return puVar4;\n}\n\n",
  "redirection_error": "\nvoid redirection_error(long param_1,int param_2,char *param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  char **ppcVar4;\n  uint uVar5;\n  char *pcVar6;\n  char *pcVar7;\n  size_t sVar8;\n  \n  if ((*(byte *)(param_1 + 0x10) & 1) == 0) {\n    if (*(int *)(param_1 + 8) < 0) {\n      param_3 = \"file descriptor out of range\";\n      pcVar6 = (char *)0x0;\n    }\n    else {\n      if (param_2 != -2) goto LAB_0019c458;\n      if (param_3 != (char *)0x0) {\n        internal_error(\"%s: cannot overwrite existing file\");\n        return;\n      }\nLAB_0019c598:\n      if ((*(uint *)(param_1 + 0x18) < 0x14) &&\n         ((0xe7c0fUL >> ((ulong)*(uint *)(param_1 + 0x18) & 0x3f) & 1) != 0)) {\n        uVar2 = *(uint *)(*(long *)(param_1 + 0x20) + 8);\n        uVar5 = uVar2;\n        if ((posixly_correct != 0) && (interactive_shell == 0)) {\n          uVar5 = uVar2 | 0x20;\n        }\n        *(uint *)(*(long *)(param_1 + 0x20) + 8) = uVar5 | 0x400;\n        pcVar6 = (char *)redirection_expand();\n        ppcVar4 = *(char ***)(param_1 + 0x20);\n        *(uint *)(ppcVar4 + 1) = uVar2;\n        param_3 = pcVar6;\n        if (pcVar6 == (char *)0x0) {\n          param_3 = *ppcVar4;\n        }\n      }\n      else {\n        param_3 = \"file descriptor out of range\";\n        pcVar6 = (char *)0x0;\n        if (-1 < *(int *)(param_1 + 0x20)) {\n          param_3 = (char *)itos();\n          pcVar6 = param_3;\n        }\n      }\n    }\nLAB_0019c475:\n    switch(param_2) {\n    default:\n      goto switchD_0019c48f_caseD_5;\n    case -5:\n      internal_error(\"%s: cannot assign fd to variable\");\n      break;\n    case -4:\n      pcVar7 = strerror(DAT_002489f8);\n      internal_error(\"cannot create temp file for here-document: %s\",pcVar7);\n      break;\n    case -3:\n      internal_error(\"%s: restricted: cannot redirect output\");\n      break;\n    case -2:\n      internal_error(\"%s: cannot overwrite existing file\");\n      break;\n    case -1:\n      internal_error(\"%s: ambiguous redirect\");\n    }\n  }\n  else {\n    if (param_2 < 0) {\n      pcVar6 = **(char ***)(param_1 + 8);\n      sVar8 = strlen(pcVar6);\n      pcVar7 = (char *)sh_xmalloc(sVar8 + 1,\"redir.c\",0x92);\n      param_3 = strcpy(pcVar7,pcVar6);\n      pcVar6 = param_3;\n      goto LAB_0019c475;\n    }\nLAB_0019c458:\n    iVar1 = *(int *)(param_1 + 8);\n    if ((param_2 != 9) || (iVar1 < 0)) {\n      pcVar6 = (char *)0x0;\n      if (param_3 == (char *)0x0) goto LAB_0019c598;\n      goto LAB_0019c475;\n    }\n    uVar2 = *(uint *)(param_1 + 0x18);\n    if (uVar2 == 0xe) {\n      if (iVar1 == 1) {\nLAB_0019c564:\n        uVar3 = **(undefined8 **)(param_1 + 0x20);\n        pcVar6 = strerror(9);\n        internal_error(\"%s: %s\",uVar3,pcVar6);\n        return;\n      }\nLAB_0019c609:\n      param_3 = (char *)itos();\n      pcVar6 = param_3;\n    }\n    else {\n      if (uVar2 < 0xf) {\n        if (uVar2 < 8) {\n          if (5 < uVar2) goto LAB_0019c68c;\n        }\n        else if ((uVar2 == 0xd) && (iVar1 == 0)) goto LAB_0019c564;\n        goto LAB_0019c609;\n      }\n      if (1 < uVar2 - 0xf) goto LAB_0019c609;\nLAB_0019c68c:\n      param_3 = (char *)itos((long)*(int *)(param_1 + 0x20));\n      pcVar6 = param_3;\n    }\nswitchD_0019c48f_caseD_5:\n    pcVar7 = strerror(param_2);\n    internal_error(\"%s: %s\",param_3,pcVar7);\n  }\n  if (pcVar6 != (char *)0x0) {\n    sh_xfree(pcVar6,\"redir.c\",0xe7);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_0015f5f0": "\nvoid FUN_0015f5f0(int param_1,int param_2,undefined8 param_3)\n\n{\n  uint *puVar1;\n  long lVar2;\n  undefined8 uVar3;\n  \n  lVar2 = (long)param_1;\n  if (param_2 == 2) {\n    __fprintf_chk(param_3,1,\"%ld\\n\",(long)*(int *)(*(long *)(*(long *)(jobs + lVar2 * 8) + 8) + 8));\n    return;\n  }\n  if (param_2 == 3) {\n    if ((*(uint *)(*(long *)(jobs + lVar2 * 8) + 0x18) & 2) != 0) {\n      return;\n    }\n    param_2 = 0;\n  }\n  else if (param_2 == 4) {\n    param_2 = 1;\n    goto LAB_0015f659;\n  }\n  uVar3 = 0x2b;\n  if ((DAT_00238790 != param_1) && (uVar3 = 0x2d, DAT_00238794 != param_1)) {\n    uVar3 = 0x20;\n  }\n  __fprintf_chk(param_3,1,\"[%d]%c \",param_1 + 1,uVar3);\nLAB_0015f659:\n  FUN_0015ef00(*(undefined8 *)(*(long *)(jobs + lVar2 * 8) + 8),param_1,param_2,param_3);\n  puVar1 = (uint *)(*(long *)(jobs + lVar2 * 8) + 0x18);\n  *puVar1 = *puVar1 | 2;\n  return;\n}\n\n",
  "FUN_0019a3c0": "\nbool FUN_0019a3c0(void)\n\n{\n  int iVar1;\n  char *__s1;\n  \n  __s1 = nl_langinfo(0xe);\n  if (*__s1 == 'U') {\n    iVar1 = strcmp(__s1,\"UTF-8\");\n    return iVar1 == 0;\n  }\n  if (*__s1 != 'u') {\n    return false;\n  }\n  iVar1 = strcmp(__s1,\"utf8\");\n  return iVar1 == 0;\n}\n\n",
  "rl_set_prompt": "\nundefined8 rl_set_prompt(char *param_1)\n\n{\n  size_t sVar1;\n  char *__dest;\n  \n  if (rl_prompt != (char *)0x0) {\n    free(rl_prompt);\n  }\n  if (param_1 == (char *)0x0) {\n    rl_display_prompt = \"\";\n    rl_prompt = (char *)0x0;\n  }\n  else {\n    sVar1 = strlen(param_1);\n    __dest = (char *)xmalloc(sVar1 + 1);\n    rl_display_prompt = strcpy(__dest,param_1);\n    rl_prompt = rl_display_prompt;\n  }\n  rl_visible_prompt_length = rl_expand_prompt(rl_prompt);\n  return 0;\n}\n\n",
  "FUN_001d42a0": "\nvoid FUN_001d42a0(long param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  \n  plVar1 = (long *)(param_1 + 8);\n  do {\n    if (*(char *)(plVar1 + -1) == '\\x01') {\n      lVar2 = *plVar1;\n      if (lVar2 != 0) {\n        FUN_001d42a0();\n        lVar2 = *plVar1;\n      }\nLAB_001d42bf:\n      xfree(lVar2);\n    }\n    else if (*(char *)(plVar1 + -1) == '\\x02') {\n      lVar2 = *plVar1;\n      goto LAB_001d42bf;\n    }\n    plVar1 = plVar1 + 2;\n    if (plVar1 == (long *)(param_1 + 0x1018)) {\n      return;\n    }\n  } while( true );\n}\n\n",
  "FUN_00151fa0": "\nvoid FUN_00151fa0(long *param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  long lVar4;\n  long *plVar5;\n  \n  lVar1 = *param_1;\n  plVar5 = param_1;\n  iVar3 = DAT_00242334;\n  lVar4 = export_env;\n  while (lVar1 != 0) {\n    iVar2 = iVar3;\n    if (DAT_00242330 + -1 <= iVar3) {\n      DAT_00242330 = DAT_00242330 + 0x10;\n      lVar4 = strvec_resize();\n      environ = lVar4;\n      export_env = lVar4;\n      iVar2 = DAT_00242334;\n    }\n    lVar1 = *plVar5;\n    plVar5 = plVar5 + 1;\n    iVar3 = iVar2 + 1;\n    *(undefined8 *)(lVar4 + 8 + (long)iVar2 * 8) = 0;\n    DAT_00242334 = iVar3;\n    *(long *)(lVar4 + (long)iVar2 * 8) = lVar1;\n    lVar1 = *plVar5;\n  }\n  sh_xfree(param_1,\"variables.c\",0x13c6);\n  return;\n}\n\n",
  "progcomp_create": "\nvoid progcomp_create(void)\n\n{\n  if (prog_completes != 0) {\n    return;\n  }\n  prog_completes = hash_create(0x200);\n  return;\n}\n\n",
  "FUN_001811f0": "\nuint FUN_001811f0(int param_1,undefined8 param_2)\n\n{\n  uint uVar1;\n  code *__s;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  uint uVar6;\n  size_t sVar7;\n  char *pcVar8;\n  undefined8 uVar9;\n  int iVar10;\n  uint uVar11;\n  long in_FS_OFFSET;\n  int local_200;\n  int local_1fc;\n  undefined local_1f8 [208];\n  undefined local_128 [264];\n  long local_20;\n  \n  uVar4 = running_trap;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_1fc = 0;\n  trap_saved_exit_value = last_command_exit_value;\n  uVar1 = (&DAT_00247e40)[param_1];\n  uVar11 = uVar1 & 1;\n  if (uVar11 == 0) goto LAB_00181428;\n  if ((uVar1 & 0x40) != 0) {\n    uVar11 = 0;\n    goto LAB_00181428;\n  }\n  __s = (code *)(&trap_list)[param_1];\n  uVar11 = 0;\n  if ((__s == initialize_traps) || ((param_1 - 0x41U < 3 && ((uVar1 & 0x10) != 0))))\n  goto LAB_00181428;\n  (&DAT_00247e40)[param_1] = uVar1 & 0xffffffdf | 0x10;\n  sVar7 = strlen((char *)__s);\n  pcVar8 = (char *)sh_xmalloc(sVar7 + 1,\"trap.c\",0x43a);\n  pcVar8 = strcpy(pcVar8,(char *)__s);\n  uVar5 = interrupt_state;\n  running_trap = param_1 + 1;\n  interrupt_state = 0;\n  uVar9 = save_pipestatus_array();\n  save_parser_state(local_128);\n  uVar3 = subst_assign_varlist;\n  uVar2 = temporary_env;\n  subst_assign_varlist = 0;\n  temporary_env = 0;\n  if (param_1 == 0x41) {\n    local_200 = return_catch_flag;\n    iVar10 = 5;\n    if (return_catch_flag != 0) goto LAB_0018146f;\n  }\n  else {\n    save_pipeline(1);\n    local_200 = return_catch_flag;\n    if (return_catch_flag != 0) {\nLAB_0018146f:\n      local_200 = return_catch_flag;\n      xbcopy(return_catch,local_1f8,200);\n      local_1fc = __sigsetjmp(return_catch,0);\n    }\n    iVar10 = (-(uint)(param_1 - 0x41U < 3) & 0xfffffff0) + 0x15;\n  }\n  uVar11 = return_catch_value;\n  if (local_1fc == 0) {\n    evalnest = evalnest + 1;\n    parse_and_execute(pcVar8,param_2,iVar10);\n    evalnest = evalnest + -1;\n    uVar11 = last_command_exit_value;\n  }\n  if (param_1 != 0x41) {\n    restore_pipeline(1);\n  }\n  subst_assign_varlist = uVar3;\n  restore_parser_state(local_128);\n  restore_pipestatus_array(uVar9);\n  uVar6 = (&DAT_00247e40)[param_1];\n  temporary_env = uVar2;\n  if ((uVar1 & 0x10) == 0) {\n    uVar6 = uVar6 & 0xffffffef;\n    (&DAT_00247e40)[param_1] = uVar6;\n  }\n  running_trap = uVar4;\n  interrupt_state = uVar5;\n  if ((uVar6 & 0x20) != 0) {\n    sh_xfree(__s,\"trap.c\",0x481);\n    (&DAT_00247e40)[param_1] = (&DAT_00247e40)[param_1] & 0xffffffdf;\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n  }\n  if (local_200 != 0) {\n    return_catch_flag = local_200;\n    return_catch_value = uVar11;\n    xbcopy(local_1f8,return_catch,200);\n    if (local_1fc != 0) {\n                    /* WARNING: Subroutine does not return */\n      __longjmp_chk(return_catch,1);\n    }\n  }\nLAB_00181428:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar11;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00191550": "\nundefined8 FUN_00191550(void)\n\n{\n  return 0;\n}\n\n",
  "rl_keep_mark_active": "\nvoid rl_keep_mark_active(void)\n\n{\n  _rl_keep_mark_active = _rl_keep_mark_active + 1;\n  return;\n}\n\n",
  "fcntl": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fcntl(int __fd,int __cmd,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fcntl_00237938)();\n  return iVar1;\n}\n\n",
  "FUN_001d77b0": "\nint FUN_001d77b0(int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  fwrite(\"--More--\",1,8,rl_outstream);\n  fflush(rl_outstream);\n  if ((rl_readline_state._2_1_ & 8) == 0) {\n    iVar1 = FUN_001d6fc0(1);\n    _rl_erase_entire_line();\n    if (iVar1 == 0) {\n      iVar2 = -1;\n    }\n    else {\n      iVar2 = 0;\n      if (iVar1 == 2) {\n        iVar2 = param_1 + -1;\n      }\n    }\n    return iVar2;\n  }\n  _rl_erase_entire_line();\n  return 0;\n}\n\n",
  "sh_charvis": "\nulong sh_charvis(long param_1,ulong *param_2,long param_3,long param_4,long *param_5)\n\n{\n  byte *__s;\n  byte *pbVar1;\n  ulong uVar2;\n  size_t sVar3;\n  ushort **ppuVar4;\n  __int32_t **pp_Var5;\n  size_t sVar6;\n  long lVar7;\n  byte bVar8;\n  long lVar9;\n  long lVar10;\n  ulong uVar11;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  uVar2 = *param_2;\n  lVar9 = *param_5;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  __s = (byte *)(param_1 + uVar2);\n  pbVar1 = (byte *)(param_4 + lVar9);\n  bVar8 = *__s;\n  uVar11 = uVar2 + 1;\n  lVar10 = lVar9 + 1;\n  lVar7 = param_3 + param_1;\n  if (locale_mb_cur_max < 2) {\n    lVar7 = 0;\n  }\n  if ((bVar8 != 0x20) && (bVar8 != 9)) {\n    if (bVar8 == 0x7f) {\n      *pbVar1 = 0x5e;\n      lVar10 = lVar9 + 2;\n      *(undefined *)(param_4 + 1 + lVar9) = 0x3f;\n      goto LAB_001cc923;\n    }\n    if (bVar8 < 0x20) {\n      *pbVar1 = 0x5e;\n      bVar8 = bVar8 ^ 0x40;\n      ppuVar4 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar4 + (ulong)bVar8 * 2 + 1) & 2) != 0) {\n        pp_Var5 = __ctype_toupper_loc();\n        bVar8 = *(byte *)(*pp_Var5 + bVar8);\n      }\n      *(byte *)(param_4 + 1 + lVar9) = bVar8;\n      lVar10 = lVar9 + 2;\n      goto LAB_001cc923;\n    }\n    if ((-1 < (char)bVar8) || (locale_utf8locale == 0)) {\n      if ((1 < locale_mb_cur_max) &&\n         ((*(uint *)(is_basic_table + (ulong)(bVar8 >> 5) * 4) >> (bVar8 & 0x1f) & 1) == 0)) {\n        if (((char)bVar8 < '\\0') || (sVar3 = 1, locale_utf8locale == 0)) {\n          sVar3 = mbrtowc((wchar_t *)0x0,(char *)__s,lVar7 - (long)__s,&local_48);\n          if (0xfffffffffffffffd < sVar3) goto LAB_001cca77;\n          bVar8 = *__s;\n          if (sVar3 == 0) {\n            sVar3 = 1;\n          }\n        }\n        lVar10 = lVar9 + sVar3;\n        lVar7 = uVar2 - lVar9;\n        while( true ) {\n          lVar9 = lVar9 + 1;\n          *(byte *)(param_4 + -1 + lVar9) = bVar8;\n          if (lVar9 == lVar10) break;\n          bVar8 = *(byte *)(param_1 + lVar7 + lVar9);\n        }\n        uVar11 = uVar2 + sVar3;\n        goto LAB_001cc923;\n      }\n      if ((char)bVar8 < '\\0') {\n        *pbVar1 = 0x4d;\n        lVar10 = lVar9 + 3;\n        *(undefined *)(param_4 + 1 + lVar9) = 0x2d;\n        *(byte *)(param_4 + 2 + lVar9) = bVar8 & 0x7f;\n        goto LAB_001cc923;\n      }\n    }\n    else if (1 < locale_mb_cur_max) {\n      sVar3 = 1;\n      if ((*(uint *)(is_basic_table + (ulong)(bVar8 >> 5) * 4) >> (bVar8 & 0x1f) & 1) == 0) {\n        sVar6 = mbrtowc((wchar_t *)0x0,(char *)__s,lVar7 - (long)__s,&local_48);\n        if (0xfffffffffffffffd < sVar6) {\nLAB_001cca77:\n          *pbVar1 = *__s;\n          goto LAB_001cc923;\n        }\n        bVar8 = *__s;\n        sVar3 = 1;\n        if (sVar6 != 0) {\n          sVar3 = sVar6;\n        }\n      }\n      lVar10 = lVar9 + sVar3;\n      lVar7 = uVar2 - lVar9;\n      while( true ) {\n        lVar9 = lVar9 + 1;\n        *(byte *)(param_4 + -1 + lVar9) = bVar8;\n        if (lVar10 == lVar9) break;\n        bVar8 = *(byte *)(lVar7 + param_1 + lVar9);\n      }\n      uVar11 = uVar2 + sVar3;\n      goto LAB_001cc923;\n    }\n  }\n  *pbVar1 = bVar8;\nLAB_001cc923:\n  *param_2 = uVar11;\n  *param_5 = lVar10;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar11 & 0xffffffff;\n}\n\n",
  "FUN_00131c3f": "\nvoid FUN_00131c3f(void)\n\n{\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n",
  "__ctype_toupper_loc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__int32_t ** __ctype_toupper_loc(void)\n\n{\n  __int32_t **pp_Var1;\n  \n  pp_Var1 = (__int32_t **)(*(code *)PTR___ctype_toupper_loc_00237808)();\n  return pp_Var1;\n}\n\n",
  "rl_get_next_history": "\nundefined8 rl_get_next_history(int param_1)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  \n  if (param_1 < 0) {\n    uVar3 = rl_get_previous_history(-param_1);\n    return uVar3;\n  }\n  if (param_1 == 0) {\n    return 0;\n  }\n  rl_maybe_replace_line();\n  if (_rl_history_saved_point != -1) {\nLAB_001f13d8:\n    while( true ) {\n      puVar2 = (undefined8 *)next_history();\njoined_r0x001f1486:\n      if (puVar2 == (undefined8 *)0x0) break;\n      param_1 = param_1 + -1;\n      if (param_1 == 0) {\n        rl_replace_line(*puVar2,0);\n        rl_mark = 0;\n        rl_undo_list = puVar2[2];\n        rl_point = rl_end;\n        if (rl_editing_mode == 0) {\n          rl_point = 0;\n          rl_mark = rl_end;\n        }\n        FUN_001f06f0();\n        return 0;\n      }\n    }\n    rl_maybe_unsave_line();\n    return 0;\n  }\n  if (rl_point == 0) {\n    iVar1 = rl_point;\n    if (rl_end == 0) goto LAB_001f13d8;\n  }\n  else {\n    iVar1 = rl_point;\n    if (rl_point == rl_end) {\n      iVar1 = _rl_history_saved_point;\n    }\n  }\n  _rl_history_saved_point = iVar1;\n  puVar2 = (undefined8 *)next_history();\n  goto joined_r0x001f1486;\n}\n\n",
  "FUN_0019e490": "\nundefined8 FUN_0019e490(long param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  long *plVar3;\n  long lVar4;\n  long *plVar5;\n  size_t sVar6;\n  char *__dest;\n  char *__s;\n  undefined8 *puVar7;\n  long lVar8;\n  int iVar9;\n  int iVar10;\n  \n  plVar3 = (long *)all_aliases();\n  if (plVar3 == (long *)0x0) {\n    *(undefined8 *)(param_1 + 0x10) = 0;\n    return 0;\n  }\n  iVar10 = 0;\n  lVar8 = 8;\n  iVar2 = 0;\n  if (*plVar3 == 0) {\n    plVar5 = (long *)strlist_create(1);\n    puVar7 = (undefined8 *)*plVar5;\n  }\n  else {\n    do {\n      iVar9 = iVar2;\n      lVar4 = lVar8;\n      iVar10 = iVar9 + 1;\n      lVar8 = lVar4 + 8;\n      iVar2 = iVar10;\n    } while (*(long *)((long)plVar3 + lVar4) != 0);\n    lVar8 = 0;\n    plVar5 = (long *)strlist_create(iVar9 + 2);\n    do {\n      __s = **(char ***)((long)plVar3 + lVar8);\n      if (__s != (char *)0x0) {\n        sVar6 = strlen(__s);\n        __dest = (char *)sh_xmalloc(sVar6 + 1,\"pcomplete.c\",0x180);\n        __s = strcpy(__dest,__s);\n      }\n      lVar1 = *plVar5;\n      *(char **)(lVar1 + lVar8) = __s;\n      lVar8 = lVar8 + 8;\n    } while ((long)(iVar9 + 1) * 8 != lVar8);\n    puVar7 = (undefined8 *)(lVar1 + lVar4);\n  }\n  *puVar7 = 0;\n  *(int *)((long)plVar5 + 0xc) = iVar10;\n  *(int *)(plVar5 + 1) = iVar10;\n  *(long **)(param_1 + 0x10) = plVar5;\n  sh_xfree(plVar3,\"pcomplete.c\",0x187);\n  return 1;\n}\n\n",
  "xtrace_init": "\nvoid xtrace_init(void)\n\n{\n  if (stderr != 0) {\n    xtrace_fd = 0xffffffff;\n    xtrace_fp = stderr;\n    return;\n  }\n  internal_error(\"xtrace_set: NULL file pointer\");\n  return;\n}\n\n",
  "FUN_001517e0": "\nundefined8 FUN_001517e0(undefined8 param_1,char *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  \n  if (restricted == 0) {\nLAB_00151849:\n    phash_insert(param_4,param_2,0,0);\n    uVar3 = FUN_001516e0(param_1);\n    return uVar3;\n  }\n  pcVar2 = strchr(param_2,0x2f);\n  if (pcVar2 != (char *)0x0) {\n    sh_restricted(param_2);\n    return 0;\n  }\n  pcVar2 = (char *)find_user_command();\n  if ((pcVar2 != (char *)0x0) && (*pcVar2 != '\\0')) {\n    iVar1 = executable_file(pcVar2);\n    if (iVar1 != 0) {\n      sh_xfree(pcVar2,\"variables.c\",0x6fb);\n      goto LAB_00151849;\n    }\n  }\n  sh_notfound(param_2);\n  sh_xfree(pcVar2,\"variables.c\",0x6f8);\n  return 0;\n}\n\n",
  "_rl_callback_data_dispose": "\nvoid _rl_callback_data_dispose(void)\n\n{\n  xfree();\n  return;\n}\n\n",
  "fnmatch": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fnmatch(char *__pattern,char *__name,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fnmatch_00237a58)();\n  return iVar1;\n}\n\n",
  "FUN_00191560": "\nvoid FUN_00191560(byte *param_1,int param_2)\n\n{\n  size_t sVar1;\n  byte *pbVar2;\n  byte bVar3;\n  \n  sVar1 = strlen((char *)param_1);\n  pbVar2 = (byte *)sh_xmalloc((long)((int)sVar1 + 1),\"bashline.c\",0xff1);\n  bVar3 = *param_1;\n  do {\n    if (bVar3 == 0) {\n      *pbVar2 = 0;\n      return;\n    }\n    if (bVar3 == 0x5c) {\n      if ((param_2 == 0x27) ||\n         ((bVar3 = param_1[1], param_2 == 0x22 && ((*(byte *)(&sh_syntaxtab + bVar3) & 0x40) == 0)))\n         ) {\n        *pbVar2 = 0x5c;\n        bVar3 = param_1[1];\n        pbVar2 = pbVar2 + 1;\n      }\n      *pbVar2 = bVar3;\n      if (bVar3 == 0) {\n        return;\n      }\n      param_1 = param_1 + 1;\n      pbVar2 = pbVar2 + 1;\n    }\n    else if (param_2 == 0) {\n      if ((bVar3 == 0x27) || (bVar3 == 0x22)) {\n        param_2 = (int)(char)bVar3;\n      }\n      else {\nLAB_001915b3:\n        *pbVar2 = bVar3;\n        pbVar2 = pbVar2 + 1;\n      }\n    }\n    else {\n      if ((char)bVar3 != param_2) goto LAB_001915b3;\n      param_2 = 0;\n    }\n    bVar3 = param_1[1];\n    param_1 = param_1 + 1;\n  } while( true );\n}\n\n",
  "FUN_001a7e10": "\nuint FUN_001a7e10(char *param_1,uint param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  long lVar4;\n  long lVar5;\n  long lVar6;\n  int *piVar7;\n  long lVar8;\n  size_t sVar9;\n  undefined8 uVar10;\n  undefined8 *puVar11;\n  long lVar12;\n  char *pcVar13;\n  uint uVar14;\n  long lVar15;\n  undefined8 uVar16;\n  undefined8 uVar17;\n  long in_FS_OFFSET;\n  char local_244;\n  long local_238;\n  long local_230;\n  undefined8 local_228;\n  code *local_210;\n  undefined4 local_1b4;\n  char *local_1b0;\n  stat local_1a8;\n  undefined local_118 [214];\n  undefined2 local_42;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar4 = find_variable(\"FUNCNAME\");\n  local_228 = 0;\n  if ((lVar4 != 0) && ((*(byte *)(lVar4 + 0x28) & 4) != 0)) {\n    local_228 = *(undefined8 *)(lVar4 + 8);\n  }\n  uVar17 = 0;\n  lVar5 = find_variable(\"BASH_SOURCE\");\n  if ((lVar5 != 0) && ((*(byte *)(lVar5 + 0x28) & 4) != 0)) {\n    uVar17 = *(undefined8 *)(lVar5 + 8);\n  }\n  uVar16 = 0;\n  lVar6 = find_variable(\"BASH_LINENO\");\n  if ((lVar6 != 0) && ((*(byte *)(lVar6 + 0x28) & 4) != 0)) {\n    uVar16 = *(undefined8 *)(lVar6 + 8);\n  }\n  local_238 = find_variable(\"BASH_ARGV\");\n  if (local_238 != 0) {\n    if ((*(byte *)(local_238 + 0x28) & 4) == 0) {\n      local_238 = 0;\n    }\n    else {\n      local_238 = *(long *)(local_238 + 8);\n    }\n  }\n  local_230 = find_variable(\"BASH_ARGC\");\n  if (local_230 != 0) {\n    if ((*(byte *)(local_230 + 0x28) & 4) == 0) {\n      local_230 = 0;\n    }\n    else {\n      local_230 = *(long *)(local_230 + 8);\n    }\n  }\n  iVar1 = open(param_1,0);\n  if (iVar1 < 0) {\n    piVar7 = __errno_location();\n    iVar2 = *piVar7;\nLAB_001a7f1b:\n    *piVar7 = iVar2;\nLAB_001a7f1d:\n    if (((param_2 & 1) == 0) || (piVar7 = __errno_location(), *piVar7 != 2)) {\n      file_error(param_1);\n    }\n    if ((param_2 & 0x10) != 0) {\n      last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n      jump_to_top_level(3);\n    }\n    if ((param_2 & 2) == 0) {\n      piVar7 = __errno_location();\n      uVar14 = (*piVar7 == 2 & param_2) - 1;\n      goto LAB_001a7f52;\n    }\n  }\n  else {\n    iVar2 = fstat(iVar1,&local_1a8);\n    if (iVar2 == -1) {\n      piVar7 = __errno_location();\n      iVar2 = *piVar7;\n      close(iVar1);\n      goto LAB_001a7f1b;\n    }\n    uVar3 = param_2 & 2;\n    if (uVar3 == 0) {\n      local_210 = internal_error;\n    }\n    else {\n      local_210 = builtin_error;\n    }\n    local_1a8.st_mode = local_1a8.st_mode & 0xf000;\n    if (local_1a8.st_mode != 0x4000) {\n      local_244 = (char)param_2;\n      if ((local_244 < '\\0') && (local_1a8.st_mode != 0x8000)) {\n        pcVar13 = \"%s: not a regular file\";\n        goto LAB_001a8052;\n      }\n      pcVar13 = \"%s: file is too large\";\n      if (local_1a8.st_size == 0xffffffffffffffff) goto LAB_001a8052;\n      if ((local_1a8.st_mode == 0x8000) && (-1 < local_1a8.st_size)) {\n        local_1b0 = (char *)sh_xmalloc(local_1a8.st_size + 1,\"evalfile.c\",0xa0);\n        lVar8 = read(iVar1,local_1b0,local_1a8.st_size);\n        if (-1 < lVar8) {\n          local_1b0[lVar8] = '\\0';\n        }\n      }\n      else {\n        iVar2 = zmapfd(iVar1,&local_1b0,0);\n        lVar8 = (long)iVar2;\n      }\n      piVar7 = __errno_location();\n      iVar2 = *piVar7;\n      close(iVar1);\n      pcVar13 = local_1b0;\n      *piVar7 = iVar2;\n      if (-1 < lVar8) {\n        if (lVar8 == 0) {\n          sh_xfree(local_1b0,\"evalfile.c\",0xb4);\n          uVar14 = (uint)(uVar3 == 0);\n          goto LAB_001a7f52;\n        }\n        sVar9 = strlen(local_1b0);\n        if ((int)sVar9 < lVar8) {\n          lVar15 = 0;\n          iVar1 = 0;\n          do {\n            lVar12 = lVar8;\n            if (pcVar13[lVar15] == '\\0') {\n              lVar12 = lVar8 + -1;\n              memmove(pcVar13 + lVar15,pcVar13 + lVar15 + 1,lVar8 - lVar15);\n              if ((uVar3 != 0) && (iVar1 = iVar1 + 1, 0x100 < iVar1)) {\n                uVar14 = 0x7e;\n                sh_xfree(local_1b0,\"evalfile.c\",0xcd);\n                (*local_210)(\"%s: cannot execute binary file\",param_1);\n                goto LAB_001a7f52;\n              }\n            }\n            lVar15 = lVar15 + 1;\n            pcVar13 = local_1b0;\n            lVar8 = lVar12;\n          } while (lVar15 < lVar12);\n        }\n        uVar3 = param_2 & 4;\n        if (uVar3 == 0) {\n          xbcopy(return_catch,local_118,200);\n          if ((param_2 & 8) != 0) {\n            local_1b4 = interactive;\n            goto LAB_001a831d;\n          }\n        }\n        else {\n          begin_unwind_frame(\"_evalfile\");\n          unwind_protect_mem(&return_catch_flag,4);\n          unwind_protect_mem(return_catch,200);\n          if ((param_2 & 8) != 0) {\n            unwind_protect_mem(&interactive,4);\n          }\n          unwind_protect_mem(&sourcelevel,4);\n          if ((param_2 & 8) != 0) {\nLAB_001a831d:\n            interactive = 0;\n          }\n        }\n        return_catch_flag = return_catch_flag + 1;\n        sourcelevel = sourcelevel + 1;\n        array_rshift(uVar17,1,param_1);\n        iVar1 = executing_line_number();\n        uVar10 = itos((long)iVar1);\n        array_rshift(uVar16,1,uVar10);\n        sh_xfree(uVar10,\"evalfile.c\",0xef);\n        array_rshift(local_228,1,\"source\");\n        puVar11 = (undefined8 *)sh_xmalloc(0x30,\"evalfile.c\",0xf2);\n        puVar11[2] = uVar17;\n        puVar11[3] = lVar5;\n        puVar11[4] = uVar16;\n        puVar11[5] = lVar6;\n        *puVar11 = local_228;\n        puVar11[1] = lVar4;\n        if (uVar3 != 0) {\n          add_unwind_protect(restore_funcarray_state,puVar11);\n        }\n        if ((param_2 & 0x100) == 0) {\n          if (shell_compatibility_level < 0x2d) {\n            init_bash_argv();\n          }\n          array_rshift(local_238,1,param_1);\n          local_42 = 0x31;\n          array_rshift(local_230,1,&local_42);\n          if (uVar3 != 0) {\n            add_unwind_protect(pop_args,0);\n          }\n        }\n        iVar1 = __sigsetjmp(return_catch,0);\n        if (iVar1 == 0) {\n          uVar14 = parse_and_execute(local_1b0,param_1,(uint)((param_2 & 0x20) == 0) << 2 | 0x10);\n          if ((param_2 & 4) != 0) goto LAB_001a8535;\nLAB_001a847e:\n          if ((param_2 & 8) != 0) {\n            interactive = local_1b4;\n          }\n          restore_funcarray_state(puVar11);\n          if ((param_2 & 0x100) == 0) {\n            array_shift(local_230,1,1);\n            array_shift(local_238,1,1);\n          }\n          return_catch_flag = return_catch_flag + -1;\n          sourcelevel = sourcelevel + -1;\n          xbcopy(local_118,return_catch,200);\n        }\n        else {\n          parse_and_execute_cleanup(0xffffffff);\n          uVar14 = return_catch_value;\n          if ((param_2 & 4) == 0) goto LAB_001a847e;\nLAB_001a8535:\n          run_unwind_frame(\"_evalfile\");\n        }\n        if (current_token == 0x131) {\n          push_token(10);\n        }\n        if ((param_2 & 2) != 0) goto LAB_001a7f52;\n        goto LAB_001a7f4c;\n      }\n      sh_xfree(local_1b0,\"evalfile.c\",0xae);\n      goto LAB_001a7f1d;\n    }\n    pcVar13 = \"%s: is a directory\";\nLAB_001a8052:\n    uVar14 = 0xffffffff;\n    (*local_210)(pcVar13,param_1);\n    close(iVar1);\n    if (uVar3 == 0) goto LAB_001a7f52;\n  }\nLAB_001a7f4c:\n  uVar14 = 1;\nLAB_001a7f52:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar14;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00131c2d": "\nvoid FUN_00131c2d(void)\n\n{\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n",
  "sv_execignore": "\nvoid sv_execignore(void)\n\n{\n  setup_exec_ignore();\n  return;\n}\n\n",
  "get_hostname_list": "\nundefined8 get_hostname_list(void)\n\n{\n  if (hostname_list_initialized != 0) {\n    return DAT_00248860;\n  }\n  FUN_00192f00();\n  return DAT_00248860;\n}\n\n",
  "iswalnum": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswalnum(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswalnum_00237bd8)();\n  return iVar1;\n}\n\n",
  "FUN_0018ee60": "\nchar ** FUN_0018ee60(char **param_1,char **param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  size_t sVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char **ppcVar6;\n  char **ppcVar7;\n  char **ppcVar8;\n  char **ppcVar9;\n  int local_5c;\n  char **local_58;\n  \n  if (((*param_2 == (char *)0x0) || (**param_2 != '\\0')) ||\n     (local_58 = param_1, param_2[1] != (char *)0x0)) {\n    iVar1 = strvec_len(param_1);\n    iVar2 = strvec_len(param_2);\n    local_58 = (char **)sh_malloc((long)(iVar2 * iVar1 + 1) << 3,\"braces.c\",0x2f7);\n    if (local_58 != (char **)0x0) {\n      ppcVar7 = local_58;\n      if (0 < iVar1) {\n        local_5c = 0;\n        ppcVar7 = param_1;\n        do {\n          pcVar5 = *ppcVar7;\n          sVar3 = strlen(pcVar5);\n          if (0 < iVar2) {\n            ppcVar6 = local_58 + local_5c;\n            ppcVar8 = param_2;\n            do {\n              ppcVar9 = ppcVar8 + 1;\n              sVar4 = strlen(*ppcVar8);\n              pcVar5 = (char *)sh_xmalloc(sVar4 + (long)((int)sVar3 + 1),\"braces.c\",0x302);\n              *ppcVar6 = pcVar5;\n              strcpy(pcVar5,*ppcVar7);\n              strcpy(*ppcVar6 + (int)sVar3,*ppcVar8);\n              ppcVar6 = ppcVar6 + 1;\n              ppcVar8 = ppcVar9;\n            } while (param_2 + (ulong)(iVar2 - 1) + 1 != ppcVar9);\n            local_5c = local_5c + iVar2;\n            pcVar5 = *ppcVar7;\n          }\n          ppcVar7 = ppcVar7 + 1;\n          sh_xfree(pcVar5,\"braces.c\",0x307);\n        } while (ppcVar7 != param_1 + (ulong)(iVar1 - 1) + 1);\n        ppcVar7 = local_58 + local_5c;\n      }\n      sh_xfree(param_1,\"braces.c\",0x309);\n      *ppcVar7 = (char *)0x0;\n    }\n  }\n  return local_58;\n}\n\n",
  "make_arith_command": "\nundefined8 * make_arith_command(undefined8 param_1)\n\n{\n  undefined4 uVar1;\n  undefined8 *puVar2;\n  undefined4 *puVar3;\n  \n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0x1b2);\n  puVar3 = (undefined4 *)sh_xmalloc(0x10,\"make_cmd.c\",0x1b3);\n  uVar1 = line_number;\n  puVar2[3] = puVar3;\n  *puVar3 = 0;\n  puVar3[1] = uVar1;\n  *(undefined8 *)(puVar3 + 2) = param_1;\n  puVar2[2] = 0;\n  *puVar2 = 10;\n  return puVar2;\n}\n\n",
  "coproc_setvars": "\nvoid coproc_setvars(char **param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  size_t sVar3;\n  undefined8 uVar4;\n  undefined1 *puVar5;\n  undefined8 uVar6;\n  char *__dest;\n  char *pcVar7;\n  long in_FS_OFFSET;\n  char *local_48;\n  undefined4 local_40;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*param_1 == (char *)0x0) goto LAB_0014a064;\n  local_40 = 0;\n  local_48 = *param_1;\n  iVar1 = check_identifier(&local_48,1);\n  if (iVar1 == 0) goto LAB_0014a064;\n  sVar3 = strlen(*param_1);\n  uVar4 = sh_xmalloc(sVar3 + 0x10,\"execute_cmd.c\",0x8ee);\n  puVar5 = (undefined1 *)find_variable(*param_1);\n  if (puVar5 == (undefined1 *)0x0) {\n    puVar5 = (undefined1 *)find_variable_nameref_for_create(*param_1,1);\n    if (puVar5 == nameref_invalid_value) {\n      sh_xfree(uVar4,\"execute_cmd.c\",0x8f9);\n      goto LAB_0014a064;\n    }\n    if (puVar5 != (undefined1 *)0x0) {\n      uVar2 = *(uint *)(puVar5 + 0x28);\n      if ((uVar2 & 0x800) == 0) goto LAB_0014a0c2;\n      sh_xfree(*param_1,\"execute_cmd.c\",0x8fe);\n      pcVar7 = *(char **)(puVar5 + 8);\n      sVar3 = strlen(pcVar7);\n      __dest = (char *)sh_xmalloc(sVar3 + 1,\"execute_cmd.c\",0x8ff);\n      pcVar7 = strcpy(__dest,pcVar7);\n      *param_1 = pcVar7;\n      puVar5 = (undefined1 *)make_new_array_variable(pcVar7);\n      if (puVar5 != (undefined1 *)0x0) goto LAB_0014a0bf;\n    }\n    puVar5 = (undefined1 *)make_new_array_variable(*param_1);\n    uVar2 = *(uint *)(puVar5 + 0x28);\n  }\n  else {\nLAB_0014a0bf:\n    uVar2 = *(uint *)(puVar5 + 0x28);\nLAB_0014a0c2:\n    if ((uVar2 & 0x4002) != 0) {\n      if ((uVar2 & 2) != 0) {\n        err_readonly(*param_1);\n      }\n      sh_xfree(uVar4,\"execute_cmd.c\",0x908);\n      goto LAB_0014a064;\n    }\n  }\n  if ((uVar2 & 4) == 0) {\n    convert_var_to_array(puVar5);\n  }\n  uVar6 = itos((long)*(int *)((long)param_1 + 0xc));\n  bind_array_variable(*param_1,0,uVar6,0);\n  sh_xfree(uVar6,\"execute_cmd.c\",0x913);\n  uVar6 = itos((long)*(int *)(param_1 + 2));\n  bind_array_variable(*param_1,1,uVar6,0);\n  sh_xfree(uVar6,\"execute_cmd.c\",0x918);\n  __sprintf_chk(uVar4,1,0xffffffffffffffff,\"%s_PID\",*param_1);\n  uVar6 = itos((long)*(int *)(param_1 + 1));\n  bind_variable(uVar4,uVar6,0);\n  sh_xfree(uVar6,\"execute_cmd.c\",0x927);\n  sh_xfree(uVar4,\"execute_cmd.c\",0x929);\nLAB_0014a064:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0019e7a0": "\nundefined8 FUN_0019e7a0(undefined8 param_1)\n\n{\n  FUN_0019e5f0(param_1,all_visible_variables);\n  return 0;\n}\n\n",
  "FUN_00131c48": "\nvoid FUN_00131c48(void)\n\n{\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n",
  "copy_function_def": "\nvoid copy_function_def(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = sh_xmalloc(0x20,\"copy_cmd.c\",0x165);\n  copy_function_def_contents(param_1,uVar1);\n  return;\n}\n\n",
  "hash_remove": "\nlong ** hash_remove(char *param_1,long *param_2)\n\n{\n  long **pplVar1;\n  char cVar2;\n  char cVar3;\n  int iVar4;\n  int iVar5;\n  long **pplVar6;\n  uint uVar7;\n  long **pplVar8;\n  char *pcVar9;\n  long **pplVar10;\n  \n  if (param_2 == (long *)0x0) {\n    return (long **)0x0;\n  }\n  pplVar6 = (long **)0x0;\n  iVar4 = *(int *)((long)param_2 + 0xc);\n  if (iVar4 != 0) {\n    cVar2 = *param_1;\n    if (cVar2 == '\\0') {\n      uVar7 = 0x811c9dc5;\n    }\n    else {\n      uVar7 = 0x811c9dc5;\n      pcVar9 = param_1;\n      cVar3 = cVar2;\n      do {\n        pcVar9 = pcVar9 + 1;\n        uVar7 = uVar7 * 0x1000193 ^ (int)cVar3;\n        cVar3 = *pcVar9;\n      } while (cVar3 != '\\0');\n    }\n    pplVar1 = (long **)(*param_2 + (long)(int)(*(int *)(param_2 + 1) - 1U & uVar7) * 8);\n    pplVar6 = (long **)*pplVar1;\n    if (pplVar6 == (long **)0x0) {\n      pplVar6 = (long **)0x0;\n    }\n    else {\n      pplVar10 = (long **)0x0;\n      do {\n        pplVar8 = pplVar6;\n        if (((*(uint *)(pplVar8 + 3) == uVar7) && (*(char *)pplVar8[1] == cVar2)) &&\n           (iVar5 = strcmp((char *)pplVar8[1],param_1), iVar5 == 0)) {\n          if (pplVar10 == (long **)0x0) {\n            *pplVar1 = *pplVar8;\n          }\n          else {\n            *pplVar10 = *pplVar8;\n          }\n          *(int *)((long)param_2 + 0xc) = iVar4 + -1;\n          return pplVar8;\n        }\n        pplVar6 = (long **)*pplVar8;\n        pplVar10 = pplVar8;\n      } while (pplVar6 != (long **)0x0);\n    }\n  }\n  return pplVar6;\n}\n\n",
  "exec_builtin": "\nint exec_builtin(undefined8 param_1)\n\n{\n  bool bVar1;\n  bool bVar2;\n  long lVar3;\n  int iVar4;\n  int iVar5;\n  char **ppcVar6;\n  char *pcVar7;\n  size_t sVar8;\n  char *pcVar9;\n  char *pcVar10;\n  int *piVar11;\n  undefined8 *puVar12;\n  char *pcVar13;\n  uint local_44;\n  \n  bVar2 = false;\n  bVar1 = false;\n  exec_argv0 = (char *)0x0;\n  reset_internal_getopt();\n  pcVar10 = (char *)0x0;\n  do {\n    while( true ) {\n      while( true ) {\n        iVar4 = internal_getopt(param_1,&DAT_0020fa48);\n        lVar3 = loptend;\n        if (iVar4 == -1) {\n          dispose_redirects(redirection_undo_list);\n          redirection_undo_list = 0;\n          if (lVar3 == 0) {\n            redirection_undo_list = 0;\n            return 0;\n          }\n          local_44 = restricted;\n          if (restricted == 0) {\n            ppcVar6 = (char **)strvec_from_word_list(lVar3,1,0,0);\n            iVar4 = absolute_program(*ppcVar6);\n            if (iVar4 == 0) {\n              pcVar9 = (char *)search_for_command(*ppcVar6,1);\n            }\n            else {\n              pcVar9 = *ppcVar6;\n            }\n            if (pcVar9 == (char *)0x0) {\n              iVar4 = file_isdir(*ppcVar6);\n              puVar12 = (undefined8 *)0x0;\n              if (iVar4 == 0) {\n                iVar4 = 0x7f;\n                sh_notfound(*ppcVar6);\n                local_44 = 0;\n              }\n              else {\n                iVar4 = 0x7e;\n                pcVar10 = strerror(0x15);\n                builtin_error(\"%s: cannot execute: %s\",*ppcVar6,pcVar10);\n              }\n            }\n            else {\n              pcVar7 = (char *)full_pathname(pcVar9);\n              pcVar13 = pcVar9;\n              if ((pcVar7 != (char *)0x0) && (pcVar13 = pcVar7, *ppcVar6 != pcVar9)) {\n                sh_xfree(pcVar9,\"./exec.def\",0xb0);\n              }\n              if (pcVar10 == (char *)0x0) {\n                if (bVar1) {\n                  pcVar10 = *ppcVar6;\n                  sVar8 = strlen(pcVar10);\n                  pcVar9 = (char *)sh_xmalloc(sVar8 + 2,\"./exec.def\",0x5d);\n                  *pcVar9 = '-';\n                  strcpy(pcVar9 + 1,pcVar10);\n                  sh_xfree(*ppcVar6,\"./exec.def\",0xbd);\n                  *ppcVar6 = pcVar9;\n                }\n              }\n              else {\n                sh_xfree(*ppcVar6,\"./exec.def\",0xb6);\n                if (bVar1) {\n                  sVar8 = strlen(pcVar10);\n                  pcVar9 = (char *)sh_xmalloc(sVar8 + 2,\"./exec.def\",0x5d);\n                  *pcVar9 = '-';\n                  strcpy(pcVar9 + 1,pcVar10);\n                }\n                else {\n                  sVar8 = strlen(pcVar10);\n                  pcVar9 = (char *)sh_xmalloc(sVar8 + 1,\"./exec.def\",0xb7);\n                  pcVar9 = strcpy(pcVar9,pcVar10);\n                }\n                *ppcVar6 = pcVar9;\n                sVar8 = strlen(pcVar9);\n                pcVar10 = (char *)sh_xmalloc(sVar8 + 1,\"./exec.def\",0xb8);\n                exec_argv0 = strcpy(pcVar10,pcVar9);\n              }\n              if (bVar2) {\n                puVar12 = (undefined8 *)strvec_create(1);\n                *puVar12 = 0;\n              }\n              else {\n                if ((subshell_environment & 2) == 0) {\n                  adjust_shell_level(0xffffffff);\n                }\n                maybe_make_export_env();\n                puVar12 = export_env;\n              }\n              if ((interactive_shell != 0) && (subshell_environment == 0)) {\n                maybe_save_shell_history();\n              }\n              reset_signal_handlers();\n              local_44 = job_control;\n              if (subshell_environment == 0) {\n                end_job_control();\n              }\n              if ((job_control | interactive) != 0) {\n                default_tty_job_signals();\n              }\n              if (-1 < default_buffered_input) {\n                sync_buffered_stream();\n              }\n              iVar4 = shell_execve(pcVar13,ppcVar6,puVar12);\n              if (!bVar2) {\n                adjust_shell_level(1);\n              }\n              if (iVar4 != 0x7f) {\n                iVar5 = executable_file(pcVar13);\n                if (iVar5 == 0) {\n                  piVar11 = __errno_location();\n                  iVar4 = 0x7e;\n                  pcVar10 = strerror(*piVar11);\n                  builtin_error(\"%s: cannot execute: %s\",pcVar13,pcVar10);\n                }\n                else {\n                  file_error(pcVar13);\n                }\n              }\n              ppcVar6 = (char **)0x0;\n              sh_xfree(pcVar13,\"./exec.def\",0xfd);\n            }\n            if ((subshell_environment == 0) && ((interactive | no_exit_on_failed_exec) != 0)) {\n              if (ppcVar6 != (char **)0x0) {\n                strvec_dispose(ppcVar6);\n              }\n              if ((puVar12 != (undefined8 *)0x0) && (export_env != puVar12)) {\n                strvec_dispose(puVar12);\n              }\n              initialize_signals(1);\n              restore_traps();\n              if (local_44 == 0) {\n                return iVar4;\n              }\n              restart_job_control();\n              return iVar4;\n            }\n            last_command_exit_value = iVar4;\n                    /* WARNING: Subroutine does not return */\n            exit_shell(iVar4);\n          }\n          sh_restricted(0);\n          return 1;\n        }\n        if (iVar4 != 99) break;\n        bVar2 = true;\n      }\n      if (iVar4 < 100) break;\n      if (iVar4 != 0x6c) goto LAB_001a9980;\n      bVar1 = true;\n    }\n    if (iVar4 == -99) {\n      builtin_help();\n      return 0x102;\n    }\n    pcVar10 = list_optarg;\n  } while (iVar4 == 0x61);\nLAB_001a9980:\n  builtin_usage();\n  return 0x102;\n}\n\n",
  "restore_funcarray_state": "\nvoid restore_funcarray_state(long param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  undefined8 uVar3;\n  \n  array_shift(*(undefined8 *)(param_1 + 0x10),1,1);\n  array_shift(*(undefined8 *)(param_1 + 0x20),1,1);\n  lVar2 = find_variable(\"FUNCNAME\");\n  uVar3 = 0;\n  if ((lVar2 == 0) || ((*(byte *)(lVar2 + 0x28) & 4) == 0)) {\n    lVar1 = *(long *)(param_1 + 8);\n  }\n  else {\n    uVar3 = *(undefined8 *)(lVar2 + 8);\n    lVar1 = *(long *)(param_1 + 8);\n  }\n  if (lVar1 == lVar2) {\n    array_shift(uVar3,1,1);\n  }\n  sh_xfree(param_1,\"execute_cmd.c\",0x13a1);\n  return;\n}\n\n",
  "alias_builtin": "\nulong alias_builtin(undefined8 param_1)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  bool bVar4;\n  int iVar5;\n  int iVar6;\n  long *plVar7;\n  ulong uVar8;\n  long lVar9;\n  long *plVar10;\n  long *plVar11;\n  bool bVar12;\n  \n  bVar12 = posixly_correct == 0;\n  bVar4 = false;\n  reset_internal_getopt();\n  while (iVar5 = internal_getopt(param_1,&DAT_001faa86), plVar11 = loptend, iVar5 != -1) {\n    if (iVar5 == -99) {\n      builtin_help();\n      return 0x102;\n    }\n    bVar4 = true;\n    bVar12 = true;\n    if (iVar5 != 0x70) {\n      builtin_usage();\n      return 0x102;\n    }\n  }\n  if ((loptend == (long *)0x0) || (bVar4)) {\n    if ((aliases == 0) || (plVar7 = (long *)all_aliases(), plVar7 == (long *)0x0)) {\n      return 0;\n    }\n    lVar9 = *plVar7;\n    plVar10 = plVar7;\n    while (lVar9 != 0) {\n      plVar10 = plVar10 + 1;\n      FUN_001a1aa0(lVar9,bVar12);\n      lVar9 = *plVar10;\n    }\n    sh_xfree(plVar7,\"./alias.def\",0x6e);\n    if (plVar11 == (long *)0x0) {\n      uVar8 = sh_chkwrite(0);\n      return uVar8;\n    }\n  }\n  iVar5 = 0;\n  do {\n    pcVar3 = *(char **)plVar11[1];\n    if ((*pcVar3 == '=') || (*pcVar3 == '\\0')) {\nLAB_001a1ce8:\n      lVar9 = find_alias(pcVar3);\n      if (lVar9 == 0) {\n        iVar5 = iVar5 + 1;\n        sh_notfound(pcVar3);\n      }\n      else {\n        FUN_001a1aa0(lVar9,bVar12);\n      }\n    }\n    else {\n      lVar9 = 1;\n      do {\n        pcVar1 = pcVar3 + lVar9;\n        pcVar2 = pcVar3 + lVar9;\n        lVar9 = lVar9 + 1;\n        if (*pcVar1 == '\\0') goto LAB_001a1ce8;\n      } while (*pcVar1 != '=');\n      *pcVar2 = '\\0';\n      iVar6 = legal_alias_name(pcVar3,0);\n      if (iVar6 == 0) {\n        iVar5 = iVar5 + 1;\n        builtin_error(\"`%s\\': invalid alias name\");\n      }\n      else {\n        add_alias(pcVar3);\n      }\n    }\n    plVar11 = (long *)*plVar11;\n    if (plVar11 == (long *)0x0) {\n      return (ulong)(iVar5 != 0);\n    }\n  } while( true );\n}\n\n",
  "itos": "\nvoid itos(undefined8 param_1)\n\n{\n  char *__s;\n  size_t sVar1;\n  char *__dest;\n  long in_FS_OFFSET;\n  undefined auStack_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  __s = (char *)fmtumax(param_1,10,auStack_28,0x16,0);\n  sVar1 = strlen(__s);\n  __dest = (char *)sh_xmalloc(sVar1 + 1,\"itos.c\",0x32);\n  strcpy(__dest,__s);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "localtime": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntm * localtime(time_t *__timer)\n\n{\n  tm *ptVar1;\n  \n  ptVar1 = (tm *)(*(code *)PTR_localtime_00237858)();\n  return ptVar1;\n}\n\n",
  "FUN_00134d00": "\nvoid FUN_00134d00(void)\n\n{\n  byte *pbVar1;\n  long *plVar2;\n  long *plVar3;\n  \n  plVar3 = pushed_string_list;\n  if (pushed_string_list != (long *)0x0) {\n    do {\n      plVar2 = (long *)*plVar3;\n      if (plVar3[2] != 0) {\n        sh_xfree(plVar3[2],\"/usr/local/src/chet/src/bash/src/parse.y\",0x7c5);\n      }\n      if (plVar3[3] != 0) {\n        pbVar1 = (byte *)(plVar3[3] + 0x10);\n        *pbVar1 = *pbVar1 & 0xfd;\n      }\n      sh_xfree(plVar3,\"/usr/local/src/chet/src/bash/src/parse.y\",0x7ca);\n      plVar3 = plVar2;\n    } while (plVar2 != (long *)0x0);\n  }\n  pushed_string_list = (long *)0x0;\n  return;\n}\n\n",
  "async_redirect_stdin": "\nvoid async_redirect_stdin(void)\n\n{\n  int __fd;\n  int *piVar1;\n  char *pcVar2;\n  \n  __fd = open(\"/dev/null\",0);\n  if (0 < __fd) {\n    dup2(__fd,0);\n    close(__fd);\n    return;\n  }\n  if (__fd == 0) {\n    return;\n  }\n  piVar1 = __errno_location();\n  pcVar2 = strerror(*piVar1);\n  internal_error(\"cannot redirect standard input from /dev/null: %s\",pcVar2);\n  return;\n}\n\n",
  "realloc": "\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)FUN_001f9500(__ptr,__size,0,0);\n  return pvVar1;\n}\n\n",
  "fgets": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * fgets(char *__s,int __n,FILE *__stream)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_fgets_00237ae8)();\n  return pcVar1;\n}\n\n",
  "FUN_00131c5a": "\nvoid FUN_00131c5a(void)\n\n{\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n",
  "FUN_001dbd80": "\nundefined8 FUN_001dbd80(char *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  size_t sVar2;\n  undefined8 uVar3;\n  undefined *puVar4;\n  long in_FS_OFFSET;\n  int local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar2 = strlen(param_1);\n  uVar3 = xmalloc(sVar2 * 2 + 1);\n  iVar1 = rl_translate_keyseq(param_1,uVar3,&local_34);\n  if (iVar1 == 0) {\n    puVar4 = (undefined *)FUN_001da1c0(uVar3,(long)local_34,param_3,0);\n    xfree(uVar3);\n    if ((puVar4 == (undefined *)0x0 || puVar4 == PTR_rl_do_lowercase_version_00237fa0) ||\n       (uVar3 = 1, puVar4 == PTR_rl_vi_movement_mode_00237f08)) {\n      if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n        uVar3 = rl_generic_bind(0,param_1,param_2,param_3);\n        return uVar3;\n      }\n      goto LAB_001dbe6f;\n    }\n  }\n  else {\n    xfree(uVar3);\n    uVar3 = 0xffffffff;\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\nLAB_001dbe6f:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "sh_getopt_dispose_istate": "\nvoid sh_getopt_dispose_istate(undefined8 param_1)\n\n{\n  sh_xfree(param_1,\"getopt.c\",0xef);\n  return;\n}\n\n",
  "initialize_job_control": "\nint initialize_job_control(uint param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  int iVar3;\n  \n  shell_pgrp = getpgrp();\n  if (shell_pgrp == -1) {\n    sys_error(\"initialize_job_control: getpgrp failed\");\n                    /* WARNING: Subroutine does not return */\n    exit(1);\n  }\n  if ((param_1 | interactive) == 0) {\n    job_control = 0;\n    original_pgrp = -1;\n    shell_tty = fileno(stderr);\n    terminal_pgrp = tcgetpgrp(shell_tty);\n    iVar1 = shell_pgrp;\n    goto LAB_001664b2;\n  }\n  shell_tty = -1;\n  if (forced_interactive == 0) {\nLAB_0016634d:\n    iVar1 = fileno(stderr);\n    shell_tty = dup(iVar1);\n    if (shell_tty != -1) goto LAB_00166423;\n    shell_tty = -1;\n  }\n  else {\n    iVar1 = fileno(stderr);\n    iVar1 = isatty(iVar1);\n    if (iVar1 == 0) {\n      shell_tty = open(\"/dev/tty\",0x802);\n    }\n    if (shell_tty == -1) goto LAB_0016634d;\nLAB_00166423:\n    shell_tty = move_to_high_fd(shell_tty,1,0xffffffff);\n  }\n  if (shell_pgrp == 0) {\n    shell_pgrp = getpid();\n    setpgid(0,shell_pgrp);\n    if (shell_tty != -1) {\n      tcsetpgrp(shell_tty,shell_pgrp);\n    }\n  }\n  iVar1 = 0x12;\n  do {\n    terminal_pgrp = tcgetpgrp(shell_tty);\n    if (terminal_pgrp == -1) {\n      piVar2 = __errno_location();\n      iVar3 = *piVar2;\n      original_pgrp = shell_pgrp;\nLAB_00166595:\n      shell_pgrp = getpid();\n      if (shell_pgrp == original_pgrp) {\nLAB_001665b4:\n        job_control = 1;\nLAB_001665be:\n        iVar1 = tcgetpgrp(shell_tty);\n        if ((iVar1 == -1) || (shell_pgrp != iVar1)) {\n          if (iVar3 != -1) {\n            piVar2 = __errno_location();\n            *piVar2 = iVar3;\n          }\n          sys_error(0x1fe000,iVar1);\n          job_control = 0;\n        }\n        else if (job_control != 0) goto LAB_001664b2;\n      }\n      else {\n        iVar1 = setpgid(0,shell_pgrp);\n        if (iVar1 < 0) {\n          sys_error(\"initialize_job_control: setpgid\");\n          shell_pgrp = original_pgrp;\n          goto LAB_001665b4;\n        }\n        job_control = 1;\n        if ((shell_pgrp == original_pgrp) || (terminal_pgrp == shell_pgrp)) goto LAB_001665be;\n        iVar1 = give_terminal_to(shell_pgrp,0);\n        if (iVar1 < 0) {\n          piVar2 = __errno_location();\n          iVar1 = *piVar2;\n          setpgid(0,original_pgrp);\n          shell_pgrp = original_pgrp;\n          *piVar2 = iVar1;\n          sys_error(0x1fe000,shell_pgrp);\n          job_control = 0;\n        }\n        else if (job_control != 0) goto LAB_001665be;\n      }\n      internal_error(\"no job control in this shell\");\n      iVar1 = shell_pgrp;\n      goto LAB_001664b2;\n    }\n    if (shell_pgrp == terminal_pgrp) {\n      iVar3 = -1;\n      original_pgrp = terminal_pgrp;\n      goto LAB_00166595;\n    }\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    set_signal_handler(0x15,0);\n    kill(0,0x15);\n    set_signal_handler(0x15);\n    iVar1 = iVar1 + -1;\n  } while (iVar1 != 0);\n  sys_error(\"initialize_job_control: no job control in background\");\n  original_pgrp = terminal_pgrp;\n  job_control = 0;\n  iVar1 = shell_pgrp;\nLAB_001664b2:\n  running_in_background = (uint)(terminal_pgrp != iVar1);\n  iVar1 = fileno(stderr);\n  if (iVar1 != shell_tty) {\n    fcntl(shell_tty,2,1);\n  }\n  set_signal_handler(0x11,FUN_00162660);\n  change_flag(0x6d,(-(uint)(job_control == 0) & 0xfffffffe) + 0x2d);\n  if (interactive != 0) {\n    get_tty_state();\n  }\n  set_maxchild(0);\n  return job_control;\n}\n\n",
  "FUN_00131c76": "\nvoid FUN_00131c76(void)\n\n{\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n",
  "unquoted_glob_pattern_p": "\n/* WARNING: Removing unreachable block (ram,0x001848c4) */\n\nundefined8 unquoted_glob_pattern_p(char *param_1)\n\n{\n  char cVar1;\n  byte bVar2;\n  mbstate_t mVar3;\n  size_t sVar4;\n  undefined8 uVar5;\n  size_t sVar6;\n  ulong uVar7;\n  char *pcVar8;\n  char *pcVar9;\n  int iVar10;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar4 = strlen(param_1);\n  cVar1 = *param_1;\n  if (cVar1 != '\\0') {\n    iVar10 = 0;\n    pcVar8 = param_1;\n    pcVar9 = param_1 + 1;\n    do {\n      mVar3 = local_48;\n      if (cVar1 < 'A') {\n        if (' ' < cVar1) {\n          uVar7 = 1L << (cVar1 - 0x21U & 0x3f);\n          if ((uVar7 & 0x80000401) == 0) {\n            if ((uVar7 & 0x40000200) == 0) {\n              if (cVar1 != '/') goto LAB_00184778;\n              iVar10 = 0;\n              goto LAB_001847da;\n            }\n          }\n          else {\nLAB_001847da:\n            if (pcVar8[1] != '(') goto LAB_001847a5;\n          }\nLAB_001847e0:\n          uVar5 = 1;\n          goto LAB_001847e5;\n        }\n        if ((cVar1 == '\\x01') && (pcVar9 = pcVar8 + 2, pcVar8[1] == '\\0')) break;\nLAB_00184778:\n        pcVar8 = pcVar9 + -1;\n        if (((1 < locale_mb_cur_max) &&\n            (bVar2 = pcVar9[-1],\n            (*(uint *)(is_basic_table + (ulong)(bVar2 >> 5) * 4) >> (bVar2 & 0x1f) & 1) == 0)) &&\n           ((((locale_utf8locale == 0 || ((char)bVar2 < '\\0')) &&\n             (sVar6 = mbrtowc((wchar_t *)0x0,pcVar8,(size_t)(param_1 + (sVar4 - (long)pcVar8)),\n                              &local_48), sVar6 < 0xfffffffffffffffe)) &&\n            (mVar3 = local_48, sVar6 != 0)))) {\n          pcVar9 = pcVar8 + sVar6;\n        }\n      }\n      else if (cVar1 == '\\\\') {\n        cVar1 = pcVar8[1];\n        if ((cVar1 == '\\0') || ((cVar1 == '/' && (iVar10 == 0)))) {\n          if (cVar1 != '\\0') {\n            pcVar9 = pcVar8 + 2;\n            goto LAB_00184778;\n          }\n          break;\n        }\n        pcVar9 = pcVar8 + 2;\n      }\n      else if (cVar1 == ']') {\n        if (iVar10 != 0) goto LAB_001847e0;\n      }\n      else {\n        if (cVar1 != '[') goto LAB_00184778;\n        iVar10 = iVar10 + 1;\n      }\nLAB_001847a5:\n      local_48 = mVar3;\n      cVar1 = *pcVar9;\n      pcVar8 = pcVar9;\n      pcVar9 = pcVar9 + 1;\n    } while (cVar1 != '\\0');\n  }\n  uVar5 = 0;\nLAB_001847e5:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar5;\n}\n\n",
  "rl_check_signals": "\nvoid rl_check_signals(void)\n\n{\n  if (_rl_caught_signal == 0) {\n    return;\n  }\n  _rl_signal_handler(_rl_caught_signal);\n  return;\n}\n\n",
  "_rl_lowercase_p": "\nushort _rl_lowercase_p(uint param_1)\n\n{\n  ushort **ppuVar1;\n  \n  ppuVar1 = __ctype_b_loc();\n  return (*ppuVar1)[param_1 & 0xff] >> 9 & 1;\n}\n\n",
  "making_children": "\nvoid making_children(void)\n\n{\n  if (already_making_children != 0) {\n    return;\n  }\n  already_making_children = 1;\n  start_pipeline();\n  return;\n}\n\n",
  "FUN_001b8740": "\nint FUN_001b8740(char *param_1,byte *param_2,int param_3,int param_4,int param_5)\n\n{\n  byte *pbVar1;\n  bool bVar2;\n  int iVar3;\n  char *pcVar4;\n  byte bVar5;\n  ulong uVar6;\n  char cVar7;\n  byte *pbVar8;\n  ulong uVar9;\n  long in_FS_OFFSET;\n  int local_60;\n  int local_58;\n  int local_54;\n  ushort local_42;\n  long local_40;\n  \n  cVar7 = *param_1;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  pbVar8 = &DAT_00213d70;\n  if (param_2 != (byte *)0x0) {\n    pbVar8 = param_2;\n  }\n  if (cVar7 == '%') {\n    cVar7 = param_1[1];\n    param_1 = param_1 + 1;\n  }\n  bVar2 = false;\n  while( true ) {\n    pcVar4 = strchr(\"#\\'-+ 0\",(int)cVar7);\n    if (pcVar4 == (char *)0x0) break;\n    if (cVar7 == '-') {\n      bVar2 = true;\n    }\n    cVar7 = param_1[1];\n    param_1 = param_1 + 1;\n  }\n  local_58 = param_3;\n  if (cVar7 == '*') {\n    cVar7 = param_1[1];\n    param_1 = param_1 + 1;\n    local_60 = param_4;\n    if (-1 < param_4) goto joined_r0x001b8ab7;\n    local_60 = -param_4;\n    if (cVar7 == '.') {\n      bVar2 = true;\n      goto LAB_001b8abd;\n    }\n    param_3 = local_60 - param_3;\n    if (param_3 < 0) {\n      param_3 = 0;\n    }\n  }\n  else {\n    local_60 = 0;\n    if ((byte)(cVar7 - 0x30U) < 10) {\n      pcVar4 = param_1 + 1;\n      param_1 = param_1 + 1;\n      uVar6 = (ulong)(cVar7 + -0x30);\n      cVar7 = *pcVar4;\n      while ((byte)(cVar7 - 0x30U) < 10) {\n        param_1 = param_1 + 1;\n        uVar6 = (long)(char)(cVar7 + -0x30) + uVar6 * 10;\n        cVar7 = *param_1;\n      }\n      uVar9 = 0x7fffffff;\n      if (uVar6 < 0x80000000) {\n        uVar9 = uVar6;\n      }\n      local_60 = (int)uVar9;\n    }\njoined_r0x001b8ab7:\n    if (cVar7 == '.') {\nLAB_001b8abd:\n      if (param_1[1] == '*') {\nLAB_001b8b5a:\n        bVar5 = (byte)~(byte)((uint)param_5 >> 0x18) >> 7;\n        local_54 = param_5;\n      }\n      else {\n        bVar5 = param_1[1] - 0x30;\n        if (bVar5 < 10) {\n          pcVar4 = param_1 + 2;\n          uVar6 = (ulong)(char)bVar5;\n          cVar7 = param_1[2];\n          while ((byte)(cVar7 - 0x30U) < 10) {\n            pcVar4 = pcVar4 + 1;\n            uVar6 = (long)(char)(cVar7 + -0x30) + uVar6 * 10;\n            cVar7 = *pcVar4;\n          }\n          if (0x7fffffff < uVar6) {\n            uVar6 = 0x7fffffff;\n          }\n          local_54 = (int)uVar6;\n          if ((local_54 < param_5) && (param_5 != 0x7fffffff)) goto LAB_001b8b5a;\n          bVar5 = 1;\n        }\n        else {\n          local_54 = 0;\n          bVar5 = 1;\n        }\n      }\n      if ((local_54 <= param_3) && (local_58 = local_54, bVar5 == 0)) {\n        local_58 = param_3;\n      }\n    }\n    local_60 = local_60 - local_58;\n    param_3 = 0;\n    if (-1 < local_60) {\n      param_3 = local_60;\n    }\n    if (!bVar2) {\n      iVar3 = param_3;\n      if (0 < local_60) {\n        do {\n          while( true ) {\n            DAT_00248d80 = DAT_00248d80 + 1;\n            local_42 = 0x20;\n            if (DAT_00248dac != 0) break;\n            putc(0x20,stdout);\n            if (terminating_signal != 0) goto LAB_001b89e2;\nLAB_001b899a:\n            if (interrupt_state == 0) goto LAB_001b89a4;\nLAB_001b89f7:\n            throw_to_top_level();\n            iVar3 = iVar3 + -1;\n            if (iVar3 == 0) goto LAB_001b8a01;\n          }\n          FUN_001b86c0(&local_42);\n          if (terminating_signal == 0) goto LAB_001b899a;\nLAB_001b89e2:\n          termsig_handler(terminating_signal);\n          if (interrupt_state != 0) goto LAB_001b89f7;\nLAB_001b89a4:\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\nLAB_001b8a01:\n        iVar3 = 1;\n        if (0 < param_3) {\n          iVar3 = param_3;\n        }\n        param_3 = param_3 - iVar3;\n      }\n      goto LAB_001b8820;\n    }\n  }\n  param_3 = -param_3;\nLAB_001b8820:\n  if (0 < local_58) {\n    pbVar1 = pbVar8 + (ulong)(local_58 - 1) + 1;\n    do {\n      while( true ) {\n        DAT_00248d80 = DAT_00248d80 + 1;\n        local_42 = (ushort)*pbVar8;\n        if (DAT_00248dac != 0) break;\n        putc((int)(char)*pbVar8,stdout);\n        if (terminating_signal != 0) goto LAB_001b88a2;\nLAB_001b885a:\n        if (interrupt_state == 0) goto LAB_001b8864;\nLAB_001b88b7:\n        throw_to_top_level();\n        pbVar8 = pbVar8 + 1;\n        if (pbVar1 == pbVar8) goto LAB_001b88c5;\n      }\n      FUN_001b86c0(&local_42);\n      if (terminating_signal == 0) goto LAB_001b885a;\nLAB_001b88a2:\n      termsig_handler(terminating_signal);\n      if (interrupt_state != 0) goto LAB_001b88b7;\nLAB_001b8864:\n      pbVar8 = pbVar8 + 1;\n    } while (pbVar1 != pbVar8);\n  }\nLAB_001b88c5:\n  while (param_3 != 0) {\n    DAT_00248d80 = DAT_00248d80 + 1;\n    local_42 = 0x20;\n    if (DAT_00248dac == 0) {\n      putc(0x20,stdout);\n    }\n    else {\n      FUN_001b86c0(&local_42);\n    }\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state == 0) {\n      param_3 = param_3 + 1;\n    }\n    else {\n      throw_to_top_level();\n      param_3 = param_3 + 1;\n    }\n  }\n  iVar3 = ferror(stdout);\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return -(uint)(iVar3 != 0);\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "uinttostr": "\nvoid uinttostr(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  fmtumax(param_1,10,param_2,param_3,8);\n  return;\n}\n\n",
  "remove_backslashes": "\nvoid remove_backslashes(char *param_1)\n\n{\n  char cVar1;\n  size_t sVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  sVar2 = strlen(param_1);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"subst.c\",0xfef);\n  cVar1 = *param_1;\n  while (cVar1 != '\\0') {\n    pcVar4 = param_1 + (cVar1 == '\\\\');\n    if (*pcVar4 == '\\0') break;\n    param_1 = pcVar4 + 1;\n    *pcVar3 = *pcVar4;\n    pcVar3 = pcVar3 + 1;\n    cVar1 = pcVar4[1];\n  }\n  *pcVar3 = '\\0';\n  return;\n}\n\n",
  "rl_delete_text": "\nint rl_delete_text(int param_1,int param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  int iVar4;\n  \n  iVar4 = param_1;\n  if (param_2 < param_1) {\n    iVar4 = param_2;\n    param_2 = param_1;\n  }\n  if ((rl_end < param_2) && (param_2 = rl_end, rl_end < iVar4)) {\n    iVar4 = rl_end;\n  }\n  iVar1 = 0;\n  if (-1 < iVar4) {\n    iVar1 = iVar4;\n  }\n  uVar2 = rl_copy_text(iVar1,param_2);\n  iVar4 = param_2 - iVar1;\n  if (iVar1 < rl_end - iVar4) {\n    lVar3 = (long)iVar1;\n    do {\n      *(undefined *)(rl_line_buffer + lVar3) = *(undefined *)(rl_line_buffer + lVar3 + (long)iVar4);\n      lVar3 = lVar3 + 1;\n    } while ((int)lVar3 < rl_end - iVar4);\n  }\n  if (_rl_doing_an_undo == 0) {\n    rl_add_undo(0,iVar1,param_2);\n  }\n  else {\n    xfree(uVar2);\n  }\n  rl_end = rl_end - iVar4;\n  *(undefined *)(rl_line_buffer + rl_end) = 0;\n  if (rl_end < rl_mark) {\n    rl_mark = rl_end;\n  }\n  else if (rl_mark < 0) {\n    rl_mark = 0;\n    return iVar4;\n  }\n  return iVar4;\n}\n\n",
  "print_timeval": "\nint print_timeval(undefined8 param_1,long *param_2)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  long lVar4;\n  \n  lVar4 = *param_2;\n  iVar2 = (int)param_2[1] + (int)(param_2[1] / 1000000) * -1000000;\n  iVar3 = iVar2 / 1000;\n  if ((499 < iVar2 % 1000) && (iVar3 = iVar3 + 1, iVar3 == 1000)) {\n    lVar4 = lVar4 + 1;\n    iVar3 = 0;\n  }\n  uVar1 = locale_decpoint();\n  __fprintf_chk(param_1,1,\"%ldm%d%c%03ds\",lVar4 / 0x3c,(int)lVar4 + (int)(lVar4 / 0x3c) * -0x3c,\n                uVar1);\n  return iVar3;\n}\n\n",
  "reset_shell_options": "\nvoid reset_shell_options(void)\n\n{\n  pipefail_opt = 0;\n  ignoreeof = 0;\n  posixly_correct = 0;\n  dont_save_function_defs = 0;\n  enable_history_list = 1;\n  remember_on_history = 1;\n  return;\n}\n\n",
  "FUN_001da280": "\nundefined8 FUN_001da280(long param_1,int *param_2)\n\n{\n  byte bVar1;\n  char cVar2;\n  long lVar3;\n  int iVar4;\n  undefined8 uVar5;\n  \n  iVar4 = *param_2;\n  lVar3 = (long)iVar4;\n  bVar1 = *(byte *)(param_1 + lVar3);\n  if ((bVar1 == 0x3d) || (bVar1 == 0x21)) {\n    cVar2 = *(char *)(param_1 + 1 + lVar3);\n    if (bVar1 == 0x3d) {\n      uVar5 = 1;\n      iVar4 = iVar4 + 1 + (uint)(cVar2 == '=');\n      goto LAB_001da2c8;\n    }\n    if (cVar2 == '=') {\n      iVar4 = iVar4 + 2;\n      uVar5 = 2;\n      goto LAB_001da2c8;\n    }\n    if (bVar1 == 0x3c) goto LAB_001da2f9;\n  }\n  else {\n    if ((bVar1 & 0xfd) != 0x3c) {\n      return 0xffffffff;\n    }\n    cVar2 = *(char *)(param_1 + 1 + lVar3);\n    if (bVar1 == 0x3c) {\n      if (cVar2 == '=') {\n        iVar4 = iVar4 + 2;\n        uVar5 = 6;\n        goto LAB_001da2c8;\n      }\nLAB_001da2f9:\n      iVar4 = iVar4 + 1;\n      uVar5 = 5;\n      goto LAB_001da2c8;\n    }\n    if ((cVar2 == '=') && (bVar1 == 0x3e)) {\n      iVar4 = iVar4 + 2;\n      uVar5 = 4;\n      goto LAB_001da2c8;\n    }\n  }\n  uVar5 = 0xffffffff;\n  if (bVar1 == 0x3e) {\n    iVar4 = iVar4 + 1;\n    uVar5 = 3;\n  }\nLAB_001da2c8:\n  *param_2 = iVar4;\n  return uVar5;\n}\n\n",
  "array_create": "\nundefined8 * array_create(void)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar1 = (undefined8 *)sh_xmalloc(0x20,\"array.c\",0x56);\n  *puVar1 = 0xffffffffffffffff;\n  puVar1[1] = 0;\n  puVar1[3] = 0;\n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"array.c\",0x208);\n  *puVar2 = 0xffffffffffffffff;\n  puVar2[1] = 0;\n  puVar2[2] = puVar2;\n  puVar2[3] = puVar2;\n  puVar1[2] = puVar2;\n  return puVar1;\n}\n\n",
  "u32tochar": "\nundefined8 u32tochar(ulong param_1,uint *param_2)\n\n{\n  uint uVar1;\n  \n  if (param_1 < 0x100) {\n    *(char *)param_2 = (char)param_1;\n    *(undefined *)((long)param_2 + 1) = 0;\n    return 1;\n  }\n  if (param_1 < 0x10000) {\n    *(ushort *)param_2 = (ushort)param_1 << 8 | (ushort)param_1 >> 8;\n    *(undefined *)((long)param_2 + 2) = 0;\n    return 2;\n  }\n  uVar1 = (uint)param_1;\n  *param_2 = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\n  *(undefined *)(param_2 + 1) = 0;\n  return 4;\n}\n\n",
  "_rl_add_macro_char": "\nvoid _rl_add_macro_char(undefined param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  int iVar3;\n  \n  lVar2 = (long)DAT_0024b190;\n  iVar3 = DAT_0024b190 + 1;\n  if (DAT_0024b194 <= iVar3) {\n    if (DAT_0024b198 == 0) {\n      DAT_0024b194 = 0x19;\n      DAT_0024b198 = xmalloc(0x19);\n      lVar2 = (long)DAT_0024b190;\n      iVar3 = DAT_0024b190 + 1;\n    }\n    else {\n      DAT_0024b194 = DAT_0024b194 + 0x19;\n      DAT_0024b198 = xrealloc(DAT_0024b198,(long)DAT_0024b194);\n      lVar2 = (long)DAT_0024b190;\n      iVar3 = DAT_0024b190 + 1;\n    }\n  }\n  lVar1 = DAT_0024b198;\n  DAT_0024b190 = iVar3;\n  *(undefined *)(DAT_0024b198 + lVar2) = param_1;\n  *(undefined *)(lVar1 + iVar3) = 0;\n  return;\n}\n\n",
  "strstr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strstr(char *__haystack,char *__needle)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strstr_00237ea0)();\n  return pcVar1;\n}\n\n",
  "gather_here_documents": "\nvoid gather_here_documents(void)\n\n{\n  undefined8 *puVar1;\n  \n  here_doc_first_line = 1;\n  if (0 < need_here_doc) {\n    puVar1 = &DAT_00240dc0;\n    do {\n      parser_state = parser_state | 0x20000;\n      make_here_document(*puVar1,line_number);\n      *puVar1 = 0;\n      parser_state = parser_state & 0xfffdffff;\n      need_here_doc = need_here_doc + -1;\n      puVar1 = puVar1 + 1;\n    } while (0 < need_here_doc);\n    here_doc_first_line = 0;\n    return;\n  }\n  here_doc_first_line = 0;\n  return;\n}\n\n",
  "FUN_001513d0": "\nvoid FUN_001513d0(char **param_1,char **param_2)\n\n{\n  if (**param_1 == **param_2) {\n    strcmp(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "strsub": "\nchar * strsub(char *param_1,char *param_2,char *param_3,int param_4)\n\n{\n  char cVar1;\n  int iVar2;\n  size_t sVar3;\n  size_t sVar4;\n  char *pcVar5;\n  size_t sVar6;\n  char *pcVar7;\n  ulong uVar8;\n  ulong uVar9;\n  ulong uVar11;\n  long lVar12;\n  bool bVar13;\n  ulong uVar10;\n  \n  sVar3 = strlen(param_2);\n  sVar4 = strlen(param_3);\n  cVar1 = *param_1;\n  if (cVar1 != '\\0') {\n    pcVar5 = (char *)0x0;\n    lVar12 = 0;\n    uVar11 = 0;\n    bVar13 = true;\n    uVar8 = 0;\n    pcVar7 = param_1;\n    do {\n      while ((bVar13 &&\n             ((sVar3 == 0 ||\n              ((*param_2 == cVar1 && (iVar2 = strncmp(pcVar7,param_2,sVar3), iVar2 == 0))))))) {\n        if ((sVar4 != 0) && (uVar11 <= sVar4 + uVar8)) {\n          do {\n            uVar11 = uVar11 + sVar4 * 2;\n          } while (uVar11 <= sVar4 + uVar8);\n          pcVar5 = (char *)sh_xrealloc(pcVar5,uVar11,\"stringlib.c\",0xa0);\n        }\n        cVar1 = *param_3;\n        uVar9 = uVar8;\n        if (cVar1 != '\\0') {\n          uVar10 = uVar8;\n          do {\n            uVar9 = uVar10 + 1;\n            pcVar5[uVar10] = cVar1;\n            cVar1 = param_3[uVar9 - uVar8];\n            uVar10 = uVar9;\n          } while (cVar1 != '\\0');\n        }\n        sVar6 = 1;\n        if (sVar3 != 0) {\n          sVar6 = sVar3;\n        }\n        lVar12 = lVar12 + sVar6;\n        pcVar7 = param_1 + lVar12;\n        bVar13 = param_4 != 0;\n        cVar1 = *pcVar7;\n        uVar8 = uVar9;\n        if (cVar1 == '\\0') goto LAB_00199f20;\n      }\n      uVar9 = uVar8 + 1;\n      if (uVar11 <= uVar9) {\n        do {\n          uVar11 = uVar11 + 0x10;\n        } while (uVar11 <= uVar9);\n        pcVar5 = (char *)sh_xrealloc(pcVar5,uVar11,\"stringlib.c\",0xaa);\n      }\n      cVar1 = *pcVar7;\n      lVar12 = lVar12 + 1;\n      pcVar7 = param_1 + lVar12;\n      pcVar5[uVar8] = cVar1;\n      cVar1 = *pcVar7;\n      uVar8 = uVar9;\n    } while (cVar1 != '\\0');\nLAB_00199f20:\n    if (pcVar5 != (char *)0x0) {\n      pcVar5[uVar9] = '\\0';\n      return pcVar5;\n    }\n  }\n  sVar3 = strlen(param_1);\n  pcVar7 = (char *)sh_xmalloc(sVar3 + 1,\"stringlib.c\",0xb1);\n  pcVar7 = strcpy(pcVar7,param_1);\n  return pcVar7;\n}\n\n",
  "locale_decpoint": "\nint locale_decpoint(void)\n\n{\n  char cVar1;\n  int iVar2;\n  lconv *plVar3;\n  \n  plVar3 = localeconv();\n  if ((plVar3 != (lconv *)0x0) && (plVar3->decimal_point != (char *)0x0)) {\n    cVar1 = *plVar3->decimal_point;\n    iVar2 = (int)cVar1;\n    if (cVar1 == '\\0') {\n      iVar2 = 0x2e;\n    }\n    return iVar2;\n  }\n  return 0x2e;\n}\n\n",
  "top_level_cleanup": "\nvoid top_level_cleanup(void)\n\n{\n  if (parse_and_execute_level != 0) {\n    do {\n      parse_and_execute_cleanup(0xffffffff);\n    } while (parse_and_execute_level != 0);\n  }\n  unlink_fifo_list();\n  run_unwind_protects();\n  funcnest = 0;\n  breaking = 0;\n  continuing = 0;\n  loop_level = 0;\n  wait_intr_flag = 0;\n  return_catch_flag = 0;\n  comsub_ignore_return = 0;\n  executing_list = 0;\n  return;\n}\n\n",
  "_rl_standout_off": "\nvoid _rl_standout_off(void)\n\n{\n  if ((DAT_0024b640 != 0) && (DAT_0024b638 != 0)) {\n    tputs(DAT_0024b638,1,_rl_output_character_function);\n    return;\n  }\n  return;\n}\n\n",
  "rl_unbind_command_in_map": "\nundefined8 rl_unbind_command_in_map(char *param_1,undefined8 param_2)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 *puVar4;\n  \n  rl_initialize_funmap();\n  ppcVar1 = (char **)*funmap;\n  puVar4 = funmap;\n  while( true ) {\n    if (ppcVar1 == (char **)0x0) {\n      return 0;\n    }\n    puVar4 = puVar4 + 1;\n    iVar2 = strcasecmp(*ppcVar1,param_1);\n    if (iVar2 == 0) break;\n    ppcVar1 = (char **)*puVar4;\n  }\n  if (ppcVar1[1] == (char *)0x0) {\n    return 0;\n  }\n  uVar3 = rl_unbind_function_in_map(ppcVar1[1],param_2);\n  return uVar3;\n}\n\n",
  "shtimer_alrm": "\nundefined8 shtimer_alrm(void)\n\n{\n  return 0;\n}\n\n",
  "FUN_00187050": "\nvoid FUN_00187050(void)\n\n{\n  byte bVar1;\n  int iVar2;\n  byte *pbVar3;\n  \n  pbVar3 = *(byte **)(DAT_00248560 + ((long)DAT_0024856c + 1) * 8);\n  bVar1 = *pbVar3;\n  if (bVar1 == 0x3d) {\n    bVar1 = pbVar3[1];\n    if (bVar1 == 0) goto LAB_001870b7;\njoined_r0x001870fa:\n    if (bVar1 != 0x3d) goto LAB_00187089;\n    bVar1 = pbVar3[2];\n  }\n  else {\n    if ((bVar1 & 0xfd) != 0x3c) {\n      if (bVar1 != 0x21) {\n        if (((bVar1 == 0x2d) && (pbVar3[3] == 0)) && (iVar2 = test_binop(), iVar2 != 0))\n        goto LAB_001870b7;\n        goto LAB_00187089;\n      }\n      bVar1 = pbVar3[1];\n      goto joined_r0x001870fa;\n    }\n    bVar1 = pbVar3[1];\n  }\n  if (bVar1 == 0) {\nLAB_001870b7:\n    binary_test();\n    DAT_0024856c = DAT_0024856c + 3;\n    return;\n  }\nLAB_00187089:\n                    /* WARNING: Subroutine does not return */\n  FUN_00186410(\"%s: binary operator expected\",pbVar3);\n}\n\n",
  "FUN_0013d3a0": "\nvoid FUN_0013d3a0(void)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  \nLAB_0013d3a8:\n  iVar2 = DAT_00240b58;\n  if (DAT_00240b58 != 0) goto LAB_0013d400;\n  do {\n    DAT_00240b38 = FUN_0013a230();\n    while( true ) {\n      if (DAT_00240b38 != 10) {\n        return;\n      }\n      if (((interactive == 0) || (1 < bash_input - 1U)) ||\n         ((pushed_string_list != 0 && (*(long *)(pushed_string_list + 0x18) != 0))))\n      goto LAB_0013d3a8;\n      FUN_001373e0();\n      iVar2 = DAT_00240b58;\n      if (DAT_00240b58 == 0) break;\nLAB_0013d400:\n      uVar1 = DAT_00240b50;\n      if (iVar2 - 0x119U < 2) {\n        DAT_00240b50 = 0;\n        yylval = uVar1;\n      }\n      DAT_00240b58 = 0;\n      DAT_00240b38 = iVar2;\n    }\n  } while( true );\n}\n\n",
  "FUN_00191510": "\nvoid FUN_00191510(undefined8 param_1,int param_2)\n\n{\n  if (param_2 == 0) {\n    DAT_00248808 = 0;\n  }\n  if ((DAT_00248988 != 0) && (*(long *)(DAT_00248988 + (long)DAT_00248808 * 8) != 0)) {\n    DAT_00248808 = DAT_00248808 + 1;\n  }\n  return;\n}\n\n",
  "string_list_internal": "\nchar * string_list_internal(long **param_1,char *param_2)\n\n{\n  size_t sVar1;\n  long lVar2;\n  long **pplVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char *pcVar6;\n  char *local_40;\n  \n  if (param_1 == (long **)0x0) {\n    local_40 = (char *)0x0;\n  }\n  else {\n    if (*param_1 == (long *)0x0) {\n      pcVar6 = (char *)*param_1[1];\n      sVar4 = strlen(pcVar6);\n      pcVar5 = (char *)sh_xmalloc(sVar4 + 1,\"subst.c\",0xaf7);\n      pcVar6 = strcpy(pcVar5,pcVar6);\n      return pcVar6;\n    }\n    sVar4 = 0;\n    if ((((param_2 != (char *)0x0) && (*param_2 != '\\0')) && (sVar4 = 1, param_2[1] != '\\0')) &&\n       (sVar4 = 2, param_2[2] != '\\0')) {\n      sVar4 = strlen(param_2);\n    }\n    lVar2 = 0;\n    pplVar3 = param_1;\n    while( true ) {\n      sVar1 = strlen((char *)*pplVar3[1]);\n      pplVar3 = (long **)*pplVar3;\n      lVar2 = lVar2 + sVar1;\n      if (pplVar3 == (long **)0x0) break;\n      if (param_1 != pplVar3) {\n        lVar2 = lVar2 + sVar4;\n      }\n    }\n    local_40 = (char *)sh_xmalloc(lVar2 + 1,\"subst.c\",0xb04);\n    pplVar3 = param_1;\n    pcVar6 = local_40;\n    while( true ) {\n      pcVar5 = (char *)*pplVar3[1];\n      sVar1 = strlen(pcVar5);\n      memcpy(pcVar6,pcVar5,sVar1);\n      pplVar3 = (long **)*pplVar3;\n      pcVar5 = pcVar6 + sVar1;\n      if (pplVar3 == (long **)0x0) break;\n      pcVar6 = pcVar5;\n      if ((param_1 != pplVar3) && (sVar4 != 0)) {\n        if (sVar4 == 1) {\n          pcVar6 = pcVar5 + 1;\n          *pcVar5 = *param_2;\n        }\n        else {\n          pcVar6 = pcVar5 + sVar4;\n          memcpy(pcVar5,param_2,sVar4);\n        }\n      }\n    }\n    *pcVar5 = '\\0';\n  }\n  return local_40;\n}\n\n",
  "FUN_001d6140": "\nchar * FUN_001d6140(char *param_1)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(param_1,0x2f);\n  if ((pcVar1 != (char *)0x0) && (*pcVar1 != '\\0')) {\n    if (pcVar1[1] == '\\0') {\n      if (param_1 == pcVar1) {\n        return param_1;\n      }\n      pcVar1 = pcVar1 + -1;\n      if (param_1 < pcVar1) {\n        do {\n          if (*pcVar1 == '/') goto LAB_001d617e;\n          pcVar1 = pcVar1 + -1;\n        } while (param_1 != pcVar1);\n      }\n      if (*pcVar1 != '/') {\n        return param_1;\n      }\n    }\nLAB_001d617e:\n    param_1 = pcVar1 + 1;\n  }\n  return param_1;\n}\n\n",
  "make_while_command": "\nvoid make_while_command(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined4 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x18,\"make_cmd.c\",0x195);\n  *(undefined8 *)(puVar1 + 2) = param_1;\n  *(undefined8 *)(puVar1 + 4) = param_2;\n  *puVar1 = 0;\n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar2[3] = puVar1;\n  *puVar2 = 2;\n  *puVar1 = 0;\n  puVar2[2] = 0;\n  return;\n}\n\n",
  "rl_show_char": "\nint rl_show_char(uint param_1)\n\n{\n  ushort **ppuVar1;\n  __int32_t **pp_Var2;\n  ulong uVar3;\n  int iVar4;\n  \n  iVar4 = 1;\n  if (param_1 - 0x80 < 0x80) {\n    if (_rl_output_meta_chars != 0) goto LAB_001e1e2d;\n    param_1 = param_1 & 0xffffff7f;\n    iVar4 = 3;\n    fwrite(&DAT_0021391a,1,2,rl_outstream);\n    if ((int)param_1 < 0x20) goto LAB_001e1e5f;\n  }\n  else if ((int)param_1 < 0x20) {\n    if ((param_1 & 0x80) != 0) goto LAB_001e1e2d;\nLAB_001e1e5f:\n    if (param_1 != 9) {\n      iVar4 = iVar4 + 2;\n      fwrite(&DAT_0021391d,1,2,rl_outstream);\n      uVar3 = (ulong)(param_1 & 0xff | 0x40);\n      ppuVar1 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar1 + uVar3 * 2 + 1) & 2) == 0) {\n        param_1 = param_1 | 0x40;\n      }\n      else {\n        pp_Var2 = __ctype_toupper_loc();\n        param_1 = (*pp_Var2)[uVar3];\n      }\n    }\n    goto LAB_001e1e2d;\n  }\n  if (param_1 == 0x7f) {\n    iVar4 = iVar4 + 2;\n    param_1 = 0x3f;\n    fwrite(&DAT_0021391d,1,2,rl_outstream);\n  }\nLAB_001e1e2d:\n  putc(param_1,rl_outstream);\n  fflush(rl_outstream);\n  return iVar4;\n}\n\n",
  "rl_noninc_forward_search_again": "\nbool rl_noninc_forward_search_again(undefined8 param_1,int param_2)\n\n{\n  int iVar1;\n  bool bVar2;\n  \n  if (DAT_0024a480 == 0) {\n    rl_ding();\n    bVar2 = true;\n  }\n  else {\n    if (((rl_editing_mode == 0) && (_rl_keymap == vi_movement_keymap)) && (param_2 == 0x4e)) {\n      iVar1 = FUN_001d4610(DAT_0024a480,1,0x10);\n    }\n    else {\n      iVar1 = FUN_001d4610(DAT_0024a480,1,0);\n    }\n    bVar2 = iVar1 != 1;\n  }\n  return bVar2;\n}\n\n",
  "filter_stringlist": "\nlong * filter_stringlist(long *param_1)\n\n{\n  long *plVar1;\n  \n  if (((param_1 != (long *)0x0) && (*param_1 != 0)) && (*(int *)((long)param_1 + 0xc) != 0)) {\n    plVar1 = (long *)FUN_0019ed40();\n    return plVar1;\n  }\n  return param_1;\n}\n\n",
  "FUN_001931e0": "\nundefined4 FUN_001931e0(undefined4 param_1,undefined4 param_2,int param_3,char *param_4)\n\n{\n  undefined8 uVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  char *pcVar4;\n  char *pcVar5;\n  long in_FS_OFFSET;\n  bool bVar6;\n  undefined auStack_148 [264];\n  long local_40;\n  \n  uVar1 = rl_readline_state;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  saved_command_line_count = current_command_line_count;\n  rl_newline(1);\n  if (rl_explicit_arg == 0) {\n    using_history();\n    current_command_line_count = current_command_line_count + 1;\n    bash_add_history(rl_line_buffer);\n    current_command_line_count = 0;\n    bash_add_history(&DAT_00213d70);\n    history_lines_this_session = history_lines_this_session + 1;\n    using_history();\n    sVar3 = strlen(param_4);\n    pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"bashline.c\",0x3d2);\n    pcVar4 = strcpy(pcVar4,param_4);\n  }\n  else {\n    sVar3 = strlen(param_4);\n    pcVar4 = (char *)sh_xmalloc(sVar3 + 8,\"bashline.c\",0x3c0);\n    __sprintf_chk(pcVar4,1,0xffffffffffffffff,\"%s %d\",param_4,param_1);\n  }\n  bVar6 = false;\n  pcVar5 = (char *)rl_variable_value(\"input-meta\");\n  if ((*pcVar5 == 'o') && (pcVar5[1] == 'n')) {\n    bVar6 = pcVar5[2] == '\\0';\n  }\n  if (rl_deprep_term_function != (undefined *)0x0) {\n    (*(code *)rl_deprep_term_function)();\n  }\n  rl_clear_signals();\n  save_parser_state(auStack_148);\n  pcVar5 = \"v\";\n  if (param_3 != 0) {\n    pcVar5 = \"C-xC-e\";\n  }\n  uVar2 = parse_and_execute(pcVar4,pcVar5,4);\n  restore_parser_state(auStack_148);\n  reset_readahead_token();\n  if (rl_prep_term_function != (undefined *)0x0) {\n    (*(code *)rl_prep_term_function)(bVar6);\n  }\n  rl_set_signals();\n  rl_readline_state = (long)(int)uVar1;\n  current_command_line_count = saved_command_line_count;\n  *rl_line_buffer = 0;\n  rl_end = 0;\n  rl_point = 0;\n  rl_done = 0;\n  if (param_3 == 0) {\n    rl_vi_insertion_mode(1,param_2);\n  }\n  rl_forced_update_display();\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "bash_execute_unix_command": "\nundefined8 bash_execute_unix_command(int param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  long lVar5;\n  size_t sVar6;\n  char *__dest;\n  long lVar7;\n  long in_FS_OFFSET;\n  int local_164;\n  undefined4 local_160 [2];\n  undefined local_158 [268];\n  undefined local_4c [12];\n  long local_40;\n  \n  lVar5 = rl_executing_keyseq;\n  lVar7 = (long)rl_key_sequence_length;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((1 < param_1) || (rl_explicit_arg != 0)) {\n    uVar3 = rl_get_keymap();\n    iVar1 = rl_trim_arg_from_keyseq(rl_executing_keyseq,(long)rl_key_sequence_length,uVar3);\n    if (0 < iVar1) {\n      lVar5 = iVar1 + rl_executing_keyseq;\n      lVar7 = (long)(rl_key_sequence_length - iVar1);\n    }\n  }\n  uVar3 = rl_get_keymap();\n  uVar3 = FUN_001944d0(uVar3);\n  pcVar4 = (char *)rl_function_of_keyseq_len(lVar5,lVar7,uVar3,&local_164);\n  if (local_164 == 1) {\n    local_164 = (int)pcVar4[0x1000];\n    if ((local_164 == 2) && (pcVar4 = *(char **)(pcVar4 + 0x1008), pcVar4 != (char *)0x0))\n    goto LAB_001947ac;\n  }\n  else if ((pcVar4 != (char *)0x0) && (local_164 == 2)) {\nLAB_001947ac:\n    lVar5 = rl_get_termcap(\"ce\");\n    if (lVar5 == 0) {\n      rl_crlf();\n    }\n    else {\n      rl_clear_visible_line();\n      fflush(rl_outstream);\n    }\n    lVar7 = bind_variable(\"READLINE_LINE\",rl_line_buffer,0);\n    if (lVar7 != 0) {\n      *(uint *)(lVar7 + 0x28) = *(uint *)(lVar7 + 0x28) | 1;\n    }\n    lVar7 = (long)rl_point;\n    if (1 < locale_mb_cur_max) {\n      iVar1 = FUN_001945d0(lVar7);\n      lVar7 = (long)iVar1;\n    }\n    uVar3 = inttostr(lVar7,local_4c,0xc);\n    lVar7 = bind_int_variable(\"READLINE_POINT\",uVar3,0);\n    if (lVar7 != 0) {\n      *(uint *)(lVar7 + 0x28) = *(uint *)(lVar7 + 0x28) | 1;\n    }\n    lVar7 = (long)rl_mark;\n    if (1 < locale_mb_cur_max) {\n      iVar1 = FUN_001945d0(lVar7);\n      lVar7 = (long)iVar1;\n    }\n    uVar3 = inttostr(lVar7,local_4c,0xc);\n    lVar7 = bind_int_variable(\"READLINE_MARK\",uVar3,0);\n    if (lVar7 != 0) {\n      *(uint *)(lVar7 + 0x28) = *(uint *)(lVar7 + 0x28) | 1;\n    }\n    if ((1 < param_1) || (rl_explicit_arg != 0)) {\n      uVar3 = inttostr((long)param_1,local_4c,0xc);\n      lVar7 = bind_int_variable(\"READLINE_ARGUMENT\",uVar3,0);\n      if (lVar7 != 0) {\n        *(uint *)(lVar7 + 0x28) = *(uint *)(lVar7 + 0x28) | 1;\n      }\n    }\n    array_needs_making = 1;\n    save_parser_state(local_158);\n    rl_clear_signals();\n    sVar6 = strlen(pcVar4);\n    __dest = (char *)sh_xmalloc(sVar6 + 1,\"bashline.c\",0x11a9);\n    pcVar4 = strcpy(__dest,pcVar4);\n    iVar1 = parse_and_execute(pcVar4,\"bash_execute_unix_command\",4);\n    rl_set_signals();\n    restore_parser_state(local_158);\n    lVar7 = find_variable(\"READLINE_LINE\");\n    if (((lVar7 != 0) && (pcVar4 = *(char **)(lVar7 + 8), pcVar4 != (char *)0x0)) &&\n       (iVar2 = strcmp(pcVar4,rl_line_buffer), iVar2 != 0)) {\n      FUN_00194330(pcVar4);\n    }\n    lVar7 = find_variable(\"READLINE_POINT\");\n    if ((lVar7 != 0) && (iVar2 = legal_number(*(undefined8 *)(lVar7 + 8),local_160), iVar2 != 0)) {\n      FUN_00193570(local_160[0],&rl_point);\n    }\n    lVar7 = find_variable(\"READLINE_MARK\");\n    if ((lVar7 != 0) && (iVar2 = legal_number(*(undefined8 *)(lVar7 + 8),local_160), iVar2 != 0)) {\n      FUN_00193570(local_160[0],&rl_mark);\n    }\n    check_unbind_variable(\"READLINE_LINE\");\n    check_unbind_variable(\"READLINE_POINT\");\n    check_unbind_variable(\"READLINE_MARK\");\n    check_unbind_variable(\"READLINE_ARGUMENT\");\n    array_needs_making = 1;\n    if ((lVar5 == 0) || (iVar1 == 0x7c)) {\n      rl_forced_update_display();\n      uVar3 = 0;\n    }\n    else {\n      rl_redraw_prompt_last_line();\n      uVar3 = 0;\n    }\n    goto LAB_0019471a;\n  }\n  rl_crlf();\n  internal_error(\"bash_execute_unix_command: cannot find keymap for command\");\n  rl_forced_update_display();\n  uVar3 = 1;\nLAB_0019471a:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
  "array_remove": "\nlong * array_remove(long *param_1,long param_2)\n\n{\n  long lVar1;\n  long lVar2;\n  long *plVar3;\n  long *plVar4;\n  int iVar5;\n  long *plVar6;\n  long lVar7;\n  \n  if (((param_1 == (long *)0x0) || (lVar1 = param_1[1], lVar1 == 0)) ||\n     (lVar2 = *param_1, lVar2 < param_2)) {\n    return (long *)0x0;\n  }\n  plVar3 = (long *)param_1[2];\n  plVar4 = (long *)plVar3[2];\n  if (param_2 < *plVar4) {\n    return (long *)0x0;\n  }\n  plVar6 = (long *)param_1[3];\n  if (plVar6 == (long *)0x0) {\n    iVar5 = 1;\n    lVar7 = *plVar4 / 2;\n  }\n  else {\n    lVar7 = *plVar6;\n    iVar5 = 1;\n    if (param_2 < lVar7 / 2) goto LAB_001891b0;\n    iVar5 = -1;\n    plVar4 = plVar6;\n  }\n  if (lVar7 <= param_2) {\n    iVar5 = 1;\n  }\nLAB_001891b0:\n  while( true ) {\n    if (plVar3 == plVar4) {\n      return (long *)0x0;\n    }\n    if (*plVar4 == param_2) break;\n    if (iVar5 == 1) {\n      plVar4 = (long *)plVar4[2];\n      if (*plVar4 != param_2 && param_2 <= *plVar4) {\n        return (long *)0x0;\n      }\n    }\n    else {\n      plVar4 = (long *)plVar4[3];\n      if ((iVar5 == -1) && (*plVar4 < param_2)) {\n        return (long *)0x0;\n      }\n    }\n  }\n  lVar7 = plVar4[2];\n  plVar6 = (long *)plVar4[3];\n  *(long **)(lVar7 + 0x18) = plVar6;\n  plVar6[2] = lVar7;\n  param_1[1] = lVar1 + -1;\n  if (lVar2 == param_2) {\n    *param_1 = *plVar6;\n  }\n  if (plVar3 == (long *)plVar4[2]) {\n    if (plVar3 == plVar6) {\n      plVar6 = (long *)0x0;\n    }\n    param_1[3] = (long)plVar6;\n    return plVar4;\n  }\n  param_1[3] = (long)(long *)plVar4[2];\n  return plVar4;\n}\n\n",
  "_rl_any_typein": "\nbool _rl_any_typein(void)\n\n{\n  return DAT_0024b3e0 != DAT_0024b3e4;\n}\n\n",
  "dispose_function_def_contents": "\nvoid dispose_function_def_contents(long param_1)\n\n{\n  dispose_word(*(undefined8 *)(param_1 + 8));\n  dispose_command(*(undefined8 *)(param_1 + 0x10));\n  if (*(long *)(param_1 + 0x18) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x18),\"dispose_cmd.c\",0xe9);\n    return;\n  }\n  return;\n}\n\n",
  "history_delimiting_chars": "\nundefined * history_delimiting_chars(char *param_1)\n\n{\n  uint uVar1;\n  long lVar2;\n  int iVar3;\n  int iVar4;\n  char *pcVar5;\n  long lVar6;\n  char cVar7;\n  int *piVar8;\n  \n  iVar4 = DAT_00240d6c;\n  uVar1 = parser_state;\n  if ((parser_state & 0x20000) != 0) {\n    if (DAT_00240a18 == 0) {\n      if (DAT_00240ae8 != 0) {\n        DAT_00240ae8 = 0;\n        return &DAT_001ff6d2;\n      }\n      if (here_doc_first_line != 0) goto LAB_00136638;\n      goto LAB_001365f8;\n    }\n    goto LAB_00136638;\n  }\n  DAT_00240ae8 = 0;\n  if (DAT_00240a18 != 0) goto LAB_00136638;\n  if ((parser_state & 0x2000) != 0) {\n    DAT_00240ae8 = 0;\n    return &DAT_001fdb1c;\n  }\n  if (DAT_00240d6c == 0x29) {\n    if (DAT_00240d68 == 0x28) {\n      DAT_00240ae8 = 0;\n      return &DAT_001fdb1c;\n    }\n    if ((parser_state & 0x80) != 0) {\n      DAT_00240ae8 = 0;\n      return &DAT_001fdb1c;\n    }\n    goto LAB_00136681;\n  }\n  if (DAT_00240d6c == 0x119) {\n    if (DAT_00240d68 == 0x10f) {\n      DAT_00240ae8 = 0;\n      return &DAT_001fdb1c;\n    }\n    if (1 < current_command_line_count) goto LAB_00136558;\nLAB_0013657b:\n    if (DAT_00240d68 == 0x109) {\n      lVar6 = (long)(int)DAT_00240da0;\n      cVar7 = *(char *)(DAT_00240da8 + lVar6);\n      if ((cVar7 == '\\t') || (cVar7 == ' ')) {\n        lVar2 = (long)((int)DAT_00240da0 + 1);\n        do {\n          do {\n            lVar6 = lVar2;\n            cVar7 = *(char *)(DAT_00240da8 + lVar6);\n            lVar2 = lVar6 + 1;\n          } while (cVar7 == ' ');\n        } while (cVar7 == '\\t');\n      }\n      if (cVar7 != 'i') {\n        return &DAT_001fab1e;\n      }\n      if (*(char *)(DAT_00240da8 + 1 + lVar6) != 'n') {\n        return &DAT_001fab1e;\n      }\n      return &DAT_001fdb1c;\n    }\n    if ((DAT_00240d68 == 0x107) && ((uVar1 & 0x80) != 0)) {\n      return &DAT_001fdb1c;\n    }\n  }\n  else if (1 < current_command_line_count) {\nLAB_00136558:\n    if ((DAT_00240d70 == 10) && (pcVar5 = strstr(param_1,\"<<\"), pcVar5 != (char *)0x0)) {\n      DAT_00240ae8 = 1;\nLAB_00136638:\n      return &DAT_001ff6d2;\n    }\n    if (0 < need_here_doc) goto LAB_00136638;\n    if (iVar4 == 0x119) goto LAB_0013657b;\n  }\n  piVar8 = &DAT_001fb004;\n  iVar3 = 10;\n  do {\n    if (iVar4 == iVar3) {\n      return &DAT_001fdb1c;\n    }\n    iVar3 = *piVar8;\n    piVar8 = piVar8 + 1;\n  } while (iVar3 != 0);\n  iVar4 = line_isblank(param_1);\n  if (iVar4 != 0) {\n    if (current_command_line_count < 2) {\n      return &DAT_00213d70;\n    }\n    if (DAT_00240d70 != 10) {\n      return &DAT_00213d70;\n    }\n    if (DAT_00240d6c == 10) {\nLAB_001365f8:\n      return &DAT_00213d70;\n    }\n  }\nLAB_00136681:\n  return &DAT_001faa24;\n}\n\n",
  "FUN_001513a0": "\nvoid FUN_001513a0(undefined8 *param_1,undefined8 *param_2)\n\n{\n  if (**(char **)*param_1 == **(char **)*param_2) {\n    strcmp(*(char **)*param_1,*(char **)*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001d33a0": "\nundefined8 FUN_001d33a0(int param_1,undefined4 param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  size_t sVar2;\n  \n  if (param_1 != 0) {\n    do {\n      while( true ) {\n        iVar1 = rl_point;\n        if (rl_end <= rl_point) goto LAB_001d3445;\n        rl_vi_delete(1,param_2);\n        if ((rl_point < iVar1) && (rl_point < rl_end)) {\n          sVar2 = __ctype_get_mb_cur_max();\n          iVar1 = rl_point;\n          if ((sVar2 == 1) || (rl_byte_oriented != 0)) {\n            rl_point = rl_point + 1;\n          }\n          else {\n            rl_point = _rl_forward_char_internal(1);\n            if ((iVar1 == rl_point) || (rl_end < rl_point)) {\n              rl_point = rl_end;\n            }\n          }\n        }\n        sVar2 = __ctype_get_mb_cur_max();\n        if ((1 < sVar2) && (rl_byte_oriented == 0)) break;\n        _rl_insert_char(1,param_2);\n        param_1 = param_1 + -1;\n        if (param_1 == 0) goto LAB_001d3445;\n      }\n      rl_insert_text(param_3);\n      param_1 = param_1 + -1;\n    } while (param_1 != 0);\n  }\nLAB_001d3445:\n  rl_backward_char(1,param_2);\n  rl_end_undo_group();\n  return 0;\n}\n\n",
  "clearerr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid clearerr(FILE *__stream)\n\n{\n  (*(code *)PTR_clearerr_00237b60)();\n  return;\n}\n\n",
  "bash_delete_last_history": "\nbool bash_delete_last_history(void)\n\n{\n  int iVar1;\n  long *plVar2;\n  long lVar3;\n  \n  plVar2 = (long *)history_list();\n  if (plVar2 != (long *)0x0) {\n    if (*plVar2 == 0) {\n      iVar1 = -1;\n    }\n    else {\n      lVar3 = 0;\n      do {\n        iVar1 = (int)lVar3;\n        lVar3 = lVar3 + 1;\n      } while (plVar2[lVar3] != 0);\n    }\n    lVar3 = history_get(history_base + iVar1);\n    if (lVar3 != 0) {\n      lVar3 = remove_history(iVar1);\n      if (lVar3 != 0) {\n        free_history_entry(lVar3);\n        history_lines_this_session = history_lines_this_session + -1;\n      }\n      iVar1 = where_history();\n      if (iVar1 <= history_length) {\n        return lVar3 != 0;\n      }\n      history_set_pos();\n      return lVar3 != 0;\n    }\n  }\n  return false;\n}\n\n",
  "compspec_dispose": "\nvoid compspec_dispose(int *param_1)\n\n{\n  *param_1 = *param_1 + -1;\n  if (*param_1 == 0) {\n    FUN_001a1120();\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001a3a10": "\nvoid FUN_001a3a10(char **param_1,char **param_2)\n\n{\n  if (**param_1 == **param_2) {\n    strcmp(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00177e80": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong * FUN_00177e80(byte **param_1,uint param_2,uint param_3,undefined4 *param_4,int *param_5)\n\n{\n  bool bVar1;\n  bool bVar2;\n  mbstate_t mVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  int iVar8;\n  undefined2 *puVar9;\n  size_t sVar10;\n  ulong uVar11;\n  undefined *puVar12;\n  byte **ppbVar13;\n  byte *pbVar14;\n  char *pcVar15;\n  undefined8 uVar16;\n  undefined8 *puVar17;\n  long *plVar18;\n  char *pcVar19;\n  char **ppcVar20;\n  undefined2 *puVar21;\n  uint uVar22;\n  size_t sVar23;\n  uint uVar24;\n  uint uVar25;\n  undefined8 uVar26;\n  byte *pbVar27;\n  ulong uVar28;\n  char cVar29;\n  byte *pbVar30;\n  long lVar31;\n  ulong uVar32;\n  ulong uVar33;\n  ulong uVar34;\n  ulong uVar35;\n  char cVar36;\n  long lVar37;\n  long lVar38;\n  ulong uVar39;\n  long in_FS_OFFSET;\n  undefined uVar40;\n  byte bVar41;\n  char local_d8;\n  uint local_c8;\n  int local_c4;\n  byte *local_b8;\n  uint local_a8;\n  size_t local_98;\n  int local_90;\n  uint local_8c;\n  uint local_5c;\n  uint local_58;\n  int local_54;\n  int local_50;\n  uint local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  bVar41 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  if ((((**param_1 == 0x22) && (iVar5 = strcmp((char *)*param_1,\"\\\"$@\\\"\"), iVar5 == 0)) &&\n      (*(int *)(param_1 + 1) == 3)) && (DAT_00242228 != 0)) {\n    if (param_4 != (undefined4 *)0x0) {\n      *param_4 = 1;\n    }\n    if (param_5 != (int *)0x0) {\n      *param_5 = 1;\n    }\n    if (DAT_00247890 == 0) {\n      uVar26 = list_rest_of_args();\n      plVar18 = (long *)FUN_00170510(uVar26);\n      DAT_00247890 = copy_word_list(plVar18);\n    }\n    else {\n      plVar18 = (long *)copy_word_list();\n    }\n    goto LAB_00178af0;\n  }\n  puVar9 = (undefined2 *)sh_xmalloc(0x70,\"subst.c\",0x2aec);\n  *(undefined *)puVar9 = 0;\n  local_54 = 0;\n  local_58 = 0;\n  pbVar30 = *param_1;\n  if (pbVar30 != (byte *)0x0) {\n    sVar10 = __ctype_get_mb_cur_max();\n    local_98 = 1;\n    iVar5 = (int)sVar10;\n    if (1 < iVar5) {\n      local_98 = strlen((char *)pbVar30);\n    }\n    if (param_4 != (undefined4 *)0x0) {\n      *param_4 = 0;\n    }\n    local_8c = 0xffffffff;\n    uVar28 = 0x70;\n    local_a8 = 0;\n    bVar1 = false;\n    local_c8 = 0;\n    local_90 = 0;\n    uVar24 = 0x80;\n    if ((param_2 & 2) == 0) {\n      uVar24 = (param_2 & 1) << 6;\n    }\n    uVar22 = param_2 & 0x100;\n    uVar11 = 0;\n    local_c4 = 0;\n    local_5c = 0;\n    uVar39 = (ulong)*pbVar30;\n    uVar32 = 0;\n    uVar34 = 0;\nLAB_00177fe0:\n    mVar3 = local_48;\n    cVar29 = (char)DAT_002387c0;\n    pbVar14 = pbVar30 + uVar11;\n    cVar36 = (char)uVar39;\n    uVar6 = (uint)uVar32;\n    local_d8 = (char)param_2;\n    uVar35 = uVar39;\n    uVar33 = uVar34;\n    uVar7 = local_5c;\n    if ('`' < cVar36) {\n      if (cVar36 != '~') goto switchD_00178012_caseD_2;\n      uVar25 = *(uint *)(param_1 + 1);\n      if (((bVar1) || ((int)uVar6 < 1)) && ((uVar25 & 0x1000 | param_2 & 3) == 0)) {\n        uVar40 = 2;\n        if ((uVar25 & 0x800) == 0) {\n          uVar40 = (uVar25 & 0x84) != 0;\n        }\n        pbVar14 = (byte *)bash_tilde_find_word(pbVar14,uVar40,&local_4c);\n        bVar1 = false;\n        uVar7 = local_5c;\n        if (pbVar14 != (byte *)0x0) {\n          if ((*pbVar14 != 0) && (0 < (int)local_4c)) {\n            pcVar15 = (char *)bash_tilde_expand(pbVar14,uVar40);\n            if (pcVar15 == (char *)0x0) {\n              sh_xfree(pbVar14,\"subst.c\",0x2bba);\n              local_5c = local_5c + local_4c;\n              goto LAB_0017875c;\n            }\n            if (((*pcVar15 == '~') && (uVar39 = (ulong)*pbVar14, *pbVar14 == 0x7e)) &&\n               (iVar8 = strcmp((char *)pbVar14,pcVar15), iVar8 == 0)) {\n              sh_xfree(pbVar14,\"subst.c\",0x2bb6);\n              sh_xfree(pcVar15,\"subst.c\",0x2bb7);\n              uVar7 = local_5c;\n              bVar1 = false;\n              goto LAB_00178040;\n            }\n            sh_xfree(pbVar14,\"subst.c\",0x2bba);\n            local_5c = local_5c + local_4c;\n            goto LAB_00179436;\n          }\n          sh_xfree(pbVar14,\"subst.c\",0x2bc1);\n          uVar7 = local_5c;\n        }\n      }\n      else if ((uVar25 & 0x50 | param_3) == 0) {\n        bVar1 = false;\n        if ((*(char *)((long)&ifs_cmap + uVar39) != '\\0') && ((param_2 & 3) == 0))\n        goto LAB_00178296;\n      }\n      else {\n        bVar1 = false;\n      }\n      goto LAB_00178040;\n    }\n    switch(uVar39) {\n    case 0:\n      goto switchD_00178012_caseD_0;\n    case 1:\n      local_5c = uVar6 + 1;\n      if (1 < iVar5) {\n        bVar4 = pbVar30[(int)local_5c];\n        if (bVar4 != 0) {\n          if (((*(uint *)(is_basic_table + (ulong)(bVar4 >> 5) * 4) >> (bVar4 & 0x1f) & 1) == 0) &&\n             ((locale_utf8locale == 0 || ((char)bVar4 < '\\0')))) {\n            sVar10 = mbrtowc((wchar_t *)0x0,(char *)(pbVar30 + (int)local_5c),\n                             local_98 - (long)(int)local_5c,&local_48);\n            if (sVar10 < 0xfffffffffffffffe) {\n              if (sVar10 == 0) {\n                sVar10 = 1;\n              }\n              lVar31 = sVar10 + 1;\n              lVar37 = sVar10 + 2;\n              goto LAB_00179ad7;\n            }\n            local_48 = mVar3;\n            local_b8 = (byte *)sh_xmalloc(3,\"subst.c\",0x2b13);\n            lVar31 = 2;\n            *local_b8 = 1;\n            lVar37 = (long)(int)local_5c;\n            local_5c = local_5c + 1;\n            local_b8[1] = pbVar30[lVar37];\n          }\n          else {\n            lVar37 = 3;\n            lVar31 = 2;\nLAB_00179ad7:\n            local_b8 = (byte *)sh_xmalloc(lVar37,\"subst.c\",0x2b13);\n            *local_b8 = 1;\n            pbVar14 = local_b8 + 1;\n            do {\n              lVar37 = (long)(int)local_5c;\n              pbVar27 = pbVar14 + 1;\n              local_5c = local_5c + 1;\n              *pbVar14 = pbVar30[lVar37];\n              pbVar14 = pbVar27;\n            } while (pbVar27 != local_b8 + lVar31);\n          }\n          local_b8[lVar31] = 0;\n          bVar4 = *local_b8;\n          goto LAB_0017884f;\n        }\n      }\n      local_b8 = (byte *)sh_xmalloc(3,\"subst.c\",0x2b18);\n      *local_b8 = 1;\n      bVar4 = pbVar30[(int)local_5c];\n      local_b8[2] = 0;\n      local_b8[1] = bVar4;\n      if (pbVar30[(int)local_5c] == 0) {\nLAB_00178380:\n        if (local_b8[1] == 0) {\n          sVar10 = 1;\n          uVar34 = uVar33 + 1;\n        }\n        else {\nLAB_00178ec8:\n          if (local_b8[2] == 0) {\n            sVar10 = 2;\n            uVar34 = uVar33 + 2;\n          }\n          else {\n            sVar10 = strlen((char *)local_b8);\n            uVar34 = uVar33 + sVar10;\n          }\n        }\n        goto LAB_00178398;\n      }\nLAB_00178842:\n      local_5c = local_5c + 1;\njoined_r0x0017866a:\n      if (local_b8 != (byte *)0x0) {\n        bVar4 = *local_b8;\n        goto LAB_0017884f;\n      }\nLAB_00178670:\n      uVar11 = (ulong)(int)local_5c;\n      uVar39 = (ulong)pbVar30[uVar11];\n      uVar32 = uVar11;\n      goto LAB_00177fe0;\n    default:\nswitchD_00178012_caseD_2:\n      if ((param_2 & 3) == 0) {\nLAB_00178023:\n        if (param_3 == 0) goto LAB_00178430;\nLAB_00178031:\n        if (locale_mb_cur_max < 2) break;\n        bVar4 = *pbVar14;\n        if ((*(uint *)(is_basic_table + (ulong)(bVar4 >> 5) * 4) >> (bVar4 & 0x1f) & 1) == 0) {\n          if (locale_utf8locale != 0) {\n            lVar31 = 2;\n            sVar10 = 1;\n            if (-1 < (char)bVar4) goto LAB_00179953;\n          }\n          sVar10 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,local_98 - uVar11,&local_48);\n          if (sVar10 < 0xfffffffffffffffe) {\n            if (sVar10 == 0) {\n              sVar10 = 1;\n            }\n            lVar31 = sVar10 + 1;\n            goto LAB_00179953;\n          }\n          local_48 = mVar3;\n          local_b8 = (byte *)sh_xmalloc(2,\"subst.c\",0x2d8b);\n          sVar10 = 1;\n          lVar31 = (long)(int)local_5c;\n          local_5c = local_5c + 1;\n          *local_b8 = pbVar30[lVar31];\n        }\n        else {\n          lVar31 = 2;\n          sVar10 = 1;\nLAB_00179953:\n          local_b8 = (byte *)sh_xmalloc(lVar31,\"subst.c\",0x2d8b);\n          pbVar14 = local_b8;\n          do {\n            lVar31 = (long)(int)local_5c;\n            pbVar27 = pbVar14 + 1;\n            local_5c = local_5c + 1;\n            *pbVar14 = pbVar30[lVar31];\n            pbVar14 = pbVar27;\n          } while (local_b8 + sVar10 != pbVar27);\n        }\n        local_b8[sVar10] = 0;\n        goto joined_r0x0017866a;\n      }\nLAB_001782b0:\n      cVar29 = (char)uVar35;\n      local_5c = uVar6 + 1;\nLAB_001782bc:\n      if (cVar29 == '\\0') {\n        uVar39 = 0x7f;\n        uVar7 = local_5c;\n        break;\n      }\nLAB_001782c5:\n      if (iVar5 < 2) {\n        uVar40 = 1;\n        goto LAB_00178f65;\n      }\n      local_5c = local_5c - 1;\n      bVar4 = pbVar30[(int)local_5c];\n      if (((*(uint *)(is_basic_table + (ulong)(bVar4 >> 5) * 4) >> (bVar4 & 0x1f) & 1) == 0) &&\n         ((locale_utf8locale == 0 || ((char)bVar4 < '\\0')))) {\n        sVar10 = mbrtowc((wchar_t *)0x0,(char *)(pbVar30 + (int)local_5c),\n                         local_98 - (long)(int)local_5c,&local_48);\n        if (sVar10 < 0xfffffffffffffffe) {\n          if (sVar10 == 0) {\n            sVar10 = 1;\n          }\n          lVar37 = sVar10 + 1;\n          lVar31 = sVar10 + 2;\n          goto LAB_00178317;\n        }\n        uVar26 = 0x2d7f;\nLAB_001791e8:\n        local_48 = mVar3;\n        local_b8 = (byte *)sh_xmalloc(3,\"subst.c\",uVar26);\n        *local_b8 = 1;\n        goto LAB_001791fb;\n      }\n      lVar37 = 2;\n      lVar31 = 3;\nLAB_00178317:\n      local_b8 = (byte *)sh_xmalloc(lVar31,\"subst.c\",0x2d7f);\n      *local_b8 = 1;\n      pbVar14 = local_b8 + 1;\n      do {\n        lVar31 = (long)(int)local_5c;\n        pbVar27 = pbVar14 + 1;\n        local_5c = local_5c + 1;\n        *pbVar14 = pbVar30[lVar31];\n        pbVar14 = pbVar27;\n      } while (pbVar27 != local_b8 + lVar37);\nLAB_00178363:\n      local_b8[lVar37] = 0;\n      sVar10 = 0;\n      if (*local_b8 != 0) goto LAB_00178380;\nLAB_00178398:\n      if (uVar28 - uVar33 <= sVar10) {\nLAB_0017886c:\n        uVar28 = (uVar34 & 0xffffffffffffff80) + 0x80;\n        puVar9 = (undefined2 *)sh_xrealloc(puVar9,uVar28,\"subst.c\",0x2f3);\n      }\nLAB_001783a7:\n      memcpy((undefined *)((long)puVar9 + uVar33),local_b8,sVar10);\n      *(undefined *)((long)puVar9 + uVar34) = 0;\n      uVar26 = 0x2fa;\nLAB_001783cf:\n      sh_xfree(local_b8,\"subst.c\",uVar26);\n      uVar11 = (ulong)(int)local_5c;\n      uVar39 = (ulong)pbVar30[uVar11];\n      uVar32 = uVar11;\n      goto LAB_00177fe0;\n    case 0x20:\n      if (((local_a8 | ifs_is_null) == 0) &&\n         (((*(uint *)(param_1 + 1) & 0x850) == 0 || ((*(uint *)(param_1 + 1) & 0x4000) != 0)))) {\n        local_a8 = param_2 & 3;\n        uVar35 = 0x20;\n        if ((param_2 & 3) == 0) goto LAB_00178023;\n        local_a8 = 0;\n        uVar35 = 0x20;\n        goto LAB_001782b0;\n      }\n      local_5c = uVar6 + 1;\n      uVar40 = 1;\nLAB_00178f65:\n      uVar35 = uVar34 + 2;\n      if (uVar28 <= uVar35) {\n        do {\n          uVar28 = uVar28 + 0x80;\n        } while (uVar28 <= uVar35);\n        puVar9 = (undefined2 *)sh_xrealloc(puVar9,uVar28,\"subst.c\",0x2c61);\n      }\n      *(undefined *)((long)puVar9 + uVar34) = uVar40;\n      *(char *)((long)puVar9 + uVar34 + 1) = (char)uVar39;\n      *(undefined *)((long)puVar9 + uVar35) = 0;\n      uVar11 = (ulong)(int)local_5c;\n      uVar39 = (ulong)pbVar30[uVar11];\n      uVar32 = uVar11;\n      uVar34 = uVar35;\n      goto LAB_00177fe0;\n    case 0x22:\n      if (((param_2 & 3) == 0) || (uVar22 != 0)) {\n        local_5c = uVar6 + 1;\n        local_4c = local_5c;\n        pcVar15 = (char *)FUN_0016aa90(pbVar30,&local_5c,*(int *)(param_1 + 1) >> 0x11 & 0x400);\n        if (local_4c == 1) {\n          local_c4 = 2;\n          if (pbVar30[(int)local_5c] != 0) {\n            local_c4 = 1;\n          }\n        }\n        else {\n          local_c4 = 1;\n        }\n        if (pcVar15 != (char *)0x0) {\n          if (*pcVar15 == '\\0') {\n            sh_xfree(pcVar15,\"subst.c\",0x2cca);\n          }\n          else {\n            ppcVar20 = (char **)alloc_word_desc();\n            *ppcVar20 = pcVar15;\n            uVar7 = *(uint *)(param_1 + 1);\n            if ((uVar7 & 0x20000) != 0) {\n              *(uint *)(ppcVar20 + 1) = *(uint *)(ppcVar20 + 1) | uVar7 & 0x20800;\n              uVar7 = *(uint *)(param_1 + 1);\n            }\n            if ((uVar7 & 0x8000000) != 0) {\n              *(uint *)(ppcVar20 + 1) = *(uint *)(ppcVar20 + 1) | 0x8000000;\n              uVar7 = *(uint *)(param_1 + 1);\n            }\n            if ((uVar7 & 0x400) != 0) {\n              *(uint *)(ppcVar20 + 1) = *(uint *)(ppcVar20 + 1) | 0x400;\n              uVar7 = *(uint *)(param_1 + 1);\n            }\n            if ((uVar7 & 0x100000) != 0) {\n              *(uint *)(ppcVar20 + 1) = *(uint *)(ppcVar20 + 1) | 0x100000;\n              uVar7 = *(uint *)(param_1 + 1);\n            }\n            if ((uVar7 & 0x800) != 0) {\n              *(uint *)(ppcVar20 + 1) = *(uint *)(ppcVar20 + 1) | 0x800;\n            }\n            local_50 = 0;\n            plVar18 = (long *)FUN_00177e80(ppcVar20,uVar22 | 1,0,&local_50);\n            local_c8 = local_c8 + local_50;\n            if ((plVar18 == (long *)&DAT_00247880) || (plVar18 == (long *)&DAT_00247870)) {\n              sh_xfree(puVar9,\"subst.c\",0x2c92);\n              sh_xfree(pbVar30,\"subst.c\",0x2c93);\n              *ppcVar20 = (char *)0x0;\n              dispose_word(ppcVar20);\n              goto LAB_00178af0;\n            }\n            dispose_word();\n            if (plVar18 != (long *)0x0) {\n              if (((plVar18[1] != 0) && (*plVar18 == 0)) && ((*(byte *)(plVar18[1] + 10) & 4) != 0))\n              {\n                if ((local_54 != 0) && (local_50 != 0)) {\n                  local_58 = local_58 + 1;\n                }\n                local_54 = 1;\n              }\n              dequote_list(plVar18);\n              if (local_50 != 0) {\n                local_58 = local_58 + 1;\n                if (param_4 != (undefined4 *)0x0) {\n                  *param_4 = 1;\n                }\n                if (param_5 != (int *)0x0) {\n                  *param_5 = 1;\n                }\n              }\n              if (*plVar18 == 0) {\n                pcVar15 = *(char **)plVar18[1];\n                sVar10 = strlen(pcVar15);\n                pcVar19 = (char *)sh_xmalloc(sVar10 + 1,\"subst.c\",0x2ce5);\n                pcVar15 = strcpy(pcVar19,pcVar15);\n                uVar7 = *(uint *)(plVar18[1] + 8);\n                dispose_words(plVar18);\n                if (((uVar7 & 0x40000) != 0) && ((*pcVar15 != '\\x7f' || (pcVar15[1] != '\\0')))) {\n                  remove_quoted_nulls(pcVar15);\n                }\n                goto LAB_00179436;\n              }\n              if (local_58 == 0) {\n                uVar26 = FUN_00170510(plVar18);\n                local_b8 = (byte *)string_list_internal(uVar26,&DAT_001fdb1c);\n              }\n              else {\n                local_b8 = (byte *)string_list_dollar_at(plVar18,1,0);\n              }\n              dispose_words();\n              goto joined_r0x0017866a;\n            }\n            if (local_50 != 0) {\n              uVar11 = (ulong)(int)local_5c;\n              local_58 = local_58 + 1;\n              uVar39 = (ulong)pbVar30[uVar11];\n              uVar32 = uVar11;\n              goto LAB_00177fe0;\n            }\n          }\n        }\n        if (local_c4 == 1) {\n          local_54 = 1;\n          if ((param_2 == 0) && ((*(uint *)(param_1 + 1) & 0x4810) == 0x4000)) {\n            uVar6 = local_5c - 1;\nLAB_00178235:\n            uVar39 = 0x7f;\n            uVar7 = uVar6;\n            break;\n          }\n          if ((*(uint *)(param_1 + 1) & 0x50) != 0) {\nLAB_00179720:\n            local_54 = 1;\n            uVar11 = (ulong)(int)local_5c;\n            uVar39 = (ulong)pbVar30[uVar11];\n            uVar32 = (ulong)local_5c;\n            goto LAB_00177fe0;\n          }\n        }\n        else {\n          local_c4 = 2;\n        }\nLAB_0017875c:\n        uVar39 = 0x7f;\n        local_54 = 1;\n        uVar7 = local_5c - 1;\n      }\n      break;\n    case 0x24:\n      if (param_5 != (int *)0x0) {\n        *param_5 = 1;\n      }\n      local_50 = 0;\n      uVar7 = *(uint *)(param_1 + 1);\n      uVar6 = (int)uVar7 >> 10 & 1;\n      if ((uVar7 & 0x40) != 0) {\n        uVar6 = uVar6 | 4;\n      }\n      if ((uVar7 & 0x800) != 0) {\n        uVar6 = uVar6 | 8;\n      }\n      if ((uVar7 & 0x8000000) != 0) {\n        uVar6 = uVar6 | 0x10;\n      }\n      ppbVar13 = (byte **)FUN_001745e0(pbVar30,&local_5c,param_2,param_5,&local_50,&local_58,\n                                       &local_54,uVar6);\n      local_c8 = local_c8 + local_50;\n      uVar7 = *(uint *)(ppbVar13 + 1);\n      local_a8 = local_a8 + (uVar7 & 8);\n      if (ppbVar13 == (byte **)&DAT_00247860) {\n        sh_xfree(pbVar30,\"subst.c\",0x2bdb);\n        sh_xfree(puVar9,\"subst.c\",0x2bdc);\n        plVar18 = (long *)&DAT_00247880;\n      }\n      else {\n        if (ppbVar13 != (byte **)&DAT_00247850) {\n          if ((param_4 != (undefined4 *)0x0) && (local_c8 != 0)) {\n            *param_4 = 1;\n            uVar7 = *(uint *)(ppbVar13 + 1);\n          }\n          if ((uVar7 & 0x40000) != 0) {\n            local_54 = 1;\n          }\n          if ((uVar7 & 0x200000) != 0) {\n            local_54 = 1;\n          }\n          local_b8 = *ppbVar13;\n          dispose_word_desc();\n          if (local_54 == 0) goto joined_r0x0017866a;\n          if (local_b8 == (byte *)0x0) goto LAB_00178670;\n          bVar4 = *local_b8;\n          if (bVar4 != 0x7f) goto LAB_0017884f;\n          if (local_b8[1] != 0) goto LAB_00178ec8;\n          uVar26 = 0x2bef;\n          goto LAB_001783cf;\n        }\n        sh_xfree(pbVar30,\"subst.c\",0x2bdb);\n        sh_xfree(puVar9,\"subst.c\",0x2bdc);\n        plVar18 = (long *)&DAT_00247870;\n      }\n      goto LAB_00178af0;\n    case 0x27:\n      if ((param_2 & 3) == 0) {\n        local_5c = uVar6 + 1;\n        local_4c = local_5c;\n        pcVar15 = (char *)FUN_001674a0(pbVar30,&local_5c,0);\n        if ((local_4c == 1) && (pbVar30[(int)local_5c] == 0)) {\n          if (*pcVar15 != '\\0') {\n            local_c4 = 2;\nLAB_00179404:\n            pcVar19 = (char *)dequote_escapes(pcVar15);\n            strcpy(pcVar15,pcVar19);\n            sh_xfree(pcVar19,\"subst.c\",0x1377);\nLAB_00179436:\n            local_b8 = (byte *)quote_string(pcVar15);\n            sh_xfree(pcVar15,\"subst.c\",0x2d15);\n            goto joined_r0x0017866a;\n          }\n          sh_xfree(pcVar15,\"subst.c\",0x2d33);\n          local_c4 = 2;\nLAB_00178532:\n          uVar39 = 0x7f;\n          uVar7 = local_5c - 1;\n        }\n        else {\n          if (*pcVar15 != '\\0') {\n            local_c4 = 1;\n            goto LAB_00179404;\n          }\n          sh_xfree(pcVar15,\"subst.c\",0x2d33);\n          local_54 = 1;\n          if ((param_2 != 0) || ((*(uint *)(param_1 + 1) & 0x4810) != 0x4000)) {\n            local_c4 = 1;\n            if ((*(uint *)(param_1 + 1) & 0x50) != 0) goto LAB_00179720;\n            goto LAB_00178532;\n          }\n          uVar39 = 0x7f;\n          local_c4 = 1;\n          uVar7 = local_5c - 1;\n        }\n      }\n      break;\n    case 0x3a:\n      uVar25 = *(uint *)(param_1 + 1);\n      bVar2 = bVar1;\n      if ((((uVar25 & 0x3000) == 0) && ((uVar25 & 0x804) != 0)) &&\n         (((posixly_correct == 0 || ((uVar25 & 0x80) != 0)) &&\n          (bVar2 = true, pbVar30[uVar11 + 1] != 0x7e)))) {\n        bVar2 = bVar1;\n      }\n      bVar1 = bVar2;\n      if (((uVar25 & 0x50 | param_3) == 0) && (*(char *)((long)&ifs_cmap + uVar39) != '\\0')) {\n        if ((param_2 & 3) != 0) goto LAB_001782b0;\nLAB_00178430:\n        if (*(char *)((long)&ifs_cmap + uVar39) != '\\0') {\n          uVar25 = *(uint *)(param_1 + 1);\n          goto LAB_00178296;\n        }\n        goto LAB_00178031;\n      }\n      break;\n    case 0x3c:\n    case 0x3e:\n      local_5c = uVar6 + 1;\n      uVar7 = uVar6;\n      if (((pbVar30[(int)local_5c] != 0x28) || ((param_2 & 3) != 0)) ||\n         ((*(byte *)((long)param_1 + 10) & 0x10) != 0)) break;\n      local_4c = uVar6 + 2;\n      lVar31 = xparse_dolparen(pbVar30,pbVar30 + (int)local_4c,&local_4c,\n                               (ulong)(no_longjmp_on_fatal_error != 0) << 6);\n      local_5c = local_4c;\n      if (lVar31 != 0) {\n        local_b8 = (byte *)FUN_0016fe40(lVar31,cVar36 == '>');\n        sh_xfree(lVar31,\"subst.c\",0x2b43);\n        goto LAB_00178e80;\n      }\n      if (pbVar30[(int)local_4c] != 0) {\n        local_b8 = (byte *)0x0;\n        local_5c = local_4c;\n        goto LAB_00178842;\n      }\nswitchD_00178012_caseD_0:\n      if (*(char *)puVar9 != '\\0') {\n        uVar24 = *(uint *)(param_1 + 1);\n        pbVar30 = ifs_value;\n        goto joined_r0x001788ba;\n      }\n      if ((local_54 == 0) && ((local_58 != 0 || (local_c4 != 1)))) {\n        plVar18 = (long *)0x0;\n      }\n      else {\n        *puVar9 = 0x7f;\n        puVar17 = (undefined8 *)alloc_word_desc();\n        *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x40000;\n        *puVar17 = puVar9;\n        puVar9 = (undefined2 *)0x0;\n        plVar18 = (long *)make_word_list(puVar17,0);\n        if ((param_2 & 3) != 0) {\n          *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 2;\n        }\n      }\n      goto LAB_00178ae0;\n    case 0x3d:\n      uVar25 = *(uint *)(param_1 + 1);\n      if ((uVar25 & 0x1800) == 0) {\n        if (((((uVar25 & 4) != 0) &&\n             ((((posixly_correct == 0 || ((uVar25 & 0x80) != 0)) && (local_8c == 0xffffffff)) &&\n              (0 < (int)uVar6)))) || (bVar2 = bVar1, local_8c == uVar6)) &&\n           (local_8c = uVar6, bVar2 = true, pbVar30[uVar11 + 1] != 0x7e)) {\n          bVar2 = bVar1;\n        }\n        if ((uVar25 & 0x20000) != 0) {\n          *(uint *)(param_1 + 1) = uVar25 | 0x800;\n        }\n        bVar1 = bVar2;\n        if (((param_3 == 0) && ((*(byte *)(param_1 + 1) & 0x50) == 0)) &&\n           (*(char *)((long)&ifs_cmap + uVar39) != '\\0')) {\n          local_90 = local_90 + 1;\n          if ((param_2 & 3) == 0) {\n            uVar35 = 0x3d;\n            goto LAB_0017829f;\n          }\n          if (*pbVar14 != 0) {\n            uVar35 = 0x3d;\n            goto LAB_001782b0;\n          }\n          goto LAB_001782c5;\n        }\n      }\n      else if (((uVar25 & 0x50 | param_3) == 0) && (*(char *)((long)&ifs_cmap + uVar39) != '\\0')) {\n        if ((param_2 & 3) == 0) goto LAB_00178430;\n        goto LAB_001782b0;\n      }\n      break;\n    case 0x5b:\n      if ((uVar22 == 0) || (shell_compatibility_level < 0x34)) {\n        if ((param_3 != 0) ||\n           (((uVar25 = *(uint *)(param_1 + 1), (uVar25 & 0x50) != 0 ||\n             (*(char *)((long)&ifs_cmap + uVar39) == '\\0')) || ((param_2 & 3) != 0)))) break;\n        uVar35 = 0x5b;\nLAB_00178296:\n        if ((uVar25 & 0x50) != 0) goto LAB_00178031;\nLAB_0017829f:\n        cVar29 = (char)uVar35;\n        local_90 = local_90 + 1;\n        if (*pbVar14 != 0) goto LAB_001782b0;\n        goto LAB_001782bc;\n      }\n      if (*pbVar30 == 0) {\n        sVar10 = 0;\n        if ((char)DAT_002387c0 == '\\x01') {\nLAB_00178b8b:\n          puVar17 = &DAT_002387c0;\n          for (lVar31 = 0x20; lVar31 != 0; lVar31 = lVar31 + -1) {\n            *puVar17 = 0;\n            puVar17 = puVar17 + (ulong)bVar41 * -2 + 1;\n          }\n          DAT_0023883e = 1;\n          DAT_00238820 = 1;\n          DAT_002387e4 = 1;\n          DAT_002387e7 = 1;\n          DAT_0023881b = 1;\n          _DAT_0023881c = 0x101;\n          DAT_002387e2 = 1;\n          goto LAB_00178bd2;\n        }\n        FUN_0016af90(pbVar30,uVar32 & 0xffffffff,0);\n      }\n      else {\n        sVar10 = 1;\n        if ((pbVar30[1] != 0) && (sVar10 = 2, pbVar30[2] != 0)) {\n          sVar10 = strlen((char *)pbVar30);\n          uVar32 = uVar32 & 0xffffffff;\n        }\n        if (cVar29 == '\\x01') goto LAB_00178b8b;\nLAB_00178bd2:\n        uVar6 = (uint)uVar32;\n        iVar8 = FUN_0016af90(pbVar30,uVar32 & 0xffffffff,0);\n        if ((((ulong)(long)iVar8 < sVar10) && (pbVar30[iVar8] == 0x5d)) && (iVar8 - uVar6 != 1)) {\n          uVar26 = substring(pbVar30,uVar6 + 1,iVar8);\n          uVar16 = expand_subscript_string(uVar26,param_2 & 0xfffffefe);\n          sh_xfree(uVar26,\"subst.c\",0x2a6b);\n          pcVar15 = (char *)sh_backslash_quote(uVar16,&DAT_002387c0,0);\n          sh_xfree(uVar16,\"subst.c\",0x2a6d);\n          if ((pcVar15 == (char *)0x0) || (*pcVar15 == '\\0')) {\n            lVar38 = 2;\n            lVar37 = 1;\n            lVar31 = 3;\n          }\n          else if (pcVar15[1] == '\\0') {\n            lVar38 = 3;\n            lVar37 = 2;\n            lVar31 = 4;\n          }\n          else if (pcVar15[2] == '\\0') {\n            lVar38 = 4;\n            lVar37 = 3;\n            lVar31 = 5;\n          }\n          else {\n            sVar10 = strlen(pcVar15);\n            lVar31 = sVar10 + 3;\n            lVar37 = sVar10 + 1;\n            lVar38 = sVar10 + 2;\n          }\n          local_b8 = (byte *)sh_xmalloc(lVar31,\"subst.c\",0x2a70);\n          *local_b8 = 0x5b;\n          strcpy((char *)(local_b8 + 1),pcVar15);\n          local_b8[lVar37] = 0x5d;\n          local_b8[lVar38] = 0;\n          sh_xfree(pcVar15,\"subst.c\",0x2a76);\n          local_5c = iVar8 + 1;\n          bVar4 = *local_b8;\n          goto LAB_0017884f;\n        }\n      }\n      local_b8 = (byte *)sh_xmalloc(2,\"subst.c\",0x2a61);\n      bVar4 = *pbVar14;\n      local_5c = uVar6 + 1;\n      local_b8[1] = 0;\n      *local_b8 = bVar4;\n      bVar4 = *local_b8;\nLAB_0017884f:\n      sVar10 = 0;\n      uVar33 = uVar34;\n      if (bVar4 != 0) goto LAB_00178380;\n      if (uVar28 == uVar34) goto LAB_0017886c;\n      goto LAB_001783a7;\n    case 0x5c:\n      lVar31 = uVar11 + 1;\n      pbVar14 = pbVar30 + lVar31;\n      if (*pbVar14 == 10) goto LAB_001792f0;\n      local_5c = uVar6 + 1;\n      bVar4 = *pbVar14;\n      if (((param_2 & 0x82) == 0x82) && (bVar4 == 0x22)) {\n        if ((param_2 & 3) != 0) {\n          uVar7 = 0x40;\nLAB_0017912c:\n          if ((param_3 | uVar7 & (&sh_syntaxtab)[bVar4]) == 0) {\n            if (*(char *)((long)&ifs_cmap + (ulong)bVar4) != '\\0') {\n              uVar32 = uVar34 + 2;\n              if (uVar28 <= uVar32) {\n                do {\n                  uVar28 = uVar28 + 0x80;\n                } while (uVar28 <= uVar32);\n                puVar9 = (undefined2 *)sh_xrealloc(puVar9,uVar28,\"subst.c\",0x2c3e);\n              }\n              mVar3 = local_48;\n              *(undefined *)((long)puVar9 + uVar34) = 1;\n              *(undefined *)((long)puVar9 + uVar34 + 1) = 0x5c;\n              *(undefined *)((long)puVar9 + uVar32) = 0;\n              uVar34 = uVar32;\n              if (locale_mb_cur_max < 2) {\n                uVar39 = 1;\n                goto LAB_00179477;\n              }\n              bVar4 = pbVar30[(int)local_5c];\n              if (((*(uint *)(is_basic_table + (ulong)(bVar4 >> 5) * 4) >> (bVar4 & 0x1f) & 1) == 0)\n                 && ((locale_utf8locale == 0 || ((char)bVar4 < '\\0')))) {\n                sVar10 = mbrtowc((wchar_t *)0x0,(char *)(pbVar30 + (int)local_5c),\n                                 local_98 - (long)(int)local_5c,&local_48);\n                if (sVar10 < 0xfffffffffffffffe) {\n                  sVar23 = 1;\n                  if (sVar10 != 0) {\n                    sVar23 = sVar10;\n                  }\n                  lVar31 = sVar23 + 2;\n                  lVar37 = sVar23 + 1;\n                  goto LAB_00179f52;\n                }\n                local_48 = mVar3;\n                local_b8 = (byte *)sh_xmalloc(3,\"subst.c\",0x2c44);\n                lVar37 = 2;\n                *local_b8 = 1;\n                lVar31 = (long)(int)local_5c;\n                local_5c = local_5c + 1;\n                local_b8[1] = pbVar30[lVar31];\n              }\n              else {\n                lVar37 = 2;\n                lVar31 = 3;\nLAB_00179f52:\n                local_b8 = (byte *)sh_xmalloc(lVar31,\"subst.c\",0x2c44);\n                *local_b8 = 1;\n                pbVar14 = local_b8 + 1;\n                do {\n                  lVar31 = (long)(int)local_5c;\n                  pbVar27 = pbVar14 + 1;\n                  local_5c = local_5c + 1;\n                  *pbVar14 = pbVar30[lVar31];\n                  pbVar14 = pbVar27;\n                } while (local_b8 + lVar37 != pbVar27);\n              }\n              local_b8[lVar37] = 0;\n              bVar4 = *local_b8;\n              goto LAB_0017884f;\n            }\n            if (bVar4 == 0) goto LAB_00179679;\nLAB_001798a1:\n            if (locale_mb_cur_max < 2) goto LAB_00179477;\n            if (((*(uint *)(is_basic_table + (ulong)(bVar4 >> 5) * 4) >> (bVar4 & 0x1f) & 1) != 0)\n               || ((locale_utf8locale != 0 && (-1 < (char)bVar4)))) {\n              lVar37 = 2;\n              lVar31 = 3;\nLAB_001798f5:\n              local_b8 = (byte *)sh_xmalloc(lVar31,\"subst.c\",0x2c51);\n              *local_b8 = 0x5c;\n              pbVar14 = local_b8 + 1;\n              do {\n                lVar31 = (long)(int)local_5c;\n                pbVar27 = pbVar14 + 1;\n                local_5c = local_5c + 1;\n                *pbVar14 = pbVar30[lVar31];\n                pbVar14 = pbVar27;\n              } while (local_b8 + lVar37 != pbVar27);\n              goto LAB_00178363;\n            }\n            sVar10 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,local_98 - lVar31,&local_48);\n            if (sVar10 < 0xfffffffffffffffe) {\n              sVar23 = 1;\n              if (sVar10 != 0) {\n                sVar23 = sVar10;\n              }\n              lVar31 = sVar23 + 2;\n              lVar37 = sVar23 + 1;\n              goto LAB_001798f5;\n            }\n            local_48 = mVar3;\n            local_b8 = (byte *)sh_xmalloc(3,\"subst.c\",0x2c51);\n            *local_b8 = 0x5c;\nLAB_001791fb:\n            lVar31 = (long)(int)local_5c;\n            lVar37 = 2;\n            local_5c = local_5c + 1;\n            local_b8[1] = pbVar30[lVar31];\n            goto LAB_00178363;\n          }\n          if (bVar4 != 0) {\n            if ((uVar7 & (&sh_syntaxtab)[bVar4]) == 0) goto LAB_001798a1;\n            goto LAB_001795c8;\n          }\nLAB_00179679:\n          uVar35 = uVar34 + 2;\n          if (uVar28 <= uVar35) {\n            do {\n              uVar28 = uVar28 + 0x80;\n            } while (uVar28 <= uVar35);\n            puVar9 = (undefined2 *)sh_xrealloc(puVar9,uVar28,\"subst.c\",0x2c48);\n          }\n          *(undefined *)((long)puVar9 + uVar34) = 1;\n          *(undefined *)((long)puVar9 + uVar34 + 1) = 0x5c;\n          *(undefined *)((long)puVar9 + uVar35) = 0;\n          uVar11 = (ulong)(int)local_5c;\n          uVar39 = (ulong)pbVar30[uVar11];\n          uVar32 = uVar11;\n          uVar34 = uVar35;\n          goto LAB_00177fe0;\n        }\nLAB_001795c8:\n        uVar39 = 1;\n        if (1 < locale_mb_cur_max) {\n          if (((*(uint *)(is_basic_table + (ulong)(bVar4 >> 5) * 4) >> (bVar4 & 0x1f) & 1) == 0) &&\n             ((locale_utf8locale == 0 || ((char)bVar4 < '\\0')))) {\n            sVar10 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,local_98 - lVar31,&local_48);\n            if (0xfffffffffffffffd < sVar10) {\n              uVar26 = 0x2c5b;\n              goto LAB_001791e8;\n            }\n            if (sVar10 == 0) {\n              sVar10 = 1;\n            }\n            lVar37 = sVar10 + 1;\n            lVar31 = sVar10 + 2;\n          }\n          else {\n            lVar37 = 2;\n            lVar31 = 3;\n          }\n          local_b8 = (byte *)sh_xmalloc(lVar31,\"subst.c\",0x2c5b);\n          *local_b8 = 1;\n          pbVar14 = local_b8 + 1;\n          do {\n            lVar31 = (long)(int)local_5c;\n            pbVar27 = pbVar14 + 1;\n            local_5c = local_5c + 1;\n            *pbVar14 = pbVar30[lVar31];\n            pbVar14 = pbVar27;\n          } while (local_b8 + lVar37 != pbVar27);\n          goto LAB_00178363;\n        }\n      }\n      else {\n        if ((-1 < local_d8) || (bVar4 != 0x7d)) {\n          uVar7 = uVar24;\n          if ((param_2 & 3) != 0) goto LAB_0017912c;\n          if (bVar4 == 0) goto LAB_00178235;\n          goto LAB_001795c8;\n        }\n        uVar39 = 1;\n        if (1 < locale_mb_cur_max) {\n          if (((uint)is_basic_table._12_4_ >> 0x1d & 1 | locale_utf8locale) == 0) {\n            sVar10 = mbrtowc((wchar_t *)0x0,(char *)pbVar14,local_98 - lVar31,&local_48);\n            if (0xfffffffffffffffd < sVar10) {\n              uVar26 = 0x2c39;\n              goto LAB_001791e8;\n            }\n            sVar23 = 1;\n            if (sVar10 != 0) {\n              sVar23 = sVar10;\n            }\n            lVar31 = sVar23 + 2;\n            lVar37 = sVar23 + 1;\n          }\n          else {\n            lVar37 = 2;\n            lVar31 = 3;\n          }\n          local_b8 = (byte *)sh_xmalloc(lVar31,\"subst.c\",0x2c39);\n          *local_b8 = 1;\n          pbVar14 = local_b8 + 1;\n          do {\n            lVar31 = (long)(int)local_5c;\n            pbVar27 = pbVar14 + 1;\n            local_5c = local_5c + 1;\n            *pbVar14 = pbVar30[lVar31];\n            pbVar14 = pbVar27;\n          } while (local_b8 + lVar37 != pbVar27);\n          goto LAB_00178363;\n        }\n      }\nLAB_00179477:\n      uVar40 = (undefined)uVar39;\n      local_5c = local_5c + 1;\n      uVar39 = (ulong)bVar4;\n      goto LAB_00178f65;\n    case 0x60:\n      local_5c = uVar6 + 1;\n      local_4c = uVar6;\n      puVar12 = (undefined *)\n                FUN_0016b540(pbVar30,&local_5c,&DAT_00213e43,\n                             (-(uint)((*(uint *)(param_1 + 1) & 0x8000000) == 0) & 0xfffffc04) +\n                             0x400);\n      if ((puVar12 != &DAT_0024784d) && (puVar12 != &DAT_0024784c)) {\n        if (param_5 != (int *)0x0) {\n          *param_5 = 1;\n        }\n        if ((*(byte *)((long)param_1 + 9) & 4) == 0) {\n          de_backslash(puVar12);\n          ppbVar13 = (byte **)command_substitute(puVar12,param_2,0);\n          local_b8 = (byte *)0x0;\n          if (ppbVar13 != (byte **)0x0) {\n            local_b8 = *ppbVar13;\n            dispose_word_desc();\n          }\n        }\n        else {\n          local_b8 = (byte *)substring(pbVar30,local_4c,local_5c + 1);\n        }\n        if (puVar12 != (undefined *)0x0) {\n          sh_xfree(puVar12,\"subst.c\",0x2c1b);\n        }\nLAB_00178e80:\n        if (pbVar30[(int)local_5c] == 0) goto joined_r0x0017866a;\n        goto LAB_00178842;\n      }\n      uVar7 = local_5c - 1;\n      if (local_5c - 1 != local_4c) {\n        set_exit_status(1);\n        report_error(\"bad substitution: no closing \\\"`\\\" in %s\",pbVar30 + (int)local_4c);\n        sh_xfree(pbVar30,\"subst.c\",0x2c06);\n        sh_xfree(puVar9,\"subst.c\",0x2c07);\n        plVar18 = (long *)&DAT_00247880;\n        if (puVar12 != &DAT_0024784d) {\n          plVar18 = (long *)&DAT_00247870;\n        }\n        goto LAB_00178af0;\n      }\n    }\nLAB_00178040:\n    local_5c = uVar7;\n    uVar35 = uVar34 + 1;\n    if (uVar28 <= uVar35) {\n      do {\n        uVar28 = uVar28 + 0x80;\n      } while (uVar28 <= uVar35);\n      puVar9 = (undefined2 *)sh_xrealloc(puVar9,uVar28,\"subst.c\",0x2d8e);\n    }\n    *(char *)((long)puVar9 + uVar34) = (char)uVar39;\n    *(undefined *)((long)puVar9 + uVar35) = 0;\n    local_5c = local_5c + 1;\n    uVar11 = (ulong)(int)local_5c;\n    uVar39 = (ulong)pbVar30[uVar11];\n    uVar32 = (ulong)local_5c;\n    uVar34 = uVar35;\n    goto LAB_00177fe0;\n  }\n  plVar18 = (long *)0x0;\n  if (*(char *)puVar9 != '\\0') {\n    local_a8 = 0;\n    local_c8 = 0;\n    uVar24 = *(uint *)(param_1 + 1);\n    local_90 = 0;\n    local_c4 = 0;\n    pbVar30 = ifs_value;\njoined_r0x001788ba:\n    ifs_value = pbVar30;\n    if ((uVar24 & 0x10) == 0) {\n      if ((uVar24 & 0x800) == 0) {\n        if ((local_c8 | local_58) == 0) {\n          if (local_a8 == 0) goto LAB_0017931c;\n        }\n        else if (local_a8 == 0) {\n          if (local_c8 == 0) {\nLAB_0017931c:\n            puVar17 = (undefined8 *)alloc_word_desc();\n            if (((param_5 == (int *)0x0) || (*param_5 != 0)) || (local_90 == 0)) {\n              *puVar17 = puVar9;\n              if (local_54 == 0) goto LAB_001799e0;\nLAB_00179357:\n              if ((*(char *)puVar9 == '\\x7f') && (*(char *)((long)puVar9 + 1) == '\\0')) {\n                *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x40000;\n                puVar21 = (undefined2 *)*puVar17;\n              }\n              else {\n                *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x200000;\n                puVar21 = (undefined2 *)*puVar17;\n              }\n            }\n            else {\n              puVar21 = (undefined2 *)remove_quoted_ifs(puVar9);\n              *puVar17 = puVar21;\n              if (local_54 != 0) goto LAB_00179357;\n            }\n            if (puVar9 != puVar21) {\n              sh_xfree(puVar9,\"subst.c\",0x2e3f);\n            }\n            goto LAB_001799e0;\n          }\n          if ((local_58 | param_2) != 0) {\n            if (pbVar30 != (byte *)0x0) {\nLAB_00179569:\n              if (*pbVar30 == 0) {\n                pbVar30 = &DAT_001fdb1c;\n              }\n              plVar18 = (long *)list_string(puVar9,pbVar30,1);\n              goto LAB_00178ae0;\n            }\n            goto LAB_0017931c;\n          }\n          if (pbVar30 == (byte *)0x0) goto LAB_0017931c;\n          if ((uVar24 & 0x40) == 0) goto LAB_00179569;\n          puVar17 = (undefined8 *)alloc_word_desc();\n          if ((*pbVar30 & 0xdf) == 0) {\n            *puVar17 = puVar9;\n            if (local_54 != 0) {\nLAB_00178945:\n              if ((*(char *)puVar9 == '\\x7f') && (*(char *)((long)puVar9 + 1) == '\\0')) {\n                *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x40000;\n              }\n              goto LAB_0017894f;\n            }\n          }\n          else {\n            uVar26 = list_string(puVar9,pbVar30,1);\n            uVar26 = string_list_internal(uVar26,&DAT_001fdb1c);\n            *puVar17 = uVar26;\n            if (local_54 != 0) goto LAB_00178945;\nLAB_0017894f:\n            if ((undefined2 *)*puVar17 != puVar9) {\n              sh_xfree(puVar9,\"subst.c\",0x2e2d);\n            }\n          }\n          goto LAB_00178965;\n        }\n        if (ifs_is_set == 0) {\n          plVar18 = (long *)list_string(puVar9,&DAT_001ff6d0,1);\n        }\n        else {\n          plVar18 = (long *)list_string(puVar9,&DAT_001fdb1c,1);\n        }\n      }\n      else {\n        lVar31 = list_string(puVar9,&DAT_00213d70,param_2);\n        puVar17 = *(undefined8 **)(lVar31 + 8);\n        if (((local_54 != 0) && (*(char *)puVar9 == '\\x7f')) &&\n           (*(char *)((long)puVar9 + 1) == '\\0')) {\n          *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x40000;\n        }\n        sh_xfree(lVar31,\"subst.c\",0x2dea);\n        sh_xfree(puVar9,\"subst.c\",0x2deb);\nLAB_001799e0:\n        if ((param_2 & 3) == 0) {\nLAB_00178965:\n          if (local_c4 == 2) goto LAB_001799eb;\n        }\n        else {\nLAB_001799eb:\n          *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 2;\n        }\n        uVar24 = *(uint *)(param_1 + 1);\n        if ((uVar24 & 4) != 0) {\n          *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 4;\n          uVar24 = *(uint *)(param_1 + 1);\n        }\n        if ((uVar24 & 0x8000) != 0) {\n          *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x8000;\n          uVar24 = *(uint *)(param_1 + 1);\n        }\n        if ((uVar24 & 0x20) != 0) {\n          *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x20;\n          uVar24 = *(uint *)(param_1 + 1);\n        }\n        if ((uVar24 & 0x4000000) != 0) {\n          *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x4000000;\n          uVar24 = *(uint *)(param_1 + 1);\n        }\n        if ((uVar24 & 0x200) != 0) {\n          *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x200;\n        }\n        puVar9 = (undefined2 *)0x0;\n        plVar18 = (long *)make_word_list(puVar17,0);\n      }\n    }\n    else {\n      puVar17 = (undefined8 *)alloc_word_desc();\n      *puVar17 = puVar9;\n      if (((local_54 != 0) && (*(char *)puVar9 == '\\x7f')) && (*(char *)((long)puVar9 + 1) == '\\0'))\n      {\n        *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x40000;\n      }\n      uVar24 = *(uint *)(param_1 + 1);\n      if ((uVar24 & 4) != 0) {\n        *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 4;\n        uVar24 = *(uint *)(param_1 + 1);\n      }\n      if ((uVar24 & 0x8000) != 0) {\n        *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x8000;\n        uVar24 = *(uint *)(param_1 + 1);\n      }\n      if ((uVar24 & 0x20) != 0) {\n        *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x20;\n        uVar24 = *(uint *)(param_1 + 1);\n      }\n      if ((uVar24 & 0x4000000) != 0) {\n        *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x4000000;\n        uVar24 = *(uint *)(param_1 + 1);\n      }\n      if ((uVar24 & 0x200) != 0) {\n        *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 0x200;\n      }\n      if ((param_2 & 3) != 0) {\n        *(uint *)(puVar17 + 1) = *(uint *)(puVar17 + 1) | 2;\n      }\n      puVar9 = (undefined2 *)0x0;\n      plVar18 = (long *)make_word_list(puVar17,0);\n    }\n  }\nLAB_00178ae0:\n  sh_xfree(puVar9,\"subst.c\",0x2e52);\nLAB_00178af0:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return plVar18;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\nLAB_001792f0:\n  local_5c = uVar6 + 2;\n  uVar11 = (ulong)(int)local_5c;\n  uVar39 = (ulong)pbVar30[uVar11];\n  uVar32 = (ulong)local_5c;\n  goto LAB_00177fe0;\n}\n\n",
  "uitos": "\nvoid uitos(undefined8 param_1)\n\n{\n  char *__s;\n  size_t sVar1;\n  char *__dest;\n  long in_FS_OFFSET;\n  undefined auStack_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  __s = (char *)fmtumax(param_1,10,auStack_28,0x15,8);\n  sVar1 = strlen(__s);\n  __dest = (char *)sh_xmalloc(sVar1 + 1,\"itos.c\",0x53);\n  strcpy(__dest,__s);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "print_var_function": "\nvoid print_var_function(long param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (((*(byte *)(param_1 + 0x28) & 8) != 0) && (*(long *)(param_1 + 8) != 0)) {\n    uVar1 = named_function_string(0,*(long *)(param_1 + 8),3);\n    __printf_chk(1,&DAT_002102da,uVar1);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001d5280": "\nundefined8 FUN_001d5280(int param_1,termios *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  while( true ) {\n    iVar1 = tcgetattr(param_1,param_2);\n    if (-1 < iVar1) break;\n    piVar2 = __errno_location();\n    if (*piVar2 != 4) {\n      return 0xffffffff;\n    }\n  }\n  if ((*(byte *)((long)&param_2->c_lflag + 1) & 0x10) == 0) {\n    return 0;\n  }\n  _rl_errmsg(\"warning: turning off output flushing\");\n  param_2->c_lflag = param_2->c_lflag & 0xffffefff;\n  return 0;\n}\n\n",
  "FUN_00131c6c": "\nvoid FUN_00131c6c(void)\n\n{\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n",
  "fork": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__pid_t fork(void)\n\n{\n  __pid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_fork_00237e98)();\n  return _Var1;\n}\n\n",
  "_rl_rubout_char": "\nulong _rl_rubout_char(int param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  undefined4 uVar3;\n  size_t sVar4;\n  ushort **ppuVar5;\n  ulong uVar6;\n  \n  iVar2 = rl_point;\n  if (param_1 < 0) {\n    uVar6 = rl_delete(-param_1);\n    return uVar6;\n  }\n  if (rl_point != 0) {\n    if ((param_1 < 2) && (uVar6 = (ulong)rl_explicit_arg, rl_explicit_arg == 0)) {\n      sVar4 = __ctype_get_mb_cur_max();\n      if ((sVar4 == 1) || (rl_byte_oriented != 0)) {\n        rl_point = rl_point + -1;\n        bVar1 = *(byte *)(rl_line_buffer + rl_point);\n        rl_delete_text(rl_point,iVar2);\n        iVar2 = rl_point;\n        if (rl_point == rl_end) {\n          ppuVar5 = __ctype_b_loc();\n          if ((*(byte *)((long)*ppuVar5 + (ulong)bVar1 * 2 + 1) & 0x40) != 0) {\n            if (_rl_last_c_pos == 0) {\n              uVar6 = 0;\n            }\n            else {\n              uVar3 = rl_character_len(bVar1,iVar2);\n              _rl_erase_at_end_of_line(uVar3);\n            }\n          }\n        }\n      }\n      else {\n        rl_point = _rl_find_prev_mbchar(rl_line_buffer,rl_point,1);\n        rl_delete_text(rl_point,iVar2);\n      }\n    }\n    else {\n      rl_backward_char();\n      uVar6 = 0;\n      rl_kill_text(iVar2,rl_point);\n    }\n    return uVar6;\n  }\n  rl_ding();\n  return 1;\n}\n\n",
  "expand_subscript_string": "\nundefined8 expand_subscript_string(char *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  size_t sVar2;\n  char *__dest;\n  undefined *puVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  char *local_48;\n  undefined4 local_40;\n  long local_30;\n  \n  uVar1 = DAT_00247848;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    local_40 = 0x101040;\n    sVar2 = strlen(param_1);\n    __dest = (char *)sh_xmalloc(sVar2 + 1,\"subst.c\",0x2a25);\n    local_48 = strcpy(__dest,param_1);\n    DAT_00247848 = 1;\n    puVar3 = (undefined *)FUN_00177e80(&local_48,param_2,0,0,0);\n    if (puVar3 == &DAT_00247880) {\n      uVar4 = 2;\n    }\n    else {\n      if (puVar3 != &DAT_00247870) {\n        uVar4 = 0;\n        DAT_00247848 = uVar1;\n        if (puVar3 != (undefined *)0x0) {\n          if (*(undefined8 **)(puVar3 + 8) != (undefined8 *)0x0) {\n            remove_quoted_nulls(**(undefined8 **)(puVar3 + 8));\n            *(uint *)(*(long *)(puVar3 + 8) + 8) = *(uint *)(*(long *)(puVar3 + 8) + 8) & 0xfffbffff\n            ;\n          }\n          dequote_list(puVar3);\n          uVar4 = string_list_internal(puVar3,&DAT_001fdb1c);\n          dispose_words(puVar3);\n        }\n        sh_xfree(local_48,\"subst.c\",0x2a37);\n        goto LAB_0017b79f;\n      }\n      uVar4 = 1;\n    }\n    local_48 = (char *)0x0;\n    last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n    FUN_001667f0(uVar4);\n  }\n  uVar4 = 0;\nLAB_0017b79f:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "sh_badpid": "\nvoid sh_badpid(undefined8 param_1)\n\n{\n  builtin_error(\"`%s\\': not a pid or valid job spec\",param_1);\n  return;\n}\n\n",
  "_hs_append_history_line": "\nchar * _hs_append_history_line(int param_1,char *param_2)\n\n{\n  ulong uVar1;\n  char **ppcVar2;\n  size_t sVar3;\n  size_t sVar4;\n  char *pcVar5;\n  ulong __size;\n  char *pcStack_28;\n  \n  ppcVar2 = *(char ***)(DAT_0024b6e8 + (long)param_1 * 8);\n  pcVar5 = *ppcVar2;\n  sVar3 = strlen(pcVar5);\n  sVar4 = strlen(param_2);\n  uVar1 = sVar3 + 2 + sVar4;\n  __size = uVar1;\n  if (0x100 < sVar3) {\n    if (uVar1 < 0x201) {\n      __size = 0x200;\n    }\n    else {\n      __size = 0x200;\n      do {\n        __size = __size * 2;\n      } while (__size < uVar1);\n    }\n  }\n  pcVar5 = (char *)realloc(pcVar5,__size);\n  if (pcVar5 == (char *)0x0) {\n    return pcStack_28;\n  }\n  *ppcVar2 = pcVar5;\n  pcVar5[sVar3] = '\\n';\n  pcVar5 = strcpy(*ppcVar2 + sVar3 + 1,param_2);\n  return pcVar5;\n}\n\n",
  "sv_ignoreeof": "\nvoid sv_ignoreeof(void)\n\n{\n  char *__nptr;\n  int iVar1;\n  long lVar2;\n  \n  eof_encountered = 0;\n  lVar2 = find_variable();\n  if ((lVar2 == 0) || (__nptr = *(char **)(lVar2 + 8), __nptr == (char *)0x0)) {\n    ignoreeof = 0;\n    set_shellopts();\n    return;\n  }\n  ignoreeof = 1;\n  if (*__nptr != '\\0') {\n    iVar1 = all_digits(__nptr);\n    if (iVar1 != 0) {\n      lVar2 = strtol(__nptr,(char **)0x0,10);\n      eof_encountered_limit = (undefined4)lVar2;\n      goto LAB_00153a17;\n    }\n  }\n  eof_encountered_limit = 10;\nLAB_00153a17:\n  set_shellopts();\n  return;\n}\n\n",
  "append_process": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid append_process(undefined8 param_1,undefined4 param_2,uint param_3,int param_4)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  \n  puVar4 = (undefined8 *)sh_xmalloc(0x20,\"jobs.c\",0x601);\n  lVar1 = jobs;\n  *puVar4 = 0;\n  lVar1 = *(long *)(lVar1 + (long)param_4 * 8);\n  *(undefined4 *)(puVar4 + 1) = param_2;\n  *(uint *)((long)puVar4 + 0xc) = (param_3 & 0xff) << 8;\n  _DAT_0023876c = _DAT_0023876c + 1;\n  puVar2 = *(undefined8 **)(lVar1 + 8);\n  *(undefined4 *)(puVar4 + 2) = 0;\n  puVar4[3] = param_1;\n  puVar3 = puVar2;\n  do {\n    puVar5 = puVar3;\n    puVar3 = (undefined8 *)*puVar5;\n  } while (puVar3 != puVar2);\n  *puVar5 = puVar4;\n  *puVar4 = puVar3;\n  return;\n}\n\n",
  "getrlimit": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint getrlimit(__rlimit_resource_t __resource,rlimit *__rlimits)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_getrlimit_00237e18)();\n  return iVar1;\n}\n\n",
  "sync_buffered_stream": "\nundefined8 sync_buffered_stream(int param_1)\n\n{\n  int *piVar1;\n  \n  if (DAT_00247f68 == 0) {\n    return 0xffffffff;\n  }\n  piVar1 = *(int **)(DAT_00247f68 + (long)param_1 * 8);\n  if (piVar1 != (int *)0x0) {\n    if (*(long *)(piVar1 + 6) - *(long *)(piVar1 + 10) != 0) {\n      lseek(*piVar1,-(*(long *)(piVar1 + 6) - *(long *)(piVar1 + 10)),1);\n    }\n    *(undefined8 *)(piVar1 + 10) = 0;\n    *(undefined8 *)(piVar1 + 6) = 0;\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
  "select": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint select(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,timeval *__timeout)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_select_00237bb8)();\n  return iVar1;\n}\n\n",
  "FUN_001cff80": "\nundefined4 FUN_001cff80(int *param_1)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *pcVar3;\n  __int32_t **pp_Var4;\n  size_t sVar5;\n  undefined4 uVar6;\n  uint uVar7;\n  \n  iVar1 = *param_1;\n  if (iVar1 == 2) {\n    uVar7 = param_1[8];\n    pcVar3 = strchr(\" l|hwW^0bBFT`\",uVar7);\n    if (((pcVar3 == (char *)0x0) && (param_1[5] == rl_point || param_1[5] < rl_point)) &&\n       (rl_mark < rl_end)) {\n      sVar5 = __ctype_get_mb_cur_max();\n      if ((sVar5 == 1) || (rl_byte_oriented != 0)) {\n        rl_mark = rl_mark + 1;\n        uVar7 = param_1[8];\n      }\n      else {\n        rl_mark = _rl_find_next_mbchar(rl_line_buffer,rl_mark,1,0);\n        uVar7 = param_1[8];\n      }\n    }\n    ppuVar2 = __ctype_b_loc();\n    if ((*(byte *)((long)*ppuVar2 + (ulong)(uVar7 & 0xff) * 2 + 1) & 2) != 0) {\n      pp_Var4 = __ctype_toupper_loc();\n      uVar7 = (*pp_Var4)[uVar7 & 0xff];\n    }\n    if ((uVar7 == 0x57) && (rl_point < param_1[5])) {\n      rl_point = param_1[5];\n    }\n    if (_rl_vi_redoing == 0) {\n      rl_begin_undo_group();\n      rl_kill_text(rl_point,rl_mark);\n      uVar7 = param_1[7];\n      if ((*(byte *)((long)*ppuVar2 + (ulong)(uVar7 & 0xff) * 2 + 1) & 1) == 0) {\n        DAT_0024a420 = 1;\n      }\n      DAT_0023b36c = rl_numeric_arg;\n      DAT_0023b368 = rl_arg_sign;\n      _rl_vi_last_command = uVar7;\n      rl_begin_undo_group();\n      _rl_keymap = &vi_insertion_keymap;\n      DAT_0024a3c8 = uVar7;\n      if (_rl_show_mode_in_prompt != 0) {\n        _rl_reset_prompt();\n        uVar6 = 0;\n        goto LAB_001cffba;\n      }\n    }\n    else {\n      if ((DAT_0024a408 != (char *)0x0) && (*DAT_0024a408 != '\\0')) {\n        rl_begin_undo_group();\n      }\n      rl_delete_text(rl_point,rl_mark);\n      if ((DAT_0024a408 != (char *)0x0) && (*DAT_0024a408 != '\\0')) {\n        rl_insert_text();\n        rl_end_undo_group();\n      }\n    }\n    uVar6 = 0;\n  }\n  else if (iVar1 == 4) {\n    pcVar3 = strchr(\" l|h^0%bBFT`\",param_1[8]);\n    if (((pcVar3 == (char *)0x0) && (param_1[5] == rl_point || param_1[5] < rl_point)) &&\n       (rl_mark < rl_end)) {\n      sVar5 = __ctype_get_mb_cur_max();\n      if ((sVar5 == 1) || (rl_byte_oriented != 0)) {\n        rl_mark = rl_mark + 1;\n      }\n      else {\n        rl_mark = _rl_find_next_mbchar(rl_line_buffer,rl_mark,1,0);\n      }\n    }\n    rl_begin_undo_group();\n    uVar6 = 0;\n    rl_kill_text(rl_point,rl_mark);\n    rl_end_undo_group();\n    rl_do_undo();\n    rl_point = param_1[5];\n    _rl_fix_point(1);\n  }\n  else if (iVar1 == 1) {\n    pcVar3 = strchr(\" l|h^0bBFT`\",param_1[8]);\n    if (((pcVar3 == (char *)0x0) && (param_1[5] == rl_point || param_1[5] < rl_point)) &&\n       (rl_mark < rl_end)) {\n      sVar5 = __ctype_get_mb_cur_max();\n      if ((sVar5 == 1) || (rl_byte_oriented != 0)) {\n        rl_mark = rl_mark + 1;\n      }\n      else {\n        rl_mark = _rl_find_next_mbchar(rl_line_buffer,rl_mark,1,0);\n      }\n    }\n    rl_kill_text(rl_point,rl_mark);\n    uVar6 = 0;\n  }\n  else {\n    uVar6 = 1;\n    _rl_errmsg(\"vidomove_dispatch: unknown operator %d\");\n  }\nLAB_001cffba:\n  rl_readline_state = rl_readline_state & 0xffffffffffefffff;\n  return uVar6;\n}\n\n",
  "reap_dead_jobs": "\nvoid reap_dead_jobs(void)\n\n{\n  FUN_00165350(0);\n  if ((DAT_0023877c != 0) && (DAT_00247660 == 0)) {\n    FUN_001626a0();\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00167020": "\nint FUN_00167020(long param_1,long param_2,uint param_3,int param_4)\n\n{\n  byte *__s;\n  byte bVar1;\n  mbstate_t mVar2;\n  char cVar3;\n  size_t sVar4;\n  int iVar5;\n  ulong uVar6;\n  char *__s_00;\n  int iVar7;\n  ulong uVar8;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  uVar6 = (ulong)(int)param_3;\n  __s_00 = (char *)(param_1 + uVar6);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar3 = *__s_00;\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  if ((cVar3 != '\\'') && (cVar3 != '\\0')) {\n    uVar8 = uVar6;\n    do {\n      mVar2 = local_48;\n      iVar7 = (int)uVar8;\n      local_48 = mVar2;\n      if ((((cVar3 != '\\\\') || (param_4 == 0)) || (*(char *)(param_1 + 1 + uVar6) != '\\'')) ||\n         (*(char *)(param_1 + 2 + uVar6) == '\\0')) goto LAB_001670cb;\n      if (locale_mb_cur_max < 2) {\n        iVar7 = iVar7 + 1;\nLAB_001670a4:\n        local_48 = mVar2;\n        param_3 = iVar7 + 1;\n        uVar6 = (ulong)(int)param_3;\n        __s_00 = (char *)(param_1 + uVar6);\n        cVar3 = *__s_00;\n      }\n      else {\n        iVar5 = 1;\n        if (((uint)is_basic_table._8_4_ >> 0x1c & 1 | locale_utf8locale) == 0) {\n          sVar4 = mbrtowc((wchar_t *)0x0,__s_00,param_2 - uVar6,&local_48);\n          iVar5 = (int)sVar4;\n          if (sVar4 < 0xfffffffffffffffe) {\n            if (sVar4 != 0) goto LAB_001671a4;\n            iVar7 = iVar7 + 1;\n          }\n          else {\n            iVar7 = iVar7 + 1;\n            local_48 = mVar2;\n          }\n        }\n        else {\nLAB_001671a4:\n          iVar7 = iVar7 + iVar5;\n        }\nLAB_001670cb:\n        mVar2 = local_48;\n        if (locale_mb_cur_max < 2) goto LAB_001670a4;\n        __s = (byte *)(param_1 + iVar7);\n        bVar1 = *__s;\n        if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n          if ((locale_utf8locale != 0) && (-1 < (char)bVar1)) {\n            if (bVar1 == 0) goto LAB_001670a4;\n            goto LAB_001670ee;\n          }\n          sVar4 = mbrtowc((wchar_t *)0x0,(char *)__s,param_2 - iVar7,&local_48);\n          if ((0xfffffffffffffffd < sVar4) || (mVar2 = local_48, sVar4 == 0)) goto LAB_001670a4;\n        }\n        else {\nLAB_001670ee:\n          sVar4 = 1;\n        }\n        param_3 = iVar7 + (int)sVar4;\n        uVar6 = (ulong)(int)param_3;\n        __s_00 = (char *)(param_1 + uVar6);\n        cVar3 = *__s_00;\n      }\n    } while ((cVar3 != '\\0') && (uVar8 = (ulong)param_3, cVar3 != '\\''));\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return (param_3 + 1) - (uint)(cVar3 == '\\0');\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "bind_assoc_variable": "\nlong bind_assoc_variable(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                        byte param_5)\n\n{\n  uint uVar1;\n  long lVar2;\n  \n  uVar1 = *(uint *)(param_1 + 0x28);\n  if ((uVar1 & 2) == 0) {\n    if ((uVar1 & 0x4000) != 0) {\n      return param_1;\n    }\n  }\n  else if (((param_5 & 0x20) == 0) || ((uVar1 & 0x4000) != 0)) {\n    err_readonly(param_2);\n    return param_1;\n  }\n  lVar2 = FUN_0018a950(param_1,*(undefined8 *)(param_1 + 8));\n  return lVar2;\n}\n\n",
  "rl_vi_yank_pop": "\nundefined8 rl_vi_yank_pop(void)\n\n{\n  char *__s;\n  int iVar1;\n  int iVar2;\n  size_t sVar3;\n  int iVar4;\n  \n  if (((rl_last_func == (code *)PTR_rl_vi_put_00237f20) || (rl_last_func == rl_vi_yank_pop)) &&\n     (DAT_0024b160 != 0)) {\n    __s = *(char **)(DAT_0024b160 + (long)DAT_0024b158 * 8);\n    sVar3 = strlen(__s);\n    iVar1 = rl_point;\n    iVar2 = (int)sVar3;\n    iVar4 = rl_point - iVar2;\n    if (-1 < iVar4) {\n      if (iVar2 == 0) {\nLAB_001e9149:\n        rl_delete_text(iVar4,iVar1);\n        DAT_0024b158 = DAT_0024b158 + -1;\n        if (DAT_0024b158 < 0) {\n          DAT_0024b158 = DAT_0024b154 + -1;\n        }\n        rl_point = iVar4;\n        rl_vi_put(1,0x70);\n        return 0;\n      }\n      if (*(char *)(iVar4 + rl_line_buffer) == *__s) {\n        iVar2 = strncmp((char *)(iVar4 + rl_line_buffer),__s,(long)iVar2);\n        if (iVar2 == 0) goto LAB_001e9149;\n      }\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  _rl_abort_internal();\n}\n\n",
  "command_substitute": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 * command_substitute(byte *param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  byte bVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  int iVar4;\n  __pid_t _Var5;\n  int iVar6;\n  int iVar7;\n  long lVar8;\n  undefined8 uVar9;\n  undefined8 *puVar10;\n  undefined1 *puVar11;\n  byte *pbVar12;\n  long in_FS_OFFSET;\n  uint local_160;\n  int local_15c;\n  undefined4 local_154;\n  int local_150;\n  int local_14c;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  pbVar12 = param_1;\n  if (param_1 != (byte *)0x0) {\n    for (; bVar1 = *pbVar12, bVar1 != 0; pbVar12 = pbVar12 + 1) {\n      if (((*(byte *)((long)&sh_syntaxtab + (ulong)bVar1 * 4 + 1) & 0x20) == 0) && (bVar1 != 10)) {\n        if ((bVar1 == 0x3c) && (((pbVar12[1] & 0xfd) != 0x3c && (pbVar12[1] != 0x26)))) {\n          lVar8 = parse_string_to_command(param_1,0);\n          if ((lVar8 != 0) && (iVar7 = can_optimize_cat_file(lVar8), iVar7 != 0)) {\n            local_154 = 0;\n            iVar7 = open_redir_file(*(undefined8 *)(*(long *)(lVar8 + 0x18) + 0x10),0);\n            if (iVar7 < 0) {\nLAB_00172ae1:\n              last_command_exit_value = 1;\n              puVar11 = (undefined1 *)0x0;\n            }\n            else {\n              puVar11 = (undefined1 *)FUN_00168020(iVar7,param_2,param_3,&local_154);\n              close(iVar7);\n              if (puVar11 == &DAT_0024784f) goto LAB_00172ae1;\n              last_command_exit_value = 0;\n            }\n            last_command_subst_pid = dollar_dollar_pid;\n            dispose_command(lVar8);\n            puVar10 = (undefined8 *)alloc_word_desc();\n            *puVar10 = puVar11;\n            *(undefined4 *)(puVar10 + 1) = local_154;\n            goto LAB_00172673;\n          }\n          dispose_command(lVar8);\n        }\n        if ((wordexp_only != 0) && (read_but_dont_execute != 0)) {\n          last_command_exit_value = 0x7d;\n                    /* WARNING: Subroutine does not return */\n          jump_to_top_level(3);\n        }\n        if ((subst_assign_varlist == 0) || (uVar2 = last_made_pid, _DAT_00247840 == 0)) {\n          maybe_make_export_env();\n          uVar2 = last_made_pid;\n        }\n        local_160 = interactive;\n        if (interactive != 0) {\n          local_160 = (uint)(sourcelevel == 0) << 4;\n        }\n        last_made_pid = uVar2;\n        iVar4 = pipe(&local_150);\n        iVar7 = pipeline_pgrp;\n        if (iVar4 < 0) {\n          sys_error(&DAT_002102da,\"cannot make pipe for command substitution\");\n        }\n        else {\n          if ((subshell_environment & 0x18) == 0) {\n            pipeline_pgrp = shell_pgrp;\n          }\n          cleanup_the_pipeline();\n          uVar3 = last_asynchronous_pid;\n          iVar4 = make_child(0,subshell_environment & 1 | 4);\n          last_asynchronous_pid = uVar3;\n          if (iVar4 == 0) {\n            reset_signal_handlers();\n            if (interrupt_state != 0) {\n              _Var5 = getpid();\n              kill(_Var5,2);\n              interrupt_state = 0;\n            }\n            if (terminating_signal != 0) {\n              termsig_handler(terminating_signal);\n            }\n            if (interrupt_state != 0) {\n              throw_to_top_level();\n            }\n            subshell_environment = subshell_environment & 0xfffffeff | 0x80;\n          }\n          set_sigchld_handler();\n          stop_making_children();\n          if (iVar4 == 0) {\n            interactive = 0;\n            if ((0 < pipeline_pgrp) && (pipeline_pgrp != shell_pgrp)) {\n              shell_pgrp = pipeline_pgrp;\n            }\n            set_sigint_handler();\n            free_pushed_string_input();\n            fpurge(stdout);\n            iVar4 = dup2(local_14c,1);\n            iVar7 = local_14c;\n            if (iVar4 < 0) {\n              sys_error(&DAT_002102da,\"command_substitute: cannot duplicate pipe as fd 1\");\n                    /* WARNING: Subroutine does not return */\n              exit(1);\n            }\n            iVar6 = fileno(stdin);\n            iVar4 = local_14c;\n            if (((iVar7 != iVar6) && (iVar6 = fileno(stdout), iVar7 = local_14c, iVar4 != iVar6)) &&\n               (iVar4 = fileno(stderr), iVar7 != iVar4)) {\n              close(local_14c);\n            }\n            iVar7 = local_150;\n            iVar6 = fileno(stdin);\n            iVar4 = local_150;\n            if (((iVar7 != iVar6) && (iVar6 = fileno(stdout), iVar7 = local_150, iVar4 != iVar6)) &&\n               (iVar4 = fileno(stderr), iVar7 != iVar4)) {\n              close(local_150);\n            }\n            subshell_environment = subshell_environment | 4;\n            change_flag(0x76,0x2b);\n            if (inherit_errexit == 0) {\n              builtin_ignoring_errexit = 0;\n              change_flag(0x65,0x2b);\n            }\n            set_shellopts();\n            if (expanding_redir != 0) {\n              flush_temporary_env();\n              expanding_redir = 0;\n            }\n            FUN_0016fe00(param_1);\n            if (expand_aliases != 0) {\n              expand_aliases = (uint)(posixly_correct == 0);\n            }\n            startup_state = 2;\n            parse_and_execute_level = 0;\n            local_15c = __sigsetjmp(top_level,0);\n            if (local_15c == 0) {\n              if (return_catch_flag != 0) {\n                local_15c = 0;\n                iVar7 = __sigsetjmp(return_catch,0);\n                goto LAB_00172c69;\n              }\n            }\n            else {\n              iVar7 = 0;\nLAB_00172c69:\n              iVar4 = last_command_exit_value;\n              if (((local_15c == 4) || (local_15c == 3)) ||\n                 ((local_15c == 6 ||\n                  ((iVar4 = 1, local_15c != 0 || (iVar4 = return_catch_value, iVar7 != 0))))))\n              goto LAB_00172c40;\n            }\n            subshell_level = subshell_level + 1;\n            iVar4 = parse_and_execute(param_1,\"command substitution\",local_160 | 4);\nLAB_00172c40:\n            last_command_exit_value = iVar4;\n            iVar7 = run_exit_trap();\n            if (DAT_00247834 != 0) {\n              FUN_00168fd0();\n            }\n                    /* WARNING: Subroutine does not return */\n            exit(iVar7);\n          }\n          pipeline_pgrp = iVar7;\n          if (-1 < iVar4) {\n            close_pgrp_pipe();\n            close(local_14c);\n            begin_unwind_frame(\"read-comsub\");\n            add_unwind_protect(PTR_close_00237f50,local_150);\n            sigemptyset(&local_148);\n            sigaddset(&local_148,2);\n            sigemptyset(&local_c8);\n            sigprocmask(0,&local_148,&local_c8);\n            local_154 = 0;\n            uVar9 = FUN_00168020(local_150,param_2,param_3,&local_154);\n            close(local_150);\n            discard_unwind_frame(\"read-comsub\");\n            sigprocmask(2,&local_c8,(sigset_t *)0x0);\n            current_command_subst_pid = iVar4;\n            last_command_exit_value = wait_for(iVar4,0x100);\n            last_made_pid = uVar2;\n            last_command_subst_pid = iVar4;\n            if ((last_command_exit_value == 0x82) && (last_command_exit_signal == 2)) {\n              _Var5 = getpid();\n              kill(_Var5,2);\n            }\n            puVar10 = (undefined8 *)alloc_word_desc();\n            *puVar10 = uVar9;\n            *(undefined4 *)(puVar10 + 1) = local_154;\n            goto LAB_00172673;\n          }\n          sys_error(\"cannot make child for command substitution\");\n        }\n        last_made_pid = uVar2;\n        close(local_150);\n        close(local_14c);\n        break;\n      }\n    }\n  }\n  puVar10 = (undefined8 *)0x0;\nLAB_00172673:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar10;\n}\n\n",
  "FUN_00138940": "\nchar * FUN_00138940(undefined4 param_1,int *param_2)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined4 uVar4;\n  int iVar5;\n  int iVar6;\n  char *__s;\n  size_t sVar7;\n  undefined *puVar8;\n  undefined4 unaff_EBX;\n  char *pcVar9;\n  long in_FS_OFFSET;\n  bool bVar10;\n  undefined auStack_148 [32];\n  int local_128;\n  uint local_e8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar5 = FUN_00137960(1);\n  iVar6 = iVar5;\n  if ((DAT_00240da8 != 0) && (DAT_00240da0 != 0)) {\n    *(char *)(DAT_00240da8 + -1 + DAT_00240da0) = (char)iVar5;\n    DAT_00240da0 = DAT_00240da0 + -1;\n    iVar6 = DAT_00240b34;\n  }\n  DAT_00240b34 = iVar6;\n  if (iVar5 == 0x28) {\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      pcVar9 = (char *)FUN_00138cc0(param_1,0x28,0x29,param_2,0);\n      return pcVar9;\n    }\n    goto LAB_00138cb1;\n  }\n  save_parser_state(auStack_148);\n  uVar4 = extended_glob;\n  uVar1 = global_command;\n  shell_eof_token = 0x29;\n  need_here_doc = 0;\n  global_command = 0;\n  DAT_00240b18 = 0;\n  DAT_00240b1c = 0;\n  if (expand_aliases != 0) {\n    expand_aliases = (uint)(posixly_correct != 0);\n  }\n  bVar10 = (parser_state & 0x1000) == 0;\n  if ((shell_compatibility_level < 0x34) && (bVar10)) {\n    DAT_00240d64 = extended_glob;\n    extended_glob = 1;\n    unaff_EBX = uVar4;\n  }\n  current_token = 10;\n  DAT_00240b58 = 0x130;\n  parser_state = parser_state & 0xfff6ccdc | 0x408040;\n  iVar6 = yyparse();\n  if (0 < need_here_doc) {\n    puVar8 = &DAT_00213d70;\n    if (need_here_doc != 1) {\n      puVar8 = &DAT_002102db;\n    }\n    internal_warning(\"command substitution: %d unterminated here-document%s\",need_here_doc,puVar8);\n    gather_here_documents();\n  }\n  uVar3 = pushed_string_list;\n  uVar2 = global_command;\n  if ((shell_compatibility_level < 0x34) && (bVar10)) {\n    extended_glob = unaff_EBX;\n  }\n  if (EOF_Reached == 0) {\n    if (iVar6 != 0) {\n      if (last_command_exit_value == 0) {\n        last_command_exit_value = 1;\n      }\n      set_exit_status(last_command_exit_value);\n      if (interactive_shell == 0) {\n                    /* WARNING: Subroutine does not return */\n        jump_to_top_level(1);\n      }\n      shell_eof_token = local_128;\n      expand_aliases = local_e8;\n                    /* WARNING: Subroutine does not return */\n      jump_to_top_level(2);\n    }\n    if (current_token != shell_eof_token) {\n      DAT_00240b58 = current_token;\n      goto LAB_00138b78;\n    }\n    restore_parser_state(auStack_148);\n    pushed_string_list = uVar3;\n    __s = (char *)print_comsub(uVar2);\n    sVar7 = strlen(__s);\n    iVar6 = (uint)(*__s == '(') + (int)sVar7;\n    pcVar9 = (char *)sh_xmalloc((long)(iVar6 + 2),\"/usr/local/src/chet/src/bash/src/parse.y\",0x1067)\n    ;\n    if (*__s == '(') {\n      *pcVar9 = ' ';\n      strcpy(pcVar9 + 1,__s);\n    }\n    else {\n      strcpy(pcVar9,__s);\n    }\n    pcVar9[iVar6] = ')';\n    pcVar9[iVar6 + 1] = '\\0';\n    dispose_command(uVar2);\n    global_command = uVar1;\n    *param_2 = iVar6 + 1;\n  }\n  else {\nLAB_00138b78:\n    pcVar9 = &DAT_00240b10;\n    shell_eof_token = local_128;\n    expand_aliases = local_e8;\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pcVar9;\n  }\nLAB_00138cb1:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_keyseq_chain_dispose": "\nvoid _rl_keyseq_chain_dispose(void)\n\n{\n  if (_rl_kscxt == 0) {\n    return;\n  }\n  do {\n    _rl_kscxt = *(long *)(_rl_kscxt + 0x20);\n    xfree();\n  } while (_rl_kscxt != 0);\n  return;\n}\n\n",
  "rl_callback_handler_remove": "\nvoid rl_callback_handler_remove(void)\n\n{\n  rl_readline_state = rl_readline_state & 0xfffffffffff7ffff;\n  rl_linefunc = 0;\n  if (_rl_caught_signal != 0) {\n    _rl_signal_handler(_rl_caught_signal);\n  }\n  if (DAT_0024b508 != 0) {\n    DAT_0024b508 = 0;\n    if (rl_deprep_term_function != (undefined *)0x0) {\n      (*(code *)rl_deprep_term_function)();\n    }\n    rl_clear_signals();\n    return;\n  }\n  return;\n}\n\n",
  "FUN_0015e860": "\nvoid FUN_0015e860(ulong param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  lVar2 = (long)DAT_00238790;\n  iVar1 = (int)param_1;\n  if (DAT_00238790 == iVar1) {\n    lVar2 = (long)DAT_00238794;\n  }\n  else {\n    DAT_00238794 = DAT_00238790;\n    DAT_00238790 = iVar1;\n  }\n  if (((((int)lVar2 != -1) && (iVar1 != (int)lVar2)) &&\n      (lVar2 = *(long *)(jobs + lVar2 * 8), lVar2 != 0)) && (*(int *)(lVar2 + 0x14) == 2)) {\n    return;\n  }\n  iVar1 = *(int *)(*(long *)(jobs + (long)iVar1 * 8) + 0x14);\n  if (iVar1 == 2) {\n    iVar1 = FUN_0015e790(param_1,2);\n    if (iVar1 != -1) {\n      DAT_00238794 = iVar1;\n      return;\n    }\n    param_1 = (ulong)DAT_00238790;\n    iVar1 = *(int *)(*(long *)(jobs + param_1 * 8) + 0x14);\n  }\n  if (iVar1 != 1) {\n    param_1 = (ulong)DAT_0023877c;\n  }\n  DAT_00238794 = FUN_0015e790(param_1,1);\n  if (DAT_00238794 != -1) {\n    return;\n  }\n  DAT_00238794 = DAT_00238790;\n  return;\n}\n\n",
  "bash_delete_history_range": "\nundefined8 bash_delete_history_range(void)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long lVar3;\n  int iVar4;\n  \n  plVar2 = (long *)remove_history_range();\n  if (plVar2 != (long *)0x0) {\n    if (*plVar2 == 0) {\n      iVar4 = 0;\n    }\n    else {\n      lVar3 = 1;\n      do {\n        free_history_entry();\n        iVar4 = (int)lVar3;\n        plVar1 = plVar2 + lVar3;\n        lVar3 = lVar3 + 1;\n      } while (*plVar1 != 0);\n    }\n    sh_xfree(plVar2,\"bashhist.c\",0x17d);\n    history_lines_this_session = history_lines_this_session - iVar4;\n    return 1;\n  }\n  return 0;\n}\n\n",
  "tilde_expand": "\nlong tilde_expand(char *param_1)\n\n{\n  char *__s;\n  undefined *puVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  size_t sVar5;\n  size_t __n;\n  int iVar6;\n  char *pcVar7;\n  uint uVar8;\n  ulong uVar9;\n  char **ppcVar10;\n  bool bVar11;\n  long local_68;\n  uint local_60;\n  int local_5c;\n  \n  pcVar4 = strchr(param_1,0x7e);\n  sVar5 = strlen(param_1);\n  if (pcVar4 == (char *)0x0) {\n    local_5c = (int)sVar5 + 1;\n    local_68 = xmalloc((long)local_5c);\n  }\n  else {\n    local_5c = (int)sVar5 + 0x10;\n    local_68 = xmalloc((long)local_5c);\n  }\n  iVar6 = 0;\n  do {\n    puVar1 = tilde_additional_prefixes;\n    sVar5 = strlen(param_1);\n    if ((*param_1 == '\\0') || (*param_1 == '~')) {\n      sVar5 = 0;\n      local_60 = 0;\n      pcVar4 = param_1;\n      iVar2 = iVar6;\n    }\n    else {\n      local_60 = (uint)sVar5;\n      if ((puVar1 != (undefined *)0x0) && (0 < (int)local_60)) {\n        pcVar4 = *(char **)puVar1;\n        uVar9 = 0;\n        do {\n          pcVar7 = pcVar4;\n          ppcVar10 = (char **)puVar1;\n          while (pcVar7 != (char *)0x0) {\n            ppcVar10 = ppcVar10 + 1;\n            sVar5 = strlen(pcVar7);\n            iVar2 = strncmp(param_1 + uVar9,pcVar7,sVar5);\n            if (iVar2 == 0) {\n              local_60 = (int)uVar9 + -1 + (int)sVar5;\n              goto LAB_001f7325;\n            }\n            pcVar7 = *ppcVar10;\n          }\n          bVar11 = local_60 - 1 != uVar9;\n          uVar9 = uVar9 + 1;\n        } while (bVar11);\n      }\nLAB_001f7325:\n      iVar2 = local_60 + iVar6;\n      sVar5 = (size_t)(int)local_60;\n      pcVar4 = param_1 + sVar5;\n    }\n    if (local_5c <= iVar2) {\n      local_5c = local_5c + 0x14 + local_60;\n      local_68 = xrealloc(local_68,(long)(local_5c + 1));\n    }\n    strncpy((char *)(iVar6 + local_68),param_1,sVar5);\n    puVar1 = tilde_additional_suffixes;\n    sVar5 = strlen(pcVar4);\n    if ((int)(uint)sVar5 < 1) {\n      uVar8 = 0;\nLAB_001f7444:\n      if (local_60 == 0) {\n        *(char *)(iVar6 + local_68) = '\\0';\n        return local_68;\n      }\n    }\n    else {\n      uVar8 = 0;\n      pcVar7 = pcVar4;\n      do {\n        if (*pcVar7 == '/') {\nLAB_001f7440:\n          local_60 = local_60 | uVar8;\n          goto LAB_001f7444;\n        }\n        ppcVar10 = (char **)puVar1;\n        if (puVar1 != (undefined *)0x0) {\n          while (__s = *ppcVar10, __s != (char *)0x0) {\n            __n = strlen(__s);\n            iVar3 = strncmp(pcVar7,__s,__n);\n            ppcVar10 = ppcVar10 + 1;\n            if (iVar3 == 0) goto LAB_001f7440;\n          }\n        }\n        uVar8 = uVar8 + 1;\n        pcVar7 = pcVar7 + 1;\n      } while ((uint)sVar5 != uVar8);\n    }\n    sVar5 = (size_t)(int)uVar8;\n    pcVar7 = (char *)xmalloc((long)(int)(uVar8 + 1));\n    strncpy(pcVar7,pcVar4,sVar5);\n    pcVar7[sVar5] = '\\0';\n    param_1 = pcVar4 + sVar5;\n    pcVar4 = (char *)tilde_expand_word(pcVar7);\n    if (pcVar4 != (char *)0x0) {\n      xfree(pcVar7);\n      pcVar7 = pcVar4;\n    }\n    sVar5 = strlen(pcVar7);\n    iVar6 = iVar2 + (int)sVar5;\n    if (local_5c <= iVar6) {\n      local_5c = local_5c + 0x14 + (int)sVar5;\n      local_68 = xrealloc(local_68,(long)(local_5c + 1));\n    }\n    strcpy((char *)(iVar2 + local_68),pcVar7);\n    xfree(pcVar7);\n  } while( true );\n}\n\n",
  "FUN_0015f710": "\nundefined8 FUN_0015f710(long param_1,undefined8 param_2,int param_3,undefined4 param_4)\n\n{\n  if ((param_3 != -1) && (*(int *)(param_1 + 0x14) != param_3)) {\n    return 0;\n  }\n  FUN_0015f5f0(param_4,param_2,stdout);\n  return 0;\n}\n\n",
  "regcomp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint regcomp(regex_t *__preg,char *__pattern,int __cflags)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_regcomp_00237aa8)();\n  return iVar1;\n}\n\n",
  "update_export_env_inplace": "\nvoid update_export_env_inplace(char *param_1,int param_2,char *param_3)\n\n{\n  long lVar1;\n  char *__dest;\n  size_t sVar2;\n  \n  lVar1 = (long)param_2 + 1;\n  if (param_3 == (char *)0x0) {\n    __dest = (char *)sh_xmalloc(lVar1,\"variables.c\",0x144c);\n    strcpy(__dest,param_1);\n  }\n  else {\n    sVar2 = 0;\n    if (((*param_3 != '\\0') && (sVar2 = 1, param_3[1] != '\\0')) && (sVar2 = 2, param_3[2] != '\\0'))\n    {\n      sVar2 = strlen(param_3);\n    }\n    __dest = (char *)sh_xmalloc(sVar2 + lVar1,\"variables.c\",0x144c);\n    strcpy(__dest,param_1);\n    strcpy(__dest + param_2,param_3);\n  }\n  export_env = add_or_supercede_exported_var(__dest,0);\n  return;\n}\n\n",
  "FUN_00151920": "\nundefined8 FUN_00151920(undefined8 param_1,char *param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined4 local_18 [2];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((param_2 == (char *)0x0) || (*param_2 == '\\0')) ||\n     (iVar1 = legal_number(param_2,local_18), iVar1 == 0)) {\n    local_18[0] = 0;\n  }\n  subshell_level = local_18[0];\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return param_1;\n}\n\n",
  "_hs_history_patsearch": "\nundefined4 _hs_history_patsearch(char *param_1,undefined4 param_2,uint param_3)\n\n{\n  undefined4 uVar1;\n  size_t sVar2;\n  char *pcVar3;\n  long lVar4;\n  size_t sVar5;\n  int iVar6;\n  int iVar7;\n  char *__dest;\n  size_t sVar8;\n  \n  sVar2 = strlen(param_1);\n  iVar6 = (int)sVar2 + -1;\n  lVar4 = (long)iVar6;\n  if (param_1[lVar4] == '\\\\') {\n    iVar7 = 1;\n    if (0 < iVar6) {\n      do {\n        if (param_1[lVar4 + -1] != '\\\\') break;\n        lVar4 = lVar4 + -1;\n        iVar7 = 1 - iVar7;\n      } while (0 < (int)lVar4);\n      if (iVar7 == 0) goto LAB_001f6536;\n    }\n    uVar1 = 0xffffffff;\n  }\n  else {\nLAB_001f6536:\n    pcVar3 = (char *)xmalloc(sVar2 + 3);\n    if (((param_3 & 1) == 0) && (*param_1 != '*')) {\n      *pcVar3 = '*';\n      __dest = pcVar3 + 1;\n      sVar8 = sVar2 + 1;\n      sVar5 = sVar2;\n    }\n    else {\n      sVar5 = sVar2 - 1;\n      __dest = pcVar3;\n      sVar8 = sVar2;\n    }\n    strcpy(__dest,param_1);\n    if (pcVar3[sVar5] != '*') {\n      pcVar3[sVar8] = '*';\n      pcVar3[sVar8 + 1] = '\\0';\n    }\n    uVar1 = FUN_001f6220(pcVar3,param_2,param_3 | 2);\n    if (param_1 != pcVar3) {\n      xfree(pcVar3);\n    }\n  }\n  return uVar1;\n}\n\n",
  "getgid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__gid_t getgid(void)\n\n{\n  __gid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_getgid_00237ba8)();\n  return _Var1;\n}\n\n",
  "ttyname": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * ttyname(int __fd)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_ttyname_00237c90)();\n  return pcVar1;\n}\n\n",
  "FUN_001da1c0": "\nundefined * FUN_001da1c0(long param_1,ulong param_2,undefined *param_3,int *param_4)\n\n{\n  ulong uVar1;\n  byte bVar2;\n  char *pcVar3;\n  \n  if (param_3 == (undefined *)0x0) {\n    param_3 = _rl_keymap;\n  }\n  if ((param_1 != 0) && (uVar1 = 0, param_2 != 0)) {\n    while( true ) {\n      bVar2 = *(byte *)(param_1 + uVar1);\n      if (((char)bVar2 < '\\0') && (_rl_convert_meta_chars_to_ascii != 0)) {\n        pcVar3 = param_3 + 0x1b0;\n        param_3 = *(undefined **)(param_3 + 0x1b8);\n        if (*pcVar3 != '\\x01') {\n          if (param_4 == (int *)0x0) {\n            return param_3;\n          }\n          *param_4 = (int)*pcVar3;\n          return param_3;\n        }\n        bVar2 = bVar2 & 0x7f;\n      }\n      uVar1 = uVar1 + 1;\n      pcVar3 = param_3 + (ulong)bVar2 * 0x10;\n      if (*pcVar3 != '\\x01') break;\n      param_3 = *(undefined **)(pcVar3 + 8);\n      if (uVar1 == param_2) {\n        if (param_4 == (int *)0x0) {\n          return param_3;\n        }\n        *param_4 = 1;\n        return param_3;\n      }\n    }\n    if (uVar1 < param_2) {\n      return (undefined *)0x0;\n    }\n    if (param_4 != (int *)0x0) {\n      *param_4 = (int)*pcVar3;\n    }\n    return *(undefined **)(pcVar3 + 8);\n  }\n  return (undefined *)0x0;\n}\n\n",
  "init_bash_argv": "\nvoid init_bash_argv(void)\n\n{\n  undefined8 uVar1;\n  \n  if (bash_argv_initialized != 0) {\n    return;\n  }\n  uVar1 = list_rest_of_args();\n  push_args(uVar1);\n  dispose_words(uVar1);\n  bash_argv_initialized = 1;\n  return;\n}\n\n",
  "find_variable_tempenv": "\nvoid find_variable_tempenv(undefined8 param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = FUN_00152c60(param_1,1);\n  if ((lVar1 != 0) && ((*(byte *)(lVar1 + 0x29) & 8) != 0)) {\n    find_variable_nameref(lVar1);\n    return;\n  }\n  return;\n}\n\n",
  "initialize_terminating_signals": "\nvoid initialize_terminating_signals(void)\n\n{\n  if (DAT_0024853c != 0) {\n    return;\n  }\n  FUN_00185700();\n  return;\n}\n\n",
  "__strcpy_chk": "\nvoid __strcpy_chk(void)\n\n{\n  (*(code *)PTR___strcpy_chk_00237c98)();\n  return;\n}\n\n",
  "_rl_savestring": "\nvoid _rl_savestring(char *param_1)\n\n{\n  size_t sVar1;\n  char *__dest;\n  \n  sVar1 = strlen(param_1);\n  __dest = (char *)xmalloc((long)((int)sVar1 + 1));\n  strcpy(__dest,param_1);\n  return;\n}\n\n",
  "ansic_wshouldquote": "\nundefined8 ansic_wshouldquote(char *param_1)\n\n{\n  wint_t __wc;\n  int iVar1;\n  size_t sVar2;\n  wint_t *pwVar3;\n  wint_t *pwVar4;\n  \n  sVar2 = mbstowcs((wchar_t *)0x0,param_1,0);\n  if (sVar2 != 0xffffffffffffffff) {\n    pwVar3 = (wint_t *)sh_xmalloc((sVar2 + 1) * 4,\"strtrans.c\",0x14e);\n    __mbstowcs_chk(pwVar3,param_1,sVar2 + 1,0x3fffffffffffffff);\n    __wc = *pwVar3;\n    pwVar4 = pwVar3;\n    while( true ) {\n      if (__wc == 0) {\n        sh_xfree(pwVar3,\"strtrans.c\",0x158);\n        return 0;\n      }\n      iVar1 = iswprint(__wc);\n      if (iVar1 == 0) break;\n      __wc = pwVar4[1];\n      pwVar4 = pwVar4 + 1;\n    }\n    sh_xfree(pwVar3,\"strtrans.c\",0x154);\n  }\n  return 1;\n}\n\n",
  "clear_hostname_list": "\nvoid clear_hostname_list(void)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  if (hostname_list_initialized != 0) {\n    if (0 < DAT_00248858) {\n      lVar2 = 0;\n      do {\n        lVar1 = lVar2 * 8;\n        lVar2 = lVar2 + 1;\n        sh_xfree(*(undefined8 *)(DAT_00248860 + lVar1),\"bashline.c\",0x372);\n      } while ((int)lVar2 < DAT_00248858);\n    }\n    hostname_list_initialized = 0;\n    DAT_00248858 = 0;\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001af740": "\nvoid FUN_001af740(void)\n\n{\n  if ((rl_attempted_completion_function == 0) && (DAT_00248ba0 != 0)) {\n    rl_attempted_completion_function = DAT_00248ba0;\n    return;\n  }\n  return;\n}\n\n",
  "sh_invalidopt": "\nvoid sh_invalidopt(undefined8 param_1)\n\n{\n  builtin_error(\"%s: invalid option\",param_1);\n  return;\n}\n\n",
  "FUN_00191d90": "\nundefined8 FUN_00191d90(undefined8 param_1)\n\n{\n  setup_ignore_patterns(&PTR_s_FIGNORE_00238d60);\n  if (DAT_00238d70 != 0) {\n    FUN_00191ae0(param_1,FUN_001916e0);\n  }\n  return 0;\n}\n\n",
  "rl_undo_command": "\nundefined8 rl_undo_command(int param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 < 1) {\n    return 0;\n  }\n  do {\n    iVar1 = rl_do_undo();\n    if (iVar1 == 0) {\n      rl_ding();\n      return 0;\n    }\n    param_1 = param_1 + -1;\n  } while (param_1 != 0);\n  return 0;\n}\n\n",
  "FUN_001dbcb0": "\nundefined8 FUN_001dbcb0(char *param_1)\n\n{\n  size_t sVar1;\n  \n  if (param_1 == (char *)0x0) {\n    if (_rl_emacs_mode_str != (undefined *)0x0) {\n      free(_rl_emacs_mode_str);\n    }\n    _rl_emacs_mode_str = (undefined *)0x0;\n    _rl_emacs_modestr_len = 0;\n    return 0;\n  }\n  if (*param_1 == '\\0') {\n    if (_rl_emacs_mode_str != (undefined *)0x0) {\n      free(_rl_emacs_mode_str);\n    }\n    _rl_emacs_mode_str = (undefined *)xmalloc(1);\n    _rl_emacs_modestr_len = 0;\n    *_rl_emacs_mode_str = 0;\n    return 0;\n  }\n  if (_rl_emacs_mode_str != (undefined *)0x0) {\n    free(_rl_emacs_mode_str);\n  }\n  sVar1 = strlen(param_1);\n  _rl_emacs_mode_str = (undefined *)xmalloc(sVar1 * 2 + 1);\n  rl_translate_keyseq(param_1,_rl_emacs_mode_str,&_rl_emacs_modestr_len);\n  *(undefined *)((long)_rl_emacs_mode_str + (long)_rl_emacs_modestr_len) = 0;\n  return 0;\n}\n\n",
  "rl_callback_read_char": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid rl_callback_read_char(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  uint uVar3;\n  undefined8 uVar4;\n  \n  if (rl_linefunc == (code *)0x0) {\n    _rl_errmsg(\"readline_callback_read_char() called with no handler!\");\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  _DAT_0024b480 = _rl_top_level._64_4_;\n  DAT_0024b480_4 = _rl_top_level._68_4_;\n  uRam000000000024b488._0_4_ = _rl_top_level._72_4_;\n  uRam000000000024b488._4_4_ = _rl_top_level._76_4_;\n  _DAT_0024b490 = _rl_top_level._80_4_;\n  DAT_0024b490_4 = _rl_top_level._84_4_;\n  uRam000000000024b498._0_4_ = _rl_top_level._88_4_;\n  uRam000000000024b498._4_4_ = _rl_top_level._92_4_;\n  _DAT_0024b440 = _rl_top_level._0_4_;\n  uRam000000000024b444 = _rl_top_level._4_4_;\n  uRam000000000024b448 = _rl_top_level._8_4_;\n  uRam000000000024b44c = _rl_top_level._12_4_;\n  _DAT_0024b4a0 = _rl_top_level._96_4_;\n  DAT_0024b4a0_4 = _rl_top_level._100_4_;\n  uRam000000000024b4a8._0_4_ = _rl_top_level._104_4_;\n  uRam000000000024b4a8._4_4_ = _rl_top_level._108_4_;\n  _DAT_0024b4b0 = _rl_top_level._112_4_;\n  DAT_0024b4b0_4 = _rl_top_level._116_4_;\n  uRam000000000024b4b8._0_4_ = _rl_top_level._120_4_;\n  uRam000000000024b4b8._4_4_ = _rl_top_level._124_4_;\n  _DAT_0024b450 = _rl_top_level._16_4_;\n  uRam000000000024b454 = _rl_top_level._20_4_;\n  uRam000000000024b458 = _rl_top_level._24_4_;\n  uRam000000000024b45c = _rl_top_level._28_4_;\n  _DAT_0024b4d0 = _rl_top_level._144_4_;\n  DAT_0024b4d0_4 = _rl_top_level._148_4_;\n  uRam000000000024b4d8._0_4_ = _rl_top_level._152_4_;\n  uRam000000000024b4d8._4_4_ = _rl_top_level._156_4_;\n  _DAT_0024b460 = _rl_top_level._32_4_;\n  uRam000000000024b464 = _rl_top_level._36_4_;\n  uRam000000000024b468 = _rl_top_level._40_4_;\n  uRam000000000024b46c = _rl_top_level._44_4_;\n  _DAT_0024b4e0 = _rl_top_level._160_4_;\n  DAT_0024b4e0_4 = _rl_top_level._164_4_;\n  uRam000000000024b4e8._0_4_ = _rl_top_level._168_4_;\n  uRam000000000024b4e8._4_4_ = _rl_top_level._172_4_;\n  _DAT_0024b470 = _rl_top_level._48_4_;\n  uRam000000000024b474 = _rl_top_level._52_4_;\n  uRam000000000024b478 = _rl_top_level._56_4_;\n  uRam000000000024b47c = _rl_top_level._60_4_;\n  _DAT_0024b4f0 = _rl_top_level._176_4_;\n  DAT_0024b4f0_4 = _rl_top_level._180_4_;\n  uRam000000000024b4f8._0_4_ = _rl_top_level._184_4_;\n  uRam000000000024b4f8._4_4_ = _rl_top_level._188_4_;\n  DAT_0024b500 = _rl_top_level._192_8_;\n  _DAT_0024b4c0 = _rl_top_level._128_8_;\n  uRam000000000024b4c8 = _rl_top_level._136_8_;\n  iVar2 = __sigsetjmp(_rl_top_level,0);\n  if (iVar2 == 0) {\n    if (rl_persistent_signal_handlers == 0) {\n      rl_set_signals();\n    }\n    do {\n      if (_rl_caught_signal != 0) {\n        _rl_signal_handler(_rl_caught_signal);\n        if ((rl_readline_state & 0x80) == 0) goto LAB_001ec2eb;\nLAB_001ec54a:\n        iVar2 = _rl_isearch_callback(_rl_iscxt);\n        if ((iVar2 == 0) && (((uint)rl_readline_state & 0x20080) == 0x20000)) {\nLAB_001ec71f:\n          rl_callback_read_char();\n        }\n        break;\n      }\n      if ((rl_readline_state & 0x80) != 0) goto LAB_001ec54a;\nLAB_001ec2eb:\n      if ((rl_readline_state & 0x100) != 0) {\n        _rl_nsearch_callback(_rl_nscxt);\n        break;\n      }\n      if ((rl_readline_state & 0x800000) == 0) {\n        if ((rl_readline_state & 0x100000) == 0) {\n          if ((rl_readline_state & 0x400) == 0) {\n            if ((rl_readline_state & 0x200000) == 0) {\n              if (_rl_callback_func == (code *)0x0) {\n                uVar3 = readline_internal_char();\n              }\n              else {\n                uVar3 = (*_rl_callback_func)(_rl_callback_data);\n                if (_rl_callback_func == (code *)0x0) {\n                  if (_rl_callback_data != 0) {\n                    xfree();\n                    _rl_callback_data = 0;\n                  }\n                  goto LAB_001ec25e;\n                }\n              }\n            }\n            else {\n              uVar3 = _rl_dispatch_callback(_rl_kscxt);\n              while( true ) {\n                if (uVar3 < 0xfffffffe) break;\n                if ((rl_readline_state & 0x200000) == 0) goto LAB_001ec64f;\n                if ((_rl_kscxt == (byte *)0x0) || ((*_rl_kscxt & 1) == 0)) goto LAB_001ec263;\n                uVar3 = _rl_dispatch_callback();\n              }\n              if ((rl_readline_state & 0x200000) == 0) {\nLAB_001ec64f:\n                _rl_internal_char_cleanup();\n                _rl_want_redisplay = 1;\n              }\n            }\n            goto LAB_001ec263;\n          }\n          iVar2 = _rl_arg_callback(_rl_argcxt);\n          if ((iVar2 == 0) && (((uint)rl_readline_state & 0x20400) == 0x20000)) goto LAB_001ec71f;\n        }\n        else {\n          _rl_vi_domove_callback(_rl_vimvcxt);\n        }\n        if ((rl_readline_state & 0x400) == 0) {\n          _rl_internal_char_cleanup();\n        }\n        break;\n      }\n      uVar1 = *(undefined4 *)(_rl_callback_data + 8);\n      uVar3 = (*_rl_callback_func)();\n      if ((_rl_callback_func == (code *)0x0) && (_rl_callback_data != 0)) {\n        xfree();\n        _rl_callback_data = 0;\n      }\n      if ((rl_readline_state & 0x100000) != 0) {\n        _rl_vi_domove_motion_cleanup(uVar1,_rl_vimvcxt);\n        _rl_internal_char_cleanup();\n        break;\n      }\nLAB_001ec25e:\n      _rl_internal_char_cleanup();\nLAB_001ec263:\n      if (_rl_caught_signal != 0) {\n        _rl_signal_handler(_rl_caught_signal);\n      }\n      if (rl_done == 0) {\n        if (_rl_want_redisplay == 0) {\n          if (0 < (int)uVar3) {\n            rl_readline_state = rl_readline_state | 0x8000000;\n            rl_eof_found = uVar3;\n          }\n        }\n        else {\n          (*(code *)rl_redisplay_function)();\n          _rl_want_redisplay = 0;\n          if (0 < (int)uVar3) goto LAB_001ec2a7;\nLAB_001ec2b8:\n          if (rl_done != 0) goto LAB_001ec488;\n        }\n      }\n      else {\n        if (0 < (int)uVar3) {\nLAB_001ec2a7:\n          rl_readline_state = rl_readline_state | 0x8000000;\n          rl_eof_found = uVar3;\n          goto LAB_001ec2b8;\n        }\nLAB_001ec488:\n        uVar4 = readline_internal_teardown(uVar3);\n        if (rl_deprep_term_function != (undefined *)0x0) {\n          (*(code *)rl_deprep_term_function)();\n        }\n        rl_clear_signals();\n        DAT_0024b508 = 0;\n        if (rl_linefunc == (code *)0x0) {\n          if (*rl_line_buffer != '\\0') goto LAB_001ec5e8;\n        }\n        else {\n          (*rl_linefunc)(uVar4);\n          if (*rl_line_buffer != '\\0') {\nLAB_001ec5e8:\n            _rl_init_line_state();\n          }\n          if ((DAT_0024b508 == 0) && (rl_linefunc != (code *)0x0)) {\n            FUN_001ec080();\n          }\n        }\n      }\n    } while (((rl_pending_input != 0) || (iVar2 = _rl_pushed_input_available(), iVar2 != 0)) ||\n            ((rl_readline_state & 0x800) != 0));\n  }\n  else {\n    (*(code *)rl_redisplay_function)();\n    _rl_want_redisplay = 0;\n    _rl_top_level._0_4_ = _DAT_0024b440;\n    _rl_top_level._4_4_ = uRam000000000024b444;\n    _rl_top_level._8_4_ = uRam000000000024b448;\n    _rl_top_level._12_4_ = uRam000000000024b44c;\n    _rl_top_level._16_4_ = _DAT_0024b450;\n    _rl_top_level._20_4_ = uRam000000000024b454;\n    _rl_top_level._24_4_ = uRam000000000024b458;\n    _rl_top_level._28_4_ = uRam000000000024b45c;\n    _rl_top_level._32_4_ = _DAT_0024b460;\n    _rl_top_level._36_4_ = uRam000000000024b464;\n    _rl_top_level._40_4_ = uRam000000000024b468;\n    _rl_top_level._44_4_ = uRam000000000024b46c;\n    _rl_top_level._48_4_ = _DAT_0024b470;\n    _rl_top_level._52_4_ = uRam000000000024b474;\n    _rl_top_level._56_4_ = uRam000000000024b478;\n    _rl_top_level._60_4_ = uRam000000000024b47c;\n    _rl_top_level._64_4_ = _DAT_0024b480;\n    _rl_top_level._68_4_ = DAT_0024b480_4;\n    _rl_top_level._72_4_ = (undefined4)uRam000000000024b488;\n    _rl_top_level._76_4_ = uRam000000000024b488._4_4_;\n    _rl_top_level._80_4_ = _DAT_0024b490;\n    _rl_top_level._84_4_ = DAT_0024b490_4;\n    _rl_top_level._88_4_ = (undefined4)uRam000000000024b498;\n    _rl_top_level._92_4_ = uRam000000000024b498._4_4_;\n    _rl_top_level._96_4_ = _DAT_0024b4a0;\n    _rl_top_level._100_4_ = DAT_0024b4a0_4;\n    _rl_top_level._104_4_ = (undefined4)uRam000000000024b4a8;\n    _rl_top_level._108_4_ = uRam000000000024b4a8._4_4_;\n    _rl_top_level._112_4_ = _DAT_0024b4b0;\n    _rl_top_level._116_4_ = DAT_0024b4b0_4;\n    _rl_top_level._120_4_ = (undefined4)uRam000000000024b4b8;\n    _rl_top_level._124_4_ = uRam000000000024b4b8._4_4_;\n    _rl_top_level._128_8_ = _DAT_0024b4c0;\n    _rl_top_level._136_8_ = uRam000000000024b4c8;\n    _rl_top_level._144_4_ = _DAT_0024b4d0;\n    _rl_top_level._148_4_ = DAT_0024b4d0_4;\n    _rl_top_level._152_4_ = (undefined4)uRam000000000024b4d8;\n    _rl_top_level._156_4_ = uRam000000000024b4d8._4_4_;\n    _rl_top_level._160_4_ = _DAT_0024b4e0;\n    _rl_top_level._164_4_ = DAT_0024b4e0_4;\n    _rl_top_level._168_4_ = (undefined4)uRam000000000024b4e8;\n    _rl_top_level._172_4_ = uRam000000000024b4e8._4_4_;\n    _rl_top_level._176_4_ = _DAT_0024b4f0;\n    _rl_top_level._180_4_ = DAT_0024b4f0_4;\n    _rl_top_level._184_4_ = (undefined4)uRam000000000024b4f8;\n    _rl_top_level._188_4_ = uRam000000000024b4f8._4_4_;\n    _rl_top_level._192_8_ = DAT_0024b500;\n    if ((rl_readline_state & 0x4000000) != 0) {\n      rl_done = 1;\n      rl_readline_state = rl_readline_state | 0x2000000;\n    }\n  }\n  if (rl_persistent_signal_handlers == 0) {\n    rl_clear_signals();\n  }\n  return;\n}\n\n",
  "procsub_waitpid": "\nulong procsub_waitpid(void)\n\n{\n  long lVar1;\n  ulong uVar2;\n  \n  lVar1 = procsub_search();\n  if (lVar1 == 0) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    if (*(int *)(lVar1 + 0x10) != 0) {\n      uVar2 = wait_for(*(undefined4 *)(lVar1 + 8),0);\n      return uVar2;\n    }\n    uVar2 = (ulong)*(uint *)(lVar1 + 0xc);\n  }\n  return uVar2;\n}\n\n",
  "uconvert": "\nundefined8 uconvert(char *param_1,long *param_2,long *param_3,char **param_4)\n\n{\n  char cVar1;\n  byte bVar2;\n  char *pcVar3;\n  long lVar4;\n  int iVar5;\n  long lVar6;\n  int iVar7;\n  char *pcVar8;\n  bool bVar9;\n  \n  if (param_1 == (char *)0x0) {\n    iVar7 = 1;\n    lVar4 = 0;\n  }\n  else {\n    cVar1 = *param_1;\n    iVar7 = 1;\n    if ((cVar1 - 0x2bU & 0xfd) == 0) {\n      bVar9 = cVar1 != '-';\n      cVar1 = param_1[1];\n      param_1 = param_1 + 1;\n      iVar7 = (bVar9 - 1) + (uint)bVar9;\n    }\n    lVar4 = 0;\n    while (cVar1 != '\\0') {\n      if (cVar1 == '.') {\n        pcVar3 = param_1 + 1;\n        lVar6 = 0;\n        iVar5 = 0;\n        pcVar8 = pcVar3;\n        goto LAB_001cb383;\n      }\n      if (9 < (byte)(cVar1 - 0x30U)) {\n        if (param_2 != (long *)0x0) {\n          *param_2 = iVar7 * lVar4;\n        }\n        if (param_3 != (long *)0x0) {\n          *param_3 = 0;\n        }\n        if (param_4 == (char **)0x0) {\n          return 0;\n        }\n        *param_4 = param_1;\n        return 0;\n      }\n      param_1 = param_1 + 1;\n      lVar4 = (long)(char)(cVar1 - 0x30U) + lVar4 * 10;\n      cVar1 = *param_1;\n    }\n  }\n  if (param_2 != (long *)0x0) {\n    *param_2 = iVar7 * lVar4;\n  }\n  if (param_3 != (long *)0x0) {\n    *param_3 = 0;\n  }\n  if (param_4 == (char **)0x0) {\n    return 1;\n  }\n  *param_4 = param_1;\n  return 1;\n  while( true ) {\n    bVar2 = *pcVar8 - 0x30;\n    if (9 < bVar2) {\n      if (param_4 != (char **)0x0) {\n        lVar6 = lVar6 * (int)(&DAT_00212930)[iVar5];\n        pcVar3 = pcVar8;\n      }\n      if (param_2 != (long *)0x0) {\n        *param_2 = iVar7 * lVar4;\n      }\n      if (param_3 != (long *)0x0) {\n        *param_3 = lVar6;\n      }\n      if (param_4 != (char **)0x0) {\n        *param_4 = pcVar3;\n      }\n      return 0;\n    }\n    iVar5 = iVar5 + 1;\n    pcVar8 = pcVar8 + 1;\n    lVar6 = (long)(char)bVar2 + lVar6 * 10;\n    if (iVar5 == 6) break;\nLAB_001cb383:\n    if (*pcVar8 == '\\0') {\n      lVar6 = lVar6 * (int)(&DAT_00212930)[iVar5];\n      goto LAB_001cb3c3;\n    }\n  }\n  lVar6 = lVar6 + (ulong)((byte)(param_1[7] - 0x35U) < 5);\nLAB_001cb3c3:\n  if (param_4 != (char **)0x0) {\n    pcVar3 = pcVar3 + iVar5;\n    cVar1 = *pcVar3;\n    while ((byte)(cVar1 - 0x30U) < 10) {\n      pcVar8 = pcVar3 + 1;\n      pcVar3 = pcVar3 + 1;\n      cVar1 = *pcVar8;\n    }\n  }\n  if (param_2 != (long *)0x0) {\n    *param_2 = iVar7 * lVar4;\n  }\n  if (param_3 != (long *)0x0) {\n    *param_3 = lVar6;\n  }\n  if (param_4 != (char **)0x0) {\n    *param_4 = pcVar3;\n  }\n  return 1;\n}\n\n",
  "_rl_init_terminal_io": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 _rl_init_terminal_io(char *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  undefined8 uVar4;\n  undefined **ppuVar5;\n  undefined *puVar6;\n  undefined8 *puVar7;\n  long in_FS_OFFSET;\n  bool bVar8;\n  uint local_4c;\n  void *local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (char *)0x0) {\n    iVar1 = 0;\n    param_1 = (char *)sh_get_env_value(\"TERM\");\n    _rl_term_clrscroll = 0;\n    _rl_term_clreol = 0;\n    _rl_term_cr = (undefined *)0x0;\n    _rl_term_clrpag = 0;\n    if (rl_instream != (FILE *)0x0) goto LAB_001ed219;\nLAB_001ed221:\n    if (param_1 != (char *)0x0) goto LAB_001ed22a;\n    bVar8 = true;\n    param_1 = \"dumb\";\n  }\n  else {\n    iVar1 = 0;\n    _rl_term_clrscroll = 0;\n    _rl_term_clreol = 0;\n    _rl_term_cr = (undefined *)0x0;\n    _rl_term_clrpag = 0;\n    if (rl_instream != (FILE *)0x0) {\nLAB_001ed219:\n      _rl_term_clreol = 0;\n      _rl_term_clrpag = 0;\n      _rl_term_clrscroll = 0;\n      _rl_term_cr = (undefined *)0x0;\n      iVar1 = fileno(rl_instream);\n      goto LAB_001ed221;\n    }\nLAB_001ed22a:\n    bVar8 = false;\n    if (*param_1 == 'd') {\n      iVar2 = strcmp(param_1,\"dumb\");\n      bVar8 = iVar2 == 0;\n    }\n  }\n  if ((code *)rl_redisplay_function == rl_redisplay) {\n    if (DAT_0024b670 == (void *)0x0) {\n      DAT_0024b670 = (void *)xmalloc(0x7f0);\n    }\n    if (DAT_0024b678 == (void *)0x0) {\n      DAT_0024b678 = (void *)xmalloc(0xff0);\n    }\n    local_48 = DAT_0024b670;\n    iVar2 = tgetent(DAT_0024b678,param_1);\n    if (iVar2 == 1) {\n      ppuVar5 = &PTR_DAT_00235a70;\n      puVar7 = &DAT_0024b5f0;\n      puVar6 = &DAT_00213d6c;\n      while( true ) {\n        uVar4 = tgetstr(puVar6,&local_48);\n        *puVar7 = uVar4;\n        if (ppuVar5 == &PTR_DAT_00235c80) break;\n        puVar6 = *ppuVar5;\n        puVar7 = (undefined8 *)ppuVar5[1];\n        ppuVar5 = ppuVar5 + 2;\n      }\n      PC = 0;\n      DAT_0024b668 = 1;\n      if (_rl_term_pc != (undefined *)0x0) {\n        PC = *_rl_term_pc;\n      }\n      BC = _rl_term_backspace;\n      UP = _rl_term_up;\n      if (_rl_term_cr == (undefined *)0x0) {\n        _rl_term_cr = &DAT_00213355;\n      }\n      iVar2 = tgetflag(&DAT_00213d71);\n      uVar3 = 0;\n      if (iVar2 == 1) {\n        iVar2 = tgetflag(&DAT_00213d74);\n        uVar3 = (uint)(iVar2 == 1);\n      }\n      _rl_term_autowrap = uVar3;\n      if ((_rl_screenwidth < 1) || (_rl_screenheight < 1)) {\n        _rl_get_screen_size(iVar1,0);\n      }\n      local_4c = 1;\n      if ((_rl_term_IC == 0) && (_rl_term_im == 0)) {\n        local_4c = (uint)(_rl_term_ic != 0);\n      }\n      _rl_terminal_can_insert = local_4c;\n      iVar1 = tgetflag(&DAT_00213d77);\n      DAT_0024b658 = (uint)(iVar1 == 1);\n      if (iVar1 != 1) {\n        DAT_0024b648 = 0;\n        DAT_0024b650 = 0;\n      }\n      FUN_001ec8e0(emacs_standard_keymap);\n      FUN_001ec8e0(vi_movement_keymap);\n      FUN_001ec8e0(&vi_insertion_keymap);\n      if (bVar8) {\n        _rl_enable_active_region = 0;\n        _rl_enable_bracketed_paste = 0;\n      }\n      _rl_reset_region_color(0,DAT_0024b640);\n      _rl_reset_region_color(1,DAT_0024b638);\n      goto LAB_001ed481;\n    }\n  }\n  if (DAT_0024b670 != (void *)0x0) {\n    free(DAT_0024b670);\n  }\n  if (DAT_0024b678 != (void *)0x0) {\n    free(DAT_0024b678);\n  }\n  local_48 = (void *)0x0;\n  DAT_0024b670 = (void *)0x0;\n  DAT_0024b678 = (void *)0x0;\n  _rl_term_autowrap = 0;\n  if (((_rl_screenwidth < 1) || (_rl_screenheight < 1)) &&\n     ((_rl_get_screen_size(iVar1,0), _rl_screenwidth < 1 || (_rl_screenheight < 1)))) {\n    _rl_screenwidth = 0x4f;\n    _rl_screenchars = 0x768;\n    _rl_screenheight = 0x18;\n  }\n  else {\n    _rl_screenchars = _rl_screenheight * _rl_screenwidth;\n  }\n  _rl_term_cr = &DAT_00213355;\n  _rl_term_IC = 0;\n  _rl_term_ic = 0;\n  _rl_term_ei = 0;\n  _rl_term_im = 0;\n  DAT_0024b660 = 0;\n  _rl_term_DC = 0;\n  _rl_term_dc = 0;\n  _rl_term_up = 0;\n  DAT_0024b620 = 0;\n  DAT_0024b618 = 0;\n  DAT_0024b628 = 0;\n  DAT_0024b630 = 0;\n  DAT_0024b5e8 = 0;\n  DAT_0024b5e0 = 0;\n  _DAT_0024b5f8 = 0;\n  DAT_0024b600 = 0;\n  DAT_0024b5f0 = 0;\n  DAT_0024b608 = 0;\n  DAT_0024b610 = 0;\n  DAT_0024b5d8 = 0;\n  DAT_0024b5d0 = 0;\n  DAT_0024b648 = 0;\n  DAT_0024b650 = 0;\n  DAT_0024b5c8 = 0;\n  DAT_0024b5c0 = 0;\n  _rl_term_forward_char = 0;\n  DAT_0024b638 = 0;\n  DAT_0024b640 = 0;\n  DAT_0024b658 = 0;\n  _rl_terminal_can_insert = 0;\n  _rl_enable_bracketed_paste = 0;\n  _rl_enable_active_region = 0;\n  xfree(_rl_active_region_start_color);\n  _rl_active_region_start_color = 0;\n  xfree(_rl_active_region_end_color);\n  _rl_active_region_end_color = 0;\n  _rl_term_backspace = &DAT_00213d6f;\n  BC = &DAT_00213d6f;\n  PC = 0;\n  UP = _rl_term_up;\nLAB_001ed481:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 0;\n}\n\n",
  "sigint_sighandler": "\nvoid sigint_sighandler(int param_1)\n\n{\n  int iVar1;\n  \n  if (interrupt_state == 0) {\n    interrupt_state = 1;\n  }\n  if (wait_intr_flag != 0) {\n    last_command_exit_value = param_1 + 0x80;\n    set_pipestatus_from_exit(last_command_exit_value);\n    wait_signal_received = param_1;\n    return;\n  }\n  iVar1 = signal_is_trapped(param_1);\n  if (iVar1 != 0) {\n    set_trap_state(param_1);\n  }\n  if (interrupt_immediately != 0) {\n    interrupt_immediately = 0;\n    set_exit_status(param_1 + 0x80);\n    throw_to_top_level();\n    return;\n  }\n  if ((rl_readline_state._1_1_ & 0x80) != 0) {\n    bashline_set_event_hook();\n    return;\n  }\n  return;\n}\n\n",
  "shift_args": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid shift_args(int param_1)\n\n{\n  char *__s;\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  undefined8 *puVar3;\n  size_t sVar4;\n  char *__dest;\n  bool bVar5;\n  \n  if (0 < param_1) {\n    param_1 = param_1 + -1;\n    do {\n      if (DAT_00242228 != 0) {\n        sh_xfree(DAT_00242228,\"common.c\",0x1b6);\n      }\n      puVar2 = &DAT_00242228;\n      do {\n        puVar3 = puVar2 + 1;\n        *puVar2 = puVar2[1];\n        puVar1 = rest_of_args;\n        puVar2 = puVar3;\n      } while (puVar3 != (undefined8 *)&DAT_00242268);\n      if (rest_of_args == (undefined8 *)0x0) {\n        _DAT_00242268 = (char *)0x0;\n      }\n      else {\n        __s = *(char **)rest_of_args[1];\n        sVar4 = strlen(__s);\n        __dest = (char *)sh_xmalloc(sVar4 + 1,\"common.c\",0x1be);\n        _DAT_00242268 = strcpy(__dest,__s);\n        rest_of_args = (undefined8 *)*rest_of_args;\n        *puVar1 = 0;\n        dispose_words(puVar1);\n      }\n      posparam_count = posparam_count + -1;\n      bVar5 = param_1 != 0;\n      param_1 = param_1 + -1;\n    } while (bVar5);\n    return;\n  }\n  return;\n}\n\n",
  "test_binop": "\nuint test_binop(byte *param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  \n  bVar2 = *param_1;\n  if (bVar2 == 0x3d) {\n    bVar2 = param_1[1];\n    if (bVar2 == 0) {\n      return 1;\n    }\n  }\n  else {\n    if ((bVar2 & 0xfd) == 0x3c) {\n      return (uint)(param_1[1] == 0);\n    }\n    if (bVar2 != 0x21) {\n      if (bVar2 != 0x2d) {\n        return 0;\n      }\n      bVar2 = param_1[1];\n      if (bVar2 == 0) {\n        return 0;\n      }\n      bVar1 = param_1[2];\n      if (bVar1 == 0) {\n        return 0;\n      }\n      if (param_1[3] != 0) {\n        return 0;\n      }\n      if (bVar1 == 0x74) {\n        if ((byte)(bVar2 + 0x99) < 9) {\n          return (uint)(0x1a1L >> (bVar2 + 0x99 & 0x3f)) & 1;\n        }\n        return 0;\n      }\n      if (bVar2 == 0x65) {\n        if (bVar1 != 0x66) {\n          return (uint)(bVar1 == 0x71);\n        }\n        return 1;\n      }\n      if (bVar1 != 0x65) {\n        return 0;\n      }\n      if (7 < (byte)(bVar2 + 0x99)) {\n        return 0;\n      }\n      return (uint)(0xa1L >> (bVar2 + 0x99 & 0x3f)) & 1;\n    }\n    bVar2 = param_1[1];\n  }\n  if (bVar2 != 0x3d) {\n    return 0;\n  }\n  return (uint)(param_1[2] == 0);\n}\n\n",
  "make_coproc_command": "\nvoid make_coproc_command(char *param_1,undefined8 param_2)\n\n{\n  undefined4 *puVar1;\n  size_t sVar2;\n  char *pcVar3;\n  undefined8 *puVar4;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x18,\"make_cmd.c\",0x343);\n  sVar2 = strlen(param_1);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"make_cmd.c\",0x344);\n  pcVar3 = strcpy(pcVar3,param_1);\n  *(undefined8 *)(puVar1 + 4) = param_2;\n  *(char **)(puVar1 + 2) = pcVar3;\n  *puVar1 = 0x1001;\n  puVar4 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar4[3] = puVar1;\n  *puVar4 = 0xe;\n  *puVar1 = 0;\n  puVar4[2] = 0;\n  return;\n}\n\n",
  "FUN_0017f770": "\nvoid FUN_0017f770(undefined8 *param_1)\n\n{\n  sh_xfree(*param_1,\"hashcmd.c\",0x35);\n  sh_xfree(param_1,\"hashcmd.c\",0x36);\n  return;\n}\n\n",
  "sh_chkwrite": "\nundefined4 sh_chkwrite(undefined4 param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  char *pcVar3;\n  \n  if (terminating_signal == 0) {\n    if (interrupt_state == 0) goto LAB_001a407d;\n  }\n  else {\n    termsig_handler(terminating_signal);\n    if (interrupt_state == 0) goto LAB_001a407d;\n  }\n  throw_to_top_level();\nLAB_001a407d:\n  fflush(stdout);\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state == 0) {\n    iVar1 = ferror(stdout);\n  }\n  else {\n    throw_to_top_level();\n    iVar1 = ferror(stdout);\n  }\n  if (iVar1 == 0) {\n    return param_1;\n  }\n  piVar2 = __errno_location();\n  pcVar3 = strerror(*piVar2);\n  builtin_error(\"write error: %s\",pcVar3);\n  fpurge(stdout);\n  clearerr(stdout);\n  return 1;\n}\n\n",
  "disable_priv_mode": "\nvoid disable_priv_mode(void)\n\n{\n  int iVar1;\n  \n  iVar1 = setresuid(current_user,current_user,current_user);\n  if (iVar1 < 0) {\n    sys_error(\"cannot set uid to %d: effective uid %d\",current_user,DAT_00238044);\n  }\n  iVar1 = setresgid(DAT_00238048,DAT_00238048,DAT_00238048);\n  if (iVar1 < 0) {\n    sys_error(\"cannot set gid to %d: effective gid %d\",DAT_00238048,DAT_0023804c);\n  }\n  DAT_00238044 = current_user;\n  DAT_0023804c = DAT_00238048;\n  return;\n}\n\n",
  "FUN_001ab350": "\nundefined8 FUN_001ab350(long param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  lVar1 = printable_filename(**(undefined8 **)(param_1 + 0x10),1);\n  lVar2 = printable_filename(*(undefined8 *)(param_1 + 8),1);\n  __printf_chk(1,\"builtin hash -p %s %s\\n\",lVar1,lVar2);\n  if (**(long **)(param_1 + 0x10) != lVar1) {\n    sh_xfree(lVar1,\"./hash.def\",0xfd);\n  }\n  if (*(long *)(param_1 + 8) != lVar2) {\n    sh_xfree(lVar2,\"./hash.def\",0xff);\n  }\n  return 0;\n}\n\n",
  "FUN_001d4840": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_001d4840(int param_1)\n\n{\n  char *pcVar1;\n  char *__dest;\n  \n  _rl_history_search_pos = where_history();\n  DAT_0024a46c = rl_point;\n  DAT_0024a470 = 0;\n  _DAT_0024a468 = param_1;\n  if (rl_point != 0) {\n    pcVar1 = DAT_0024a460;\n    if (DAT_0024a458 + -2 <= rl_point) {\n      DAT_0024a458 = rl_point + 2;\n      pcVar1 = (char *)xrealloc(DAT_0024a460,(long)DAT_0024a458);\n    }\n    __dest = pcVar1;\n    DAT_0024a460 = pcVar1;\n    if (param_1 != 0) {\n      *pcVar1 = '^';\n      __dest = pcVar1 + 1;\n    }\n    strncpy(__dest,rl_line_buffer,(long)rl_point);\n    pcVar1[param_1 + rl_point] = '\\0';\n  }\n  _rl_free_saved_history_line();\n  return;\n}\n\n",
  "all_exported_variables": "\nvoid * all_exported_variables(void)\n\n{\n  int iVar1;\n  void *__base;\n  \n  __base = (void *)map_over(FUN_00151290,shell_variables);\n  if (__base != (void *)0x0) {\n    iVar1 = strvec_len(__base);\n    qsort(__base,(long)iVar1,8,FUN_001513a0);\n  }\n  return __base;\n}\n\n",
  "make_arith_for_command": "\nundefined8 * make_arith_for_command(long param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined4 *puVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  int iVar6;\n  char *pcVar7;\n  char *pcVar8;\n  long local_60;\n  long local_58;\n  \n  lVar5 = 0;\n  iVar6 = 0;\n  pcVar8 = **(char ***)(param_1 + 8);\n  local_60 = 0;\n  local_58 = 0;\n  do {\n    cVar1 = *pcVar8;\n    while ((cVar1 != ' ' && (cVar1 != '\\t'))) {\n      iVar2 = skip_to_delim(pcVar8,0,&DAT_001fab1e,0x81);\n      iVar6 = iVar6 + 1;\n      pcVar7 = pcVar8 + iVar2;\n      if (iVar2 < 1) {\n        if (iVar6 == 2) {\n          local_58 = 0;\n          goto LAB_001433ba;\n        }\n        if (iVar6 == 3) {\n          local_60 = 0;\n          goto LAB_001433ba;\n        }\n        if (iVar6 == 1) {\n          lVar5 = 0;\n        }\n        cVar1 = *pcVar7;\n      }\n      else {\n        pcVar8 = (char *)substring(pcVar8);\n        if (iVar6 == 1) {\n          lVar5 = 0;\n          if (pcVar8 != (char *)0x0) {\n            if (*pcVar8 != '\\0') {\n              lVar5 = FUN_00142fc0(pcVar8);\n            }\n            goto LAB_001434ce;\n          }\n        }\n        else if (iVar6 == 2) {\n          local_58 = 0;\n          if (pcVar8 != (char *)0x0) {\n            if (*pcVar8 != '\\0') {\n              local_58 = FUN_00142fc0(pcVar8);\n            }\n            goto LAB_001434ce;\n          }\n        }\n        else if (iVar6 == 3) {\n          local_60 = 0;\n          if (pcVar8 != (char *)0x0) {\n            if (*pcVar8 != '\\0') {\n              local_60 = FUN_00142fc0(pcVar8);\n            }\nLAB_001434ce:\n            sh_xfree(pcVar8,\"make_cmd.c\",0x131);\n          }\n        }\n        else if (pcVar8 != (char *)0x0) goto LAB_001434ce;\nLAB_001433ba:\n        cVar1 = *pcVar7;\n      }\n      if (cVar1 == '\\0') {\n        if (iVar6 == 3) {\n          puVar3 = (undefined4 *)sh_xmalloc(0x28,\"make_cmd.c\",0x145);\n          *puVar3 = 0;\n          puVar3[1] = param_3;\n          if (lVar5 == 0) {\n            lVar5 = FUN_00142fc0(&DAT_001fea52);\n          }\n          *(long *)(puVar3 + 2) = lVar5;\n          if (local_58 == 0) {\n            local_58 = FUN_00142fc0(&DAT_001fea52);\n          }\n          *(long *)(puVar3 + 4) = local_58;\n          if (local_60 == 0) {\n            local_60 = FUN_00142fc0(&DAT_001fea52);\n          }\n          *(long *)(puVar3 + 6) = local_60;\n          *(undefined8 *)(puVar3 + 8) = param_2;\n          dispose_words(param_1);\n          puVar4 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n          puVar4[3] = puVar3;\n          *puVar4 = 0xc;\n          *puVar3 = 0;\n          puVar4[2] = 0;\n          return puVar4;\n        }\n        if (iVar6 < 3) {\n          parser_error(param_3,\"syntax error: arithmetic expression required\");\n        }\n        else {\n          parser_error(param_3,\"syntax error: `;\\' unexpected\");\n        }\n        parser_error(param_3,\"syntax error: `((%s))\\'\",**(undefined8 **)(param_1 + 8));\n        sh_xfree(lVar5,\"make_cmd.c\",0x13e);\n        sh_xfree(local_58,\"make_cmd.c\",0x13f);\n        sh_xfree(local_60,\"make_cmd.c\",0x140);\n        set_exit_status(2);\n        return (undefined8 *)0x0;\n      }\n      pcVar8 = pcVar7 + 1;\n      cVar1 = pcVar7[1];\n    }\n    pcVar8 = pcVar8 + 1;\n  } while( true );\n}\n\n",
  "make_default_mailpath": "\nundefined8 * make_default_mailpath(void)\n\n{\n  size_t sVar1;\n  undefined8 *puVar2;\n  \n  get_current_user_info();\n  sVar1 = strlen(DAT_00238050);\n  puVar2 = (undefined8 *)sh_xmalloc(sVar1 + 0xc,\"mailcheck.c\",0x161);\n  *puVar2 = 0x69616d2f7261762f;\n  *(undefined2 *)(puVar2 + 1) = 0x6c;\n  *(undefined *)((long)puVar2 + 9) = 0x2f;\n  strcpy((char *)((long)puVar2 + 10),DAT_00238050);\n  return puVar2;\n}\n\n",
  "FUN_00194e30": "\nundefined8 FUN_00194e30(void)\n\n{\n  long lVar1;\n  \n  lVar1 = alias_expand(rl_line_buffer);\n  if (lVar1 != 0) {\n    FUN_00194d10(lVar1);\n    return 0;\n  }\n  FUN_001934f0();\n  return 1;\n}\n\n",
  "internal_getopt": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint internal_getopt(long **param_1,char *param_2)\n\n{\n  char cVar1;\n  char cVar2;\n  char cVar3;\n  char *pcVar4;\n  long *plVar5;\n  undefined8 *puVar6;\n  int iVar7;\n  char *pcVar8;\n  long **pplVar9;\n  char **ppcVar10;\n  int __c;\n  \n  cVar1 = *param_2;\n  if (param_1 == (long **)0x0) {\n    loptend = (long **)0x0;\n    list_optflags = 0;\n    list_optarg = (char *)0x0;\n    return -1;\n  }\n  if (_DAT_00248e10 == param_1) {\n    if (DAT_00248e18 != 1) {\n      ppcVar10 = (char **)lcurrent[1];\n      pplVar9 = lcurrent;\n      iVar7 = DAT_00248e18;\n      goto LAB_001bb34c;\n    }\n    if (lcurrent == (long **)0x0) {\n      loptend = lcurrent;\n      _DAT_00248e10 = (long **)0x0;\n      return -1;\n    }\n  }\n  else {\n    DAT_00248e18 = 1;\n    loptend = (long **)0x0;\n    lcurrent = param_1;\n    _DAT_00248e10 = param_1;\n  }\n  pplVar9 = lcurrent;\n  ppcVar10 = (char **)lcurrent[1];\n  pcVar4 = *ppcVar10;\n  cVar2 = *pcVar4;\n  if (cVar2 == '-') {\n    cVar3 = pcVar4[1];\n    if (cVar3 == '\\0') {\n      loptend = lcurrent;\n      _DAT_00248e10 = (long **)0x0;\n      return -1;\n    }\n    iVar7 = strcmp(pcVar4,\"--help\");\n    if (iVar7 == 0) {\n      loptend = pplVar9;\n      _DAT_00248e10 = (long **)0x0;\n      return -99;\n    }\n    if ((cVar3 == '-') && (pcVar4[2] == '\\0')) {\n      loptend = (long **)*pplVar9;\n      _DAT_00248e10 = (long **)0x0;\n      return -1;\n    }\n  }\n  else if (((cVar2 != '+') || (cVar1 != '+')) || (pcVar4[1] == '\\0')) {\n    loptend = lcurrent;\n    _DAT_00248e10 = (long **)0x0;\n    return -1;\n  }\n  list_opttype = (int)cVar2;\n  iVar7 = 1;\n  DAT_0023a6c4 = cVar2;\nLAB_001bb34c:\n  pcVar4 = *ppcVar10;\n  cVar2 = pcVar4[iVar7];\n  __c = (int)cVar2;\n  list_optopt = __c;\n  if ((__c == 0x3a) || (pcVar8 = strchr(param_2 + (cVar1 == '+'),__c), pcVar8 == (char *)0x0)) {\n    DAT_0023a6c5 = cVar2;\n    sh_invalidopt(&DAT_0023a6c4);\n    DAT_00248e18 = DAT_00248e18 + 1;\n    if (*(char *)(*lcurrent[1] + (long)DAT_00248e18) == '\\0') {\n      lcurrent = (long **)*lcurrent;\n      DAT_00248e18 = 1;\n      if (lcurrent == (long **)0x0) {\n        list_optflags = 0;\n        list_optarg = (char *)0x0;\n        DAT_00248e18 = 1;\n        return 0x3f;\n      }\n    }\n    loptend = (long **)*lcurrent;\n    list_optflags = 0;\n    list_optarg = (char *)0x0;\n    return 0x3f;\n  }\n  cVar3 = pcVar8[1];\n  if (1 < (byte)(cVar3 - 0x3aU)) {\n    if (cVar3 == '#') {\n      cVar1 = pcVar4[(long)iVar7 + 1];\n      if (cVar1 == '\\0') {\n        if ((*pplVar9 != (long *)0x0) &&\n           (iVar7 = legal_number(*(undefined8 *)(*pplVar9)[1],0), iVar7 != 0)) {\n          puVar6 = (undefined8 *)(*lcurrent)[1];\n          lcurrent = (long **)**lcurrent;\n          list_optflags = *(undefined4 *)(puVar6 + 1);\n          list_optarg = (char *)*puVar6;\n          return __c;\n        }\n        DAT_0023a6c5 = cVar2;\n        sh_neednumarg(&DAT_0023a6c4);\n        list_optflags = 0;\n        list_optarg = (char *)0x0;\n        DAT_00248e18 = 1;\n        return 0x3f;\n      }\n      if ((byte)(cVar1 - 0x30U) < 10) {\n        lcurrent = (long **)*pplVar9;\n        list_optflags = 0;\n        list_optarg = pcVar4 + (long)iVar7 + 1;\n        return __c;\n      }\n    }\n    else {\n      DAT_00248e18 = iVar7 + 1;\n      if (pcVar4[DAT_00248e18] == '\\0') {\n        DAT_00248e18 = 1;\n        lcurrent = (long **)*pplVar9;\n      }\n    }\n    list_optflags = 0;\n    list_optarg = (char *)0x0;\n    return __c;\n  }\n  plVar5 = *pplVar9;\n  pcVar8 = pcVar4 + (long)iVar7 + 1;\n  if (pcVar4[(long)iVar7 + 1] == '\\0') {\n    if (plVar5 == (long *)0x0) {\n      if (cVar3 != ';') {\n        DAT_0023a6c5 = cVar2;\n        sh_needarg(&DAT_0023a6c4);\n        list_optflags = 0;\n        list_optarg = (char *)0x0;\n        DAT_00248e18 = 1;\n        return 0x3f;\n      }\n    }\n    else {\n      list_optarg = *(char **)plVar5[1];\n      if ((cVar3 == ':') ||\n         (((*list_optarg != '-' && ((cVar1 != '+' || (*list_optarg != '+')))) ||\n          (list_optarg[1] == '\\0')))) {\n        lcurrent = (long **)*plVar5;\n        list_optflags = *(undefined4 *)((char **)plVar5[1] + 1);\n        DAT_00248e18 = 1;\n        return __c;\n      }\n    }\n    list_optarg = (char *)0x0;\n    pcVar8 = list_optarg;\n  }\n  list_optarg = pcVar8;\n  DAT_00248e18 = 1;\n  list_optflags = 0;\n  lcurrent = (long **)plVar5;\n  return __c;\n}\n\n",
  "tgetstr": "\nvoid tgetstr(void)\n\n{\n  (*(code *)PTR_tgetstr_00237c50)();\n  return;\n}\n\n",
  "setifs": "\nvoid setifs(long param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  size_t sVar3;\n  size_t sVar4;\n  long lVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  undefined8 *puVar8;\n  \n  iVar2 = locale_utf8locale;\n  ifs_var = param_1;\n  if (param_1 == 0) {\n    pbVar6 = &DAT_001ff6d0;\n    ifs_is_set = 0;\n    ifs_value = &DAT_001ff6d0;\n    puVar8 = &ifs_cmap;\n    for (lVar5 = 0x20; lVar5 != 0; lVar5 = lVar5 + -1) {\n      *puVar8 = 0;\n      puVar8 = puVar8 + 1;\n    }\n    bVar1 = 0x20;\n    ifs_is_null = 0;\n    pbVar7 = pbVar6;\nLAB_0017f260:\n    do {\n      pbVar6 = pbVar6 + 1;\n      *(undefined *)((long)&ifs_cmap + (ulong)bVar1) = 1;\n      bVar1 = *pbVar6;\n    } while (bVar1 != 0);\n    if ((locale_utf8locale != 0) && (pbVar6 = ifs_value, -1 < (char)*pbVar7)) goto LAB_0017f2a2;\n  }\n  else {\n    pbVar6 = *(byte **)(param_1 + 8);\n    if (pbVar6 == (byte *)0x0) {\n      ifs_is_set = 1;\n      ifs_is_null = 0;\n      puVar8 = &ifs_cmap;\n      for (lVar5 = 0x20; lVar5 != 0; lVar5 = lVar5 + -1) {\n        *puVar8 = 0;\n        puVar8 = puVar8 + 1;\n      }\n      ifs_value = &DAT_001ff6d0;\n      pbVar6 = &DAT_001ff6d0;\n      bVar1 = 0x20;\n      pbVar7 = pbVar6;\n      goto LAB_0017f260;\n    }\n    ifs_is_set = 1;\n    ifs_is_null = (uint)(*pbVar6 == 0);\n    puVar8 = &ifs_cmap;\n    ifs_value = pbVar6;\n    for (lVar5 = 0x20; lVar5 != 0; lVar5 = lVar5 + -1) {\n      *puVar8 = 0;\n      puVar8 = puVar8 + 1;\n    }\n    bVar1 = *pbVar6;\n    pbVar7 = pbVar6;\n    if (bVar1 != 0) goto LAB_0017f260;\n    if (iVar2 != 0) goto LAB_0017f2a2;\n  }\n  sVar3 = __ctype_get_mb_cur_max();\n  sVar3 = strnlen((char *)ifs_value,sVar3);\n  sVar4 = __ctype_get_mb_cur_max();\n  pbVar6 = ifs_value;\n  if (1 < sVar4) {\n    iVar2 = mblen((char *)ifs_value,sVar3);\n    ifs_firstc_len = (long)iVar2;\n    pbVar6 = ifs_value;\n    if (ifs_firstc_len - 2U < 0xfffffffffffffffc) {\n      __memcpy_chk(&ifs_firstc,ifs_value,ifs_firstc_len,0x10);\n      return;\n    }\n  }\nLAB_0017f2a2:\n  DAT_002476f1 = 0;\n  ifs_firstc_len = 1;\n  ifs_firstc = *pbVar6;\n  return;\n}\n\n",
  "FUN_00185df0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00185df0(int param_1)\n\n{\n  int __signo;\n  __pid_t __pid;\n  int iVar1;\n  int *piVar2;\n  long in_FS_OFFSET;\n  sigset_t sStack_c8;\n  undefined8 local_40;\n  \n  local_40 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  DAT_00248538 = 1;\n  terminating_signal = 0;\n  if ((param_1 == 2) && (iVar1 = signal_is_trapped(2), iVar1 != 0)) {\n    run_interrupt_trap(0);\n  }\n  if ((interactive_shell == 0) || (interactive == 0)) {\nLAB_00185e4c:\n    if (this_shell_builtin == read_builtin) {\nLAB_00185f48:\n      read_tty_cleanup();\n    }\n    if (param_1 != 1) goto joined_r0x00185e72;\n    if ((subshell_environment & 0x24 | interactive) != 0) {\n      hangup_all_jobs();\n      goto joined_r0x00185e72;\n    }\n  }\n  else {\n    if ((param_1 == 1) || (param_1 == 0xf)) {\n      if (remember_on_history != 0) {\n        maybe_save_shell_history();\n      }\n      goto LAB_00185e4c;\n    }\n    if (this_shell_builtin == read_builtin) goto LAB_00185f48;\njoined_r0x00185e72:\n    if ((subshell_environment & 0x24) != 0) goto LAB_00185e78;\n  }\n  end_job_control();\nLAB_00185e78:\n  unlink_all_fifos();\n  procsub_clear();\n  funcnest = 0;\n  breaking = 0;\n  continuing = 0;\n  loop_level = 0;\n  wait_intr_flag = 0;\n  return_catch_flag = 0;\n  comsub_ignore_return = 0;\n  executing_list = 0;\n  run_exit_trap();\n  sigprocmask(2,(sigset_t *)top_level_mask,(sigset_t *)0x0);\n  set_signal_handler(param_1,0);\n  __pid = getpid();\n  kill(__pid,param_1);\n  if (dollar_dollar_pid == 1) {\n    iVar1 = 0;\n    piVar2 = &DAT_00238b60;\n    sigprocmask(2,(sigset_t *)0x0,&sStack_c8);\n    do {\n      __signo = *piVar2;\n      set_signal_handler(__signo,0);\n      sigdelset(&sStack_c8,__signo);\n      if (param_1 == __signo) {\n        iVar1 = piVar2[5];\n      }\n      piVar2 = piVar2 + 6;\n    } while (piVar2 != &shell_compatibility_level);\n    sigprocmask(2,&sStack_c8,(sigset_t *)0x0);\n    if (iVar1 != 0) {\n      do {\n        invalidInstructionException();\n      } while( true );\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1 + 0x80);\n}\n\n",
  "sh_regmatch": "\nundefined sh_regmatch(char *param_1,char *param_2,uint param_3)\n\n{\n  int iVar1;\n  regmatch_t *__pmatch;\n  size_t sVar2;\n  char *__dest;\n  long lVar3;\n  ulong uVar4;\n  ulong uVar5;\n  long in_FS_OFFSET;\n  undefined uVar6;\n  undefined local_88 [16];\n  undefined local_78 [16];\n  undefined local_68 [16];\n  undefined local_58 [16];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_88 = (undefined  [16])0x0;\n  local_78 = (undefined  [16])0x0;\n  local_68 = (undefined  [16])0x0;\n  local_58 = (undefined  [16])0x0;\n  iVar1 = regcomp((regex_t *)local_88,param_2,(-(uint)(match_ignore_case == 0) & 0xfffffffe) + 3);\n  uVar6 = 2;\n  if (iVar1 == 0) {\n    __pmatch = (regmatch_t *)sh_malloc(local_58._0_8_ * 8 + 8,\"shmatch.c\",0x51);\n    if (__pmatch == (regmatch_t *)0x0) {\n      iVar1 = regexec((regex_t *)local_88,param_1,0,(regmatch_t *)0x0,0);\n      uVar6 = iVar1 != 0;\n      sVar2 = strlen(param_1);\n      __dest = (char *)sh_malloc((long)((int)sVar2 + 0xb),\"shmatch.c\",0x5e);\n      unbind_global_variable_noref(\"BASH_REMATCH\");\n      make_new_array_variable(\"BASH_REMATCH\");\n    }\n    else {\n      iVar1 = regexec((regex_t *)local_88,param_1,local_58._0_8_ + 1,__pmatch,0);\n      uVar6 = iVar1 != 0;\n      sVar2 = strlen(param_1);\n      __dest = (char *)sh_malloc((long)((int)sVar2 + 0xb),\"shmatch.c\",0x5e);\n      unbind_global_variable_noref(\"BASH_REMATCH\");\n      lVar3 = make_new_array_variable(\"BASH_REMATCH\");\n      if ((((lVar3 != 0) && (lVar3 = *(long *)(lVar3 + 8), lVar3 != 0)) && ((param_3 & 1) != 0)) &&\n         ((__dest != (char *)0x0 && (iVar1 == 0)))) {\n        uVar4 = 0;\n        do {\n          memset(__dest,0,(long)((int)sVar2 + 10));\n          strncpy(__dest,param_1 + __pmatch[uVar4].rm_so,\n                  (long)(__pmatch[uVar4].rm_eo - __pmatch[uVar4].rm_so));\n          uVar5 = uVar4 + 1;\n          array_insert(lVar3,uVar4,__dest);\n          uVar4 = uVar5;\n        } while (uVar5 <= (ulong)local_58._0_8_);\n      }\n    }\n    sh_xfree(__dest,\"shmatch.c\",0x7b);\n    sh_xfree(__pmatch,\"shmatch.c\",0x7c);\n    regfree((regex_t *)local_88);\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar6;\n}\n\n",
  "initialize_bash_input": "\nvoid initialize_bash_input(void)\n\n{\n  bash_input = 0;\n  if (DAT_00240a68 != 0) {\n    sh_xfree(DAT_00240a68,\"/usr/local/src/chet/src/bash/src/parse.y\",0x58c);\n  }\n  DAT_00240a68 = 0;\n  DAT_00240a70 = 0;\n  DAT_00240a78 = 0;\n  DAT_00240a80 = 0;\n  return;\n}\n\n",
  "_rl_optimize_redisplay": "\nvoid _rl_optimize_redisplay(void)\n\n{\n  if (_rl_vis_botlin == 0) {\n    DAT_0024a8d8 = 1;\n  }\n  return;\n}\n\n",
  "get_group_list": "\nlong get_group_list(int *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long lVar3;\n  int iVar4;\n  long lVar5;\n  \n  lVar3 = DAT_00240e68;\n  if (DAT_00240e68 != 0) {\n    if (param_1 == (int *)0x0) {\n      return DAT_00240e68;\n    }\n    *param_1 = DAT_00240e84;\n    return lVar3;\n  }\n  if (DAT_00240e84 == 0) {\n    FUN_00141070();\n    if (DAT_00240e84 < 1) goto LAB_00142a79;\n  }\n  else if (DAT_00240e84 < 1) {\nLAB_00142a79:\n    if (param_1 != (int *)0x0) {\n      *param_1 = 0;\n      return 0;\n    }\n    return 0;\n  }\n  DAT_00240e68 = strvec_create();\n  lVar3 = DAT_00240e68;\n  iVar4 = DAT_00240e84;\n  if (0 < DAT_00240e84) {\n    lVar5 = 0;\n    do {\n      puVar1 = (undefined8 *)(DAT_00240e68 + lVar5 * 8);\n      lVar3 = lVar5 * 4;\n      lVar5 = lVar5 + 1;\n      uVar2 = itos(*(undefined4 *)(DAT_00240e78 + lVar3));\n      iVar4 = DAT_00240e84;\n      *puVar1 = uVar2;\n      lVar3 = DAT_00240e68;\n    } while ((int)lVar5 < iVar4);\n  }\n  if (param_1 == (int *)0x0) {\n    DAT_00240e68 = lVar3;\n    return lVar3;\n  }\n  DAT_00240e68 = lVar3;\n  *param_1 = iVar4;\n  return lVar3;\n}\n\n",
  "set_or_show_attributes": "\nuint set_or_show_attributes(undefined8 param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  long lVar4;\n  uint uVar5;\n  uint uVar6;\n  bool bVar7;\n  int iVar8;\n  uint uVar9;\n  int iVar10;\n  int iVar11;\n  uint uVar12;\n  int iVar13;\n  undefined8 uVar14;\n  undefined8 uVar15;\n  long lVar16;\n  long *plVar17;\n  undefined8 *puVar18;\n  uint uVar19;\n  long *plVar20;\n  uint uVar21;\n  long in_FS_OFFSET;\n  int local_84;\n  uint local_80;\n  int local_5c;\n  undefined2 local_48;\n  undefined local_46;\n  long local_40;\n  \n  uVar21 = 0;\n  iVar13 = 0;\n  uVar19 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  reset_internal_getopt();\n  uVar12 = 0;\nLAB_001b3750:\n  iVar8 = internal_getopt(param_1,\"aAfnp\");\n  puVar18 = loptend;\n  do {\n    loptend = puVar18;\n    if (iVar8 == -1) {\n      if (puVar18 != (undefined8 *)0x0) {\n        uVar5 = param_2 & 1;\n        uVar6 = param_2 & 1;\n        uVar9 = param_2 & 1;\n        if ((param_2 & 1) != 0) {\n          array_needs_making = 1;\n        }\n        local_80 = param_2 & 2;\n        if ((iVar13 != 0) && ((param_2 & 2) != 0)) {\n          local_80 = 0;\n          param_2 = param_2 & 0xfffffffd;\n        }\n        local_84 = 0;\n        local_5c = 0;\n        iVar8 = 3 - (uint)(local_80 == 0);\n        iVar10 = iVar8 + uVar9;\n        break;\n      }\n      if ((param_2 & 8 | uVar12) == 0) {\n        plVar17 = (long *)all_shell_variables();\nLAB_001b3b8f:\n        if ((param_2 & 4) == 0) {\n          if ((param_2 & 0x40) != 0) {\n            uVar21 = uVar21 + 1;\n            if (param_2 != 0x40) {\n              param_2 = param_2 & 0xffffffbf;\n            }\n          }\n        }\n        else {\n          uVar19 = uVar19 + 1;\n          if (param_2 != 4) {\n            param_2 = param_2 & 0xfffffffb;\n          }\n        }\n      }\n      else {\n        plVar17 = (long *)all_shell_functions();\n        if (param_2 != 8) {\n          param_2 = param_2 & 0xfffffff7;\n          goto LAB_001b3b8f;\n        }\n      }\n      uVar12 = 0;\n      if (plVar17 == (long *)0x0) goto LAB_001b39ba;\n      lVar4 = *plVar17;\n      plVar20 = plVar17;\n      goto joined_r0x001b3bc8;\n    }\n    if (iVar8 == 0x66) {\n      uVar12 = 1;\n      goto LAB_001b3750;\n    }\n    if (0x66 < iVar8) {\n      if (iVar8 == 0x6e) {\n        iVar13 = 1;\n        goto LAB_001b3750;\n      }\n      if (iVar8 == 0x70) goto LAB_001b3750;\nLAB_001b39b0:\n      builtin_usage();\n      uVar12 = 0x102;\n      goto LAB_001b39ba;\n    }\n    if (iVar8 == 0x41) goto LAB_001b3a08;\n    if (iVar8 != 0x61) {\n      if (iVar8 != -99) goto LAB_001b39b0;\n      builtin_help();\n      uVar12 = 0x102;\n      goto LAB_001b39ba;\n    }\n    uVar19 = 1;\n    iVar8 = internal_getopt(param_1,\"aAfnp\");\n    puVar18 = loptend;\n  } while( true );\n  do {\n    lVar4 = *(long *)puVar18[1];\n    if (uVar12 == 0) {\n      iVar11 = assignment(lVar4,0);\n      if (iVar11 == 0) {\n        iVar11 = legal_identifier(lVar4);\n        if (iVar11 == 0) {\n          sh_invalidid(lVar4);\n          local_5c = local_5c + 1;\n        }\n        else {\n          set_var_attribute(lVar4,param_2,iVar13);\n        }\n      }\n      else {\n        puVar1 = (undefined *)(lVar4 + iVar11);\n        pcVar2 = (char *)(lVar4 + -1 + (long)iVar11);\n        *puVar1 = 0;\n        if (*pcVar2 == '+') {\n          *pcVar2 = '\\0';\n          iVar11 = legal_identifier(lVar4);\n          if (iVar11 == 0) goto LAB_001b3b38;\n          *puVar1 = 0x3d;\n          bVar7 = true;\n          *pcVar2 = '+';\n        }\n        else {\n          iVar11 = legal_identifier(lVar4);\n          if (iVar11 == 0) {\nLAB_001b3b38:\n            sh_invalidid(lVar4);\n            local_84 = local_84 + 1;\n            goto LAB_001b3940;\n          }\n          *puVar1 = 0x3d;\n          bVar7 = false;\n        }\n        if ((uVar19 | uVar21) == 0) {\n          iVar11 = do_assignment_no_expand(lVar4);\n          local_84 = local_84 + (uint)(iVar11 == 0);\n        }\n        else {\n          uVar3 = *puVar18;\n          *puVar18 = 0;\n          local_48 = 0x672d;\n          if (local_80 != 0) {\n            local_46 = 0x72;\n          }\n          if (uVar6 != 0) {\n            *(undefined *)((long)&local_48 + (long)iVar8) = 0x78;\n          }\n          *(byte *)((long)&local_48 + (long)iVar10) = (-(uVar19 == 0) & 0xe0U) + 0x61;\n          *(undefined *)((long)&local_48 + (long)(iVar10 + 1)) = 0;\n          uVar14 = make_word(&local_48);\n          uVar15 = make_word_list(uVar14,puVar18);\n          iVar11 = declare_builtin(uVar15);\n          local_84 = (local_84 + 1) - (uint)(iVar11 == 0);\n          *puVar18 = uVar3;\n          dispose_word(uVar14);\n          sh_xfree(uVar15,\"./setattr.def\",0x108);\n        }\n        *puVar1 = 0;\n        if (bVar7) {\n          *pcVar2 = '\\0';\n          set_var_attribute(lVar4,param_2,iVar13);\n          *puVar1 = 0x3d;\n          *pcVar2 = '+';\n        }\n        else {\n          set_var_attribute(lVar4,param_2,iVar13);\n          *puVar1 = 0x3d;\n        }\n      }\n    }\n    else {\n      lVar16 = find_function(lVar4);\n      if (lVar16 == 0) {\n        builtin_error(\"%s: not a function\",lVar4);\n        local_5c = local_5c + 1;\n      }\n      else if (uVar5 == 0) {\n        if (iVar13 != 0) goto LAB_001b3a4f;\nLAB_001b3a65:\n        *(uint *)(lVar16 + 0x28) = *(uint *)(lVar16 + 0x28) | param_2;\n      }\n      else if (iVar13 == 0) {\n        iVar11 = exportable_function_name(lVar4);\n        if (iVar11 != 0) goto LAB_001b3a65;\n        builtin_error(\"%s: cannot export\",lVar4);\n        local_5c = local_5c + 1;\n      }\n      else {\nLAB_001b3a4f:\n        *(uint *)(lVar16 + 0x28) = *(uint *)(lVar16 + 0x28) & ~param_2;\n      }\n    }\nLAB_001b3940:\n    puVar18 = (undefined8 *)*puVar18;\n  } while (puVar18 != (undefined8 *)0x0);\n  uVar12 = 0x104;\n  if (local_84 == 0) {\n    uVar12 = (uint)(local_5c != 0);\n  }\n  goto LAB_001b39ba;\njoined_r0x001b3bc8:\n  if (lVar4 == 0) goto LAB_001b3c52;\n  plVar20 = plVar20 + 1;\n  uVar12 = *(uint *)(lVar4 + 0x28);\n  if ((((uVar19 == 0) || ((uVar12 & 4) != 0)) && ((uVar21 == 0 || ((uVar12 & 0x40) != 0)))) &&\n     (((uVar12 & 0x9000) != 0x9000 && ((param_2 & uVar12) != 0)))) {\n    show_var_attributes(lVar4,this_shell_builtin == export_builtin ||\n                              this_shell_builtin == readonly_builtin,param_3);\n    iVar13 = sh_chkwrite(0);\n    if (iVar13 != 0) {\n      uVar12 = 1;\n      goto LAB_001b3c54;\n    }\n  }\n  lVar4 = *plVar20;\n  goto joined_r0x001b3bc8;\nLAB_001b3a08:\n  uVar21 = 1;\n  goto LAB_001b3750;\nLAB_001b3c52:\n  uVar12 = 0;\nLAB_001b3c54:\n  sh_xfree(plVar17,\"./setattr.def\",0x155);\nLAB_001b39ba:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar12;\n}\n\n",
  "timeval_to_secs": "\nvoid timeval_to_secs(long *param_1,long *param_2,int *param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  \n  lVar1 = *param_1;\n  *param_2 = lVar1;\n  iVar2 = (int)param_1[1] + (int)(param_1[1] / 1000000) * -1000000;\n  iVar3 = iVar2 / 1000;\n  if (iVar2 % 1000 < 500) {\n    *param_3 = iVar3;\n    return;\n  }\n  iVar3 = iVar3 + 1;\n  *param_3 = iVar3;\n  if (iVar3 == 1000) {\n    *param_2 = lVar1 + 1;\n    *param_3 = 0;\n  }\n  return;\n}\n\n",
  "getdtablesize": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint getdtablesize(void)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_getdtablesize_00237ea8)();\n  return iVar1;\n}\n\n",
  "rl_forced_update_display": "\nundefined8 rl_forced_update_display(void)\n\n{\n  undefined8 *puVar1;\n  undefined *puVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  puVar2 = PTR_DAT_00240520;\n  pcVar4 = *(char **)PTR_DAT_00240520;\n  if (pcVar4 != (char *)0x0) {\n    if (*pcVar4 != '\\0') {\n      do {\n        pcVar3 = pcVar4 + 1;\n        *pcVar4 = '\\0';\n        pcVar4 = pcVar3;\n      } while (*pcVar3 != '\\0');\n      pcVar4 = *(char **)puVar2;\n      if (pcVar4 == (char *)0x0) goto LAB_001e1c28;\n    }\n    *pcVar4 = '\\0';\n  }\nLAB_001e1c28:\n  _rl_last_v_pos = 0;\n  puVar1 = *(undefined8 **)(puVar2 + 0x10);\n  _rl_last_c_pos = 0;\n  DAT_0024a8c0 = 0;\n  _rl_vis_botlin = 0;\n  if (puVar1 != (undefined8 *)0x0) {\n    *puVar1 = 0;\n  }\n  DAT_0024a8b0 = DAT_0024a8b0 + 1;\n  DAT_0024a888 = 0;\n  (*(code *)rl_redisplay_function)();\n  return 0;\n}\n\n",
  "tcsetattr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint tcsetattr(int __fd,int __optional_actions,termios *__termios_p)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_tcsetattr_00237d38)();\n  return iVar1;\n}\n\n",
  "iswlower": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswlower(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswlower_00237810)();\n  return iVar1;\n}\n\n",
  "rl_initialize_funmap": "\nvoid rl_initialize_funmap(void)\n\n{\n  char **ppcVar1;\n  int iVar2;\n  code *pcVar3;\n  char *pcVar4;\n  \n  if (DAT_0024a438 == 0) {\n    pcVar3 = rl_abort;\n    pcVar4 = \"abort\";\n    iVar2 = 0;\n    ppcVar1 = &PTR_s_accept_line_002369b0;\n    while( true ) {\n      rl_add_funmap_entry(pcVar4,pcVar3);\n      pcVar4 = *ppcVar1;\n      iVar2 = iVar2 + 1;\n      if (pcVar4 == (char *)0x0) break;\n      pcVar3 = (code *)ppcVar1[1];\n      ppcVar1 = ppcVar1 + 2;\n    }\n    DAT_0024a438 = 1;\n    funmap_program_specific_entry_start = iVar2;\n  }\n  return;\n}\n\n",
  "any_signals_trapped": "\nulong any_signals_trapped(void)\n\n{\n  ulong uVar1;\n  \n  uVar1 = 1;\n  while( true ) {\n    if ((((&DAT_00247e40)[uVar1] & 1) != 0) && (((&DAT_00247e40)[uVar1] & 0x40) == 0)) break;\n    uVar1 = uVar1 + 1;\n    if (uVar1 == 0x41) {\n      return 0xffffffff;\n    }\n  }\n  return uVar1 & 0xffffffff;\n}\n\n",
  "FUN_001af710": "\nvoid FUN_001af710(undefined4 *param_1)\n\n{\n  ttsetattr(*param_1,param_1 + 1);\n  DAT_00248c04 = 0;\n  return;\n}\n\n",
  "FUN_001eb6c0": "\nbool FUN_001eb6c0(void)\n\n{\n  int iVar1;\n  long lVar2;\n  ulong *puVar3;\n  ulong uVar4;\n  long in_FS_OFFSET;\n  byte bVar5;\n  long local_148;\n  long local_140;\n  ulong local_138 [16];\n  ulong local_b8 [17];\n  long local_30;\n  \n  bVar5 = 0;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = fileno(rl_instream);\n  puVar3 = local_138;\n  for (lVar2 = 0x10; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + (ulong)bVar5 * -2 + 1;\n  }\n  puVar3 = local_b8;\n  for (lVar2 = 0x10; lVar2 != 0; lVar2 = lVar2 + -1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + (ulong)bVar5 * -2 + 1;\n  }\n  lVar2 = __fdelt_chk((long)iVar1);\n  uVar4 = 1L << ((byte)iVar1 & 0x3f);\n  local_138[lVar2] = local_138[lVar2] | uVar4;\n  lVar2 = __fdelt_chk((long)iVar1);\n  local_b8[lVar2] = local_b8[lVar2] | uVar4;\n  local_148 = (long)(DAT_00240538 / 1000000);\n  local_140 = (long)(DAT_00240538 % 1000000);\n  iVar1 = _rl_timeout_select(iVar1 + 1,local_138,0,local_b8,&local_148,0);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0 < iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "__strncpy_chk": "\nvoid __strncpy_chk(void)\n\n{\n  (*(code *)PTR___strncpy_chk_00237c70)();\n  return;\n}\n\n",
  "FUN_001c9490": "\nbyte * FUN_001c9490(byte *param_1,int param_2,uint param_3,undefined4 *param_4,int *param_5)\n\n{\n  byte bVar1;\n  ushort *puVar2;\n  char cVar3;\n  int iVar4;\n  size_t sVar5;\n  byte *pbVar6;\n  size_t sVar7;\n  byte *pbVar8;\n  long lVar9;\n  ushort **ppuVar10;\n  __int32_t **pp_Var11;\n  byte bVar12;\n  size_t sVar13;\n  int iVar14;\n  byte *__s;\n  byte bVar15;\n  uint uVar16;\n  byte bVar17;\n  ulong uVar18;\n  byte *pbVar19;\n  uint uVar20;\n  long in_FS_OFFSET;\n  bool bVar21;\n  wchar_t local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar5 = __ctype_get_mb_cur_max();\n  iVar4 = param_2 * 4 + 4;\n  if (iVar4 < 0xc) {\n    iVar4 = 0xc;\n  }\n  pbVar6 = (byte *)sh_xmalloc((long)iVar4,\"strtrans.c\",0x48);\n  pbVar19 = pbVar6;\n  if (param_1 == (byte *)0x0) {\nLAB_001c95b8:\n    *pbVar19 = 0;\njoined_r0x001c9b41:\n    if (param_5 != (int *)0x0) {\n      *param_5 = (int)pbVar19 - (int)pbVar6;\n    }\n    if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    return pbVar6;\n  }\nLAB_001c9518:\n  bVar15 = *param_1;\n  __s = param_1;\n  pbVar8 = pbVar19;\n  if (bVar15 != 0) {\n    while (bVar15 == 0x5c) {\n      bVar12 = __s[1];\n      if (bVar12 == 0) {\n        if (locale_utf8locale == 0) goto LAB_001c96b0;\n        goto LAB_001c9645;\n      }\n      param_1 = __s + 2;\n      uVar20 = (uint)(char)bVar12;\n      switch(bVar12) {\n      case 0x22:\n      case 0x27:\n      case 0x3f:\n        uVar16 = param_3 & 1;\n        goto joined_r0x001c9581;\n      default:\n        goto switchD_001c9555_caseD_23;\n      case 0x30:\n        goto LAB_001c97d6;\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n        if ((param_3 & 1) != 0) {\n          *pbVar8 = 0x5c;\n          pbVar8 = pbVar8 + 1;\n          uVar16 = param_3 & 2;\n          goto LAB_001c9708;\n        }\nLAB_001c97d6:\n        uVar16 = uVar20 - 0x30;\n        bVar15 = __s[2];\n        pbVar19 = param_1;\n        if (7 < (byte)(bVar15 - 0x30)) goto LAB_001c9821;\n        goto LAB_001c9805;\n      case 0x45:\n      case 0x65:\n        bVar12 = 0x1b;\n        break;\n      case 0x55:\n      case 0x75:\n        ppuVar10 = __ctype_b_loc();\n        iVar14 = (uint)(uVar20 != 0x75) * 4 + 4;\n        uVar18 = 0;\n        iVar4 = iVar14;\n        goto LAB_001c9786;\n      case 0x5c:\n        break;\n      case 0x61:\n        bVar12 = 7;\n        break;\n      case 0x62:\n        bVar12 = 8;\n        break;\n      case 99:\n        if (param_4 != (undefined4 *)0x0) {\n          *param_4 = 1;\n          *pbVar8 = 0;\n          pbVar19 = pbVar8;\n          goto joined_r0x001c9b41;\n        }\n        if (((param_3 & 1) == 0) && (bVar15 = __s[2], bVar15 != 0)) {\n          uVar20 = (uint)(char)bVar15;\n          if (bVar15 != 0) {\n            param_1 = __s + 3;\n            uVar16 = param_3 & 2;\n            if ((uVar20 == 0x5c) && ((param_3 & 2) != 0)) {\n              if (__s[3] == 0x5c) {\n                param_1 = __s + 4;\n              }\n            }\n            else if (uVar20 == 0x3f) {\n              bVar12 = 0x7f;\n              if ((param_3 & 2) == 0) break;\n              bVar12 = 0x7f;\n              goto LAB_001c9718;\n            }\n            ppuVar10 = __ctype_b_loc();\n            if ((*(byte *)((long)*ppuVar10 + (ulong)bVar15 * 2 + 1) & 2) == 0) {\n              bVar12 = bVar15 & 0x1f;\n              uVar20 = bVar15 & 0x1f;\n            }\n            else {\n              pp_Var11 = __ctype_toupper_loc();\n              uVar20 = (*pp_Var11)[(char)bVar15] & 0x1f;\n              bVar12 = (byte)uVar20;\n            }\n            goto LAB_001c9708;\n          }\n          bVar12 = 0;\n        }\n        else {\n          uVar20 = 99;\n        }\nswitchD_001c9555_caseD_23:\n        uVar16 = param_3 & 4;\njoined_r0x001c9581:\n        if (uVar16 == 0) {\n          uVar16 = param_3 & 2;\n          *pbVar8 = 0x5c;\n          pbVar8 = pbVar8 + 1;\n        }\n        else {\n          uVar16 = param_3 & 2;\n        }\n        goto LAB_001c9708;\n      case 0x66:\n        bVar12 = 0xc;\n        break;\n      case 0x6e:\n        bVar12 = 10;\n        break;\n      case 0x72:\n        bVar12 = 0xd;\n        break;\n      case 0x74:\n        bVar12 = 9;\n        break;\n      case 0x76:\n        bVar12 = 0xb;\n        break;\n      case 0x78:\n        if ((param_3 & 2) == 0) {\n          bVar15 = __s[2];\n          uVar20 = param_3 & 0x10;\n        }\n        else {\n          bVar15 = __s[2];\n          if (bVar15 == 0x7b) {\n            bVar15 = __s[3];\n            param_3 = param_3 | 0x10;\n            param_1 = __s + 3;\n            uVar20 = 0x10;\n          }\n          else {\n            uVar20 = param_3 & 0x10;\n          }\n        }\n        ppuVar10 = __ctype_b_loc();\n        bVar17 = 0;\n        puVar2 = *ppuVar10;\n        iVar4 = 2;\n        bVar1 = *(byte *)((long)puVar2 + (ulong)bVar15 * 2 + 1);\n        goto joined_r0x001c987e;\n      }\n      *pbVar8 = bVar12;\n      bVar15 = *param_1;\n      pbVar19 = pbVar8 + 1;\n      __s = param_1;\n      pbVar8 = pbVar19;\n      if (bVar15 == 0) goto LAB_001c95b8;\n    }\n    if (locale_utf8locale == 0) {\nLAB_001c96b0:\n      if ((0 < (int)sVar5) &&\n         ((*(uint *)(is_basic_table + (ulong)(bVar15 >> 5) * 4) >> (bVar15 & 0x1f) & 1) == 0))\n      goto LAB_001c961b;\n    }\n    else if ((char)bVar15 < '\\0') {\nLAB_001c961b:\n      param_1 = __s + 1;\n      sVar7 = mbrtowc(&local_44,(char *)__s,(long)(int)sVar5,(mbstate_t *)0x0);\n      pbVar19 = pbVar8 + 1;\n      if (sVar7 < 0xfffffffffffffffe) {\n        *pbVar8 = bVar15;\n        if (sVar7 - 1 != 0) {\n          sVar13 = 1;\n          do {\n            pbVar8[sVar13] = __s[sVar13];\n            sVar13 = sVar13 + 1;\n          } while (sVar7 != sVar13);\n          pbVar19 = pbVar8 + sVar7;\n          param_1 = param_1 + (sVar7 - 1);\n        }\n        goto LAB_001c9518;\n      }\n    }\nLAB_001c9645:\n    param_1 = __s + 1;\n    pbVar19 = pbVar8 + 1;\n    *pbVar8 = bVar15;\n    goto LAB_001c9518;\n  }\n  goto LAB_001c95b8;\njoined_r0x001c987e:\n  if ((bVar1 & 0x10) == 0) goto LAB_001c98b7;\n  if (iVar4 == 0) {\n    if (uVar20 != 0) goto LAB_001c9a5a;\n    goto LAB_001c9a2d;\n  }\n  if ((byte)(bVar15 + 0x9f) < 6) {\n    cVar3 = bVar15 + 0xa9;\n  }\n  else if ((byte)(bVar15 + 0xbf) < 6) {\n    cVar3 = bVar15 - 0x37;\n  }\n  else {\n    cVar3 = bVar15 - 0x30;\n  }\n  bVar15 = param_1[1];\n  bVar17 = bVar17 * '\\x10' + cVar3;\n  param_1 = param_1 + 1;\n  iVar4 = iVar4 + -1;\n  bVar1 = *(byte *)((long)puVar2 + (ulong)bVar15 * 2 + 1);\n  goto joined_r0x001c987e;\nLAB_001c98b7:\n  if (uVar20 != 0) goto LAB_001c9ab9;\n  if (iVar4 == 2) {\n    *pbVar8 = 0x5c;\n    uVar20 = 0x78;\n    pbVar8 = pbVar8 + 1;\n  }\n  else {\nLAB_001c9a2d:\n    uVar20 = (uint)bVar17;\n    bVar12 = bVar17;\n  }\n  goto LAB_001c98dd;\nLAB_001c9a5a:\n  do {\n    if ((byte)(bVar15 + 0x9f) < 6) {\n      cVar3 = bVar15 + 0xa9;\n    }\n    else if ((byte)(bVar15 + 0xbf) < 6) {\n      cVar3 = bVar15 - 0x37;\n    }\n    else {\n      cVar3 = bVar15 - 0x30;\n    }\n    bVar15 = param_1[1];\n    bVar17 = bVar17 * '\\x10' + cVar3;\n    param_1 = param_1 + 1;\n  } while ((*(byte *)((long)puVar2 + (ulong)bVar15 * 2 + 1) & 0x10) != 0);\nLAB_001c9ab9:\n  bVar12 = bVar17;\n  param_3 = param_3 & 0xffffffef;\n  uVar20 = (uint)bVar12;\n  param_1 = param_1 + (bVar15 == 0x7d);\nLAB_001c98dd:\n  uVar16 = param_3 & 2;\nLAB_001c9708:\n  if ((uVar16 != 0) && ((uVar20 == 1 || (uVar20 == 0x7f)))) {\nLAB_001c9718:\n    *pbVar8 = 1;\n    pbVar8 = pbVar8 + 1;\n  }\n  *pbVar8 = bVar12;\n  pbVar19 = pbVar8 + 1;\n  goto LAB_001c9518;\nLAB_001c9786:\n  bVar15 = *param_1;\n  if ((*(byte *)((long)*ppuVar10 + (ulong)bVar15 * 2 + 1) & 0x10) == 0) goto LAB_001c9a8e;\n  bVar21 = iVar4 == 0;\n  iVar4 = iVar4 + -1;\n  if (bVar21) goto LAB_001c992a;\n  if ((byte)(bVar15 + 0x9f) < 6) {\n    lVar9 = (long)(char)(bVar15 + 0xa9);\n  }\n  else if ((byte)(bVar15 + 0xbf) < 6) {\n    lVar9 = (long)(char)(bVar15 - 0x37);\n  }\n  else {\n    lVar9 = (long)((char)bVar15 + -0x30);\n  }\n  uVar18 = uVar18 * 0x10 + lVar9;\n  param_1 = param_1 + 1;\n  goto LAB_001c9786;\nLAB_001c9a8e:\n  if (iVar4 == iVar14) {\n    *pbVar8 = 0x5c;\n    pbVar8 = pbVar8 + 1;\n    uVar16 = param_3 & 2;\n  }\n  else {\nLAB_001c992a:\n    if (0x7f < uVar18) {\n      iVar4 = u32cconv(uVar18,pbVar8);\n      pbVar19 = pbVar8 + iVar4;\n      goto LAB_001c9518;\n    }\n    uVar20 = (uint)uVar18;\n    bVar12 = (byte)uVar18;\n    uVar16 = param_3 & 2;\n  }\n  goto LAB_001c9708;\n  while (pbVar19 = __s + (ulong)((uint)(uVar20 == 0x30) & param_3 & 1) + 4,\n        param_1 != __s + (ulong)((uint)(uVar20 == 0x30) & param_3 & 1) + 4) {\nLAB_001c9805:\n    param_1 = param_1 + 1;\n    uVar16 = (int)(char)(bVar15 - 0x30) + uVar16 * 8;\n    bVar15 = *param_1;\n    pbVar19 = param_1;\n    if (7 < (byte)(bVar15 - 0x30)) break;\n  }\nLAB_001c9821:\n  param_1 = pbVar19;\n  bVar12 = (byte)uVar16;\n  uVar20 = uVar16 & 0xff;\n  uVar16 = param_3 & 2;\n  goto LAB_001c9708;\n}\n\n",
  "get_array_value": "\nvoid get_array_value(undefined8 param_1,undefined4 param_2,undefined8 param_3)\n\n{\n  FUN_0018cd60(param_1,0,param_2,param_3);\n  return;\n}\n\n",
  "_rl_standout_on": "\nvoid _rl_standout_on(void)\n\n{\n  if ((DAT_0024b640 != 0) && (DAT_0024b638 != 0)) {\n    tputs(DAT_0024b640,1,_rl_output_character_function);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001415eb": "\nundefined8 FUN_001415eb(char *param_1)\n\n{\n  while( true ) {\n    if (*param_1 == '\\0') {\n      return 1;\n    }\n    if (9 < (byte)(*param_1 - 0x30U)) break;\n    param_1 = param_1 + 1;\n  }\n  return 0;\n}\n\n",
  "group_member": "\nint group_member(__gid_t __gid)\n\n{\n  __gid_t *p_Var1;\n  \n  if (DAT_00238048 == __gid) {\n    return 1;\n  }\n  if (DAT_0023804c != __gid) {\n    if (DAT_00240e84 == 0) {\n      FUN_00141070();\n      if (DAT_00240e84 < 1) {\n        return 0;\n      }\n    }\n    else if (DAT_00240e84 < 1) {\n      return 0;\n    }\n    p_Var1 = DAT_00240e78;\n    do {\n      if (*p_Var1 == __gid) {\n        return 1;\n      }\n      p_Var1 = p_Var1 + 1;\n    } while (p_Var1 != DAT_00240e78 + (ulong)(DAT_00240e84 - 1) + 1);\n    return 0;\n  }\n  return 1;\n}\n\n",
  "_rl_parse_colors": "\nvoid _rl_parse_colors(void)\n\n{\n  bool bVar1;\n  ushort uVar2;\n  void *pvVar3;\n  char cVar4;\n  char cVar5;\n  int iVar6;\n  char *pcVar7;\n  size_t sVar8;\n  char *pcVar9;\n  void *pvVar10;\n  long lVar11;\n  char *unaff_RBP;\n  long in_FS_OFFSET;\n  char *local_58;\n  char *local_50;\n  undefined2 local_43;\n  undefined local_41;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar7 = (char *)sh_get_env_value(\"LS_COLORS\");\n  local_58 = pcVar7;\n  if ((pcVar7 == (char *)0x0) || (*pcVar7 == '\\0')) {\n    _rl_color_ext_list = (void *)0x0;\nLAB_001f7feb:\n    if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    return;\n  }\n  local_41 = 0;\n  local_43 = 0x3f3f;\n  sVar8 = strlen(pcVar7);\n  pcVar9 = (char *)xmalloc(sVar8 + 1);\n  DAT_0024b770 = strcpy(pcVar9,pcVar7);\n  local_50 = DAT_0024b770;\nLAB_001f804e:\n  cVar5 = *pcVar7;\n  do {\n    if (cVar5 == '*') {\n      pvVar10 = (void *)xmalloc(0x28);\n      pvVar3 = pvVar10;\n      *(void **)((long)pvVar10 + 0x20) = _rl_color_ext_list;\n      _rl_color_ext_list = pvVar3;\n      *(char **)((long)pvVar10 + 8) = local_50;\n      local_58 = pcVar7 + 1;\n      cVar5 = FUN_001f7d30(&local_50,&local_58,1,pvVar10);\n      if (cVar5 != '\\0') {\n        cVar5 = *local_58;\n        local_58 = local_58 + 1;\n        if (cVar5 == '=') {\n          *(char **)((long)pvVar10 + 0x18) = local_50;\n          cVar5 = FUN_001f7d30(&local_50,&local_58,0,(long)pvVar10 + 0x10);\n          if (cVar5 != '\\0') goto LAB_001f816f;\n        }\n        if (*(long *)((long)pvVar10 + 8) != 0) {\n          _rl_errmsg(\"LS_COLORS: syntax error: %s\");\n        }\n      }\nLAB_001f8203:\n      _rl_errmsg(\"unparsable value for LS_COLORS environment variable\");\n      free(DAT_0024b770);\n      pvVar3 = _rl_color_ext_list;\n      while (pvVar3 != (void *)0x0) {\n        pvVar10 = *(void **)((long)pvVar3 + 0x20);\n        free(pvVar3);\n        pvVar3 = pvVar10;\n      }\n      _rl_color_ext_list = (void *)0x0;\n      _rl_colored_stats = 0;\n      goto LAB_001f7feb;\n    }\n    if (cVar5 == ':') break;\n    if (cVar5 == '\\0') goto LAB_001f7feb;\n    uVar2 = (ushort)local_43 >> 8;\n    local_43 = CONCAT11((char)uVar2,cVar5);\n    local_58 = pcVar7 + 1;\n    if (pcVar7[1] == '\\0') goto LAB_001f8203;\n    pcVar9 = pcVar7 + 3;\n    local_43 = CONCAT11(pcVar7[1],cVar5);\n    local_58 = pcVar9;\n    if (pcVar7[2] != '=') goto LAB_001f8203;\n    lVar11 = 0;\n    cVar4 = 'l';\n    pcVar7 = \"lc\";\n    while( true ) {\n      if ((cVar5 == cVar4) && (iVar6 = strcmp((char *)&local_43,pcVar7), iVar6 == 0)) {\n        (&PTR_DAT_002405e8)[(long)(int)lVar11 * 2] = local_50;\n        cVar5 = FUN_001f7d30(&local_50,&local_58,0);\n        pcVar9 = local_58;\n        if (cVar5 != '\\0') goto LAB_001f816f;\n        _rl_errmsg(\"LS_COLORS: unrecognized prefix: %s\");\n        if (pcVar9 == (char *)0x0) goto LAB_001f8203;\n        goto LAB_001f813b;\n      }\n      lVar11 = lVar11 + 1;\n      pcVar7 = (&PTR_DAT_00235c80)[lVar11];\n      if (pcVar7 == (char *)0x0) break;\n      cVar4 = *pcVar7;\n    }\n    _rl_errmsg(\"LS_COLORS: unrecognized prefix: %s\");\nLAB_001f813b:\n    bVar1 = false;\n    while( true ) {\n      cVar5 = *pcVar9;\n      if (cVar5 == '\\0' || cVar5 == ':') break;\n      unaff_RBP = pcVar9 + 1;\n      pcVar9 = unaff_RBP;\n      bVar1 = cVar5 != '\\0' && cVar5 != ':';\n    }\n    if (bVar1) {\n      local_58 = unaff_RBP;\n    }\n    if (cVar5 != ':') {\n      if (cVar5 != '\\0') goto LAB_001f8203;\n      goto LAB_001f7feb;\n    }\nLAB_001f816f:\n    cVar5 = *local_58;\n    pcVar7 = local_58;\n  } while( true );\n  pcVar7 = pcVar7 + 1;\n  local_58 = pcVar7;\n  goto LAB_001f804e;\n}\n\n",
  "waitpid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__pid_t waitpid(__pid_t __pid,int *__stat_loc,int __options)\n\n{\n  __pid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_waitpid_00237d10)();\n  return _Var1;\n}\n\n",
  "dlerror": "\nvoid dlerror(void)\n\n{\n  (*(code *)PTR_dlerror_00237828)();\n  return;\n}\n\n",
  "colon_builtin": "\nundefined8 colon_builtin(void)\n\n{\n  return 0;\n}\n\n",
  "_rl_block_sigint": "\nvoid _rl_block_sigint(void)\n\n{\n  if (DAT_0024aa88 == 0) {\n    DAT_0024aa88 = 1;\n  }\n  return;\n}\n\n",
  "FUN_0018e9b0": "\nvoid FUN_0018e9b0(long param_1,long param_2,int *param_3,int param_4)\n\n{\n  byte bVar1;\n  mbstate_t mVar2;\n  size_t sVar3;\n  undefined8 uVar4;\n  int iVar5;\n  int iVar6;\n  byte *__s;\n  ulong uVar7;\n  ulong uVar8;\n  int iVar9;\n  int iVar10;\n  int iVar11;\n  long in_FS_OFFSET;\n  uint local_6c;\n  int local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  iVar11 = *param_3;\n  uVar7 = (ulong)iVar11;\n  __s = (byte *)(param_1 + uVar7);\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  local_6c = (uint)(param_4 != 0x7d);\n  bVar1 = *__s;\n  if (bVar1 != 0) {\n    iVar9 = 0;\n    iVar6 = 0;\n    uVar8 = uVar7;\n    iVar10 = iVar9;\n    do {\n      mVar2 = local_48;\n      iVar5 = (int)(char)bVar1;\n      iVar11 = (int)uVar8;\n      if (iVar10 != 0) goto LAB_0018eb28;\n      if (iVar5 == 0x5c) {\n        if ((iVar6 == 0 || iVar6 == 0x22) || (iVar6 == 0x60)) {\n          uVar8 = (ulong)(iVar11 + 1);\n          iVar10 = 1;\n          local_48 = mVar2;\n        }\n        else {\n          if (iVar6 == 0x5c) {\nLAB_0018eba2:\n            iVar6 = 0;\n          }\nLAB_0018eba4:\n          if (locale_mb_cur_max < 2) {\nLAB_0018ec3b:\n            uVar8 = (ulong)(iVar11 + 1);\n          }\n          else {\n            if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n              if ((locale_utf8locale == 0) || (sVar3 = 1, (char)bVar1 < '\\0')) {\n                sVar3 = mbrtowc((wchar_t *)0x0,(char *)__s,param_2 - uVar7,&local_48);\n                if (sVar3 < 0xfffffffffffffffe) {\n                  if (sVar3 != 0) goto LAB_0018ebe6;\n                  uVar8 = (ulong)(iVar11 + 1);\n                }\n                else {\n                  uVar8 = (ulong)(iVar11 + 1);\n                  local_48 = mVar2;\n                }\n                goto LAB_0018ead8;\n              }\n            }\n            else {\n              sVar3 = 1;\n            }\nLAB_0018ebe6:\n            uVar8 = (ulong)(uint)(iVar11 + (int)sVar3);\n          }\n        }\n      }\n      else if ((iVar5 == 0x24) && (*(char *)(param_1 + 1 + uVar7) == '{')) {\n        if (iVar6 == 0x27) goto LAB_0018eba4;\n        uVar8 = (ulong)(iVar11 + 1);\n        iVar10 = 1;\n        iVar9 = iVar9 + (uint)(iVar6 == 0);\n        local_48 = mVar2;\n      }\n      else {\n        if (iVar6 != 0) {\n          if (iVar5 == iVar6) goto LAB_0018eba2;\n          if (((iVar6 != 0x22) || (iVar5 != 0x24)) || (*(char *)(param_1 + 1 + uVar7) != '('))\n          goto LAB_0018eba4;\n          iVar6 = 0x22;\nLAB_0018ec0a:\n          local_4c = iVar11 + 2;\n          uVar4 = extract_command_subst(param_1,&local_4c,0);\n          iVar11 = local_4c;\n          sh_xfree(uVar4,\"braces.c\",0x2a9);\n          goto LAB_0018ec3b;\n        }\n        if ((byte)(bVar1 - 0x22) < 0x3f) {\n          uVar8 = 1L << (bVar1 - 0x22 & 0x3f);\n          if ((uVar8 & 0x14000004) == 0) {\n            if ((uVar8 & 0x4000000000000021) != 0) {\n              uVar8 = (ulong)(iVar11 + 1);\n              iVar10 = 0;\n              local_48 = mVar2;\n              iVar6 = iVar5;\n              goto LAB_0018ead8;\n            }\n            goto LAB_0018ea74;\n          }\n          if (*(char *)(param_1 + 1 + uVar7) == '(') goto LAB_0018ec0a;\n          if (param_4 == iVar5) goto LAB_0018ea84;\nLAB_0018ecc0:\n          if (iVar5 == 0x7b) goto LAB_0018eb20;\n          if ((iVar5 == 0x7d) && (iVar9 != 0)) {\n            iVar9 = iVar9 + -1;\n          }\n          else if (iVar5 == 0x2c) {\n            if (param_4 == 0x7d) {\n              if (iVar9 != 0) goto joined_r0x0018edec;\nLAB_0018ed8b:\n              local_6c = local_6c + 1;\n              iVar9 = 0;\n            }\n          }\n          else {\nLAB_0018ede0:\n            if (param_4 == 0x7d) {\njoined_r0x0018edec:\n              if ((((bVar1 == 0x2e) && (*__s == 0x2e)) && (__s[1] == 0x2e)) &&\n                 (*(char *)(param_1 + 2 + uVar7) != '}')) {\n                local_6c = (local_6c + 1) - (uint)(iVar9 != 0);\n              }\n            }\n          }\n        }\n        else {\nLAB_0018ea74:\n          if (param_4 != iVar5) goto LAB_0018ecc0;\nLAB_0018ea84:\n          if (iVar9 != 0) goto LAB_0018ecc0;\n          if (local_6c != 0) {\n            if ((iVar5 == 0x7b) &&\n               ((((iVar11 == 0 || (bVar1 = *(byte *)(param_1 + -1 + uVar7), (byte)(bVar1 - 9) < 2))\n                 || ((bVar1 & 0xdf) == 0)) &&\n                ((bVar1 = *(byte *)(param_1 + 1 + uVar7), (bVar1 & 0xdf) == 0 || bVar1 == 0x7d ||\n                 ((byte)(bVar1 - 9) < 2)))))) {\n              uVar8 = (ulong)(iVar11 + 1);\n              iVar10 = 0;\n              iVar9 = 0;\n              local_48 = mVar2;\n              goto LAB_0018ead8;\n            }\n            break;\n          }\n          if (iVar5 != 0x7b) {\n            if (iVar5 == 0x2c) {\n              if (param_4 != 0x7d) goto LAB_0018eb28;\n              goto LAB_0018ed8b;\n            }\n            goto LAB_0018ede0;\n          }\nLAB_0018eb20:\n          iVar9 = iVar9 + 1;\n        }\nLAB_0018eb28:\n        if (locale_mb_cur_max < 2) {\nLAB_0018eb75:\n          uVar8 = (ulong)(iVar11 + 1);\n        }\n        else {\n          if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale == 0) || (sVar3 = 1, (char)bVar1 < '\\0')) {\n              sVar3 = mbrtowc((wchar_t *)0x0,(char *)__s,param_2 - uVar7,&local_48);\n              if (0xfffffffffffffffd < sVar3) {\n                uVar8 = (ulong)(iVar11 + 1);\n                local_48 = mVar2;\n                goto LAB_0018eb67;\n              }\n              if (sVar3 == 0) goto LAB_0018eb75;\n            }\n          }\n          else {\n            sVar3 = 1;\n          }\n          uVar8 = (ulong)(uint)(iVar11 + (int)sVar3);\n        }\nLAB_0018eb67:\n        iVar10 = 0;\n      }\nLAB_0018ead8:\n      iVar11 = (int)uVar8;\n      uVar7 = (ulong)iVar11;\n      __s = (byte *)(param_1 + uVar7);\n      bVar1 = *__s;\n    } while (bVar1 != 0);\n  }\n  *param_3 = iVar11;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "FUN_001522f0": "\nvoid FUN_001522f0(long param_1,ulong param_2)\n\n{\n  if ((param_2 & 8) != 0) {\n    dispose_command();\n    return;\n  }\n  if ((param_2 & 4) == 0) {\n    if ((param_2 & 0x40) != 0) {\n      assoc_dispose();\n      return;\n    }\n    if ((param_2 & 0x800) == 0) {\n      if (param_1 != 0) {\n        sh_xfree(param_1,\"variables.c\",0xec4);\n        return;\n      }\n    }\n    else if (param_1 != 0) {\n      sh_xfree(param_1,\"variables.c\",0xec2);\n      return;\n    }\n    return;\n  }\n  array_dispose();\n  return;\n}\n\n",
  "make_until_command": "\nvoid make_until_command(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined4 *puVar1;\n  undefined8 *puVar2;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x18,\"make_cmd.c\",0x195);\n  *(undefined8 *)(puVar1 + 2) = param_1;\n  *(undefined8 *)(puVar1 + 4) = param_2;\n  *puVar1 = 0;\n  puVar2 = (undefined8 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  puVar2[3] = puVar1;\n  *puVar2 = 8;\n  *puVar1 = 0;\n  puVar2[2] = 0;\n  return;\n}\n\n",
  "FUN_001bd790": "\nulong FUN_001bd790(undefined8 param_1,undefined8 param_2)\n\n{\n  wchar_t *pwVar1;\n  wchar_t wVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  wchar_t wVar6;\n  long lVar7;\n  long lVar8;\n  size_t sVar9;\n  wchar_t *pwVar10;\n  wchar_t *pwVar11;\n  ulong uVar12;\n  wchar_t *pwVar13;\n  int *piVar14;\n  ulong unaff_R12;\n  wchar_t *__s;\n  long in_FS_OFFSET;\n  int *local_50;\n  long local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar7 = mbsmbchar(param_2);\n  if ((lVar7 == 0) && (lVar7 = mbsmbchar(param_1), lVar7 == 0)) {\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar12 = FUN_001bd510(param_1,param_2);\n      return uVar12;\n    }\n  }\n  else {\n    iVar3 = extglob_pattern_p(param_1);\n    local_48 = 0;\n    local_50 = (int *)0x0;\n    lVar7 = xdupmbstowcs(&local_50,0,param_1);\n    if ((lVar7 == -1) || (lVar8 = xdupmbstowcs(&local_48,0,param_2), lVar7 = local_48, lVar8 == -1))\n    {\n      uVar4 = FUN_001bd510(param_1,param_2);\n      unaff_R12 = (ulong)uVar4;\n      piVar14 = local_50;\n    }\n    else if (iVar3 == 0) {\n      piVar14 = local_50;\n      uVar4 = FUN_001bd430(local_50,local_48);\n      unaff_R12 = (ulong)uVar4;\n    }\n    else {\n      __s = local_50 + 2;\n      iVar3 = *local_50;\n      sVar9 = wcslen(__s);\n      pwVar1 = __s + sVar9;\n      pwVar10 = (wchar_t *)glob_patscan_wc(__s,pwVar1,0);\n      if (pwVar10 == (wchar_t *)0x0) {\n        unaff_R12 = 0;\n        piVar14 = local_50;\n      }\n      else if ((((pwVar1 == pwVar10) && (*pwVar1 == L'\\0')) && (pwVar1[-1] == L')')) &&\n              (pwVar13 = wcschr(__s,L'|'), pwVar13 == (wchar_t *)0x0)) {\n        pwVar1[-1] = L'\\0';\n        uVar4 = FUN_001bd430(__s,lVar7);\n        pwVar1[-1] = L')';\n        unaff_R12 = (ulong)uVar4;\n        piVar14 = local_50;\n      }\n      else {\n        do {\n          pwVar11 = (wchar_t *)glob_patscan_wc(__s,pwVar10,0x7c);\n          pwVar13 = __s;\n          if (pwVar11 == (wchar_t *)0x0) break;\n          wVar2 = pwVar11[-1];\n          iVar5 = wextglob_pattern_p(__s);\n          if ((iVar5 == 0) || (wVar6 = L')', wVar2 != L')')) {\n            wVar6 = L'\\0';\n          }\n          pwVar11[-1] = wVar6;\n          uVar4 = FUN_001bd430(__s,lVar7);\n          pwVar11[-1] = wVar2;\n          unaff_R12 = (ulong)uVar4;\n          piVar14 = local_50;\n          if (uVar4 == 0) goto LAB_001bd809;\n          __s = pwVar11;\n          pwVar13 = pwVar10;\n        } while (pwVar10 != pwVar11);\n        piVar14 = local_50;\n        if (((pwVar1 != pwVar13) && ((iVar3 == 0x2a || (unaff_R12 = 1, iVar3 == 0x3f)))) &&\n           (unaff_R12 = 1, *pwVar10 != L'\\0')) {\n          uVar4 = FUN_001bd430(pwVar10,lVar7);\n          unaff_R12 = (ulong)uVar4;\n        }\n      }\n    }\nLAB_001bd809:\n    if (piVar14 != (int *)0x0) {\n      sh_xfree(piVar14,\"glob.c\",0x1be);\n    }\n    if (local_48 != 0) {\n      sh_xfree(local_48,\"glob.c\",0x1bf);\n    }\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return unaff_R12 & 0xffffffff;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "add_unwind_protect": "\nvoid add_unwind_protect(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 *puVar1;\n  \n  if (DAT_0024838c < 1) {\n    puVar1 = (undefined8 *)sh_xmalloc(0x20,\"unwind_prot.c\",0xe0);\n  }\n  else {\n    DAT_0024838c = DAT_0024838c + -1;\n    puVar1 = *(undefined8 **)(uwcache + (long)DAT_0024838c * 8);\n  }\n  puVar1[1] = param_1;\n  puVar1[2] = param_2;\n  *puVar1 = DAT_00248390;\n  DAT_00248390 = puVar1;\n  return;\n}\n\n",
  "sh_mkdoublequoted": "\nundefined * sh_mkdoublequoted(byte *param_1,int param_2,int param_3)\n\n{\n  mbstate_t mVar1;\n  undefined *puVar2;\n  undefined2 *puVar3;\n  size_t sVar4;\n  size_t sVar5;\n  byte bVar6;\n  byte *__s;\n  int iVar7;\n  int iVar8;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  if (param_3 == 0) {\n    iVar7 = param_2 + 3;\n    iVar8 = 1;\n  }\n  else {\n    sVar4 = __ctype_get_mb_cur_max();\n    iVar7 = param_2 * 2 + 1;\n    iVar8 = (int)sVar4;\n  }\n  puVar2 = (undefined *)sh_xmalloc((long)iVar7,\"shquote.c\",0xc3);\n  puVar3 = (undefined2 *)(puVar2 + 1);\n  *puVar2 = 0x22;\n  bVar6 = *param_1;\n  __s = param_1;\n  while (bVar6 != 0) {\n    while (mVar1 = local_48, param_3 != 0) {\n      if (bVar6 == 0x22) {\n        *(undefined *)puVar3 = 0x5c;\n        puVar3 = (undefined2 *)((long)puVar3 + 1);\n      }\n      bVar6 = *__s;\n      if (locale_utf8locale == 0) {\n        if (((iVar8 < 2) ||\n            ((*(uint *)(is_basic_table + (ulong)(bVar6 >> 5) * 4) >> (bVar6 & 0x1f) & 1) != 0)) ||\n           (locale_mb_cur_max < 2)) goto LAB_001c8c10;\nLAB_001c8cc5:\n        sVar4 = mbrtowc((wchar_t *)0x0,(char *)__s,(size_t)(param_1 + ((long)param_2 - (long)__s)),\n                        &local_48);\n        if (0xfffffffffffffffd < sVar4) {\n          *(byte *)puVar3 = *__s;\n          goto LAB_001c8c1b;\n        }\n        bVar6 = *__s;\n        sVar5 = 1;\n        if (sVar4 != 0) {\n          sVar5 = sVar4;\n        }\n        sVar4 = 0;\n        while( true ) {\n          *(byte *)((long)puVar3 + sVar4) = bVar6;\n          sVar4 = sVar4 + 1;\n          if (sVar5 == sVar4) break;\n          bVar6 = __s[sVar4];\n        }\n      }\n      else {\n        if ((-1 < (char)bVar6) || (locale_mb_cur_max < 2)) goto LAB_001c8c10;\n        if ((*(uint *)(is_basic_table + (ulong)(bVar6 >> 5) * 4) >> (bVar6 & 0x1f) & 1) == 0)\n        goto LAB_001c8cc5;\n        *(byte *)puVar3 = bVar6;\n        sVar4 = 1;\n      }\n      __s = __s + sVar4;\n      puVar3 = (undefined2 *)(sVar4 + (long)puVar3);\n      bVar6 = *__s;\n      if (bVar6 == 0) goto LAB_001c8c68;\n    }\n    bVar6 = *__s;\nLAB_001c8c10:\n    *(byte *)puVar3 = bVar6;\nLAB_001c8c1b:\n    puVar3 = (undefined2 *)((long)puVar3 + 1);\n    __s = __s + 1;\n    local_48 = mVar1;\n    bVar6 = *__s;\n  }\nLAB_001c8c68:\n  *puVar3 = 0x22;\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "getpwuid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\npasswd * getpwuid(__uid_t __uid)\n\n{\n  passwd *ppVar1;\n  \n  ppVar1 = (passwd *)(*(code *)PTR_getpwuid_00237998)();\n  return ppVar1;\n}\n\n",
  "FUN_0015f750": "\nvoid FUN_0015f750(undefined4 param_1,int param_2)\n\n{\n  long lVar1;\n  ulong uVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  sigset_t sStack_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_138);\n  sigaddset(&sStack_138,0x11);\n  sigemptyset(&local_b8);\n  sigprocmask(0,&sStack_138,&local_b8);\n  if (0 < DAT_0023877c) {\n    uVar2 = 0;\n    do {\n      while( true ) {\n        uVar3 = uVar2 & 0xffffffff;\n        lVar1 = *(long *)(jobs + uVar2 * 8);\n        if ((lVar1 == 0) || ((param_2 != -1 && (param_2 != *(int *)(lVar1 + 0x14))))) break;\n        uVar2 = uVar2 + 1;\n        FUN_0015f5f0(uVar3,param_1,stdout);\n        if (DAT_0023877c <= (int)uVar2) goto LAB_0015f803;\n      }\n      uVar2 = uVar2 + 1;\n    } while ((int)uVar2 < DAT_0023877c);\n  }\nLAB_0015f803:\n  sigprocmask(2,&local_b8,(sigset_t *)0x0);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "assoc_reference": "\nundefined8 assoc_reference(long param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  lVar1 = hash_search(param_2,param_1,0);\n  if (lVar1 != 0) {\n    return *(undefined8 *)(lVar1 + 0x10);\n  }\n  return 0;\n}\n\n",
  "FUN_001962d0": "\nchar * FUN_001962d0(char *param_1,int param_2)\n\n{\n  char cVar1;\n  size_t sVar2;\n  char *pcVar3;\n  long lVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  int iVar7;\n  \n  if (param_2 == 0) {\n    if (DAT_00248800 != (char *)0x0) {\n      sh_xfree(DAT_00248800,\"bashline.c\",0x96d);\n    }\n    if (*param_1 == '`') {\n      pcVar6 = param_1 + 1;\n      DAT_002487f0 = 1;\n    }\n    else {\n      DAT_002487f0 = 0;\n      pcVar6 = param_1;\n      if ((*param_1 == '$') && (param_1[1] == '(')) {\n        pcVar6 = param_1 + 2;\n        DAT_002487f0 = 2;\n      }\n    }\n    rl_completion_suppress_quote = 1;\n    DAT_002487f8 = param_1;\n    sVar2 = strlen(pcVar6);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"bashline.c\",0x977);\n    DAT_00248800 = strcpy(pcVar3,pcVar6);\n    if (DAT_002487e8 != (long *)0x0) {\n      sh_xfree(DAT_002487e8,\"bashline.c\",0x979);\n    }\n    pcVar3 = DAT_00248800;\n    sVar2 = strlen(DAT_00248800);\n    pcVar6 = pcVar3 + (sVar2 - 1);\n    if (pcVar3 < pcVar6) {\n      do {\n        cVar1 = *pcVar6;\n        if (((cVar1 == ' ') || (cVar1 == '\\t')) ||\n           ((cVar1 != '\\0' && (lVar4 = mbschr(\";|&{(`\"), lVar4 != 0)))) {\n          pcVar3 = DAT_00248800;\n          if (DAT_00248800 < pcVar6) {\n            pcVar3 = pcVar6 + 1;\n            DAT_002487f0 = DAT_002487f0 + ((int)pcVar3 - (int)DAT_00248800);\n            if ((*pcVar6 == ' ') || (*pcVar6 == '\\t')) {\n              DAT_002487e8 = (long *)rl_completion_matches(pcVar3,rl_filename_completion_function);\n            }\n            else {\n              DAT_002487e8 = (long *)rl_completion_matches(pcVar3,command_word_completion_function);\n            }\n            goto LAB_0019641c;\n          }\n          break;\n        }\n        pcVar6 = pcVar6 + -1;\n        pcVar3 = DAT_00248800;\n      } while (DAT_00248800 < pcVar6);\n    }\n    DAT_002487e8 = (long *)rl_completion_matches(pcVar3,command_word_completion_function);\nLAB_0019641c:\n    if (DAT_002487e8 == (long *)0x0) {\n      rl_filename_quoting_desired = 0;\n      DAT_002487e4 = 0;\n      rl_completion_suppress_append = 1;\n      return (char *)0x0;\n    }\n    if (*DAT_002487e8 == 0) {\n      DAT_002487e4 = 0;\n    }\n    else if (DAT_002487e8[1] == 0) {\n      DAT_002487e4 = 0;\n      uVar5 = bash_tilde_expand(*DAT_002487e8,0);\n      iVar7 = file_isdir(uVar5);\n      sh_xfree(uVar5,\"bashline.c\",0xc38);\n      if (iVar7 != 0) {\n        rl_completion_append_character = 0x2f;\n        goto LAB_001964a7;\n      }\n    }\n    else {\n      DAT_002487e4 = 1;\n    }\n    rl_completion_suppress_append = 1;\n  }\nLAB_001964a7:\n  if ((DAT_002487e8 != (long *)0x0) && ((char *)DAT_002487e8[DAT_002487e4] != (char *)0x0)) {\n    sVar2 = strlen((char *)DAT_002487e8[DAT_002487e4]);\n    pcVar6 = (char *)sh_xmalloc((long)(DAT_002487f0 + 1) + sVar2,\"bashline.c\",0x9a3);\n    sVar2 = (size_t)DAT_002487f0;\n    if (DAT_002487f0 == 1) {\n      sVar2 = 1;\n      *pcVar6 = *DAT_002487f8;\n    }\n    else {\n      strncpy(pcVar6,DAT_002487f8,sVar2);\n    }\n    iVar7 = DAT_002487e4 + 1;\n    strcpy(pcVar6 + sVar2,(char *)DAT_002487e8[DAT_002487e4]);\n    DAT_002487e4 = iVar7;\n    return pcVar6;\n  }\n  rl_filename_quoting_desired = 0;\n  return (char *)0x0;\n}\n\n",
  "FUN_0015afb0": "\nundefined4 * FUN_0015afb0(undefined4 *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined4 *puVar2;\n  long lVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  \n  puVar2 = (undefined4 *)sh_xmalloc(0x20,\"copy_cmd.c\",0xb9);\n  puVar1 = *(undefined8 **)(param_1 + 2);\n  uVar5 = *puVar1;\n  *puVar2 = *param_1;\n  puVar2[1] = param_1[1];\n  lVar3 = make_bare_word(uVar5);\n  uVar5 = *(undefined8 *)(param_1 + 4);\n  *(undefined4 *)(lVar3 + 8) = *(undefined4 *)(puVar1 + 1);\n  *(long *)(puVar2 + 2) = lVar3;\n  uVar4 = copy_word_list(uVar5);\n  uVar5 = *(undefined8 *)(param_1 + 6);\n  *(undefined8 *)(puVar2 + 4) = uVar4;\n  uVar5 = copy_command(uVar5);\n  *(undefined8 *)(puVar2 + 6) = uVar5;\n  return puVar2;\n}\n\n",
  "inttostr": "\nvoid inttostr(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  fmtumax(param_1,10,param_2,param_3,0);\n  return;\n}\n\n",
  "command_builtin": "\nuint command_builtin(undefined8 param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  uint uVar4;\n  long lVar5;\n  undefined8 uVar6;\n  uint *puVar7;\n  long *plVar8;\n  uint uVar9;\n  \n  uVar9 = 0;\n  uVar4 = 0;\n  reset_internal_getopt();\n  while (iVar2 = internal_getopt(param_1,&DAT_0020f252), plVar8 = loptend, iVar2 != -1) {\n    if (iVar2 == 0x70) {\n      uVar9 = 0x100;\n    }\n    else if (iVar2 < 0x71) {\n      if (iVar2 == -99) {\n        builtin_help();\n        return 0x102;\n      }\n      if (iVar2 != 0x56) {\nLAB_001a3800:\n        builtin_usage();\n        return 0x102;\n      }\n      uVar4 = 0x82;\n    }\n    else {\n      if (iVar2 != 0x76) goto LAB_001a3800;\n      uVar4 = 4;\n    }\n  }\n  if (loptend == (long *)0x0) {\n    return 0;\n  }\n  if (uVar9 == 0) {\n    if (uVar4 == 0) {\n      begin_unwind_frame(\"command_builtin\");\n      lVar5 = make_bare_simple_command();\n      lVar1 = *(long *)(lVar5 + 0x18);\n      uVar6 = copy_word_list(plVar8);\n      puVar7 = *(uint **)(lVar5 + 0x18);\n      uVar9 = 0x830;\n      *(undefined8 *)(lVar1 + 8) = uVar6;\n      uVar4 = *(uint *)(lVar5 + 4);\n      *(undefined8 *)(puVar7 + 4) = 0;\nLAB_001a38ed:\n      *(uint *)(lVar5 + 4) = uVar4 | uVar9;\n      *puVar7 = *puVar7 | uVar9;\n      add_unwind_protect(dispose_command,lVar5);\n      uVar4 = execute_command(lVar5);\n      run_unwind_frame(\"command_builtin\");\n      return uVar4;\n    }\n  }\n  else {\n    if (restricted != 0) {\n      sh_restricted(&DAT_001fab0e);\n      return 1;\n    }\n    if (uVar4 == 0) {\n      begin_unwind_frame(\"command_builtin\");\n      lVar5 = make_bare_simple_command();\n      lVar1 = *(long *)(lVar5 + 0x18);\n      uVar6 = copy_word_list(plVar8);\n      puVar7 = *(uint **)(lVar5 + 0x18);\n      uVar9 = 0x4830;\n      *(undefined8 *)(lVar1 + 8) = uVar6;\n      uVar4 = *(uint *)(lVar5 + 4);\n      *(undefined8 *)(puVar7 + 4) = 0;\n      goto LAB_001a38ed;\n    }\n  }\n  iVar2 = 0;\n  do {\n    iVar3 = describe_command(*(undefined8 *)plVar8[1],uVar9 | uVar4);\n    if ((iVar3 == 0) && (uVar4 != 4)) {\n      sh_notfound(*(undefined8 *)plVar8[1]);\n    }\n    plVar8 = (long *)*plVar8;\n    iVar2 = iVar2 + iVar3;\n  } while (plVar8 != (long *)0x0);\n  return (uint)(iVar2 == 0);\n}\n\n",
  "set_default_lang": "\nvoid set_default_lang(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = get_string_value(\"LC_ALL\");\n  set_locale_var(\"LC_ALL\",uVar1);\n  uVar1 = get_string_value(&DAT_001fd139);\n  set_lang(&DAT_001fd139,uVar1);\n  return;\n}\n\n",
  "rl_parse_and_bind": "\n/* WARNING: Type propagation algorithm not settling */\n\nundefined4 rl_parse_and_bind(byte *param_1)\n\n{\n  byte bVar1;\n  char **ppcVar2;\n  uint uVar3;\n  byte bVar4;\n  int iVar5;\n  char *pcVar6;\n  ushort **ppuVar7;\n  __int32_t **pp_Var8;\n  size_t sVar9;\n  byte *pbVar10;\n  long lVar11;\n  ulong uVar12;\n  byte *pbVar13;\n  int iVar14;\n  byte *pbVar15;\n  ulong uVar16;\n  byte *pbVar17;\n  uint uVar18;\n  byte *pbVar19;\n  undefined8 *puVar20;\n  uint uVar21;\n  long lVar22;\n  char *pcVar23;\n  undefined *puVar24;\n  byte *pbVar25;\n  undefined **ppuVar26;\n  uint uVar27;\n  undefined1 *puVar28;\n  undefined4 uVar29;\n  long in_FS_OFFSET;\n  bool bVar30;\n  bool bVar31;\n  undefined local_42;\n  undefined local_41;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 != (byte *)0x0) {\n    for (; (bVar4 = *param_1, bVar4 == 0x20 || (bVar4 == 9)); param_1 = param_1 + 1) {\n    }\n    if ((bVar4 != 0) && (bVar4 != 0x23)) {\n      if (bVar4 == 0x24) {\n        bVar4 = param_1[1];\n        pbVar25 = param_1 + 1;\n        if ((bVar4 == 9) || (bVar4 == 0x20)) {\n          pbVar19 = param_1 + 2;\n          do {\n            do {\n              pbVar25 = pbVar19;\n              bVar4 = *pbVar25;\n              iVar5 = ~(uint)param_1 + (int)pbVar25;\n              pbVar19 = pbVar25 + 1;\n            } while (bVar4 == 0x20);\n          } while (bVar4 == 9);\n        }\n        else {\n          iVar5 = 0;\n        }\n        pbVar19 = pbVar25;\n        if (bVar4 != 0) {\n          pbVar13 = param_1 + (long)iVar5 + 2;\n          pbVar15 = pbVar25;\n          do {\n            pbVar19 = pbVar13;\n            if ((bVar4 == 0x20) || (bVar4 == 9)) {\n              *pbVar15 = 0;\n              bVar4 = *pbVar19;\n              if (bVar4 != 0) {\n                pbVar13 = param_1 + (long)(((iVar5 + 1) - (int)(param_1 + (long)iVar5 + 2)) +\n                                          (int)pbVar19) + 2;\n                goto LAB_001ddc1e;\n              }\n              break;\n            }\n            bVar4 = *pbVar19;\n            pbVar13 = pbVar19 + 1;\n            pbVar15 = pbVar19;\n          } while (bVar4 != 0);\n        }\n        goto LAB_001ddba4;\n      }\n      if (_rl_parsing_conditionalized_out == '\\0') {\n        if (bVar4 == 0x22) {\n          iVar5 = 1;\n          bVar4 = param_1[1];\n          while ((int)(char)bVar4 != 0) {\n            uVar12 = (ulong)(iVar5 + 1);\n            uVar21 = (int)(char)bVar4;\n            while( true ) {\n              bVar4 = param_1[uVar12];\n              uVar27 = (uint)uVar12;\n              pbVar25 = param_1 + uVar12;\n              if (uVar21 == 0x5c) break;\n              uVar18 = (uint)(char)bVar4;\n              if (uVar21 == 0x22) {\n                if (bVar4 == 0) goto LAB_001dd938;\n                goto LAB_001dd630;\n              }\n              uVar12 = uVar12 + 1;\n              uVar21 = uVar18;\n              if (bVar4 == 0) goto LAB_001dd887;\n            }\n            if (bVar4 == 0) break;\n            iVar5 = uVar27 + 1;\n            bVar4 = param_1[iVar5];\n          }\nLAB_001dd887:\n          uVar29 = 1;\n          FUN_001da6e0(\"%s: no closing `\\\"\\' in key binding\",param_1);\n          goto LAB_001dd76b;\n        }\n        uVar18 = (uint)(char)bVar4;\n        uVar27 = 0;\n        uVar12 = 0;\n        pbVar25 = param_1;\n        if (bVar4 == 0) {\nLAB_001dd942:\n          uVar29 = 1;\n          FUN_001da6e0(\"`%s\\': invalid key binding: missing key sequence\",param_1);\n          goto LAB_001dd76b;\n        }\nLAB_001dd630:\n        uVar16 = (long)(int)(uVar27 + 1);\n        uVar21 = (uint)bVar4;\n        do {\n          uVar3 = (uint)uVar16;\n          uVar27 = uVar3 - 1;\n          if ((uVar18 == 0x3a) || (uVar18 == 0x20)) {\n            if (uVar27 == 0) goto LAB_001dd942;\n            if ((uVar18 == 0x3a) && (param_1[uVar12 + 1] == 0x3d)) {\n              if ((char)uVar21 == '\\0') {\n                uVar16 = (ulong)uVar27;\n              }\n              else {\n                *pbVar25 = 0;\n              }\n              uVar27 = (int)uVar16 + 1;\n              bVar30 = true;\n              param_1[(int)uVar16] = 0;\n            }\n            else {\n              bVar30 = false;\n              if ((char)uVar21 != '\\0') {\nLAB_001dd685:\n                *pbVar25 = 0;\n                bVar30 = false;\n                uVar27 = uVar3;\n              }\n            }\n            goto LAB_001dd68e;\n          }\n          if (uVar18 == 9) {\n            if (uVar27 != 0) goto LAB_001dd685;\n            goto LAB_001dd942;\n          }\n          pbVar19 = param_1 + uVar16;\n          uVar18 = (uint)(char)*pbVar19;\n          pbVar25 = param_1 + uVar16;\n          uVar12 = uVar16;\n          uVar16 = uVar16 + 1;\n          uVar21 = uVar18;\n          uVar27 = uVar3;\n        } while (*pbVar19 != 0);\nLAB_001dd938:\n        uVar18 = 0;\n        bVar30 = false;\nLAB_001dd68e:\n        iVar5 = strcasecmp((char *)param_1,\"set\");\n        pbVar25 = param_1 + (int)uVar27;\n        bVar4 = *pbVar25;\n        if (iVar5 == 0) {\n          while (pbVar19 = pbVar25, bVar4 != 0) {\n            if ((bVar4 != 0x20) && (bVar4 != 9)) {\n              bVar4 = *pbVar25;\n              goto joined_r0x001dd8ad;\n            }\n            pbVar19 = pbVar25 + 1;\n            pbVar25 = pbVar25 + 1;\n            bVar4 = *pbVar19;\n          }\nLAB_001dd7fd:\n          bVar4 = 0;\n          goto LAB_001dd7ff;\n        }\n        pbVar19 = pbVar25;\n        if (bVar4 != 0) {\n          pbVar13 = param_1 + (long)(int)uVar27 + 1;\n          iVar5 = (int)pbVar25;\n          lVar22 = (long)pbVar13 - (long)pbVar25;\n          do {\n            iVar14 = (uVar27 - iVar5) + (int)pbVar19;\n            if ((bVar4 != 0x20) && (bVar4 != 9)) {\n              if ((bVar4 != 0x27) && (bVar4 != 0x22)) goto LAB_001dd980;\n              iVar5 = iVar14 + 1;\n              goto LAB_001dd6fd;\n            }\n            bVar4 = *pbVar13;\n            pbVar13 = pbVar13 + 1;\n            pbVar25 = pbVar19 + lVar22;\n            pbVar19 = pbVar25;\n          } while (bVar4 != 0);\n        }\n        goto LAB_001dd9b6;\n      }\n    }\n  }\n  goto LAB_001dd768;\n  while( true ) {\n    bVar4 = *pbVar15;\n    pbVar13 = pbVar15 + 1;\n    pbVar19 = pbVar15;\n    if (bVar4 == 0) break;\nLAB_001ddc1e:\n    pbVar15 = pbVar13;\n    if ((bVar4 != 0x20) && (bVar4 != 9)) break;\n  }\nLAB_001ddba4:\n  iVar5 = 0;\n  pcVar23 = \"if\";\n  ppuVar26 = &PTR_s_if_002359c0;\n  do {\n    iVar14 = strcasecmp((char *)pbVar25,pcVar23);\n    if (iVar14 == 0) {\n      (*(code *)(&PTR_FUN_002359c8)[(long)iVar5 * 2])(pbVar19);\n      uVar29 = 0;\n      goto LAB_001dd76b;\n    }\n    pcVar23 = ppuVar26[2];\n    ppuVar26 = ppuVar26 + 2;\n    iVar5 = iVar5 + 1;\n  } while (pcVar23 != (char *)0x0);\n  FUN_001da6e0(\"%s: unknown parser directive\",pbVar25);\n  goto LAB_001dd768;\n  while( true ) {\n    bVar30 = bVar4 == 0x20;\n    bVar31 = bVar4 == 9;\n    bVar4 = pbVar13[1];\n    pbVar19 = pbVar13 + 1;\n    if (bVar30 || bVar31) break;\njoined_r0x001dd8ad:\n    pbVar13 = pbVar19;\n    pbVar19 = pbVar13;\n    if (bVar4 == 0) goto LAB_001dd7fd;\n  }\n  *pbVar13 = 0;\n  while ((bVar4 != 0 && ((bVar4 == 0x20 || (bVar4 == 9))))) {\n    pbVar13 = pbVar19 + 1;\n    pbVar19 = pbVar19 + 1;\n    bVar4 = *pbVar13;\n  }\nLAB_001dd7ff:\n  ppuVar26 = &PTR_s_blink_matching_paren_002372b8;\n  pcVar23 = \"bind-tty-special-chars\";\n  do {\n    iVar5 = strcasecmp((char *)pbVar25,pcVar23);\n    pbVar13 = pbVar19;\n    if (iVar5 == 0) {\n      bVar4 = *pbVar19;\n      pbVar15 = pbVar19;\n      if (bVar4 != 0) goto LAB_001dd840;\n      goto LAB_001dd85c;\n    }\n    pcVar23 = *ppuVar26;\n    ppuVar26 = ppuVar26 + 3;\n  } while (pcVar23 != (char *)0x0);\n  ppuVar26 = &PTR_s_active_region_start_color_00235858;\n  pcVar23 = \"active-region-end-color\";\n  do {\n    iVar5 = strcasecmp((char *)pbVar25,pcVar23);\n    if (iVar5 == 0) {\n      if (bVar4 == 0x22) {\n        bVar4 = pbVar19[1];\n        pbVar13 = pbVar19 + 1;\n        iVar5 = 1;\n        lVar22 = 1;\n        pbVar15 = pbVar13;\n        goto joined_r0x001ddd77;\n      }\n      sVar9 = strlen((char *)pbVar19);\n      pbVar15 = pbVar19 + (sVar9 - 1);\n      if (pbVar19 <= pbVar15) goto LAB_001ddc8c;\n      bVar4 = pbVar15[1];\n      pbVar17 = pbVar19 + sVar9;\n      goto LAB_001ddca6;\n    }\n    pcVar23 = *ppuVar26;\n    ppuVar26 = ppuVar26 + 3;\n  } while (pcVar23 != (char *)0x0);\n  uVar29 = 1;\n  FUN_001da6e0(\"%s: unknown variable name\",pbVar25);\n  goto LAB_001dd76b;\n  while( true ) {\n    bVar4 = pbVar15[1];\n    pbVar15 = pbVar15 + 1;\n    if (bVar4 == 0) break;\nLAB_001dd840:\n    if ((bVar4 == 0x20) || (bVar4 == 9)) break;\n  }\n  if (pbVar19 < pbVar15) {\n    *pbVar15 = 0;\n  }\n  goto LAB_001dd85c;\njoined_r0x001ddd77:\n  if (bVar4 == 0) goto LAB_001ddd9b;\n  pbVar17 = pbVar19 + lVar22 + 1;\n  while (pbVar10 = pbVar17, bVar4 != 0x5c) {\n    if (bVar4 == 0x22) goto LAB_001ddd9b;\n    bVar4 = *pbVar10;\n    iVar5 = iVar5 + 1;\n    pbVar17 = pbVar10 + 1;\n    pbVar15 = pbVar10;\n    if (bVar4 == 0) goto LAB_001ddd9b;\n  }\n  pbVar15 = pbVar19 + (iVar5 + 1);\n  if (*pbVar15 == 0) goto LAB_001ddd9b;\n  iVar5 = iVar5 + 2;\n  lVar22 = (long)iVar5;\n  pbVar15 = pbVar19 + lVar22;\n  bVar4 = *pbVar15;\n  goto joined_r0x001ddd77;\nLAB_001ddd9b:\n  *pbVar15 = 0;\n  goto LAB_001dd85c;\n  while (pbVar15 = pbVar17 + -1, pbVar19 <= pbVar15) {\nLAB_001ddc8c:\n    pbVar17 = pbVar15;\n    bVar4 = *pbVar17;\n    if ((bVar4 != 0x20) && (bVar4 != 9)) {\n      bVar4 = pbVar17[1];\n      pbVar15 = pbVar17;\n      pbVar17 = pbVar17 + 1;\n      break;\n    }\n  }\nLAB_001ddca6:\n  if ((bVar4 != 0) && (pbVar19 <= pbVar17)) {\n    pbVar15[1] = 0;\n  }\nLAB_001dd85c:\n  rl_variable_bind(pbVar25,pbVar13);\n  uVar29 = 0;\n  goto LAB_001dd76b;\nLAB_001dd6fd:\n  uVar21 = (uint)(char)param_1[iVar5];\n  if (param_1[iVar5] == 0) goto LAB_001dd739;\n  pbVar25 = param_1 + (long)iVar5 + 1;\n  uVar27 = uVar21;\n  while( true ) {\n    iVar14 = iVar5 + 1;\n    bVar1 = *pbVar25;\n    if (uVar21 == 0x5c) break;\n    if ((byte)uVar27 == bVar4) goto LAB_001dd980;\n    uVar21 = (uint)(char)bVar1;\n    pbVar25 = pbVar25 + 1;\n    iVar5 = iVar14;\n    uVar27 = (uint)bVar1;\n    if (bVar1 == 0) goto LAB_001dd739;\n  }\n  if (bVar1 == 0) goto LAB_001dd739;\n  iVar5 = iVar5 + 2;\n  goto LAB_001dd6fd;\nLAB_001dd739:\n  uVar29 = 1;\n  FUN_001da6e0(\"`%s\\': missing closing quote for macro\",pbVar19);\n  goto LAB_001dd76b;\nLAB_001dd980:\n  pbVar25 = param_1 + iVar14;\n  bVar4 = *pbVar25;\n  if (bVar4 != 0) {\n    pbVar13 = param_1 + (long)iVar14 + 1;\n    lVar22 = (long)pbVar13 - (long)pbVar25;\n    do {\n      if ((bVar4 == 0x20) || (bVar4 == 9)) break;\n      bVar4 = *pbVar13;\n      pbVar13 = pbVar13 + 1;\n      pbVar25 = pbVar25 + lVar22;\n    } while (bVar4 != 0);\n  }\nLAB_001dd9b6:\n  *pbVar25 = 0;\n  if (!bVar30) {\n    if (uVar18 == 0) {\n      uVar29 = 1;\n      FUN_001da6e0(\"%s: no key sequence terminator\",param_1);\n    }\n    else if (*param_1 == 0x22) {\n      sVar9 = strlen((char *)param_1);\n      lVar22 = xmalloc(sVar9 + 1);\n      bVar4 = param_1[1];\n      if (bVar4 == 0) {\n        iVar5 = 0;\n      }\n      else {\n        bVar30 = false;\n        lVar11 = 1;\n        do {\n          iVar14 = (int)lVar11;\n          iVar5 = iVar14 + -1;\n          if ((bVar4 == 0x5c) || (bVar30)) {\n            bVar30 = (bool)(bVar30 ^ 1);\n          }\n          else {\n            if (bVar4 == 0x22) break;\n            bVar30 = false;\n          }\n          *(byte *)(lVar22 + -1 + lVar11) = bVar4;\n          lVar11 = lVar11 + 1;\n          bVar4 = param_1[lVar11];\n          iVar5 = iVar14;\n        } while (bVar4 != 0);\n      }\n      *(undefined *)(lVar22 + iVar5) = 0;\n      bVar4 = *pbVar19;\n      if ((bVar4 == 0x27) || (bVar4 == 0x22)) {\n        sVar9 = strlen((char *)pbVar19);\n        if (((int)sVar9 != 0) && (pbVar19[(long)(int)sVar9 + -1] == bVar4)) {\n          pbVar19[(long)(int)sVar9 + -1] = 0;\n        }\n        rl_macro_bind(lVar22,pbVar19 + 1,_rl_keymap);\n      }\n      else {\n        rl_initialize_funmap();\n        ppcVar2 = (char **)*funmap;\n        puVar20 = funmap;\n        while (ppcVar2 != (char **)0x0) {\n          puVar20 = puVar20 + 1;\n          iVar5 = strcasecmp(*ppcVar2,(char *)pbVar19);\n          if (iVar5 == 0) {\n            pcVar23 = ppcVar2[1];\n            goto LAB_001ddf08;\n          }\n          ppcVar2 = (char **)*puVar20;\n        }\n        pcVar23 = (char *)0x0;\nLAB_001ddf08:\n        rl_generic_bind(0,lVar22,pcVar23,_rl_keymap);\n      }\n      uVar29 = 0;\n      xfree(lVar22);\n    }\n    else {\n      ppuVar26 = &PTR_DAT_00235790;\n      pcVar6 = strrchr((char *)param_1,0x2d);\n      pcVar23 = \"DEL\";\n      pbVar25 = (byte *)(pcVar6 + 1);\n      if (pcVar6 == (char *)0x0) {\n        pbVar25 = param_1;\n      }\n      iVar5 = 0;\n      do {\n        iVar14 = strcasecmp((char *)pbVar25,pcVar23);\n        if (iVar14 == 0) {\n          uVar12 = (ulong)(uint)(&DAT_00235788)[(long)iVar5 * 4];\n          goto LAB_001dda34;\n        }\n        pcVar23 = *ppuVar26;\n        ppuVar26 = ppuVar26 + 2;\n        iVar5 = iVar5 + 1;\n      } while (pcVar23 != (char *)0x0);\n      uVar12 = (ulong)*pbVar25;\nLAB_001dda34:\n      puVar28 = _rl_possible_control_prefixes;\n      pcVar23 = \"Control-\";\n      do {\n        lVar22 = _rl_strindex(param_1,pcVar23);\n        if (lVar22 != 0) {\n          ppuVar7 = __ctype_b_loc();\n          if ((*(byte *)((long)*ppuVar7 + (uVar12 & 0xff) * 2 + 1) & 2) == 0) {\n            uVar12 = (ulong)((uint)uVar12 & 0x1f);\n            bVar30 = true;\n          }\n          else {\n            pp_Var8 = __ctype_toupper_loc();\n            bVar30 = true;\n            uVar12 = (ulong)((*pp_Var8)[uVar12 & 0xff] & 0x1f);\n          }\n          goto LAB_001dda94;\n        }\n        pcVar23 = *(char **)(puVar28 + 8);\n        puVar28 = puVar28 + 8;\n      } while (pcVar23 != (char *)0x0);\n      bVar30 = false;\nLAB_001dda94:\n      puVar28 = _rl_possible_meta_prefixes;\n      puVar24 = &DAT_002135b4;\n      do {\n        lVar22 = _rl_strindex(param_1,puVar24);\n        if (lVar22 != 0) {\n          uVar12 = uVar12 | 0x80;\n          goto LAB_001ddaca;\n        }\n        puVar24 = *(undefined **)(puVar28 + 8);\n        puVar28 = puVar28 + 8;\n      } while (puVar24 != (undefined *)0x0);\n      if ((bVar30) || (pbVar25 == param_1)) {\nLAB_001ddaca:\n        bVar4 = *pbVar19;\n        if ((bVar4 == 0x27) || (bVar4 == 0x22)) {\n          sVar9 = strlen((char *)pbVar19);\n          local_41 = 0;\n          if (((int)sVar9 != 0) && (pbVar19[(long)(int)sVar9 + -1] == bVar4)) {\n            pbVar19[(long)(int)sVar9 + -1] = 0;\n          }\n          uVar29 = 0;\n          local_42 = (char)uVar12;\n          rl_macro_bind(&local_42,pbVar19 + 1,_rl_keymap);\n        }\n        else {\n          iVar5 = strcasecmp((char *)pbVar19,\"prefix-meta\");\n          if (iVar5 == 0) {\n            local_41 = 0;\n            local_42 = (char)uVar12;\n            rl_generic_bind(1,&local_42,emacs_meta_keymap,_rl_keymap);\n            uVar29 = 0;\n          }\n          else {\n            rl_initialize_funmap();\n            ppcVar2 = (char **)*funmap;\n            puVar20 = funmap;\n            while (ppcVar2 != (char **)0x0) {\n              puVar20 = puVar20 + 1;\n              iVar5 = strcasecmp(*ppcVar2,(char *)pbVar19);\n              if (iVar5 == 0) {\n                pcVar23 = ppcVar2[1];\n                goto LAB_001dde40;\n              }\n              ppcVar2 = (char **)*puVar20;\n            }\n            pcVar23 = (char *)0x0;\nLAB_001dde40:\n            uVar29 = 0;\n            rl_bind_key(uVar12,pcVar23);\n          }\n        }\n      }\n      else {\n        uVar29 = 1;\n        FUN_001da6e0(\"%s: unknown key modifier\",param_1);\n      }\n    }\n    goto LAB_001dd76b;\n  }\nLAB_001dd768:\n  uVar29 = 0;\nLAB_001dd76b:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar29;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_kill_kbd_macro": "\nvoid _rl_kill_kbd_macro(void)\n\n{\n  if (DAT_0024b198 != 0) {\n    xfree();\n    DAT_0024b198 = 0;\n  }\n  DAT_0024b190 = 0;\n  DAT_0024b194 = 0;\n  if (rl_executing_macro != (void *)0x0) {\n    free(rl_executing_macro);\n  }\n  rl_readline_state = rl_readline_state & 0xffffffffffffefff;\n  rl_executing_macro = (void *)0x0;\n  DAT_0024b1a0 = 0;\n  return;\n}\n\n",
  "rl_refresh_line": "\nundefined8 rl_refresh_line(void)\n\n{\n  _rl_refresh_line();\n  rl_display_fixed = 1;\n  return 0;\n}\n\n",
  "_rl_digit_value": "\nint _rl_digit_value(int param_1)\n\n{\n  return param_1 + -0x30;\n}\n\n",
  "legal_alias_name": "\nundefined8 legal_alias_name(byte *param_1)\n\n{\n  byte bVar1;\n  \n  bVar1 = *param_1;\n  while( true ) {\n    if (bVar1 == 0) {\n      return 1;\n    }\n    if ((((&sh_syntaxtab)[bVar1] & 0x402) != 0) ||\n       ((bVar1 < 0x3f && ((0x5000801000000000U >> ((ulong)bVar1 & 0x3f) & 1) != 0)))) break;\n    bVar1 = param_1[1];\n    param_1 = param_1 + 1;\n  }\n  return 0;\n}\n\n",
  "restore_pipeline": "\nlong * restore_pipeline(int param_1)\n\n{\n  long *plVar1;\n  undefined8 *puVar2;\n  long *plVar3;\n  long *plVar4;\n  long in_FS_OFFSET;\n  sigset_t sStack_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_138);\n  sigaddset(&sStack_138,0x11);\n  sigemptyset(&local_b8);\n  sigprocmask(0,&sStack_138,&local_b8);\n  puVar2 = DAT_00247668;\n  plVar4 = the_pipeline;\n  the_pipeline = (long *)*DAT_00247668;\n  DAT_00247668 = (undefined8 *)DAT_00247668[1];\n  sh_xfree(puVar2,\"jobs.c\",0x1fd);\n  already_making_children = DAT_00247664;\n  sigprocmask(2,&local_b8,(sigset_t *)0x0);\n  if ((param_1 != 0) && (plVar3 = plVar4, plVar4 != (long *)0x0)) {\n    do {\n      plVar1 = (long *)*plVar3;\n      if (plVar3[3] != 0) {\n        sh_xfree(plVar3[3],\"jobs.c\",0x5c2);\n      }\n      sh_xfree(plVar3,\"jobs.c\",0x5c3);\n      plVar3 = plVar1;\n    } while (plVar4 != plVar1);\n    plVar4 = (long *)0x0;\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return plVar4;\n}\n\n",
  "alloc_word_desc": "\nvoid alloc_word_desc(void)\n\n{\n  undefined8 *puVar1;\n  \n  if (0 < DAT_00241ecc) {\n    DAT_00241ecc = DAT_00241ecc + -1;\n    puVar1 = *(undefined8 **)(wdcache + (long)DAT_00241ecc * 8);\n    *(undefined4 *)(puVar1 + 1) = 0;\n    *puVar1 = 0;\n    return;\n  }\n  puVar1 = (undefined8 *)sh_xmalloc(0x10,\"make_cmd.c\",0x4c);\n  *(undefined4 *)(puVar1 + 1) = 0;\n  *puVar1 = 0;\n  return;\n}\n\n",
  "progcomp_remove": "\nundefined8 progcomp_remove(undefined8 param_1)\n\n{\n  int *piVar1;\n  long lVar2;\n  undefined8 uVar3;\n  \n  if (prog_completes != 0) {\n    lVar2 = hash_remove(param_1,prog_completes,0);\n    uVar3 = 0;\n    if (lVar2 != 0) {\n      piVar1 = *(int **)(lVar2 + 0x10);\n      if ((piVar1 != (int *)0x0) && (*piVar1 = *piVar1 + -1, *piVar1 == 0)) {\n        FUN_001a1120();\n      }\n      sh_xfree(*(undefined8 *)(lVar2 + 8),\"pcomplib.c\",0xa7);\n      sh_xfree(lVar2,\"pcomplib.c\",0xa8);\n      uVar3 = 1;\n    }\n    return uVar3;\n  }\n  return 1;\n}\n\n",
  "difftimeval": "\nlong * difftimeval(long *param_1,long *param_2,long *param_3)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  \n  lVar2 = *param_3;\n  lVar1 = *param_2;\n  *param_1 = lVar2 - lVar1;\n  lVar3 = param_3[1] - param_2[1];\n  if (-1 < lVar3) {\n    param_1[1] = lVar3;\n    return param_1;\n  }\n  param_1[1] = lVar3 + 1000000;\n  lVar2 = (lVar2 - lVar1) + -1;\n  if (-1 < lVar2) {\n    *param_1 = lVar2;\n    return param_1;\n  }\n  *param_1 = 0;\n  param_1[1] = 0;\n  return param_1;\n}\n\n",
  "_rl_signal_handler": "\nvoid _rl_signal_handler(int param_1)\n\n{\n  __pid_t __pid;\n  long lVar1;\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  _rl_caught_signal = 0;\n  rl_readline_state = rl_readline_state | 0x8000;\n  if (param_1 == 0x1c) {\n    rl_resize_terminal();\n    if (rl_signal_event_hook != (code *)0x0) {\n      (*rl_signal_event_hook)();\n    }\n    goto switchD_001e8700_caseD_0;\n  }\n  if (_rl_sigcleanup != (code *)0x0) {\n    (*_rl_sigcleanup)();\n    _rl_sigcleanup = (code *)0x0;\n    _rl_sigcleanarg = 0;\n  }\n  sigemptyset(&sStack_128);\n  sigprocmask(0,(sigset_t *)0x0,&sStack_128);\n  switch(param_1) {\n  default:\n    goto switchD_001e8700_caseD_0;\n  case 1:\n  case 0xe:\n  case 0xf:\n    if (param_1 == 0xe) {\n      _rl_timeout_handle_sigalrm();\n    }\n  case 3:\n    rl_echo_signal_char(param_1);\n    _rl_clean_up_for_exit();\n    if (rl_deprep_term_function == (undefined *)0x0) {\n      rl_clear_pending_input();\n      rl_clear_signals();\n    }\n    else {\n      (*(code *)rl_deprep_term_function)();\n      rl_clear_pending_input();\n      rl_clear_signals();\n    }\n    goto LAB_001e8739;\n  case 2:\n    _rl_reset_completion_state();\n    rl_free_undo_list();\n    lVar1 = current_history();\n    if (lVar1 != 0) {\n      *(undefined8 *)(lVar1 + 0x10) = 0;\n    }\n    _rl_kill_kbd_macro();\n    rl_clear_message();\n    _rl_reset_argument();\n    rl_callback_sigcleanup();\n    sigaddset(&sStack_128,0x16);\n    break;\n  case 0x14:\n  case 0x15:\n  case 0x16:\n    sigaddset(&sStack_128,0x16);\n  }\n  sigprocmask(0,&sStack_128,&local_a8);\n  rl_echo_signal_char(param_1);\n  _rl_clean_up_for_exit();\n  if (rl_deprep_term_function == (undefined *)0x0) {\n    rl_clear_pending_input();\n    rl_clear_signals();\n  }\n  else {\n    (*(code *)rl_deprep_term_function)();\n    rl_clear_pending_input();\n    rl_clear_signals();\n  }\n  sigprocmask(1,&local_a8,(sigset_t *)0x0);\nLAB_001e8739:\n  __pid = getpid();\n  kill(__pid,param_1);\n  if (rl_prep_term_function != (undefined *)0x0) {\n    (*(code *)rl_prep_term_function)(_rl_meta_flag);\n  }\n  rl_set_signals();\nswitchD_001e8700_caseD_0:\n  rl_readline_state = rl_readline_state & 0xffffffffffff7fff;\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "strlist_flush": "\nvoid strlist_flush(long *param_1)\n\n{\n  if (param_1 != (long *)0x0) {\n    if (*param_1 != 0) {\n      strvec_flush();\n      *(undefined4 *)((long)param_1 + 0xc) = 0;\n    }\n    return;\n  }\n  return;\n}\n\n",
  "get_word_from_string": "\nundefined8 get_word_from_string(byte **param_1,byte *param_2,byte **param_3)\n\n{\n  byte bVar1;\n  bool bVar2;\n  bool bVar3;\n  char cVar4;\n  int iVar5;\n  byte *pbVar6;\n  ushort **ppuVar7;\n  undefined8 uVar8;\n  int iVar9;\n  long lVar10;\n  bool bVar11;\n  ulong uVar12;\n  size_t sVar13;\n  byte *__s;\n  byte *pbVar14;\n  byte *pbVar15;\n  undefined8 *puVar16;\n  uint uVar17;\n  ushort uVar18;\n  int unaff_R14D;\n  long in_FS_OFFSET;\n  bool bVar19;\n  int local_168;\n  int local_154;\n  mbstate_t local_150;\n  undefined8 local_148;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((param_1 != (byte **)0x0) && (__s = *param_1, __s != (byte *)0x0)) &&\n     (uVar12 = (ulong)*__s, *__s != 0)) {\n    bVar19 = param_2 == (byte *)0x0;\n    if (bVar19) {\n      uVar17 = 0;\n      puVar16 = &local_148;\n      for (lVar10 = 0x20; lVar10 != 0; lVar10 = lVar10 + -1) {\n        *puVar16 = 0;\n        puVar16 = puVar16 + 1;\n      }\nLAB_0016e7ec:\n      while (cVar4 = (char)uVar12, bVar3 = (byte)(cVar4 - 9U) < 2, bVar19 = bVar3 || cVar4 == ' ',\n            bVar3 || cVar4 == ' ') {\n        if (*(char *)((long)&local_148 + uVar12) == '\\0') goto LAB_0016e649;\n        pbVar6 = __s + 1;\n        uVar12 = (ulong)*pbVar6;\n        __s = __s + 1;\n        if (*pbVar6 == 0) goto LAB_0016e810;\n      }\n      bVar19 = true;\nLAB_0016e649:\n      if (*__s != 0) {\n        local_154 = 0;\n        sVar13 = 1;\n        if ((__s[1] != 0) && (sVar13 = 2, __s[2] != 0)) {\n          sVar13 = strlen((char *)__s);\n        }\n        uVar8 = FUN_00167770(__s,sVar13,&local_154,param_2,uVar17);\n        iVar5 = local_154;\n        lVar10 = (long)local_154;\n        pbVar6 = __s + lVar10;\n        if (param_3 != (byte **)0x0) {\n          *param_3 = pbVar6;\n        }\n        bVar1 = *pbVar6;\n        if (bVar1 == 0) goto LAB_0016e7b1;\n        if (bVar19) {\n          if ((char)bVar1 < '\\v') {\n            uVar18 = (ushort)('\\b' < (char)bVar1);\n          }\n          else {\n            uVar18 = (ushort)(bVar1 == 0x20);\n          }\n        }\n        else {\n          ppuVar7 = __ctype_b_loc();\n          uVar18 = (*ppuVar7)[bVar1] >> 0xd & 1;\n        }\n        iVar9 = iVar5 + 1;\n        local_150.__count = 0;\n        local_150.__value = (_union_27)0x0;\n        if (1 < locale_mb_cur_max) {\n          bVar1 = *pbVar6;\n          if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale == 0) || ((char)bVar1 < '\\0')) {\n              sVar13 = mbrtowc((wchar_t *)0x0,(char *)pbVar6,sVar13 - lVar10,&local_150);\n              iVar9 = (int)sVar13;\n              if ((sVar13 < 0xfffffffffffffffe) && (sVar13 != 0)) goto LAB_0016e943;\n            }\n            else if (bVar1 != 0) goto LAB_0016e93e;\n            iVar9 = iVar5 + 1;\n          }\n          else {\nLAB_0016e93e:\n            iVar9 = 1;\nLAB_0016e943:\n            iVar9 = iVar9 + iVar5;\n          }\n        }\n        pbVar14 = __s + iVar9;\n        bVar1 = *pbVar14;\n        pbVar6 = pbVar14;\n        local_154 = iVar9;\n        if (bVar1 != 0) {\n          pbVar15 = __s + (long)iVar9 + 1;\n          bVar3 = false;\n          while( true ) {\n            uVar12 = (ulong)bVar1;\n            bVar2 = (byte)(bVar1 - 9) < 2;\n            bVar11 = bVar2 || bVar1 == 0x20;\n            if (!bVar2 && bVar1 != 0x20) break;\n            if (*(char *)((long)&local_148 + uVar12) == '\\0') {\n              pbVar6 = __s + unaff_R14D;\n              if (!bVar3) {\n                pbVar6 = pbVar14;\n              }\n              goto LAB_0016e7b1;\n            }\n            bVar1 = *pbVar15;\n            iVar9 = iVar9 + 1;\n            pbVar6 = pbVar15;\n            pbVar15 = pbVar15 + 1;\n            unaff_R14D = iVar9;\n            bVar3 = bVar11;\n            if (bVar1 == 0) goto LAB_0016e7b1;\n          }\n          if (bVar3) {\n            local_154 = unaff_R14D;\n          }\n          if (((uVar18 == 0) || (*(char *)((long)&local_148 + uVar12) == '\\0')) ||\n             ((!bVar19 &&\n              (ppuVar7 = __ctype_b_loc(), (*(byte *)((long)*ppuVar7 + uVar12 * 2 + 1) & 0x20) != 0))\n             )) {\n            pbVar6 = __s + local_154;\n          }\n          else {\n            pbVar14 = __s + (iVar9 + 1);\n            bVar1 = *pbVar14;\n            pbVar6 = pbVar14;\n            if (bVar1 != 0) {\n              lVar10 = (long)(iVar9 + 2);\n              goto LAB_0016e910;\n            }\n          }\n        }\n        goto LAB_0016e7b1;\n      }\n    }\n    else {\n      bVar1 = *param_2;\n      if (((bVar1 == 0x20) && (param_2[1] == 9)) && ((param_2[2] == 10 && (param_2[3] == 0)))) {\n        bVar19 = true;\n        puVar16 = &local_148;\n        for (lVar10 = 0x20; lVar10 != 0; lVar10 = lVar10 + -1) {\n          *puVar16 = 0;\n          puVar16 = puVar16 + 1;\n        }\n      }\n      else {\n        puVar16 = &local_148;\n        for (lVar10 = 0x20; lVar10 != 0; lVar10 = lVar10 + -1) {\n          *puVar16 = 0;\n          puVar16 = puVar16 + 1;\n        }\n      }\n      uVar17 = 0;\n      pbVar6 = param_2;\n      while (bVar1 != 0) {\n        if (bVar1 == 1) {\n          uVar17 = uVar17 | 0x10;\n        }\n        else if (bVar1 == 0x7f) {\n          uVar17 = uVar17 | 0x20;\n        }\n        pbVar6 = pbVar6 + 1;\n        *(undefined *)((long)&local_148 + (ulong)bVar1) = 1;\n        bVar1 = *pbVar6;\n      }\n      if (bVar19) goto LAB_0016e7ec;\n      ppuVar7 = __ctype_b_loc();\n      do {\n        if (((*(byte *)((long)*ppuVar7 + uVar12 * 2 + 1) & 0x20) == 0) ||\n           (*(char *)((long)&local_148 + uVar12) == '\\0')) goto LAB_0016e649;\n        pbVar6 = __s + 1;\n        uVar12 = (ulong)*pbVar6;\n        __s = __s + 1;\n      } while (*pbVar6 != 0);\n    }\nLAB_0016e810:\n    *param_1 = __s;\n    if (param_3 != (byte **)0x0) {\n      *param_3 = __s;\n    }\n  }\n  uVar8 = 0;\n  goto LAB_0016e7b4;\nLAB_0016e910:\n  do {\n    if (!bVar19) {\n      ppuVar7 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar7 + (ulong)bVar1 * 2 + 1) & 0x20) != 0) goto LAB_0016ea0a;\nLAB_0016e92b:\n      pbVar6 = pbVar14;\n      if (bVar11) {\n        pbVar6 = __s + local_168;\n      }\n      break;\n    }\n    if ('\\n' < (char)bVar1) {\n      if (bVar1 == 0x20) goto LAB_0016ea0a;\n      goto LAB_0016e92b;\n    }\n    if ((char)bVar1 < '\\t') goto LAB_0016e92b;\nLAB_0016ea0a:\n    if (*(char *)((long)&local_148 + (ulong)bVar1) == '\\0') goto LAB_0016e92b;\n    local_168 = (int)lVar10;\n    pbVar6 = __s + lVar10;\n    bVar11 = true;\n    bVar1 = __s[lVar10];\n    lVar10 = lVar10 + 1;\n  } while (bVar1 != 0);\nLAB_0016e7b1:\n  *param_1 = pbVar6;\nLAB_0016e7b4:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar8;\n}\n\n",
  "dispose_command": "\nvoid dispose_command(undefined4 *param_1)\n\n{\n  undefined8 *puVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  \n  if (param_1 != (undefined4 *)0x0) {\n    if (*(long *)(param_1 + 4) != 0) {\n      dispose_redirects();\n    }\n    switch(*param_1) {\n    case 0:\n    case 5:\n      lVar2 = *(long *)(param_1 + 6);\n      dispose_word(*(undefined8 *)(lVar2 + 8));\n      dispose_words(*(undefined8 *)(lVar2 + 0x10));\n      dispose_command(*(undefined8 *)(lVar2 + 0x18));\n      sh_xfree(lVar2,\"dispose_cmd.c\",0x3e);\n      break;\n    case 1:\n      lVar2 = *(long *)(param_1 + 6);\n      dispose_word(*(undefined8 *)(lVar2 + 8));\n      puVar3 = *(undefined8 **)(lVar2 + 0x10);\n      while (puVar3 != (undefined8 *)0x0) {\n        dispose_words(puVar3[1]);\n        dispose_command(puVar3[2]);\n        puVar1 = (undefined8 *)*puVar3;\n        sh_xfree(puVar3,\"dispose_cmd.c\",0x75);\n        puVar3 = puVar1;\n      }\n      sh_xfree(lVar2,\"dispose_cmd.c\",0x77);\n      break;\n    case 2:\n    case 8:\n      lVar2 = *(long *)(param_1 + 6);\n      dispose_command(*(undefined8 *)(lVar2 + 8));\n      dispose_command(*(undefined8 *)(lVar2 + 0x10));\n      sh_xfree(lVar2,\"dispose_cmd.c\",0x83);\n      break;\n    case 3:\n      lVar2 = *(long *)(param_1 + 6);\n      dispose_command(*(undefined8 *)(lVar2 + 8));\n      dispose_command(*(undefined8 *)(lVar2 + 0x10));\n      dispose_command(*(undefined8 *)(lVar2 + 0x18));\n      sh_xfree(lVar2,\"dispose_cmd.c\",0x8f);\n      break;\n    case 4:\n      lVar2 = *(long *)(param_1 + 6);\n      dispose_words(*(undefined8 *)(lVar2 + 8));\n      dispose_redirects(*(undefined8 *)(lVar2 + 0x10));\n      sh_xfree(lVar2,\"dispose_cmd.c\",0x9a);\n      break;\n    case 6:\n      lVar2 = *(long *)(param_1 + 6);\n      dispose_command(*(undefined8 *)(lVar2 + 8));\n      dispose_command(*(undefined8 *)(lVar2 + 0x10));\n      sh_xfree(lVar2,\"dispose_cmd.c\",0xa5);\n      break;\n    case 7:\n      lVar2 = *(long *)(param_1 + 6);\n      dispose_word(*(undefined8 *)(lVar2 + 8));\n      dispose_command(*(undefined8 *)(lVar2 + 0x10));\n      if (*(long *)(lVar2 + 0x18) != 0) {\n        sh_xfree(*(long *)(lVar2 + 0x18),\"dispose_cmd.c\",0xe9);\n      }\n      sh_xfree(lVar2,\"dispose_cmd.c\",0xf1);\n      break;\n    case 9:\n      dispose_command(*(undefined8 *)(*(long *)(param_1 + 6) + 8));\n      sh_xfree(*(undefined8 *)(param_1 + 6),\"dispose_cmd.c\",0x54);\n      break;\n    case 10:\n      lVar2 = *(long *)(param_1 + 6);\n      dispose_words(*(undefined8 *)(lVar2 + 8));\n      sh_xfree(lVar2,\"dispose_cmd.c\",0xb0);\n      break;\n    case 0xb:\n      dispose_cond_node(*(undefined8 *)(param_1 + 6));\n      break;\n    case 0xc:\n      lVar2 = *(long *)(param_1 + 6);\n      dispose_words(*(undefined8 *)(lVar2 + 8));\n      dispose_words(*(undefined8 *)(lVar2 + 0x10));\n      dispose_words(*(undefined8 *)(lVar2 + 0x18));\n      dispose_command(*(undefined8 *)(lVar2 + 0x20));\n      sh_xfree(lVar2,\"dispose_cmd.c\",0x4c);\n      break;\n    case 0xd:\n      dispose_command(*(undefined8 *)(*(long *)(param_1 + 6) + 8));\n      sh_xfree(*(undefined8 *)(param_1 + 6),\"dispose_cmd.c\",0x5b);\n      break;\n    case 0xe:\n      sh_xfree(*(undefined8 *)(*(long *)(param_1 + 6) + 8),\"dispose_cmd.c\",0x61);\n      dispose_command(*(undefined8 *)(*(long *)(param_1 + 6) + 0x10));\n      sh_xfree(*(undefined8 *)(param_1 + 6),\"dispose_cmd.c\",99);\n      break;\n    default:\n      command_error(\"dispose_command\",1,*param_1,0);\n    }\n    sh_xfree(param_1,\"dispose_cmd.c\",0xcd);\n    return;\n  }\n  return;\n}\n\n",
  "wcsrtombs": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t wcsrtombs(char *__dst,wchar_t **__src,size_t __len,mbstate_t *__ps)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_wcsrtombs_00237978)();\n  return sVar1;\n}\n\n",
  "FUN_00134d70": "\nvoid FUN_00134d70(void)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  pcVar4 = DAT_00240da8;\n  sVar2 = strlen(DAT_00240da8);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"/usr/local/src/chet/src/bash/src/parse.y\",0x182c);\n  pcVar4 = strcpy(pcVar3,pcVar4);\n  sVar2 = strlen(pcVar4);\n  iVar1 = (int)sVar2;\n  if (iVar1 != 0) {\n    pcVar3 = pcVar4 + (long)iVar1 + -1;\n    do {\n      if (*pcVar3 != '\\n') break;\n      *pcVar3 = '\\0';\n      pcVar3 = pcVar3 + -1;\n    } while (pcVar3 != pcVar4 + (((long)iVar1 + -2) - (ulong)(iVar1 - 1)));\n  }\n  parser_error(line_number,\"`%s\\'\",pcVar4);\n  sh_xfree(pcVar4,\"/usr/local/src/chet/src/bash/src/parse.y\",0x1832);\n  return;\n}\n\n",
  "unbind_args": "\nvoid unbind_args(void)\n\n{\n  remember_args(0,1);\n  pop_args();\n  return;\n}\n\n",
  "legal_identifier": "\nundefined8 legal_identifier(byte *param_1)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  ushort **ppuVar3;\n  byte *pbVar4;\n  undefined8 uVar5;\n  \n  if (param_1 == (byte *)0x0) {\n    return 0;\n  }\n  bVar2 = *param_1;\n  uVar5 = 0;\n  if (bVar2 != 0) {\n    ppuVar3 = __ctype_b_loc();\n    if (((*(byte *)((long)*ppuVar3 + (ulong)bVar2 * 2 + 1) & 4) != 0) || (bVar2 == 0x5f)) {\n      pbVar4 = param_1 + 1;\n      bVar2 = param_1[1];\n      while (bVar2 != 0) {\n        if (((*(byte *)(*ppuVar3 + bVar2) & 8) == 0) && (bVar2 != 0x5f)) {\n          return 0;\n        }\n        pbVar1 = pbVar4 + 1;\n        pbVar4 = pbVar4 + 1;\n        bVar2 = *pbVar1;\n      }\n      uVar5 = 1;\n    }\n  }\n  return uVar5;\n}\n\n",
  "rl_backward_byte": "\nundefined8 rl_backward_byte(int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (param_1 < 0) {\n    uVar1 = rl_forward_byte(-param_1);\n    return uVar1;\n  }\n  if (param_1 == 0) {\n    if (rl_point < 0) {\n      rl_point = 0;\n      return 0;\n    }\n  }\n  else {\n    if (rl_point < param_1) {\n      rl_point = 0;\n      rl_ding();\n      if (rl_point < 0) {\n        rl_point = 0;\n      }\n      return 0;\n    }\n    rl_point = rl_point - param_1;\n  }\n  return 0;\n}\n\n",
  "FUN_0019e7c0": "\nundefined8 FUN_0019e7c0(uint *param_1)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  \n  uVar2 = rl_funmap_names();\n  puVar3 = (undefined8 *)strlist_create(0);\n  *puVar3 = uVar2;\n  *(undefined4 *)(puVar3 + 1) = 0;\n  uVar1 = strvec_len(uVar2);\n  *(undefined4 *)((long)puVar3 + 0xc) = uVar1;\n  *(undefined8 **)(param_1 + 4) = puVar3;\n  *param_1 = *param_1 | 0x20;\n  return 0;\n}\n\n",
  "sh_neednumarg": "\nvoid sh_neednumarg(undefined8 param_1)\n\n{\n  builtin_error(\"%s: numeric argument required\",param_1);\n  return;\n}\n\n",
  "FUN_001bf950": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nuint FUN_001bf950(uint param_1,uint param_2,uint param_3)\n\n{\n  uint uVar1;\n  \n  if (param_1 == param_2) {\n    uVar1 = 0;\n  }\n  else {\n    if (((param_3 == 0) && (glob_asciirange != 0)) && ((param_1 | param_2) < 0x100))\n    goto LAB_001bf993;\n    _DAT_0023a6d0 = param_2;\n    _DAT_0023a6d8 = param_1;\n    uVar1 = wcscoll((wchar_t *)&DAT_0023a6d8,(wchar_t *)&DAT_0023a6d0);\n    param_3 = param_3 | uVar1;\n  }\n  if (param_3 != 0) {\n    return uVar1;\n  }\nLAB_001bf993:\n  return param_1 - param_2;\n}\n\n",
  "command_error": "\nvoid command_error(undefined8 param_1,int param_2,undefined4 param_3)\n\n{\n  if (3 < param_2) {\n    param_2 = 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  programming_error(\"%s: %s: %d\",param_1,(&PTR_s_unknown_command_error_00234b20)[param_2],param_3);\n}\n\n",
  "rl_get_screen_size": "\nvoid rl_get_screen_size(undefined4 *param_1,undefined4 *param_2)\n\n{\n  if (param_1 != (undefined4 *)0x0) {\n    *param_1 = _rl_screenheight;\n  }\n  if (param_2 != (undefined4 *)0x0) {\n    *param_2 = _rl_screenwidth;\n  }\n  return;\n}\n\n",
  "make_command": "\nvoid make_command(undefined4 param_1,undefined4 *param_2)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x20,\"make_cmd.c\",0xb1);\n  *puVar1 = param_1;\n  *(undefined4 **)(puVar1 + 6) = param_2;\n  puVar1[1] = 0;\n  *param_2 = 0;\n  *(undefined8 *)(puVar1 + 4) = 0;\n  return;\n}\n\n",
  "show_name_attributes": "\nbool show_name_attributes(undefined8 param_1,undefined4 param_2)\n\n{\n  long lVar1;\n  \n  lVar1 = find_variable_noref();\n  if (lVar1 != 0) {\n    show_var_attributes(lVar1,this_shell_builtin == export_builtin ||\n                              this_shell_builtin == readonly_builtin,param_2);\n  }\n  return lVar1 == 0;\n}\n\n",
  "with_input_from_stdin": "\nvoid with_input_from_stdin(void)\n\n{\n  long *plVar1;\n  \n  if (bash_input == 1) {\n    return;\n  }\n  plVar1 = stream_list;\n  if (stream_list != (long *)0x0) {\n    do {\n      if (*(int *)(plVar1 + 1) == 1) {\n        return;\n      }\n      plVar1 = (long *)*plVar1;\n    } while (plVar1 != (long *)0x0);\n  }\n  init_yy_io(FUN_00134e10,FUN_00134ae0,1,\"readline stdin\",current_readline_line);\n  return;\n}\n\n",
  "FUN_00135010": "\nundefined8 FUN_00135010(void)\n\n{\n  undefined8 uVar1;\n  \n  if (DAT_00240a70 != 0) {\n    uVar1 = getc_with_restart();\n    return uVar1;\n  }\n  return 0xffffffff;\n}\n\n",
  "u32toutf16": "\nundefined8 u32toutf16(uint param_1,uint *param_2)\n\n{\n  if ((0x1fff < param_1 - 0xe000) && (0xd7ff < param_1)) {\n    param_1 = param_1 - 0x10000;\n    if (0xfffff < param_1) {\n      *param_2 = 0;\n      return 0;\n    }\n    param_2[1] = (param_1 & 0x3ff) + 0xdc00;\n    *param_2 = (param_1 >> 10) + 0xd800;\n    param_2[2] = 0;\n    return 2;\n  }\n  *param_2 = param_1;\n  param_2[1] = 0;\n  return 1;\n}\n\n",
  "FUN_0016aa90": "\nbyte * FUN_0016aa90(long param_1,uint *param_2,uint param_3)\n\n{\n  byte *pbVar1;\n  uint uVar2;\n  bool bVar3;\n  bool bVar4;\n  mbstate_t mVar5;\n  int iVar6;\n  size_t sVar7;\n  byte *pbVar8;\n  byte *__s;\n  byte *pbVar9;\n  long lVar10;\n  size_t sVar11;\n  byte bVar12;\n  size_t sVar13;\n  long lVar14;\n  byte *pbVar15;\n  uint uVar16;\n  long lVar17;\n  uint uVar18;\n  int iVar19;\n  int iVar20;\n  ulong uVar21;\n  ulong uVar22;\n  long in_FS_OFFSET;\n  bool bVar23;\n  uint local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  uVar16 = param_3 & 0x800;\n  uVar2 = *param_2;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar7 = strlen((char *)(param_1 + (int)uVar2));\n  pbVar8 = (byte *)sh_xmalloc(sVar7 + 1,\"subst.c\",0x370);\n  uVar18 = *param_2;\n  uVar21 = (ulong)(int)uVar18;\n  __s = (byte *)(param_1 + uVar21);\n  bVar12 = *__s;\n  pbVar15 = pbVar8;\n  if (bVar12 != 0) {\n    bVar4 = false;\n    bVar23 = false;\n    bVar3 = false;\n    iVar19 = 0;\n    lVar17 = 0;\n    uVar22 = uVar21;\n    do {\n      mVar5 = local_48;\n      pbVar15 = pbVar8 + lVar17;\n      iVar20 = (int)uVar21;\n      if (bVar3) {\n        if (((uVar16 == 0) && (bVar12 != 0x22)) ||\n           ((uVar21 = (ulong)(iVar20 + 1), uVar16 != 0 &&\n            ((!bVar4 || ((*(byte *)(&sh_syntaxtab + bVar12) & 0x40) != 0)))))) {\n          *pbVar15 = 0x5c;\n          iVar19 = iVar19 + 1;\n          uVar21 = (ulong)(iVar20 + 1);\n          lVar17 = (long)iVar19;\n        }\n        goto LAB_0016abc1;\n      }\n      if (bVar12 == 0x5c) {\n        uVar21 = (ulong)(iVar20 + 1U);\n        bVar3 = true;\n        uVar22 = (ulong)(int)(iVar20 + 1U);\n        __s = (byte *)(param_1 + uVar22);\n      }\n      else if (bVar23) {\n        bVar23 = bVar12 != 0x60;\n        *pbVar15 = bVar12;\n        iVar19 = iVar19 + 1;\n        uVar21 = (ulong)(iVar20 + 1U);\n        uVar22 = (ulong)(int)(iVar20 + 1U);\n        lVar17 = (long)iVar19;\n        __s = (byte *)(param_1 + uVar22);\n        pbVar15 = pbVar8 + lVar17;\n      }\n      else if (bVar12 == 0x60) {\n        iVar19 = iVar19 + 1;\n        uVar21 = (ulong)(iVar20 + 1U);\n        *pbVar15 = 0x60;\n        bVar23 = true;\n        uVar22 = (ulong)(int)(iVar20 + 1U);\n        lVar17 = (long)iVar19;\n        __s = (byte *)(param_1 + uVar22);\n        pbVar15 = pbVar8 + lVar17;\n      }\n      else if (bVar12 == 0x24) {\n        pbVar1 = (byte *)(param_1 + 1 + uVar22);\n        bVar12 = *pbVar1;\n        if ((bVar12 != 0x28) && (uVar21 = (ulong)(iVar20 + 1), bVar12 != 0x7b)) goto LAB_0016abc1;\n        uVar18 = iVar20 + 2;\n        local_4c = uVar18;\n        if (bVar12 == 0x28) {\n          pbVar9 = (byte *)extract_command_subst(param_1,&local_4c,param_3 & 0x400);\n        }\n        else {\n          pbVar9 = (byte *)FUN_001691b0(param_1,&local_4c,1,0);\n        }\n        *pbVar15 = 0x24;\n        bVar3 = true;\n        pbVar8[iVar19 + 1] = *pbVar1;\n        if (pbVar9 == (byte *)0x0) {\n          if (no_longjmp_on_fatal_error == 0) {\n            do {\n              invalidInstructionException();\n            } while( true );\n          }\n          pbVar9 = (byte *)(param_1 + 2 + uVar22);\n          bVar3 = false;\n        }\n        bVar12 = *pbVar9;\n        iVar6 = iVar19 + 2;\n        if (bVar12 != 0) {\n          lVar10 = (long)(iVar19 + 3);\n          do {\n            pbVar8[lVar10 + -1] = bVar12;\n            iVar6 = (int)lVar10;\n            lVar10 = lVar10 + 1;\n            bVar12 = pbVar9[lVar10 + (-3 - lVar17)];\n          } while (bVar12 != 0);\n        }\n        iVar19 = iVar6;\n        lVar17 = (long)iVar19;\n        pbVar15 = pbVar8 + lVar17;\n        *pbVar15 = *(byte *)(param_1 + (int)local_4c);\n        uVar21 = (ulong)local_4c;\n        if (iVar20 + 1 < (int)local_4c) {\n          uVar22 = (ulong)(int)local_4c;\n          __s = (byte *)(param_1 + uVar22);\n          if (*__s != 0) {\n            iVar19 = iVar19 + 1;\n            uVar18 = local_4c + 1;\n            lVar17 = (long)iVar19;\n            pbVar15 = pbVar8 + lVar17;\n            goto LAB_0016adf9;\n          }\n          uVar18 = local_4c;\n          if (!bVar3) break;\n        }\n        else {\nLAB_0016adf9:\n          uVar21 = (ulong)uVar18;\n          uVar22 = (ulong)(int)uVar18;\n          __s = (byte *)(param_1 + uVar22);\n          if (!bVar3) {\n            bVar23 = false;\n            goto LAB_0016abef;\n          }\n        }\n        sh_xfree(pbVar9,\"subst.c\",0x3e0);\n        bVar3 = false;\n      }\n      else {\n        uVar18 = iVar20 + 1;\n        uVar21 = (ulong)uVar18;\n        if (bVar12 == 0x22) {\n          if (uVar16 == 0) {\n            *pbVar15 = 0;\n            goto LAB_0016ab6f;\n          }\n          uVar22 = (ulong)(int)uVar18;\n          bVar4 = (bool)(bVar4 ^ 1);\n          uVar21 = (ulong)uVar18;\n          __s = (byte *)(param_1 + uVar22);\n        }\n        else {\nLAB_0016abc1:\n          iVar19 = iVar19 + 1;\n          bVar12 = *__s;\n          pbVar15 = pbVar8 + lVar17;\n          uVar18 = (uint)uVar21;\n          if (locale_mb_cur_max < 2) {\n            uVar22 = (ulong)(int)uVar18;\n            lVar17 = (long)iVar19;\n            *pbVar15 = bVar12;\n            __s = (byte *)(param_1 + uVar22);\n            pbVar15 = pbVar8 + lVar17;\n            bVar3 = false;\n          }\n          else {\n            if ((*(uint *)(is_basic_table + (ulong)(bVar12 >> 5) * 4) >> (bVar12 & 0x1f) & 1) == 0)\n            {\n              if ((locale_utf8locale != 0) && (sVar13 = 1, -1 < (char)bVar12)) goto LAB_0016ac8d;\n              sVar11 = mbrtowc((wchar_t *)0x0,(char *)__s,((long)(int)uVar2 + sVar7) - (long)iVar20,\n                               &local_48);\n              if (sVar11 < 0xfffffffffffffffe) {\n                sVar13 = 1;\n                if (sVar11 != 0) {\n                  sVar13 = sVar11;\n                }\n                goto LAB_0016ac8d;\n              }\n              *pbVar15 = *(byte *)(param_1 + iVar20);\n              local_48 = mVar5;\n            }\n            else {\n              sVar13 = 1;\nLAB_0016ac8d:\n              lVar14 = (long)iVar20;\n              lVar17 = lVar17 - lVar14;\n              lVar10 = lVar14 + sVar13;\n              do {\n                pbVar8[lVar14 + lVar17] = *(byte *)(param_1 + lVar14);\n                lVar14 = lVar14 + 1;\n              } while (lVar10 != lVar14);\n              iVar20 = (int)sVar13 + -1;\n              uVar18 = uVar18 + iVar20;\n              iVar19 = iVar19 + iVar20;\n            }\n            uVar21 = (ulong)uVar18;\n            uVar22 = (ulong)(int)uVar18;\n            lVar17 = (long)iVar19;\n            bVar3 = false;\n            __s = (byte *)(param_1 + uVar22);\n            pbVar15 = pbVar8 + lVar17;\n          }\n        }\n      }\nLAB_0016abef:\n      bVar12 = *__s;\n      uVar18 = (uint)uVar21;\n    } while (bVar12 != 0);\n  }\n  *pbVar15 = 0;\nLAB_0016ab6f:\n  *param_2 = uVar18;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pbVar8;\n}\n\n",
  "get_exitstat": "\nuint get_exitstat(long *param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  long lVar3;\n  undefined *puVar4;\n  char *pcVar5;\n  uint uVar6;\n  long in_FS_OFFSET;\n  byte local_18 [8];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (long *)0x0) {\nLAB_001a45b0:\n    if (((this_shell_builtin != return_builtin) || (running_trap < 1)) ||\n       (uVar6 = trap_saved_exit_value, running_trap == 0x42)) {\n      uVar6 = last_command_exit_value;\n    }\n  }\n  else {\n    pcVar5 = *(char **)param_1[1];\n    if (((*pcVar5 == '-') && (pcVar5[1] == '-')) && (pcVar5[2] == '\\0')) {\n      param_1 = (long *)*param_1;\n      if (param_1 == (long *)0x0) goto LAB_001a45b0;\n      pcVar5 = *(char **)param_1[1];\n      if (pcVar5 != (char *)0x0) goto LAB_001a455d;\nLAB_001a4624:\n      puVar4 = &DAT_0020f367;\n    }\n    else {\nLAB_001a455d:\n      iVar2 = legal_number(pcVar5,local_18);\n      if (iVar2 != 0) {\n        if (*param_1 != 0) {\n          FUN_001a3b30();\n          lVar3 = 0;\n          uVar6 = 0;\n          while( true ) {\n            bVar1 = pcVar5[lVar3] - 0x30;\n            if (7 < bVar1) break;\n            lVar3 = lVar3 + 1;\n            uVar6 = (int)(char)bVar1 + uVar6 * 8;\n            if (0xfff < (int)uVar6) {\n              return 0xffffffff;\n            }\n          }\n          if (pcVar5[lVar3] != '\\0') {\n            return 0xffffffff;\n          }\n          if ((int)lVar3 == 0) {\n            return 0xffffffff;\n          }\n          return uVar6;\n        }\n        uVar6 = (uint)local_18[0];\n        goto LAB_001a457b;\n      }\n      puVar4 = *(undefined **)param_1[1];\n      if (puVar4 == (undefined *)0x0) goto LAB_001a4624;\n    }\n    builtin_error(\"%s: numeric argument required\",puVar4);\n    uVar6 = 2;\n  }\nLAB_001a457b:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar6;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "sh_makepath": "\nchar * sh_makepath(undefined2 *param_1,char *param_2,byte param_3)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  undefined2 *puVar3;\n  undefined2 *puVar4;\n  undefined2 *puVar5;\n  long lVar6;\n  undefined8 uVar7;\n  char *pcVar8;\n  char *pcVar9;\n  bool bVar10;\n  bool bVar11;\n  char cVar12;\n  int iVar13;\n  int local_40;\n  \n  if ((param_1 != (undefined2 *)0x0) && (cVar12 = *(char *)param_1, cVar12 != '\\0')) {\n    if (((param_3 & 8) == 0) || (cVar12 != '.')) {\n      bVar10 = (bool)(cVar12 == '~' & param_3);\n      if (bVar10 != false) {\n        puVar3 = (undefined2 *)bash_tilde_expand(param_1,0);\n        bVar10 = param_1 != puVar3 && puVar3 != (undefined2 *)&DAT_00213d70;\n        param_1 = puVar3;\n      }\n    }\n    else {\n      bVar10 = false;\n      if (*(char *)((long)param_1 + 1) == '\\0') {\n        local_40 = 0;\n        puVar3 = (undefined2 *)&DAT_00213d70;\n        bVar11 = bVar10;\n        goto LAB_001c626d;\n      }\n      if (*(char *)((long)param_1 + 1) == '/') {\n        local_40 = 0;\n        puVar3 = (undefined2 *)&DAT_00213d70;\n        bVar11 = false;\n        if (*(char *)(param_1 + 1) == '\\0') goto LAB_001c626d;\n      }\n    }\n    puVar3 = param_1;\n    sVar1 = strlen((char *)puVar3);\n    local_40 = (int)sVar1;\n    bVar11 = bVar10;\n    goto LAB_001c626d;\n  }\n  if ((param_3 & 2) == 0) {\n    uVar7 = 0x5e;\nLAB_001c6236:\n    puVar3 = (undefined2 *)sh_xmalloc(2,\"makepath.c\",uVar7);\n    *puVar3 = 0x2e;\n    local_40 = 1;\n    bVar11 = param_1 != puVar3 && puVar3 != (undefined2 *)&DAT_00213d70;\n  }\n  else {\n    puVar3 = (undefined2 *)get_working_directory(\"sh_makepath\");\n    if (puVar3 == (undefined2 *)0x0) {\n      pcVar9 = (char *)get_string_value(&DAT_001fc3d5);\n      uVar7 = 0x59;\n      if (pcVar9 == (char *)0x0) goto LAB_001c6236;\n      sVar1 = strlen(pcVar9);\n      pcVar2 = (char *)sh_xmalloc(sVar1 + 1,\"makepath.c\",0x56);\n      puVar3 = (undefined2 *)strcpy(pcVar2,pcVar9);\n    }\n    sVar1 = strlen((char *)puVar3);\n    local_40 = (int)sVar1;\n    bVar11 = param_1 != puVar3 && puVar3 != (undefined2 *)&DAT_00213d70;\n  }\nLAB_001c626d:\n  sVar1 = strlen(param_2);\n  iVar13 = (int)sVar1;\n  if ((((param_3 & 4) == 0) || (*param_2 != '.')) || (param_2[1] != '/')) {\n    iVar13 = iVar13 + 2;\n  }\n  else {\n    param_2 = param_2 + 2;\n  }\n  pcVar2 = (char *)sh_xmalloc((long)(iVar13 + local_40),\"makepath.c\",0x74);\n  cVar12 = *(char *)puVar3;\n  puVar5 = puVar3;\n  pcVar9 = pcVar2;\n  if (cVar12 != '\\0') {\n    do {\n      pcVar8 = pcVar9;\n      puVar4 = puVar5;\n      puVar5 = (undefined2 *)((long)puVar4 + 1);\n      pcVar9 = pcVar8 + 1;\n      *pcVar8 = cVar12;\n      cVar12 = *(char *)puVar5;\n    } while (cVar12 != '\\0');\n    if ((puVar3 < puVar5) && (*(char *)puVar4 != '/')) {\n      *pcVar9 = '/';\n      pcVar9 = pcVar8 + 2;\n    }\n  }\n  lVar6 = 0;\n  do {\n    cVar12 = param_2[lVar6];\n    pcVar9[lVar6] = cVar12;\n    lVar6 = lVar6 + 1;\n  } while (cVar12 != '\\0');\n  if (bVar11 != false) {\n    sh_xfree(puVar3,\"makepath.c\",0x7e);\n  }\n  return pcVar2;\n}\n\n",
  "FUN_001cf760": "\nvoid FUN_001cf760(int param_1,int param_2)\n\n{\n  char *pcVar1;\n  \n  if (DAT_0024a404 <= param_2) {\n    DAT_0024a404 = ((param_2 + 0x20) - param_2 % 0x20) + DAT_0024a404;\n    DAT_0024a408 = (char *)xrealloc(DAT_0024a408,(long)DAT_0024a404);\n  }\n  pcVar1 = strncpy(DAT_0024a408,(char *)(param_1 + rl_line_buffer),(long)(param_2 + -1));\n  pcVar1[(long)param_2 + -1] = '\\0';\n  return;\n}\n\n",
  "print_simple_command": "\nvoid print_simple_command(long param_1)\n\n{\n  undefined *puVar1;\n  long *plVar2;\n  long lVar3;\n  \n  plVar2 = *(long **)(param_1 + 8);\n  if (plVar2 == (long *)0x0) {\n    lVar3 = *(long *)(param_1 + 0x10);\n    if (lVar3 == 0) {\n      return;\n    }\n  }\n  else {\n    do {\n      puVar1 = &DAT_00213d70;\n      if (*plVar2 != 0) {\n        puVar1 = &DAT_001fdb1c;\n      }\n      FUN_001446d0(&DAT_001fc632,*(undefined8 *)plVar2[1],puVar1);\n      plVar2 = (long *)*plVar2;\n    } while (plVar2 != (long *)0x0);\n    lVar3 = *(long *)(param_1 + 0x10);\n    if (lVar3 == 0) {\n      return;\n    }\n    if (*(long *)(param_1 + 8) != 0) {\n      FUN_001446d0(&DAT_001fdb1c);\n      lVar3 = *(long *)(param_1 + 0x10);\n    }\n  }\n  FUN_00144c70(lVar3);\n  return;\n}\n\n",
  "rl_previous_screen_line": "\nvoid rl_previous_screen_line(void)\n\n{\n  rl_backward_char(_rl_screenwidth + (uint)(_rl_term_autowrap == 0));\n  return;\n}\n\n",
  "give_terminal_to": "\nuint give_terminal_to(__pid_t param_1,uint param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  param_2 = param_2 | job_control;\n  if (param_2 != 0) {\n    sigemptyset(&sStack_128);\n    sigaddset(&sStack_128,0x16);\n    sigaddset(&sStack_128,0x15);\n    sigaddset(&sStack_128,0x14);\n    sigaddset(&sStack_128,0x11);\n    sigemptyset(&local_a8);\n    sigprocmask(0,&sStack_128,&local_a8);\n    iVar1 = tcsetpgrp(shell_tty,param_1);\n    if (iVar1 < 0) {\n      piVar2 = __errno_location();\n      iVar1 = *piVar2;\n      sigprocmask(2,&local_a8,(sigset_t *)0x0);\n      param_2 = 0xffffffff;\n      *piVar2 = iVar1;\n    }\n    else {\n      terminal_pgrp = param_1;\n      sigprocmask(2,&local_a8,(sigset_t *)0x0);\n      param_2 = 0;\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "array_unshift_element": "\nvoid array_unshift_element(undefined8 param_1)\n\n{\n  array_shift(param_1,1,0);\n  return;\n}\n\n",
  "sv_histignore": "\nvoid sv_histignore(void)\n\n{\n  setup_history_ignore();\n  return;\n}\n\n",
  "FUN_001335b0": "\n/* WARNING: Removing unreachable block (ram,0x001335d4) */\n/* WARNING: Removing unreachable block (ram,0x001335e0) */\n\nvoid FUN_001335b0(void)\n\n{\n  return;\n}\n\n",
  "gen_compspec_completions": "\nlong * gen_compspec_completions\n                 (long param_1,char *param_2,undefined8 param_3,int param_4,int param_5,\n                 uint *param_6)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  int iVar3;\n  int iVar4;\n  undefined8 *puVar5;\n  undefined8 *puVar6;\n  size_t sVar7;\n  long lVar8;\n  long **pplVar9;\n  long *plVar10;\n  char *pcVar11;\n  long lVar12;\n  long **pplVar13;\n  size_t sVar14;\n  char *pcVar15;\n  char **ppcVar16;\n  undefined8 uVar17;\n  ulong uVar18;\n  char *__dest;\n  ulong uVar19;\n  int iVar20;\n  undefined *puVar21;\n  long in_FS_OFFSET;\n  long *local_a0;\n  int local_98;\n  long local_88;\n  uint local_70;\n  uint local_6c;\n  int local_4c;\n  int local_48;\n  uint local_44;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_a0 = (long *)FUN_0019f840(*(undefined8 *)(param_1 + 8),param_3);\n  if (*(long *)(param_1 + 0x18) != 0) {\n    puVar5 = (undefined8 *)strlist_create(0);\n    puVar6 = (undefined8 *)\n             glob_filename(*(undefined8 *)(param_1 + 0x18),(ulong)(glob_star != 0) << 10);\n    if (puVar6 == &glob_error_return) {\n      *puVar5 = 0;\n    }\n    else {\n      *puVar5 = puVar6;\n      if (puVar6 != (undefined8 *)0x0) {\n        uVar2 = strvec_len();\n        *(undefined4 *)(puVar5 + 1) = uVar2;\n        *(undefined4 *)((long)puVar5 + 0xc) = uVar2;\n      }\n    }\n    local_a0 = (long *)strlist_append(local_a0,puVar5);\n    strlist_dispose(puVar5);\n    rl_filename_completion_desired = 1;\n  }\n  pcVar11 = *(char **)(param_1 + 0x20);\n  if ((pcVar11 != (char *)0x0) && (*pcVar11 != '\\0')) {\n    sVar7 = strlen(pcVar11);\n    lVar8 = split_at_delims(pcVar11,sVar7 & 0xffffffff,0,0xffffffff,0,0,0);\n    if (lVar8 != 0) {\n      pplVar9 = (long **)expand_words_shellexp(lVar8);\n      dispose_words(lVar8);\n      iVar3 = list_length(pplVar9);\n      plVar10 = (long *)strlist_create(iVar3 + 1);\n      pcVar11 = (char *)bash_dequote_text(param_3);\n      if (pcVar11 == (char *)0x0) {\n        iVar3 = 0;\n        if (pplVar9 != (long **)0x0) goto LAB_001a0109;\n        *(undefined4 *)((long)plVar10 + 0xc) = 0;\n        *(undefined8 *)*plVar10 = 0;\n        dispose_words(0);\n      }\n      else {\n        if (*pcVar11 == '\\0') {\n          iVar3 = 0;\n        }\n        else if (pcVar11[1] == '\\0') {\n          iVar3 = 1;\n        }\n        else if (pcVar11[2] == '\\0') {\n          iVar3 = 2;\n        }\n        else {\n          sVar7 = strlen(pcVar11);\n          iVar3 = (int)sVar7;\n        }\n        if (pplVar9 == (long **)0x0) {\n          *(undefined4 *)((long)plVar10 + 0xc) = 0;\n          *(undefined8 *)*plVar10 = 0;\n          dispose_words(0);\n        }\n        else {\nLAB_001a0109:\n          iVar20 = 0;\n          pplVar13 = pplVar9;\n          do {\n            while (pcVar15 = (char *)*pplVar13[1], iVar3 == 0) {\n              if (pcVar15 != (char *)0x0) goto LAB_001a0976;\nLAB_001a0163:\n              pplVar13 = (long **)*pplVar13;\n              lVar8 = (long)iVar20;\n              iVar20 = iVar20 + 1;\n              *(char **)(*plVar10 + lVar8 * 8) = pcVar15;\n              if (pplVar13 == (long **)0x0) goto LAB_001a0179;\n            }\n            if ((*pcVar15 == *pcVar11) && (iVar4 = strncmp(pcVar15,pcVar11,(long)iVar3), iVar4 == 0)\n               ) {\nLAB_001a0976:\n              sVar7 = strlen(pcVar15);\n              __dest = (char *)sh_xmalloc(sVar7 + 1,\"pcomplete.c\",0x3b1);\n              pcVar15 = strcpy(__dest,pcVar15);\n              goto LAB_001a0163;\n            }\n            pplVar13 = (long **)*pplVar13;\n          } while (pplVar13 != (long **)0x0);\nLAB_001a0179:\n          *(int *)((long)plVar10 + 0xc) = iVar20;\n          *(undefined8 *)(*plVar10 + (long)iVar20 * 8) = 0;\n          dispose_words(pplVar9);\n          if (pcVar11 == (char *)0x0) goto LAB_001a01d2;\n        }\n        sh_xfree(pcVar11,\"pcomplete.c\",0x3b6);\n      }\nLAB_001a01d2:\n      local_a0 = (long *)strlist_append(local_a0,plVar10);\n      strlist_dispose(plVar10);\n    }\n  }\n  if ((*(long *)(param_1 + 0x40) == 0) && (*(long *)(param_1 + 0x38) == 0)) {\n    local_70 = 0;\n    local_6c = 1;\n  }\n  else {\n    lVar8 = substring(pcomp_line,param_4,param_5);\n    local_88 = split_at_delims(lVar8,param_5 - param_4,rl_completer_word_break_characters,\n                               pcomp_ind - param_4,0x104,&local_4c);\n    if ((local_88 != 0) &&\n       (((*(char ***)(local_88 + 8) != (char **)0x0 && (*param_2 == '\\0')) &&\n        (***(char ***)(local_88 + 8) != '\\0')))) {\n      uVar17 = make_bare_word(param_2);\n      local_88 = make_word_list(uVar17,local_88);\n      local_4c = local_4c + 1;\n      local_48 = local_48 + 1;\n    }\n    if (*(long *)(param_1 + 0x38) == 0) {\n      local_70 = 0;\n      local_6c = 1;\n      if (*(long *)(param_1 + 0x40) != 0) goto LAB_001a0304;\nLAB_001a087d:\n      if (*(long *)(param_1 + 0x38) == 0) goto LAB_001a0690;\n    }\n    else {\n      local_44 = 0;\n      lVar12 = FUN_0019f1a0(*(long *)(param_1 + 0x38),param_2,param_3,lVar8,pcomp_ind - param_4,\n                            local_88,local_48);\n      local_70 = local_44;\n      local_6c = 1;\n      if (local_44 != 0) {\n        local_6c = local_44;\n        local_70 = local_44 & 0x200;\n      }\n      if (lVar12 != 0) {\n        local_a0 = (long *)strlist_append(local_a0,lVar12);\n        strlist_dispose(lVar12);\n      }\n      if (*(long *)(param_1 + 0x40) == 0) goto LAB_001a087d;\nLAB_001a0304:\n      iVar3 = local_48;\n      FUN_0019ef10(lVar8,pcomp_ind - param_4,local_88,local_48,1);\n      pplVar13 = (long **)FUN_0019eac0(*(undefined8 *)(param_1 + 0x40),param_2,param_3,local_88,\n                                       iVar3);\n      sVar7 = strlen(*(char **)(param_1 + 0x40));\n      iVar3 = (int)sVar7 + 1;\n      iVar20 = iVar3;\n      for (pplVar9 = (long **)*pplVar13; pplVar9 != (long **)0x0; pplVar9 = (long **)*pplVar9) {\n        pcVar11 = (char *)*pplVar9[1];\n        iVar4 = 3;\n        if (((pcVar11 != (char *)0x0) && (*pcVar11 != '\\0')) &&\n           ((iVar4 = 4, pcVar11[1] != '\\0' && (iVar4 = 5, pcVar11[2] != '\\0')))) {\n          sVar14 = strlen(pcVar11);\n          iVar4 = (int)sVar14 + 3;\n        }\n        iVar20 = iVar20 + iVar4;\n      }\n      local_98 = iVar20 + 2;\n      pcVar11 = (char *)sh_xmalloc((long)(iVar20 + 3),\"pcomplete.c\",0x4d5);\n      strcpy(pcVar11,*(char **)(param_1 + 0x40));\n      pcVar11[(int)sVar7] = ' ';\n      for (pplVar9 = (long **)*pplVar13; pplVar9 != (long **)0x0; pplVar9 = (long **)*pplVar9) {\n        puVar21 = (undefined *)*pplVar9[1];\n        if (puVar21 == (undefined *)0x0) {\n          puVar21 = &DAT_00213d70;\n        }\n        pcVar15 = (char *)sh_single_quote(puVar21);\n        sVar7 = strlen(pcVar15);\n        iVar20 = iVar3 + 2 + (int)sVar7;\n        if (local_98 <= iVar20) {\n          local_98 = local_98 + 0x40 + (iVar20 - local_98 & 0xffffffc0U);\n          pcVar11 = (char *)sh_xrealloc(pcVar11,(long)local_98,\"pcomplete.c\",0x4de);\n        }\n        strcpy(pcVar11 + iVar3,pcVar15);\n        iVar3 = iVar3 + (int)sVar7;\n        if (*pplVar9 != (long *)0x0) {\n          lVar12 = (long)iVar3;\n          iVar3 = iVar3 + 1;\n          pcVar11[lVar12] = ' ';\n        }\n        sh_xfree(pcVar15,\"pcomplete.c\",0x4e3);\n      }\n      pcVar11[iVar3] = '\\0';\n      ppcVar16 = (char **)command_substitute(pcVar11,0,0);\n      if (ppcVar16 == (char **)0x0) {\n        dispose_words(pplVar13);\n        sh_xfree(pcVar11,\"pcomplete.c\",0x4ee);\n        unbind_variable_noref(\"COMP_LINE\");\n        unbind_variable_noref(\"COMP_POINT\");\n        unbind_variable_noref(\"COMP_TYPE\");\n        unbind_variable_noref(\"COMP_KEY\");\n        unbind_variable_noref(\"COMP_WORDS\");\n        unbind_variable_noref(\"COMP_CWORD\");\n        array_needs_making = 1;\n      }\n      else {\n        pcVar15 = *ppcVar16;\n        dispose_word_desc(ppcVar16);\n        dispose_words(pplVar13);\n        sh_xfree(pcVar11,\"pcomplete.c\",0x4ee);\n        unbind_variable_noref(\"COMP_LINE\");\n        unbind_variable_noref(\"COMP_POINT\");\n        unbind_variable_noref(\"COMP_TYPE\");\n        unbind_variable_noref(\"COMP_KEY\");\n        unbind_variable_noref(\"COMP_WORDS\");\n        unbind_variable_noref(\"COMP_CWORD\");\n        array_needs_making = 1;\n        if (pcVar15 != (char *)0x0) {\n          if (*pcVar15 == '\\0') {\n            sh_xfree(pcVar15,\"pcomplete.c\",0x4f3);\n          }\n          else {\n            plVar10 = (long *)strlist_create(0x10);\n            uVar18 = 0;\n            cVar1 = *pcVar15;\n            if (cVar1 == '\\0') {\n              lVar12 = *plVar10;\n              iVar3 = *(int *)((long)plVar10 + 0xc);\n            }\n            else {\nLAB_001a0570:\n              do {\n                lVar12 = (long)(int)uVar18;\n                pcVar11 = pcVar15 + lVar12;\n                uVar19 = uVar18;\n                do {\n                  if (cVar1 == '\\n') break;\n                  iVar3 = (int)uVar19;\n                  if ((cVar1 == '\\\\') && (pcVar15[lVar12 + 1] == '\\n')) {\n                    iVar3 = iVar3 + 1;\n                  }\n                  uVar19 = (ulong)(iVar3 + 1U);\n                  lVar12 = (long)(int)(iVar3 + 1U);\n                  pcVar11 = pcVar15 + lVar12;\n                  cVar1 = *pcVar11;\n                } while (cVar1 != '\\0');\n                uVar17 = substring(pcVar15,uVar18,uVar19);\n                iVar20 = *(int *)((long)plVar10 + 0xc);\n                if (*(int *)(plVar10 + 1) + -1 <= iVar20) {\n                  strlist_resize(plVar10,*(int *)(plVar10 + 1) + 0x10);\n                  iVar20 = *(int *)((long)plVar10 + 0xc);\n                }\n                lVar12 = *plVar10;\n                iVar3 = iVar20 + 1;\n                *(int *)((long)plVar10 + 0xc) = iVar3;\n                *(undefined8 *)(lVar12 + (long)iVar20 * 8) = uVar17;\n                cVar1 = *pcVar11;\n                if (cVar1 != '\\n') {\n                  uVar18 = uVar19;\n                  if (cVar1 == '\\0') break;\n                  goto LAB_001a0570;\n                }\n                uVar19 = (long)((int)uVar19 + 1);\n                do {\n                  uVar18 = uVar19 & 0xffffffff;\n                  cVar1 = pcVar15[uVar19];\n                  uVar19 = uVar19 + 1;\n                } while (cVar1 == '\\n');\n              } while (cVar1 != '\\0');\n            }\n            *(undefined8 *)(lVar12 + (long)iVar3 * 8) = 0;\n            sh_xfree(pcVar15,\"pcomplete.c\",0x50c);\n            local_a0 = (long *)strlist_append(local_a0,plVar10);\n            strlist_dispose(plVar10);\n          }\n        }\n      }\n      if (*(long *)(param_1 + 0x40) == 0) goto LAB_001a087d;\n    }\n    if (local_88 != 0) {\n      dispose_words(local_88);\n    }\n    if (lVar8 != 0) {\n      sh_xfree(lVar8,\"pcomplete.c\",0x5b9);\n    }\n  }\nLAB_001a0690:\n  if (param_6 != (uint *)0x0) {\n    *param_6 = local_6c;\n  }\n  if (local_70 != 0) {\n    strlist_dispose(local_a0);\n    local_a0 = (long *)0x0;\n    goto LAB_001a071d;\n  }\n  if (*(long *)(param_1 + 0x50) == 0) {\nLAB_001a06d4:\n    lVar12 = *(long *)(param_1 + 0x28);\n    lVar8 = *(long *)(param_1 + 0x30);\njoined_r0x001a06df:\n    if ((lVar12 == 0) && (lVar8 == 0)) {\n      uVar18 = *(ulong *)(param_1 + 0x10);\n    }\n    else {\nLAB_001a06e5:\n      local_a0 = (long *)strlist_prefix_suffix(local_a0);\n      uVar18 = *(ulong *)(param_1 + 0x10);\n    }\n    if (local_a0 == (long *)0x0) goto LAB_001a07c0;\n    if ((*(int *)((long)local_a0 + 0xc) == 0) && ((uVar18 & 8) != 0)) {\n      lVar8 = compspec_create();\n      *(undefined8 *)(lVar8 + 8) = 0x20;\n      sh_xfree(local_a0,\"pcomplete.c\",0x5e3);\n      uVar17 = *(undefined8 *)(lVar8 + 8);\n      goto LAB_001a091b;\n    }\n  }\n  else {\n    if (local_a0 != (long *)0x0) {\n      if (((*local_a0 == 0) || (*(int *)((long)local_a0 + 0xc) == 0)) ||\n         (plVar10 = (long *)FUN_0019ed40(local_a0,*(long *)(param_1 + 0x50),param_3),\n         plVar10 == local_a0)) goto LAB_001a06d4;\n      if (*local_a0 != 0) {\n        sh_xfree(*local_a0,\"pcomplete.c\",0x5d2);\n      }\n      sh_xfree(local_a0,\"pcomplete.c\",0x5d3);\n      lVar12 = *(long *)(param_1 + 0x28);\n      lVar8 = *(long *)(param_1 + 0x30);\n      local_a0 = plVar10;\n      goto joined_r0x001a06df;\n    }\n    if ((*(long *)(param_1 + 0x28) != 0) || (*(long *)(param_1 + 0x30) != 0)) goto LAB_001a06e5;\n    uVar18 = *(ulong *)(param_1 + 0x10);\nLAB_001a07c0:\n    if ((uVar18 & 8) != 0) {\n      lVar8 = compspec_create();\n      uVar17 = 0x20;\n      *(undefined8 *)(lVar8 + 8) = 0x20;\nLAB_001a091b:\n      local_a0 = (long *)FUN_0019f840(uVar17,param_3);\n      compspec_dispose(lVar8);\n      goto LAB_001a071d;\n    }\n    local_a0 = (long *)0x0;\n  }\n  if ((uVar18 & 0x80) != 0) {\n    lVar8 = compspec_create();\n    *(undefined8 *)(lVar8 + 8) = 0x20;\n    uVar17 = FUN_0019f840(0x20,param_3);\n    local_a0 = (long *)strlist_append(local_a0,uVar17);\n    strlist_dispose(uVar17);\n    compspec_dispose(lVar8);\n  }\nLAB_001a071d:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_a0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00185700": "\nvoid FUN_00185700(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  sigaction local_168;\n  sigaction local_c8;\n  long local_30;\n  \n  piVar2 = &DAT_00238b60;\n  piVar3 = &DAT_00238b60;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_168.sa_flags = 0;\n  local_168.__sigaction_handler.sa_handler = termsig_sighandler;\n  sigemptyset(&local_168.sa_mask);\n  sigemptyset(&local_c8.sa_mask);\n  do {\n    iVar1 = *piVar3;\n    piVar3 = piVar3 + 6;\n    sigaddset(&local_168.sa_mask,iVar1);\n  } while (piVar3 != &shell_compatibility_level);\n  do {\n    iVar1 = signal_is_trapped(*piVar2);\n    if (iVar1 == 0) {\n      iVar1 = *piVar2;\n      sigaction(iVar1,&local_168,&local_c8);\n      *(_union_1457 *)(piVar2 + 2) = local_c8.__sigaction_handler;\n      piVar2[4] = local_c8.sa_flags;\n      set_original_signal(iVar1,local_168.__sigaction_handler.sa_handler);\n      if ((interactive_shell == 0) && (*(long *)(piVar2 + 2) == 1)) {\n        iVar1 = *piVar2;\n        sigaction(iVar1,&local_c8,&local_168);\n        set_signal_hard_ignored(iVar1);\n      }\n      if ((*piVar2 == 0x1b) && (1 < *(ulong *)(piVar2 + 2))) {\n        sigaction(0x1b,&local_c8,(sigaction *)0x0);\n      }\n    }\n    piVar2 = piVar2 + 6;\n  } while (piVar2 != &shell_compatibility_level);\n  DAT_0024853c = 1;\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001d7060": "\nvoid FUN_001d7060(char **param_1,int param_2,char *param_3)\n\n{\n  byte bVar1;\n  byte bVar2;\n  ushort *puVar3;\n  byte *pbVar4;\n  char *__s1;\n  wchar_t __wc;\n  wchar_t wVar5;\n  int iVar6;\n  size_t sVar7;\n  ushort **ppuVar8;\n  __int32_t **pp_Var9;\n  char *pcVar10;\n  size_t sVar11;\n  long lVar12;\n  __int32_t _Var13;\n  __int32_t _Var14;\n  byte **ppbVar15;\n  long in_FS_OFFSET;\n  char *local_68;\n  int local_60;\n  wchar_t local_58;\n  wchar_t local_54;\n  mbstate_t local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 < 2) {\n    local_60 = 100000;\n    sVar7 = 100000;\n    lVar12 = 0x186a1;\n  }\n  else {\n    local_60 = 100000;\n    ppbVar15 = (byte **)(param_1 + 1);\n    do {\n      sVar7 = __ctype_get_mb_cur_max();\n      if ((1 < sVar7) && (rl_byte_oriented == 0)) {\n        local_50.__count = 0;\n        local_50.__value = (_union_27)0x0;\n        local_48.__count = 0;\n        local_48.__value = (_union_27)0x0;\n      }\n      iVar6 = 0;\n      lVar12 = 0;\n      bVar1 = **ppbVar15;\n      while (bVar1 != 0) {\n        _Var13 = (__int32_t)(char)bVar1;\n        bVar2 = ppbVar15[1][lVar12];\n        _Var14 = (__int32_t)(char)bVar2;\n        if (bVar2 == 0) break;\n        if (_rl_completion_case_fold != 0) {\n          ppuVar8 = __ctype_b_loc();\n          puVar3 = *ppuVar8;\n          if ((*(byte *)((long)puVar3 + (ulong)bVar1 * 2 + 1) & 1) != 0) {\n            pp_Var9 = __ctype_tolower_loc();\n            _Var13 = (*pp_Var9)[bVar1];\n          }\n          if ((*(byte *)((long)puVar3 + (ulong)bVar2 * 2 + 1) & 1) != 0) {\n            pp_Var9 = __ctype_tolower_loc();\n            _Var14 = (*pp_Var9)[bVar2];\n          }\n        }\n        sVar7 = __ctype_get_mb_cur_max();\n        if ((sVar7 < 2) || (rl_byte_oriented != 0)) {\njoined_r0x001d70f3:\n          if (_Var13 != _Var14) break;\n        }\n        else {\n          pbVar4 = *ppbVar15;\n          sVar7 = strlen((char *)(pbVar4 + lVar12));\n          sVar7 = mbrtowc(&local_58,(char *)(pbVar4 + lVar12),sVar7,&local_50);\n          pbVar4 = ppbVar15[1];\n          sVar11 = strlen((char *)(pbVar4 + lVar12));\n          sVar11 = mbrtowc(&local_54,(char *)(pbVar4 + lVar12),sVar11,&local_48);\n          __wc = local_54;\n          if ((0xfffffffffffffffd < sVar7) || (0xfffffffffffffffd < sVar11))\n          goto joined_r0x001d70f3;\n          wVar5 = local_58;\n          if (_rl_completion_case_fold != 0) {\n            wVar5 = towlower(local_58);\n            local_58 = wVar5;\n            local_54 = towlower(__wc);\n          }\n          if (wVar5 != local_54) break;\n          if (1 < sVar7) {\n            iVar6 = iVar6 + -1 + (int)sVar7;\n          }\n        }\n        iVar6 = iVar6 + 1;\n        lVar12 = (long)iVar6;\n        bVar1 = (*ppbVar15)[lVar12];\n      }\n      if (local_60 <= iVar6) {\n        iVar6 = local_60;\n      }\n      ppbVar15 = ppbVar15 + 1;\n      local_60 = iVar6;\n    } while ((byte **)(param_1 + (ulong)(param_2 - 2) + 2) != ppbVar15);\n    if ((iVar6 == 0) && (param_3 != (char *)0x0)) {\n      if (*param_3 != '\\0') {\n        sVar7 = strlen(param_3);\n        pcVar10 = (char *)xmalloc(sVar7 + 1);\n        *param_1 = pcVar10;\n        strcpy(pcVar10,param_3);\n        goto LAB_001d73d6;\n      }\n      local_60 = 0;\n      sVar7 = 0;\n      lVar12 = 1;\n    }\n    else {\n      sVar7 = (size_t)iVar6;\n      lVar12 = (long)(iVar6 + 1);\n    }\n  }\n  pcVar10 = (char *)xmalloc(lVar12);\n  iVar6 = _rl_completion_case_fold;\n  *param_1 = pcVar10;\n  if (iVar6 == 0) {\n    strncpy(pcVar10,param_1[1],sVar7);\n  }\n  else {\n    pcVar10 = (char *)0x0;\n    local_68 = param_3;\n    if ((((rl_filename_completion_desired != 0) &&\n         (local_68 = param_3, rl_filename_dequoting_function != (code *)0x0)) &&\n        (local_68 = param_3, rl_completion_found_quote != 0)) &&\n       (pcVar10 = (char *)0x0, local_68 = param_3, rl_filename_quoting_desired != 0)) {\n      pcVar10 = (char *)(*rl_filename_dequoting_function)(param_3,rl_completion_quote_character);\n      local_68 = pcVar10;\n    }\n    if (rl_sort_completion_matches != 0) {\n      qsort(param_1 + 1,(long)param_2,8,_rl_qsort_string_compare);\n    }\n    sVar11 = strlen(local_68);\n    if ((int)sVar11 < local_60) {\n      local_60 = (int)sVar11;\n    }\n    if (0 < param_2) {\n      lVar12 = 1;\n      do {\n        __s1 = param_1[lVar12];\n        iVar6 = strncmp(__s1,local_68,(long)local_60);\n        if (iVar6 == 0) {\n          strncpy(*param_1,__s1,sVar7);\n          if ((int)lVar12 <= param_2) goto LAB_001d737a;\n          break;\n        }\n        lVar12 = lVar12 + 1;\n      } while ((int)lVar12 <= param_2);\n    }\n    strncpy(*param_1,param_1[1],sVar7);\nLAB_001d737a:\n    if (pcVar10 != (char *)0x0) {\n      free(pcVar10);\n    }\n  }\n  (*param_1)[sVar7] = '\\0';\nLAB_001d73d6:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "read_builtin_timeout": "\nundefined8 read_builtin_timeout(int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (((read_timeout != (long *)0x0) && (*(int *)(read_timeout + 2) == param_1)) &&\n     ((*read_timeout != 0 || (read_timeout[1] != 0)))) {\n    if ((*(byte *)((long)read_timeout + 0x14) & 1) != 0) {\n      uVar1 = shtimer_alrm();\n      return uVar1;\n    }\n    uVar1 = shtimer_select();\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "rl_make_keymap": "\nvoid rl_make_keymap(void)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  code **ppcVar4;\n  \n  puVar1 = (undefined *)xmalloc(0x1010);\n  puVar2 = puVar1;\n  do {\n    *puVar2 = 0;\n    puVar3 = puVar2 + 0x10;\n    *(undefined8 *)(puVar2 + 8) = 0;\n    puVar2 = puVar3;\n  } while (puVar3 != puVar1 + 0x1010);\n  ppcVar4 = (code **)(puVar1 + 0x208);\n  do {\n    *ppcVar4 = rl_insert;\n    ppcVar4 = ppcVar4 + 2;\n  } while (ppcVar4 != (code **)(puVar1 + 0x7f8));\n  *(code **)(puVar1 + 0x98) = rl_insert;\n  *(code **)(puVar1 + 0x7f8) = rl_rubout;\n  *(code **)(puVar1 + 0x88) = rl_rubout;\n  ppcVar4 = (code **)(puVar1 + 0x808);\n  do {\n    *ppcVar4 = rl_insert;\n    ppcVar4 = ppcVar4 + 2;\n  } while (ppcVar4 != (code **)(puVar1 + 0x1008));\n  return;\n}\n\n",
  "FUN_001522e0": "\nundefined8 FUN_001522e0(undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
  "procsub_search": "\nundefined8 * procsub_search(int param_1)\n\n{\n  undefined8 *puVar1;\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_128);\n  sigaddset(&sStack_128,0x11);\n  sigemptyset(&local_a8);\n  sigprocmask(0,&sStack_128,&local_a8);\n  for (puVar1 = procsubs; (puVar1 != (undefined8 *)0x0 && (*(int *)(puVar1 + 1) != param_1));\n      puVar1 = (undefined8 *)*puVar1) {\n  }\n  sigprocmask(2,&local_a8,(sigset_t *)0x0);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "can_optimize_cat_file": "\nbool can_optimize_cat_file(int *param_1)\n\n{\n  long *plVar1;\n  \n  if ((*param_1 == 4) && (*(long *)(param_1 + 4) == 0)) {\n    if ((param_1[1] & 0x80U) != 0) {\n      return false;\n    }\n    if ((((*(long *)(*(long *)(param_1 + 6) + 8) == 0) &&\n         (plVar1 = *(long **)(*(long *)(param_1 + 6) + 0x10), plVar1 != (long *)0x0)) &&\n        (*plVar1 == 0)) && (*(int *)(plVar1 + 3) == 1)) {\n      return *(int *)(plVar1 + 1) == 0;\n    }\n  }\n  return false;\n}\n\n",
  "compspec_copy": "\nundefined4 * compspec_copy(long param_1)\n\n{\n  undefined4 *puVar1;\n  size_t sVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  puVar1 = (undefined4 *)sh_xmalloc(0x58,\"pcomplib.c\",0x61);\n  pcVar4 = *(char **)(param_1 + 0x18);\n  *puVar1 = 1;\n  *(undefined8 *)(puVar1 + 2) = *(undefined8 *)(param_1 + 8);\n  *(undefined8 *)(puVar1 + 4) = *(undefined8 *)(param_1 + 0x10);\n  if (pcVar4 != (char *)0x0) {\n    sVar2 = strlen(pcVar4);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"pcomplib.c\",0x67);\n    pcVar4 = strcpy(pcVar3,pcVar4);\n  }\n  *(char **)(puVar1 + 6) = pcVar4;\n  pcVar4 = *(char **)(param_1 + 0x20);\n  if (pcVar4 != (char *)0x0) {\n    sVar2 = strlen(pcVar4);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"pcomplib.c\",0x68);\n    pcVar4 = strcpy(pcVar3,pcVar4);\n  }\n  *(char **)(puVar1 + 8) = pcVar4;\n  pcVar4 = *(char **)(param_1 + 0x28);\n  if (pcVar4 != (char *)0x0) {\n    sVar2 = strlen(pcVar4);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"pcomplib.c\",0x69);\n    pcVar4 = strcpy(pcVar3,pcVar4);\n  }\n  *(char **)(puVar1 + 10) = pcVar4;\n  pcVar4 = *(char **)(param_1 + 0x30);\n  if (pcVar4 != (char *)0x0) {\n    sVar2 = strlen(pcVar4);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"pcomplib.c\",0x6a);\n    pcVar4 = strcpy(pcVar3,pcVar4);\n  }\n  *(char **)(puVar1 + 0xc) = pcVar4;\n  pcVar4 = *(char **)(param_1 + 0x38);\n  if (pcVar4 != (char *)0x0) {\n    sVar2 = strlen(pcVar4);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"pcomplib.c\",0x6b);\n    pcVar4 = strcpy(pcVar3,pcVar4);\n  }\n  *(char **)(puVar1 + 0xe) = pcVar4;\n  pcVar4 = *(char **)(param_1 + 0x40);\n  if (pcVar4 != (char *)0x0) {\n    sVar2 = strlen(pcVar4);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"pcomplib.c\",0x6c);\n    pcVar4 = strcpy(pcVar3,pcVar4);\n  }\n  *(char **)(puVar1 + 0x10) = pcVar4;\n  pcVar4 = *(char **)(param_1 + 0x48);\n  if (pcVar4 != (char *)0x0) {\n    sVar2 = strlen(pcVar4);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"pcomplib.c\",0x6d);\n    pcVar4 = strcpy(pcVar3,pcVar4);\n  }\n  *(char **)(puVar1 + 0x12) = pcVar4;\n  pcVar4 = *(char **)(param_1 + 0x50);\n  if (pcVar4 != (char *)0x0) {\n    sVar2 = strlen(pcVar4);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"pcomplib.c\",0x6e);\n    pcVar4 = strcpy(pcVar3,pcVar4);\n  }\n  *(char **)(puVar1 + 0x14) = pcVar4;\n  return puVar1;\n}\n\n",
  "strcreplace": "\nchar * strcreplace(char *param_1,int param_2,char *param_3,uint param_4)\n\n{\n  char cVar1;\n  ulong uVar2;\n  int iVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char *pcVar6;\n  char *pcVar7;\n  ulong uVar8;\n  long lVar9;\n  char *pcVar10;\n  size_t local_60;\n  \n  local_60 = 0;\n  if ((((param_3 != (char *)0x0) && (*param_3 != '\\0')) && (local_60 = 1, param_3[1] != '\\0')) &&\n     (local_60 = 2, param_3[2] != '\\0')) {\n    local_60 = strlen(param_3);\n  }\n  sVar4 = strlen(param_1);\n  uVar8 = local_60 + 2 + sVar4;\n  pcVar5 = (char *)sh_xmalloc(uVar8,\"stringlib.c\",0xc9);\n  cVar1 = *param_1;\n  pcVar6 = pcVar5;\n  do {\n    while( true ) {\n      if (cVar1 == '\\0') {\n        *pcVar5 = '\\0';\n        return pcVar6;\n      }\n      pcVar10 = param_1 + 1;\n      if (cVar1 != param_2) break;\n      if (local_60 == 0) goto LAB_0019a062;\n      lVar9 = (long)pcVar5 - (long)pcVar6;\n      if (((param_4 & 1) != 0) &&\n         ((iVar3 = glob_pattern_p(param_3,param_4 & 1), iVar3 != 0 ||\n          (pcVar7 = strchr(param_3,0x5c), pcVar7 != (char *)0x0)))) {\n        pcVar7 = (char *)quote_globbing_chars(param_3);\n        sVar4 = strlen(pcVar7);\n        if (uVar8 <= lVar9 + sVar4) {\n          do {\n            uVar8 = uVar8 * 2;\n          } while (uVar8 <= lVar9 + sVar4);\n          pcVar6 = (char *)sh_xrealloc(pcVar6,uVar8,\"stringlib.c\",0xd6);\n          pcVar5 = pcVar6 + lVar9;\n        }\n        pcVar5 = strcpy(pcVar5,pcVar7);\n        pcVar5 = pcVar5 + sVar4;\n        sh_xfree(pcVar7,\"stringlib.c\",0xda);\n        goto LAB_0019a062;\n      }\n      if (uVar8 <= local_60 + lVar9) {\n        do {\n          uVar8 = uVar8 * 2;\n        } while (uVar8 <= local_60 + lVar9);\n        pcVar6 = (char *)sh_xrealloc(pcVar6,uVar8,\"stringlib.c\",0xde);\n        pcVar5 = pcVar6 + lVar9;\n      }\n      pcVar5 = strcpy(pcVar5,param_3);\n      pcVar5 = pcVar5 + local_60;\n      cVar1 = *pcVar10;\n      param_1 = pcVar10;\n    }\n    pcVar7 = pcVar10;\n    if ((cVar1 == '\\\\') &&\n       ((param_1[1] == param_2 || (((param_4 & 2) != 0 && (param_1[1] == '\\\\')))))) {\n      pcVar7 = param_1 + 2;\n      param_1 = pcVar10;\n    }\n    pcVar10 = pcVar7;\n    lVar9 = (long)pcVar5 - (long)pcVar6;\n    uVar2 = lVar9 + 2;\n    pcVar7 = pcVar5;\n    if (uVar8 <= uVar2) {\n      do {\n        uVar8 = uVar8 * 2;\n      } while (uVar8 <= uVar2);\n      pcVar6 = (char *)sh_xrealloc(pcVar6,uVar8,\"stringlib.c\",0xee);\n      pcVar7 = pcVar6 + lVar9;\n    }\n    pcVar5 = pcVar7 + 1;\n    *pcVar7 = *param_1;\nLAB_0019a062:\n    cVar1 = *pcVar10;\n    param_1 = pcVar10;\n  } while( true );\n}\n\n",
  "FUN_00135000": "\nvoid FUN_00135000(undefined8 param_1)\n\n{\n  ungetc_with_restart(param_1,DAT_00240a70);\n  return;\n}\n\n",
  "FUN_00136330": "\nvoid FUN_00136330(undefined8 param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = (long)need_here_doc;\n  if (need_here_doc < 0x10) {\n    need_here_doc = need_here_doc + 1;\n    (&DAT_00240dc0)[lVar1] = param_1;\n    return;\n  }\n  last_command_exit_value = 2;\n  need_here_doc = 0;\n  parser_error(line_number,&DAT_002102da,\"maximum here-document count exceeded\");\n  if ((interactive != 0) && (EOF_Reached != 0)) {\n    EOF_Reached = 0;\n  }\n  last_command_exit_value = 2;\n  if (executing_builtin != 0) {\n    last_command_exit_value = (-(uint)(parse_and_execute_level == 0) & 0xffffff01) + 0x101;\n  }\n  set_pipestatus_from_exit(last_command_exit_value);\n  reset_parser();\n                    /* WARNING: Subroutine does not return */\n  exit_shell(last_command_exit_value);\n}\n\n",
  "FUN_001411c0": "\nundefined8 FUN_001411c0(char *param_1,long *param_2)\n\n{\n  char *pcVar1;\n  int *piVar2;\n  long lVar3;\n  char cVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  char *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  lVar3 = strtoimax(param_1,&local_28,10);\n  if ((*piVar2 == 0) && (param_1 != local_28)) {\n    cVar4 = *local_28;\n    if ((cVar4 == ' ') || (cVar4 == '\\t')) {\n      pcVar1 = local_28 + 1;\n      do {\n        do {\n          local_28 = pcVar1;\n          cVar4 = *local_28;\n          pcVar1 = local_28 + 1;\n        } while (cVar4 == ' ');\n      } while (cVar4 == '\\t');\n    }\n    if ((*param_1 != '\\0') && (cVar4 == '\\0')) {\n      uVar5 = 1;\n      if (param_2 != (long *)0x0) {\n        *param_2 = lVar3;\n      }\n      goto LAB_00141241;\n    }\n  }\n  uVar5 = 0;\nLAB_00141241:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "initialize_job_signals": "\nvoid initialize_job_signals(void)\n\n{\n  if (interactive != 0) {\n    set_signal_handler(2,sigint_sighandler);\n    set_signal_handler(0x14,1);\n    set_signal_handler(0x16,1);\n    set_signal_handler(0x15,1);\n    return;\n  }\n  if (job_control == 0) {\n    return;\n  }\n  DAT_00247688 = set_signal_handler(0x14,FUN_00164d30);\n  DAT_00247678 = set_signal_handler(0x15,FUN_00164d30);\n  DAT_00247680 = set_signal_handler(0x16,FUN_00164d30);\n  return;\n}\n\n",
  "FUN_001bb8a0": "\nuint FUN_001bb8a0(undefined8 param_1,undefined4 *param_2,ulong *param_3,ulong *param_4)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char cVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  char *pcVar7;\n  undefined **ppuVar8;\n  ulong uVar9;\n  long in_FS_OFFSET;\n  ulong local_88;\n  char *local_58;\n  undefined4 local_50;\n  long local_40;\n  \n  uVar9 = 0;\n  uVar5 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  reset_internal_getopt();\n  local_88 = 0;\n  iVar4 = internal_getopt(param_1,\"abcdefgjko:prsuvA:G:W:P:S:X:F:C:DEI\");\n  pcVar2 = list_optarg;\n  do {\n    list_optarg = pcVar2;\n    if (iVar4 == -1) {\n      *param_3 = uVar9;\n      *param_4 = local_88;\n      uVar5 = uVar5 ^ 1;\nLAB_001bb92a:\n      if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return uVar5;\n    }\n    if (iVar4 == -99) {\n      builtin_help();\n      uVar5 = 0x102;\n      goto LAB_001bb92a;\n    }\n    switch(iVar4) {\n    case 0x41:\n      ppuVar8 = &PTR_s_arrayvar_002354b8;\n      cVar3 = 'a';\n      iVar4 = 0;\n      pcVar7 = \"alias\";\n      cVar1 = *pcVar2;\n      while ((cVar3 != cVar1 || (iVar6 = strcmp(pcVar2,pcVar7), iVar6 != 0))) {\n        pcVar7 = *ppuVar8;\n        ppuVar8 = ppuVar8 + 3;\n        iVar4 = iVar4 + 1;\n        if (pcVar7 == (char *)0x0) {\n          builtin_error(\"%s: invalid action name\",pcVar2);\n          uVar5 = 0x102;\n          goto LAB_001bb92a;\n        }\n        cVar3 = *pcVar7;\n      }\n      uVar9 = uVar9 | (&DAT_002354a8)[(long)iVar4 * 3];\n      break;\n    default:\n      builtin_usage();\n      uVar5 = 0x102;\n      goto LAB_001bb92a;\n    case 0x43:\n      DAT_00248e20 = pcVar2;\n      break;\n    case 0x44:\n      if (param_2 == (undefined4 *)0x0) {\n        sh_invalidopt(&DAT_0021115f);\n        builtin_usage();\n        uVar5 = 0x102;\n        goto LAB_001bb92a;\n      }\n      param_2[2] = 1;\n      break;\n    case 0x45:\n      if (param_2 == (undefined4 *)0x0) {\n        sh_invalidopt(&DAT_00211162);\n        builtin_usage();\n        uVar5 = 0x102;\n        goto LAB_001bb92a;\n      }\n      param_2[3] = 1;\n      break;\n    case 0x46:\n      local_50 = 0;\n      DAT_00248e28 = pcVar2;\n      local_58 = pcVar2;\n      iVar4 = check_identifier(&local_58,posixly_correct);\n      pcVar2 = DAT_00248e28;\n      if ((iVar4 == 0) || (pcVar7 = strpbrk(DAT_00248e28,\"()<>;&| \\t\\n\"), pcVar7 != (char *)0x0)) {\n        sh_invalidid(pcVar2);\n        uVar5 = 0x102;\n        goto LAB_001bb92a;\n      }\n      break;\n    case 0x47:\n      DAT_00248e50 = pcVar2;\n      break;\n    case 0x49:\n      if (param_2 == (undefined4 *)0x0) {\n        sh_invalidopt(&DAT_00211165);\n        builtin_usage();\n        uVar5 = 0x102;\n        goto LAB_001bb92a;\n      }\n      param_2[4] = 1;\n      break;\n    case 0x50:\n      DAT_00248e40 = pcVar2;\n      break;\n    case 0x53:\n      DAT_00248e38 = pcVar2;\n      break;\n    case 0x57:\n      DAT_00248e48 = pcVar2;\n      break;\n    case 0x58:\n      DAT_00248e30 = pcVar2;\n      break;\n    case 0x61:\n      uVar9 = uVar9 | 1;\n      break;\n    case 0x62:\n      uVar9 = uVar9 | 8;\n      break;\n    case 99:\n      uVar9 = uVar9 | 0x10;\n      break;\n    case 100:\n      uVar9 = uVar9 | 0x20;\n      break;\n    case 0x65:\n      uVar9 = uVar9 | 0x100;\n      break;\n    case 0x66:\n      uVar9 = uVar9 | 0x200;\n      break;\n    case 0x67:\n      uVar9 = uVar9 | 0x800;\n      break;\n    case 0x6a:\n      uVar9 = uVar9 | 0x4000;\n      break;\n    case 0x6b:\n      uVar9 = uVar9 | 0x8000;\n      break;\n    case 0x6f:\n      ppuVar8 = &PTR_s_default_00235410;\n      cVar3 = 'b';\n      pcVar7 = \"bashdefault\";\n      cVar1 = *pcVar2;\n      iVar4 = 0;\n      while ((cVar1 != cVar3 || (iVar6 = strcmp(pcVar2,pcVar7), iVar6 != 0))) {\n        pcVar7 = *ppuVar8;\n        ppuVar8 = ppuVar8 + 2;\n        iVar4 = iVar4 + 1;\n        if (pcVar7 == (char *)0x0) {\n          sh_invalidoptname(pcVar2);\n          uVar5 = 0x102;\n          goto LAB_001bb92a;\n        }\n        cVar3 = *pcVar7;\n      }\n      local_88 = local_88 | (&DAT_00235408)[(long)iVar4 * 2];\n      break;\n    case 0x70:\n      if (param_2 == (undefined4 *)0x0) {\n        sh_invalidopt(&DAT_001fab0e);\n        builtin_usage();\n        uVar5 = 0x102;\n        goto LAB_001bb92a;\n      }\n      *param_2 = 1;\n      break;\n    case 0x72:\n      if (param_2 == (undefined4 *)0x0) {\n        sh_invalidopt(&DAT_00211183);\n        builtin_usage();\n        uVar5 = 0x102;\n        goto LAB_001bb92a;\n      }\n      param_2[1] = 1;\n      break;\n    case 0x73:\n      uVar9 = uVar9 | 0x20000;\n      break;\n    case 0x75:\n      uVar9 = uVar9 | 0x400000;\n      break;\n    case 0x76:\n      uVar9 = uVar9 | 0x800000;\n    }\n    uVar5 = 1;\n    iVar4 = internal_getopt(param_1,\"abcdefgjko:prsuvA:G:W:P:S:X:F:C:DEI\");\n    pcVar2 = list_optarg;\n  } while( true );\n}\n\n",
  "FUN_001446d0": "\nvoid FUN_001446d0(char *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,undefined8 param_6)\n\n{\n  char cVar1;\n  char cVar2;\n  size_t sVar3;\n  char *__s;\n  char **ppcVar4;\n  ulong uVar5;\n  char *pcVar6;\n  int iVar7;\n  int iVar8;\n  long in_FS_OFFSET;\n  bool bVar9;\n  uint local_98;\n  char **local_90;\n  char local_7d;\n  undefined local_7c;\n  char local_7b [11];\n  long local_70;\n  char *local_68 [4];\n  undefined8 local_48;\n  undefined8 local_40;\n  \n  local_70 = *(long *)(in_FS_OFFSET + 0x28);\n  local_90 = (char **)&stack0x00000008;\n  local_98 = 8;\n  local_68[1] = (char *)param_2;\n  local_68[2] = (char *)param_3;\n  local_68[3] = (char *)param_4;\n  local_48 = param_5;\n  local_40 = param_6;\n  sVar3 = strlen(param_1);\n  FUN_00144630((int)sVar3 + 1);\n  cVar1 = *param_1;\n  local_7c = 0;\n  do {\n    if (cVar1 == '\\0') {\n      *(undefined *)(the_printed_command + command_string_index) = 0;\n      if (local_70 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    pcVar6 = param_1 + 1;\n    if ((cVar1 == '%') && (cVar2 = param_1[1], cVar2 != '\\0')) {\n      pcVar6 = param_1 + 2;\n      if (cVar2 == 'd') {\n        if (local_98 < 0x30) {\n          uVar5 = (ulong)local_98;\n          local_98 = local_98 + 8;\n          iVar7 = *(int *)((long)local_68 + uVar5);\n          if (-1 < iVar7) goto LAB_001448a4;\nLAB_00144931:\n          __s = local_7b;\n          bVar9 = true;\n          __sprintf_chk(__s,1,0xb,&DAT_001fc618,0xffffffff);\n        }\n        else {\n          iVar7 = *(int *)local_90;\n          local_90 = local_90 + 1;\n          if (iVar7 < 0) goto LAB_00144931;\nLAB_001448a4:\n          __s = (char *)inttostr((long)iVar7,local_7b,0xb);\n          bVar9 = __s != (char *)0x0;\n        }\n        sVar3 = strlen(__s);\n        iVar7 = (int)sVar3;\n      }\n      else {\n        if (cVar2 < 'e') {\n          if (cVar2 == '%') {\n            local_7d = '%';\n          }\n          else {\n            if (cVar2 != 'c') goto LAB_00144868;\n            if (local_98 < 0x30) {\n              uVar5 = (ulong)local_98;\n              local_98 = local_98 + 8;\n              ppcVar4 = (char **)((long)local_68 + uVar5);\n            }\n            else {\n              ppcVar4 = local_90;\n              local_90 = local_90 + 1;\n            }\n            local_7d = (char)*(int *)ppcVar4;\n          }\n          sVar3 = 1;\n          iVar8 = 2;\n          iVar7 = 1;\n          __s = &local_7d;\n          goto LAB_00144769;\n        }\n        if (cVar2 != 's') {\nLAB_00144868:\n                    /* WARNING: Subroutine does not return */\n          programming_error(\"cprintf: `%c\\': invalid format character\");\n        }\n        if (local_98 < 0x30) {\n          uVar5 = (ulong)local_98;\n          local_98 = local_98 + 8;\n          ppcVar4 = (char **)((long)local_68 + uVar5);\n        }\n        else {\n          ppcVar4 = local_90;\n          local_90 = local_90 + 1;\n        }\n        __s = *ppcVar4;\n        bVar9 = true;\n        sVar3 = strlen(__s);\n        iVar7 = (int)sVar3;\n      }\n      if ((iVar7 != 0) && (bVar9)) {\n        iVar8 = iVar7 + 1;\n        sVar3 = (size_t)iVar7;\n        goto LAB_00144769;\n      }\n    }\n    else {\n      sVar3 = 1;\n      iVar8 = 2;\n      iVar7 = 1;\n      __s = &local_7d;\n      local_7d = cVar1;\nLAB_00144769:\n      FUN_00144630(iVar8);\n      memcpy((void *)(command_string_index + the_printed_command),__s,sVar3);\n      command_string_index = command_string_index + iVar7;\n    }\n    cVar1 = *pcVar6;\n    param_1 = pcVar6;\n  } while( true );\n}\n\n",
  "FUN_001ab320": "\nundefined8 FUN_001ab320(long param_1)\n\n{\n  __printf_chk(1,&DAT_0020fbe3,*(undefined4 *)(param_1 + 0x1c),**(undefined8 **)(param_1 + 0x10));\n  return 0;\n}\n\n",
  "mbschr": "\nbyte * mbschr(byte *param_1,uint param_2)\n\n{\n  byte bVar1;\n  size_t __n;\n  size_t sVar2;\n  byte *pbVar3;\n  long in_FS_OFFSET;\n  mbstate_t local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((locale_utf8locale == 0) || (0x7f < (int)param_2)) {\n    if (((byte)param_2 < 0x30) || (locale_mb_cur_max < 2)) {\n      if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n        pbVar3 = (byte *)strchr((char *)param_1,param_2);\n        return pbVar3;\n      }\n    }\n    else {\n      local_38.__count = 0;\n      local_38.__value = (_union_27)0x0;\n      for (__n = strlen((char *)param_1); __n != 0; __n = __n - sVar2) {\n        bVar1 = *param_1;\n        if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n          sVar2 = mbrtowc((wchar_t *)0x0,(char *)param_1,__n,&local_38);\n          if (0xfffffffffffffffb < sVar2 - 2) {\n            bVar1 = *param_1;\n            goto joined_r0x001cd883;\n          }\n        }\n        else {\njoined_r0x001cd883:\n          if (bVar1 == param_2) goto LAB_001cd922;\n          sVar2 = 1;\n        }\n        param_1 = param_1 + sVar2;\n      }\n      param_1 = (byte *)0x0;\nLAB_001cd922:\n      if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return param_1;\n      }\n    }\n  }\n  else if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    pbVar3 = (byte *)utf8_mbschr();\n    return pbVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00144b90": "\nvoid FUN_00144b90(long param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  \n  iVar2 = *(int *)(param_1 + 0x18);\n  if ((*(byte *)(param_1 + 0x10) & 1) == 0) {\n    if (*(int *)(param_1 + 8) != 0) {\n      FUN_001446d0(\"%d\");\n      uVar3 = *(undefined8 *)(param_1 + 0x28);\n      bVar1 = *(byte *)(*(long *)(param_1 + 0x20) + 8);\n      goto joined_r0x00144bfa;\n    }\n  }\n  else {\n    FUN_001446d0(&DAT_001fc62b,**(undefined8 **)(param_1 + 8));\n  }\n  uVar3 = *(undefined8 *)(param_1 + 0x28);\n  bVar1 = *(byte *)(*(long *)(param_1 + 0x20) + 8);\njoined_r0x00144bfa:\n  if ((bVar1 & 2) == 0) {\n    pcVar4 = \"-\";\n    if (iVar2 != 8) {\n      pcVar4 = \"\";\n    }\n    FUN_001446d0(&DAT_001fc630,pcVar4);\n    return;\n  }\n  uVar3 = sh_single_quote(uVar3);\n  pcVar4 = \"-\";\n  if (iVar2 != 8) {\n    pcVar4 = \"\";\n  }\n  FUN_001446d0(&DAT_001fc630,pcVar4,uVar3);\n  sh_xfree(uVar3,\"print_cmd.c\",0x471);\n  return;\n}\n\n",
  "wait_for_job": "\nint wait_for_job(int param_1,uint param_2,undefined4 *param_3)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  long *plVar3;\n  undefined2 uVar4;\n  int iVar5;\n  long lVar6;\n  long *plVar7;\n  int *piVar8;\n  long lVar9;\n  long in_FS_OFFSET;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_148);\n  sigaddset(&local_148,0x11);\n  sigemptyset(&local_c8);\n  sigprocmask(0,&local_148,&local_c8);\n  lVar9 = (long)param_1;\n  lVar6 = *(long *)(jobs + lVar9 * 8);\n  if (*(int *)(lVar6 + 0x14) == 2) {\n    internal_warning(\"wait_for_job: job %d is stopped\",param_1 + 1);\n    lVar6 = *(long *)(jobs + lVar9 * 8);\n  }\n  plVar3 = *(long **)(lVar6 + 8);\n  do {\n    plVar7 = plVar3;\n    if (plVar7 == (long *)0x0) {\n      do {\n        invalidInstructionException();\n      } while( true );\n    }\n    plVar3 = (long *)*plVar7;\n  } while (*(long **)(lVar6 + 8) != (long *)*plVar7);\n  uVar1 = *(undefined4 *)(plVar7 + 1);\n  sigprocmask(2,&local_c8,(sigset_t *)0x0);\n  while( true ) {\n    iVar5 = wait_for(uVar1,0);\n    if (((iVar5 == -1) && (piVar8 = __errno_location(), *piVar8 == 10)) && (DAT_0023877c != 0)) {\n      FUN_0015ebc0();\n    }\n    if (((wait_intr_flag != 0) && (wait_signal_received != 0)) &&\n       ((this_shell_builtin != (undefined *)0x0 && (this_shell_builtin == PTR_wait_builtin_00237f70)\n        ))) {\n                    /* WARNING: Subroutine does not return */\n      __longjmp_chk(wait_intr_buf,1);\n    }\n    if ((param_2 & 2) == 0) {\n      sigemptyset(&local_148);\n      sigaddset(&local_148,0x11);\n      sigemptyset(&local_c8);\n      sigprocmask(0,&local_148,&local_c8);\n      if (param_1 == -1) goto LAB_00164280;\n      goto LAB_0016425a;\n    }\n    sigemptyset(&local_148);\n    sigaddset(&local_148,0x11);\n    sigemptyset(&local_c8);\n    sigprocmask(0,&local_148,&local_c8);\n    if (param_1 == -1) {\n      sigprocmask(2,&local_c8,(sigset_t *)0x0);\n      sigemptyset(&local_148);\n      sigaddset(&local_148,0x11);\n      sigemptyset(&local_c8);\n      sigprocmask(0,&local_148,&local_c8);\n      goto LAB_00164280;\n    }\n    lVar6 = *(long *)(jobs + lVar9 * 8);\n    if (lVar6 == 0) break;\n    iVar2 = *(int *)(lVar6 + 0x14);\n    sigprocmask(2,&local_c8,(sigset_t *)0x0);\n    if (iVar2 == 4) {\nLAB_00164230:\n      sigemptyset(&local_148);\n      sigaddset(&local_148,0x11);\n      sigemptyset(&local_c8);\n      sigprocmask(0,&local_148,&local_c8);\nLAB_0016425a:\n      lVar6 = *(long *)(jobs + lVar9 * 8);\n      if ((lVar6 != 0) && (*(int *)(lVar6 + 0x14) == 4)) {\n        *(uint *)(lVar6 + 0x18) = *(uint *)(lVar6 + 0x18) | 2;\n      }\nLAB_00164280:\n      sigprocmask(2,&local_c8,(sigset_t *)0x0);\n      if (param_3 != (undefined4 *)0x0) {\n        *param_3 = uVar1;\n        uVar4 = 0x7f;\n        if (-1 < iVar5) {\n          uVar4 = (undefined2)iVar5;\n        }\n        *(undefined2 *)(param_3 + 1) = uVar4;\n      }\n      if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return iVar5;\n    }\n  }\n  sigprocmask(2,&local_c8,(sigset_t *)0x0);\n  goto LAB_00164230;\n}\n\n",
  "tcsetpgrp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint tcsetpgrp(int __fd,__pid_t __pgrp_id)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_tcsetpgrp_00237d30)();\n  return iVar1;\n}\n\n",
  "ignore_signal": "\nvoid ignore_signal(ulong param_1)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  long lVar4;\n  \n  iVar1 = (int)param_1;\n  if ((iVar1 - 0x41U < 3) || (iVar1 == 0)) {\n    if ((*(byte *)(&DAT_00247e40 + iVar1) & 0x40) == 0) goto LAB_00182bb4;\n    if ((iVar1 != 0) && (iVar1 < 0x41)) goto LAB_00182b68;\nLAB_00182b7d:\n    uVar2 = (&DAT_00247e40)[iVar1];\n  }\n  else {\n    if (0x40 < iVar1) goto LAB_00182b7d;\nLAB_00182b68:\n    lVar4 = (long)iVar1;\n    if (*(code **)(original_signals + lVar4 * 8) != initialize_traps) goto LAB_00182b7d;\n    uVar3 = set_signal_handler(param_1,0);\n    *(undefined8 *)(original_signals + lVar4 * 8) = uVar3;\n    set_signal_handler(param_1 & 0xffffffff,uVar3);\n    param_1 = param_1 & 0xffffffff;\n    uVar2 = (&DAT_00247e40)[lVar4];\n    if (*(long *)(original_signals + lVar4 * 8) == 1) {\n      uVar2 = uVar2 | 2;\n      (&DAT_00247e40)[lVar4] = uVar2;\n    }\n  }\n  if ((uVar2 & 0x42) != 0) {\n    return;\n  }\n  if ((uVar2 & 8) == 0) {\n    set_signal_handler(param_1,1);\n    param_1 = param_1 & 0xffffffff;\n  }\nLAB_00182bb4:\n  FUN_001815b0(param_1,1);\n  return;\n}\n\n",
  "_rl_clear_screen": "\nvoid _rl_clear_screen(int param_1)\n\n{\n  if (_rl_term_clrpag == 0) {\n    rl_crlf();\n    return;\n  }\n  tputs(_rl_term_clrpag,1,_rl_output_character_function);\n  if ((param_1 != 0) && (_rl_term_clrscroll != 0)) {\n    tputs(_rl_term_clrscroll,1,_rl_output_character_function);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001cff10": "\nundefined8 FUN_001cff10(void)\n\n{\n  int iVar1;\n  \n  rl_readline_state = rl_readline_state | 0x40;\n  _rl_callback_func = 0;\n  _rl_want_redisplay = 1;\n  iVar1 = rl_read_key();\n  rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n  if (iVar1 - 0x61U < 0x1a) {\n    *(undefined4 *)(&DAT_0024a360 + (long)(int)(iVar1 - 0x61U) * 4) = rl_point;\n    return 0;\n  }\n  rl_ding();\n  return 1;\n}\n\n",
  "FUN_001566a0": "\nvoid FUN_001566a0(char **param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined **ppuVar8;\n  long lVar9;\n  \n  lVar3 = bind_variable(*param_1,param_1[1],0x220);\n  if (*(int *)(lVar3 + 0x2c) == 0) {\n    uVar7 = *(uint *)(param_1 + 5);\n    *(uint *)(param_1 + 5) = uVar7 & 0xffcfffff;\n    uVar7 = uVar7 & 0xffcfffff | *(uint *)(lVar3 + 0x28);\n  }\n  else {\n    uVar7 = *(uint *)(lVar3 + 0x28) | *(uint *)(param_1 + 5);\n    if ((0 < *(int *)(lVar3 + 0x2c)) && ((uVar7 & 0x20) == 0)) {\n      uVar7 = uVar7 | 0x200000;\n      goto LAB_001566e2;\n    }\n  }\n  uVar7 = uVar7 & 0xffdfffff;\nLAB_001566e2:\n  pcVar5 = PTR_s_BASH_COMPAT_00238460;\n  pcVar6 = *param_1;\n  *(uint *)(lVar3 + 0x28) = uVar7;\n  if (pcVar5 != (undefined *)0x0) {\n    cVar1 = *pcVar6;\n    ppuVar8 = &PTR_s_BASH_XTRACEFD_00238470;\n    do {\n      iVar2 = (int)*pcVar5 - (int)cVar1;\n      if (iVar2 == 0) {\n        iVar2 = strcmp(pcVar5,pcVar6);\n        if (iVar2 == 0) {\n          sVar4 = strlen(pcVar6);\n          pcVar5 = (char *)sh_xmalloc(sVar4 + 1,\"variables.c\",0x11ef);\n          lVar3 = tempvar_list;\n          lVar9 = (long)tvlist_ind;\n          tvlist_ind = tvlist_ind + 1;\n          pcVar6 = strcpy(pcVar5,pcVar6);\n          *(char **)(lVar3 + lVar9 * 8) = pcVar6;\n          break;\n        }\n      }\n      if (0 < iVar2) break;\n      pcVar5 = *ppuVar8;\n      ppuVar8 = ppuVar8 + 2;\n    } while (pcVar5 != (char *)0x0);\n  }\n  dispose_variable(param_1);\n  return;\n}\n\n",
  "FUN_001d7970": "\nint FUN_001d7970(char *param_1,char *param_2,undefined4 param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  size_t sVar3;\n  size_t sVar4;\n  char *__dest;\n  long lVar5;\n  char *__dest_00;\n  long lVar6;\n  int unaff_R14D;\n  uint __c;\n  long in_FS_OFFSET;\n  char *local_e8;\n  char *local_e0;\n  stat local_d8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((_rl_colored_stats == 0) || (rl_filename_completion_desired == 0)) &&\n     ((unaff_R14D = FUN_001d61a0(param_1,param_3,param_1), rl_filename_completion_desired == 0 ||\n      ((rl_visible_stats | _rl_complete_mark_directories | _rl_colored_stats) == 0))))\n  goto LAB_001d7aeb;\n  if (param_1 == param_2) {\n    local_e8 = (char *)tilde_expand(param_1);\n    if (rl_visible_stats != 0) {\n      __c = FUN_001d5d10();\n      if (_rl_colored_stats != 0) goto LAB_001d7cfa;\n      goto LAB_001d7ad9;\n    }\n    if (_rl_complete_mark_directories == 0) {\n      __c = 0;\n      if (_rl_colored_stats == 0) {\n        xfree();\n        goto LAB_001d7aeb;\n      }\nLAB_001d7cfa:\n      unaff_R14D = FUN_001d61a0(param_1,param_3,local_e8);\n      goto LAB_001d7ad9;\n    }\n    iVar2 = stat(local_e8,&local_d8);\n    if ((iVar2 != 0) || ((local_d8.st_mode & 0xf000) != 0x4000)) {\n      if (_rl_colored_stats == 0) {\n        xfree();\n        goto LAB_001d7aeb;\n      }\n      __c = 0;\n      goto LAB_001d7cfa;\n    }\n    if (_rl_colored_stats != 0) {\n      __c = 0x2f;\n      goto LAB_001d7cfa;\n    }\n    xfree();\n    __c = 0x2f;\n  }\n  else {\n    cVar1 = param_1[-1];\n    param_1[-1] = '\\0';\n    if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\nLAB_001d79e0:\n      param_2 = \"/\";\n    }\n    else if (*param_2 == '/') {\n      if (param_2[1] == '\\0') {\n        param_2 = \"//\";\n      }\n      else if ((param_2[1] == '/') && (param_2[2] == '\\0')) goto LAB_001d79e0;\n    }\n    local_e0 = param_2;\n    local_e8 = (char *)tilde_expand(param_2);\n    if (rl_directory_completion_hook != (code *)0x0) {\n      (*rl_directory_completion_hook)(&local_e8);\n    }\n    sVar3 = strlen(local_e8);\n    sVar4 = strlen(param_1);\n    __dest = (char *)xmalloc((long)((int)sVar3 + 2 + (int)sVar4));\n    strcpy(__dest,local_e8);\n    lVar5 = (long)(int)sVar3;\n    lVar6 = lVar5 + -1;\n    if (local_e8[lVar5 + -1] != '/') {\n      __dest[lVar5] = '/';\n      lVar6 = lVar5;\n    }\n    strcpy(__dest + lVar6 + 1,param_1);\n    if (rl_visible_stats == 0) {\n      __c = _rl_complete_mark_directories;\n      if (_rl_complete_mark_directories != 0) {\n        local_e0 = (char *)0x0;\n        if ((rl_directory_completion_hook == (code *)0x0) && (rl_filename_stat_hook != (code *)0x0))\n        {\n          sVar3 = strlen(__dest);\n          __dest_00 = (char *)xmalloc(sVar3 + 1);\n          local_e0 = strcpy(__dest_00,__dest);\n          (*rl_filename_stat_hook)(&local_e0);\n          xfree(__dest);\n          __dest = local_e0;\n        }\n        iVar2 = stat(__dest,&local_d8);\n        if ((iVar2 != 0) || (__c = 0x2f, (local_d8.st_mode & 0xf000) != 0x4000)) {\n          __c = 0;\n        }\n      }\n    }\n    else {\n      __c = FUN_001d5d10(__dest);\n    }\n    if (_rl_colored_stats != 0) {\n      unaff_R14D = FUN_001d61a0(param_1,param_3,__dest);\n    }\n    xfree(__dest);\n    param_1[-1] = cVar1;\nLAB_001d7ad9:\n    xfree(local_e8);\n    if (__c == 0) goto LAB_001d7aeb;\n  }\n  unaff_R14D = unaff_R14D + 1;\n  putc(__c,rl_outstream);\nLAB_001d7aeb:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return unaff_R14D;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "open_buffered_stream": "\nundefined8 open_buffered_stream(char *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = open(param_1,0);\n  if (-1 < iVar1) {\n    uVar2 = fd_to_buffered_stream(iVar1);\n    return uVar2;\n  }\n  return 0;\n}\n\n",
  "sv_histtimefmt": "\nvoid sv_histtimefmt(void)\n\n{\n  long lVar1;\n  \n  lVar1 = find_variable();\n  if ((lVar1 != 0) && (history_comment_char == '\\0')) {\n    history_comment_char = '#';\n  }\n  history_write_timestamps = (uint)(lVar1 != 0);\n  return;\n}\n\n",
  "type_builtin": "\nundefined8 type_builtin(long **param_1)\n\n{\n  char *__s1;\n  char cVar1;\n  char *pcVar2;\n  int iVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  uint uVar6;\n  long *plVar7;\n  long **pplVar8;\n  bool bVar9;\n  \n  pplVar8 = param_1;\n  if (param_1 == (long **)0x0) {\n    return 0;\n  }\n  do {\n    while( true ) {\n      pcVar2 = (char *)*pplVar8[1];\n      if (*pcVar2 != '-') goto LAB_001b51b0;\n      cVar1 = pcVar2[1];\n      __s1 = pcVar2 + 1;\n      if (cVar1 == 't') break;\n      if (cVar1 == '-') {\n        iVar3 = strcmp(__s1,\"-type\");\n        if (iVar3 == 0) goto LAB_001b5191;\n        iVar3 = strcmp(__s1,\"-path\");\n        if (iVar3 == 0) goto LAB_001b5257;\n        iVar3 = strcmp(__s1,\"-all\");\njoined_r0x001b5233:\n        if (iVar3 == 0) {\n          pcVar2[1] = 'a';\n          *(undefined *)(*pplVar8[1] + 2) = 0;\n        }\n      }\n      else if (cVar1 == 'p') {\n        iVar3 = strcmp(__s1,\"path\");\n        if (iVar3 == 0) {\nLAB_001b5257:\n          pcVar2[1] = 'p';\n          *(undefined *)(*pplVar8[1] + 2) = 0;\n        }\n      }\n      else if (cVar1 == 'a') {\n        iVar3 = strcmp(__s1,\"all\");\n        goto joined_r0x001b5233;\n      }\nLAB_001b5160:\n      pplVar8 = (long **)*pplVar8;\n      if (pplVar8 == (long **)0x0) goto LAB_001b51b0;\n    }\n    iVar3 = strcmp(__s1,\"type\");\n    if (iVar3 != 0) goto LAB_001b5160;\nLAB_001b5191:\n    pcVar2[1] = 't';\n    *(undefined *)(*pplVar8[1] + 2) = 0;\n    pplVar8 = (long **)*pplVar8;\n  } while (pplVar8 != (long **)0x0);\nLAB_001b51b0:\n  reset_internal_getopt();\n  uVar6 = 2;\n  while( true ) {\n    iVar3 = internal_getopt(param_1,\"afptP\");\n    if (iVar3 == -1) {\n      if (loptend == (long *)0x0) {\n        bVar9 = false;\n      }\n      else {\n        iVar3 = 0;\n        plVar7 = loptend;\n        do {\n          uVar4 = describe_command(*(undefined8 *)plVar7[1],uVar6);\n          if ((uVar4 | uVar6 & 0x18) == 0) {\n            sh_notfound(*(undefined8 *)plVar7[1]);\n          }\n          plVar7 = (long *)*plVar7;\n          iVar3 = iVar3 + (uint)(uVar4 == 0);\n        } while (plVar7 != (long *)0x0);\n        bVar9 = iVar3 != 0;\n      }\n      uVar5 = sh_chkwrite(bVar9);\n      return uVar5;\n    }\n    if (iVar3 == -99) break;\n    switch(iVar3) {\n    case 0x50:\n      uVar6 = uVar6 & 0xfffffff5 | 0x30;\n      break;\n    default:\n      builtin_usage();\n      return 0x102;\n    case 0x61:\n      uVar6 = uVar6 | 1;\n      break;\n    case 0x66:\n      uVar6 = uVar6 | 0x40;\n      break;\n    case 0x70:\n      uVar6 = uVar6 & 0xfffffff5 | 0x10;\n      break;\n    case 0x74:\n      uVar6 = uVar6 & 0xffffffed | 8;\n    }\n  }\n  builtin_help();\n  return 0x102;\n}\n\n",
  "xmalloc": "\nvoid * xmalloc(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  if (DAT_00248a48 == 0) {\n    DAT_00248a50 = sbrk(0);\n    DAT_00248a48 = 1;\n  }\n  pvVar1 = malloc(param_1);\n  if (pvVar1 == (void *)0x0) {\n    FUN_001a1750(\"xmalloc\",param_1);\n  }\n  return pvVar1;\n}\n\n",
  "dlopen": "\nvoid dlopen(void)\n\n{\n  (*(code *)PTR_dlopen_00237b10)();\n  return;\n}\n\n",
  "_rl_find_completion_word": "\nchar _rl_find_completion_word(uint *param_1,int *param_2)\n\n{\n  char cVar1;\n  long lVar2;\n  uint uVar3;\n  int iVar4;\n  char *pcVar5;\n  size_t sVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char cVar9;\n  uint uVar10;\n  int iVar11;\n  bool bVar12;\n  char *local_50;\n  \n  uVar3 = rl_point;\n  if ((rl_completion_word_break_hook == (code *)0x0) ||\n     (local_50 = (char *)(*rl_completion_word_break_hook)(), local_50 == (char *)0x0)) {\n    local_50 = rl_completer_word_break_characters;\n    if (rl_completer_quote_characters != (char *)0x0) goto LAB_001d80a0;\nLAB_001d81ca:\n    uVar8 = (ulong)rl_point;\n    if (uVar3 == rl_point) {\n      uVar10 = 0;\nLAB_001d8303:\n      do {\n        do {\n          sVar6 = __ctype_get_mb_cur_max();\n          if ((sVar6 < 2) || (rl_byte_oriented != 0)) {\n            rl_point = rl_point - 1;\n          }\n          else {\n            rl_point = _rl_find_prev_mbchar(rl_line_buffer,rl_point,0);\n          }\n          lVar2 = rl_line_buffer;\n          uVar8 = (ulong)rl_point;\n          uVar7 = (ulong)(int)rl_point;\n          if (rl_point == 0) {\n            cVar9 = '\\0';\n            goto LAB_001d8178;\n          }\n          iVar11 = (int)*(char *)(rl_line_buffer + uVar7);\n          pcVar5 = strchr(local_50,iVar11);\n        } while (pcVar5 == (char *)0x0);\n        if ((rl_char_is_quoted_p == (code *)0x0) || (uVar10 == 0)) {\n          cVar9 = '\\0';\n          iVar4 = iVar11;\n          if (iVar11 == 0) goto LAB_001d8182;\n          goto LAB_001d823b;\n        }\n        iVar11 = (*rl_char_is_quoted_p)(lVar2,uVar8);\n      } while (iVar11 != 0);\n      uVar7 = (ulong)(int)rl_point;\n      cVar9 = '\\0';\n      uVar8 = uVar7;\n      goto LAB_001d8178;\n    }\n    cVar9 = '\\0';\n    uVar10 = 0;\n    cVar1 = *(char *)(rl_line_buffer + (int)rl_point);\n  }\n  else {\n    if (rl_completer_quote_characters == (char *)0x0) goto LAB_001d81ca;\nLAB_001d80a0:\n    bVar12 = true;\n    cVar9 = '\\0';\n    uVar10 = 0;\n    if (0 < (int)uVar3) {\n      cVar9 = '\\0';\n      bVar12 = false;\n      uVar10 = 0;\n      iVar11 = 0;\n      do {\n        if (bVar12) {\n          bVar12 = false;\n        }\n        else {\n          cVar1 = *(char *)(rl_line_buffer + iVar11);\n          if (cVar9 == '\\'') {\nLAB_001d82b0:\n            if (cVar9 == cVar1) {\n              cVar9 = '\\0';\n              rl_point = uVar3;\n            }\n          }\n          else if (cVar1 == '\\\\') {\n            uVar10 = uVar10 | 4;\n            bVar12 = true;\n          }\n          else {\n            if (cVar9 != '\\0') goto LAB_001d82b0;\n            pcVar5 = strchr(rl_completer_quote_characters,(int)cVar1);\n            if (pcVar5 != (char *)0x0) {\n              rl_point = iVar11 + 1;\n              if (cVar1 == '\\'') {\n                uVar10 = uVar10 | 1;\n                cVar9 = '\\'';\n              }\n              else if (cVar1 == '\\\"') {\n                uVar10 = uVar10 | 2;\n                cVar9 = '\\\"';\n              }\n              else {\n                uVar10 = uVar10 | 8;\n                cVar9 = cVar1;\n              }\n            }\n          }\n        }\n        sVar6 = __ctype_get_mb_cur_max();\n        if ((sVar6 < 2) || (rl_byte_oriented != 0)) {\n          iVar11 = iVar11 + 1;\n        }\n        else {\n          iVar11 = _rl_find_next_mbchar(rl_line_buffer,iVar11,1,0);\n        }\n      } while (iVar11 < (int)uVar3);\n      bVar12 = cVar9 == '\\0';\n    }\n    if ((rl_point == uVar3) && (bVar12)) goto LAB_001d8303;\n    uVar7 = (ulong)(int)rl_point;\n    uVar8 = (ulong)rl_point;\nLAB_001d8178:\n    cVar1 = *(char *)(rl_line_buffer + uVar7);\n  }\n  iVar11 = (int)cVar1;\n  if (iVar11 == 0) goto LAB_001d8182;\n  if (rl_char_is_quoted_p == (code *)0x0) {\n    pcVar5 = strchr(local_50,iVar11);\njoined_r0x001d8425:\n    iVar4 = iVar11;\n    if (pcVar5 != (char *)0x0) {\nLAB_001d823b:\n      iVar11 = 0;\n      if (((rl_basic_quote_characters != (undefined *)0x0) &&\n          (pcVar5 = strchr(rl_basic_quote_characters,iVar4), pcVar5 != (char *)0x0)) &&\n         (iVar11 = 0, 1 < (int)(uVar3 - rl_point))) {\n        iVar11 = iVar4;\n      }\n      if ((rl_special_prefixes == (char *)0x0) ||\n         (pcVar5 = strchr(rl_special_prefixes,iVar4), pcVar5 == (char *)0x0)) {\n        rl_point = rl_point + 1;\n      }\n      goto LAB_001d8182;\n    }\n  }\n  else {\n    if (uVar10 == 0) {\n      pcVar5 = strchr(local_50,iVar11);\n      goto joined_r0x001d8425;\n    }\n    iVar4 = (*rl_char_is_quoted_p)(rl_line_buffer,uVar8 & 0xffffffff);\n    if (iVar4 == 0) {\n      pcVar5 = strchr(local_50,iVar11);\n      goto joined_r0x001d8425;\n    }\n  }\n  iVar11 = 0;\nLAB_001d8182:\n  if (param_1 != (uint *)0x0) {\n    *param_1 = uVar10;\n  }\n  if (param_2 != (int *)0x0) {\n    *param_2 = iVar11;\n  }\n  return cVar9;\n}\n\n",
  "rl_free_undo_list": "\nvoid rl_free_undo_list(void)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long *plVar3;\n  \n  plVar2 = rl_undo_list;\n  plVar3 = rl_undo_list;\n  if (rl_undo_list != (long *)0x0) {\n    do {\n      while (plVar1 = (long *)*plVar3, *(int *)(plVar3 + 3) != 0) {\n        xfree(plVar3);\n        plVar3 = plVar1;\n        if (plVar1 == (long *)0x0) goto LAB_001ea380;\n      }\n      xfree(plVar3[2]);\n      xfree(plVar3);\n      plVar3 = plVar1;\n    } while (plVar1 != (long *)0x0);\n  }\nLAB_001ea380:\n  rl_undo_list = (long *)0x0;\n  _hs_replace_history_data(0xffffffff,plVar2,0);\n  return;\n}\n\n",
  "FUN_0019e2d0": "\nundefined8 FUN_0019e2d0(uint *param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  undefined8 *puVar3;\n  long lVar4;\n  uint uVar5;\n  undefined8 *puVar6;\n  undefined8 *puVar7;\n  int iVar8;\n  \n  plVar2 = (long *)strlist_create();\n  if (num_shell_builtins < 1) {\n    puVar7 = (undefined8 *)*plVar2;\n    iVar8 = 0;\n  }\n  else {\n    uVar5 = num_shell_builtins - 1;\n    lVar1 = *plVar2;\n    iVar8 = 0;\n    puVar7 = (undefined8 *)(shell_builtins + 0x30);\n    puVar3 = (undefined8 *)shell_builtins;\n    puVar6 = puVar7;\n    while( true ) {\n      if ((puVar3[1] != 0) && ((*(byte *)(puVar3 + 2) & 1) != 0)) {\n        lVar4 = (long)iVar8;\n        iVar8 = iVar8 + 1;\n        *(undefined8 *)(lVar1 + lVar4 * 8) = *puVar3;\n      }\n      if (puVar6 == puVar7 + (ulong)uVar5 * 6) break;\n      puVar3 = puVar6;\n      puVar6 = puVar6 + 6;\n    }\n    puVar7 = (undefined8 *)(lVar1 + (long)iVar8 * 8);\n  }\n  *(int *)((long)plVar2 + 0xc) = iVar8;\n  *puVar7 = 0;\n  *(long **)(param_1 + 4) = plVar2;\n  *param_1 = *param_1 | 0x20;\n  return 0;\n}\n\n",
  "sh_contains_shell_metas": "\nundefined8 sh_contains_shell_metas(byte *param_1)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  byte *pbVar3;\n  \n  if (param_1 != (byte *)0x0) {\n    bVar2 = *param_1;\n    pbVar3 = param_1;\n    while (bVar2 != 0) {\n      if ((char)bVar2 < '@') {\n        if (('\\b' < (char)bVar2) &&\n           (((1L << (bVar2 & 0x3f) & 0xd80007d700000600U) != 0 ||\n            ((bVar2 == 0x23 && (param_1 == pbVar3)))))) {\n          return 1;\n        }\n      }\n      else if (bVar2 == 0x7e) {\n        if (param_1 == pbVar3) {\n          return 1;\n        }\n        if (pbVar3[-1] == 0x3d) {\n          return 1;\n        }\n        if (pbVar3[-1] == 0x3a) {\n          return 1;\n        }\n      }\n      else if (bVar2 != 0x7f) {\n        if (bVar2 == 0x60) {\n          return 1;\n        }\n        if ((char)bVar2 < 'a') {\n          if ((byte)(bVar2 + 0xa5) < 4) {\n            return 1;\n          }\n        }\n        else if ((byte)(bVar2 + 0x85) < 3) {\n          return 1;\n        }\n      }\n      pbVar1 = pbVar3 + 1;\n      pbVar3 = pbVar3 + 1;\n      bVar2 = *pbVar1;\n    }\n  }\n  return 0;\n}\n\n",
  "FUN_001d5f60": "\nvoid FUN_001d5f60(char *param_1,int param_2,undefined4 param_3,char *param_4)\n\n{\n  char cVar1;\n  char cVar2;\n  char cVar3;\n  int iVar4;\n  char *__s;\n  size_t sVar5;\n  char *pcVar6;\n  int iVar7;\n  char *__s_00;\n  \n  cVar1 = *param_4;\n  __s = (char *)FUN_001d5ec0(param_1,param_3,param_4);\n  if (__s == (char *)0x0) {\n    return;\n  }\n  sVar5 = strlen(__s);\n  cVar2 = *param_4;\n  iVar7 = rl_point + -1;\n  if ((param_2 == 0) || (cVar2 == '\\0')) {\n    if ((cVar2 != cVar1) && (param_2 != 0)) {\n      if (cVar1 != *(char *)(rl_line_buffer + -1 + (long)param_2)) goto LAB_001d5fce;\n      if (*__s != cVar1) goto LAB_001d60f7;\n    }\nLAB_001d5fc6:\n    if (cVar2 == '\\0') goto LAB_001d5fce;\n  }\n  else {\n    cVar3 = *(char *)(rl_line_buffer + -1 + (long)param_2);\n    if ((cVar2 == cVar3) && (cVar2 == *__s)) {\n      param_2 = param_2 + -1;\n    }\n    else if ((cVar2 != cVar1) && ((cVar3 == cVar1 && (cVar3 != *__s)))) {\nLAB_001d60f7:\n      param_2 = param_2 + -1;\n      goto LAB_001d5fc6;\n    }\n  }\n  if (((iVar7 != 0) && (cVar2 == *(char *)(rl_line_buffer + rl_point))) &&\n     (cVar2 == __s[(long)(int)sVar5 + -1])) {\n    iVar7 = rl_point;\n  }\nLAB_001d5fce:\n  if (_rl_skip_completed_text == 0) {\n    _rl_replace_text(__s,param_2,iVar7);\n  }\n  else {\n    __s_00 = __s;\n    iVar4 = param_2;\n    if (param_2 < rl_end) {\n      pcVar6 = (char *)(param_2 + rl_line_buffer);\n      do {\n        if (*__s_00 == '\\0') {\n          if (param_2 <= iVar7) goto LAB_001d6028;\n          goto LAB_001d6035;\n        }\n        if (*__s_00 != *pcVar6) goto LAB_001d6028;\n        param_2 = param_2 + 1;\n        __s_00 = __s_00 + 1;\n        pcVar6 = pcVar6 + 1;\n        iVar4 = rl_end;\n      } while (rl_end != param_2);\n    }\n    param_2 = iVar4;\n    if ((param_2 <= iVar7) || (*__s_00 != '\\0')) {\nLAB_001d6028:\n      _rl_replace_text(__s_00,param_2,iVar7);\n    }\nLAB_001d6035:\n    sVar5 = strlen(__s_00);\n    rl_point = (int)sVar5 + param_2;\n  }\n  if (param_1 == __s) {\n    return;\n  }\n  xfree(__s);\n  return;\n}\n\n",
  "rl_rubout": "\nundefined8 rl_rubout(int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (param_1 < 0) {\n    uVar1 = rl_delete(-param_1);\n    return uVar1;\n  }\n  if (rl_point != 0) {\n    if (rl_insert_mode != 0) {\n      uVar1 = _rl_rubout_char();\n      return uVar1;\n    }\n    uVar1 = _rl_overwrite_rubout();\n    return uVar1;\n  }\n  rl_ding();\n  return 1;\n}\n\n",
  "rl_read_key": "\nuint rl_read_key(void)\n\n{\n  ulong uVar1;\n  uint uVar2;\n  int iVar3;\n  long lVar4;\n  int *piVar5;\n  \n  uVar2 = rl_pending_input;\n  if (rl_pending_input == 0) {\n    uVar2 = _rl_next_macro_key();\n    if (uVar2 == 0) {\n      if (rl_event_hook == (code *)0x0) {\n        lVar4 = (long)DAT_0024b3e4;\n        if (DAT_0024b3e0 == DAT_0024b3e4) {\n          uVar2 = (*(code *)rl_getc_function)(rl_instream);\n        }\n        else {\n          DAT_0024b3e4 = DAT_0024b3e4 + 1;\n          uVar2 = (uint)(byte)(&DAT_0024b1e0)[lVar4];\n          if (0x1ff < DAT_0024b3e4) {\n            DAT_0024b3e4 = 0;\n          }\n        }\n        if (_rl_caught_signal != 0) {\n          _rl_signal_handler(_rl_caught_signal);\n        }\n      }\n      else {\n        do {\n          lVar4 = (long)DAT_0024b3e4;\n          if (DAT_0024b3e0 != DAT_0024b3e4) {\n            DAT_0024b3e4 = DAT_0024b3e4 + 1;\n            if (0x1ff < DAT_0024b3e4) {\n              DAT_0024b3e4 = 0;\n            }\n            return (uint)(byte)(&DAT_0024b1e0)[lVar4];\n          }\n          iVar3 = FUN_001eb820();\n          uVar1 = rl_readline_state;\n          if (iVar3 < 0) {\n            rl_done = 1;\n            rl_readline_state = rl_readline_state | 0x2000000;\n            piVar5 = __errno_location();\n            if (*piVar5 != 5) {\n              return 10;\n            }\n            return ((uVar1 & 8) == 0) - 2;\n          }\n          if (iVar3 == 0) {\n            if (_rl_caught_signal != 0) {\n              _rl_signal_handler(_rl_caught_signal);\n            }\n            if (rl_done != 0) {\n              return 10;\n            }\n            (*rl_event_hook)();\n          }\n        } while (rl_event_hook != (code *)0x0);\n        uVar2 = 0;\n      }\n    }\n    else {\n      uVar2 = uVar2 & 0xff;\n    }\n  }\n  else {\n    rl_readline_state = rl_readline_state & 0xfffffffffffdffff;\n    rl_pending_input = 0;\n  }\n  return uVar2;\n}\n\n",
  "FUN_0018ffd0": "\nvoid FUN_0018ffd0(char **param_1,char **param_2)\n\n{\n  if (**param_1 == **param_2) {\n    strcmp(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "brand": "\nuint brand(void)\n\n{\n  ulong uVar1;\n  uint uVar2;\n  \n  uVar1 = 0x1f0cce42;\n  if (DAT_0023b318 != 0) {\n    uVar2 = (DAT_0023b318 % 0x1f31d) * 0x41a7 + (DAT_0023b318 / 0x1f31d) * -0xb14;\n    uVar1 = (ulong)(uVar2 + 0x7fffffff);\n    if (-1 < (int)uVar2) {\n      uVar1 = (ulong)uVar2;\n    }\n  }\n  uVar2 = (uint)uVar1;\n  DAT_0023b318 = uVar2;\n  if (0x32 < shell_compatibility_level) {\n    uVar2 = uVar2 & 0xffff ^ (uint)(uVar1 >> 0x10);\n  }\n  return uVar2 & 0x7fff;\n}\n\n",
  "rl_echo_signal_char": "\nvoid rl_echo_signal_char(int param_1)\n\n{\n  ushort **ppuVar1;\n  __int32_t **pp_Var2;\n  uint uVar3;\n  ulong uVar4;\n  undefined8 uVar5;\n  long in_FS_OFFSET;\n  undefined local_23;\n  byte local_22;\n  undefined local_21;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((_rl_echoctl == 0) || (_rl_echo_control_chars == 0)) goto LAB_001e85a7;\n  if (param_1 == 3) {\n    uVar3 = _rl_quit_char;\n    if ((int)_rl_quit_char < 0x20) goto LAB_001e8600;\nLAB_001e85d3:\n    if (uVar3 != 0x7f) goto LAB_001e8630;\n    local_23 = 0x5e;\n    local_22 = 0x3f;\nLAB_001e85e2:\n    uVar5 = 2;\n    local_21 = 0;\n  }\n  else {\n    uVar3 = _rl_susp_char;\n    if ((param_1 != 0x14) && (uVar3 = _rl_intr_char, param_1 != 2)) goto LAB_001e85a7;\n    if (0x1f < (int)uVar3) goto LAB_001e85d3;\nLAB_001e8600:\n    if ((uVar3 & 0x80) == 0) {\n      local_23 = 0x5e;\n      local_22 = (byte)uVar3 | 0x40;\n      ppuVar1 = __ctype_b_loc();\n      uVar4 = (ulong)(uVar3 & 0xff | 0x40);\n      if ((*(byte *)((long)*ppuVar1 + uVar4 * 2 + 1) & 2) != 0) {\n        pp_Var2 = __ctype_toupper_loc();\n        local_22 = *(byte *)(*pp_Var2 + uVar4);\n      }\n      goto LAB_001e85e2;\n    }\nLAB_001e8630:\n    local_23 = (undefined)uVar3;\n    uVar5 = 1;\n    local_22 = 0;\n  }\n  _rl_output_some_chars(&local_23,uVar5);\nLAB_001e85a7:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "all_shell_functions": "\nvoid * all_shell_functions(void)\n\n{\n  int iVar1;\n  void *__base;\n  \n  __base = (void *)map_over_funcs(0);\n  if (__base != (void *)0x0) {\n    iVar1 = strvec_len(__base);\n    qsort(__base,(long)iVar1,8,FUN_001513a0);\n  }\n  return __base;\n}\n\n",
  "_rl_fix_mark": "\nvoid _rl_fix_mark(void)\n\n{\n  if (rl_end < rl_mark) {\n    rl_mark = rl_end;\n    return;\n  }\n  if (-1 < rl_mark) {\n    return;\n  }\n  rl_mark = 0;\n  return;\n}\n\n",
  "file_status": "\nuint file_status(char *param_1)\n\n{\n  int iVar1;\n  long *plVar2;\n  uint uVar3;\n  long in_FS_OFFSET;\n  stat sStack_b8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = stat(param_1,&sStack_b8);\n  uVar3 = 0;\n  if ((-1 < iVar1) && (uVar3 = 0x11, (sStack_b8.st_mode & 0xf000) != 0x4000)) {\n    plVar2 = DAT_00238da8;\n    if (DAT_00238da8 != (long *)0x0) {\n      for (; *plVar2 != 0; plVar2 = plVar2 + 2) {\n        iVar1 = strmatch(*plVar2,param_1,(-(uint)(extended_glob == 0) & 0xffffffe0) + 0x30);\n        if (iVar1 != 1) goto LAB_0019b2f0;\n      }\n    }\n    uVar3 = 3;\n    iVar1 = eaccess(param_1,1);\n    if (iVar1 != 0) {\nLAB_0019b2f0:\n      uVar3 = 1;\n    }\n    iVar1 = eaccess(param_1,4);\n    if (iVar1 == 0) {\n      uVar3 = uVar3 | 0x40;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}\n\n",
  "remember_mail_dates": "\nvoid remember_mail_dates(void)\n\n{\n  char *pcVar1;\n  long lVar2;\n  char *pcVar3;\n  char cVar4;\n  char *pcVar5;\n  long in_FS_OFFSET;\n  undefined4 local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_34 = 0;\n  lVar2 = get_string_value(\"MAILPATH\");\n  if (lVar2 == 0) {\n    lVar2 = get_string_value(&DAT_001fd178);\n    if (lVar2 == 0) {\n      lVar2 = make_default_mailpath();\n      if (lVar2 != 0) {\n        FUN_00180670(lVar2,0);\n        sh_xfree(lVar2,\"mailcheck.c\",0x185);\n      }\n    }\n    else {\n      FUN_00180670(lVar2,0);\n    }\n  }\n  else {\n    while (pcVar3 = (char *)extract_colon_unit(lVar2,&local_34), pcVar3 != (char *)0x0) {\n      cVar4 = *pcVar3;\n      pcVar5 = pcVar3;\n      while (cVar4 != '\\0') {\n        while (cVar4 != '\\\\') {\n          if ((cVar4 == '?') || (cVar4 == '%')) {\n            if (*pcVar5 != '\\0') {\n              *pcVar5 = '\\0';\n              pcVar5 = pcVar5 + 1;\n            }\n            goto LAB_00180b0a;\n          }\n          cVar4 = pcVar5[1];\n          pcVar5 = pcVar5 + 1;\n          if (cVar4 == '\\0') goto LAB_00180b08;\n        }\n        if (pcVar5[1] == '\\0') break;\n        pcVar1 = pcVar5 + 2;\n        pcVar5 = pcVar5 + 2;\n        cVar4 = *pcVar1;\n      }\nLAB_00180b08:\n      pcVar5 = (char *)0x0;\nLAB_00180b0a:\n      FUN_00180670(pcVar3,pcVar5);\n      sh_xfree(pcVar3,\"mailcheck.c\",400);\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "ttfd_nocanon": "\nvoid ttfd_nocanon(int param_1,termios *param_2)\n\n{\n  param_2->c_lflag = param_2->c_lflag & 0xfffffffd;\n  tcsetattr(param_1,1,param_2);\n  return;\n}\n\n",
  "FUN_00151400": "\nchar ** FUN_00151400(char *param_1)\n\n{\n  char **ppcVar1;\n  size_t sVar2;\n  char *pcVar3;\n  \n  ppcVar1 = (char **)sh_xmalloc(0x30,\"variables.c\",0xad0);\n  sVar2 = strlen(param_1);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"variables.c\",0xad2);\n  pcVar3 = strcpy(pcVar3,param_1);\n  ppcVar1[1] = (char *)0x0;\n  *ppcVar1 = pcVar3;\n  ppcVar1[2] = (char *)0x0;\n  ppcVar1[3] = (char *)0x0;\n  ppcVar1[4] = (char *)0x0;\n  ppcVar1[5] = (char *)0x0;\n  return ppcVar1;\n}\n\n",
  "nameref_transform_name": "\nundefined8 nameref_transform_name(undefined8 param_1,ulong param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  if ((param_2 & 2) == 0) {\n    if ((param_2 & 8) == 0) {\n      return param_1;\n    }\n    if ((param_2 & 0x40) == 0) {\n      lVar2 = find_global_variable_last_nameref();\n    }\n    else {\n      lVar2 = find_variable_last_nameref(param_1,1);\n    }\n    if (lVar2 == 0) {\n      return param_1;\n    }\n  }\n  else {\n    lVar2 = find_variable_last_nameref(param_1,1);\n    if (lVar2 == 0) {\n      return param_1;\n    }\n    if (*(int *)(lVar2 + 0x2c) != variable_context) {\n      return param_1;\n    }\n  }\n  if (((*(byte *)(lVar2 + 0x29) & 8) != 0) &&\n     (iVar1 = valid_nameref_value(*(undefined8 *)(lVar2 + 8),1), iVar1 != 0)) {\n    param_1 = *(undefined8 *)(lVar2 + 8);\n  }\n  return param_1;\n}\n\n",
  "absolute_program": "\nbool absolute_program(undefined8 param_1)\n\n{\n  long lVar1;\n  \n  lVar1 = mbschr(param_1,0x2f);\n  return lVar1 != 0;\n}\n\n",
  "make_command_string": "\nundefined8 make_command_string(void)\n\n{\n  DAT_00241f28 = 0;\n  command_string_index = 0;\n  DAT_00241f18 = 0;\n  FUN_00146230();\n  return the_printed_command;\n}\n\n",
  "strvec_search": "\nulong strvec_search(char **param_1,char *param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  ulong uVar3;\n  char *__s2;\n  \n  __s2 = *param_1;\n  if (__s2 != (char *)0x0) {\n    cVar1 = *param_2;\n    uVar3 = 0;\n    do {\n      if (cVar1 == *__s2) {\n        iVar2 = strcmp(param_2,__s2);\n        if (iVar2 == 0) {\n          return uVar3 & 0xffffffff;\n        }\n      }\n      uVar3 = uVar3 + 1;\n      __s2 = param_1[uVar3];\n    } while (__s2 != (char *)0x0);\n  }\n  return 0xffffffff;\n}\n\n",
  "coproc_fdsave": "\nvoid coproc_fdsave(long param_1)\n\n{\n  *(undefined8 *)(param_1 + 0x14) = *(undefined8 *)(param_1 + 0xc);\n  return;\n}\n\n",
  "rl_kill_region": "\nundefined4 rl_kill_region(void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  iVar1 = rl_point;\n  if (rl_mark <= rl_point) {\n    iVar1 = rl_mark;\n  }\n  uVar2 = FUN_001e9520(1);\n  rl_point = iVar1;\n  _rl_fix_point(1);\n  return uVar2;\n}\n\n",
  "rl_dump_macros": "\nundefined8 rl_dump_macros(void)\n\n{\n  if (rl_dispatching != 0) {\n    fwrite(&DAT_001ff375,1,2,rl_outstream);\n  }\n  FUN_001dc2f0(rl_explicit_arg,_rl_keymap,0);\n  rl_on_new_line();\n  return 0;\n}\n\n",
  "yy_input_name": "\nchar * yy_input_name(void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = DAT_00240a68;\n  if (DAT_00240a68 == (char *)0x0) {\n    pcVar1 = \"stdin\";\n  }\n  return pcVar1;\n}\n\n",
  "utf8_mbsmbchar": "\nvoid utf8_mbsmbchar(void)\n\n{\n  FUN_001ccc42();\n  return;\n}\n\n",
  "setservent": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid setservent(int __stay_open)\n\n{\n  (*(code *)PTR_setservent_00237a98)();\n  return;\n}\n\n",
  "wcsnwidth": "\nulong wcsnwidth(wchar_t *param_1,long param_2,long param_3)\n\n{\n  int iVar1;\n  wchar_t *pwVar2;\n  wchar_t *pwVar3;\n  int iVar4;\n  bool bVar5;\n  \n  if (param_2 == 0) {\n    return 0;\n  }\n  param_2 = param_2 + -1;\n  iVar4 = 0;\n  pwVar2 = param_1;\n  do {\n    pwVar3 = pwVar2 + 1;\n    if (*pwVar2 == L'\\0') break;\n    iVar1 = wcwidth(*pwVar2);\n    if (iVar1 < 0) {\n      return 0xffffffff;\n    }\n    if ((long)iVar1 == param_3 - iVar4) break;\n    if ((ulong)(param_3 - iVar4) < (ulong)(long)iVar1) {\n      return (long)pwVar2 - (long)param_1 >> 2 & 0xffffffff;\n    }\n    iVar4 = iVar4 + iVar1;\n    bVar5 = param_2 != 0;\n    param_2 = param_2 + -1;\n    pwVar2 = pwVar3;\n  } while (bVar5);\n  return (long)pwVar3 - (long)param_1 >> 2;\n}\n\n",
  "enable_hostname_completion": "\nundefined4 enable_hostname_completion(int param_1)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  char *pcVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char *pcVar6;\n  \n  pcVar5 = (char *)rl_completer_word_break_characters;\n  uVar2 = perform_hostname_completion;\n  rl_special_prefixes = &DAT_001ff438;\n  perform_hostname_completion = (uint)(param_1 != 0);\n  if (param_1 == 0) {\n    rl_special_prefixes = &DAT_00213cf3;\n  }\n  if ((bash_readline_initialized == 0) &&\n     ((rl_completer_word_break_characters == (undefined8 *)0x0 ||\n      ((undefined8 *)rl_basic_word_break_characters == rl_completer_word_break_characters)))) {\n    if (param_1 != 0) {\n      rl_completer_word_break_characters = (undefined8 *)sh_xmalloc(0xf,\"bashline.c\",0x198);\n      *rl_completer_word_break_characters = 0x3c3e4027220a0920;\n      *(undefined4 *)(rl_completer_word_break_characters + 1) = 0x267c3b3d;\n      *(undefined2 *)((long)rl_completer_word_break_characters + 0xc) = 0x3a28;\n      *(undefined *)((long)rl_completer_word_break_characters + 0xe) = 0;\n      return uVar2;\n    }\n    rl_completer_word_break_characters = (undefined8 *)sh_xmalloc(0xe,\"bashline.c\",0x19a);\n    *rl_completer_word_break_characters = 0x3d3c3e27220a0920;\n    *(undefined4 *)(rl_completer_word_break_characters + 1) = 0x28267c3b;\n    *(undefined2 *)((long)rl_completer_word_break_characters + 0xc) = 0x3a;\n    return uVar2;\n  }\n  pcVar3 = strchr((char *)rl_completer_word_break_characters,0x40);\n  if ((pcVar3 == (char *)0x0) != (param_1 != 0)) {\n    return uVar2;\n  }\n  sVar4 = strlen(pcVar5);\n  pcVar5 = (char *)sh_xmalloc((long)param_1 + 1 + sVar4,\"bashline.c\",0x1a4);\n  if (param_1 == 0) {\n    cVar1 = *(char *)rl_completer_word_break_characters;\n    pcVar3 = pcVar5;\n    pcVar6 = (char *)rl_completer_word_break_characters;\n    while (cVar1 != '\\0') {\n      pcVar6 = pcVar6 + 1;\n      if (cVar1 != '@') {\n        *pcVar3 = cVar1;\n        pcVar3 = pcVar3 + 1;\n      }\n      cVar1 = *pcVar6;\n    }\n    *pcVar3 = '\\0';\n  }\n  else {\n    *pcVar5 = '@';\n    strcpy(pcVar5 + 1,(char *)rl_completer_word_break_characters);\n  }\n  sh_xfree(rl_completer_word_break_characters,\"bashline.c\",0x1b8);\n  rl_completer_word_break_characters = (undefined8 *)pcVar5;\n  return uVar2;\n}\n\n",
  "FUN_0019b300": "\nchar * FUN_0019b300(char *param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  size_t sVar2;\n  char *pcVar3;\n  \n  uVar1 = file_status();\n  if (((uVar1 & 1) != 0) && (((param_2 & 1) != 0 || (((param_2 & 8) != 0 && ((uVar1 & 2) != 0))))))\n  {\n    sVar2 = strlen(param_1);\n    pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"findcmd.c\",0x205);\n    pcVar3 = strcpy(pcVar3,param_1);\n    return pcVar3;\n  }\n  return (char *)0x0;\n}\n\n",
  "FUN_0019e810": "\nundefined8 FUN_0019e810(uint *param_1)\n\n{\n  undefined4 uVar1;\n  undefined8 *puVar2;\n  \n  puVar2 = (undefined8 *)strlist_create(0);\n  *puVar2 = &signal_names;\n  uVar1 = strvec_len();\n  *(undefined4 *)((long)puVar2 + 0xc) = uVar1;\n  *(undefined8 **)(param_1 + 4) = puVar2;\n  *param_1 = *param_1 | 0x10;\n  return 0;\n}\n\n",
  "restore_token_state": "\nvoid restore_token_state(undefined4 *param_1)\n\n{\n  if (param_1 != (undefined4 *)0x0) {\n    DAT_00240d70 = *param_1;\n    DAT_00240d6c = param_1[1];\n    DAT_00240d68 = param_1[2];\n    current_token = param_1[3];\n  }\n  return;\n}\n\n",
  "access": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint access(char *__name,int __type)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_access_00237d48)();\n  return iVar1;\n}\n\n",
  "history_get_history_state": "\nvoid history_get_history_state(void)\n\n{\n  int iVar1;\n  undefined8 *puVar2;\n  \n  puVar2 = (undefined8 *)xmalloc(0x18);\n  iVar1 = DAT_0024b6e4;\n  *puVar2 = DAT_0024b6e8;\n  *(undefined4 *)(puVar2 + 1) = history_offset;\n  *(undefined4 *)((long)puVar2 + 0xc) = history_length;\n  *(undefined4 *)(puVar2 + 2) = DAT_0024b6e0;\n  *(uint *)((long)puVar2 + 0x14) = (uint)(iVar1 != 0);\n  return;\n}\n\n",
  "builtin_warning": "\nvoid builtin_warning(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                    undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                    undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                    undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  long local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(long *)(in_FS_OFFSET + 0x28);\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  FUN_001a3980();\n  fwrite(\"warning: \",1,9,stderr);\n  local_d0 = &stack0x00000008;\n  local_d8 = 8;\n  local_c8 = local_b8;\n  local_d4 = 0x30;\n  __vfprintf_chk(stderr,1,param_9,&local_d8);\n  fputc(10,stderr);\n  if (local_c0 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0019eac0": "\nundefined8 *\nFUN_0019eac0(undefined8 param_1,undefined8 param_2,undefined8 param_3,long *param_4,int param_5)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  \n  uVar2 = make_word();\n  puVar3 = (undefined8 *)make_word_list(uVar2,0);\n  uVar2 = make_word(param_2);\n  puVar4 = (undefined8 *)make_word_list(uVar2,0);\n  *puVar3 = puVar4;\n  uVar2 = make_word(param_3);\n  puVar5 = (undefined8 *)make_word_list(uVar2,0);\n  *puVar4 = puVar5;\n  if (param_4 != (long *)0x0) {\n    if (1 < param_5 + -1) {\n      iVar1 = 1;\n      do {\n        param_4 = (long *)*param_4;\n        iVar1 = iVar1 + 1;\n        if (param_4 == (long *)0x0) goto LAB_0019eb40;\n      } while (param_5 + -1 != iVar1);\n    }\n    if (param_4[1] != 0) {\n      uVar2 = copy_word();\n      goto LAB_0019eb4f;\n    }\n  }\nLAB_0019eb40:\n  uVar2 = make_word(&DAT_00213d70);\nLAB_0019eb4f:\n  uVar2 = make_word_list(uVar2,0);\n  *puVar5 = uVar2;\n  return puVar3;\n}\n\n",
  "pushd_builtin": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nint pushd_builtin(long **param_1)\n\n{\n  long *plVar1;\n  long *__src;\n  long lVar2;\n  bool bVar3;\n  bool bVar4;\n  int iVar5;\n  char *pcVar6;\n  long lVar7;\n  long lVar8;\n  long *plVar9;\n  size_t sVar10;\n  char *__dest;\n  char *pcVar11;\n  uint uVar12;\n  long lVar13;\n  long lVar14;\n  void *__dest_00;\n  char cVar15;\n  long in_FS_OFFSET;\n  long local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (long **)0x0) {\nLAB_001af0c0:\n    if (DAT_00248b48 == 0) {\n      iVar5 = 1;\n      builtin_error(\"no other directory\");\n      goto LAB_001aeef3;\n    }\n    lVar7 = get_working_directory(\"pushd\");\n    if (lVar7 != 0) {\n      iVar5 = 1;\n      plVar1 = (long *)(DAT_00248b50 + (long)(DAT_00248b48 + -1) * 8);\n      lVar2 = *plVar1;\n      *plVar1 = lVar7;\n      if ((lVar2 != 0) && (iVar5 = FUN_001ae4d0(lVar2), iVar5 == 0)) {\n        dirs_builtin(0);\n      }\n      sh_xfree(lVar2,\"./pushd.def\",0xd3);\n      goto LAB_001aeef3;\n    }\n  }\n  else {\n    pcVar6 = (char *)*param_1[1];\n    cVar15 = *pcVar6;\n    if (cVar15 != '-') {\nLAB_001aee13:\n      bVar3 = false;\n      bVar4 = false;\n      do {\n        if (cVar15 == '-') {\n          cVar15 = pcVar6[1];\n          if (cVar15 != 'n') {\n            if (cVar15 == '-') {\n              if (pcVar6[2] == '\\0') {\n                param_1 = (long **)*param_1;\n                if (bVar4) goto LAB_001aefea;\n                if (param_1 != (long **)0x0) goto LAB_001aee3e;\n                goto LAB_001aeeaa;\n              }\n            }\n            else if (cVar15 == '\\0') goto LAB_001aee34;\nLAB_001aeecc:\n            iVar5 = legal_number(pcVar6 + 1,&local_48);\n            if (iVar5 != 0) {\n              lVar7 = (long)DAT_00248b48;\n              local_48 = lVar7 - local_48;\n              goto joined_r0x001aef3a;\n            }\nLAB_001aeedc:\n            iVar5 = 0x102;\n            sh_invalidnum(*param_1[1]);\n            builtin_usage();\n            goto LAB_001aeef3;\n          }\n          if (pcVar6[2] != '\\0') goto LAB_001aeecc;\n          param_1 = (long **)*param_1;\n          bVar3 = true;\n        }\n        else {\n          if (cVar15 != '+') {\nLAB_001aee34:\n            if (bVar4) goto LAB_001aefea;\nLAB_001aee3e:\n            pcVar6 = (char *)get_working_directory(\"pushd\");\n            if (pcVar6 == (char *)0x0) goto LAB_001af18d;\n            if (!bVar3) goto LAB_001aee60;\n            pcVar11 = (char *)*param_1[1];\n            sVar10 = strlen(pcVar11);\n            __dest = (char *)sh_xmalloc(sVar10 + 1,\"./pushd.def\",0x12e);\n            pcVar11 = strcpy(__dest,pcVar11);\n            goto LAB_001aee73;\n          }\n          iVar5 = legal_number(pcVar6 + 1,&local_48);\n          if (iVar5 == 0) goto LAB_001aeedc;\n          lVar7 = (long)DAT_00248b48;\njoined_r0x001aef3a:\n          if ((local_48 < 0) || (lVar7 < local_48)) {\n            if ((int)lVar7 == 0) {\n              iVar5 = 1;\n              builtin_error(\"directory stack empty\");\n            }\n            else {\n              iVar5 = 1;\n              sh_erange(*param_1[1],\"directory stack index\");\n            }\n            goto LAB_001aeef3;\n          }\n          param_1 = (long **)*param_1;\n          bVar4 = true;\n        }\n        if (param_1 == (long **)0x0) goto LAB_001aefe0;\n        pcVar6 = (char *)*param_1[1];\n        cVar15 = *pcVar6;\n      } while( true );\n    }\n    iVar5 = strcmp(pcVar6,\"--help\");\n    if (iVar5 == 0) {\n      builtin_help();\n      iVar5 = 0x102;\n      goto LAB_001aeef3;\n    }\n    if ((pcVar6[1] != '-') || (pcVar6[2] != '\\0')) goto LAB_001aee13;\n    if (*param_1 == (long *)0x0) goto LAB_001af0c0;\n    pcVar6 = (char *)get_working_directory(\"pushd\");\n    if (pcVar6 != (char *)0x0) {\n      bVar3 = false;\nLAB_001aee60:\n      iVar5 = cd_builtin(param_1);\n      pcVar11 = pcVar6;\n      if (iVar5 == 0) {\nLAB_001aee73:\n        if (DAT_00248b48 == _DAT_00248b4c) {\n          _DAT_00248b4c = DAT_00248b48 + 10;\n          DAT_00248b50 = strvec_resize();\n        }\n        *(char **)(DAT_00248b50 + (long)DAT_00248b48 * 8) = pcVar11;\n        DAT_00248b48 = DAT_00248b48 + 1;\n        dirs_builtin(0);\n        if (bVar3) {\n          sh_xfree(pcVar6,\"./pushd.def\",0x131);\n        }\n        goto LAB_001aeeaa;\n      }\n      sh_xfree(pcVar6,\"./pushd.def\",0x136);\n    }\n  }\nLAB_001af18d:\n  iVar5 = 1;\nLAB_001aeef3:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar5;\nLAB_001aefe0:\n  if (bVar4) {\nLAB_001aefea:\n    lVar7 = get_working_directory(\"pushd\");\n    if (local_48 == 0) {\n      iVar5 = 0;\n      if (((!bVar3) && (iVar5 = 1, lVar7 != 0)) && (iVar5 = FUN_001ae4d0(lVar7), iVar5 == 0)) {\n        dirs_builtin(0);\n      }\n      sh_xfree(lVar7,\"./pushd.def\",0x10b);\n    }\n    else {\n      lVar13 = (long)DAT_00248b48;\n      lVar2 = DAT_00248b50 + -8;\n      uVar12 = DAT_00248b48 - 2;\n      lVar8 = (long)(DAT_00248b48 + -1) * 8;\n      lVar14 = (ulong)uVar12 * -8;\n      plVar1 = (long *)(DAT_00248b50 + lVar8);\n      __dest_00 = (void *)(lVar8 + lVar14 + DAT_00248b50);\n      __src = (long *)(DAT_00248b50 + lVar8 + -8 + lVar14);\n      lVar8 = local_48;\n      do {\n        lVar14 = *(long *)(lVar2 + lVar13 * 8);\n        plVar9 = plVar1;\n        if (-1 < (int)uVar12) {\n          __dest_00 = memmove(__dest_00,__src,(ulong)uVar12 * 8 + 8);\n          plVar9 = __src;\n        }\n        *plVar9 = lVar7;\n        lVar8 = lVar8 + -1;\n        lVar7 = lVar14;\n      } while (lVar8 != 0);\n      local_48 = 0;\n      iVar5 = 0;\n      if (((!bVar3) && (iVar5 = 1, lVar14 != 0)) && (iVar5 = FUN_001ae4d0(lVar14), iVar5 == 0)) {\n        dirs_builtin(0);\n      }\n      sh_xfree(lVar14,\"./pushd.def\",0x11e);\n    }\n    goto LAB_001aeef3;\n  }\nLAB_001aeeaa:\n  iVar5 = 0;\n  goto LAB_001aeef3;\n}\n\n",
  "rl_translate_keyseq": "\nundefined8 rl_translate_keyseq(long param_1,long param_2,int *param_3)\n\n{\n  long lVar1;\n  ushort **ppuVar2;\n  ushort *puVar3;\n  __int32_t **pp_Var4;\n  bool bVar5;\n  ulong uVar6;\n  byte bVar7;\n  byte bVar8;\n  int iVar9;\n  char cVar10;\n  int iVar11;\n  bool bVar12;\n  int iVar13;\n  byte *pbVar14;\n  byte *pbVar15;\n  \n  iVar13 = 0;\n  bVar12 = false;\n  iVar9 = 0;\n  bVar5 = false;\n  do {\n    lVar1 = (long)iVar9;\n    pbVar14 = (byte *)(param_1 + lVar1);\n    bVar7 = *pbVar14;\n    pbVar15 = pbVar14;\n    iVar11 = iVar9;\n    if (bVar7 == 0) {\n      if (!(bool)(bVar5 | bVar12)) {\nLAB_001dad2c:\n        *param_3 = iVar13;\n        *(undefined *)(param_2 + iVar13) = 0;\n        return 0;\n      }\n      if (bVar5) {\n        ppuVar2 = __ctype_b_loc();\n        uVar6 = 0;\n        puVar3 = *ppuVar2;\n        goto LAB_001dacc4;\n      }\n      if (bVar12) goto LAB_001dacf8;\n      bVar7 = 0;\nLAB_001dac5e:\n      lVar1 = (long)iVar13;\n      iVar13 = iVar13 + 1;\n      *(byte *)(param_2 + lVar1) = bVar7;\n      bVar7 = *pbVar14;\njoined_r0x001dac6d:\n      if (bVar7 == 0) goto LAB_001dad2c;\n      bVar12 = false;\n      bVar5 = false;\n    }\n    else {\n      bVar8 = bVar7;\n      if (bVar7 != 0x5c) {\nLAB_001dade9:\n        iVar9 = iVar11;\n        bVar7 = bVar8;\n        if (bVar5) {\n          if (bVar8 != 0x3f) {\nLAB_001db246:\n            ppuVar2 = __ctype_b_loc();\n            uVar6 = (ulong)bVar8;\n            puVar3 = *ppuVar2 + uVar6;\n            bVar7 = bVar8;\n            goto LAB_001dacc4;\n          }\n          bVar7 = 0x7f;\n          goto LAB_001dacef;\n        }\nLAB_001dada0:\n        pbVar14 = pbVar15;\n        if (bVar12) {\nLAB_001dacf8:\n          bVar7 = bVar7 | 0x80;\n          pbVar15 = pbVar14;\n        }\n        else if (-1 < (char)bVar7) goto LAB_001dac5e;\n        pbVar14 = pbVar15;\n        if (_rl_convert_meta_chars_to_ascii == 0) goto LAB_001dac5e;\n        *(undefined *)(param_2 + iVar13) = 0x1b;\n        iVar11 = iVar13 + 1;\n        iVar13 = iVar13 + 2;\n        *(byte *)(param_2 + iVar11) = bVar7 & 0x7f;\n        bVar7 = *pbVar15;\n        goto joined_r0x001dac6d;\n      }\n      pbVar15 = (byte *)(param_1 + 1 + lVar1);\n      bVar8 = *pbVar15;\n      if (bVar8 == 0) {\n        pbVar15 = pbVar14;\n        if (!bVar5) goto LAB_001dacef;\n        ppuVar2 = __ctype_b_loc();\n        uVar6 = 0x5c;\n        puVar3 = *ppuVar2 + 0x5c;\n        goto LAB_001dacc4;\n      }\n      iVar11 = iVar9 + 1;\n      if (bVar8 == 0x43) {\n        if (*(char *)(param_1 + 2 + lVar1) != '-') {\nLAB_001dad92:\n          iVar9 = iVar11;\n          bVar7 = bVar8;\n          if (bVar5) goto LAB_001db246;\n          goto LAB_001dada0;\n        }\n        iVar9 = iVar9 + 2;\n        bVar5 = true;\n      }\n      else {\n        if (bVar8 != 0x4d) {\n          switch(bVar8) {\n          case 0x30:\n          case 0x31:\n          case 0x32:\n          case 0x33:\n          case 0x34:\n          case 0x35:\n          case 0x36:\n          case 0x37:\n            bVar8 = bVar8 - 0x30;\n            lVar1 = (long)(iVar9 + 2);\n            bVar7 = *(char *)(param_1 + lVar1) - 0x30;\n            if (bVar7 < 8) {\n              iVar9 = iVar9 + 3;\n              bVar8 = bVar7 + bVar8 * '\\b';\n              bVar7 = *(char *)(param_1 + iVar9) - 0x30;\n              iVar11 = iVar9 + 2;\n              if (bVar7 < 8) {\n                bVar8 = bVar7 + bVar8 * '\\b';\n                lVar1 = (long)iVar9;\n                iVar11 = iVar9;\n              }\n            }\n            else {\nLAB_001db15b:\n              lVar1 = (long)iVar11;\n            }\n            pbVar15 = (byte *)(lVar1 + param_1);\n          default:\n            goto LAB_001dade9;\n          case 0x5c:\n            iVar9 = iVar11;\n            if (bVar5) {\n              ppuVar2 = __ctype_b_loc();\n              uVar6 = 0x5c;\n              puVar3 = *ppuVar2 + 0x5c;\nLAB_001dacc4:\n              bVar7 = bVar7 & 0x1f;\n              iVar9 = iVar11;\n              if ((*puVar3 & 0x200) != 0) {\n                pp_Var4 = __ctype_toupper_loc();\n                bVar7 = (byte)(*pp_Var4)[uVar6] & 0x1f;\n              }\n            }\n            break;\n          case 0x61:\n            if (bVar5) {\n              bVar7 = 7;\n              ppuVar2 = __ctype_b_loc();\n              uVar6 = 7;\n              puVar3 = *ppuVar2 + 7;\n              goto LAB_001dacc4;\n            }\n            bVar7 = 7;\n            iVar9 = iVar11;\n            break;\n          case 0x62:\n            if (bVar5) {\n              bVar7 = 8;\n              ppuVar2 = __ctype_b_loc();\n              uVar6 = 8;\n              puVar3 = *ppuVar2 + 8;\n              goto LAB_001dacc4;\n            }\n            bVar7 = 8;\n            iVar9 = iVar11;\n            break;\n          case 100:\n            if (bVar5) {\n              bVar7 = 0x7f;\n              ppuVar2 = __ctype_b_loc();\n              uVar6 = 0x7f;\n              puVar3 = *ppuVar2 + 0x7f;\n              goto LAB_001dacc4;\n            }\n            bVar7 = 0x7f;\n            iVar9 = iVar11;\n            break;\n          case 0x65:\n            if (bVar5) {\n              bVar7 = 0x1b;\n              ppuVar2 = __ctype_b_loc();\n              uVar6 = 0x1b;\n              puVar3 = *ppuVar2 + 0x1b;\n              goto LAB_001dacc4;\n            }\n            bVar7 = 0x1b;\n            iVar9 = iVar11;\n            break;\n          case 0x66:\n            if (bVar5) {\n              bVar7 = 0xc;\n              ppuVar2 = __ctype_b_loc();\n              uVar6 = 0xc;\n              puVar3 = *ppuVar2 + 0xc;\n              goto LAB_001dacc4;\n            }\n            bVar7 = 0xc;\n            iVar9 = iVar11;\n            break;\n          case 0x6e:\n            if (bVar5) {\n              bVar7 = 10;\n              ppuVar2 = __ctype_b_loc();\n              uVar6 = 10;\n              puVar3 = *ppuVar2 + 10;\n              goto LAB_001dacc4;\n            }\n            bVar7 = 10;\n            iVar9 = iVar11;\n            break;\n          case 0x72:\n            if (bVar5) {\n              bVar7 = 0xd;\n              ppuVar2 = __ctype_b_loc();\n              uVar6 = 0xd;\n              puVar3 = *ppuVar2 + 0xd;\n              goto LAB_001dacc4;\n            }\n            bVar7 = 0xd;\n            iVar9 = iVar11;\n            break;\n          case 0x74:\n            if (bVar5) {\n              bVar7 = 9;\n              ppuVar2 = __ctype_b_loc();\n              uVar6 = 9;\n              puVar3 = *ppuVar2 + 9;\n              goto LAB_001dacc4;\n            }\n            bVar7 = 9;\n            iVar9 = iVar11;\n            break;\n          case 0x76:\n            if (bVar5) {\n              bVar7 = 0xb;\n              ppuVar2 = __ctype_b_loc();\n              uVar6 = 0xb;\n              puVar3 = *ppuVar2 + 0xb;\n              goto LAB_001dacc4;\n            }\n            bVar7 = 0xb;\n            iVar9 = iVar11;\n            break;\n          case 0x78:\n            bVar8 = 0;\n            lVar1 = (long)(iVar9 + 2);\n            ppuVar2 = __ctype_b_loc();\n            iVar9 = 2;\n            while( true ) {\n              bVar7 = *(byte *)(param_1 + lVar1);\n              if ((*(byte *)((long)*ppuVar2 + (ulong)bVar7 * 2 + 1) & 0x10) == 0) break;\n              if (iVar9 == 0) {\n                iVar11 = (int)lVar1 + -1;\n                goto LAB_001db15b;\n              }\n              if ((byte)(bVar7 + 0x9f) < 6) {\n                cVar10 = bVar7 + 0xa9;\n              }\n              else {\n                cVar10 = bVar7 - 0x30;\n                if ((byte)(bVar7 + 0xbf) < 6) {\n                  cVar10 = bVar7 - 0x37;\n                }\n              }\n              iVar9 = iVar9 + -1;\n              bVar8 = bVar8 * '\\x10' + cVar10;\n              lVar1 = lVar1 + 1;\n            }\n            iVar11 = (int)lVar1 + -1;\n            pbVar15 = (byte *)(iVar11 + param_1);\n            if (iVar9 != 2) goto LAB_001db15b;\n            bVar7 = 0x78;\n            iVar9 = iVar11;\n            if (bVar5) {\n              puVar3 = *ppuVar2 + 0x78;\n              uVar6 = 0x78;\n              bVar7 = 0x78;\n              goto LAB_001dacc4;\n            }\n          }\nLAB_001dacef:\n          pbVar14 = pbVar15;\n          if (bVar12) goto LAB_001dacf8;\n          goto LAB_001dac5e;\n        }\n        if (*(char *)(param_1 + 2 + lVar1) != '-') goto LAB_001dad92;\n        iVar9 = iVar9 + 2;\n        bVar12 = true;\n      }\n    }\n    iVar9 = iVar9 + 1;\n  } while( true );\n}\n\n",
  "rl_bind_key_if_unbound": "\nundefined8 rl_bind_key_if_unbound(undefined param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = rl_untranslate_keyseq(param_1);\n  if (lVar1 != 0) {\n    uVar2 = FUN_001dbd80(lVar1,param_2,_rl_keymap);\n    return uVar2;\n  }\n  return 0;\n}\n\n",
  "do_redirections": "\nint do_redirections(long *param_1,uint param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  long local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_2 & 2) != 0) {\n    if (redirection_undo_list != 0) {\n      dispose_redirects();\n      redirection_undo_list = 0;\n    }\n    if (exec_redirection_undo_list != 0) {\n      dispose_exec_redirects();\n    }\n  }\n  if (param_1 != (long *)0x0) {\n    do {\n      local_38 = 0;\n      iVar1 = FUN_0019c700(param_1,param_2,&local_38);\n      if (iVar1 != 0) {\n        redirection_error(param_1,iVar1,local_38);\n        if (local_38 != 0) {\n          sh_xfree(local_38,\"redir.c\",0x10b);\n        }\n        goto LAB_0019e11a;\n      }\n      if (local_38 != 0) {\n        sh_xfree(local_38,\"redir.c\",0x10e);\n      }\n      param_1 = (long *)*param_1;\n    } while (param_1 != (long *)0x0);\n  }\n  iVar1 = 0;\nLAB_0019e11a:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "assoc_to_word_list": "\nvoid assoc_to_word_list(undefined8 param_1)\n\n{\n  FUN_0018d590(param_1,0);\n  return;\n}\n\n",
  "quote_globbing_chars": "\nbyte * quote_globbing_chars(byte *param_1)\n\n{\n  mbstate_t mVar1;\n  size_t sVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  size_t sVar5;\n  size_t sVar6;\n  byte bVar7;\n  byte *__s;\n  byte *pbVar8;\n  byte *pbVar9;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar2 = strlen((char *)param_1);\n  pbVar3 = (byte *)sh_xmalloc(sVar2 * 2 + 1,\"pathexp.c\",0x187);\n  bVar7 = *param_1;\n  pbVar8 = pbVar3;\n  if (bVar7 != 0) {\n    __s = param_1;\n    do {\n      while( true ) {\n        mVar1 = local_48;\n        pbVar9 = pbVar8;\n        if (((byte)(bVar7 - 0x21) < 0x3d) &&\n           ((uVar4 = 1L << (bVar7 - 0x21 & 0x3f), (uVar4 & 0x1c00000040000200) != 0 ||\n            (((uVar4 & 0x80000401) != 0 && (__s[1] == 0x28)))))) {\n          *pbVar8 = 0x5c;\n          pbVar9 = pbVar8 + 1;\n        }\n        bVar7 = *__s;\n        pbVar8 = pbVar9 + 1;\n        if (locale_mb_cur_max < 2) break;\n        if (((*(uint *)(is_basic_table + (ulong)(bVar7 >> 5) * 4) >> (bVar7 & 0x1f) & 1) == 0) &&\n           ((locale_utf8locale == 0 || ((char)bVar7 < '\\0')))) {\n          sVar5 = mbrtowc((wchar_t *)0x0,(char *)__s,(size_t)(param_1 + (sVar2 - (long)__s)),\n                          &local_48);\n          if (0xfffffffffffffffd < sVar5) {\n            *pbVar9 = *__s;\n            goto LAB_00184f99;\n          }\n          sVar6 = 1;\n          if (sVar5 != 0) {\n            sVar6 = sVar5;\n          }\n          sVar5 = 0;\n          bVar7 = *__s;\n          while( true ) {\n            pbVar9[sVar5] = bVar7;\n            sVar5 = sVar5 + 1;\n            if (sVar5 == sVar6) break;\n            bVar7 = __s[sVar5];\n          }\n        }\n        else {\n          *pbVar9 = bVar7;\n          sVar6 = 1;\n        }\n        pbVar8 = pbVar9 + sVar6;\n        bVar7 = __s[sVar6];\n        __s = __s + sVar6;\n        if (bVar7 == 0) goto LAB_00185010;\n      }\n      *pbVar9 = bVar7;\nLAB_00184f99:\n      bVar7 = __s[1];\n      __s = __s + 1;\n      local_48 = mVar1;\n    } while (bVar7 != 0);\n  }\nLAB_00185010:\n  *pbVar8 = 0;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pbVar3;\n}\n\n",
  "fmtulong": "\nchar * fmtulong(ulong param_1,uint param_2,char *param_3,long param_4,uint param_5)\n\n{\n  undefined auVar1 [16];\n  undefined auVar2 [16];\n  byte bVar3;\n  uint uVar4;\n  int *piVar5;\n  ulong uVar6;\n  char cVar7;\n  ulong uVar8;\n  char *pcVar9;\n  char *pcVar10;\n  int iVar11;\n  \n  if (param_2 == 0) {\n    if ((param_5 & 8) == 0) {\n      if ((long)param_1 < 0) {\n        param_3 = param_3 + param_4 + -2;\n        param_1 = -param_1;\n        iVar11 = 0x2d;\n        param_3[1] = '\\0';\n      }\n      else {\n        param_3 = param_3 + param_4 + -2;\n        param_3[1] = '\\0';\n        iVar11 = 0;\n      }\n    }\n    else {\n      param_3 = param_3 + param_4 + -2;\n      iVar11 = 0;\n      param_3[1] = '\\0';\n    }\nLAB_001ca6c0:\n    pcVar9 = param_3 + -1;\n    cVar7 = (char)param_1;\n    if (param_1 < 10) {\n      *param_3 = cVar7 + '0';\n    }\n    else {\n      if ((long)param_1 < 0) {\n        pcVar9 = param_3 + -2;\n        param_1 = param_1 / 10;\n        *param_3 = cVar7 + (char)param_1 * -10 + '0';\n      }\n      while( true ) {\n        uVar6 = param_1 / 10;\n        pcVar9[1] = (char)param_1 + (char)uVar6 * -10 + '0';\n        if (uVar6 == 0) break;\n        pcVar9 = pcVar9 + -1;\n        param_1 = uVar6;\n      }\n    }\n    goto LAB_001ca688;\n  }\n  if (0x3e < param_2 - 2) {\n    strncpy(param_3,\"invalid base\",param_4 - 1);\n    param_3[param_4 + -1] = '\\0';\n    piVar5 = __errno_location();\n    *piVar5 = 0x16;\n    return param_3;\n  }\n  if ((param_5 & 8) == 0) {\n    iVar11 = 0;\n    if ((long)param_1 < 0) {\n      param_1 = -param_1;\n      iVar11 = 0x2d;\n    }\n  }\n  else {\n    iVar11 = 0;\n  }\n  param_3 = param_3 + param_4 + -2;\n  param_3[1] = '\\0';\n  if (param_2 == 8) {\n    do {\n      pcVar9 = param_3 + -1;\n      cVar7 = ((byte)param_1 & 7) + 0x30;\n      param_1 = param_1 >> 3;\n      *param_3 = cVar7;\n      param_3 = pcVar9;\n    } while (param_1 != 0);\n    if ((param_5 & 1) != 0) goto LAB_001ca678;\n  }\n  else {\n    if (8 < (int)param_2) {\n      if (param_2 != 10) {\n        if (param_2 != 0x10) goto LAB_001ca870;\n        do {\n          while (pcVar10 = param_3, uVar4 = (uint)param_1 & 0xf, (param_5 & 4) == 0) {\n            param_1 = param_1 >> 4;\n            *pcVar10 = \"0123456789abcdef\"[uVar4];\n            param_3 = pcVar10 + -1;\n            if (param_1 == 0) goto LAB_001ca7cf;\n          }\n          param_1 = param_1 >> 4;\n          *pcVar10 = \"0123456789ABCDEF\"[uVar4];\n          param_3 = pcVar10 + -1;\n        } while (param_1 != 0);\nLAB_001ca7cf:\n        pcVar9 = pcVar10 + -1;\n        if ((param_5 & 1) == 0) {\n          if ((param_5 & 2) == 0) goto LAB_001ca688;\n          *pcVar9 = '#';\n          pcVar10[-2] = '6';\n          pcVar10 = pcVar9;\n          goto LAB_001ca961;\n        }\n        goto LAB_001ca8d8;\n      }\n      goto LAB_001ca6c0;\n    }\n    if (param_2 != 2) {\nLAB_001ca870:\n      uVar6 = (ulong)(int)param_2;\n      do {\n        auVar1._8_8_ = 0;\n        auVar1._0_8_ = uVar6;\n        auVar2._8_8_ = 0;\n        auVar2._0_8_ = param_1;\n        uVar8 = SUB168(auVar2 % auVar1,0);\n        cVar7 = SUB161(auVar2 % auVar1,0);\n        if (uVar8 < 10) {\n          cVar7 = cVar7 + '0';\nLAB_001ca883:\n          *param_3 = cVar7;\n        }\n        else {\n          if (0x23 < uVar8) {\n            if (uVar8 < 0x3e) {\n              cVar7 = cVar7 + '\\x1d';\n            }\n            else {\n              cVar7 = '_';\n              if (uVar8 == 0x3e) {\n                cVar7 = '@';\n              }\n            }\n            goto LAB_001ca883;\n          }\n          cVar7 = cVar7 + 'W';\n          *param_3 = cVar7;\n        }\n        if (param_1 < uVar6) goto LAB_001ca8b7;\n        param_3 = param_3 + -1;\n        param_1 = param_1 / uVar6;\n      } while( true );\n    }\n    do {\n      pcVar9 = param_3 + -1;\n      bVar3 = (byte)param_1;\n      param_1 = param_1 >> 1;\n      *param_3 = (bVar3 & 1) + 0x30;\n      param_3 = pcVar9;\n    } while (param_1 != 0);\n  }\n  if ((param_5 >> 1 & 1) == 0) goto LAB_001ca688;\n  *pcVar9 = '#';\n  pcVar9[-1] = (char)param_2 + (char)(param_2 / 10) * -10 + '0';\n  goto LAB_001ca761;\nLAB_001ca8b7:\n  pcVar9 = param_3 + -1;\n  if (((param_5 & 1) != 0) && ((param_2 - 8 & 0xfffffff7) == 0)) {\n    if (param_2 == 0x10) {\nLAB_001ca8d8:\n      pcVar9[-1] = '0';\n      *pcVar9 = (-((param_5 & 4) == 0) & 0x20U) + 0x58;\n      pcVar9 = pcVar9 + -2;\n      goto LAB_001ca688;\n    }\nLAB_001ca678:\n    if (cVar7 != '0') {\n      *pcVar9 = '0';\n      pcVar9 = pcVar9 + -1;\n    }\n    goto LAB_001ca688;\n  }\n  if (((byte)(param_5 >> 1) & param_2 != 10) == 0) goto LAB_001ca688;\n  *pcVar9 = '#';\n  param_3[-2] = (char)param_2 + (char)(param_2 / 10) * -10 + '0';\n  pcVar10 = pcVar9;\n  if (10 < (int)param_2) {\nLAB_001ca961:\n    pcVar9 = pcVar10 + -3;\n    pcVar10[-2] = (char)((ulong)param_2 / 10) + '0';\n    goto LAB_001ca688;\n  }\nLAB_001ca761:\n  pcVar9 = pcVar9 + -2;\nLAB_001ca688:\n  if (iVar11 == 0) {\n    return pcVar9 + 1;\n  }\n  *pcVar9 = '-';\n  return pcVar9;\n}\n\n",
  "FUN_001f6220": "\nint FUN_001f6220(char *param_1,uint param_2,ulong param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  size_t sVar7;\n  char *pcVar8;\n  uint uVar9;\n  long local_48;\n  size_t sVar6;\n  \n  uVar9 = history_offset;\n  if (param_1 == (char *)0x0) {\n    return -1;\n  }\n  if (*param_1 == '\\0') {\n    return -1;\n  }\n  if (history_length == 0) {\n    return -1;\n  }\n  if ((int)history_offset < (int)history_length) {\n    if (-1 < (int)param_2) {\n      local_48 = history_list();\n      sVar6 = strlen(param_1);\n      iVar1 = (int)sVar6;\n      goto LAB_001f6293;\n    }\n  }\n  else {\n    if (-1 < (int)param_2) {\n      return -1;\n    }\n    uVar9 = history_length - 1;\n  }\n  local_48 = history_list();\n  sVar6 = strlen(param_1);\n  iVar1 = (int)sVar6;\n  if ((int)(param_2 & uVar9) < 0) {\n    return -1;\n  }\nLAB_001f6293:\n  iVar2 = 1;\n  if ((param_3 & 2) == 0) {\n    iVar2 = iVar1;\n  }\n  sVar6 = (size_t)iVar1;\n  do {\n    while (-1 < (int)param_2) {\n      if (history_length == uVar9) {\n        return -1;\n      }\n      pcVar8 = **(char ***)(local_48 + (long)(int)uVar9 * 8);\n      sVar7 = strlen(pcVar8);\n      if (((param_3 & 2) != 0) || (iVar1 <= (int)sVar7)) {\n        if ((param_3 & 1) != 0) goto LAB_001f6336;\n        iVar3 = (int)sVar7 - iVar1;\n        if (-1 < iVar3) {\n          iVar5 = 0;\n          do {\n            if ((param_3 & 2) == 0) {\n              if (iVar1 == 0) {\n                history_offset = uVar9;\n                return iVar5;\n              }\n              if (*param_1 == *pcVar8) {\n                iVar4 = strncmp(param_1,pcVar8,sVar6);\n                goto joined_r0x001f6442;\n              }\n            }\n            else {\n              iVar4 = fnmatch(param_1,pcVar8,0);\njoined_r0x001f6442:\n              if (iVar4 == 0) {\n                history_offset = uVar9;\n                return iVar5;\n              }\n            }\n            iVar5 = iVar5 + 1;\n            pcVar8 = pcVar8 + 1;\n          } while (iVar5 <= iVar3);\n        }\n      }\nLAB_001f62f2:\n      uVar9 = uVar9 + 1;\n    }\n    pcVar8 = **(char ***)(local_48 + (long)(int)uVar9 * 8);\n    sVar7 = strlen(pcVar8);\n    if (((param_3 & 2) != 0) || (iVar1 <= (int)sVar7)) {\n      if ((param_3 & 1) == 0) {\n        iVar3 = (int)sVar7 - iVar2;\n        if (-1 < iVar3) {\n          pcVar8 = pcVar8 + iVar3;\n          do {\n            if ((param_3 & 2) == 0) {\n              if (iVar1 == 0) {\n                history_offset = uVar9;\n                return iVar3;\n              }\n              if (*param_1 == *pcVar8) {\n                iVar5 = strncmp(param_1,pcVar8,sVar6);\n                goto joined_r0x001f64f2;\n              }\n            }\n            else {\n              iVar5 = fnmatch(param_1,pcVar8,0);\njoined_r0x001f64f2:\n              if (iVar5 == 0) {\n                history_offset = uVar9;\n                return iVar3;\n              }\n            }\n            iVar3 = iVar3 + -1;\n            pcVar8 = pcVar8 + -1;\n          } while (iVar3 != -1);\n        }\n      }\n      else {\nLAB_001f6336:\n        if ((param_3 & 2) == 0) {\n          if ((iVar1 == 0) ||\n             ((*param_1 == *pcVar8 && (iVar3 = strncmp(param_1,pcVar8,sVar6), iVar3 == 0)))) {\n            history_offset = uVar9;\n            return 0;\n          }\n        }\n        else {\n          iVar3 = fnmatch(param_1,pcVar8,0);\n          if (iVar3 == 0) {\n            history_offset = uVar9;\n            return 0;\n          }\n        }\n        if (-1 < (int)param_2) goto LAB_001f62f2;\n      }\n    }\n    uVar9 = uVar9 - 1;\n    if ((int)(param_2 & uVar9) < 0) {\n      return -1;\n    }\n  } while( true );\n}\n\n",
  "rl_function_of_keyseq_len": "\nvoid rl_function_of_keyseq_len(void)\n\n{\n  FUN_001da1c0();\n  return;\n}\n\n",
  "rl_vi_set_mark": "\nbool rl_vi_set_mark(void)\n\n{\n  int iVar1;\n  uint uVar2;\n  \n  if ((rl_readline_state & 0x80000) != 0) {\n    _rl_callback_data = 0;\n    _rl_callback_func = FUN_001cff10;\n    return false;\n  }\n  rl_readline_state = rl_readline_state | 0x40;\n  iVar1 = rl_read_key();\n  rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n  uVar2 = iVar1 - 0x61;\n  if (0x19 < uVar2) {\n    rl_ding();\n  }\n  else {\n    *(undefined4 *)(&DAT_0024a360 + (long)(int)uVar2 * 4) = rl_point;\n  }\n  return 0x19 < uVar2;\n}\n\n",
  "history_set_history_state": "\nvoid history_set_history_state(undefined8 *param_1)\n\n{\n  DAT_0024b6e8 = *param_1;\n  history_offset = *(undefined4 *)(param_1 + 1);\n  history_length = *(undefined4 *)((long)param_1 + 0xc);\n  DAT_0024b6e0 = *(undefined4 *)(param_1 + 2);\n  if ((*(byte *)((long)param_1 + 0x14) & 1) != 0) {\n    DAT_0024b6e4 = 1;\n  }\n  return;\n}\n\n",
  "fnx_fromfs": "\nundefined8 fnx_fromfs(undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
  "rl_yank_last_arg": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid rl_yank_last_arg(int param_1,ulong param_2)\n\n{\n  int iVar1;\n  \n  if (rl_last_func == rl_yank_last_arg) {\n    if (DAT_0024b148 != 0) {\n      rl_do_undo();\n      param_2 = param_2 & 0xffffffff;\n    }\n    if (param_1 < 0) {\n      DAT_00240530 = -DAT_00240530;\n    }\n    _DAT_0024b150 = DAT_00240530 + _DAT_0024b150;\n    if (_DAT_0024b150 < 0) {\n      _DAT_0024b150 = 0;\n    }\n  }\n  else {\n    _DAT_0024b150 = 0;\n    DAT_0024b14c = rl_explicit_arg;\n    DAT_00240530 = 1;\n    DAT_00240534 = param_1;\n  }\n  if (DAT_0024b14c == 0) {\n    iVar1 = FUN_001e9190(0x24,param_2,_DAT_0024b150);\n  }\n  else {\n    iVar1 = FUN_001e9190(DAT_00240534,param_2,_DAT_0024b150);\n  }\n  DAT_0024b148 = (uint)(iVar1 == 0);\n  return;\n}\n\n",
  "FUN_00148690": "\nundefined8 FUN_00148690(long *param_1,undefined4 *param_2)\n\n{\n  char *__src;\n  uint uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  long lVar5;\n  size_t sVar6;\n  char *__dest;\n  \n  if (*param_1 == 0) {\n    uVar3 = *(undefined8 *)param_1[1];\n  }\n  else {\n    uVar3 = string_list();\n  }\n  uVar4 = expand_arith_string(uVar3,0x101);\n  if (*param_1 != 0) {\n    sh_xfree(uVar3,\"execute_cmd.c\",0xbeb);\n  }\n  uVar3 = make_word(uVar4);\n  lVar5 = make_word_list(uVar3,0);\n  sh_xfree(uVar4,\"execute_cmd.c\",0xbed);\n  if (lVar5 != 0) {\n    if (echo_command_at_execute != 0) {\n      xtrace_print_arith_cmd(lVar5);\n    }\n    command_string_index = 0;\n    print_arith_command(lVar5);\n    uVar1 = signal_in_progress(0x41);\n    if ((uVar1 | running_trap) == 0) {\n      if (the_printed_command_except_trap != (char *)0x0) {\n        sh_xfree(the_printed_command_except_trap,\"execute_cmd.c\",0xbf8);\n      }\n      __src = the_printed_command;\n      sVar6 = strlen(the_printed_command);\n      __dest = (char *)sh_xmalloc(sVar6 + 1,\"execute_cmd.c\",0xbf9);\n      the_printed_command_except_trap = strcpy(__dest,__src);\n    }\n    iVar2 = run_debug_trap();\n    this_command_name = &DAT_001fc775;\n    if ((debugging_mode == 0) || (iVar2 == 0)) {\n      uVar3 = evalexp(**(undefined8 **)(lVar5 + 8),shell_compatibility_level < 0x34,param_2);\n    }\n    else {\n      *param_2 = 1;\n      uVar3 = 0;\n    }\n    dispose_words(lVar5);\n    return uVar3;\n  }\n  *param_2 = 1;\n  return 0;\n}\n\n",
  "remove_alias": "\nundefined4 remove_alias(undefined8 param_1)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  \n  if (aliases != 0) {\n    lVar2 = hash_remove(param_1,aliases,0);\n    if (lVar2 == 0) {\n      uVar1 = 0xffffffff;\n    }\n    else {\n      FUN_00187930(*(undefined8 *)(lVar2 + 0x10));\n      sh_xfree(*(undefined8 *)(lVar2 + 8),\"alias.c\",0xc0);\n      sh_xfree(lVar2,\"alias.c\",0xc1);\n      set_itemlist_dirty(it_aliases);\n      uVar1 = *(undefined4 *)(aliases + 0xc);\n    }\n    return uVar1;\n  }\n  return 0xffffffff;\n}\n\n",
  "FUN_0019f1a0": "\nundefined8 *\nFUN_0019f1a0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n            undefined4 param_5,undefined8 param_6,int param_7,uint *param_8)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined8 *puVar6;\n  uint uVar7;\n  long in_FS_OFFSET;\n  undefined local_148 [264];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  *param_8 = 0;\n  lVar4 = find_function();\n  if (lVar4 == 0) {\n    internal_error(\"completion: function `%s\\' not found\",param_1);\n    rl_ding();\n    rl_on_new_line();\n    puVar6 = (undefined8 *)0x0;\n  }\n  else {\n    FUN_0019ef10(param_4,param_5,param_6,param_7 + -1,0);\n    uVar5 = FUN_0019eac0(param_1,param_2,param_3,param_6,param_7);\n    save_parser_state(local_148);\n    begin_unwind_frame(\"gen-shell-function-matches\");\n    add_unwind_protect(restore_parser_state,local_148);\n    add_unwind_protect(dispose_words,uVar5);\n    add_unwind_protect(FUN_0019ea60,0);\n    iVar1 = execute_shell_function(lVar4,uVar5);\n    discard_unwind_frame(\"gen-shell-function-matches\");\n    restore_parser_state(local_148);\n    uVar7 = (uint)(iVar1 != 0x7f);\n    if (iVar1 == 0x7c) {\n      uVar7 = iVar1 != 0x7f | 0x200;\n    }\n    *param_8 = uVar7;\n    dispose_words(uVar5);\n    unbind_variable_noref(\"COMP_LINE\");\n    unbind_variable_noref(\"COMP_POINT\");\n    unbind_variable_noref(\"COMP_TYPE\");\n    unbind_variable_noref(\"COMP_KEY\");\n    unbind_variable_noref(\"COMP_WORDS\");\n    unbind_variable_noref(\"COMP_CWORD\");\n    puVar6 = (undefined8 *)find_variable(\"COMPREPLY\");\n    if (puVar6 != (undefined8 *)0x0) {\n      uVar2 = *(uint *)(puVar6 + 5);\n      if ((uVar2 & 0x44) == 0) {\n        puVar6 = (undefined8 *)convert_var_to_array(puVar6);\n        uVar2 = *(uint *)(puVar6 + 5);\n      }\n      *(uint *)(puVar6 + 5) = uVar2 & 0xffffefff;\n      if (uVar7 == 0) {\n        puVar6 = (undefined8 *)0x0;\n      }\n      else {\n        lVar4 = puVar6[1];\n        puVar6 = (undefined8 *)0x0;\n        if (((((uVar7 & 0x200) == 0) && (lVar4 != 0)) && ((uVar2 & 4) != 0)) &&\n           (puVar6 = (undefined8 *)0x0, *(long *)(lVar4 + 8) != 0)) {\n          puVar6 = (undefined8 *)strlist_create(0);\n          uVar5 = array_to_argv(lVar4,0);\n          *puVar6 = uVar5;\n          uVar3 = (undefined4)*(undefined8 *)(lVar4 + 8);\n          *(undefined4 *)(puVar6 + 1) = uVar3;\n          *(undefined4 *)((long)puVar6 + 0xc) = uVar3;\n        }\n      }\n      unbind_variable_noref(\"COMPREPLY\");\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar6;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_vi_first_print": "\nundefined8 rl_vi_first_print(void)\n\n{\n  char cVar1;\n  long lVar2;\n  long lVar3;\n  uint uVar4;\n  \n  rl_beg_of_line(1);\n  lVar3 = (long)rl_point;\n  if (rl_point < rl_end) {\n    uVar4 = (rl_end + -1) - rl_point;\n    lVar2 = (long)(rl_point + 1);\n    do {\n      cVar1 = *(char *)(rl_line_buffer + -1 + lVar2);\n      if ((cVar1 != ' ') && (cVar1 != '\\t')) {\n        return 0;\n      }\n      rl_point = (int)lVar2;\n      lVar2 = lVar2 + 1;\n    } while (lVar2 != (ulong)uVar4 + 2 + lVar3);\n  }\n  return 0;\n}\n\n",
  "sub_append_string": "\nlong sub_append_string(char *param_1,long param_2,long *param_3,long *param_4)\n\n{\n  size_t __n;\n  long lVar1;\n  \n  if (param_1 != (char *)0x0) {\n    __n = 0;\n    if (((*param_1 != '\\0') && (__n = 1, param_1[1] != '\\0')) && (__n = 2, param_1[2] != '\\0')) {\n      __n = strlen(param_1);\n    }\n    lVar1 = *param_3;\n    if ((ulong)(*param_4 - lVar1) <= __n) {\n      lVar1 = (lVar1 + __n & 0xffffffffffffff80) + 0x80;\n      *param_4 = lVar1;\n      param_2 = sh_xrealloc(param_2,lVar1,\"subst.c\",0x2f3);\n      lVar1 = *param_3;\n    }\n    memcpy((void *)(lVar1 + param_2),param_1,__n);\n    lVar1 = *param_3;\n    *param_3 = __n + lVar1;\n    *(undefined *)(param_2 + __n + lVar1) = 0;\n    sh_xfree(param_1,\"subst.c\",0x2fa);\n  }\n  return param_2;\n}\n\n",
  "set_login_shell": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 set_login_shell(void)\n\n{\n  _DAT_00248d68 = (uint)(login_shell != 0);\n  return 0;\n}\n\n",
  "dispose_exec_redirects": "\nvoid dispose_exec_redirects(void)\n\n{\n  if (exec_redirection_undo_list != 0) {\n    dispose_redirects();\n    exec_redirection_undo_list = 0;\n    return;\n  }\n  return;\n}\n\n",
  "get_variable_value": "\nundefined8 get_variable_value(long param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (param_1 == 0) {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = *(undefined8 *)(param_1 + 8);\n    if ((*(uint *)(param_1 + 0x28) & 4) != 0) {\n      uVar1 = array_reference(uVar1,0);\n      return uVar1;\n    }\n    if ((*(uint *)(param_1 + 0x28) & 0x40) != 0) {\n      uVar1 = assoc_reference(uVar1,&DAT_00210deb);\n      return uVar1;\n    }\n  }\n  return uVar1;\n}\n\n",
  "rl_next_screen_line": "\nvoid rl_next_screen_line(void)\n\n{\n  rl_forward_char(_rl_screenwidth + (uint)(_rl_term_autowrap == 0));\n  return;\n}\n\n",
  "rl_transpose_chars": "\nundefined8 rl_transpose_chars(int param_1)\n\n{\n  size_t sVar1;\n  undefined *puVar2;\n  long lVar3;\n  int iVar4;\n  undefined *puVar5;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  if ((rl_point != 0) && (1 < rl_end)) {\n    rl_begin_undo_group();\n    if (rl_point == rl_end) {\n      sVar1 = __ctype_get_mb_cur_max();\n      if ((sVar1 < 2) || (rl_byte_oriented != 0)) {\n        rl_point = rl_point + -1;\n      }\n      else {\n        rl_point = _rl_find_prev_mbchar(rl_line_buffer,rl_point,1);\n      }\n      param_1 = 1;\n    }\n    iVar4 = rl_point;\n    sVar1 = __ctype_get_mb_cur_max();\n    if ((sVar1 < 2) || (rl_byte_oriented != 0)) {\n      rl_point = rl_point + -1;\n    }\n    else {\n      rl_point = _rl_find_prev_mbchar(rl_line_buffer,rl_point,1);\n    }\n    iVar4 = iVar4 - rl_point;\n    puVar2 = (undefined *)xmalloc((long)(iVar4 + 1));\n    puVar5 = puVar2;\n    if (0 < iVar4) {\n      lVar3 = 0;\n      do {\n        puVar2[lVar3] = *(undefined *)(rl_line_buffer + (rl_point + (int)lVar3));\n        lVar3 = lVar3 + 1;\n      } while (iVar4 != lVar3);\n      puVar5 = puVar2 + iVar4;\n    }\n    *puVar5 = 0;\n    rl_delete_text(rl_point,rl_point + iVar4);\n    rl_point = _rl_find_next_mbchar(rl_line_buffer,rl_point,param_1,1);\n    if (rl_end < rl_point) {\n      rl_point = rl_end;\n    }\n    else if (rl_point < 0) {\n      rl_point = 0;\n    }\n    rl_insert_text(puVar2);\n    rl_end_undo_group();\n    xfree(puVar2);\n    return 0;\n  }\n  rl_ding();\n  return 1;\n}\n\n",
  "pwd_builtin": "\nundefined8 pwd_builtin(undefined8 param_1)\n\n{\n  bool bVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined8 uVar4;\n  char *__s;\n  \n  bVar1 = false;\n  DAT_00248a74 = no_symbolic_links;\n  reset_internal_getopt();\n  while (iVar2 = internal_getopt(param_1,&DAT_0020f22c), iVar2 != -1) {\n    if (iVar2 == 0x4c) {\n      DAT_00248a74 = 0;\n    }\n    else {\n      if (iVar2 != 0x50) {\n        if (iVar2 != -99) {\n          builtin_usage();\n          return 0x102;\n        }\n        builtin_help();\n        return 0x102;\n      }\n      DAT_00248a74 = 1;\n      bVar1 = true;\n    }\n  }\n  if (the_current_working_directory == (char *)0x0) {\n    __s = (char *)get_working_directory(&DAT_0020ed6c);\nLAB_001a364c:\n    if (the_current_working_directory == (char *)0x0) {\n      if ((posixly_correct == 0) || (iVar2 = same_file(\".\",0,0,0), iVar2 != 0)) goto LAB_001a3688;\n      if (__s != (char *)0x0) goto LAB_001a36ca;\nLAB_001a36ea:\n      if (the_current_working_directory != (char *)0x0) goto LAB_001a365d;\n    }\n    else {\n      if (__s != (char *)0x0) goto LAB_001a35ed;\nLAB_001a365d:\n      sh_xfree(the_current_working_directory,\"./cd.def\",0xbf);\n    }\n    the_current_working_directory = (char *)0x0;\n    __s = (char *)get_working_directory(&DAT_0020ed6c);\n  }\n  else {\n    __s = the_current_working_directory;\n    if (DAT_00248a74 != 0) {\n      __s = (char *)sh_physpath(the_current_working_directory,0);\n      goto LAB_001a364c;\n    }\nLAB_001a35ed:\n    if (posixly_correct == 0) goto LAB_001a35fb;\n    iVar2 = same_file(\".\",the_current_working_directory,0,0);\n    if (iVar2 == 0) {\nLAB_001a36ca:\n      if (the_current_working_directory != __s) {\n        sh_xfree(__s,\"./cd.def\",0x20b);\n        goto LAB_001a36ea;\n      }\n      goto LAB_001a365d;\n    }\n  }\nLAB_001a3688:\n  if (__s == (char *)0x0) {\n    return 1;\n  }\nLAB_001a35fb:\n  puts(__s);\n  if ((posixly_correct == 0) || (!bVar1)) {\n    uVar3 = 0;\n  }\n  else {\n    uVar3 = FUN_001a2c10(__s);\n  }\n  if (the_current_working_directory != __s) {\n    sh_xfree(__s,\"./cd.def\",0x219);\n  }\n  uVar4 = sh_chkwrite(uVar3);\n  return uVar4;\n}\n\n",
  "FUN_0014b010": "\nvoid FUN_0014b010(undefined8 param_1,undefined8 param_2,undefined *param_3,undefined8 param_4,\n                 uint param_5,uint param_6,int param_7,int *param_8,uint param_9)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *__dest;\n  char *pcVar3;\n  uint uVar4;\n  long lVar5;\n  int local_3c;\n  \n  uVar4 = 0;\n  if (param_3 == PTR_jobs_builtin_00237fa8) {\n    uVar4 = ~subshell_environment & 1 | (uint)(param_6 != 0xffffffff);\n  }\n  interactive = 0;\n  login_shell = 0;\n  if (param_3 == PTR_eval_builtin_00237f48) {\n    evalnest = 0;\n  }\n  else if (param_3 == PTR_source_builtin_00237f30) {\n    sourcenest = 0;\n  }\n  if (param_7 != 0) {\n    subshell_environment = subshell_environment | 1;\n  }\n  if ((param_6 & param_5) != 0xffffffff) {\n    subshell_environment = subshell_environment | 0x10;\n  }\n  maybe_make_export_env();\n  if (uVar4 == 0) {\n    without_job_control();\n  }\n  else {\n    kill_current_pipeline();\n  }\n  set_sigchld_handler();\n  set_sigint_handler();\n  if ((param_8 != (int *)0x0) && (0 < *param_8)) {\n    lVar5 = 0;\n    do {\n      if (*(char *)(*(long *)(param_8 + 2) + lVar5) != '\\0') {\n        close((int)lVar5);\n        *(undefined *)(*(long *)(param_8 + 2) + lVar5) = 0;\n      }\n      lVar5 = lVar5 + 1;\n    } while (*param_8 != (int)lVar5 && (int)lVar5 <= *param_8);\n  }\n  FUN_001497c0(param_5,param_6);\n  iVar1 = do_redirections(param_2,1);\n  if (iVar1 != 0) {\n                    /* WARNING: Subroutine does not return */\n    exit(1);\n  }\n  if (param_3 == (undefined *)0x0) {\n    iVar1 = FUN_0014f460(param_4,param_1,param_9,param_8,param_7,1);\n    fflush(stdout);\n    goto LAB_0014b1e9;\n  }\n  local_3c = __sigsetjmp(top_level,0);\n  if ((return_catch_flag != 0) && (param_3 == PTR_return_builtin_00237f60)) goto LAB_0014b1fa;\n  iVar1 = 0;\n  do {\n    if ((local_3c == 3) || (local_3c == 6)) {\nLAB_0014b1a4:\n      subshell_exit(last_command_exit_value);\nLAB_0014b1af:\n      iVar1 = FUN_00148110(param_3,param_1,param_9,1);\n      fflush(stdout);\n      pcVar3 = the_printed_command_except_trap;\n      if (iVar1 == 0x102) {\n        iVar1 = 2;\n      }\n      else if (iVar1 == 0x106) {\n        if (the_printed_command_except_trap == (char *)0x0) {\n          lVar5 = 1;\n          pcVar3 = \"\";\n        }\n        else {\n          sVar2 = strlen(the_printed_command_except_trap);\n          lVar5 = sVar2 + 1;\n        }\n        __dest = (char *)sh_xmalloc(lVar5,\"execute_cmd.c\",0x151c);\n        pcVar3 = strcpy(__dest,pcVar3);\n        iVar1 = FUN_0014ab30(param_1,0,pcVar3,0xffffffff,0xffffffff,param_7,0,param_9 | 0x40);\n      }\nLAB_0014b1e9:\n      subshell_exit(iVar1);\n    }\n    else if (local_3c == 0) {\n      if (iVar1 != 0) {\n        subshell_exit(return_catch_value);\n        goto LAB_0014b1a4;\n      }\n      goto LAB_0014b1af;\n    }\n    local_3c = subshell_exit(1);\nLAB_0014b1fa:\n    iVar1 = __sigsetjmp(return_catch,0);\n  } while( true );\n}\n\n",
  "FUN_00194150": "\nint FUN_00194150(int param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  \n  iVar1 = rl_point;\n  rl_point = iVar1;\n  if (param_1 != 0) {\n    FUN_00193990();\n    iVar2 = rl_point;\n    FUN_001936e0(1,param_2);\n    iVar3 = rl_point;\n    FUN_001936e0(param_1,param_2);\n    iVar4 = rl_point;\n    FUN_00193990(1,param_2);\n    iVar5 = rl_point;\n    if ((iVar3 == iVar4) || (iVar3 < rl_point)) {\n      rl_ding();\n      param_1 = 1;\n      rl_point = iVar1;\n    }\n    else {\n      uVar6 = rl_copy_text(iVar4,rl_point);\n      uVar7 = rl_copy_text(iVar3,iVar2);\n      rl_begin_undo_group();\n      rl_point = iVar3;\n      rl_delete_text(iVar3,iVar2);\n      rl_insert_text(uVar6);\n      rl_point = iVar4;\n      rl_delete_text(iVar4,iVar5);\n      rl_insert_text(uVar7);\n      rl_point = iVar2;\n      rl_end_undo_group();\n      sh_xfree(uVar6,\"bashline.c\",0x536);\n      sh_xfree(uVar7,\"bashline.c\",0x537);\n      param_1 = 0;\n    }\n  }\n  return param_1;\n}\n\n",
  "assoc_remove": "\nvoid assoc_remove(undefined8 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  \n  lVar1 = hash_remove(param_2,param_1,0);\n  if (lVar1 != 0) {\n    sh_xfree(*(undefined8 *)(lVar1 + 0x10),\"assoc.c\",0x7b);\n    sh_xfree(*(undefined8 *)(lVar1 + 8),\"assoc.c\",0x7c);\n    sh_xfree(lVar1,\"assoc.c\",0x7d);\n    return;\n  }\n  return;\n}\n\n",
  "phash_flush": "\nvoid phash_flush(void)\n\n{\n  if (hashed_filenames != 0) {\n    hash_flush(hashed_filenames,FUN_0017f770);\n    return;\n  }\n  return;\n}\n\n",
  "init_mail_dates": "\nvoid init_mail_dates(void)\n\n{\n  if (DAT_002478b8 != 0) {\n    return;\n  }\n  remember_mail_dates();\n  return;\n}\n\n",
  "polite_directory_format": "\nchar * polite_directory_format(char *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  char *__s;\n  size_t sVar4;\n  \n  __s = (char *)get_string_value(&DAT_001faa94);\n  if (__s != (char *)0x0) {\n    sVar4 = strlen(__s);\n    iVar2 = (int)sVar4;\n    if (1 < iVar2) {\n      iVar3 = strncmp(__s,param_1,(long)iVar2);\n      if (iVar3 == 0) {\n        cVar1 = param_1[iVar2];\n        if ((cVar1 == '\\0') || (cVar1 == '/')) {\n          strncpy(&DAT_00240ea1,param_1 + iVar2,0xffe);\n          DAT_00240ea0 = 0x7e;\n          DAT_00241e9f = 0;\n          return &DAT_00240ea0;\n        }\n      }\n    }\n  }\n  return param_1;\n}\n\n",
  "FUN_001d8aa0": "\nvoid FUN_001d8aa0(undefined8 *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 uVar4;\n  long lVar5;\n  int iVar6;\n  \n  iVar6 = 0;\n  _rl_move_vert(_rl_vis_botlin);\n  lVar3 = param_1[1];\n  lVar5 = 2;\n  if (lVar3 == 0) {\n    uVar4 = *param_1;\n    if (rl_filename_completion_desired != 0) {\n      uVar4 = FUN_001d6140(uVar4);\n    }\n    rl_crlf();\n    FUN_001d7970(uVar4,*param_1,0);\n    rl_crlf();\n    rl_forced_update_display();\n    rl_display_fixed = 1;\n    return;\n  }\n  do {\n    if (rl_filename_completion_desired != 0) {\n      lVar3 = FUN_001d6140();\n    }\n    iVar1 = FUN_001d7840(lVar3);\n    if (iVar6 < iVar1) {\n      iVar6 = iVar1;\n    }\n    iVar1 = (int)lVar5;\n    lVar3 = param_1[lVar5];\n    lVar5 = lVar5 + 1;\n  } while (lVar3 != 0);\n  iVar1 = iVar1 + -1;\n  if (rl_completion_display_matches_hook == (code *)0x0) {\n    if ((0 < rl_completion_query_items) && (rl_completion_query_items <= iVar1)) {\n      rl_crlf();\n      __fprintf_chk(rl_outstream,1,\"Display all %d possibilities? (y or n)\",iVar1);\n      fflush(rl_outstream);\n      if (((rl_readline_state._2_1_ & 8) == 0) && (iVar2 = FUN_001d6fc0(0), iVar2 == 0)) {\n        rl_crlf();\n        rl_forced_update_display();\n        rl_display_fixed = 1;\n        return;\n      }\n    }\n    rl_display_match_list(param_1,iVar1,iVar6);\n    rl_forced_update_display();\n    rl_display_fixed = 1;\n    return;\n  }\n                    /* WARNING: Could not recover jumptable at 0x001d8b21. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*rl_completion_display_matches_hook)(param_1,iVar1,iVar6);\n  return;\n}\n\n",
  "FUN_0015e790": "\nulong FUN_0015e790(int param_1,int param_2)\n\n{\n  long lVar1;\n  ulong uVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  sigset_t sStack_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_138);\n  sigaddset(&sStack_138,0x11);\n  sigemptyset(&local_b8);\n  sigprocmask(0,&sStack_138,&local_b8);\n  if (-1 < param_1 + -1) {\n    uVar2 = (ulong)(param_1 + -1);\n    do {\n      lVar1 = *(long *)(jobs + uVar2 * 8);\n      uVar3 = uVar2 & 0xffffffff;\n      if ((lVar1 != 0) && (*(int *)(lVar1 + 0x14) == param_2)) goto LAB_0015e81f;\n      uVar2 = uVar2 - 1;\n    } while (-1 < (int)uVar2);\n  }\n  uVar3 = 0xffffffff;\nLAB_0015e81f:\n  sigprocmask(2,&local_b8,(sigset_t *)0x0);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "assoc_dequote_escapes": "\nlong * assoc_dequote_escapes(long *param_1)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long lVar3;\n  \n  if (param_1 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  if (*(int *)((long)param_1 + 0xc) == 0) {\n    return (long *)0x0;\n  }\n  lVar3 = 0;\n  if (0 < *(int *)(param_1 + 1)) {\n    do {\n      for (puVar1 = *(undefined8 **)(*param_1 + lVar3 * 8); puVar1 != (undefined8 *)0x0;\n          puVar1 = (undefined8 *)*puVar1) {\n        uVar2 = dequote_escapes(puVar1[2]);\n        if (puVar1[2] != 0) {\n          sh_xfree(puVar1[2],\"assoc.c\",0xe4);\n        }\n        puVar1[2] = uVar2;\n      }\n      lVar3 = lVar3 + 1;\n    } while (*(int *)(param_1 + 1) != (int)lVar3 && (int)lVar3 <= *(int *)(param_1 + 1));\n  }\n  return param_1;\n}\n\n",
  "procsub_clear": "\nvoid procsub_clear(void)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  long in_FS_OFFSET;\n  sigset_t sStack_138;\n  sigset_t local_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_138);\n  sigaddset(&sStack_138,0x11);\n  sigemptyset(&local_b8);\n  sigprocmask(0,&sStack_138,&local_b8);\n  puVar2 = procsubs;\n  while (puVar2 != (undefined8 *)0x0) {\n    puVar1 = (undefined8 *)*puVar2;\n    if (puVar2[3] != 0) {\n      sh_xfree(puVar2[3],\"jobs.c\",0x3ea);\n    }\n    sh_xfree(puVar2,\"jobs.c\",0x3eb);\n    puVar2 = puVar1;\n  }\n  DAT_00242518 = 0;\n  procsubs = (undefined8 *)0x0;\n  DAT_00242520 = 0;\n  sigprocmask(2,&local_b8,(sigset_t *)0x0);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "signal_is_special": "\nuint signal_is_special(int param_1)\n\n{\n  return (&DAT_00247e40)[param_1] & 4;\n}\n\n",
  "print_array_assignment": "\nvoid print_array_assignment(undefined8 *param_1,int param_2)\n\n{\n  long lVar1;\n  undefined *puVar2;\n  \n  lVar1 = array_to_assign(param_1[1]);\n  if (lVar1 != 0) {\n    __printf_chk(1,\"%s=%s\\n\",*param_1,lVar1);\n    sh_xfree(lVar1,\"arrayfunc.c\",0x4c9);\n    return;\n  }\n  puVar2 = &DAT_001ff15d;\n  if (param_2 == 0) {\n    puVar2 = &DAT_001ff146;\n  }\n  __printf_chk(1,\"%s=%s\\n\",*param_1,puVar2);\n  return;\n}\n\n",
  "_rl_nchars_available": "\nundefined4 _rl_nchars_available(void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  undefined4 local_24;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_24 = 0;\n  iVar1 = fileno(rl_instream);\n  piVar3 = __errno_location();\n  *piVar3 = 0;\n  iVar1 = ioctl(iVar1,0x541b,&local_24);\n  uVar2 = local_24;\n  if ((iVar1 == -1) && (*piVar3 == 5)) {\n    uVar2 = 0xffffffff;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
  "rl_universal_argument": "\nundefined8 rl_universal_argument(void)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  \n  rl_save_prompt();\n  uVar1 = rl_readline_state;\n  _rl_argcxt = 0;\n  rl_numeric_arg = rl_numeric_arg << 2;\n  rl_readline_state = rl_readline_state | 0x400;\n  if ((uVar1 & 0x80000) != 0) {\n    return 0;\n  }\n  uVar2 = FUN_001f0a70();\n  return uVar2;\n}\n\n",
  "should_suppress_fork": "\nbool should_suppress_fork(undefined8 param_1)\n\n{\n  uint uVar1;\n  int iVar2;\n  \n  uVar1 = subshell_environment;\n  if ((((startup_state == 2) && (parse_and_execute_level == 1)) && (*DAT_00240a70 == '\\0')) &&\n     (iVar2 = parser_expanding_alias(), iVar2 == 0)) {\n    iVar2 = should_optimize_fork(param_1,uVar1 & 0x20);\n    return iVar2 != 0;\n  }\n  return false;\n}\n\n",
  "FUN_001565c0": "\nvoid FUN_001565c0(char **param_1)\n\n{\n  char cVar1;\n  long lVar2;\n  int iVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char *pcVar6;\n  undefined **ppuVar7;\n  long lVar8;\n  \n  if ((*(uint *)(param_1 + 5) & 0x300000) == 0x300000) {\n    FUN_00156420();\n    return;\n  }\n  pcVar6 = *param_1;\n  if (PTR_s_BASH_COMPAT_00238460 != (undefined *)0x0) {\n    cVar1 = *pcVar6;\n    ppuVar7 = &PTR_s_BASH_XTRACEFD_00238470;\n    pcVar5 = PTR_s_BASH_COMPAT_00238460;\n    do {\n      iVar3 = (int)*pcVar5 - (int)cVar1;\n      if (iVar3 == 0) {\n        iVar3 = strcmp(pcVar5,pcVar6);\n        if (iVar3 == 0) {\n          sVar4 = strlen(pcVar6);\n          pcVar5 = (char *)sh_xmalloc(sVar4 + 1,\"variables.c\",0x1239);\n          lVar2 = tempvar_list;\n          lVar8 = (long)tvlist_ind;\n          tvlist_ind = tvlist_ind + 1;\n          pcVar6 = strcpy(pcVar5,pcVar6);\n          *(char **)(lVar2 + lVar8 * 8) = pcVar6;\n          break;\n        }\n      }\n      if (0 < iVar3) break;\n      pcVar5 = *ppuVar7;\n      ppuVar7 = ppuVar7 + 2;\n    } while (pcVar5 != (char *)0x0);\n  }\n  dispose_variable(param_1);\n  return;\n}\n\n",
  "history_is_stifled": "\nundefined4 history_is_stifled(void)\n\n{\n  return DAT_0024b6e4;\n}\n\n",
  "restore_pgrp_pipe": "\nvoid restore_pgrp_pipe(undefined4 *param_1)\n\n{\n  pgrp_pipe = *param_1;\n  DAT_0023873c = param_1[1];\n  return;\n}\n\n",
  "ttfd_cbreak": "\nvoid ttfd_cbreak(int param_1,termios *param_2)\n\n{\n  param_2->c_iflag = param_2->c_iflag & 0xffffffbf | 0x100;\n  param_2->c_oflag = param_2->c_oflag & 0xffffffc7 | 5;\n  *(undefined2 *)(param_2->c_cc + 5) = 0x100;\n  param_2->c_lflag = param_2->c_lflag & 0xffffff95 | 0x8001;\n  tcsetattr(param_1,1,param_2);\n  return;\n}\n\n",
  "set_sigchld_handler": "\nvoid set_sigchld_handler(void)\n\n{\n  set_signal_handler(0x11,FUN_00162660);\n  return;\n}\n\n",
  "init_yy_io": "\nvoid init_yy_io(undefined8 param_1,undefined8 param_2,undefined4 param_3,char *param_4,\n               undefined8 param_5)\n\n{\n  size_t sVar1;\n  char *__dest;\n  \n  bash_input = param_3;\n  if (DAT_00240a68 != (char *)0x0) {\n    sh_xfree(DAT_00240a68,\"/usr/local/src/chet/src/bash/src/parse.y\",0x59f);\n  }\n  if (param_4 != (char *)0x0) {\n    sVar1 = strlen(param_4);\n    __dest = (char *)sh_xmalloc(sVar1 + 1,\"/usr/local/src/chet/src/bash/src/parse.y\",0x5a0);\n    param_4 = strcpy(__dest,param_4);\n  }\n  DAT_00240a68 = param_4;\n  DAT_00240a70 = param_5;\n  DAT_00240a78 = param_1;\n  DAT_00240a80 = param_2;\n  return;\n}\n\n",
  "list_rest_of_args": "\nlong * list_rest_of_args(void)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  long *plVar3;\n  long *plVar4;\n  \n  plVar3 = (long *)0x0;\n  plVar4 = &DAT_00242228;\n  do {\n    puVar1 = rest_of_args;\n    if (*plVar4 == 0) break;\n    uVar2 = make_bare_word();\n    plVar4 = plVar4 + 1;\n    plVar3 = (long *)make_word_list(uVar2,plVar3);\n    puVar1 = rest_of_args;\n  } while (plVar4 != (long *)&tempenv_assign_error);\n  for (; puVar1 != (undefined8 *)0x0; puVar1 = (undefined8 *)*puVar1) {\n    uVar2 = make_bare_word(*(undefined8 *)puVar1[1]);\n    plVar3 = (long *)make_word_list(uVar2,plVar3);\n  }\n  if ((plVar3 != (long *)0x0) && (*plVar3 != 0)) {\n    plVar3 = (long *)list_reverse(plVar3);\n    return plVar3;\n  }\n  return plVar3;\n}\n\n",
  "tzset": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid tzset(void)\n\n{\n  (*(code *)PTR_tzset_00237b80)();\n  return;\n}\n\n",
  "rl_end_undo_group": "\nundefined8 rl_end_undo_group(void)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)xmalloc(0x20);\n  puVar1[1] = 0;\n  *puVar1 = rl_undo_list;\n  puVar1[2] = 0;\n  *(undefined4 *)(puVar1 + 3) = 3;\n  rl_undo_list = puVar1;\n  _rl_undo_group_level = _rl_undo_group_level + -1;\n  return 0;\n}\n\n",
  "array_expand_index": "\nundefined8 array_expand_index(undefined8 param_1,char *param_2,int param_3)\n\n{\n  undefined8 uVar1;\n  char *__dest;\n  char *pcVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  int local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  __dest = (char *)sh_xmalloc((long)param_3,\"arrayfunc.c\",0x545);\n  strncpy(__dest,param_2,(long)(param_3 + -1));\n  __dest[(long)param_3 + -1] = '\\0';\n  pcVar2 = (char *)expand_arith_string(__dest,0x301);\n  uVar1 = this_command_name;\n  this_command_name = 0;\n  uVar3 = evalexp(pcVar2,shell_compatibility_level < 0x34,&local_34);\n  this_command_name = uVar1;\n  if (__dest != pcVar2) {\n    sh_xfree(pcVar2,\"arrayfunc.c\",0x556);\n  }\n  sh_xfree(__dest,\"arrayfunc.c\",0x557);\n  if (local_34 == 0) {\n    set_exit_status(1);\n    if (no_longjmp_on_fatal_error == 0) {\n      top_level_cleanup();\n                    /* WARNING: Subroutine does not return */\n      jump_to_top_level(2);\n    }\n    uVar3 = 0;\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "localeconv": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nlconv * localeconv(void)\n\n{\n  lconv *plVar1;\n  \n  plVar1 = (lconv *)(*(code *)PTR_localeconv_00237918)();\n  return plVar1;\n}\n\n",
  "FUN_001cec90": "\nulong FUN_001cec90(uint param_1,long param_2,ulong param_3,int param_4)\n\n{\n  undefined uVar1;\n  undefined *puVar2;\n  undefined8 uVar3;\n  long lVar4;\n  ulong uVar5;\n  ushort **ppuVar6;\n  __int32_t **pp_Var7;\n  undefined *puVar8;\n  \n  lVar4 = _rl_dispatching_keymap;\n  if (param_1 != 0xfffffffe) {\n    uVar5 = (ulong)param_1;\n    if ((int)param_1 < 0) {\n      if (*(long *)(param_2 + 0x1008) == 0) {\n        if (param_4 != 0) {\n          if ((rl_readline_state._1_1_ & 8) == 0) {\n            _rl_unget_char(param_3 & 0xffffffff);\n          }\n          else {\n            _rl_prev_macro_key();\n          }\n          if (0 < rl_key_sequence_length) {\n            rl_key_sequence_length = rl_key_sequence_length + -1;\n            *(undefined *)(rl_executing_keyseq + rl_key_sequence_length) = 0;\n          }\n          uVar5 = 0xffffffff;\n          _rl_dispatching_keymap = param_2;\n        }\n      }\n      else {\n        if ((rl_readline_state._1_1_ & 8) == 0) {\n          _rl_unget_char(param_3 & 0xffffffff);\n        }\n        else {\n          _rl_prev_macro_key();\n        }\n        if (0 < rl_key_sequence_length) {\n          rl_key_sequence_length = rl_key_sequence_length + -1;\n          *(undefined *)(rl_executing_keyseq + rl_key_sequence_length) = 0;\n        }\n        uVar5 = 0xfffffffe;\n        _rl_dispatching_keymap = param_2;\n      }\n    }\n    return uVar5;\n  }\n  puVar2 = *(undefined **)(_rl_dispatching_keymap + 0x1008);\n  if (*(char *)(_rl_dispatching_keymap + 0x1000) == '\\0') {\n    if (puVar2 != PTR_rl_do_lowercase_version_00237fa0) {\n      puVar8 = (undefined *)((long)(int)param_3 * 0x10 + _rl_dispatching_keymap);\n      uVar1 = *puVar8;\n      uVar3 = *(undefined8 *)(puVar8 + 8);\n      *puVar8 = 0;\n      *(undefined **)(puVar8 + 8) = puVar2;\n      _rl_dispatching_keymap = param_2;\n      uVar5 = _rl_dispatch_subseq(param_3 & 0xffffffff,lVar4,0);\n      *puVar8 = uVar1;\n      *(undefined8 *)(puVar8 + 8) = uVar3;\n      return uVar5;\n    }\n    ppuVar6 = __ctype_b_loc();\n    uVar5 = param_3 & 0xff;\n    lVar4 = param_2;\n    if ((*(byte *)((long)*ppuVar6 + (param_3 & 0xff) * 2 + 1) & 1) != 0) {\n      pp_Var7 = __ctype_tolower_loc();\n      uVar5 = (ulong)(uint)(*pp_Var7)[param_3 & 0xff];\n      lVar4 = param_2;\n    }\n  }\n  else {\n    uVar5 = 0x100;\n  }\n  _rl_dispatching_keymap = lVar4;\n  uVar5 = _rl_dispatch_subseq(uVar5,_rl_dispatching_keymap,0);\n  return uVar5;\n}\n\n",
  "get_random_number": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid get_random_number(void)\n\n{\n  __pid_t _Var1;\n  int iVar2;\n  \n  _Var1 = getpid();\n  if ((subshell_environment != 0) && (_DAT_002422e8 != _Var1)) {\n    seedrand();\n    _DAT_002422e8 = _Var1;\n    iVar2 = brand();\n    if (last_random_value != iVar2) {\n      last_random_value = iVar2;\n      return;\n    }\n  }\n  do {\n    iVar2 = brand();\n  } while (last_random_value == iVar2);\n  last_random_value = iVar2;\n  return;\n}\n\n",
  "make_new_array_variable": "\nlong make_new_array_variable(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = FUN_00152bf0(param_1,*(undefined8 *)(global_variables + 0x20));\n  uVar2 = array_create();\n  *(uint *)(lVar1 + 0x28) = *(uint *)(lVar1 + 0x28) | 4;\n  *(undefined8 *)(lVar1 + 8) = uVar2;\n  return lVar1;\n}\n\n",
  "history_search_prefix": "\nvoid history_search_prefix(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_001f6220(param_1,param_2,1);\n  return;\n}\n\n",
  "rl_unix_line_discard": "\nundefined8 rl_unix_line_discard(void)\n\n{\n  if (rl_point == 0) {\n    rl_ding();\n  }\n  else {\n    rl_kill_text(rl_point,0);\n    rl_point = 0;\n    if (rl_editing_mode == 1) {\n      rl_mark = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
  "FUN_001b86c0": "\nvoid FUN_001b86c0(undefined *param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  \n  lVar3 = (long)DAT_00248d88;\n  if (DAT_00248d90 <= (ulong)(long)(DAT_00248d88 + 2)) {\n    DAT_00248d90 = (long)(DAT_00248d88 + 2) + 0x3fU & 0xffffffffffffffc0;\n    DAT_00248da0 = sh_xrealloc(DAT_00248da0,DAT_00248d90,\"./printf.def\",0x432);\n    lVar3 = (long)DAT_00248d88;\n  }\n  lVar1 = DAT_00248da0;\n  DAT_00248d88 = (int)lVar3 + 1;\n  lVar2 = (long)DAT_00248d88;\n  *(undefined *)(DAT_00248da0 + lVar3) = *param_1;\n  *(undefined *)(lVar1 + lVar2) = 0;\n  return;\n}\n\n",
  "rl_yank_pop": "\nundefined8 rl_yank_pop(void)\n\n{\n  char *__s;\n  int iVar1;\n  int iVar2;\n  size_t sVar3;\n  int iVar4;\n  \n  if (((rl_last_func == rl_yank) || (rl_last_func == rl_yank_pop)) && (DAT_0024b160 != 0)) {\n    __s = *(char **)(DAT_0024b160 + (long)DAT_0024b158 * 8);\n    sVar3 = strlen(__s);\n    iVar1 = rl_point;\n    iVar2 = (int)sVar3;\n    iVar4 = rl_point - iVar2;\n    if (-1 < iVar4) {\n      if (iVar2 == 0) {\nLAB_001e9633:\n        rl_delete_text(iVar4,iVar1);\n        DAT_0024b158 = DAT_0024b158 + -1;\n        if (DAT_0024b158 < 0) {\n          DAT_0024b158 = DAT_0024b154 + -1;\n        }\n        rl_point = iVar4;\n        if (DAT_0024b160 != 0) {\n          _rl_set_mark_at_pos(iVar4);\n          rl_insert_text(*(undefined8 *)(DAT_0024b160 + (long)DAT_0024b158 * 8));\n          return 0;\n        }\n                    /* WARNING: Subroutine does not return */\n        _rl_abort_internal();\n      }\n      if (*(char *)(iVar4 + rl_line_buffer) == *__s) {\n        iVar2 = strncmp((char *)(iVar4 + rl_line_buffer),__s,(long)iVar2);\n        if (iVar2 == 0) goto LAB_001e9633;\n      }\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  _rl_abort_internal();\n}\n\n",
  "FUN_001af770": "\nvoid FUN_001af770(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  __longjmp_chk(read_timeout + 0x30,1);\n}\n\n",
  "FUN_001e27c0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_001e27c0(char *param_1,char *param_2,char *param_3,char *param_4,uint param_5,uint param_6,\n                 uint param_7,int param_8)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  bool bVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  int iVar8;\n  size_t sVar9;\n  long lVar10;\n  size_t sVar11;\n  undefined8 uVar12;\n  uint uVar13;\n  int *piVar14;\n  char *pcVar15;\n  uint uVar16;\n  uint uVar17;\n  char *pcVar18;\n  char *pcVar19;\n  ulong uVar20;\n  char *pcVar21;\n  int iVar22;\n  uint uVar23;\n  ulong uVar24;\n  char *pcVar25;\n  ulong uVar26;\n  ulong uVar27;\n  int iVar28;\n  int iVar29;\n  long in_FS_OFFSET;\n  bool bVar30;\n  ulong local_f0;\n  char *local_e0;\n  char *local_d0;\n  char *local_c8;\n  char *local_c0;\n  ulong local_b0;\n  ulong local_a8;\n  char *local_a0;\n  ulong local_80;\n  wchar_t local_5c;\n  undefined8 local_58;\n  undefined8 local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar9 = __ctype_get_mb_cur_max();\n  iVar8 = (int)sVar9;\n  iVar7 = (int)param_1;\n  uVar17 = _rl_last_c_pos;\n  if ((iVar8 < 2) || (rl_byte_oriented != 0)) {\n    if (_rl_last_v_pos == 0) {\n      if (DAT_0024a888 != 0) {\n        if ((int)_rl_screenwidth < (int)DAT_0024a870) {\n          uVar17 = _rl_last_c_pos - DAT_0024a878;\n        }\n        else {\n          uVar17 = _rl_last_c_pos - DAT_0024a884;\n        }\n      }\n    }\n    else if (_rl_last_v_pos == _DAT_0024a874) {\n      uVar17 = (_rl_last_c_pos - DAT_0024a884) + DAT_0024a878;\n    }\n  }\n  iVar6 = (int)param_3;\n  pcVar18 = param_3;\n  pcVar21 = param_1;\n  local_d0 = param_4;\n  pcVar25 = param_1;\n  if ((((uVar17 == _rl_screenwidth) && (_rl_term_autowrap != 0)) &&\n      (_rl_horizontal_scroll_mode == 0)) && (param_5 - 1 == _rl_last_v_pos)) {\n    if ((1 < iVar8) && (rl_byte_oriented == 0)) {\n      if ((*(uint *)(PTR_DAT_00240518 + 0x1c) != param_5 &&\n           (int)param_5 <= (int)*(uint *)(PTR_DAT_00240518 + 0x1c)) &&\n         (0 < *(int *)(*(long *)(PTR_DAT_00240518 + 0x20) + (long)(int)param_5 * 4))) {\n        _rl_clear_to_eol();\n      }\n      sVar9 = (size_t)iVar8;\n      local_48.__count = 0;\n      local_48.__value = (_union_27)0x0;\n      sVar11 = mbrtowc(&local_5c,param_1,sVar9,&local_48);\n      if (sVar11 < 0xfffffffffffffffe) {\n        if (sVar11 == 0) {\n          local_48.__count = 0;\n          local_48.__value = (_union_27)0x0;\n          sVar11 = mbrtowc(&local_5c,param_3,sVar9,&local_48);\n          uVar20 = sVar11 & 0xffffffff;\n          if (0xfffffffffffffffd < sVar11) {\n            uVar13 = 1;\n            uVar17 = 0;\n            uVar20 = 1;\n            uVar16 = 1;\n            uVar23 = 0;\n            if (0 < (int)param_6) goto LAB_001e467b;\n            goto LAB_001e471c;\n          }\n          uVar17 = 0;\n          uVar23 = 0;\n          goto LAB_001e2db1;\n        }\n        uVar17 = (uint)sVar11;\n        if (L'_' < local_5c) {\n          if (0x1d < (uint)(local_5c + L'\\xffffff9f')) goto LAB_001e4e05;\nLAB_001e4e58:\n          local_48.__count = 0;\n          local_48.__value = (_union_27)0x0;\n          sVar11 = mbrtowc(&local_5c,param_3,sVar9,&local_48);\n          if (0xfffffffffffffffd < sVar11) goto LAB_001e4f86;\n          uVar23 = 1;\nLAB_001e4e89:\n          uVar20 = sVar11 & 0xffffffff;\n          goto LAB_001e2db1;\n        }\n        if (L'@' < local_5c) goto LAB_001e4e58;\n        if (local_5c < L'$') {\n          if (L'\\x1f' < local_5c) goto LAB_001e4e58;\n        }\n        else if ((uint)(local_5c + L'\\xffffffdb') < 0x1b) goto LAB_001e4e58;\nLAB_001e4e05:\n        uVar23 = wcwidth(local_5c);\n        if ((int)uVar23 < 0) goto LAB_001e4904;\n        local_48.__count = 0;\n        local_48.__value = (_union_27)0x0;\n        sVar11 = mbrtowc(&local_5c,param_3,sVar9,&local_48);\n        if (sVar11 < 0xfffffffffffffffe) goto LAB_001e4e89;\n        uVar20 = 1;\n        uVar13 = 1;\n      }\n      else {\n        uVar17 = 1;\nLAB_001e4904:\n        local_48.__count = 0;\n        local_48.__value = (_union_27)0x0;\n        sVar11 = mbrtowc(&local_5c,param_3,sVar9,&local_48);\n        uVar20 = sVar11 & 0xffffffff;\n        if (0xfffffffffffffffd < sVar11) {\nLAB_001e4f86:\n          uVar23 = 1;\n          uVar13 = 1;\n          uVar20 = 1;\n          goto LAB_001e471c;\n        }\n        uVar23 = 1;\nLAB_001e2db1:\n        if (sVar11 == 0) {\n          uVar20 = 0;\n          uVar13 = 0;\n        }\n        else if (local_5c < L'`') {\n          if (local_5c < L'A') {\n            if (local_5c < L'$') {\n              uVar13 = 1;\n              if (L'\\x1f' < local_5c) goto LAB_001e2dbd;\n            }\n            else if ((uint)(local_5c + L'\\xffffffdb') < 0x1b) goto LAB_001e4d16;\nLAB_001e4cfd:\n            uVar13 = wcwidth(local_5c);\n            if (-1 < (int)uVar13) goto LAB_001e2dbd;\n          }\nLAB_001e4d16:\n          uVar13 = 1;\n        }\n        else {\n          uVar13 = 1;\n          if (0x1d < (uint)(local_5c + L'\\xffffff9f')) goto LAB_001e4cfd;\n        }\n      }\nLAB_001e2dbd:\n      if (((int)uVar13 < (int)uVar23) && ((int)uVar20 < (int)param_7)) {\n        do {\n          uVar16 = (uint)uVar20;\n          sVar11 = mbrtowc(&local_5c,param_3 + (int)uVar16,sVar9,&local_48);\n          if (sVar11 < 0xfffffffffffffffe) {\n            if (sVar11 == 0) goto LAB_001e461e;\n            if (local_5c < L'`') {\n              if (local_5c < L'A') {\n                if (local_5c < L'$') {\n                  iVar22 = 1;\n                  if (L'\\x1f' < local_5c) goto LAB_001e2e80;\n                }\n                else if ((uint)(local_5c + L'\\xffffffdb') < 0x1b) goto LAB_001e4095;\nLAB_001e2e61:\n                iVar22 = wcwidth(local_5c);\n                if (iVar22 < 0) {\n                  iVar22 = 1;\n                }\n              }\n              else {\nLAB_001e4095:\n                iVar22 = 1;\n              }\n            }\n            else {\n              iVar22 = 1;\n              if (0x1d < (uint)(local_5c + L'\\xffffff9f')) goto LAB_001e2e61;\n            }\nLAB_001e2e80:\n            uVar13 = uVar13 + iVar22;\n            uVar16 = uVar16 + (int)sVar11;\n          }\n          else {\n            uVar13 = uVar13 + 1;\n            uVar16 = uVar16 + 1;\n          }\n          uVar20 = (ulong)uVar16;\n          if (((int)param_7 <= (int)uVar16) || ((int)uVar23 <= (int)uVar13)) goto LAB_001e461e;\n        } while( true );\n      }\n      goto LAB_001e4629;\n    }\n    if (*param_3 == '\\0') {\n      putc(0x20,rl_outstream);\n    }\n    else {\n      FUN_001e0800(param_3,param_4,1);\n    }\n    _rl_last_v_pos = _rl_last_v_pos + 1;\n    _rl_last_c_pos = 1;\n    if ((*param_1 != '\\0') && (*param_3 != '\\0')) {\n      *param_1 = *param_3;\n      *param_2 = *param_4;\n    }\n  }\n  if (DAT_0024a8d8 == 0) {\n    if (1 < iVar8) goto LAB_001e29e7;\nLAB_001e29f7:\n    pcVar15 = param_2;\n    local_c8 = param_3;\n    if (0 < (long)(int)param_6) {\n      do {\n        if (((*pcVar25 == '\\0') || (*pcVar25 != *local_c8)) || (*pcVar15 != *local_d0))\n        goto LAB_001e2a58;\n        pcVar25 = pcVar25 + 1;\n        local_c8 = local_c8 + 1;\n        local_d0 = local_d0 + 1;\n        local_a8 = (long)pcVar25 - (long)param_1;\n        pcVar15 = pcVar15 + 1;\n        pcVar18 = local_c8;\n      } while ((long)local_a8 < (long)(int)param_6);\n      goto LAB_001e2a5e;\n    }\nLAB_001e44ab:\n    local_a8 = 0;\n    local_80 = 0;\n    local_b0 = 0;\n    goto LAB_001e43b0;\n  }\nLAB_001e2844:\n  if (0 < (int)param_6) {\n    do {\n      if (*pcVar21 == '\\0') break;\n      pcVar21 = pcVar21 + 1;\n    } while (pcVar21 != param_1 + (int)param_6);\n  }\n  iVar22 = (int)pcVar21;\n  if (0 < (int)param_7) {\n    do {\n      if (*pcVar18 == '\\0') break;\n      pcVar18 = pcVar18 + 1;\n    } while (pcVar18 != param_3 + (int)param_7);\n    FUN_001e1320(0,param_1,param_2);\n    uVar17 = (uint)((long)pcVar18 - (long)param_3);\n    uVar20 = (long)pcVar18 - (long)param_3 & 0xffffffff;\n    if ((int)DAT_0024a894 <= (int)uVar17) goto LAB_001e28c5;\n    uVar16 = 0;\n    pcVar25 = param_3;\n    local_e0 = param_4;\n    goto LAB_001e339e;\n  }\n  FUN_001e1320(0,param_1,param_2);\n  if (0 < (int)DAT_0024a894) goto LAB_001e33ac;\n  uVar20 = 0;\n  uVar17 = 0;\nLAB_001e28c5:\n  _rl_output_some_chars(param_3);\n  lVar10 = (long)(int)DAT_0024a894;\n  iVar5 = (int)uVar20;\n  _rl_last_c_pos = DAT_0024a894;\n  if (iVar8 < 2) {\n    iVar28 = iVar5 - DAT_0024a894;\n    if (0 < iVar28) {\n      FUN_001e0800(param_3 + lVar10,param_4 + lVar10,iVar28);\nLAB_001e3870:\n      _rl_last_c_pos = _rl_last_c_pos + iVar28;\n    }\nLAB_001e37f5:\n    if ((int)param_6 <= (int)param_7) {\nLAB_001e3805:\n      if ((param_5 != 0) || ((int)(param_6 - DAT_0024a888) <= (int)(param_7 - DAT_0024a884)))\n      goto LAB_001e2970;\n    }\n    goto LAB_001e33e4;\n  }\n  iVar28 = iVar5 - DAT_0024a894;\n  if (rl_byte_oriented != 0) {\n    if (iVar28 < 1) goto LAB_001e37f5;\nLAB_001e3843:\n    FUN_001e0800(param_3 + lVar10,param_4 + lVar10,iVar28);\n    uVar13 = DAT_0024a894;\n    if (rl_byte_oriented == 0) goto LAB_001e3870;\n    iVar6 = 0;\n    if ((int)DAT_0024a894 < iVar5) {\n      sVar9 = __ctype_get_mb_cur_max();\n      if ((sVar9 == 1) || (rl_byte_oriented != 0)) {\n        iVar6 = iVar5 - uVar13;\n      }\n      else {\n        iVar6 = FUN_001e08f0(param_3,uVar13,uVar20,1);\n      }\n    }\n    _rl_last_c_pos = _rl_last_c_pos + iVar6;\n    if ((int)param_6 <= (int)param_7) goto LAB_001e3805;\n    goto LAB_001e4009;\n  }\n  _rl_last_c_pos = DAT_0024a870;\n  if (0 < iVar28) goto LAB_001e3843;\n  if ((int)param_6 <= (int)param_7) goto LAB_001e3805;\n  param_7 = (int)pcVar18 - iVar6;\n  param_6 = iVar22 - iVar7;\n  goto LAB_001e2930;\nLAB_001e461e:\n  uVar20 = (ulong)uVar16;\nLAB_001e4629:\n  uVar16 = (uint)uVar20;\n  if (((int)uVar23 < (int)uVar13) && ((int)uVar17 < (int)param_6)) {\nLAB_001e467b:\n    do {\n      sVar11 = mbrtowc(&local_5c,param_1 + (int)uVar17,sVar9,&local_48);\n      if (sVar11 < 0xfffffffffffffffe) {\n        if (sVar11 == 0) goto LAB_001e4705;\n        if (local_5c < L'`') {\n          if (local_5c < L'A') {\n            if (local_5c < L'$') {\n              iVar22 = 1;\n              if (L'\\x1f' < local_5c) goto LAB_001e46e0;\n            }\n            else if ((uint)(local_5c + L'\\xffffffdb') < 0x1b) goto LAB_001e46ef;\nLAB_001e46bd:\n            iVar22 = wcwidth(local_5c);\n            if (iVar22 < 0) {\n              iVar22 = 1;\n            }\n          }\n          else {\nLAB_001e46ef:\n            iVar22 = 1;\n          }\n        }\n        else {\n          iVar22 = 1;\n          if (0x1d < (uint)(local_5c + L'\\xffffff9f')) goto LAB_001e46bd;\n        }\nLAB_001e46e0:\n        uVar23 = uVar23 + iVar22;\n        uVar17 = uVar17 + (int)sVar11;\n      }\n      else {\n        uVar23 = uVar23 + 1;\n        uVar17 = uVar17 + 1;\n      }\n      if (((int)param_6 <= (int)uVar17) || ((int)uVar13 <= (int)uVar23)) goto LAB_001e4705;\n    } while( true );\n  }\n  if (uVar13 != 0) goto LAB_001e471c;\n  putc(0x20,rl_outstream);\n  _rl_last_v_pos = _rl_last_v_pos + 1;\n  _rl_last_c_pos = 1;\n  if ((*param_1 != '\\0') && (*param_3 != '\\0')) {\n    *param_1 = *param_3;\n    *param_2 = *param_4;\n  }\nLAB_001e4838:\n  if (DAT_0024a8d8 != 0) goto LAB_001e2844;\nLAB_001e29e7:\n  uVar20 = (ulong)rl_byte_oriented;\n  if (rl_byte_oriented != 0) goto LAB_001e29f7;\n  uVar17 = param_6;\n  if ((int)param_7 <= (int)param_6) {\n    uVar17 = param_7;\n  }\n  local_80 = (ulong)(int)uVar17;\n  local_a8 = (ulong)uVar17;\n  iVar22 = memcmp(param_1,param_3,local_80);\n  if ((iVar22 == 0) && (iVar22 = memcmp(param_2,param_4,local_80), iVar22 == 0)) {\n    pcVar25 = param_1 + local_80;\n    pcVar18 = param_3 + local_80;\n    local_b0 = (ulong)uVar17;\n    local_d0 = param_4 + local_80;\n  }\n  else {\n    local_58 = 0;\n    local_50 = 0;\n    if (param_7 == param_6) {\n      local_80 = (ulong)(int)param_7;\n      iVar22 = memcmp(param_3,param_1,local_80);\n      if ((iVar22 == 0) && (iVar22 = memcmp(param_4,param_2,local_80), iVar22 == 0)) {\n        local_d0 = param_4 + local_80;\n        pcVar25 = param_1 + local_80;\n        pcVar18 = param_3 + local_80;\n        local_b0 = (ulong)param_7;\n        local_a8 = (ulong)param_7;\n        goto LAB_001e2a71;\n      }\n    }\n    if ((int)param_6 < 1) goto LAB_001e44ab;\n    uVar17 = 0;\n    pcVar21 = param_2;\n    local_c8 = param_3;\n    do {\n      if (((*pcVar25 == '\\0') ||\n          (iVar22 = _rl_compare_chars(param_1,uVar20 & 0xffffffff,&local_50,param_3,uVar17,&local_58\n                                     ), iVar22 == 0)) || (*pcVar21 != *local_d0)) goto LAB_001e2a58;\n      uVar13 = _rl_find_next_mbchar(param_1,uVar20 & 0xffffffff,1,0);\n      uVar20 = (ulong)(int)uVar13;\n      uVar17 = _rl_find_next_mbchar(param_3,uVar17,1,0);\n      pcVar25 = param_1 + uVar20;\n      pcVar21 = param_2 + uVar20;\n      local_80 = (ulong)(int)uVar17;\n      pcVar18 = param_3 + local_80;\n      local_d0 = param_4 + local_80;\n      local_c8 = pcVar18;\n    } while ((int)uVar13 < (int)param_6);\n    local_b0 = (ulong)uVar17;\n    local_a8 = (ulong)uVar13;\n  }\n  goto LAB_001e2a71;\nLAB_001e4705:\n  uVar20 = (ulong)uVar16;\nLAB_001e471c:\n  uVar16 = (uint)uVar20;\n  FUN_001e0800(param_3,param_4,uVar20);\n  _rl_last_v_pos = _rl_last_v_pos + 1;\n  _rl_last_c_pos = uVar13;\n  if ((uVar13 == uVar23) && ((int)uVar16 <= (int)uVar17)) {\n    if ((uVar17 != 0) && (uVar16 != 0)) {\n      sVar9 = (size_t)(int)uVar16;\n      if (uVar16 != uVar17) {\n        pcVar15 = param_1 + (int)uVar17;\n        sVar11 = strlen(pcVar15);\n        memmove(param_1 + sVar9,pcVar15,sVar11 + 1);\n        sVar11 = strlen(pcVar15);\n        memmove(param_2 + sVar9,param_2 + (int)uVar17,sVar11 + 1);\n      }\n      memcpy(param_1,param_3,sVar9);\n      memcpy(param_2,param_4,sVar9);\n      puVar1 = PTR_DAT_00240520;\n      iVar22 = uVar16 - uVar17;\n      param_6 = param_6 + iVar22;\n      if ((iVar22 != 0) && ((int)param_5 <= param_8)) {\n        lVar10 = (long)(int)(param_5 + 1) << 2;\n        iVar5 = param_5 + 1;\n        do {\n          if (_rl_vis_botlin + 1 < iVar5) break;\n          piVar14 = (int *)(*(long *)(puVar1 + 0x10) + lVar10);\n          lVar10 = lVar10 + 4;\n          *piVar14 = *piVar14 + iVar22;\n          bVar30 = iVar5 <= param_8;\n          iVar5 = iVar5 + 1;\n        } while (bVar30);\n      }\n    }\n    goto LAB_001e4838;\n  }\n  iVar6 = param_7 - uVar16;\n  pcVar21 = param_1 + (int)param_6;\n  pcVar18 = param_3 + (int)param_7;\n  if (0 < iVar6) {\n    pcVar25 = param_3 + (int)uVar16;\n    FUN_001e0800(pcVar25,param_4 + (int)uVar16,iVar6);\n    goto LAB_001e37bc;\n  }\n  if ((int)param_6 <= (int)param_7) goto LAB_001e33b8;\n  uVar17 = param_6 - param_7;\n  goto LAB_001e3406;\nLAB_001e2a58:\n  local_a8 = (ulong)(uint)((int)pcVar25 - iVar7);\n  pcVar18 = local_c8;\nLAB_001e2a5e:\n  local_a8 = local_a8 & 0xffffffff;\n  local_80 = (long)pcVar18 - (long)param_3;\n  local_b0 = local_80 & 0xffffffff;\nLAB_001e2a71:\n  pcVar21 = pcVar25;\n  if ((int)local_a8 < (int)param_6) {\n    do {\n      if (*pcVar21 == '\\0') break;\n      pcVar21 = pcVar21 + 1;\n    } while (pcVar21 != pcVar25 + (ulong)((param_6 - 1) - (int)local_a8) + 1);\n    bVar30 = pcVar25 == pcVar21;\n    pcVar15 = pcVar18;\n    if ((int)local_b0 < (int)param_7) goto LAB_001e2ab6;\n  }\n  else {\nLAB_001e43b0:\n    bVar30 = true;\n    pcVar25 = pcVar21;\n    pcVar15 = pcVar18;\n    if ((int)param_7 <= (int)local_b0) goto LAB_001e2970;\nLAB_001e2ab6:\n    pcVar18 = pcVar15;\n    do {\n      if (*pcVar18 == '\\0') break;\n      pcVar18 = pcVar18 + 1;\n    } while (((int)local_b0 - (int)pcVar15) + (int)pcVar18 < (int)param_7);\n    bVar30 = (bool)(bVar30 & pcVar18 == pcVar15);\n  }\n  if (bVar30) goto LAB_001e2970;\n  iVar22 = (int)pcVar18;\n  if ((iVar8 < 2) || (rl_byte_oriented != 0)) {\nLAB_001e2ee8:\n    local_c0 = pcVar21 + -1;\n    pcVar19 = pcVar18 + -1;\n    local_c8 = param_2 + ((long)local_c0 - (long)param_1);\n    local_a0 = param_4 + ((long)pcVar19 - (long)param_3);\n    if ((pcVar15 < pcVar19) && (pcVar25 < local_c0)) {\n      bVar30 = true;\n      while ((*local_c0 == *pcVar19 && (*local_c8 == *local_a0))) {\n        if (*local_c0 != ' ') {\n          bVar30 = false;\n        }\n        local_c0 = local_c0 + -1;\n        local_c8 = local_c8 + -1;\n        pcVar19 = pcVar19 + -1;\n        local_a0 = local_a0 + -1;\n        if ((local_c0 <= pcVar25) || (pcVar19 <= pcVar15)) break;\n      }\n      goto LAB_001e2f70;\n    }\nLAB_001e2f7c:\n    iVar5 = (int)pcVar25;\n    pcVar19 = pcVar18;\n    local_c0 = pcVar21;\n  }\n  else {\n    if (_rl_utf8locale != 0) {\n      local_48.__count = 0;\n      local_48.__value = (_union_27)0x0;\n      sVar9 = mbrtowc(&local_5c,pcVar25,(long)iVar8,&local_48);\n      if (((0 < (int)sVar9) && ((uint)(local_5c + L'\\xfffffd00') < 0x70)) &&\n         (iVar5 = wcwidth(local_5c), iVar5 == 0)) {\n        uVar17 = _rl_find_prev_mbchar(param_1,local_a8,0);\n        local_a8 = (ulong)uVar17;\n        uVar13 = _rl_find_prev_mbchar(param_3,local_b0,0);\n        local_b0 = (ulong)uVar13;\n        pcVar25 = param_1 + (int)uVar17;\n        local_80 = (ulong)(int)uVar13;\n        local_d0 = param_4 + local_80;\n        pcVar15 = param_3 + local_80;\n      }\n      if (rl_byte_oriented != 0) goto LAB_001e2ee8;\n    }\n    iVar5 = _rl_find_prev_mbchar(param_1,(int)pcVar21 - iVar7,0);\n    local_c0 = param_1 + iVar5;\n    local_c8 = param_2 + iVar5;\n    iVar5 = _rl_find_prev_mbchar(param_3,iVar22 - iVar6,0);\n    pcVar19 = param_3 + iVar5;\n    local_a0 = param_4 + iVar5;\n    if ((pcVar19 <= pcVar15) || (local_c0 <= pcVar25)) goto LAB_001e2f7c;\n    bVar30 = true;\n    while( true ) {\n      local_50 = 0;\n      local_58 = 0;\n      iVar28 = (int)local_c0 - iVar7;\n      iVar5 = _rl_compare_chars(param_1,iVar28,&local_50,param_3,(long)pcVar19 - (long)param_3,\n                                &local_58);\n      if ((iVar5 == 0) || (*local_c8 != *local_a0)) break;\n      bVar3 = false;\n      if (*local_c0 != ' ') {\n        bVar3 = bVar30;\n      }\n      bVar30 = bVar3;\n      iVar5 = _rl_find_prev_mbchar(param_1,iVar28,0);\n      local_c0 = param_1 + iVar5;\n      local_c8 = param_2 + iVar5;\n      iVar5 = _rl_find_prev_mbchar(param_3,(long)pcVar19 - (long)param_3 & 0xffffffff,0);\n      pcVar19 = param_3 + iVar5;\n      local_a0 = param_4 + iVar5;\n      if ((local_c0 <= pcVar25) || (pcVar19 <= pcVar15)) break;\n    }\nLAB_001e2f70:\n    iVar5 = (int)pcVar25;\n    if (bVar30) goto LAB_001e2f7c;\n    iVar28 = _rl_compare_chars(local_c0,0,0,pcVar19,0,0);\n    if ((iVar28 == 0) || (*local_c8 != *local_a0)) {\n      if (*local_c0 == '\\0') {\nLAB_001e3ca7:\n        if (*pcVar19 != '\\0') {\n          if (1 < iVar8) goto LAB_001e3cb8;\n          goto LAB_001e3cc8;\n        }\n      }\n      else {\n        if ((iVar8 < 2) || (rl_byte_oriented != 0)) {\n          local_c0 = local_c0 + 1;\n          goto LAB_001e3ca7;\n        }\n        iVar28 = _rl_find_next_mbchar(param_1,(int)local_c0 - iVar7,1,0);\n        local_c0 = param_1 + iVar28;\n        if (*pcVar19 == '\\0') goto LAB_001e2f84;\nLAB_001e3cb8:\n        if (rl_byte_oriented == 0) {\n          iVar28 = _rl_find_next_mbchar(param_3,(int)pcVar19 - iVar6,1,0);\n          pcVar19 = param_3 + iVar28;\n        }\n        else {\nLAB_001e3cc8:\n          pcVar19 = pcVar19 + 1;\n        }\n      }\n    }\n  }\nLAB_001e2f84:\n  uVar17 = DAT_0024a884;\n  iVar28 = (int)local_c0;\n  iVar29 = (int)pcVar15;\n  if (param_5 == 0) {\n    if (_rl_last_v_pos != 0) {\n      _rl_move_vert(0);\n      DAT_0024a888 = DAT_0024a878;\n      if ((iVar8 == 1) || (rl_byte_oriented != 0)) {\n        if (DAT_0024a878 != 0) {\n          _rl_last_c_pos = _rl_last_c_pos + DAT_0024a878;\n        }\n        goto LAB_001e3008;\n      }\nLAB_001e3484:\n      uVar16 = DAT_0024a894;\n      if ((int)param_7 <= (int)DAT_0024a894) {\n        uVar16 = param_7;\n      }\n      if (param_5 == 0) goto joined_r0x001e3028;\n      FUN_001e1320(local_a8,param_1,param_2);\n      uVar20 = (long)pcVar19 - (long)pcVar15;\n      uVar13 = (int)uVar20 - (iVar28 - iVar5);\n      local_f0 = (ulong)uVar13;\n      if (iVar8 < 2) goto LAB_001e395b;\n      if (rl_byte_oriented == 0) goto LAB_001e388e;\nLAB_001e3f42:\n      uVar24 = local_f0;\nLAB_001e320a:\n      uVar26 = (long)pcVar18 - (long)pcVar15 & 0xffffffff;\n      uVar27 = (long)pcVar18 - (long)pcVar15;\n      iVar7 = (int)uVar26;\n      if (1 < iVar8) {\nLAB_001e321a:\n        uVar27 = uVar26;\n        iVar7 = (int)uVar26;\n        if (rl_byte_oriented == 0) goto LAB_001e3d34;\n      }\n      goto LAB_001e322b;\n    }\nLAB_001e3008:\n    uVar16 = DAT_0024a894;\n    if ((int)param_7 <= (int)DAT_0024a894) {\n      uVar16 = param_7;\n    }\njoined_r0x001e3028:\n    if ((((_rl_horizontal_scroll_mode != 0) || (_rl_term_cr == 0)) || ((int)uVar16 <= DAT_0024a88c))\n       || ((int)_rl_last_c_pos < 1)) {\nLAB_001e302e:\n      uVar13 = _rl_last_c_pos;\n      FUN_001e1320(local_a8,param_1,param_2);\n      uVar20 = (long)pcVar19 - (long)pcVar15;\n      uVar23 = (int)uVar20 - (iVar28 - iVar5);\n      local_f0 = (ulong)uVar23;\n      if (iVar8 < 2) goto LAB_001e3a58;\n      uVar24 = (ulong)rl_byte_oriented;\n      local_f0._0_4_ = uVar23;\n      if (rl_byte_oriented == 0) {\n        if (((0 < (int)uVar13) || (0 < (int)_rl_last_c_pos)) && (_rl_last_c_pos == DAT_0024a870)) {\n          DAT_0024a8d4 = 1;\n        }\n        iVar28 = iVar28 - iVar7;\n        iVar4 = (int)((long)pcVar19 - (long)param_3);\n        uVar20 = (long)pcVar19 - (long)param_3 & 0xffffffff;\n        uVar13 = (uint)uVar20;\n        if (((pcVar15 != param_3) || (iVar4 <= DAT_0024a880)) ||\n           (((int)param_7 < (int)DAT_0024a894 ||\n            (((int)DAT_0024a894 < iVar4 || (DAT_0024a888 == uVar17)))))) goto LAB_001e38a0;\n        if ((iVar4 < (int)param_7) && (iVar28 < (int)param_6)) {\n          while (uVar23 = (uint)uVar20, (int)uVar23 < (int)DAT_0024a894) {\n            uVar13 = _rl_find_next_mbchar(param_3,uVar20,1,1);\n            iVar4 = _rl_find_next_mbchar(param_1,iVar28,1,1);\n            pcVar19 = pcVar19 + (int)(uVar13 - uVar23);\n            local_c0 = local_c0 + (iVar4 - iVar28);\n            if (((int)param_7 <= (int)uVar13) || ((int)param_6 <= iVar4)) {\n              uVar24 = 0;\n              goto LAB_001e31b4;\n            }\n            iVar28 = iVar4;\n            uVar20 = (ulong)uVar13;\n          }\n          uVar24 = 0;\n          uVar13 = uVar23;\n        }\nLAB_001e31b4:\n        if (uVar13 == DAT_0024a894) {\n          uVar24 = (ulong)(DAT_0024a884 + DAT_0024a870);\n        }\n        else {\n          uVar20 = (long)pcVar19 - (long)param_3;\n          if (0 < (int)uVar20) {\n            sVar9 = __ctype_get_mb_cur_max();\n            uVar24 = uVar20 & 0xffffffff;\n            if ((sVar9 != 1) && (rl_byte_oriented == 0)) {\n              uVar13 = FUN_001e08f0(param_3,0,uVar20 & 0xffffffff,1);\n              uVar24 = (ulong)uVar13;\n            }\n          }\n        }\n        uVar20 = (long)pcVar19 - (long)pcVar15;\n        local_f0._0_4_ = (int)uVar20 - ((int)local_c0 - iVar5);\n        iVar28 = (int)local_c0 - iVar7;\n        goto LAB_001e31f0;\n      }\n      iVar7 = DAT_0024a888 - uVar17;\n      uVar13 = uVar23 + iVar7;\n      if (DAT_0024a888 != uVar17) goto LAB_001e3d14;\n      uVar24 = (ulong)uVar23;\n      uVar26 = (ulong)(uint)(iVar22 - iVar29);\n      goto LAB_001e321a;\n    }\n    if (((int)local_a8 < 1) && ((int)local_b0 < 1)) {\nLAB_001e34fb:\n      if ((int)uVar16 <= (int)local_a8) {\n        sVar9 = __ctype_get_mb_cur_max();\n        if ((sVar9 < 2) || (uVar13 = DAT_0024a870, rl_byte_oriented != 0)) {\n          uVar13 = DAT_0024a880 + 1;\n        }\n        if ((int)_rl_last_c_pos < (int)uVar13) {\n          iVar4 = (int)local_b0;\n          if ((int)local_a8 <= (int)local_b0) {\n            iVar4 = (int)local_a8;\n          }\n          goto LAB_001e3569;\n        }\n      }\n      goto LAB_001e302e;\n    }\n    iVar4 = (int)local_b0;\n    if ((int)local_a8 <= (int)local_b0) {\n      iVar4 = (int)local_a8;\n    }\n    if (DAT_0024a880 < iVar4) goto LAB_001e34fb;\nLAB_001e3569:\n    _rl_cr();\n    if (DAT_0024a860 != 0) {\n      _rl_output_some_chars(&DAT_00213e4c,1);\n    }\n    _rl_output_some_chars(DAT_0024a8a0,uVar16);\n    uVar12 = DAT_0024a8a0;\n    iVar2 = DAT_0024a860;\n    uVar13 = uVar16;\n    if ((1 < iVar8) && (rl_byte_oriented == 0)) {\n      uVar13 = DAT_0024a870;\n      if (DAT_0024a894 != uVar16) {\n        uVar13 = 0;\n        if (((0 < (int)uVar16) && (sVar9 = __ctype_get_mb_cur_max(), uVar13 = uVar16, sVar9 != 1))\n           && (rl_byte_oriented == 0)) {\n          uVar13 = FUN_001e08f0(uVar12,0,uVar16,1);\n        }\n        uVar13 = uVar13 - DAT_0024a884;\n      }\n      DAT_0024a8d4 = 1;\n    }\n    _rl_last_c_pos = iVar2 + uVar13;\n    if (DAT_0024a880 < iVar4) goto LAB_001e302e;\n    lVar10 = (long)(int)uVar16;\n    if (((param_7 == param_6) && ((long)local_c0 - (long)param_1 < lVar10)) &&\n       ((long)pcVar19 - (long)param_3 < lVar10)) goto LAB_001e2970;\n    pcVar25 = param_3 + lVar10;\n    local_e0 = param_4 + lVar10;\n    uVar20 = (ulong)(uint)(iVar22 - (int)pcVar25);\nLAB_001e339e:\n    iVar6 = (int)uVar20;\n    if (0 < iVar6) {\n      FUN_001e0800(pcVar25,local_e0,uVar20);\n      if (iVar8 < 2) {\nLAB_001e37ca:\n        _rl_last_c_pos = _rl_last_c_pos + iVar6;\n        goto LAB_001e33ac;\n      }\nLAB_001e37bc:\n      iVar22 = (int)pcVar21;\n      if (rl_byte_oriented != 0) goto LAB_001e37ca;\n      uVar17 = (uint)((long)pcVar18 - (long)param_3);\n      iVar5 = 0;\n      if ((int)uVar16 < (int)uVar17) {\n        sVar9 = __ctype_get_mb_cur_max();\n        if ((sVar9 == 1) || (rl_byte_oriented != 0)) {\n          iVar5 = uVar17 - uVar16;\n        }\n        else {\n          iVar5 = FUN_001e08f0(param_3,uVar16,(long)pcVar18 - (long)param_3 & 0xffffffff,1);\n        }\n      }\n      _rl_last_c_pos = iVar5 + _rl_last_c_pos;\n      if ((((int)DAT_0024a884 <= (int)DAT_0024a878) || (_DAT_0024a874 != param_5)) ||\n         (((int)DAT_0024a870 <= (int)_rl_screenwidth || (_rl_horizontal_scroll_mode != 0)))) {\n        if ((param_5 != 0 || DAT_0024a878 == 0) || (param_3 != pcVar25)) goto LAB_001e3ff9;\n        if (((int)DAT_0024a894 <= iVar6) &&\n           (((int)DAT_0024a878 <= (int)DAT_0024a884 && (_rl_horizontal_scroll_mode == 0)))) {\n          DAT_0024a8d4 = 1;\n          _rl_last_c_pos = _rl_last_c_pos - DAT_0024a878;\n        }\n        if ((int)param_7 < (int)param_6) goto LAB_001e4009;\n        goto LAB_001e33ca;\n      }\n      DAT_0024a8d4 = 1;\n      _rl_last_c_pos = _rl_last_c_pos - (DAT_0024a884 - DAT_0024a878);\nLAB_001e3ff9:\n      if ((int)param_6 <= (int)param_7) goto LAB_001e33b8;\nLAB_001e4009:\n      param_7 = uVar17;\n      param_6 = iVar22 - iVar7;\n      uVar17 = param_6 - param_7;\n      goto LAB_001e3406;\n    }\nLAB_001e33ac:\n    if ((int)param_6 <= (int)param_7) {\nLAB_001e33b8:\n      if (param_5 != 0) goto LAB_001e2970;\nLAB_001e33ca:\n      if ((int)(param_6 - DAT_0024a888) <= (int)(param_7 - DAT_0024a884)) goto LAB_001e2970;\n    }\nLAB_001e33e4:\n    uVar20 = (long)pcVar18 - (long)param_3;\n    lVar10 = (long)pcVar21 - (long)param_1;\nLAB_001e33f0:\n    param_6 = (uint)lVar10;\n    param_7 = (uint)uVar20;\n    uVar17 = param_6 - param_7;\n    if (iVar8 < 2) goto LAB_001e3b40;\nLAB_001e3406:\n    if (rl_byte_oriented == 0) {\nLAB_001e2930:\n      if ((int)param_6 < 1) {\n        param_6 = 0;\n        if ((int)param_7 < 1) goto LAB_001e2970;\nLAB_001e2944:\n        sVar9 = __ctype_get_mb_cur_max();\n        if (sVar9 == 1) {\n          param_6 = param_6 - param_7;\n        }\n        else {\n          if (rl_byte_oriented != 0) {\n            uVar17 = param_6 - param_7;\n            goto joined_r0x001e3410;\n          }\n          iVar7 = FUN_001e08f0(param_3,0,param_7,1);\n          param_6 = param_6 - iVar7;\n        }\nLAB_001e3e74:\n        if (param_6 == 0) goto LAB_001e2970;\n      }\n      else {\n        sVar9 = __ctype_get_mb_cur_max();\n        if ((sVar9 != 1) && (rl_byte_oriented == 0)) {\n          param_6 = FUN_001e08f0(param_1,0,param_6,1);\n          if (0 < (int)param_7) goto LAB_001e2944;\n          goto LAB_001e3e74;\n        }\n        if (0 < (int)param_7) goto LAB_001e2944;\n      }\nLAB_001e3b53:\n      if ((rl_byte_oriented == 0) && ((int)_rl_screenwidth <= (int)_rl_last_c_pos))\n      goto LAB_001e2970;\n    }\n    else {\njoined_r0x001e3410:\n      param_6 = uVar17;\n      if (param_6 == 0) goto LAB_001e2970;\n    }\n  }\n  else {\n    if (param_5 == _rl_last_v_pos) {\nLAB_001e3900:\n      FUN_001e1320(local_a8,param_1,param_2);\n      uVar20 = (long)pcVar19 - (long)pcVar15;\n      local_f0._0_4_ = (int)uVar20 - (iVar28 - iVar5);\n      if (iVar8 < 2) goto LAB_001e3945;\n      uVar17 = rl_byte_oriented;\n      uVar13 = (uint)local_f0;\n      if (rl_byte_oriented == 0) {\nLAB_001e388e:\n        local_f0._0_4_ = uVar13;\n        uVar13 = (int)pcVar19 - iVar6;\n        iVar28 = iVar28 - iVar7;\nLAB_001e38a0:\n        uVar24 = 0;\n        uVar20 = (long)pcVar19 - (long)pcVar15;\n        if ((int)local_b0 < (int)uVar13) {\n          sVar9 = __ctype_get_mb_cur_max();\n          if ((sVar9 == 1) || (rl_byte_oriented != 0)) {\n            uVar24 = (ulong)(uVar13 - (int)local_b0);\n          }\n          else {\n            uVar13 = FUN_001e08f0(param_3,local_b0,uVar13,1);\n            uVar24 = (ulong)uVar13;\n          }\n        }\nLAB_001e31f0:\n        if ((int)local_a8 < iVar28) {\n          sVar9 = __ctype_get_mb_cur_max();\n          if ((sVar9 == 1) || (rl_byte_oriented != 0)) {\n            uVar24 = (ulong)(uint)((int)uVar24 - (iVar28 - (int)local_a8));\n          }\n          else {\n            iVar7 = FUN_001e08f0(param_1,local_a8,iVar28,1);\n            uVar24 = (ulong)(uint)((int)uVar24 - iVar7);\n          }\n        }\n      }\n      else {\n        uVar17 = 0;\n        uVar24 = (ulong)(uint)local_f0;\n      }\n      if ((param_5 != 0) || (DAT_0024a888 == uVar17)) goto LAB_001e320a;\n      iVar7 = DAT_0024a888 - uVar17;\n      uVar13 = (uint)local_f0 + iVar7;\n      if (iVar8 < 2) {\n        local_f0 = (ulong)uVar13;\n        goto LAB_001e395b;\n      }\n      local_f0._0_4_ = (uint)uVar24;\nLAB_001e3d14:\n      if (rl_byte_oriented != 0) {\n        uVar24 = (ulong)uVar13;\n        uVar26 = (ulong)(uint)(iVar22 - iVar29);\n        local_f0._0_4_ = uVar13;\n        goto LAB_001e321a;\n      }\n      uVar26 = (ulong)(uint)(iVar22 - iVar29);\n      uVar24 = (ulong)((uint)local_f0 + iVar7);\n      local_f0._0_4_ = uVar13;\nLAB_001e3d34:\n      uVar27 = uVar26;\n      iVar7 = 0;\n      if ((((int)local_b0 < iVar22 - iVar6) &&\n          (sVar9 = __ctype_get_mb_cur_max(), iVar7 = (int)uVar26, sVar9 != 1)) &&\n         (rl_byte_oriented == 0)) {\n        iVar7 = FUN_001e08f0(param_3,local_b0,iVar22 - iVar6,1);\n      }\nLAB_001e322b:\n      iVar6 = (int)uVar27;\n      uVar13 = (uint)uVar24;\n    }\n    else {\n      _rl_move_vert(param_5);\n      if (iVar8 != 1) {\n        uVar17 = rl_byte_oriented;\n        if (rl_byte_oriented == 0) goto LAB_001e3484;\n        goto LAB_001e3900;\n      }\n      FUN_001e1320(local_a8,param_1,param_2);\n      uVar20 = (long)pcVar19 - (long)pcVar15;\n      local_f0._0_4_ = (int)uVar20 - (iVar28 - iVar5);\nLAB_001e3945:\n      local_f0 = (ulong)(uint)local_f0;\n      uVar17 = 0;\n      if (param_5 == 0) {\nLAB_001e3a58:\n        if (uVar17 == DAT_0024a888) goto LAB_001e3f42;\n        local_f0 = (ulong)((uint)local_f0 + (DAT_0024a888 - uVar17));\n      }\nLAB_001e395b:\n      uVar27 = (long)pcVar18 - (long)pcVar15;\n      iVar6 = (int)uVar27;\n      iVar7 = iVar6;\n      uVar13 = (uint)local_f0;\n      uVar24 = local_f0;\n    }\n    if (0 < (int)uVar13) {\n      if ((int)(uint)local_f0 < 0) {\n        FUN_001e0800(pcVar15,local_d0,uVar27 & 0xffffffff);\n        _rl_last_c_pos = iVar7 + _rl_last_c_pos;\n        if (param_5 != 0) goto LAB_001e2970;\n      }\n      else {\n        if (((_rl_terminal_can_insert == 0) ||\n            ((iVar6 = (int)uVar24, iVar7 * 2 < iVar6 && (_rl_term_IC == 0)))) ||\n           ((_rl_vis_botlin <= (int)param_5 && _rl_vis_botlin < param_8 && (_rl_term_autowrap != 0))\n           )) {\n          FUN_001e0800(pcVar15,local_d0,uVar27 & 0xffffffff);\n          _rl_last_c_pos = iVar7 + _rl_last_c_pos;\n          if ((iVar8 < 2) || (rl_byte_oriented != 0)) goto LAB_001e2970;\n          if (_DAT_0024a874 == param_5) {\n            if ((DAT_0024a884 == 0) || (DAT_0024a8cc == 0)) goto LAB_001e2970;\n            if ((DAT_0024a884 != DAT_0024a878) &&\n               ((long)local_80 <\n                (long)(int)(DAT_0024a880 - (param_5 * _rl_screenwidth + DAT_0024a878)))) {\n              DAT_0024a8d4 = 1;\n              _rl_last_c_pos = _rl_last_c_pos - (DAT_0024a884 - DAT_0024a878);\n            }\n            if (param_5 != 0) goto LAB_001e2970;\n          }\n          else if (((param_5 != 0) || (DAT_0024a884 == 0)) || (DAT_0024a8cc == 0))\n          goto LAB_001e2970;\n          if (((DAT_0024a884 != DAT_0024a878) || (DAT_0024a888 == uVar17)) ||\n             ((DAT_0024a884 == DAT_0024a888 || ((long)DAT_0024a880 <= (long)local_80))))\n          goto LAB_001e2970;\nLAB_001e3b2b:\n          _rl_last_c_pos = _rl_last_c_pos - DAT_0024a884;\n          DAT_0024a8d4 = 1;\n          goto LAB_001e2970;\n        }\n        if (*local_c0 == '\\0') {\n          if ((iVar8 == 1) || ((rl_byte_oriented != 0 && ((uint)local_f0 != 0)))) {\nLAB_001e3eab:\n            FUN_001e0800(pcVar15,local_d0,uVar27 & 0xffffffff);\n            _rl_last_c_pos = _rl_last_c_pos + iVar7;\n            goto LAB_001e2970;\n          }\nLAB_001e42df:\n          FUN_001e0800(pcVar15,local_d0,uVar27 & 0xffffffff);\n          _rl_last_c_pos = iVar7 + _rl_last_c_pos;\n          if (iVar8 < 2) goto LAB_001e2970;\n        }\n        else {\n          if ((_rl_horizontal_scroll_mode != 0) &&\n             (((_rl_last_c_pos == 0 && (DAT_0024a88c < (int)(uint)local_f0)) && (0 < (int)uVar17))))\n          {\nLAB_001e42d4:\n            if (iVar8 == 1) goto LAB_001e3eab;\n            goto LAB_001e42df;\n          }\n          if (iVar8 < 2) {\n            if ((int)DAT_0024a888 < (int)uVar17) goto LAB_001e42d4;\nLAB_001e4325:\n            if (_rl_term_IC == 0) {\n              if ((_rl_term_im == (char *)0x0) || (*_rl_term_im == '\\0')) {\n                if ((_rl_term_ic != (char *)0x0) && (*_rl_term_ic != '\\0')) {\n                  uVar20 = uVar20 & 0xffffffff;\n                  do {\n                    iVar6 = iVar6 + -1;\n                    tputs(_rl_term_ic,1,_rl_output_character_function);\n                  } while (iVar6 != 0);\n                }\n              }\n              else {\n                tputs(_rl_term_im,1,_rl_output_character_function);\n                iVar7 = iVar6;\n                do {\n                  iVar7 = iVar7 + -1;\n                  _rl_output_character_function(0x20);\n                } while (iVar7 != 0);\n                if ((_rl_term_ei != (char *)0x0) && (*_rl_term_ei != '\\0')) {\n                  tputs(_rl_term_ei,1,_rl_output_character_function);\n                }\n                _rl_backspace(iVar6);\n                uVar20 = uVar20 & 0xffffffff;\n              }\n            }\n            else {\n              uVar12 = tgoto(_rl_term_IC,0,uVar24);\n              tputs(uVar12,1,_rl_output_character_function);\n              uVar20 = uVar20 & 0xffffffff;\n            }\n            iVar7 = (int)uVar20;\n            FUN_001e0800(pcVar15,local_d0,uVar20 & 0xffffffff);\n            if ((iVar8 < 2) || (rl_byte_oriented != 0)) {\n              _rl_last_c_pos = _rl_last_c_pos + iVar7;\n              goto LAB_001e2970;\n            }\n            if (iVar7 < 1) goto LAB_001e2970;\n            sVar9 = __ctype_get_mb_cur_max();\n            iVar8 = iVar7;\n            if ((sVar9 != 1) && (rl_byte_oriented == 0)) {\n              iVar8 = FUN_001e08f0(pcVar15,0,iVar7,1);\n            }\n            _rl_last_c_pos = _rl_last_c_pos + iVar8;\n            if ((((iVar7 <= (int)(uint)local_f0) || ((param_5 | rl_byte_oriented) != 0)) ||\n                (DAT_0024a8cc == 0)) ||\n               ((DAT_0024a884 == 0 || ((long)DAT_0024a880 < (long)local_80)))) goto LAB_001e2970;\n            goto LAB_001e3b2b;\n          }\n          if (((((param_5 | rl_byte_oriented) != 0) || (DAT_0024a884 == 0)) ||\n              (((long)DAT_0024a880 < (long)local_80 || (DAT_0024a88c <= iVar6)))) &&\n             ((int)uVar17 <= (int)DAT_0024a888)) goto LAB_001e4325;\n          FUN_001e0800(pcVar15,local_d0,uVar27 & 0xffffffff);\n          _rl_last_c_pos = iVar7 + _rl_last_c_pos;\n        }\n        if ((param_5 | rl_byte_oriented) != 0) goto LAB_001e2970;\n      }\n      if (((DAT_0024a8cc != 0) && (DAT_0024a884 != 0)) && ((long)local_80 <= (long)DAT_0024a880)) {\n        DAT_0024a8d4 = 1;\n        _rl_last_c_pos = _rl_last_c_pos - DAT_0024a884;\n      }\n      goto LAB_001e2970;\n    }\n    if ((_rl_term_dc != (char *)0x0) &&\n       (iVar22 = -uVar13, SBORROW4(iVar7 * 2,iVar22) == (int)(iVar7 * 2 + uVar13) < 0)) {\n      if (_rl_horizontal_scroll_mode == 0) {\nLAB_001e39c7:\n        if (uVar13 != 0) {\nLAB_001e4416:\n          if (-_rl_screenwidth == uVar13 || iVar22 < (int)_rl_screenwidth) {\n            if ((_rl_term_DC == (char *)0x0) || (*_rl_term_DC == '\\0')) {\n              if ((*_rl_term_dc != '\\0') && (uVar13 != 0)) {\n                for (iVar7 = -2 - uVar13; tputs(_rl_term_dc,1,_rl_output_character_function),\n                    iVar7 != -1; iVar7 = iVar7 + -1) {\n                }\n                uVar20 = uVar20 & 0xffffffff;\n              }\n            }\n            else {\n              uVar12 = tgoto(_rl_term_DC,iVar22,iVar22);\n              tputs(uVar12,iVar22,_rl_output_character_function);\n              uVar20 = uVar20 & 0xffffffff;\n            }\n          }\n        }\n      }\n      else {\n        if (_rl_last_c_pos != 0) {\n          if (DAT_0024a8cc == 0) goto LAB_001e4405;\n          goto LAB_001e39c7;\n        }\n        if (DAT_0024a8cc == 0) {\nLAB_001e4405:\n          if ((uVar13 == 0) || ((int)_rl_last_c_pos < iVar22)) goto LAB_001e39d0;\n          goto LAB_001e4416;\n        }\n        if ((uint)local_f0 + DAT_0024a888 != 0) goto LAB_001e39c7;\n      }\nLAB_001e39d0:\n      iVar7 = (int)uVar20;\n      if (iVar7 < 1) goto LAB_001e2970;\n      FUN_001e0800(pcVar15,local_d0,uVar20 & 0xffffffff);\n      if ((iVar8 < 2) || (rl_byte_oriented != 0)) {\n        _rl_last_c_pos = _rl_last_c_pos + iVar7;\n      }\n      else {\n        sVar9 = __ctype_get_mb_cur_max();\n        iVar6 = iVar7;\n        if ((sVar9 != 1) && (rl_byte_oriented == 0)) {\n          iVar6 = FUN_001e08f0(pcVar15,0,iVar7,1);\n        }\n        _rl_last_c_pos = iVar6 + _rl_last_c_pos;\n        if ((((param_5 == 0) && (DAT_0024a884 != 0)) && (DAT_0024a8cc != 0)) &&\n           ((((int)DAT_0024a878 <= (int)_rl_last_c_pos && (DAT_0024a878 != 0)) &&\n            ((long)local_80 <= (long)DAT_0024a880)))) {\n          DAT_0024a8d4 = 1;\n          _rl_last_c_pos = _rl_last_c_pos - DAT_0024a878;\n        }\n        if (((_rl_screenwidth == _rl_last_c_pos) &&\n            (piVar14 = (int *)(*(long *)(PTR_DAT_00240518 + 0x20) + 4 + (long)(int)param_5 * 4),\n            *piVar14 != 0)) && (pcVar15[(long)iVar7 + -1] != ' ')) {\n          *piVar14 = 0;\n        }\n      }\n      if (_rl_horizontal_scroll_mode == 0) goto LAB_001e2970;\n      uVar20 = (long)pcVar18 - (long)param_3;\n      lVar10 = (long)pcVar21 - (long)param_1;\n      if (lVar10 <= (long)uVar20) goto LAB_001e2970;\n      FUN_001e1320(uVar20 & 0xffffffff,param_3,param_4);\n      goto LAB_001e33f0;\n    }\n    uVar20 = (long)pcVar18 - (long)param_3;\n    param_7 = (uint)uVar20;\n    lVar10 = (long)pcVar21 - (long)param_1;\n    if (iVar6 < 1) goto LAB_001e33f0;\n    param_6 = (uint)lVar10;\n    uVar17 = param_6 - param_7;\n    FUN_001e0800(pcVar15,local_d0,iVar6);\n    _rl_last_c_pos = iVar7 + _rl_last_c_pos;\n    if (1 < iVar8) {\n      if ((param_5 | rl_byte_oriented) != 0) goto LAB_001e3406;\n      if ((((DAT_0024a884 != 0) && (DAT_0024a8cc != 0)) && ((int)DAT_0024a884 < (int)_rl_last_c_pos)\n          ) && ((long)local_80 <= (long)DAT_0024a880)) {\n        DAT_0024a8d4 = 1;\n        _rl_last_c_pos = _rl_last_c_pos - DAT_0024a884;\n      }\n      goto LAB_001e2930;\n    }\nLAB_001e3b40:\n    param_6 = uVar17;\n    if (param_6 == 0) goto LAB_001e2970;\n    if (iVar8 != 1) goto LAB_001e3b53;\n  }\n  if ((_rl_term_autowrap == 0) || (param_8 <= (int)param_5)) {\n    _rl_clear_to_eol(param_6);\n  }\n  else {\n    uVar17 = 0;\n    if (0 < (int)param_6) {\n      do {\n        uVar17 = uVar17 + 1;\n        putc(0x20,rl_outstream);\n      } while (uVar17 != param_6);\n    }\n    _rl_last_c_pos = _rl_last_c_pos + param_6;\n  }\nLAB_001e2970:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "coproc_fdrestore": "\nvoid coproc_fdrestore(long param_1)\n\n{\n  *(undefined8 *)(param_1 + 0xc) = *(undefined8 *)(param_1 + 0x14);\n  return;\n}\n\n",
  "FUN_001aa080": "\nvoid FUN_001aa080(void)\n\n{\n  echo_input_at_read = verbose_flag;\n  return;\n}\n\n",
  "rl_vi_eword": "\nundefined8 rl_vi_eword(int param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  size_t sVar3;\n  ushort **ppuVar4;\n  int iVar5;\n  int iVar6;\n  \n  if (param_1 == 0) {\n    return 0;\n  }\n  do {\n    if (rl_end + -1 <= rl_point) {\n      return 0;\n    }\n    if (*(char *)(rl_line_buffer + rl_point) == ' ' || *(char *)(rl_line_buffer + rl_point) == '\\t')\n    {\nLAB_001d1607:\n      iVar6 = rl_point;\n      if (rl_point < rl_end) {\n        do {\n          iVar5 = rl_end;\n          bVar1 = *(byte *)(rl_line_buffer + rl_point);\n          if ((bVar1 != 0x20) && (bVar1 != 9)) {\n            ppuVar4 = __ctype_b_loc();\n            if (((*(byte *)(*ppuVar4 + bVar1) & 8) != 0) || (bVar1 == 0x5f)) goto LAB_001d174e;\n            goto LAB_001d16c0;\n          }\n          sVar3 = __ctype_get_mb_cur_max();\n          iVar5 = rl_point;\n          if ((sVar3 == 1) || (rl_byte_oriented != 0)) {\n            rl_point = rl_point + 1;\n          }\n          else {\n            rl_point = _rl_forward_char_internal(1);\n            iVar6 = rl_end;\n            if ((rl_point == iVar5) || (iVar6 = rl_end, rl_end < rl_point)) break;\n          }\n          iVar6 = rl_point;\n        } while (rl_point < rl_end);\n      }\n    }\n    else {\n      iVar6 = rl_point;\n      if (rl_point < rl_end) {\n        sVar3 = __ctype_get_mb_cur_max();\n        iVar5 = rl_point;\n        if ((sVar3 == 1) || (rl_byte_oriented != 0)) {\n          rl_point = rl_point + 1;\n        }\n        else {\n          rl_point = _rl_forward_char_internal(1);\n          iVar6 = rl_end;\n          if ((rl_point == iVar5) || (iVar6 = rl_end, rl_end < rl_point)) goto joined_r0x001d16d6;\n        }\n        goto LAB_001d1607;\n      }\n    }\njoined_r0x001d16d6:\n    rl_point = iVar6;\n    param_1 = param_1 + -1;\n    if (param_1 == 0) {\n      return 0;\n    }\n  } while( true );\nLAB_001d174e:\n  iVar2 = rl_point;\n  iVar6 = rl_point;\n  if (iVar5 <= rl_point) goto joined_r0x001d16d6;\n  sVar3 = __ctype_get_mb_cur_max();\n  iVar6 = rl_point;\n  if ((sVar3 == 1) || (rl_byte_oriented != 0)) {\n    rl_point = rl_point + 1;\n    iVar6 = iVar2;\n  }\n  else {\n    rl_point = _rl_forward_char_internal(1);\n    if ((rl_point == iVar6) || (rl_end < rl_point)) goto joined_r0x001d16d6;\n  }\n  if ((rl_end <= rl_point) ||\n     ((iVar5 = rl_end, (*(byte *)(*ppuVar4 + *(byte *)(rl_line_buffer + rl_point)) & 8) == 0 &&\n      (*(byte *)(rl_line_buffer + rl_point) != 0x5f)))) goto joined_r0x001d16d6;\n  goto LAB_001d174e;\nLAB_001d16c0:\n  iVar2 = rl_point;\n  iVar6 = rl_point;\n  if (iVar5 <= rl_point) goto joined_r0x001d16d6;\n  sVar3 = __ctype_get_mb_cur_max();\n  iVar6 = rl_point;\n  if ((sVar3 == 1) || (rl_byte_oriented != 0)) {\n    rl_point = rl_point + 1;\n    iVar6 = iVar2;\n  }\n  else {\n    rl_point = _rl_forward_char_internal(1);\n    if ((rl_point == iVar6) || (rl_end < rl_point)) goto joined_r0x001d16d6;\n  }\n  if ((rl_end <= rl_point) ||\n     ((((bVar1 = *(byte *)(rl_line_buffer + rl_point), (*(byte *)(*ppuVar4 + bVar1) & 8) != 0 ||\n        (bVar1 == 0x5f)) || (bVar1 == 0x20)) || (iVar5 = rl_end, bVar1 == 9))))\n  goto joined_r0x001d16d6;\n  goto LAB_001d16c0;\n}\n\n",
  "_rl_erase_at_end_of_line": "\nvoid _rl_erase_at_end_of_line(int param_1)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  int iVar3;\n  bool bVar4;\n  \n  _rl_backspace();\n  if (0 < param_1) {\n    iVar2 = 0;\n    do {\n      iVar3 = iVar2;\n      iVar2 = iVar3 + 1;\n      putc(0x20,rl_outstream);\n    } while (param_1 != iVar2);\n    _rl_backspace(param_1);\n    puVar1 = PTR_DAT_00240520;\n    iVar2 = 0;\n    do {\n      _rl_last_c_pos = _rl_last_c_pos + -1;\n      *(undefined *)(*(long *)puVar1 + (long)_rl_last_c_pos) = 0;\n      bVar4 = iVar3 != iVar2;\n      iVar2 = iVar2 + 1;\n    } while (bVar4);\n    rl_display_fixed = rl_display_fixed + 1;\n    return;\n  }\n  _rl_backspace(param_1);\n  rl_display_fixed = rl_display_fixed + 1;\n  return;\n}\n\n",
  "FUN_001bcfa0": "\nundefined8 FUN_001bcfa0(byte *param_1)\n\n{\n  byte *pbVar1;\n  ulong uVar2;\n  byte bVar3;\n  byte *pbVar4;\n  int iVar5;\n  bool bVar6;\n  \n  bVar3 = *param_1;\n  if (bVar3 == 0) {\n    return 0;\n  }\n  iVar5 = 0;\n  bVar6 = bVar3 == 0x5b;\n  pbVar1 = param_1 + 1;\n  if (bVar6) goto LAB_001bcfec;\n  do {\n    pbVar4 = pbVar1;\n    if (bVar3 < 0x5b || bVar6) {\n      if ((byte)(bVar3 - 0x21) < 0x20) {\n        uVar2 = 1L << (bVar3 - 0x21 & 0x3f);\n        if ((uVar2 & 0x80000401) == 0) {\n          if ((uVar2 & 0x40000200) != 0) {\n            return 1;\n          }\n        }\n        else if (param_1[1] == 0x28) {\n          return 1;\n        }\n      }\n    }\n    else if (bVar3 == 0x5c) {\n      if (param_1[1] == 0) {\n        return 0;\n      }\n      pbVar4 = param_1 + 2;\n    }\n    else if ((bVar3 == 0x5d) && (iVar5 != 0)) {\n      return 1;\n    }\n    while( true ) {\n      bVar3 = *pbVar4;\n      if (bVar3 == 0) {\n        return 0;\n      }\n      bVar6 = bVar3 == 0x5b;\n      pbVar1 = pbVar4 + 1;\n      param_1 = pbVar4;\n      if (!bVar6) break;\nLAB_001bcfec:\n      pbVar4 = pbVar1;\n      iVar5 = iVar5 + 1;\n    }\n  } while( true );\n}\n\n",
  "sh_backslash_quote_for_double_quotes": "\nbyte * sh_backslash_quote_for_double_quotes(byte *param_1)\n\n{\n  mbstate_t mVar1;\n  size_t sVar2;\n  size_t sVar3;\n  byte *pbVar4;\n  size_t sVar5;\n  byte bVar6;\n  byte *__s;\n  size_t sVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  byte *pbVar10;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar2 = strlen((char *)param_1);\n  sVar3 = __ctype_get_mb_cur_max();\n  pbVar4 = (byte *)sh_xmalloc(sVar2 * 2 + 1,\"shquote.c\",0x14b);\n  bVar6 = *param_1;\n  pbVar9 = pbVar4;\n  __s = param_1;\n  mVar1 = local_48;\n  do {\n    while( true ) {\n      local_48 = mVar1;\n      if (bVar6 == 0) {\n        *pbVar9 = 0;\n        if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n          return pbVar4;\n        }\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      if ((*(byte *)(&sh_syntaxtab + bVar6) & 0x40) == 0) {\n        if ((bVar6 == 1) || (bVar6 == 0x7f)) {\n          *pbVar9 = 1;\n          pbVar9 = pbVar9 + 1;\n        }\n      }\n      else if (bVar6 != 10) {\n        *pbVar9 = 0x5c;\n        pbVar9 = pbVar9 + 1;\n      }\n      if (locale_utf8locale == 0) break;\n      if ((char)bVar6 < '\\0') goto LAB_001c919b;\nLAB_001c9159:\n      *pbVar9 = bVar6;\n      pbVar10 = pbVar9 + 1;\n      pbVar8 = __s + 1;\nLAB_001c9167:\n      bVar6 = __s[1];\n      pbVar9 = pbVar10;\n      __s = pbVar8;\n      mVar1 = local_48;\n    }\n    if (((int)sVar3 < 2) ||\n       ((*(uint *)(is_basic_table + (ulong)(bVar6 >> 5) * 4) >> (bVar6 & 0x1f) & 1) != 0))\n    goto LAB_001c9159;\nLAB_001c919b:\n    bVar6 = *__s;\n    pbVar10 = pbVar9 + 1;\n    pbVar8 = __s + 1;\n    if (1 < locale_mb_cur_max) {\n      if (((*(uint *)(is_basic_table + (ulong)(bVar6 >> 5) * 4) >> (bVar6 & 0x1f) & 1) == 0) &&\n         (((char)bVar6 < '\\0' || (locale_utf8locale == 0)))) {\n        sVar5 = mbrtowc((wchar_t *)0x0,(char *)__s,(size_t)(param_1 + (sVar2 - (long)__s)),&local_48\n                       );\n        if (sVar5 < 0xfffffffffffffffe) {\n          sVar7 = 1;\n          if (sVar5 != 0) {\n            sVar7 = sVar5;\n          }\n          sVar5 = 0;\n          bVar6 = *__s;\n          while( true ) {\n            pbVar9[sVar5] = bVar6;\n            sVar5 = sVar5 + 1;\n            if (sVar7 == sVar5) break;\n            bVar6 = __s[sVar5];\n          }\n          goto LAB_001c922b;\n        }\n        *pbVar9 = *__s;\n        local_48 = mVar1;\n      }\n      else {\n        *pbVar9 = bVar6;\n        sVar5 = 1;\nLAB_001c922b:\n        pbVar10 = pbVar9 + sVar5;\n        pbVar8 = __s + sVar5;\n        __s = __s + (sVar5 - 1);\n      }\n      goto LAB_001c9167;\n    }\n    *pbVar9 = bVar6;\n    bVar6 = __s[1];\n    pbVar9 = pbVar10;\n    __s = pbVar8;\n  } while( true );\n}\n\n",
  "rl_vi_change_case": "\nundefined8 rl_vi_change_case(int param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  int iVar3;\n  size_t sVar4;\n  ushort **ppuVar5;\n  __int32_t **pp_Var6;\n  wchar_t __wc;\n  long in_FS_OFFSET;\n  wchar_t local_54;\n  mbstate_t local_50;\n  char local_48 [24];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (rl_point < rl_end) {\n    sVar4 = __ctype_get_mb_cur_max();\n    if ((sVar4 < 2) || (rl_byte_oriented != 0)) {\n      if (param_1 != 0) {\n        iVar3 = 0;\n        do {\n          iVar2 = rl_point;\n          if (rl_end <= rl_point) break;\n          ppuVar5 = __ctype_b_loc();\n          bVar1 = *(byte *)(rl_line_buffer + iVar2);\n          if (((*ppuVar5)[bVar1] & 0x100) == 0) {\n            if (((*ppuVar5)[bVar1] & 0x200) == 0) {\n              rl_forward_char(1,iVar3);\n            }\n            else {\n              pp_Var6 = __ctype_toupper_loc();\n              iVar3 = (*pp_Var6)[bVar1];\n              if (iVar3 != 0) goto LAB_001d2f55;\nLAB_001d3005:\n              rl_forward_char(1,0);\n            }\n          }\n          else {\n            pp_Var6 = __ctype_tolower_loc();\n            iVar3 = (*pp_Var6)[bVar1];\n            if (iVar3 == 0) goto LAB_001d3005;\nLAB_001d2f55:\n            rl_begin_undo_group();\n            rl_vi_delete(1,iVar3);\n            if (rl_point < iVar2) {\n              rl_point = rl_point + 1;\n            }\n            _rl_insert_char(1,iVar3);\n            rl_end_undo_group();\n            if ((rl_point != 0) && (rl_point == rl_end)) {\n              sVar4 = __ctype_get_mb_cur_max();\n              if ((sVar4 < 2) || (rl_byte_oriented != 0)) {\n                rl_point = rl_point + -1;\n              }\n              else {\n                rl_point = _rl_find_prev_mbchar(rl_line_buffer,rl_point,1);\n              }\n            }\n          }\n          param_1 = param_1 + -1;\n        } while (param_1 != 0);\n      }\n    }\n    else {\n      local_50.__count = 0;\n      local_50.__value = (_union_27)0x0;\n      iVar3 = _rl_adjust_point(rl_line_buffer,rl_point,&local_50);\n      if (0 < iVar3) {\n        param_1 = param_1 + -1;\n      }\n      if (param_1 != 0) {\n        do {\n          if (rl_end <= rl_point) break;\n          sVar4 = mbrtowc(&local_54,(char *)(rl_point + rl_line_buffer),(long)(rl_end - rl_point),\n                          &local_50);\n          __wc = local_54;\n          if (sVar4 < 0xfffffffffffffffe) {\n            if (sVar4 == 0) {\n              local_54 = L'\\0';\n              goto LAB_001d30b0;\n            }\n            iVar3 = iswupper(local_54);\n            if (iVar3 != 0) goto LAB_001d30c3;\nLAB_001d319c:\n            iVar3 = iswlower(__wc);\n            if ((iVar3 != 0) && (local_54 = towupper(__wc), local_54 != L'\\0')) goto LAB_001d30d6;\nLAB_001d31bb:\n            rl_forward_char(1,0);\n          }\n          else {\n            local_54 = (wchar_t)*(char *)(rl_line_buffer + rl_point);\nLAB_001d30b0:\n            __wc = local_54;\n            iVar3 = iswupper(local_54);\n            if (iVar3 == 0) goto LAB_001d319c;\nLAB_001d30c3:\n            local_54 = towlower(__wc);\n            if (local_54 == L'\\0') goto LAB_001d31bb;\nLAB_001d30d6:\n            iVar3 = rl_point;\n            sVar4 = wcrtomb(local_48,local_54,&local_50);\n            if (-1 < (int)sVar4) {\n              local_48[(int)sVar4] = '\\0';\n            }\n            rl_begin_undo_group();\n            rl_vi_delete(1,0);\n            if ((rl_point < iVar3) && (rl_point < rl_end)) {\n              sVar4 = __ctype_get_mb_cur_max();\n              iVar3 = rl_point;\n              if ((sVar4 == 1) || (rl_byte_oriented != 0)) {\n                rl_point = rl_point + 1;\n              }\n              else {\n                rl_point = _rl_forward_char_internal(1);\n                if ((iVar3 == rl_point) || (rl_end < rl_point)) {\n                  rl_point = rl_end;\n                }\n              }\n            }\n            rl_insert_text(local_48);\n            rl_end_undo_group();\n            if ((rl_point != 0) && (rl_point == rl_end)) {\n              sVar4 = __ctype_get_mb_cur_max();\n              if ((sVar4 < 2) || (rl_byte_oriented != 0)) {\n                rl_point = rl_point + -1;\n              }\n              else {\n                rl_point = _rl_find_prev_mbchar(rl_line_buffer,rl_point,1);\n              }\n            }\n          }\n          param_1 = param_1 + -1;\n        } while (param_1 != 0);\n      }\n    }\n  }\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return 0;\n}\n\n",
  "assign_array_from_string": "\nlong assign_array_from_string(undefined8 param_1,long param_2,uint param_3)\n\n{\n  long lVar1;\n  long lVar2;\n  \n  lVar1 = find_or_make_array_variable(param_1,(-(uint)((param_3 & 4) == 0) & 0xfffffffe) + 3);\n  if ((lVar1 != 0) && (param_2 != 0)) {\n    lVar2 = expand_compound_array_assignment(lVar1,param_2,param_3);\n    assign_compound_array_list(lVar1,lVar2,param_3);\n    if (lVar2 != 0) {\n      dispose_words(lVar2);\n    }\n    *(uint *)(lVar1 + 0x28) = *(uint *)(lVar1 + 0x28) & 0xffffefff;\n  }\n  return lVar1;\n}\n\n",
  "clear_string_list_expander": "\nvoid clear_string_list_expander(long param_1)\n\n{\n  long *plVar1;\n  \n  plVar1 = pushed_string_list;\n  if (pushed_string_list != (long *)0x0) {\n    do {\n      if ((plVar1[3] == param_1) && (plVar1[3] != 0)) {\n        plVar1[3] = 0;\n      }\n      plVar1 = (long *)*plVar1;\n    } while (plVar1 != (long *)0x0);\n  }\n  return;\n}\n\n",
  "xtrace_print_select_command_head": "\nvoid xtrace_print_select_command_head(long param_1)\n\n{\n  char *__s;\n  \n  if (xtrace_fp == (FILE *)0x0) {\n    xtrace_fp = stderr;\n  }\n  __s = (char *)indirection_level_string();\n  fputs(__s,xtrace_fp);\n  __fprintf_chk(xtrace_fp,1,\"select %s in \",**(undefined8 **)(param_1 + 8));\n  xtrace_print_word_list(*(undefined8 *)(param_1 + 0x10),2);\n  return;\n}\n\n",
  "describe_pid": "\nvoid describe_pid(int param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  long *plVar3;\n  long *plVar4;\n  long lVar5;\n  long in_FS_OFFSET;\n  sigset_t sStack_128;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&sStack_128);\n  sigaddset(&sStack_128,0x11);\n  sigemptyset(&local_a8);\n  sigprocmask(0,&sStack_128,&local_a8);\n  if (0 < DAT_0023877c) {\n    lVar5 = 0;\n    do {\n      lVar2 = *(long *)(jobs + lVar5 * 8);\n      if (lVar2 != 0) {\n        plVar3 = *(long **)(lVar2 + 8);\n        iVar1 = *(int *)(plVar3 + 1);\n        plVar4 = plVar3;\n        while( true ) {\n          if (param_1 == iVar1) {\n            __fprintf_chk(stderr,1,\"[%d] %ld\\n\",(int)lVar5 + 1,(long)param_1);\n            sigprocmask(2,&local_a8,(sigset_t *)0x0);\n            if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n              __stack_chk_fail();\n            }\n            return;\n          }\n          plVar4 = (long *)*plVar4;\n          if (plVar3 == plVar4) break;\n          iVar1 = *(int *)(plVar4 + 1);\n        }\n      }\n      lVar5 = lVar5 + 1;\n    } while (DAT_0023877c != lVar5);\n  }\n                    /* WARNING: Subroutine does not return */\n  programming_error(\"describe_pid: %ld: no such pid\",(long)param_1);\n}\n\n",
  "__ctype_tolower_loc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__int32_t ** __ctype_tolower_loc(void)\n\n{\n  __int32_t **pp_Var1;\n  \n  pp_Var1 = (__int32_t **)(*(code *)PTR___ctype_tolower_loc_00237eb0)();\n  return pp_Var1;\n}\n\n",
  "rl_insert_comment": "\nundefined8 rl_insert_comment(void)\n\n{\n  char cVar1;\n  int iVar2;\n  size_t sVar3;\n  char *__s1;\n  ulong uVar4;\n  \n  __s1 = _rl_comment_begin;\n  rl_point = 0;\n  if (_rl_comment_begin == (char *)0x0) {\n    if (rl_explicit_arg == 0) {\n      __s1 = \"#\";\n    }\n    else {\n      cVar1 = '#';\n      uVar4 = 1;\n      __s1 = \"#\";\nLAB_001efe5e:\n      if ((*rl_line_buffer == cVar1) &&\n         (iVar2 = strncmp(__s1,rl_line_buffer,(long)(int)uVar4), iVar2 == 0)) goto LAB_001efeb0;\n    }\n  }\n  else if (rl_explicit_arg != 0) {\n    sVar3 = strlen(_rl_comment_begin);\n    uVar4 = sVar3 & 0xffffffff;\n    if ((int)sVar3 != 0) {\n      cVar1 = *__s1;\n      goto LAB_001efe5e;\n    }\nLAB_001efeb0:\n    rl_delete_text(0,uVar4);\n    goto LAB_001efe88;\n  }\n  rl_insert_text(__s1);\nLAB_001efe88:\n  (*(code *)rl_redisplay_function)();\n  rl_newline(1,10);\n  return 0;\n}\n\n",
  "FUN_0015d040": "\nundefined8 FUN_0015d040(char *param_1)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  undefined4 uVar9;\n  undefined4 uVar10;\n  undefined4 *puVar11;\n  size_t sVar12;\n  undefined8 uVar13;\n  char *pcVar14;\n  long lVar15;\n  \n  pcVar14 = param_1;\n  if (param_1 != (char *)0x0) {\n    for (; cVar1 = *pcVar14, cVar1 != '\\0'; pcVar14 = pcVar14 + 1) {\n      if ((1 < (byte)(cVar1 - 9U)) && (cVar1 != ' ')) {\n        if (0x3ff < DAT_00242344) {\n                    /* WARNING: Subroutine does not return */\n          FUN_0015bcf0(\"expression recursion level exceeded\");\n        }\n        if (DAT_00242340 <= DAT_00242344) {\n          DAT_00242340 = DAT_00242340 + 10;\n          DAT_00242348 = sh_xrealloc(DAT_00242348,(long)DAT_00242340 * 8,\"expr.c\",0x10c);\n        }\n        puVar11 = (undefined4 *)sh_xmalloc(0x58,\"expr.c\",0x10f);\n        uVar2 = (undefined4)DAT_002386c0;\n        uVar3 = DAT_002386c0._4_4_;\n        uVar4 = (undefined4)DAT_002386c8;\n        uVar5 = DAT_002386c8._4_4_;\n        uVar6 = (undefined4)DAT_002386d0;\n        uVar7 = DAT_002386d0._4_4_;\n        uVar8 = (undefined4)DAT_002386d8;\n        uVar9 = DAT_002386d8._4_4_;\n        *(char **)(puVar11 + 2) = DAT_00242460;\n        uVar10 = DAT_00242448;\n        puVar11[0xe] = uVar2;\n        puVar11[0xf] = uVar3;\n        puVar11[0x10] = uVar4;\n        puVar11[0x11] = uVar5;\n        *puVar11 = uVar10;\n        uVar2 = DAT_00242444;\n        puVar11[0x12] = uVar6;\n        puVar11[0x13] = uVar7;\n        puVar11[0x14] = uVar8;\n        puVar11[0x15] = uVar9;\n        puVar11[1] = uVar2;\n        *(char **)(puVar11 + 4) = DAT_00242458;\n        *(undefined8 *)(puVar11 + 6) = DAT_00242450;\n        *(undefined8 *)(puVar11 + 8) = DAT_00242430;\n        *(long *)(puVar11 + 10) = DAT_00242438;\n        puVar11[0xc] = DAT_00242428;\n        lVar15 = (long)DAT_00242344;\n        DAT_00242344 = DAT_00242344 + 1;\n        *(undefined4 **)(DAT_00242348 + lVar15 * 8) = puVar11;\n        sVar12 = strlen(param_1);\n        pcVar14 = (char *)sh_xmalloc(sVar12 + 1,\"expr.c\",0x1d0);\n        DAT_00242458 = strcpy(pcVar14,param_1);\n        DAT_00242444 = 0;\n        DAT_00242448 = 0;\n        DAT_00242438 = 0;\n        DAT_00242430 = 0;\n        DAT_002386c0 = 0;\n        DAT_002386d0 = 0;\n        DAT_002386d8 = 0xffffffffffffffff;\n        DAT_002386c8 = 0xffffffffffffffff;\n        DAT_00242460 = DAT_00242458;\n        do {\n          FUN_0015d330();\n          uVar13 = FUN_0015ccc0();\n        } while (DAT_00242448 == 0x2c);\n        if (DAT_00242448 != 0) {\n                    /* WARNING: Subroutine does not return */\n          FUN_0015bcf0(\"syntax error in expression\");\n        }\n        if (DAT_00242438 != 0) {\n          sh_xfree(DAT_00242438,\"expr.c\",0x1e1);\n        }\n        if (DAT_00242460 != (char *)0x0) {\n          sh_xfree(DAT_00242460,\"expr.c\",0x1e2);\n        }\n        if (DAT_00242344 < 1) {\n          DAT_00242450 = 0;\n          DAT_00242460 = (char *)0x0;\n                    /* WARNING: Subroutine does not return */\n          FUN_0015bcf0(\"recursion stack underflow\");\n        }\n        DAT_00242344 = DAT_00242344 + -1;\n        puVar11 = *(undefined4 **)(DAT_00242348 + (long)DAT_00242344 * 8);\n        DAT_00242460 = *(char **)(puVar11 + 2);\n        DAT_002386c0 = *(undefined8 *)(puVar11 + 0xe);\n        DAT_002386c8 = *(undefined8 *)(puVar11 + 0x10);\n        DAT_002386d0 = *(undefined8 *)(puVar11 + 0x12);\n        DAT_002386d8 = *(undefined8 *)(puVar11 + 0x14);\n        DAT_00242448 = *puVar11;\n        DAT_00242444 = puVar11[1];\n        DAT_00242458 = *(char **)(puVar11 + 4);\n        DAT_00242450 = *(undefined8 *)(puVar11 + 6);\n        DAT_00242430 = *(undefined8 *)(puVar11 + 8);\n        DAT_00242438 = *(long *)(puVar11 + 10);\n        DAT_00242428 = puVar11[0xc];\n        sh_xfree(puVar11,\"expr.c\",299);\n        return uVar13;\n      }\n    }\n  }\n  return 0;\n}\n\n",
  "_rl_timeout_select": "\nint _rl_timeout_select(int param_1,fd_set *param_2,fd_set *param_3,fd_set *param_4,ulong *param_5,\n                      __sigset_t *param_6)\n\n{\n  int iVar1;\n  ulong uVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  uint local_60;\n  uint local_5c;\n  timespec local_58;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = rl_timeout_remaining(&local_60,&local_5c);\n  uVar3 = (ulong)local_60;\n  if (iVar1 == 0) {\n    if (rl_timeout_event_hook != (code *)0x0) {\n      (*rl_timeout_event_hook)();\n    }\n    rl_readline_state = rl_readline_state | 0x4000000;\n                    /* WARNING: Subroutine does not return */\n    _rl_abort_internal();\n  }\n  if (iVar1 == 1) {\n    if (param_5 != (ulong *)0x0) {\n      local_58.tv_sec = *param_5;\n      if (uVar3 == local_58.tv_sec) {\n        uVar2 = param_5[1];\n        if ((long)uVar2 <= (long)(ulong)local_5c) goto LAB_001eb567;\n      }\n      else if (local_58.tv_sec <= (long)uVar3) goto LAB_001eb563;\n    }\n    local_58.tv_nsec = (ulong)local_5c * 1000;\n    local_58.tv_sec = uVar3;\n    iVar1 = pselect(param_1,param_2,param_3,param_4,&local_58,param_6);\n    if (iVar1 == 0) {\n      if (rl_timeout_event_hook != (code *)0x0) {\n        (*rl_timeout_event_hook)();\n      }\n      rl_readline_state = rl_readline_state | 0x4000000;\n                    /* WARNING: Subroutine does not return */\n      _rl_abort_internal();\n    }\n  }\n  else {\n    if (param_5 == (ulong *)0x0) {\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        iVar1 = pselect(param_1,param_2,param_3,param_4,(timespec *)0x0,param_6);\n        return iVar1;\n      }\n      goto LAB_001eb6b2;\n    }\n    local_58.tv_sec = *param_5;\nLAB_001eb563:\n    uVar2 = param_5[1];\nLAB_001eb567:\n    local_58.tv_nsec = uVar2 * 1000;\n    iVar1 = pselect(param_1,param_2,param_3,param_4,&local_58,param_6);\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\nLAB_001eb6b2:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001498b0": "\nvoid FUN_001498b0(long param_1)\n\n{\n  if ((*(byte *)(param_1 + 0x1c) & 1) != 0) {\n    sh_getopt_restore_istate();\n    return;\n  }\n  sh_xfree(param_1,\"execute_cmd.c\",0x138f);\n  return;\n}\n\n",
  "set_sigwinch_handler": "\nvoid set_sigwinch_handler(void)\n\n{\n  DAT_00248540 = set_signal_handler(0x1c,sigwinch_sighandler);\n  return;\n}\n\n",
  "_rl_search_getchar": "\nint _rl_search_getchar(long param_1)\n\n{\n  int iVar1;\n  size_t sVar2;\n  \n  rl_readline_state = rl_readline_state | 0x40;\n  iVar1 = rl_read_key();\n  rl_readline_state = rl_readline_state & 0xffffffffffffffbf;\n  *(int *)(param_1 + 0x6c) = iVar1;\n  if (-1 < iVar1) {\n    sVar2 = __ctype_get_mb_cur_max();\n    if ((1 < sVar2) && (rl_byte_oriented == 0)) {\n      iVar1 = _rl_read_mbstring(*(undefined4 *)(param_1 + 0x6c),param_1 + 0x70,0x10);\n      *(int *)(param_1 + 0x6c) = iVar1;\n    }\n  }\n  if (_rl_caught_signal == 0) {\n    return iVar1;\n  }\n  _rl_signal_handler(_rl_caught_signal);\n  return iVar1;\n}\n\n",
  "make_local_array_variable": "\nlong make_local_array_variable(undefined8 param_1,uint param_2)\n\n{\n  uint uVar1;\n  long lVar2;\n  undefined8 uVar3;\n  \n  lVar2 = make_local_variable(param_1,param_2 & 4);\n  if (lVar2 == 0) {\n    return 0;\n  }\n  uVar1 = *(uint *)(lVar2 + 0x28);\n  if ((uVar1 & 4) != 0) {\n    return lVar2;\n  }\n  if ((param_2 & 1) == 0) {\n    if (localvar_inherit == 0) goto LAB_00154850;\n    if ((uVar1 & 0x40) != 0) {\n      internal_warning(\"%s: cannot inherit value from incompatible type\",param_1);\n      *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) & 0xffffffbf;\n      FUN_001522f0(*(undefined8 *)(lVar2 + 8));\n      uVar3 = array_create();\n      *(undefined8 *)(lVar2 + 8) = uVar3;\n      goto LAB_001547f6;\n    }\n  }\n  else {\n    if ((uVar1 & 0x40) != 0) {\n      return lVar2;\n    }\n    if (localvar_inherit == 0) {\nLAB_00154850:\n      FUN_001522f0(*(undefined8 *)(lVar2 + 8));\n      uVar3 = array_create();\n      *(undefined8 *)(lVar2 + 8) = uVar3;\n      goto LAB_001547f6;\n    }\n  }\n  lVar2 = convert_var_to_array(lVar2);\nLAB_001547f6:\n  *(uint *)(lVar2 + 0x28) = *(uint *)(lVar2 + 0x28) | 4;\n  return lVar2;\n}\n\n",
  "FUN_00192b60": "\nvoid FUN_00192b60(char *param_1)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  byte bVar3;\n  int iVar4;\n  FILE *__stream;\n  char *pcVar5;\n  long lVar6;\n  size_t sVar7;\n  undefined8 *puVar8;\n  uint uVar9;\n  ulong uVar10;\n  long lVar11;\n  byte *pbVar12;\n  long lVar13;\n  uint uVar14;\n  byte *pbVar15;\n  undefined8 *puVar16;\n  undefined8 *puVar17;\n  ulong uVar18;\n  ulong uVar19;\n  long in_FS_OFFSET;\n  byte bVar20;\n  byte local_248 [9];\n  byte local_23f [239];\n  undefined8 uStack_150;\n  undefined8 local_148;\n  long local_40;\n  \n  bVar20 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  __stream = fopen(param_1,\"r\");\n  if (__stream != (FILE *)0x0) {\nLAB_00192bb0:\n    pcVar5 = fgets((char *)local_248,0xff,__stream);\n    if (pcVar5 != (char *)0x0) {\n      lVar6 = 0;\n      bVar3 = local_248[0];\n      while (bVar3 != 0) {\n        if ((0x20 < bVar3) || ((0x100002600U >> ((ulong)bVar3 & 0x3f) & 1) == 0)) {\n          if (bVar3 != 0x23) {\n            uVar18 = (ulong)(int)lVar6;\n            iVar4 = strncmp((char *)(local_248 + uVar18),\"$include \",9);\n            if (iVar4 != 0) {\n              bVar2 = local_248[uVar18];\n              uVar19 = uVar18;\n              if (9 < (byte)(bVar3 - 0x30)) goto LAB_00192c30;\n              goto LAB_00192cd2;\n            }\n            pbVar12 = local_23f + uVar18;\n            bVar3 = *pbVar12;\n            if (bVar3 != 0) goto LAB_00192e8c;\n            goto LAB_00192eb6;\n          }\n          break;\n        }\n        lVar6 = lVar6 + 1;\n        bVar3 = local_248[lVar6];\n      }\n      goto LAB_00192bb0;\n    }\n    fclose(__stream);\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n  while( true ) {\n    bVar3 = pbVar12[1];\n    pbVar12 = pbVar12 + 1;\n    if (bVar3 == 0) break;\nLAB_00192e8c:\n    if ((bVar3 != 0x20) && (bVar3 != 9)) {\n      bVar3 = *pbVar12;\n      if (bVar3 != 0) goto LAB_00192eac;\n      break;\n    }\n  }\n  goto LAB_00192eb6;\n  while( true ) {\n    bVar3 = pbVar12[1];\n    pbVar12 = pbVar12 + 1;\n    if (bVar3 == 0) break;\nLAB_00192eac:\n    if ((bVar3 < 0x21) && ((0x100002600U >> ((ulong)bVar3 & 0x3f) & 1) != 0)) break;\n  }\nLAB_00192eb6:\n  *pbVar12 = 0;\n  FUN_00192b60();\n  goto LAB_00192bb0;\nLAB_00192cd2:\n  if (bVar2 == 0) goto LAB_00192bb0;\n  uVar18 = (ulong)(int)uVar19;\n  if ((bVar2 < 0x21) && ((0x100002600U >> ((ulong)bVar2 & 0x3f) & 1) != 0)) goto LAB_00192c30;\n  uVar19 = uVar19 + 1;\n  bVar2 = local_248[uVar19];\n  goto LAB_00192cd2;\nLAB_00192c30:\n  bVar3 = local_248[uVar18];\n  if (bVar3 != 0) {\n    do {\n      uVar19 = (ulong)bVar3;\n      uVar10 = uVar18 & 0xffffffff;\n      if (bVar3 < 0x21) goto LAB_00192cb0;\n      do {\n        do {\n          if (((char)uVar19 == '\\0') || ((char)uVar19 == '#')) goto LAB_00192bb0;\n          uVar9 = (uint)uVar10;\n          pbVar15 = local_248 + (int)uVar9;\n          pbVar12 = pbVar15;\n          do {\n            uVar14 = (uint)uVar10;\n            if (((byte)uVar19 < 0x21) && ((0x100002600U >> (uVar19 & 0x3f) & 1) != 0)) {\n              if (uVar14 == uVar9) goto LAB_00192c99;\n              goto LAB_00192d18;\n            }\n            pbVar1 = pbVar12 + 1;\n            uVar19 = (ulong)*pbVar1;\n            pbVar12 = pbVar12 + 1;\n            uVar14 = uVar14 + 1;\n            uVar10 = (ulong)uVar14;\n          } while (*pbVar1 != 0);\n          if (uVar9 == uVar14) goto LAB_00192bb0;\nLAB_00192d18:\n          __strncpy_chk(&local_148,pbVar15,(long)(int)(uVar14 - uVar9),0x100);\n          *(undefined *)((long)&local_148 + (long)(int)(uVar14 - uVar9)) = 0;\n          if (DAT_0024885c <= DAT_00248858 + 1) {\n            DAT_0024885c = (DAT_0024885c + 0x20) - DAT_0024885c % 0x20;\n            DAT_00248860 = strvec_resize(DAT_00248860);\n          }\n          sVar7 = strlen((char *)&local_148);\n          uVar18 = sVar7 + 1;\n          puVar8 = (undefined8 *)sh_xmalloc(uVar18,\"bashline.c\",0x319);\n          lVar6 = DAT_00248860;\n          lVar13 = (long)DAT_00248858;\n          DAT_00248858 = DAT_00248858 + 1;\n          uVar9 = (uint)uVar18;\n          if (uVar9 < 8) {\n            if ((uVar18 & 4) == 0) {\n              if (uVar9 != 0) {\n                *(undefined *)puVar8 = (undefined)local_148;\n                if ((uVar18 & 2) != 0) {\n                  *(undefined2 *)((long)puVar8 + ((uVar18 & 0xffffffff) - 2)) =\n                       *(undefined2 *)((long)&uStack_150 + (uVar18 & 0xffffffff) + 6);\n                }\n              }\n            }\n            else {\n              *(undefined4 *)puVar8 = (undefined4)local_148;\n              *(undefined4 *)((long)puVar8 + ((uVar18 & 0xffffffff) - 4)) =\n                   *(undefined4 *)((long)&uStack_150 + (uVar18 & 0xffffffff) + 4);\n            }\n          }\n          else {\n            *puVar8 = CONCAT44(local_148._4_4_,(undefined4)local_148);\n            *(undefined8 *)((long)puVar8 + ((uVar18 & 0xffffffff) - 8)) =\n                 *(undefined8 *)((long)&uStack_150 + (uVar18 & 0xffffffff));\n            lVar11 = (long)puVar8 - (long)(undefined8 *)((ulong)(puVar8 + 1) & 0xfffffffffffffff8);\n            puVar16 = (undefined8 *)((long)&local_148 - lVar11);\n            puVar17 = (undefined8 *)((ulong)(puVar8 + 1) & 0xfffffffffffffff8);\n            for (uVar18 = (ulong)((int)lVar11 + uVar9 >> 3); uVar18 != 0; uVar18 = uVar18 - 1) {\n              *puVar17 = *puVar16;\n              puVar16 = puVar16 + (ulong)bVar20 * -2 + 1;\n              puVar17 = puVar17 + (ulong)bVar20 * -2 + 1;\n            }\n          }\n          *(undefined8 **)(lVar6 + lVar13 * 8) = puVar8;\n          *(undefined8 *)(lVar6 + 8 + lVar13 * 8) = 0;\nLAB_00192c99:\n          uVar18 = (ulong)(int)uVar14;\n          bVar3 = local_248[uVar18];\n          uVar19 = (ulong)bVar3;\n          if (bVar3 == 0) goto LAB_00192bb0;\n          uVar10 = (ulong)uVar14;\n        } while (0x20 < bVar3);\nLAB_00192cb0:\n        uVar18 = uVar18 + 1;\n      } while ((0xfffffffeffffd9ffU >> (uVar19 & 0x3f) & 1) != 0);\n      bVar3 = local_248[uVar18];\n    } while( true );\n  }\n  goto LAB_00192bb0;\n}\n\n",
  "_rl_prev_macro_key": "\nint _rl_prev_macro_key(void)\n\n{\n  int iVar1;\n  \n  if (rl_executing_macro == 0) {\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = DAT_0024b1a0;\n    if (DAT_0024b1a0 != 0) {\n      DAT_0024b1a0 = DAT_0024b1a0 + -1;\n      return (int)*(char *)(rl_executing_macro + DAT_0024b1a0);\n    }\n  }\n  return iVar1;\n}\n\n",
  "_rl_free_history_entry": "\nvoid _rl_free_history_entry(void **param_1)\n\n{\n  if (param_1 != (void **)0x0) {\n    if (*param_1 != (void *)0x0) {\n      free(*param_1);\n    }\n    if (param_1[1] != (void *)0x0) {\n      free(param_1[1]);\n    }\n    xfree(param_1);\n    return;\n  }\n  return;\n}\n\n",
  "rl_insert_close": "\nundefined4 rl_insert_close(undefined8 param_1,int param_2)\n\n{\n  char cVar1;\n  undefined *__s;\n  int iVar2;\n  long lVar3;\n  char *pcVar4;\n  long lVar5;\n  int iVar6;\n  fd_set *pfVar7;\n  undefined4 uVar8;\n  int iVar9;\n  int __c;\n  char *pcVar10;\n  long in_FS_OFFSET;\n  bool bVar11;\n  byte bVar12;\n  int local_dc;\n  timeval local_d8;\n  fd_set local_c8;\n  long local_40;\n  \n  bVar12 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((rl_explicit_arg != 0) || (rl_blink_matching_paren == 0)) {\n    _rl_insert_char();\n    uVar8 = 0;\n    goto LAB_001f8317;\n  }\n  _rl_insert_char(1);\n  (*(code *)rl_redisplay_function)();\n  lVar5 = rl_line_buffer;\n  __s = rl_basic_quote_characters;\n  if (param_2 == 0x5d) {\n    local_dc = 0x5b;\nLAB_001f8398:\n    iVar6 = rl_point + -2;\n    if (-1 < iVar6) {\n      iVar9 = 1;\n      iVar2 = 0;\n      do {\n        lVar3 = (long)iVar6;\n        __c = (int)*(char *)(lVar5 + lVar3);\n        if (iVar2 == 0) {\nLAB_001f83e9:\n          pcVar10 = (char *)(lVar5 + lVar3);\n          cVar1 = *pcVar10;\n          while( true ) {\n            iVar2 = (int)cVar1;\n            if ((__s != (undefined *)0x0) && (pcVar4 = strchr(__s,iVar2), pcVar4 != (char *)0x0))\n            break;\n            if (param_2 == iVar2) {\n              iVar9 = iVar9 + 1;\n            }\n            else if ((iVar2 == local_dc) && (iVar9 = iVar9 + -1, iVar9 == 0)) {\n              pfVar7 = &local_c8;\n              for (lVar5 = 0x10; lVar5 != 0; lVar5 = lVar5 + -1) {\n                pfVar7->fds_bits[0] = 0;\n                pfVar7 = (fd_set *)((long)pfVar7 + ((ulong)bVar12 * -2 + 1) * 8);\n              }\n              iVar9 = fileno(rl_instream);\n              iVar2 = fileno(rl_instream);\n              lVar5 = __fdelt_chk((long)iVar2);\n              iVar2 = rl_point;\n              local_c8.fds_bits[lVar5] = local_c8.fds_bits[lVar5] | 1L << ((byte)iVar9 & 0x3f);\n              local_d8.tv_sec = (__time_t)(DAT_00240760 / 1000000);\n              local_d8.tv_usec = (__suseconds_t)(DAT_00240760 % 1000000);\n              rl_point = iVar6;\n              (*(code *)rl_redisplay_function)();\n              select(1,&local_c8,(fd_set *)0x0,(fd_set *)0x0,&local_d8);\n              uVar8 = 0;\n              rl_point = iVar2;\n              goto LAB_001f8317;\n            }\n            if (iVar6 + -1 == -1) goto LAB_001f8383;\n            pcVar10 = pcVar10 + -1;\n            cVar1 = *pcVar10;\n            iVar6 = iVar6 + -1;\n          }\n        }\n        else {\n          if (__c == iVar2) {\n            bVar11 = iVar6 != 0;\n            iVar6 = iVar6 + -1;\n            if (bVar11) {\n              lVar3 = (long)iVar6;\n              goto LAB_001f83e9;\n            }\n            break;\n          }\n          if ((__s != (undefined *)0x0) && (pcVar10 = strchr(__s,__c), pcVar10 != (char *)0x0)) {\n            iVar2 = __c;\n          }\n        }\n        bVar11 = iVar6 != 0;\n        iVar6 = iVar6 + -1;\n      } while (bVar11);\n    }\n  }\n  else {\n    if (param_2 == 0x7d) {\n      local_dc = 0x7b;\n      goto LAB_001f8398;\n    }\n    if (param_2 == 0x29) {\n      local_dc = 0x28;\n      goto LAB_001f8398;\n    }\n  }\nLAB_001f8383:\n  uVar8 = 1;\nLAB_001f8317:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar8;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001b8b90": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong FUN_001b8b90(void)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long lVar4;\n  char *pcVar5;\n  undefined8 *puVar6;\n  long in_FS_OFFSET;\n  char *local_28;\n  long local_20;\n  \n  puVar6 = DAT_00248db8;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00248db8 == (undefined8 *)0x0) {\n    lVar4 = 0;\n  }\n  else {\n    pcVar5 = *(char **)DAT_00248db8[1];\n    cVar1 = *pcVar5;\n    if ((cVar1 == '\\'') || (cVar1 == '\\\"')) {\n      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n        lVar4 = FUN_001b8480();\n        return lVar4;\n      }\n      goto LAB_001b8ca9;\n    }\n    piVar3 = __errno_location();\n    *piVar3 = 0;\n    lVar4 = strtoimax(pcVar5,&local_28,0);\n    if (*local_28 == '\\0') {\n      if (*piVar3 == 0x22) {\n        uVar2 = *(undefined8 *)puVar6[1];\n        pcVar5 = strerror(0x22);\n        builtin_error(\"warning: %s: %s\",uVar2,pcVar5);\n        puVar6 = DAT_00248db8;\n      }\n    }\n    else {\n      sh_invalidnum(*(undefined8 *)puVar6[1]);\n      _DAT_00248db0 = 1;\n      puVar6 = DAT_00248db8;\n    }\n    DAT_00248db8 = (undefined8 *)*puVar6;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar4;\n  }\nLAB_001b8ca9:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "_rl_backspace": "\nundefined8 _rl_backspace(int param_1)\n\n{\n  int iVar1;\n  \n  if (_rl_term_backspace == 0) {\n    iVar1 = 0;\n    if (0 < param_1) {\n      do {\n        iVar1 = iVar1 + 1;\n        putc(8,_rl_out_stream);\n      } while (param_1 != iVar1);\n      return 0;\n    }\n  }\n  else if (0 < param_1) {\n    iVar1 = 0;\n    do {\n      iVar1 = iVar1 + 1;\n      tputs(_rl_term_backspace,1,_rl_output_character_function);\n    } while (param_1 != iVar1);\n  }\n  return 0;\n}\n\n",
  "FUN_001df160": "\n/* WARNING: Removing unreachable block (ram,0x001dfe35) */\n/* WARNING: Removing unreachable block (ram,0x001dfdb7) */\n\nundefined4 FUN_001df160(long param_1,ulong param_2)\n\n{\n  undefined8 *puVar1;\n  char cVar2;\n  bool bVar3;\n  undefined4 uVar4;\n  int iVar5;\n  int iVar6;\n  char *pcVar7;\n  size_t sVar8;\n  long lVar9;\n  long lVar10;\n  char *pcVar11;\n  undefined8 uVar12;\n  code *pcVar13;\n  ushort **ppuVar14;\n  __int32_t **pp_Var15;\n  undefined *puVar16;\n  uint uVar18;\n  long lVar19;\n  uint uVar20;\n  ulong uVar21;\n  long lVar22;\n  int iVar23;\n  int iVar24;\n  char **ppcVar25;\n  long in_FS_OFFSET;\n  int local_6c;\n  uint local_54;\n  int local_48;\n  undefined4 uStack_44;\n  long local_40;\n  long lVar17;\n  \n  uVar21 = param_2 & 0xffffffff;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  _rl_add_executing_keyseq(param_2 & 0xffffffff);\n  if ((_rl_enable_bracketed_paste != 0) && ((int)uVar21 == 0x1b)) {\n    pcVar7 = strchr(*(char **)(param_1 + 0xa0),0x1b);\n    if ((pcVar7 == (char *)0x0) || (iVar6 = _rl_nchars_available(), iVar6 < 6)) {\n      lVar22 = 0x1b0;\n      uVar21 = 0x1b;\n      goto LAB_001df1a8;\n    }\n    iVar6 = _rl_read_bracketed_paste_prefix(0x1b);\n    if (iVar6 != 1) {\n      iVar6 = _rl_pushed_input_available();\n      if (iVar6 == 0) {\n        uVar21 = (ulong)*(uint *)(param_1 + 0x6c);\n      }\n      else {\n        uVar20 = rl_read_key();\n        *(uint *)(param_1 + 0x6c) = uVar20;\n        uVar21 = (ulong)uVar20;\n      }\n      goto LAB_001df19d;\n    }\n    *(undefined4 *)(param_1 + 0x6c) = 0xfffffff9;\nswitchD_001df37d_caseD_fffffff9:\n    pcVar7 = (char *)_rl_bracketed_text(&local_48);\n    if ((pcVar7 != (char *)0x0) && (*pcVar7 != '\\0')) {\n      if (_rl_enable_active_region != 0) {\n        rl_activate_mark();\n      }\n      lVar9 = (long)*(int *)(param_1 + 0x10);\n      sVar8 = CONCAT44(uStack_44,local_48);\n      lVar22 = *(long *)(param_1 + 8);\n      if ((ulong)(long)*(int *)(param_1 + 0x14) <= lVar9 + 1 + sVar8) {\n        iVar6 = *(int *)(param_1 + 0x14) + 2 + local_48;\n        *(int *)(param_1 + 0x14) = iVar6;\n        lVar22 = xrealloc(lVar22,(long)iVar6);\n        sVar8 = CONCAT44(uStack_44,local_48);\n        *(long *)(param_1 + 8) = lVar22;\n        lVar9 = (long)*(int *)(param_1 + 0x10);\n      }\n      memcpy((void *)(lVar22 + lVar9),pcVar7,sVar8);\n      local_48 = *(int *)(param_1 + 0x10) + local_48;\n      *(int *)(param_1 + 0x10) = local_48;\n      *(undefined *)(*(long *)(param_1 + 8) + (long)local_48) = 0;\n    }\n    xfree(pcVar7);\n    local_6c = *(int *)(param_1 + 0x10);\n    local_54 = *(uint *)(param_1 + 4);\n    goto LAB_001df4fb;\n  }\nLAB_001df19d:\n  if (-1 < (int)uVar21) {\n    lVar22 = (long)(int)uVar21 << 4;\nLAB_001df1a8:\n    lVar9 = *(long *)(param_1 + 0x50);\n    cVar2 = *(char *)(lVar9 + lVar22);\n    iVar6 = (int)uVar21;\n    if (cVar2 != '\\x01') {\nLAB_001df1bd:\n      if (cVar2 != '\\0') goto LAB_001df1c5;\n      sVar8 = __ctype_get_mb_cur_max();\n      if (((sVar8 < 2) || (rl_byte_oriented != 0)) || (*(char *)(param_1 + 0x71) == '\\0')) {\n        lVar9 = *(long *)(param_1 + 0x50);\n        pcVar13 = *(code **)(lVar9 + 8 + lVar22);\n        if (pcVar13 != (code *)PTR_rl_do_lowercase_version_00237fa0) goto LAB_001df3b6;\n        ppuVar14 = __ctype_b_loc();\n        if ((*(byte *)((long)*ppuVar14 + (uVar21 & 0xff) * 2 + 1) & 1) != 0) {\n          pp_Var15 = __ctype_tolower_loc();\n          pcVar13 = *(code **)(lVar9 + 8 + (long)(*pp_Var15)[uVar21 & 0xff] * 0x10);\n          goto LAB_001df3b6;\n        }\n        uVar20 = *(uint *)(param_1 + 4);\nLAB_001df3da:\n        if (pcVar13 == (code *)PTR_rl_rubout_00237f28) {\n          uVar18 = 0xfffffffd;\n        }\n        else if ((pcVar13 == (code *)PTR_rl_abort_00237fd0) || (iVar6 == 7)) {\n          uVar18 = 0xfffffffc;\n        }\n        else if ((iVar6 == 0x17) || (pcVar13 == (code *)PTR_rl_unix_word_rubout_00237f78)) {\n          uVar18 = 0xfffffffb;\n        }\n        else if ((iVar6 == 0x19) || (pcVar13 == (code *)PTR_rl_yank_00237f58)) {\n          uVar18 = 0xfffffffa;\n        }\n        else {\n          if (pcVar13 != (code *)PTR_rl_bracketed_paste_begin_00237f90) {\n            iVar24 = *(int *)(param_1 + 0x6c);\n            goto LAB_001df1cf;\n          }\n          uVar18 = 0xfffffff9;\n        }\n      }\n      else {\n        pcVar13 = (code *)rl_function_of_keyseq(param_1 + 0x70,*(undefined8 *)(param_1 + 0x50),0);\nLAB_001df3b6:\n        uVar20 = *(uint *)(param_1 + 4);\n        if (pcVar13 == rl_reverse_search_history) {\n          uVar18 = uVar20 | 0xfffffffe;\n        }\n        else {\n          if (pcVar13 != rl_forward_search_history) goto LAB_001df3da;\n          uVar18 = ~(uVar20 & 1);\n        }\n      }\n      *(uint *)(param_1 + 0x6c) = uVar18;\n      if ((uVar20 & 8) != 0) {\n        *(uint *)(param_1 + 4) = uVar20 & 0xfffffff7;\n        *(undefined8 *)(param_1 + 0x50) = *(undefined8 *)(param_1 + 0x58);\n      }\n      goto LAB_001df2e7;\n    }\n    iVar24 = *(int *)(param_1 + 0x6c);\n    pcVar7 = strchr(*(char **)(param_1 + 0xa0),iVar24);\n    if (pcVar7 != (char *)0x0) {\n      uVar20 = *(uint *)(param_1 + 4);\n      pcVar13 = (code *)0x0;\n      goto LAB_001df1cf;\n    }\n    if ((_rl_keyseq_timeout < 1) || ((rl_readline_state & 0xa0000) != 0)) {\n      lVar10 = *(long *)((char *)(lVar9 + lVar22) + 8);\n    }\n    else {\n      iVar24 = _rl_pushed_input_available();\n      lVar9 = *(long *)(param_1 + 0x50);\n      lVar10 = *(long *)(lVar9 + 8 + lVar22);\n      if ((iVar24 == 0) && (*(long *)(lVar10 + 0x1008) != 0)) {\n        iVar24 = _rl_input_queued(_rl_keyseq_timeout * 1000);\n        if (iVar24 == 0) {\n          cVar2 = *(char *)(*(long *)(param_1 + 0x50) + lVar22);\n          goto LAB_001df1bd;\n        }\n        lVar9 = *(long *)(param_1 + 0x50);\n        lVar10 = *(long *)(lVar9 + 8 + lVar22);\n      }\n    }\n    *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 8;\n    *(long *)(param_1 + 0x58) = lVar9;\n    *(long *)(param_1 + 0x50) = lVar10;\n    *(int *)(param_1 + 0x68) = iVar6;\n    sVar8 = __ctype_get_mb_cur_max();\n    if ((1 < sVar8) && (rl_byte_oriented == 0)) {\n      if (*(char *)(param_1 + 0x71) == '\\0') {\n        *(char *)(param_1 + 0x80) = (char)uVar21;\n        uVar4 = 1;\n        *(undefined *)(param_1 + 0x81) = 0;\n      }\n      else {\n        uVar4 = 1;\n        *(undefined4 *)(param_1 + 0x80) = *(undefined4 *)(param_1 + 0x70);\n        *(undefined4 *)(param_1 + 0x84) = *(undefined4 *)(param_1 + 0x74);\n        *(undefined4 *)(param_1 + 0x88) = *(undefined4 *)(param_1 + 0x78);\n        *(undefined4 *)(param_1 + 0x8c) = *(undefined4 *)(param_1 + 0x7c);\n      }\n      goto LAB_001df201;\n    }\n    goto LAB_001df84f;\n  }\nLAB_001df1c5:\n  iVar24 = *(int *)(param_1 + 0x6c);\n  uVar20 = *(uint *)(param_1 + 4);\n  pcVar13 = (code *)0x0;\nLAB_001df1cf:\n  if ((uVar20 & 8) != 0) {\n    *(uint *)(param_1 + 4) = uVar20 & 0xfffffff7;\n    *(long *)(param_1 + 0x50) = *(long *)(param_1 + 0x58);\n    if (iVar24 < 1) goto LAB_001df2e7;\n    uVar20 = *(uint *)(param_1 + 0x68);\n    if (0x1f < (int)uVar20) {\n      if (uVar20 - 0x7f < 0x81) {\nLAB_001df482:\n        uVar4 = 0;\n        rl_stuff_char(iVar24);\n        rl_execute_next(*(undefined4 *)(param_1 + 0x68));\n        goto LAB_001df201;\n      }\nLAB_001df259:\n      if (*(char *)(*(long *)(param_1 + 0x58) + (long)(int)uVar20 * 0x10) == '\\x01') {\n        if ((pcVar13 == (code *)0x0) || (pcVar13 == (code *)PTR_rl_insert_00237f40)) {\n          rl_execute_next(iVar24);\n          *(undefined4 *)(param_1 + 0x6c) = *(undefined4 *)(param_1 + 0x68);\n          sVar8 = __ctype_get_mb_cur_max();\n          iVar24 = *(int *)(param_1 + 0x6c);\n          if ((1 < sVar8) && (rl_byte_oriented == 0)) {\n            if (*(char *)(param_1 + 0x81) == '\\0') {\n              *(char *)(param_1 + 0x70) = (char)iVar24;\n              *(undefined *)(param_1 + 0x71) = 0;\n            }\n            else {\n              *(undefined4 *)(param_1 + 0x70) = *(undefined4 *)(param_1 + 0x80);\n              *(undefined4 *)(param_1 + 0x74) = *(undefined4 *)(param_1 + 0x84);\n              *(undefined4 *)(param_1 + 0x78) = *(undefined4 *)(param_1 + 0x88);\n              *(undefined4 *)(param_1 + 0x7c) = *(undefined4 *)(param_1 + 0x8c);\n            }\n          }\n          *(undefined4 *)(param_1 + 0x68) = 0;\n          goto LAB_001df1d3;\n        }\n      }\n      else if ((pcVar13 == (code *)PTR_rl_insert_00237f40 || pcVar13 == (code *)0x0) ||\n              ((int)uVar20 < 1)) goto LAB_001df1dc;\n      _rl_term_executing_keyseq();\n      _rl_pending_command._0_8_ = *(undefined8 *)(param_1 + 0x50);\n      uVar4 = 0;\n      _rl_pending_command._8_4_ = 1;\n      _rl_pending_command._12_4_ = *(undefined4 *)(param_1 + 0x6c);\n      _rl_command_to_execute = _rl_pending_command;\n      _rl_pending_command._16_8_ = pcVar13;\n      goto LAB_001df201;\n    }\n    if ((uVar20 & 0x80) == 0) {\n      if (uVar20 != 7) goto LAB_001df482;\n      goto LAB_001df259;\n    }\nLAB_001df1dc:\n    pcVar7 = strchr(*(char **)(param_1 + 0xa0),iVar24);\n    if (pcVar7 == (char *)0x0) goto LAB_001df2e7;\n    if ((iVar24 == 0x1b) &&\n       ((iVar6 = _rl_pushed_input_available(), iVar6 != 0 ||\n        (iVar6 = _rl_input_available(), iVar6 != 0)))) {\n      iVar6 = 0x1b;\n      goto LAB_001df34b;\n    }\nLAB_001df1fe:\n    uVar4 = 0;\n    goto LAB_001df201;\n  }\nLAB_001df1d3:\n  if (0 < iVar24) goto LAB_001df1dc;\nLAB_001df2e7:\n  sVar8 = __ctype_get_mb_cur_max();\n  iVar6 = *(int *)(param_1 + 0x6c);\n  if ((sVar8 < 2) || (rl_byte_oriented != 0)) {\n    if (-1 < iVar6) {\n      if (iVar6 < 0x20) {\n        if (iVar6 != 7) goto LAB_001df34b;\n      }\n      else if (iVar6 - 0x7fU < 0x81) {\nLAB_001df34b:\n        rl_execute_next(iVar6);\n        goto LAB_001df1fe;\n      }\n    }\n  }\n  else if (((-1 < iVar6) && (*(char *)(param_1 + 0x70) != '\\0')) &&\n          (*(char *)(param_1 + 0x71) == '\\0')) {\n    if (iVar6 < 0x20) {\n      if (iVar6 != 7) goto LAB_001df327;\n    }\n    else if (iVar6 - 0x7fU < 0x81) {\nLAB_001df327:\n      rl_execute_next();\n      uVar4 = 0;\n      goto LAB_001df201;\n    }\n  }\n  _rl_init_executing_keyseq();\n  switch(*(undefined4 *)(param_1 + 0x6c)) {\n  default:\n    iVar6 = 1;\n    if (((*(char *)(param_1 + 0x70) != '\\0') && (*(char *)(param_1 + 0x71) != '\\0')) &&\n       (iVar6 = 2, *(char *)(param_1 + 0x72) != '\\0')) {\n      sVar8 = strlen((char *)(param_1 + 0x70));\n      iVar6 = (int)sVar8;\n    }\n    if (*(int *)(param_1 + 0x14) <= *(int *)(param_1 + 0x10) + iVar6 + 1) {\n      iVar24 = *(int *)(param_1 + 0x14) + 0x80;\n      *(int *)(param_1 + 0x14) = iVar24;\n      uVar12 = xrealloc(*(undefined8 *)(param_1 + 8),(long)iVar24);\n      *(undefined8 *)(param_1 + 8) = uVar12;\n    }\n    sVar8 = __ctype_get_mb_cur_max();\n    if ((sVar8 < 2) || (rl_byte_oriented != 0)) {\n      iVar6 = *(int *)(param_1 + 0x10);\n      *(int *)(param_1 + 0x10) = iVar6 + 1;\n      *(char *)(*(long *)(param_1 + 8) + (long)iVar6) = (char)*(undefined4 *)(param_1 + 0x6c);\n    }\n    else {\n      cVar2 = *(char *)(param_1 + 0x70);\n      if ((cVar2 == '\\0') || (*(char *)(param_1 + 0x71) == '\\0')) {\n        iVar6 = *(int *)(param_1 + 0x10);\n        *(int *)(param_1 + 0x10) = iVar6 + 1;\n        *(char *)(*(long *)(param_1 + 8) + (long)iVar6) = cVar2;\n      }\n      else if (0 < iVar6) {\n        lVar22 = param_1;\n        while( true ) {\n          iVar24 = *(int *)(param_1 + 0x10);\n          *(int *)(param_1 + 0x10) = iVar24 + 1;\n          *(char *)(*(long *)(param_1 + 8) + (long)iVar24) = cVar2;\n          if (lVar22 == (ulong)(iVar6 - 1) + param_1) break;\n          cVar2 = *(char *)(lVar22 + 0x71);\n          lVar22 = lVar22 + 1;\n        }\n      }\n    }\n    *(undefined *)(*(long *)(param_1 + 8) + (long)*(int *)(param_1 + 0x10)) = 0;\n    local_6c = *(int *)(param_1 + 0x10);\n    local_54 = *(uint *)(param_1 + 4);\n    break;\n  case 0xfffffff9:\n    goto switchD_001df37d_caseD_fffffff9;\n  case 0xfffffffa:\n    iVar6 = *(int *)(param_1 + 0x10);\n    iVar24 = rl_point + iVar6;\n    if (rl_end <= iVar24) goto LAB_001df7ef;\n    lVar22 = *(long *)(param_1 + 8);\n    if (iVar6 + 2 + (rl_end - iVar24) < *(int *)(param_1 + 0x14)) {\nLAB_001df717:\n      lVar9 = (long)iVar24;\n      while( true ) {\n        lVar10 = rl_line_buffer;\n        *(int *)(param_1 + 0x10) = iVar6 + 1;\n        puVar16 = (undefined *)(lVar10 + lVar9);\n        lVar9 = lVar9 + 1;\n        *(undefined *)(lVar22 + iVar6) = *puVar16;\n        lVar22 = *(long *)(param_1 + 8);\n        if (rl_end <= (int)lVar9) break;\n        iVar6 = *(int *)(param_1 + 0x10);\n      }\n    }\n    else {\n      iVar6 = (rl_end - iVar24) + 2 + *(int *)(param_1 + 0x14);\n      *(int *)(param_1 + 0x14) = iVar6;\n      lVar22 = xrealloc(lVar22,(long)iVar6);\n      iVar6 = rl_end;\n      *(long *)(param_1 + 8) = lVar22;\n      if (iVar24 < iVar6) {\n        iVar6 = *(int *)(param_1 + 0x10);\n        goto LAB_001df717;\n      }\n    }\n    lVar9 = (long)*(int *)(param_1 + 0x10);\nLAB_001df752:\n    *(undefined *)(lVar22 + lVar9) = 0;\n    local_6c = *(int *)(param_1 + 0x10);\n    local_54 = *(uint *)(param_1 + 4);\n    break;\n  case 0xfffffffb:\n    iVar6 = rl_point + *(int *)(param_1 + 0x10);\n    if (iVar6 < rl_end) {\n      uVar4 = _rl_char_value(rl_line_buffer,iVar6);\n      iVar24 = _rl_walphabetic(uVar4);\n      if (iVar24 != 0) {\n        sVar8 = __ctype_get_mb_cur_max();\n        if ((sVar8 < 2) || (rl_byte_oriented != 0)) {\n          iVar24 = iVar6 + 1;\n        }\n        else {\n          iVar24 = _rl_find_next_mbchar(rl_line_buffer,iVar6,1,1);\n        }\n        if (iVar24 < rl_end) {\n          do {\n            uVar4 = _rl_char_value(rl_line_buffer,iVar24);\n            iVar23 = _rl_walphabetic(uVar4);\n            if (iVar23 == 0) break;\n            sVar8 = __ctype_get_mb_cur_max();\n            if ((sVar8 < 2) || (rl_byte_oriented != 0)) {\n              iVar24 = iVar24 + 1;\n            }\n            else {\n              iVar24 = _rl_find_next_mbchar(rl_line_buffer,iVar24,1,1);\n            }\n          } while (iVar24 < rl_end);\n        }\n        iVar23 = *(int *)(param_1 + 0x10);\n        lVar22 = *(long *)(param_1 + 8);\n        if (*(int *)(param_1 + 0x14) <= (iVar24 - iVar6) + 2 + iVar23) {\n          iVar23 = (iVar24 - iVar6) + 2 + *(int *)(param_1 + 0x14);\n          *(int *)(param_1 + 0x14) = iVar23;\n          lVar22 = xrealloc(lVar22,(long)iVar23);\n          *(long *)(param_1 + 8) = lVar22;\n          iVar23 = *(int *)(param_1 + 0x10);\n        }\n        lVar9 = (long)iVar23;\n        if (iVar6 < iVar24) {\n          lVar10 = (long)iVar6 + 1;\n          lVar17 = (long)iVar6;\n          lVar19 = lVar10;\n          while( true ) {\n            puVar16 = (undefined *)(lVar17 + rl_line_buffer);\n            *(int *)(param_1 + 0x10) = (int)lVar9 + 1;\n            *(undefined *)(lVar22 + lVar9) = *puVar16;\n            lVar22 = *(long *)(param_1 + 8);\n            lVar9 = (long)*(int *)(param_1 + 0x10);\n            if ((ulong)((iVar24 - iVar6) - 1) + lVar10 == lVar19) break;\n            lVar17 = lVar19;\n            lVar19 = lVar19 + 1;\n          }\n        }\n        goto LAB_001df752;\n      }\n    }\n    goto LAB_001df7ef;\n  case 0xfffffffc:\n    uVar4 = 0xffffffff;\n    rl_replace_line(*(undefined8 *)(*(long *)(param_1 + 0x18) + (long)*(int *)(param_1 + 0x38) * 8),\n                    0);\n    rl_point = *(int *)(param_1 + 0x30);\n    rl_mark = *(int *)(param_1 + 0x34);\n    rl_deactivate_mark();\n    rl_restore_prompt();\n    rl_clear_message();\n    _rl_fix_point(1);\n    goto LAB_001df201;\n  case 0xfffffffd:\n    if (*(int *)(param_1 + 0x10) == 0) {\n      rl_ding();\n    }\n    else {\n      sVar8 = __ctype_get_mb_cur_max();\n      if ((sVar8 == 1) || (rl_byte_oriented != 0)) {\n        iVar6 = *(int *)(param_1 + 0x10) + -1;\n        *(int *)(param_1 + 0x10) = iVar6;\n        *(undefined *)(*(long *)(param_1 + 8) + (long)iVar6) = 0;\n      }\n      else {\n        iVar6 = _rl_find_prev_mbchar(*(undefined8 *)(param_1 + 8),*(undefined4 *)(param_1 + 0x10),1)\n        ;\n        if (iVar6 < 0) {\n          *(undefined4 *)(param_1 + 0x10) = 0;\n          **(undefined **)(param_1 + 8) = 0;\n        }\n        else {\n          *(int *)(param_1 + 0x10) = iVar6;\n          *(undefined *)(*(long *)(param_1 + 8) + (long)iVar6) = 0;\n        }\n      }\n    }\n    local_6c = *(int *)(param_1 + 0x10);\n    if (local_6c != 0) {\n      local_54 = *(uint *)(param_1 + 4);\nLAB_001df5cc:\n      local_54 = local_54 & 0xfffffff9;\n      *(uint *)(param_1 + 4) = local_54;\n      goto LAB_001df514;\n    }\nLAB_001df7ef:\n    rl_ding();\n    local_6c = *(int *)(param_1 + 0x10);\n    local_54 = *(uint *)(param_1 + 4);\n    break;\n  case 0xfffffffe:\n    iVar6 = *(int *)(param_1 + 100);\n    *(int *)(param_1 + 100) = -iVar6;\n    local_6c = *(int *)(param_1 + 0x10);\n    local_54 = *(uint *)(param_1 + 4) & 0xfffffffe;\n    if (0 < iVar6) {\n      local_54 = *(uint *)(param_1 + 4) | 1;\n    }\n    break;\n  case 0xffffffff:\n    local_6c = *(int *)(param_1 + 0x10);\n    if (local_6c != 0) {\n      local_54 = *(uint *)(param_1 + 4);\n      iVar6 = *(int *)(param_1 + 0x9c);\n      if (((local_54 & 1) == 0) || (iVar6 < 0)) {\n        if (*(int *)(param_1 + 0x98) == iVar6) goto LAB_001df7ef;\n        *(int *)(param_1 + 0x9c) = iVar6 + 1;\n      }\n      else {\n        *(int *)(param_1 + 0x9c) = iVar6 + -1;\n      }\n      goto LAB_001df5cc;\n    }\n    if (DAT_0024a7d8 == (char *)0x0) goto LAB_001df84f;\n    iVar6 = DAT_0024a7d0 + 0x40;\n    *(int *)(param_1 + 0x14) = iVar6;\n    pcVar11 = (char *)xrealloc(*(undefined8 *)(param_1 + 8),(long)iVar6);\n    pcVar7 = DAT_0024a7d8;\n    *(char **)(param_1 + 8) = pcVar11;\n    strcpy(pcVar11,pcVar7);\n    *(int *)(param_1 + 0x10) = DAT_0024a7d0;\n    FUN_001df030(*(undefined8 *)(param_1 + 8),*(undefined4 *)(param_1 + 4));\n    local_6c = *(int *)(param_1 + 0x10);\n    local_54 = *(uint *)(param_1 + 4);\n  }\nLAB_001df4fb:\n  local_54 = local_54 & 0xfffffff9;\n  *(uint *)(param_1 + 4) = local_54;\n  if (local_6c != 0) {\nLAB_001df514:\n    iVar6 = *(int *)(param_1 + 0x98);\n    iVar24 = *(int *)(param_1 + 0x9c);\n    uVar20 = local_54 & 1;\nLAB_001df550:\n    do {\n      if (uVar20 == 0) {\n        bVar3 = iVar24 <= iVar6 - local_6c;\n      }\n      else {\n        bVar3 = (bool)((byte)~(byte)((uint)iVar24 >> 0x18) >> 7);\n      }\n      if (bVar3 == false) goto LAB_001df86b;\n      pcVar7 = (char *)((long)iVar24 + *(long *)(param_1 + 0x90));\n      if ((**(char **)(param_1 + 8) == *pcVar7) &&\n         (iVar23 = strncmp(*(char **)(param_1 + 8),pcVar7,(long)local_6c), iVar23 == 0)) {\n        *(uint *)(param_1 + 4) = local_54 | 2;\n        puVar16 = _rl_keymap;\n        *(undefined **)(param_1 + 0x58) = _rl_keymap;\n        *(undefined **)(param_1 + 0x50) = puVar16;\n        puVar1 = (undefined8 *)(*(long *)(param_1 + 0x18) + (long)*(int *)(param_1 + 0x60) * 8);\n        *(undefined8 *)(param_1 + 0x40) = *puVar1;\n        rl_replace_line(*puVar1,0);\n        if (_rl_enable_active_region != 0) {\n          rl_activate_mark();\n        }\n        rl_point = *(int *)(param_1 + 0x9c);\n        iVar6 = rl_mark_active_p();\n        if ((iVar6 != 0) && (0 < *(int *)(param_1 + 0x10))) {\n          rl_mark = *(int *)(param_1 + 0x10) + rl_point;\n        }\n        uVar4 = 1;\n        *(undefined4 *)(param_1 + 0x3c) = *(undefined4 *)(param_1 + 0x60);\n        FUN_001df030(*(undefined8 *)(param_1 + 8),*(undefined4 *)(param_1 + 4));\n        goto LAB_001df201;\n      }\n      iVar24 = iVar24 + *(int *)(param_1 + 100);\n      *(int *)(param_1 + 0x9c) = iVar24;\n    } while (-1 < iVar24);\n    *(undefined4 *)(param_1 + 0x9c) = 0;\nLAB_001df86b:\n    iVar24 = *(int *)(param_1 + 100);\n    iVar23 = *(int *)(param_1 + 0x60);\n    lVar22 = ((long)iVar23 + (long)iVar24) * 8;\n    do {\n      iVar23 = iVar23 + iVar24;\n      *(int *)(param_1 + 0x60) = iVar23;\n      if (uVar20 == 0) {\n        if (iVar23 == *(int *)(param_1 + 0x28)) {\nLAB_001df910:\n          *(uint *)(param_1 + 4) = local_54 | 4;\n          puVar16 = _rl_keymap;\n          if (*(int *)(param_1 + 0x9c) < 0) {\n            *(undefined4 *)(param_1 + 0x9c) = 0;\n            *(undefined **)(param_1 + 0x58) = puVar16;\n            *(undefined **)(param_1 + 0x50) = puVar16;\n          }\n          else {\n            *(undefined **)(param_1 + 0x58) = _rl_keymap;\n            *(undefined **)(param_1 + 0x50) = puVar16;\n          }\n          goto LAB_001df946;\n        }\n      }\n      else if (iVar23 < 0) goto LAB_001df910;\n      ppcVar25 = (char **)(*(long *)(param_1 + 0x18) + lVar22);\n      pcVar7 = *ppcVar25;\n      *(char **)(param_1 + 0x90) = pcVar7;\n      sVar8 = strlen(pcVar7);\n      pcVar7 = *(char **)(param_1 + 0x40);\n      iVar6 = (int)sVar8;\n      *(int *)(param_1 + 0x98) = iVar6;\n      if ((((pcVar7 == (char *)0x0) || (pcVar11 = *ppcVar25, *pcVar7 != *pcVar11)) ||\n          (iVar5 = strcmp(pcVar7,pcVar11), iVar5 != 0)) && (local_6c <= iVar6))\n      goto code_r0x001df99f;\n      lVar22 = lVar22 + (long)iVar24 * 8;\n    } while( true );\n  }\n  *(uint *)(param_1 + 4) = local_54 | 4;\n  puVar16 = _rl_keymap;\n  *(undefined **)(param_1 + 0x58) = _rl_keymap;\n  *(undefined **)(param_1 + 0x50) = puVar16;\nLAB_001df946:\n  rl_ding();\n  *(undefined4 *)(param_1 + 0x60) = *(undefined4 *)(param_1 + 0x3c);\n  rl_deactivate_mark();\n  FUN_001df030(*(undefined8 *)(param_1 + 8),*(undefined4 *)(param_1 + 4));\nLAB_001df84f:\n  uVar4 = 1;\nLAB_001df201:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\ncode_r0x001df99f:\n  iVar24 = iVar6 - local_6c;\n  if (uVar20 == 0) {\n    iVar24 = 0;\n  }\n  *(int *)(param_1 + 0x9c) = iVar24;\n  goto LAB_001df550;\n}\n\n",
  "__mbrlen": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __mbrlen(char *__s,size_t __n,mbstate_t *__ps)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR___mbrlen_002378e0)();\n  return sVar1;\n}\n\n",
  "lseek": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = (*(code *)PTR_lseek_00237a40)();\n  return _Var1;\n}\n\n",
  "sh_double_quote": "\nundefined * sh_double_quote(byte *param_1)\n\n{\n  mbstate_t mVar1;\n  size_t sVar2;\n  size_t sVar3;\n  size_t sVar4;\n  undefined *puVar5;\n  byte *__s;\n  size_t sVar6;\n  byte bVar7;\n  undefined2 *puVar8;\n  undefined2 *puVar9;\n  byte *pbVar10;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar2 = strlen((char *)param_1);\n  sVar3 = __ctype_get_mb_cur_max();\n  sVar4 = strlen((char *)param_1);\n  puVar5 = (undefined *)sh_xmalloc(sVar4 * 2 + 3,\"shquote.c\",0x95);\n  *puVar5 = 0x22;\n  bVar7 = *param_1;\n  puVar8 = (undefined2 *)(puVar5 + 1);\n  __s = param_1;\n  mVar1 = local_48;\n  do {\n    while( true ) {\n      local_48 = mVar1;\n      if (bVar7 == 0) {\n        *puVar8 = 0x22;\n        if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n          return puVar5;\n        }\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      if (((*(byte *)(&sh_syntaxtab + bVar7) & 0x40) != 0) && (bVar7 != 10)) {\n        *(undefined *)puVar8 = 0x5c;\n        puVar8 = (undefined2 *)((long)puVar8 + 1);\n      }\n      if (locale_utf8locale == 0) break;\n      if ((char)bVar7 < '\\0') goto LAB_001c8a1a;\nLAB_001c89e1:\n      *(byte *)puVar8 = bVar7;\n      puVar9 = (undefined2 *)((long)puVar8 + 1);\n      pbVar10 = __s + 1;\nLAB_001c89ee:\n      bVar7 = __s[1];\n      puVar8 = puVar9;\n      __s = pbVar10;\n      mVar1 = local_48;\n    }\n    if (((int)sVar3 < 2) ||\n       ((*(uint *)(is_basic_table + (ulong)(bVar7 >> 5) * 4) >> (bVar7 & 0x1f) & 1) != 0))\n    goto LAB_001c89e1;\nLAB_001c8a1a:\n    bVar7 = *__s;\n    puVar9 = (undefined2 *)((long)puVar8 + 1);\n    pbVar10 = __s + 1;\n    if (1 < locale_mb_cur_max) {\n      if (((*(uint *)(is_basic_table + (ulong)(bVar7 >> 5) * 4) >> (bVar7 & 0x1f) & 1) == 0) &&\n         ((locale_utf8locale == 0 || ((char)bVar7 < '\\0')))) {\n        sVar6 = mbrtowc((wchar_t *)0x0,(char *)__s,(size_t)(param_1 + (sVar2 - (long)__s)),&local_48\n                       );\n        if (sVar6 < 0xfffffffffffffffe) {\n          sVar4 = 1;\n          if (sVar6 != 0) {\n            sVar4 = sVar6;\n          }\n          sVar6 = 0;\n          bVar7 = *__s;\n          while( true ) {\n            *(byte *)((long)puVar8 + sVar6) = bVar7;\n            sVar6 = sVar6 + 1;\n            if (sVar6 == sVar4) break;\n            bVar7 = __s[sVar6];\n          }\n          goto LAB_001c8a9a;\n        }\n        *(byte *)puVar8 = *__s;\n        local_48 = mVar1;\n      }\n      else {\n        *(byte *)puVar8 = bVar7;\n        sVar4 = 1;\nLAB_001c8a9a:\n        puVar9 = (undefined2 *)((long)puVar8 + sVar4);\n        pbVar10 = __s + sVar4;\n        __s = __s + (sVar4 - 1);\n      }\n      goto LAB_001c89ee;\n    }\n    *(byte *)puVar8 = bVar7;\n    bVar7 = __s[1];\n    puVar8 = puVar9;\n    __s = pbVar10;\n  } while( true );\n}\n\n",
  "rl_redraw_prompt_last_line": "\nvoid rl_redraw_prompt_last_line(void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(rl_display_prompt,10);\n  if (pcVar1 != (char *)0x0) {\n    FUN_001e2490(pcVar1 + 1);\n    return;\n  }\n  rl_forced_update_display();\n  return;\n}\n\n",
  "FUN_001e05c0": "\nvoid FUN_001e05c0(int param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  undefined8 uVar4;\n  int iVar5;\n  long lVar6;\n  size_t __n;\n  \n  puVar1 = PTR_DAT_00240520;\n  iVar3 = 0x400;\n  if (0x3ff < param_1) {\n    iVar3 = param_1;\n  }\n  if (_rl_screenwidth < iVar3) {\n    if (iVar3 <= DAT_0024a8ac) {\n      return;\n    }\n    if (param_1 < 0x401) {\n      lVar6 = 0x400;\n      iVar5 = 0x400;\n      goto LAB_001e0609;\n    }\n  }\n  else {\n    iVar3 = _rl_screenwidth + 1;\n    if (iVar3 <= DAT_0024a8ac) {\n      return;\n    }\n  }\n  iVar5 = 0x400;\n  do {\n    iVar5 = iVar5 * 2;\n  } while (iVar5 < iVar3);\n  lVar6 = (long)iVar5;\nLAB_001e0609:\n  uVar4 = xrealloc(*(undefined8 *)PTR_DAT_00240520,lVar6);\n  *(undefined8 *)puVar1 = uVar4;\n  puVar1 = PTR_DAT_00240520;\n  uVar4 = xrealloc(*(undefined8 *)(PTR_DAT_00240520 + 8),lVar6);\n  *(undefined8 *)(puVar1 + 8) = uVar4;\n  puVar1 = PTR_DAT_00240518;\n  uVar4 = xrealloc(*(undefined8 *)PTR_DAT_00240518,lVar6);\n  *(undefined8 *)puVar1 = uVar4;\n  puVar1 = PTR_DAT_00240518;\n  uVar4 = xrealloc(*(undefined8 *)(PTR_DAT_00240518 + 8));\n  iVar3 = DAT_0024a8ac;\n  puVar2 = PTR_DAT_00240520;\n  lVar6 = (long)DAT_0024a8ac;\n  *(undefined8 *)(puVar1 + 8) = uVar4;\n  __n = (size_t)(iVar5 - iVar3);\n  memset((void *)(*(long *)puVar2 + lVar6),0,__n);\n  memset((void *)(*(long *)(puVar2 + 8) + lVar6),0x30,__n);\n  puVar1 = PTR_DAT_00240518;\n  memset((void *)(*(long *)PTR_DAT_00240518 + lVar6),1,__n);\n  memset((void *)(*(long *)(puVar1 + 8) + lVar6),1,__n);\n  DAT_0024a8ac = iVar5;\n  return;\n}\n\n",
  "__stack_chk_fail": "\nvoid __stack_chk_fail_noreturn_(void)\n\n{\n  (*(code *)PTR___stack_chk_fail_002379d0)();\n  return;\n}\n\n",
  "shopt_setopt": "\nundefined4 shopt_setopt(undefined8 param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  undefined8 uVar2;\n  \n  uVar2 = make_word();\n  uVar2 = make_word_list(uVar2,0);\n  uVar1 = FUN_001b7830(param_2,uVar2);\n  dispose_words(uVar2);\n  return uVar1;\n}\n\n",
  "FUN_001815b0": "\nvoid FUN_001815b0(int param_1,long param_2)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar1 = (&DAT_00247e40)[param_1];\n  if ((uVar1 & 0x10) == 0) {\n    FUN_00181560();\n    uVar1 = (&DAT_00247e40)[param_1];\n  }\n  (&trap_list)[param_1] = param_2;\n  uVar2 = uVar1 & 0xffffffbf | 1;\n  if (param_2 == 1) {\n    uVar2 = uVar1 | 0x41;\n  }\n  if ((uVar2 & 0x10) != 0) {\n    uVar2 = uVar2 | 0x20;\n  }\n  (&DAT_00247e40)[param_1] = uVar2;\n  return;\n}\n\n",
  "ioctl": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ioctl(int __fd,ulong __request,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_ioctl_00237a70)();\n  return iVar1;\n}\n\n",
  "FUN_00152740": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong FUN_00152740(long param_1,undefined8 param_2)\n\n{\n  uint uVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  int local_2c;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((*(byte *)(param_1 + 0x28) & 0x10) == 0) {\n    local_2c = legal_number(param_2);\n  }\n  else {\n    local_28 = evalexp(param_2,0,&local_2c);\n  }\n  _DAT_002422f0 = 0;\n  if (local_2c != 0) {\n    _DAT_002422f0 = local_28;\n  }\n  gettimeofday((timeval *)&shellstart,(__timezone_ptr_t)0x0);\n  uVar1 = *(uint *)(param_1 + 0x28);\n  shell_start_time = shellstart;\n  uVar2 = itos(local_28);\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x527);\n  }\n  *(undefined8 *)(param_1 + 8) = uVar2;\n  if ((uVar1 & 0x10) != 0) {\n    *(uint *)(param_1 + 0x28) = *(uint *)(param_1 + 0x28) | 0x10;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "getopts_builtin": "\nundefined4 getopts_builtin(long param_1)\n\n{\n  long *plVar1;\n  char cVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  int iVar5;\n  undefined4 uVar6;\n  long lVar7;\n  long lVar8;\n  ulong uVar9;\n  long lVar10;\n  uint uVar11;\n  long *plVar12;\n  ulong uVar13;\n  char *pcVar14;\n  long in_FS_OFFSET;\n  undefined4 local_6c;\n  int local_60;\n  undefined local_5a;\n  undefined local_59;\n  char local_58 [14];\n  char local_4a;\n  undefined local_49;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 != 0) {\n    reset_internal_getopt();\n    iVar5 = internal_getopt(param_1,&DAT_00213d70);\n    if (iVar5 == -1) {\n      lVar7 = make_builtin_argv(loptend,&local_60);\n      uVar6 = sh_opterr;\n      if (local_60 < 3) {\n        builtin_usage();\n        uVar6 = 0x102;\n      }\n      else {\n        pcVar14 = *(char **)(lVar7 + 8);\n        uVar3 = *(undefined8 *)(lVar7 + 0x10);\n        cVar2 = *pcVar14;\n        if (cVar2 == ':') {\n          pcVar14 = pcVar14 + 1;\n          sh_opterr = 0;\n          local_6c = uVar6;\n        }\n        if (local_60 + -2 == 1) {\n          if (rest_of_args == (long *)0x0) {\n            uVar9 = 0;\n            do {\n              uVar13 = uVar9 & 0xffffffff;\n              if ((&dollar_vars)[uVar9] == 0) goto LAB_001b6d22;\n              uVar9 = uVar9 + 1;\n            } while (uVar9 != 10);\n            uVar13 = 10;\nLAB_001b6d22:\n            sh_getopt_restore_state(&dollar_vars);\n            iVar5 = sh_getopt(uVar13,&dollar_vars,pcVar14);\n          }\n          else {\n            iVar5 = number_of_args();\n            lVar8 = strvec_create(iVar5 + 2);\n            uVar9 = 0;\n            do {\n              uVar13 = uVar9 & 0xffffffff;\n              lVar10 = uVar9 * 8;\n              if ((&dollar_vars)[uVar9] == 0) goto LAB_001b6aed;\n              *(undefined8 *)(lVar8 + uVar9 * 8) = (&dollar_vars)[uVar9];\n              uVar9 = uVar9 + 1;\n            } while (uVar9 != 10);\n            lVar10 = 0x50;\n            uVar13 = 10;\nLAB_001b6aed:\n            if (rest_of_args != (long *)0x0) {\n              uVar9 = (ulong)((int)uVar13 + 1);\n              plVar12 = rest_of_args;\n              do {\n                plVar1 = plVar12 + 1;\n                plVar12 = (long *)*plVar12;\n                uVar13 = uVar9 & 0xffffffff;\n                *(undefined8 *)(lVar8 + -8 + uVar9 * 8) = *(undefined8 *)*plVar1;\n                uVar9 = uVar9 + 1;\n              } while (plVar12 != (long *)0x0);\n              lVar10 = (long)(int)uVar13 << 3;\n            }\n            *(undefined8 *)(lVar8 + lVar10) = 0;\n            sh_getopt_restore_state(lVar8);\n            iVar5 = sh_getopt(uVar13,lVar8,pcVar14);\n            sh_xfree(lVar8,\"./getopts.def\",0xe0);\n          }\n        }\n        else {\n          sh_getopt_restore_state(lVar7 + 0x10);\n          uVar4 = *(undefined8 *)(lVar7 + 0x10);\n          *(undefined8 *)(lVar7 + 0x10) = dollar_vars;\n          iVar5 = sh_getopt(local_60 + -2,lVar7 + 0x10,pcVar14);\n          *(undefined8 *)(lVar7 + 0x10) = uVar4;\n        }\n        if (cVar2 == ':') {\n          sh_opterr = local_6c;\n        }\n        if ((int)sh_optind < 10) {\n          local_4a = (char)sh_optind + '0';\n          lVar10 = 0xe;\n        }\n        else {\n          lVar8 = 0xe;\n          uVar11 = sh_optind;\n          do {\n            lVar10 = (long)(int)lVar8;\n            local_58[lVar8] = (char)uVar11 + (char)(uVar11 / 10) * -10 + '0';\n            uVar11 = uVar11 / 10;\n            lVar8 = lVar8 + -1;\n          } while (uVar11 != 0);\n        }\n        local_49 = 0;\n        bind_variable(\"OPTIND\",local_58 + lVar10,0);\n        if (iVar5 == 0x3f) {\n          if (sh_optarg == (char *)0x0) {\nLAB_001b6d70:\n            uVar6 = FUN_001b6930(uVar3,&DAT_001fa095);\n            if (cVar2 == ':') {\nLAB_001b6d8b:\n              local_59 = 0;\n              local_5a = (undefined)sh_optopt;\n              bind_variable(\"OPTARG\",&local_5a,0);\n              goto LAB_001b6c38;\n            }\n          }\n          else {\n            if (*sh_optarg != '\\0') goto LAB_001b6c10;\nLAB_001b6cc9:\n            if (cVar2 == ':') {\n              uVar6 = FUN_001b6930(uVar3,\":\");\n              goto LAB_001b6d8b;\n            }\n            uVar6 = FUN_001b6930(uVar3,&DAT_001fa095);\n          }\n          unbind_variable_noref(\"OPTARG\");\n        }\n        else if (iVar5 == -1) {\n          unbind_variable_noref(\"OPTARG\");\n          uVar6 = 1;\n          FUN_001b6930(uVar3,&DAT_001fa095);\n        }\n        else {\n          if (iVar5 == -2) goto LAB_001b6d70;\n          if (iVar5 == -3) goto LAB_001b6cc9;\nLAB_001b6c10:\n          bind_variable(\"OPTARG\",sh_optarg,0);\n          local_5a = (undefined)iVar5;\n          local_59 = 0;\n          uVar6 = FUN_001b6930(uVar3,&local_5a);\n        }\n      }\nLAB_001b6c38:\n      sh_xfree(lVar7,\"./getopts.def\",0x154);\n      goto LAB_001b6a17;\n    }\n    if (iVar5 == -99) {\n      builtin_help();\n      uVar6 = 0x102;\n      goto LAB_001b6a17;\n    }\n  }\n  builtin_usage();\n  uVar6 = 0x102;\nLAB_001b6a17:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar6;\n}\n\n",
  "getcwd": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * getcwd(char *__buf,size_t __size)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_getcwd_00237a80)();\n  return pcVar1;\n}\n\n",
  "FUN_0019bf00": "\nundefined4 FUN_0019bf00(int param_1,int param_2,int param_3)\n\n{\n  bool bVar1;\n  int __fd;\n  int iVar2;\n  uint uVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  undefined8 *puVar6;\n  uint uVar7;\n  \n  if (param_3 < 9) {\n    param_3 = 9;\n  }\n  __fd = fcntl(param_1,0,(ulong)(param_3 + 1));\n  bVar1 = false;\n  if ((__fd < 0) && (__fd = fcntl(param_1,0,10), bVar1 = false, __fd < 0)) {\n    __fd = fcntl(param_1,0,0);\n    bVar1 = true;\n    if (__fd < 0) {\n      sys_error(\"redirection error: cannot duplicate fd\");\n      return 0xffffffff;\n    }\n  }\n  iVar2 = fcntl(param_1,1,0);\n  DAT_00248a00._0_4_ = 0;\n  puVar4 = (undefined8 *)make_redirection(__fd,9,(ulong)DAT_00248a00._4_4_ << 0x20,0);\n  *(uint *)((long)puVar4 + 0x14) = *(uint *)((long)puVar4 + 0x14) | 8;\n  puVar5 = (undefined8 *)copy_redirects(puVar4);\n  DAT_00248a00._0_4_ = __fd;\n  if (param_1 == 0) {\n    puVar6 = (undefined8 *)make_redirection(0,6,CONCAT44(DAT_00248a00._4_4_,__fd),0);\n    uVar3 = *(uint *)((long)puVar6 + 0x14);\n    *(uint *)((long)puVar6 + 0x14) = uVar3 | 8;\n    if (!bVar1) {\n      *puVar6 = puVar4;\n      *puVar4 = redirection_undo_list;\n      redirection_undo_list = puVar6;\n      *puVar5 = exec_redirection_undo_list;\n      exec_redirection_undo_list = puVar5;\n      goto LAB_0019c08a;\n    }\n    *puVar6 = puVar4;\n    *(uint *)((long)puVar6 + 0x14) = uVar3 | 0x48;\n    *puVar4 = redirection_undo_list;\n    redirection_undo_list = puVar6;\n    *puVar5 = exec_redirection_undo_list;\nLAB_0019c075:\n    exec_redirection_undo_list = puVar5;\n    if ((iVar2 != 0) || (param_1 < 3)) goto LAB_0019c08a;\nLAB_0019c080:\n    uVar3 = *(uint *)((long)puVar6 + 0x14) & 0x20;\n  }\n  else {\n    puVar6 = (undefined8 *)make_redirection(param_1,7,CONCAT44(DAT_00248a00._4_4_,__fd),0);\n    uVar3 = *(uint *)((long)puVar6 + 0x14);\n    uVar7 = uVar3 | 8;\n    *(uint *)((long)puVar6 + 0x14) = uVar7;\n    if (bVar1) {\n      uVar7 = uVar3 | 0x48;\n      *(uint *)((long)puVar6 + 0x14) = uVar7;\n      if ((iVar2 != 0) || (param_1 < 3)) {\nLAB_0019c133:\n        *puVar6 = puVar4;\n        *puVar4 = redirection_undo_list;\n        redirection_undo_list = puVar6;\n        *puVar5 = exec_redirection_undo_list;\n        if ((param_1 < 10) || (param_2 == 9)) goto LAB_0019c075;\n        if (iVar2 != 0) {\n          exec_redirection_undo_list = puVar5;\n          DAT_00248a00._0_4_ = __fd;\n          puVar4 = (undefined8 *)make_redirection(param_1,7,CONCAT44(DAT_00248a00._4_4_,__fd),0);\n          *(uint *)((long)puVar4 + 0x14) = *(uint *)((long)puVar4 + 0x14) | 8;\n          *puVar4 = exec_redirection_undo_list;\n          exec_redirection_undo_list = puVar4;\n          goto LAB_0019c08a;\n        }\n        goto LAB_0019c080;\n      }\nLAB_0019bfde:\n      uVar3 = 0x20;\n      *(uint *)((long)puVar6 + 0x14) = uVar7 | 0x20;\n    }\n    else {\n      if ((param_1 < 3) || (iVar2 != 0)) goto LAB_0019c133;\n      if (9 < __fd) goto LAB_0019bfde;\n      uVar3 = uVar3 & 0x20;\n    }\n    *puVar6 = puVar4;\n    *puVar4 = redirection_undo_list;\n    redirection_undo_list = puVar6;\n    *puVar5 = exec_redirection_undo_list;\n  }\n  exec_redirection_undo_list = puVar5;\n  if (uVar3 == 0) {\n    return 0;\n  }\nLAB_0019c08a:\n  fcntl(__fd,2,1);\n  return 0;\n}\n\n",
  "rl_deprep_terminal": "\nvoid rl_deprep_terminal(void)\n\n{\n  int __fd;\n  int iVar1;\n  int *piVar2;\n  FILE *__stream;\n  \n  if (DAT_0024a590 == 0) {\n    return;\n  }\n  _rl_block_sigint();\n  __stream = rl_instream;\n  if (rl_instream == (FILE *)0x0) {\n    __stream = stdin;\n  }\n  __fd = fileno(__stream);\n  if ((DAT_0024a590 & 2) != 0) {\n    fwrite(&DAT_0021334d,1,9,rl_outstream);\n    _rl_last_c_pos = 0;\n    if (((rl_eof_found != 0) && ((rl_readline_state & 0x4000000) == 0)) || (_rl_echoing_p == 0)) {\n      fputc(10,rl_outstream);\n    }\n  }\n  if (_rl_enable_keypad != 0) {\n    _rl_control_keypad(0);\n  }\n  fflush(rl_outstream);\n  while( true ) {\n    iVar1 = tcsetattr(__fd,1,(termios *)&DAT_0024a540);\n    if (-1 < iVar1) {\n      rl_readline_state = rl_readline_state & 0xfffffffffffffffb;\n      DAT_0024a590 = 0;\n      _rl_release_sigint();\n      return;\n    }\n    piVar2 = __errno_location();\n    if (*piVar2 != 4) break;\n    *piVar2 = 0;\n  }\n  _rl_release_sigint();\n  return;\n}\n\n",
  "_rl_timeout_handle_sigalrm": "\nundefined8 _rl_timeout_handle_sigalrm(void)\n\n{\n  return 0xffffffff;\n}\n\n",
  "pop_context": "\nvoid pop_context(void)\n\n{\n  undefined8 uVar1;\n  \n  pop_dollar_vars();\n  variable_context = variable_context + -1;\n  pop_var_context();\n  uVar1 = find_variable(&DAT_001fce6e);\n  setifs(uVar1);\n  return;\n}\n\n",
  "jobs_builtin": "\nuint jobs_builtin(undefined8 param_1)\n\n{\n  long *plVar1;\n  uint *puVar2;\n  long **pplVar3;\n  int iVar4;\n  int iVar5;\n  uint uVar6;\n  long lVar7;\n  long lVar8;\n  undefined8 uVar9;\n  long **pplVar10;\n  int iVar11;\n  int iVar12;\n  long in_FS_OFFSET;\n  sigset_t sStack_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  iVar5 = 0;\n  iVar12 = 0;\n  iVar11 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  reset_internal_getopt();\nLAB_001ad277:\n  iVar4 = internal_getopt(param_1,\"lpnxrs\");\n  pplVar10 = loptend;\n  do {\n    loptend = pplVar10;\n    if (iVar4 == -1) {\n      pplVar3 = pplVar10;\n      if (iVar11 == 0) {\n        iVar11 = 0;\n        if (pplVar10 == (long **)0x0) {\n          uVar6 = 0;\n          if (iVar5 == 1) {\n            list_running_jobs(iVar12);\n          }\n          else if (iVar5 == 2) {\n            list_stopped_jobs();\n          }\n          else {\n            list_all_jobs();\n          }\n        }\n        else {\n          do {\n            sigemptyset(&sStack_148);\n            sigaddset(&sStack_148,0x11);\n            sigemptyset(&local_c8);\n            sigprocmask(0,&sStack_148,&local_c8);\n            iVar5 = get_job_spec(pplVar10);\n            if (((iVar5 == -1) || (jobs == 0)) || (*(long *)(jobs + (long)iVar5 * 8) == 0)) {\n              iVar11 = iVar11 + 1;\n              sh_badjob(*pplVar10[1]);\n            }\n            else if (iVar5 != -2) {\n              list_one_job(0,iVar12,0);\n            }\n            sigprocmask(2,&local_c8,(sigset_t *)0x0);\n            pplVar10 = (long **)*pplVar10;\n          } while (pplVar10 != (long **)0x0);\n          uVar6 = (uint)(iVar11 != 0);\n        }\n      }\n      else {\n        for (; pplVar3 != (long **)0x0; pplVar3 = (long **)*pplVar3) {\n          if ((((*(char *)*pplVar3[1] == '%') && (iVar11 = get_job_spec(pplVar3), -1 < iVar11)) &&\n              (iVar11 < DAT_0023877c)) && (lVar7 = *(long *)(jobs + (long)iVar11 * 8), lVar7 != 0))\n          {\n            sh_xfree(*pplVar3[1],\"./jobs.def\",0xbe);\n            plVar1 = pplVar3[1];\n            lVar7 = itos((long)*(int *)(lVar7 + 0x10));\n            *plVar1 = lVar7;\n          }\n        }\n        begin_unwind_frame(\"jobs_builtin\");\n        lVar8 = make_bare_simple_command();\n        lVar7 = *(long *)(lVar8 + 0x18);\n        uVar9 = copy_word_list(pplVar10);\n        *(undefined8 *)(lVar7 + 8) = uVar9;\n        puVar2 = *(uint **)(lVar8 + 0x18);\n        *(undefined8 *)(puVar2 + 4) = 0;\n        *(uint *)(lVar8 + 4) = *(uint *)(lVar8 + 4) | 0x20;\n        *puVar2 = *puVar2 | 0x20;\n        add_unwind_protect(dispose_command,lVar8);\n        uVar6 = execute_command(lVar8);\n        dispose_command(lVar8);\n        discard_unwind_frame(\"jobs_builtin\");\n      }\nLAB_001ad2b3:\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return uVar6;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (iVar4 == -99) {\n      builtin_help();\n      uVar6 = 0x102;\n      goto LAB_001ad2b3;\n    }\n    switch(iVar4) {\n    case 0x6c:\n      goto switchD_001ad29f_caseD_6c;\n    default:\n      builtin_usage();\n      uVar6 = 0x102;\n      goto LAB_001ad2b3;\n    case 0x6e:\n      iVar12 = 3;\n      goto LAB_001ad277;\n    case 0x70:\n      iVar12 = 2;\n      goto LAB_001ad277;\n    case 0x72:\n      iVar5 = 1;\n      goto LAB_001ad277;\n    case 0x73:\n      iVar5 = 2;\n      goto LAB_001ad277;\n    case 0x78:\n      if (iVar12 != 0) {\n        uVar6 = 1;\n        builtin_error(\"no other options allowed with `-x\\'\");\n        goto LAB_001ad2b3;\n      }\n      iVar11 = iVar11 + 1;\n      iVar4 = internal_getopt(param_1,\"lpnxrs\");\n      pplVar10 = loptend;\n    }\n  } while( true );\nswitchD_001ad29f_caseD_6c:\n  iVar12 = 1;\n  goto LAB_001ad277;\n}\n\n",
  "rl_backward_char_search": "\nundefined8 rl_backward_char_search(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  if ((rl_readline_state._2_1_ & 8) == 0) {\n    uVar1 = FUN_001edf90(param_1,0xfffffffe,2);\n    return uVar1;\n  }\n  _rl_callback_data = _rl_callback_data_alloc();\n  *(undefined8 *)(_rl_callback_data + 4) = 0x2fffffffe;\n  _rl_callback_func = FUN_001ee020;\n  return 0;\n}\n\n",
  "strvec_mcreate": "\nvoid strvec_mcreate(int param_1)\n\n{\n  sh_malloc((long)param_1 << 3,\"stringvec.c\",0x30);\n  return;\n}\n\n",
  "parser_save_alias": "\nvoid parser_save_alias(void)\n\n{\n  FUN_001357c0(0,0,0);\n  *(undefined4 *)(pushed_string_list + 0x3c) = 4;\n  return;\n}\n\n",
  "fclose": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fclose_00237980)();\n  return iVar1;\n}\n\n",
  "rl_variable_dumper": "\nvoid rl_variable_dumper(int param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  char *pcVar3;\n  char **ppcVar4;\n  undefined **ppuVar5;\n  char *pcVar6;\n  \n  piVar2 = &_rl_bind_stty_chars;\n  pcVar3 = \"bind-tty-special-chars\";\n  ppcVar4 = &PTR_s_blink_matching_paren_002372b8;\n  while( true ) {\n    pcVar6 = \"off\";\n    if (*piVar2 != 0) {\n      pcVar6 = \"on\";\n    }\n    if (param_1 == 0) {\n      __fprintf_chk(rl_outstream,1,\"%s is set to `%s\\'\\n\",pcVar3,pcVar6);\n      pcVar3 = *ppcVar4;\n    }\n    else {\n      __fprintf_chk(rl_outstream,1,\"set %s %s\\n\",pcVar3,pcVar6);\n      pcVar3 = *ppcVar4;\n    }\n    if (pcVar3 == (char *)0x0) break;\n    piVar2 = (int *)ppcVar4[1];\n    ppcVar4 = ppcVar4 + 3;\n  }\n  ppuVar5 = &PTR_s_active_region_start_color_00235858;\n  pcVar3 = \"active-region-end-color\";\n  do {\n    iVar1 = strcasecmp(pcVar3,\"bell-style\");\n    if (iVar1 == 0) {\n      pcVar6 = \"none\";\n      if ((_rl_bell_preference != 0) && (pcVar6 = \"visible\", _rl_bell_preference != 2)) {\n        pcVar6 = \"audible\";\n      }\njoined_r0x001defaa:\n      if (param_1 != 0) {\n        __fprintf_chk(rl_outstream,1,\"set %s %s\\n\",pcVar3,pcVar6);\n        goto LAB_001def73;\n      }\n      __fprintf_chk(rl_outstream,1,\"%s is set to `%s\\'\\n\",pcVar3,pcVar6);\n      pcVar3 = *ppuVar5;\n    }\n    else {\n      pcVar6 = (char *)FUN_001dc4f0(pcVar3);\n      if (pcVar6 != (char *)0x0) goto joined_r0x001defaa;\nLAB_001def73:\n      pcVar3 = *ppuVar5;\n    }\n    ppuVar5 = ppuVar5 + 3;\n    if (pcVar3 == (char *)0x0) {\n      return;\n    }\n  } while( true );\n}\n\n",
  "parse_shellopts": "\nvoid parse_shellopts(undefined8 param_1)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  undefined4 local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_34 = 0;\n  while( true ) {\n    lVar1 = extract_colon_unit(param_1,&local_34);\n    if (lVar1 == 0) break;\n    set_minus_o_option(0x2d,lVar1);\n    sh_xfree(lVar1,\"./set.def\",0x26c);\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "set_expand_once": "\nundefined4 set_expand_once(undefined4 param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 = assoc_expand_once;\n  if (shell_compatibility_level < 0x34) {\n    return uVar1;\n  }\n  if (param_2 == 0) {\n    assoc_expand_once = param_1;\n    return uVar1;\n  }\n  unwind_protect_mem(&assoc_expand_once,4);\n  assoc_expand_once = param_1;\n  return uVar1;\n}\n\n",
  "utf8_mbsnlen": "\nint utf8_mbsnlen(byte *param_1,undefined8 param_2,int param_3)\n\n{\n  byte bVar1;\n  int iVar2;\n  long lVar3;\n  int iVar4;\n  \n  bVar1 = *param_1;\n  if ((-1 < param_3) && (bVar1 != 0)) {\n    lVar3 = 1;\n    iVar4 = 0;\n    do {\n      iVar4 = iVar4 + (uint)((bVar1 & 0xc0) != 0x80);\n      bVar1 = param_1[lVar3];\n      iVar2 = (int)lVar3;\n      lVar3 = lVar3 + 1;\n    } while (iVar2 <= param_3 && bVar1 != 0);\n    return iVar4;\n  }\n  return 0;\n}\n\n",
  "rl_vi_yank_to": "\nint rl_vi_yank_to(undefined8 param_1,ulong param_2)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  ushort **ppuVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  \n  puVar1 = _rl_vimvcxt;\n  uVar7 = (undefined4)(param_2 & 0xffffffff);\n  if (_rl_vi_redoing == 0) {\n    if (_rl_vimvcxt == (undefined8 *)0x0) {\n      puVar4 = (undefined8 *)xmalloc(0x24);\n      *puVar4 = 4;\n      rl_mark = rl_point;\n      uVar6 = rl_end;\n      puVar4[1] = 0;\n      *(undefined4 *)(puVar4 + 2) = 0xffffffff;\n      *(undefined4 *)((long)puVar4 + 0x14) = rl_mark;\n      *(undefined4 *)(puVar4 + 3) = uVar6;\n      *(undefined4 *)((long)puVar4 + 0x1c) = uVar7;\n      *(undefined4 *)(puVar4 + 4) = 0xffffffff;\n      puVar5 = (undefined8 *)0x0;\n      _rl_vimvcxt = puVar4;\n    }\n    else {\n      *_rl_vimvcxt = 4;\n      rl_mark = rl_point;\n      uVar6 = rl_end;\n      puVar1[1] = 0;\n      *(undefined4 *)(puVar1 + 2) = 0xffffffff;\n      *(undefined4 *)((long)puVar1 + 0x14) = rl_mark;\n      *(undefined4 *)(puVar1 + 3) = uVar6;\n      *(int *)((long)puVar1 + 0x1c) = (int)param_2;\n      *(undefined4 *)(puVar1 + 4) = 0xffffffff;\n      puVar5 = (undefined8 *)0x0;\n      puVar4 = puVar1;\n    }\n  }\n  else {\n    puVar4 = (undefined8 *)xmalloc(0x24);\n    *puVar4 = 4;\n    rl_mark = rl_point;\n    uVar6 = rl_end;\n    puVar4[1] = 0;\n    *(undefined4 *)(puVar4 + 2) = 0xffffffff;\n    *(undefined4 *)((long)puVar4 + 0x14) = rl_mark;\n    *(undefined4 *)(puVar4 + 3) = uVar6;\n    *(undefined4 *)((long)puVar4 + 0x1c) = uVar7;\n    *(undefined4 *)(puVar4 + 4) = 0xffffffff;\n    puVar5 = puVar1;\n    _rl_vimvcxt = puVar4;\n  }\n  *(undefined4 *)((long)puVar4 + 0x14) = rl_mark;\n  ppuVar3 = __ctype_b_loc();\n  if ((*(byte *)((long)*ppuVar3 + (param_2 & 0xff) * 2 + 1) & 1) == 0) {\n    if (_rl_vi_redoing != 0) {\n      if (DAT_0024a400 == 0x79) {\n        *(undefined4 *)(puVar4 + 4) = 0x79;\n        rl_mark = uVar6;\n        rl_beg_of_line(1,param_2 & 0xffffffff);\n        rl_readline_state = rl_readline_state & 0xffffffffffefffff;\n        iVar2 = FUN_001cff80(_rl_vimvcxt);\n      }\n      else {\n        *(int *)(puVar4 + 4) = DAT_0024a400;\n        iVar2 = FUN_001d23d0(puVar4);\n      }\n      goto joined_r0x001d2cc5;\n    }\n    if ((rl_readline_state & 0x80000) != 0) {\n      rl_readline_state = rl_readline_state | 0x100000;\n      return 0;\n    }\n    iVar2 = _rl_bracketed_read_key();\n    *(int *)(puVar4 + 4) = iVar2;\n    if (-1 < iVar2) {\n      iVar2 = FUN_001d2470(puVar4);\n      goto joined_r0x001d2cc5;\n    }\n    *(undefined4 *)(puVar4 + 4) = 0;\n  }\n  else {\n    *(undefined4 *)(puVar4 + 4) = 0x24;\n    iVar2 = FUN_001d23d0(puVar4);\njoined_r0x001d2cc5:\n    if (-1 < iVar2) goto LAB_001d2cc7;\n  }\n  rl_ding();\n  iVar2 = -1;\nLAB_001d2cc7:\n  xfree(_rl_vimvcxt);\n  _rl_vimvcxt = puVar5;\n  return iVar2;\n}\n\n",
  "sh_validfd": "\nuint sh_validfd(int param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 = fcntl(param_1,1,0);\n  return ~uVar1 >> 0x1f;\n}\n\n",
  "return_EOF": "\nundefined8 return_EOF(void)\n\n{\n  return 0xffffffff;\n}\n\n",
  "without_job_control": "\nvoid without_job_control(void)\n\n{\n  already_making_children = 0;\n  start_pipeline();\n  sh_closepipe(&pgrp_pipe);\n  delete_all_jobs(0);\n  set_job_control(0);\n  return;\n}\n\n",
  "FUN_00183470": "\nvoid FUN_00183470(int param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  iVar1 = DAT_00247f64;\n  lVar2 = (long)DAT_00247f64;\n  DAT_00247f64 = param_1 + 0x14;\n  DAT_00247f68 = sh_xrealloc(DAT_00247f68,(long)(param_1 + 0x14) * 8,\"input.c\",0xaf);\n  if (iVar1 < DAT_00247f64) {\n    memset((void *)(DAT_00247f68 + lVar2 * 8),0,(ulong)(uint)((DAT_00247f64 + -1) - iVar1) * 8 + 8);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001a7280": "\nundefined8 FUN_001a7280(long **param_1,uint param_2,long param_3)\n\n{\n  char *__s;\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined *puVar4;\n  int iVar5;\n  uint uVar6;\n  long lVar7;\n  long **pplVar8;\n  size_t sVar9;\n  char *pcVar10;\n  undefined8 *puVar11;\n  undefined8 *puVar12;\n  code *pcVar13;\n  undefined8 uVar14;\n  undefined *__dest;\n  int iVar15;\n  undefined8 *puVar16;\n  long local_70;\n  uint local_54;\n  long local_50;\n  uint local_44;\n  \n  iVar5 = absolute_program(param_3);\n  if (((iVar5 == 0) && (lVar7 = get_string_value(\"BASH_LOADABLES_PATH\"), lVar7 != 0)) &&\n     (lVar7 = find_in_path(param_3,lVar7,0x24), lVar7 != 0)) {\n    local_70 = dlopen(lVar7,1);\n    sh_xfree(lVar7,\"./enable.def\",0x164);\n    if (local_70 != 0) goto LAB_001a732c;\n  }\n  local_70 = dlopen(param_3,1);\n  if (local_70 == 0) {\n    if ((param_2 & 8) == 0) {\n      lVar7 = printable_filename(param_3,0);\n      uVar14 = dlerror();\n      builtin_error(\"cannot open shared object %s: %s\",lVar7,uVar14);\n      if (param_3 != lVar7) {\n        sh_xfree(lVar7,\"./enable.def\",0x17a);\n      }\n    }\n    return 0x7f;\n  }\nLAB_001a732c:\n  iVar5 = 0;\n  pplVar8 = param_1;\n  if (param_1 == (long **)0x0) {\n    local_50 = sh_xmalloc(0,\"./enable.def\",0x181);\n  }\n  else {\n    do {\n      pplVar8 = (long **)*pplVar8;\n      iVar5 = iVar5 + 1;\n    } while (pplVar8 != (long **)0x0);\n    local_50 = sh_xmalloc((long)iVar5 << 3,\"./enable.def\",0x181);\n    local_54 = 0;\n    local_44 = 0;\n    do {\n      while( true ) {\n        __s = (char *)*param_1[1];\n        sVar9 = strlen(__s);\n        lVar7 = (long)(int)sVar9;\n        pcVar10 = (char *)sh_xmalloc((long)((int)sVar9 + 8),\"./enable.def\",0x18b);\n        strcpy(pcVar10,__s);\n        *(undefined8 *)(pcVar10 + lVar7) = 0x7463757274735f;\n        puVar11 = (undefined8 *)builtin_address_internal(__s,1);\n        puVar12 = (undefined8 *)dlsym(local_70,pcVar10);\n        if (puVar12 != (undefined8 *)0x0) break;\n        lVar7 = printable_filename(param_3,0);\n        uVar14 = dlerror();\n        builtin_error(\"cannot find %s in shared object %s: %s\",pcVar10,lVar7,uVar14);\n        if (param_3 != lVar7) {\n          sh_xfree(lVar7,\"./enable.def\",0x198);\n        }\n        sh_xfree(pcVar10,\"./enable.def\",0x199);\nLAB_001a73a6:\n        param_1 = (long **)*param_1;\n        if (param_1 == (long **)0x0) goto LAB_001a74fc;\n      }\n      pcVar10 = (char *)sh_xrealloc(pcVar10,lVar7 + 0xf,\"./enable.def\",0x19d);\n      strcpy(pcVar10,__s);\n      puVar16 = (undefined8 *)(pcVar10 + lVar7);\n      *(undefined2 *)((long)puVar16 + 0xc) = 100;\n      *puVar16 = 0x6e69746c6975625f;\n      *(undefined4 *)(puVar16 + 1) = 0x616f6c5f;\n      pcVar13 = (code *)dlsym(local_70,pcVar10);\n      if (pcVar13 != (code *)0x0) {\n        if ((puVar11 == (undefined8 *)0x0) || ((*(byte *)(puVar11 + 2) & 4) != 0)) {\n          iVar5 = (*pcVar13)(__s);\n        }\n        else {\n          builtin_warning(\"%s: dynamic builtin already loaded\",__s);\n          iVar5 = (*pcVar13)(__s);\n        }\n        if (iVar5 == 0) {\n          builtin_error(\"load function for %s returns failure (%d): not loaded\",__s,0);\n          sh_xfree(pcVar10,\"./enable.def\",0x1ab);\n          goto LAB_001a73a6;\n        }\n      }\n      sh_xfree(pcVar10,\"./enable.def\",0x1af);\n      uVar6 = *(uint *)(puVar12 + 2) & 0xfffffffb;\n      if ((param_2 & 4) != 0) {\n        uVar6 = *(uint *)(puVar12 + 2) & 0xfffffffb | 8;\n      }\n      *(uint *)(puVar12 + 2) = uVar6;\n      puVar12[5] = local_70;\n      if (puVar11 != (undefined8 *)0x0) {\n        uVar14 = puVar12[1];\n        local_44 = local_44 + 1;\n        *puVar11 = *puVar12;\n        puVar11[1] = uVar14;\n        uVar1 = *(undefined4 *)((long)puVar12 + 0x14);\n        uVar2 = *(undefined4 *)(puVar12 + 3);\n        uVar3 = *(undefined4 *)((long)puVar12 + 0x1c);\n        *(undefined4 *)(puVar11 + 2) = *(undefined4 *)(puVar12 + 2);\n        *(undefined4 *)((long)puVar11 + 0x14) = uVar1;\n        *(undefined4 *)(puVar11 + 3) = uVar2;\n        *(undefined4 *)((long)puVar11 + 0x1c) = uVar3;\n        uVar1 = *(undefined4 *)((long)puVar12 + 0x24);\n        uVar2 = *(undefined4 *)(puVar12 + 5);\n        uVar3 = *(undefined4 *)((long)puVar12 + 0x2c);\n        *(undefined4 *)(puVar11 + 4) = *(undefined4 *)(puVar12 + 4);\n        *(undefined4 *)((long)puVar11 + 0x24) = uVar1;\n        *(undefined4 *)(puVar11 + 5) = uVar2;\n        *(undefined4 *)((long)puVar11 + 0x2c) = uVar3;\n        goto LAB_001a73a6;\n      }\n      param_1 = (long **)*param_1;\n      *(undefined8 **)(local_50 + (long)(int)local_54 * 8) = puVar12;\n      local_54 = local_54 + 1;\n    } while (param_1 != (long **)0x0);\nLAB_001a74fc:\n    if ((local_44 | local_54) != 0) {\n      if (local_54 != 0) {\n        iVar5 = num_shell_builtins + local_54;\n        __dest = (undefined *)sh_xmalloc((long)((iVar5 * 3 + 3) * 0x10),\"./enable.def\",0x1cb);\n        memcpy(__dest,shell_builtins,(long)num_shell_builtins * 0x30);\n        lVar7 = 0;\n        do {\n          puVar11 = *(undefined8 **)(local_50 + lVar7 * 8);\n          iVar15 = (int)lVar7;\n          uVar14 = puVar11[1];\n          lVar7 = lVar7 + 1;\n          puVar12 = (undefined8 *)(__dest + (long)(num_shell_builtins + iVar15) * 0x30);\n          *puVar12 = *puVar11;\n          puVar12[1] = uVar14;\n          uVar14 = puVar11[3];\n          puVar12[2] = puVar11[2];\n          puVar12[3] = uVar14;\n          uVar14 = puVar11[5];\n          puVar12[4] = puVar11[4];\n          puVar12[5] = uVar14;\n          puVar4 = shell_builtins;\n        } while ((int)local_54 != lVar7);\n        puVar11 = (undefined8 *)(__dest + (long)iVar5 * 0x30);\n        *puVar11 = 0;\n        puVar11[1] = 0;\n        *(undefined4 *)(puVar11 + 2) = 0;\n        if ((undefined **)puVar4 != &static_shell_builtins) {\n          sh_xfree(puVar4,\"./enable.def\",0x1d8);\n        }\n        num_shell_builtins = iVar5;\n        shell_builtins = __dest;\n        initialize_shell_builtins();\n      }\n      sh_xfree(local_50,\"./enable.def\",0x1df);\n      return 0;\n    }\n  }\n  sh_xfree(local_50,\"./enable.def\",0x1c1);\n  dlclose(local_70);\n  return 1;\n}\n\n",
  "rl_username_completion_function": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nchar * rl_username_completion_function(char *param_1,int param_2)\n\n{\n  int iVar1;\n  size_t sVar2;\n  char *pcVar3;\n  long lVar4;\n  bool bVar5;\n  \n  if (param_2 == 0) {\n    if (DAT_0024a720 != (char *)0x0) {\n      free(DAT_0024a720);\n    }\n    _DAT_0024a718 = (int)*param_1;\n    bVar5 = _DAT_0024a718 == 0x7e;\n    DAT_0024a714 = (uint)bVar5;\n    sVar2 = strlen(param_1 + bVar5);\n    pcVar3 = (char *)xmalloc(sVar2 + 1);\n    DAT_0024a720 = strcpy(pcVar3,param_1 + bVar5);\n    sVar2 = strlen(DAT_0024a720);\n    DAT_0024a710 = (int)sVar2;\n    setpwent();\n  }\n  do {\n    do {\n      DAT_0024a708 = getpwent();\n      if (DAT_0024a708 == (passwd *)0x0) {\n        endpwent();\n        return (char *)0x0;\n      }\n      pcVar3 = DAT_0024a708->pw_name;\n      if (DAT_0024a710 == 0) goto LAB_001da153;\n    } while (*DAT_0024a720 != *pcVar3);\n    iVar1 = strncmp(DAT_0024a720,pcVar3,(long)DAT_0024a710);\n  } while (iVar1 != 0);\nLAB_001da153:\n  sVar2 = strlen(pcVar3);\n  pcVar3 = (char *)xmalloc(sVar2 + 2);\n  lVar4 = (long)(int)DAT_0024a714;\n  *pcVar3 = *param_1;\n  strcpy(pcVar3 + lVar4,DAT_0024a708->pw_name);\n  if (_DAT_0024a718 == 0x7e) {\n    rl_filename_completion_desired = 1;\n  }\n  return pcVar3;\n}\n\n",
  "FUN_001e2490": "\nvoid FUN_001e2490(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  undefined4 uVar2;\n  size_t sVar3;\n  \n  uVar1 = rl_display_prompt;\n  rl_save_prompt(param_1,1,&DAT_0024a88c,&DAT_0024a880,&DAT_0024a878,&DAT_0024a870);\n  rl_display_prompt = param_1;\n  DAT_0024a8a0 = (char *)FUN_001e0bd0();\n  DAT_0024a898 = 0;\n  uVar2 = 0;\n  if (DAT_0024a8a0 != (char *)0x0) {\n    sVar3 = strlen(DAT_0024a8a0);\n    uVar2 = (undefined4)sVar3;\n  }\n  DAT_0024a894 = uVar2;\n  rl_forced_update_display();\n  rl_display_prompt = uVar1;\n  rl_restore_prompt();\n  return;\n}\n\n",
  "print_select_command_head": "\nvoid print_select_command_head(long param_1)\n\n{\n  long **pplVar1;\n  undefined *puVar2;\n  \n  FUN_001446d0(\"select %s in \",**(undefined8 **)(param_1 + 8));\n  for (pplVar1 = *(long ***)(param_1 + 0x10); pplVar1 != (long **)0x0; pplVar1 = (long **)*pplVar1)\n  {\n    puVar2 = &DAT_00213d70;\n    if (*pplVar1 != (long *)0x0) {\n      puVar2 = &DAT_001fdb1c;\n    }\n    FUN_001446d0(&DAT_001fc632,*pplVar1[1],puVar2);\n  }\n  return;\n}\n\n",
  "putc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_putc_00237b00)();\n  return iVar1;\n}\n\n",
  "FUN_001628b0": "\nvoid FUN_001628b0(void)\n\n{\n  if (((interactive_shell == 0) || ((interactive | sourcelevel) != 0)) && (jobs != 0)) {\n    if (DAT_0023877c != 0) {\n      FUN_0015fd20();\n      if ((DAT_0023877c != 0) && (DAT_00247660 == 0)) {\n        FUN_001626a0();\n        return;\n      }\n      return;\n    }\n  }\n  else if ((DAT_0023877c != 0) && (DAT_00247660 == 0)) {\n    FUN_001626a0();\n    return;\n  }\n  return;\n}\n\n",
  "tt_setnoecho": "\nundefined8 tt_setnoecho(long param_1)\n\n{\n  *(uint *)(param_1 + 0xc) = *(uint *)(param_1 + 0xc) & 0xffffff97;\n  return 0;\n}\n\n",
  "_rl_char_search_internal": "\nundefined8 _rl_char_search_internal(undefined8 param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  \n  if (param_2 != 0) {\n    uVar1 = FUN_001edde0();\n    return uVar1;\n  }\n  return 1;\n}\n\n",
  "strchrnul": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchrnul(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strchrnul_002378f8)();\n  return pcVar1;\n}\n\n",
  "sh_strvis": "\nundefined * sh_strvis(char *param_1)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  long local_48;\n  long local_40;\n  undefined8 local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = 0;\n  if (param_1 != (char *)0x0) {\n    if (*param_1 == '\\0') {\n      puVar2 = (undefined *)malloc(1);\n      if (puVar2 != (undefined *)0x0) {\n        *puVar2 = 0;\n      }\n      goto LAB_001ccb4f;\n    }\n    sVar3 = strlen(param_1);\n    puVar2 = (undefined *)malloc(sVar3 * 3 + 1);\n    if (puVar2 != (undefined *)0x0) {\n      local_48 = 0;\n      local_40 = 0;\n      do {\n        iVar1 = sh_charvis(param_1,&local_48,sVar3,puVar2,&local_40);\n        local_48 = (long)iVar1;\n      } while (param_1[local_48] != '\\0');\n      puVar2[local_40] = 0;\n      goto LAB_001ccb4f;\n    }\n  }\n  puVar2 = (undefined *)0x0;\nLAB_001ccb4f:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return puVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001f2720": "\nlong FUN_001f2720(char *param_1,int param_2,int *param_3)\n\n{\n  undefined *__s;\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char *pcVar4;\n  char *pcVar5;\n  int iVar6;\n  long lVar7;\n  long lVar8;\n  size_t __n;\n  int iVar9;\n  long local_68;\n  int local_5c;\n  \n  if (param_3 != (int *)0x0 && param_2 != -1) {\n    *param_3 = -1;\n  }\n  cVar1 = *param_1;\n  if (cVar1 == '\\0') {\n    local_68 = 0;\n  }\n  else {\n    local_5c = 0;\n    lVar7 = 0;\n    local_68 = 0;\n    pcVar4 = param_1;\n    iVar9 = 0;\n    do {\n      while ((1 < (byte)(cVar1 - 9U) && (cVar1 != ' '))) {\n        if (history_comment_char == cVar1) {\n          return local_68;\n        }\n        iVar2 = FUN_001f23f0(param_1,iVar9);\n        __s = history_word_delimiters;\n        if (iVar2 == iVar9) {\n          if (history_word_delimiters == (undefined *)0x0) {\n            __n = 0;\n            lVar8 = 1;\n            pcVar5 = param_1 + iVar9;\n          }\n          else {\n            iVar2 = iVar9 + 1;\n            pcVar5 = param_1 + iVar2;\n            cVar1 = *pcVar5;\n            if (cVar1 != '\\0') {\n              pcVar3 = param_1 + (long)iVar2 + 1;\n              do {\n                pcVar5 = pcVar3;\n                pcVar3 = strchr(__s,(int)cVar1);\n                if (pcVar3 == (char *)0x0) {\n                  lVar7 = (long)(int)lVar7;\n                  goto LAB_001f27d6;\n                }\n                cVar1 = *pcVar5;\n                iVar2 = iVar2 + 1;\n                pcVar3 = pcVar5 + 1;\n              } while (cVar1 != '\\0');\n              lVar7 = (long)(int)lVar7;\n              goto LAB_001f27dc;\n            }\n            __n = 1;\n            lVar8 = 2;\n          }\n        }\n        else {\nLAB_001f27d6:\n          pcVar5 = param_1 + iVar2;\nLAB_001f27dc:\n          __n = (size_t)(iVar2 - iVar9);\n          lVar8 = (long)((iVar2 - iVar9) + 1);\n        }\n        iVar6 = (int)lVar7;\n        if (((param_3 != (int *)0x0 && param_2 != -1) && (iVar9 <= param_2)) && (param_2 < iVar2)) {\n          *param_3 = iVar6;\n        }\n        if (local_5c <= iVar6 + 2) {\n          local_5c = local_5c + 10;\n          local_68 = xrealloc(local_68,(long)local_5c << 3);\n        }\n        pcVar3 = (char *)xmalloc(lVar8);\n        pcVar4 = strncpy(pcVar3,pcVar4,__n);\n        pcVar4[__n] = '\\0';\n        *(char **)(local_68 + lVar7 * 8) = pcVar4;\n        *(undefined8 *)(local_68 + 8 + lVar7 * 8) = 0;\n        cVar1 = *pcVar5;\n        if (cVar1 == '\\0') {\n          return local_68;\n        }\n        lVar7 = (long)(iVar6 + 1);\n        pcVar4 = pcVar5;\n        iVar9 = iVar2;\n      }\n      cVar1 = param_1[iVar9 + 1];\n      pcVar4 = param_1 + (iVar9 + 1);\n      iVar9 = iVar9 + 1;\n    } while (cVar1 != '\\0');\n  }\n  return local_68;\n}\n\n",
  "shell_ungets": "\nvoid shell_ungets(char *param_1)\n\n{\n  ulong uVar1;\n  char *pcVar2;\n  size_t sVar3;\n  char *pcVar4;\n  size_t __n;\n  \n  sVar3 = strlen(param_1);\n  pcVar2 = DAT_00240da8;\n  pcVar4 = DAT_00240da8 + DAT_00240da0;\n  if (*pcVar4 == '\\0') {\n    if ((DAT_00240d98 <= sVar3) && (uVar1 = DAT_00240da0 + 1 + sVar3, DAT_00240d98 <= uVar1)) {\n      do {\n        DAT_00240d98 = DAT_00240d98 + 0x40;\n      } while (DAT_00240d98 <= uVar1);\n      DAT_00240da8 = (char *)sh_xrealloc(DAT_00240da8,DAT_00240d98,\n                                         \"/usr/local/src/chet/src/bash/src/parse.y\",0xab7);\n    }\n    strcpy(DAT_00240da8,param_1);\n    DAT_00240da0 = 0;\n    DAT_00240d8c = 0;\n    DAT_00240d90 = sVar3;\n  }\n  else {\n    if (DAT_00240da0 < sVar3) {\n      if (param_1[sVar3 - 1] != '\\n') {\n        __n = DAT_00240d90 - DAT_00240da0;\n        if ((DAT_00240d98 <= sVar3 + __n) &&\n           (uVar1 = DAT_00240da0 + 1 + sVar3 + __n, DAT_00240d98 <= uVar1)) {\n          do {\n            DAT_00240d98 = DAT_00240d98 + 0x40;\n          } while (DAT_00240d98 <= uVar1);\n          DAT_00240da8 = (char *)sh_xrealloc(DAT_00240da8,DAT_00240d98,\n                                             \"/usr/local/src/chet/src/bash/src/parse.y\",0xad3);\n          __n = DAT_00240d90 - DAT_00240da0;\n          pcVar4 = DAT_00240da8 + DAT_00240da0;\n        }\n        pcVar2 = DAT_00240da8;\n        memmove(DAT_00240da8 + sVar3,pcVar4,__n);\n        pcVar4 = stpcpy(pcVar2,param_1);\n        DAT_00240da0 = 0;\n        DAT_00240d90 = (long)pcVar4 - (long)pcVar2;\n        FUN_001354e0();\n        return;\n      }\n      pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"/usr/local/src/chet/src/bash/src/parse.y\",0xac7);\n      pcVar4 = strcpy(pcVar4,param_1);\n      FUN_001357c0(pcVar4,0,0);\n      return;\n    }\n    if (sVar3 != 0) {\n      DAT_00240da0 = DAT_00240da0 - sVar3;\n      do {\n        sVar3 = sVar3 - 1;\n        pcVar2[sVar3 + DAT_00240da0] = param_1[sVar3];\n      } while (sVar3 != 0);\n      FUN_001354e0();\n      return;\n    }\n  }\n  FUN_001354e0();\n  return;\n}\n\n",
  "clear_fifo_list": "\nvoid clear_fifo_list(void)\n\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  \n  lVar2 = DAT_00247838;\n  iVar1 = DAT_00247830;\n  if (DAT_00247834 == 0) {\n    return;\n  }\n  lVar3 = 0;\n  do {\n    while( true ) {\n      if (iVar1 <= (int)lVar3) {\n        DAT_00247834 = 0;\n        return;\n      }\n      if (*(int *)(lVar2 + lVar3 * 4) != 0) break;\n      lVar3 = lVar3 + 1;\n    }\n    *(undefined4 *)(lVar2 + lVar3 * 4) = 0;\n    lVar3 = lVar3 + 1;\n    DAT_00247834 = DAT_00247834 + -1;\n  } while (DAT_00247834 != 0);\n  DAT_00247834 = 0;\n  return;\n}\n\n",
  "get_alias_value": "\nundefined8 get_alias_value(undefined8 param_1)\n\n{\n  long lVar1;\n  \n  if (aliases == 0) {\n    return 0;\n  }\n  lVar1 = hash_search(param_1,aliases,0);\n  if ((lVar1 != 0) && (*(long *)(lVar1 + 0x10) != 0)) {\n    return *(undefined8 *)(*(long *)(lVar1 + 0x10) + 8);\n  }\n  return 0;\n}\n\n",
  "_rl_uppercase_p": "\nbyte _rl_uppercase_p(uint param_1)\n\n{\n  ushort **ppuVar1;\n  \n  ppuVar1 = __ctype_b_loc();\n  return *(byte *)((long)*ppuVar1 + (ulong)(param_1 & 0xff) * 2 + 1) & 1;\n}\n\n",
  "FUN_0019b360": "\nchar * FUN_0019b360(undefined8 param_1,char *param_2,ulong param_3,undefined8 param_4,uint *param_5)\n\n{\n  uint uVar1;\n  int iVar2;\n  char *__s;\n  size_t sVar3;\n  char *pcVar4;\n  long *plVar5;\n  \n  if ((posixly_correct == 0) && (*param_2 == '~')) {\n    pcVar4 = (char *)bash_tilde_expand(param_2,0);\n    if ((dot_found_in_search == 0) && (*pcVar4 == '.')) {\nLAB_0019b465:\n      dot_found_in_search = same_file(\".\",pcVar4,param_4,0);\n    }\n    __s = (char *)sh_makepath(pcVar4,param_1,0);\n    uVar1 = file_status(__s);\n    if (param_2 != pcVar4) {\n      sh_xfree(pcVar4,\"findcmd.c\",0x223);\n    }\n  }\n  else {\n    if ((dot_found_in_search == 0) && (pcVar4 = param_2, *param_2 == '.')) goto LAB_0019b465;\n    __s = (char *)sh_makepath(param_2,param_1,0);\n    uVar1 = file_status(__s);\n  }\n  if (param_5 != (uint *)0x0) {\n    *param_5 = uVar1;\n  }\n  if ((uVar1 & 1) == 0) {\n    sh_xfree(__s,\"findcmd.c\",0x22a);\n    return (char *)0x0;\n  }\n  if ((param_3 & 1) != 0) {\n    return __s;\n  }\n  if (((param_3 & 0x40) != 0) && ((uVar1 & 0x40) != 0)) {\n    return __s;\n  }\n  if ((uVar1 & 2) == 0) {\n    if ((param_3 & 4) != 0) goto joined_r0x0019b4d1;\nLAB_0019b422:\n    if ((param_3 & 0xc) != 0) goto LAB_0019b4ea;\n  }\n  else {\n    if ((param_3 & 0xc) != 0) {\n      if (((param_3 & 0x20) == 0) || ((uVar1 & 0x10) == 0)) {\n        if (DAT_002489e8 != (char *)0x0) {\n          sh_xfree(DAT_002489e8,\"findcmd.c\",0x23c);\n        }\n        DAT_002489e8 = (char *)0x0;\n        return __s;\n      }\n      if ((param_3 & 4) == 0) goto LAB_0019b4ea;\njoined_r0x0019b4d1:\n      if (DAT_002489e8 == (char *)0x0) {\n        plVar5 = DAT_00238da8;\n        if (DAT_00238da8 != (long *)0x0) {\n          for (; *plVar5 != 0; plVar5 = plVar5 + 2) {\n            iVar2 = strmatch(*plVar5,__s,(-(uint)(extended_glob == 0) & 0xffffffe0) + 0x30);\n            if (iVar2 != 1) goto LAB_0019b422;\n          }\n        }\n        sVar3 = strlen(__s);\n        pcVar4 = (char *)sh_xmalloc(sVar3 + 1,\"findcmd.c\",0x245);\n        DAT_002489e8 = strcpy(pcVar4,__s);\n      }\n      goto LAB_0019b422;\n    }\n    if ((param_3 & 4) != 0) goto joined_r0x0019b4d1;\n  }\n  if (((param_3 & 0x20) == 0) || ((uVar1 & 0x10) == 0)) {\n    if ((param_3 & 0x40) == 0) {\n      return __s;\n    }\n    if ((uVar1 & 0x40) != 0) {\n      return __s;\n    }\n  }\nLAB_0019b4ea:\n  sh_xfree(__s,\"findcmd.c\",0x24e);\n  return (char *)0x0;\n}\n\n",
  "zcatfd": "\nundefined8 zcatfd(undefined4 param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined auStack_1028 [4104];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  do {\n    lVar2 = zread(param_1,auStack_1028,0x1000);\n    if (lVar2 == 0) {\n      uVar3 = 0;\n      goto LAB_001cae3d;\n    }\n    if (lVar2 < 0) break;\n    iVar1 = zwrite(param_2,auStack_1028,lVar2);\n  } while (-1 < iVar1);\n  uVar3 = 0xffffffff;\nLAB_001cae3d:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001eb820": "\nint FUN_001eb820(void)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  int *piVar4;\n  ssize_t sVar5;\n  long lVar6;\n  ulong uVar7;\n  ulong *puVar8;\n  int iVar9;\n  long in_FS_OFFSET;\n  bool bVar10;\n  byte bVar11;\n  char local_14d;\n  int local_14c;\n  long local_148;\n  long local_140;\n  ulong local_138 [16];\n  ulong local_b8 [17];\n  long local_30;\n  \n  bVar11 = 0;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  local_14d = '\\0';\n  local_14c = 0;\n  iVar1 = fileno(rl_instream);\n  puVar8 = local_138;\n  for (lVar6 = 0x10; lVar6 != 0; lVar6 = lVar6 + -1) {\n    *puVar8 = 0;\n    puVar8 = puVar8 + (ulong)bVar11 * -2 + 1;\n  }\n  puVar8 = local_b8;\n  for (lVar6 = 0x10; lVar6 != 0; lVar6 = lVar6 + -1) {\n    *puVar8 = 0;\n    puVar8 = puVar8 + (ulong)bVar11 * -2 + 1;\n  }\n  lVar6 = __fdelt_chk((long)iVar1);\n  uVar7 = 1L << ((byte)iVar1 & 0x3f);\n  local_138[lVar6] = local_138[lVar6] | uVar7;\n  lVar6 = __fdelt_chk((long)iVar1);\n  local_b8[lVar6] = local_b8[lVar6] | uVar7;\n  local_148 = (long)(DAT_00240538 / 1000000);\n  local_140 = (long)(DAT_00240538 % 1000000);\n  iVar2 = _rl_timeout_select(iVar1 + 1,local_138,0,local_b8,&local_148,0);\n  if (0 < iVar2) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    iVar2 = ioctl(iVar1,0x541b,&local_14c);\n    if (iVar2 == -1) {\n      iVar9 = -1;\n      if (*piVar4 == 5) goto LAB_001eba63;\n      local_14c = 0;\n      uVar3 = fcntl(iVar1,3,0);\n      fcntl(iVar1,4,(ulong)uVar3 | 0x800);\n      sVar5 = read(iVar1,&local_14d,1);\n      local_14c = (int)sVar5;\n      fcntl(iVar1,4,(ulong)uVar3);\n      if (local_14c == -1) {\n        if (*piVar4 != 0xb) {\n          iVar9 = -(uint)(*piVar4 == 5);\n          goto LAB_001eba63;\n        }\n      }\n      else {\n        if (local_14c != 0) goto LAB_001eb935;\n        rl_stuff_char(0xffffffff);\n      }\n    }\n    else {\nLAB_001eb935:\n      if (0 < local_14c) {\n        if (DAT_0024b3e0 < DAT_0024b3e4) {\n          iVar1 = (DAT_0024b3e4 - DAT_0024b3e0) + -1;\n        }\n        else {\n          iVar1 = (DAT_0024b3e4 - DAT_0024b3e0) + 0x1ff;\n        }\n        if (iVar1 < local_14c) {\n          local_14c = iVar1;\n        }\n        if (0x1fe < iVar1) {\n          if (iVar2 == -1) {\n            if (local_14c != 0) {\n              rl_stuff_char((int)local_14d);\n            }\n          }\n          else {\n            while (iVar1 = local_14c + -1, bVar10 = local_14c != 0, local_14c = iVar1, bVar10) {\n              if (_rl_caught_signal != 0) {\n                _rl_signal_handler(_rl_caught_signal);\n              }\n              iVar1 = (*(code *)rl_getc_function)(rl_instream);\n              iVar2 = rl_stuff_char(iVar1);\n              if (((iVar2 == 0) || (iVar1 == 10)) || (iVar1 == 0xd)) break;\n            }\n          }\n        }\n        iVar9 = 1;\n        goto LAB_001eba63;\n      }\n    }\n  }\n  iVar9 = 0;\nLAB_001eba63:\n  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar9;\n}\n\n",
  "FUN_00170ca0": "\nlong ** FUN_00170ca0(long **param_1)\n\n{\n  long **pplVar1;\n  int iVar2;\n  long **pplVar3;\n  long *plVar4;\n  undefined8 uVar5;\n  long lVar6;\n  long **pplVar7;\n  long *plVar8;\n  long **pplVar9;\n  long **local_40;\n  \n  pplVar7 = (long **)0x0;\n  local_40 = (long **)0x0;\n  if (param_1 != (long **)0x0) {\n    do {\n      while( true ) {\n        pplVar9 = param_1;\n        param_1 = (long **)*pplVar9;\n        plVar4 = pplVar9[1];\n        if ((*(byte *)(plVar4 + 1) & 0x20) == 0) break;\nLAB_00170cd0:\n        lVar6 = dequote_string(*plVar4);\n        sh_xfree(*pplVar9[1],\"subst.c\",0x3052);\n        *pplVar9[1] = lVar6;\n        plVar4 = (long *)0x0;\n        pplVar3 = pplVar7;\n        pplVar7 = pplVar9;\n        pplVar1 = local_40;\nLAB_00170cff:\n        local_40 = pplVar1;\n        *pplVar9 = (long *)pplVar3;\n        strvec_dispose(plVar4);\n        if (param_1 == (long **)0x0) goto LAB_00170dd0;\n      }\n      iVar2 = unquoted_glob_pattern_p(*plVar4);\n      plVar4 = pplVar9[1];\n      if (iVar2 == 0) goto LAB_00170cd0;\n      plVar4 = (long *)shell_glob_filename(*plVar4,8);\n      if ((plVar4 == &glob_error_return) || (plVar4 == (long *)0x0)) {\n        plVar4 = (long *)sh_xmalloc(8,\"subst.c\",0x3024);\n        *plVar4 = 0;\nLAB_00170e3c:\n        lVar6 = dequote_string(*pplVar9[1]);\n        sh_xfree(*pplVar9[1],\"subst.c\",0x302c);\n        *pplVar9[1] = lVar6;\n        if (*plVar4 != 0) goto LAB_00170d69;\nLAB_00170e78:\n        if (fail_glob_expansion != 0) {\n          last_command_exit_value = 1;\n          report_error(\"no match: %s\",*pplVar9[1]);\n                    /* WARNING: Subroutine does not return */\n          FUN_001667f0(2);\n        }\n        pplVar3 = local_40;\n        pplVar1 = pplVar9;\n        if (allow_null_glob_expansion == 0) {\n          pplVar3 = pplVar7;\n          pplVar7 = pplVar9;\n          pplVar1 = local_40;\n        }\n        goto LAB_00170cff;\n      }\n      if (*plVar4 == 0) goto LAB_00170e3c;\nLAB_00170d69:\n      lVar6 = 0;\n      plVar8 = plVar4;\n      do {\n        plVar8 = plVar8 + 1;\n        uVar5 = make_bare_word();\n        lVar6 = make_word_list(uVar5,lVar6);\n      } while (*plVar8 != 0);\n      if (lVar6 == 0) goto LAB_00170e78;\n      pplVar7 = (long **)list_append(lVar6,pplVar7);\n      *pplVar9 = (long *)local_40;\n      strvec_dispose(plVar4);\n      local_40 = pplVar9;\n    } while (param_1 != (long **)0x0);\nLAB_00170dd0:\n    if (local_40 != (long **)0x0) {\n      dispose_words(local_40);\n    }\n    if (pplVar7 != (long **)0x0) {\n      if (*pplVar7 == (long *)0x0) {\n        return pplVar7;\n      }\n      pplVar7 = (long **)list_reverse(pplVar7);\n      return pplVar7;\n    }\n  }\n  return (long **)0x0;\n}\n\n",
  "find_variable_last_nameref": "\nlong find_variable_last_nameref(undefined8 param_1,int param_2)\n\n{\n  char *pcVar1;\n  long lVar2;\n  long lVar3;\n  int iVar4;\n  long lVar5;\n  bool bVar6;\n  \n  bVar6 = false;\n  if (expanding_redir == 0) {\n    bVar6 = (assigning_in_environment | executing_builtin) != 0;\n  }\n  lVar2 = FUN_00152c60(param_1,bVar6);\n  iVar4 = 9;\n  lVar3 = lVar2;\n  if (lVar2 == 0) {\nLAB_001531fc:\n    lVar5 = 0;\n  }\n  else {\n    do {\n      lVar5 = lVar3;\n      if ((*(uint *)(lVar5 + 0x28) & 0x800) == 0) {\n        return lVar2;\n      }\n      iVar4 = iVar4 + -1;\n      if (iVar4 == 0) goto LAB_001531fc;\n      pcVar1 = *(char **)(lVar5 + 8);\n      if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\\0')) {\n        if ((param_2 != 0) && ((*(uint *)(lVar5 + 0x28) & 0x1000) != 0)) {\n          return lVar5;\n        }\n        goto LAB_001531fc;\n      }\n      bVar6 = false;\n      if (expanding_redir == 0) {\n        bVar6 = (assigning_in_environment | executing_builtin) != 0;\n      }\n      lVar3 = FUN_00152c60(pcVar1,bVar6);\n      lVar2 = lVar5;\n    } while (lVar3 != 0);\n  }\n  return lVar5;\n}\n\n",
  "parse_command": "\nulong parse_command(void)\n\n{\n  uint uVar1;\n  char *pcVar2;\n  int iVar3;\n  ulong uVar4;\n  long lVar5;\n  long lVar6;\n  \n  need_here_doc = 0;\n  run_pending_traps();\n  if ((interactive == 0) || (bash_input == 3)) goto LAB_0013441c;\n  iVar3 = parser_expanding_alias();\n  if (iVar3 != 0) goto LAB_0013441c;\n  if (no_line_editing == 0) {\n    if (bash_input == 1) {\n      iVar3 = parser_will_prompt();\n      if (iVar3 != 0) goto LAB_001344e8;\n    }\n  }\n  else {\nLAB_001344e8:\n    lVar6 = find_variable(\"PROMPT_COMMAND\");\n    if (((lVar6 != 0) && (pcVar2 = *(char **)(lVar6 + 8), pcVar2 != (char *)0x0)) &&\n       (uVar1 = *(uint *)(lVar6 + 0x28), (uVar1 & 0x1000) == 0)) {\n      if ((uVar1 & 4) == 0) {\n        if (((uVar1 & 0x40) == 0) && (*pcVar2 != '\\0')) {\n          execute_variable_command(pcVar2,\"PROMPT_COMMAND\");\n        }\n      }\n      else if (0 < *(long *)(pcVar2 + 8)) {\n        execute_array_command(pcVar2,\"PROMPT_COMMAND\");\n      }\n    }\n  }\n  if (running_under_emacs == 2) {\n    lVar5 = get_string_value(&DAT_001fc3d5);\n    lVar6 = 0;\n    if (lVar5 == 0) {\n      lVar5 = get_working_directory(\"eterm\");\n      lVar6 = lVar5;\n    }\n    __fprintf_chk(stderr,1,&DAT_001fa61a,lVar5);\n    sh_xfree(lVar6,\"eval.c\",0x107);\n  }\nLAB_0013441c:\n  current_command_line_count = 0;\n  uVar4 = yyparse();\n  if (need_here_doc == 0) {\n    return uVar4;\n  }\n  gather_here_documents();\n  return uVar4 & 0xffffffff;\n}\n\n",
  "rl_read_init_file": "\nundefined8 rl_read_init_file(char *param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  if ((((param_1 == (char *)0x0) && (param_1 = DAT_0024a7b0, DAT_0024a7b0 == (char *)0x0)) &&\n      (param_1 = (char *)sh_get_env_value(\"INPUTRC\"), param_1 == (char *)0x0)) || (*param_1 == '\\0')\n     ) {\n    iVar1 = FUN_001ddf90(\"~/.inputrc\",0);\n    param_1 = \"/etc/inputrc\";\n    if (iVar1 == 0) {\n      return 0;\n    }\n  }\n  uVar2 = FUN_001ddf90(param_1,0);\n  return uVar2;\n}\n\n",
  "phash_insert": "\nvoid phash_insert(char *param_1,char *param_2,int param_3,undefined4 param_4)\n\n{\n  char **ppcVar1;\n  long lVar2;\n  uint uVar3;\n  long lVar4;\n  size_t sVar5;\n  char *pcVar6;\n  undefined8 uVar7;\n  \n  if (hashing_enabled != 0) {\n    if (hashed_filenames == 0) {\n      hashed_filenames = hash_create(0x100);\n    }\n    lVar4 = hash_insert(param_1,hashed_filenames,0);\n    if (*(undefined8 **)(lVar4 + 0x10) == (undefined8 *)0x0) {\n      sVar5 = strlen(param_1);\n      pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"hashcmd.c\",0x6d);\n      pcVar6 = strcpy(pcVar6,param_1);\n      *(char **)(lVar4 + 8) = pcVar6;\n      uVar7 = sh_xmalloc(0x10,\"hashcmd.c\",0x6e);\n      *(undefined8 *)(lVar4 + 0x10) = uVar7;\n    }\n    else {\n      sh_xfree(**(undefined8 **)(lVar4 + 0x10),\"hashcmd.c\",0x6a);\n    }\n    sVar5 = strlen(param_2);\n    pcVar6 = (char *)sh_xmalloc(sVar5 + 1,\"hashcmd.c\",0x70);\n    ppcVar1 = *(char ***)(lVar4 + 0x10);\n    pcVar6 = strcpy(pcVar6,param_2);\n    lVar2 = *(long *)(lVar4 + 0x10);\n    *ppcVar1 = pcVar6;\n    uVar3 = (uint)(param_3 != 0) * 2;\n    *(uint *)(lVar2 + 8) = uVar3;\n    if (*param_2 != '/') {\n      *(uint *)(lVar2 + 8) = uVar3 | 1;\n    }\n    *(undefined4 *)(lVar4 + 0x1c) = param_4;\n    return;\n  }\n  return;\n}\n\n",
  "quote_rhs": "\nvoid quote_rhs(undefined8 param_1)\n\n{\n  FUN_00167220(param_1,4);\n  return;\n}\n\n",
  "FUN_0014f460": "\nint FUN_0014f460(undefined8 *param_1,undefined8 *param_2,ulong param_3,undefined8 param_4,\n                undefined4 param_5,int param_6)\n\n{\n  int iVar1;\n  int iVar2;\n  long lVar3;\n  long lVar4;\n  long lVar5;\n  long lVar6;\n  long lVar7;\n  size_t sVar8;\n  char *__dest;\n  char *pcVar9;\n  long lVar10;\n  undefined8 uVar11;\n  undefined8 *puVar12;\n  undefined *puVar13;\n  undefined8 uVar14;\n  undefined8 local_88;\n  undefined8 local_80;\n  char *local_68;\n  char *local_60;\n  \n  if ((0 < funcnest_max) && (funcnest_max <= funcnest)) {\n    internal_error(\"%s: maximum function nesting level exceeded (%d)\",*param_1);\n    funcnest = 0;\n                    /* WARNING: Subroutine does not return */\n    jump_to_top_level(2);\n  }\n  lVar3 = find_variable(\"FUNCNAME\");\n  local_88 = 0;\n  if ((lVar3 != 0) && ((*(byte *)(lVar3 + 0x28) & 4) != 0)) {\n    local_88 = *(undefined8 *)(lVar3 + 8);\n  }\n  uVar14 = 0;\n  lVar4 = find_variable(\"BASH_SOURCE\");\n  if ((lVar4 != 0) && ((*(byte *)(lVar4 + 0x28) & 4) != 0)) {\n    uVar14 = *(undefined8 *)(lVar4 + 8);\n  }\n  lVar5 = find_variable(\"BASH_LINENO\");\n  local_80 = 0;\n  if ((lVar5 != 0) && ((*(byte *)(lVar5 + 0x28) & 4) != 0)) {\n    local_80 = *(undefined8 *)(lVar5 + 8);\n  }\n  lVar6 = copy_command(param_1[1]);\n  if (lVar6 != 0) {\n    if ((param_3 & 8) != 0) {\n      *(uint *)(lVar6 + 4) = *(uint *)(lVar6 + 4) | 8;\n    }\n    if (((param_3 & 0x40) != 0) && (((byte)subshell_environment & 4) != 0)) {\n      optimize_shell_function(lVar6);\n    }\n  }\n  lVar7 = sh_getopt_save_istate();\n  if (param_6 == 0) {\n    begin_unwind_frame(\"function_calling\");\n    push_context(*param_1,0,temporary_env);\n    add_unwind_protect(FUN_001498b0,lVar7);\n    add_unwind_protect(pop_context,0);\n    unwind_protect_mem(&line_number,4);\n    unwind_protect_mem(&line_number_for_err_trap,4);\n    unwind_protect_mem(&DAT_00242170,4);\n    unwind_protect_mem(&return_catch_flag,4);\n    unwind_protect_mem(return_catch,200);\n    add_unwind_protect(dispose_command,lVar6);\n    unwind_protect_mem(&this_shell_function,8);\n    unwind_protect_mem(&funcnest,4);\n    unwind_protect_mem(&loop_level,4);\n  }\n  else {\n    push_context(*param_1,1,temporary_env);\n  }\n  temporary_env = 0;\n  this_shell_function = param_1;\n  make_funcname_visible(1);\n  iVar1 = signal_is_trapped(0x41);\n  if ((iVar1 == 0) || (iVar1 = signal_is_ignored(0x41), pcVar9 = DAT_00247c08, iVar1 != 0)) {\n    pcVar9 = (char *)0x0;\n    iVar1 = signal_is_trapped(0x42);\n    if (iVar1 != 0) goto LAB_0014f9d5;\nLAB_0014f688:\n    local_60 = (char *)0x0;\n    iVar1 = signal_is_trapped(0x43);\n    if (iVar1 == 0) goto LAB_0014f6a3;\nLAB_0014fa05:\n    iVar1 = signal_is_ignored(0x43);\n    if (iVar1 != 0) goto LAB_0014f6a3;\n    local_68 = DAT_00247c18;\n  }\n  else {\n    iVar1 = signal_is_trapped(0x42);\n    if (iVar1 == 0) goto LAB_0014f688;\nLAB_0014f9d5:\n    iVar1 = signal_is_ignored(0x42);\n    if (iVar1 != 0) goto LAB_0014f688;\n    local_60 = DAT_00247c10;\n    iVar1 = signal_is_trapped(0x43);\n    if (iVar1 != 0) goto LAB_0014fa05;\nLAB_0014f6a3:\n    local_68 = (char *)0x0;\n  }\n  if ((pcVar9 != (char *)0x0) && ((*(uint *)(param_1 + 5) & 0x80 | function_trace_mode) == 0)) {\n    if (param_6 == 0) {\n      sVar8 = strlen(pcVar9);\n      __dest = (char *)sh_xmalloc(sVar8 + 1,\"execute_cmd.c\",0x1405);\n      pcVar9 = strcpy(__dest,pcVar9);\n      add_unwind_protect(xfree,pcVar9);\n      add_unwind_protect(maybe_set_debug_trap,pcVar9);\n    }\n    restore_default_signal(0x41);\n  }\n  if ((local_60 != (char *)0x0) && (error_trace_mode == 0)) {\n    if (param_6 == 0) {\n      sVar8 = strlen(local_60);\n      pcVar9 = (char *)sh_xmalloc(sVar8 + 1,\"execute_cmd.c\",0x1411);\n      pcVar9 = strcpy(pcVar9,local_60);\n      add_unwind_protect(xfree,pcVar9);\n      add_unwind_protect(maybe_set_error_trap,pcVar9);\n    }\n    restore_default_signal(0x42);\n  }\n  if ((local_68 != (char *)0x0) &&\n     ((iVar1 = signal_in_progress(0x41), iVar1 != 0 ||\n      ((*(uint *)(param_1 + 5) & 0x80 | function_trace_mode) == 0)))) {\n    if (param_6 == 0) {\n      sVar8 = strlen(local_68);\n      pcVar9 = (char *)sh_xmalloc(sVar8 + 1,\"execute_cmd.c\",0x141e);\n      pcVar9 = strcpy(pcVar9,local_68);\n      add_unwind_protect(xfree,pcVar9);\n      add_unwind_protect(maybe_set_return_trap,pcVar9);\n    }\n    restore_default_signal(0x43);\n  }\n  funcnest = funcnest + 1;\n  puVar13 = &DAT_00213d70;\n  lVar10 = find_function_def(*this_shell_function);\n  if (lVar10 != 0) {\n    puVar13 = *(undefined **)(lVar10 + 0x18);\n  }\n  array_rshift(local_88,1,*this_shell_function);\n  array_rshift(uVar14,1,puVar13);\n  iVar1 = signal_in_progress(0x42);\n  if ((iVar1 == 0) || (iVar1 = line_number_for_err_trap, running_trap != 0x43)) {\n    iVar1 = executing_line_number();\n  }\n  uVar11 = itos((long)iVar1);\n  array_rshift(local_80,1,uVar11);\n  sh_xfree(uVar11,\"execute_cmd.c\",0x1430);\n  puVar12 = (undefined8 *)sh_xmalloc(0x30,\"execute_cmd.c\",0x1434);\n  puVar12[4] = local_80;\n  puVar12[2] = uVar14;\n  puVar12[3] = lVar4;\n  puVar12[5] = lVar5;\n  *puVar12 = local_88;\n  puVar12[1] = lVar3;\n  if (param_6 == 0) {\n    add_unwind_protect(restore_funcarray_state,puVar12);\n  }\n  if ((debugging_mode != 0) || (shell_compatibility_level < 0x2d)) {\n    init_bash_argv();\n  }\n  remember_args(*param_2,1);\n  if (debugging_mode == 0) {\nLAB_0014f8d1:\n    line_number = *(undefined4 *)(lVar6 + 8);\n    DAT_00242170 = line_number;\n    if (param_6 == 0) goto LAB_0014f8f3;\n  }\n  else {\n    push_args(*param_2);\n    if (param_6 == 0) {\n      add_unwind_protect(pop_args,0);\n      goto LAB_0014f8d1;\n    }\n    DAT_00242170 = *(undefined4 *)(lVar6 + 8);\n  }\n  line_number = DAT_00242170;\n  stop_pipeline(param_5,0);\nLAB_0014f8f3:\n  if (0x2b < shell_compatibility_level) {\n    loop_level = 0;\n  }\n  return_catch_flag = return_catch_flag + 1;\n  from_return_trap = 0;\n  iVar2 = __sigsetjmp(return_catch,0);\n  uVar14 = DAT_00242178;\n  iVar1 = return_catch_value;\n  if (iVar2 == 0) {\n    DAT_0024216c = 1;\n    iVar1 = run_debug_trap();\n    if ((debugging_mode == 0) || (iVar1 == 0)) {\n      DAT_0024216c = 0;\n      DAT_00242178 = uVar14;\n      iVar1 = execute_command_internal(lVar6,0,0xffffffff,0xffffffff,param_4);\n      uVar14 = DAT_00242178;\n      run_return_trap();\n      DAT_0024216c = 0;\n      DAT_00242178 = uVar14;\n    }\n    else {\n      DAT_0024216c = 0;\n    }\n  }\n  else {\n    DAT_00242178 = uVar14;\n    if (from_return_trap == 0) {\n      run_return_trap();\n      DAT_00242178 = uVar14;\n    }\n  }\n  lVar3 = find_variable(\"OPTIND\");\n  if ((lVar3 != 0) && (*(int *)(lVar3 + 0x2c) == variable_context)) {\n    *(uint *)(lVar7 + 0x1c) = *(uint *)(lVar7 + 0x1c) | 1;\n  }\n  if (param_6 == 0) {\n    run_unwind_frame(\"function_calling\");\n  }\n  else {\n    restore_funcarray_state(puVar12);\n    if (debugging_mode != 0) {\n      pop_args();\n    }\n  }\n  if ((variable_context == 0) || (this_shell_function == (undefined8 *)0x0)) {\n    make_funcname_visible(0);\n    unlink_fifo_list();\n  }\n  return iVar1;\n}\n\n",
  "reader_loop": "\nint reader_loop(void)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined4 uVar3;\n  int iVar4;\n  char *__s;\n  long local_10;\n  \n  local_10 = 0;\n  iVar2 = indirection_level + 1;\n  indirection_level = iVar2;\n  if (just_one_command != 0) {\n    reset_readahead_token();\n  }\n  do {\n    if (EOF_Reached != 0) goto LAB_001347c8;\n    uVar3 = __sigsetjmp(top_level,0);\n    unlink_fifo_list();\n    if (((interactive_shell != 0) && (iVar4 = signal_is_ignored(2), iVar4 == 0)) &&\n       (iVar4 = signal_is_trapped(2), iVar4 == 0)) {\n      set_signal_handler(2);\n    }\n    iVar4 = iVar2;\n    switch(uVar3) {\n    case 1:\n    case 3:\n    case 6:\n      break;\n    case 2:\n      indirection_level = iVar2;\n      if (last_command_exit_value == 0) {\n        set_exit_status(1);\n      }\n      iVar4 = indirection_level;\n      if (subshell_environment == 0) {\n        if (local_10 != 0) {\n          dispose_command(local_10);\n          local_10 = 0;\n        }\n        restore_sigmask();\n        goto LAB_00134770;\n      }\n      break;\n    case 4:\n      if (exit_immediately_on_error != 0) {\n        indirection_level = iVar2;\n        reset_local_contexts();\n        iVar4 = indirection_level;\n      }\n      break;\n    case 5:\n      indirection_level = iVar2;\n      command_error(\"reader_loop\",3,uVar3,0);\n    default:\nLAB_00134770:\n      executing = 0;\n      if (temporary_env != 0) {\n        dispose_used_env_vars();\n      }\n      iVar4 = read_command();\n      lVar1 = global_command;\n      if (iVar4 == 0) {\n        if ((interactive_shell == 0) && (read_but_dont_execute != 0)) {\n          set_exit_status(last_command_exit_value);\n          dispose_command(global_command);\n          global_command = 0;\n          goto LAB_001347b0;\n        }\n        local_10 = global_command;\n        if (global_command == 0) goto LAB_001347b0;\n        global_command = 0;\n        if ((interactive != 0) && (ps0_prompt != 0)) {\n          __s = (char *)decode_prompt_string();\n          if ((__s != (char *)0x0) && (*__s != '\\0')) {\n            fputs(__s,stderr);\n            fflush(stderr);\n          }\n          sh_xfree(__s,\"eval.c\",0xa3);\n        }\n        current_command_number = current_command_number + 1;\n        executing = 1;\n        stdin_redir = 0;\n        execute_command(lVar1);\n        goto LAB_001348f3;\n      }\n      if (interactive == 0) {\n        EOF_Reached = -1;\n      }\n      goto LAB_001347b0;\n    }\n    indirection_level = iVar4;\n    local_10 = 0;\n    EOF_Reached = -1;\nLAB_001348f3:\n    if (terminating_signal != 0) {\n      termsig_handler(terminating_signal);\n    }\n    if (interrupt_state != 0) {\n      throw_to_top_level();\n    }\n    if (local_10 != 0) {\n      dispose_command(local_10);\n      local_10 = 0;\n    }\nLAB_001347b0:\n  } while (just_one_command == 0);\n  EOF_Reached = -1;\nLAB_001347c8:\n  indirection_level = indirection_level + -1;\n  return last_command_exit_value;\n}\n\n",
  "FUN_0015e6b0": "\nulong FUN_0015e6b0(int param_1,int param_2,long **param_3)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  ulong uVar4;\n  \n  if (0 < DAT_0023877c) {\n    uVar4 = 0;\n    do {\n      lVar1 = *(long *)(jobs + uVar4 * 8);\n      if (lVar1 != 0) {\n        plVar2 = *(long **)(lVar1 + 8);\n        plVar3 = plVar2;\n        do {\n          if ((*(int *)(plVar3 + 1) == param_1) &&\n             (((param_2 == 0 || (*(int *)(plVar3 + 2) == 1)) ||\n              (*(char *)((long)plVar3 + 0xc) == '\\x7f')))) {\n            if (param_3 != (long **)0x0) {\n              *param_3 = plVar3;\n            }\n            return uVar4 & 0xffffffff;\n          }\n          plVar3 = (long *)*plVar3;\n        } while (plVar2 != plVar3);\n      }\n      uVar4 = uVar4 + 1;\n    } while (uVar4 != (long)DAT_0023877c);\n  }\n  return 0xffffffff;\n}\n\n",
  "FUN_001d34a0": "\nundefined8 FUN_001d34a0(undefined4 *param_1)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  size_t sVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  char acStack_48 [24];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = _rl_bracketed_read_mbstring(acStack_48,0x10);\n  if (-1 < iVar2) {\n    sVar3 = __ctype_get_mb_cur_max();\n    if ((sVar3 < 2) || (rl_byte_oriented != 0)) {\n      DAT_0024a3d0 = (undefined)iVar2;\n    }\n    else {\n      strncpy(&DAT_0024a3d0,acStack_48,0x10);\n    }\n    DAT_0024a3e0 = 0;\n    uVar1 = *param_1;\n    _rl_callback_func = 0;\n    _rl_want_redisplay = 1;\n    if ((iVar2 != 0x1b) && (iVar2 != 3)) {\n      rl_begin_undo_group();\n      uVar4 = FUN_001d33a0(uVar1,iVar2,acStack_48);\n      goto LAB_001d3532;\n    }\n  }\n  uVar4 = 0xffffffff;\nLAB_001d3532:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "set_sigint_handler": "\nundefined8 set_sigint_handler(void)\n\n{\n  undefined8 uVar1;\n  \n  if ((DAT_00247e48 & 2) != 0) {\n    return 1;\n  }\n  if ((DAT_00247e48 & 0x40) != 0) {\n    uVar1 = set_signal_handler(2,1);\n    return uVar1;\n  }\n  if ((DAT_00247e48 & 1) != 0) {\n    uVar1 = set_signal_handler(2,trap_handler);\n    return uVar1;\n  }\n  if (interactive != 0) {\n    uVar1 = set_signal_handler(2,sigint_sighandler);\n    return uVar1;\n  }\n  uVar1 = set_signal_handler(2,termsig_sighandler);\n  return uVar1;\n}\n\n",
  "_rl_char_value": "\nwchar_t _rl_char_value(char *param_1,int param_2)\n\n{\n  int iVar1;\n  wchar_t wVar2;\n  size_t sVar3;\n  char *__s;\n  long in_FS_OFFSET;\n  wchar_t local_2c;\n  mbstate_t local_28;\n  long local_20;\n  \n  __s = param_1 + param_2;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (rl_byte_oriented == 0) {\n    if ((_rl_utf8locale != 0) && (wVar2 = (int)*__s, -1 < *__s)) goto LAB_001f6ce4;\n    sVar3 = strlen(param_1);\n    iVar1 = (int)sVar3;\n    if (param_2 < iVar1 + -1) {\n      if (iVar1 < param_2) {\n        sVar3 = strlen(__s);\n        iVar1 = (int)sVar3;\n      }\n      local_28.__count = 0;\n      local_28.__value = (_union_27)0x0;\n      sVar3 = mbrtowc(&local_2c,__s,(long)(iVar1 - param_2),&local_28);\n      wVar2 = local_2c;\n      if (sVar3 - 1 < 0xfffffffffffffffd) goto LAB_001f6ce4;\n    }\n  }\n  wVar2 = (wchar_t)*__s;\nLAB_001f6ce4:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return wVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_backward_kill_word": "\nundefined8 rl_backward_kill_word(int param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  iVar1 = rl_point;\n  if (param_1 < 0) {\n    uVar2 = rl_kill_word(-param_1);\n    return uVar2;\n  }\n  rl_backward_word();\n  if (rl_point != iVar1) {\n    rl_kill_text(iVar1);\n  }\n  if (rl_editing_mode == 1) {\n    rl_mark = rl_point;\n    return 0;\n  }\n  return 0;\n}\n\n",
  "sh_valloc": "\nulong sh_valloc(long param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  int iVar1;\n  ulong uVar2;\n  ulong uVar3;\n  long lVar4;\n  \n  iVar1 = getpagesize();\n  lVar4 = (long)iVar1;\n  uVar2 = FUN_001f85f0(param_1 + lVar4,param_2,param_3);\n  uVar3 = uVar2;\n  if ((uVar2 != 0) && ((uVar2 & lVar4 - 1U) != 0)) {\n    uVar3 = (uVar2 - 1) + lVar4 & -lVar4;\n    *(undefined *)(uVar3 - 0x10) = 0xd6;\n    *(int *)(uVar3 - 0xc) = (int)uVar3 - (int)uVar2;\n  }\n  return uVar3;\n}\n\n",
  "array_create_element": "\nundefined8 * array_create_element(undefined8 param_1,char *param_2)\n\n{\n  undefined8 *puVar1;\n  size_t sVar2;\n  char *__dest;\n  \n  puVar1 = (undefined8 *)sh_xmalloc(0x20,\"array.c\",0x208);\n  *puVar1 = param_1;\n  if (param_2 != (char *)0x0) {\n    sVar2 = strlen(param_2);\n    __dest = (char *)sh_xmalloc(sVar2 + 1,\"array.c\",0x20a);\n    param_2 = strcpy(__dest,param_2);\n  }\n  puVar1[1] = param_2;\n  puVar1[3] = 0;\n  puVar1[2] = 0;\n  return puVar1;\n}\n\n",
  "wmemchr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nwchar_t * wmemchr(wchar_t *__s,wchar_t __c,size_t __n)\n\n{\n  wchar_t *pwVar1;\n  \n  pwVar1 = (wchar_t *)(*(code *)PTR_wmemchr_00237e20)();\n  return pwVar1;\n}\n\n",
  "FUN_001da360": "\nundefined4 * FUN_001da360(uint param_1)\n\n{\n  uint uVar1;\n  ushort uVar2;\n  ushort *puVar3;\n  byte bVar4;\n  int iVar5;\n  int iVar6;\n  undefined4 *puVar7;\n  ushort **ppuVar8;\n  __int32_t **pp_Var9;\n  undefined4 *puVar10;\n  long lVar11;\n  long lVar12;\n  ulong uVar13;\n  bool bVar14;\n  \n  puVar7 = (undefined4 *)xmalloc(8);\n  if (param_1 == 0x1b) {\n    *(undefined *)((long)puVar7 + 2) = 0;\n    *(undefined2 *)puVar7 = 0x655c;\n    return puVar7;\n  }\n  if (param_1 == 0x7f) {\n    *puVar7 = 0x3f2d435c;\n    *(undefined *)(puVar7 + 1) = 0;\n    return puVar7;\n  }\n  if ((int)param_1 < 0x20) {\n    *(undefined *)((long)puVar7 + 2) = 0x2d;\n    puVar10 = (undefined4 *)((long)puVar7 + 3);\n    *(undefined2 *)puVar7 = 0x435c;\n    uVar13 = (ulong)(char)((byte)param_1 | 0x40);\n    ppuVar8 = __ctype_b_loc();\n    puVar3 = *ppuVar8;\n    uVar2 = puVar3[uVar13];\n    if ((uVar2 & 0x200) != 0) {\n      pp_Var9 = __ctype_toupper_loc();\n      param_1 = (*pp_Var9)[uVar13];\n      uVar13 = (ulong)(param_1 & 0xff);\n      if ((*(byte *)((long)puVar3 + uVar13 * 2 + 1) & 1) != 0) goto LAB_001da49a;\nLAB_001da4aa:\n      lVar11 = 4;\n      lVar12 = 3;\n      iVar6 = 4;\n      iVar5 = 3;\n      goto LAB_001da3a4;\n    }\n    if ((uVar2 & 0x100) != 0) {\nLAB_001da49a:\n      pp_Var9 = __ctype_tolower_loc();\n      param_1 = (*pp_Var9)[uVar13];\n      goto LAB_001da4aa;\n    }\n    param_1 = param_1 | 0x40;\n    lVar11 = 4;\n    lVar12 = 3;\n    bVar14 = false;\n    iVar6 = 4;\n    iVar5 = 3;\n  }\n  else {\n    lVar11 = 1;\n    lVar12 = 0;\n    iVar6 = 1;\n    iVar5 = 0;\n    puVar10 = puVar7;\nLAB_001da3a4:\n    uVar1 = param_1 - 0x80;\n    if (uVar1 < 0x20) {\n      *(undefined *)puVar10 = 0x5c;\n      param_1 = (uVar1 & 7) + 0x30;\n      *(char *)((long)puVar7 + lVar11) = '2';\n      *(char *)((long)puVar7 + (long)(iVar5 + 2)) = (char)((int)uVar1 >> 3) + '0';\n      lVar12 = (long)(iVar5 + 3);\n      iVar5 = iVar5 + 3;\n      goto LAB_001da3d5;\n    }\n    if (0x9f < (int)param_1) {\n      *(undefined *)puVar10 = 0x5c;\n      bVar4 = (byte)param_1;\n      param_1 = (param_1 & 7) + 0x30;\n      *(char *)((long)puVar7 + lVar11) = (bVar4 >> 6) + 0x30;\n      *(byte *)((long)puVar7 + (long)(iVar5 + 2)) = (bVar4 >> 3 & 7) + 0x30;\n      lVar12 = (long)(iVar5 + 3);\n      iVar5 = iVar5 + 3;\n      goto LAB_001da3d5;\n    }\n    bVar14 = param_1 == 0x22;\n  }\n  if ((param_1 == 0x5c) || (bVar14)) {\n    *(undefined *)puVar10 = 0x5c;\n    lVar12 = lVar11;\n    iVar5 = iVar6;\n  }\nLAB_001da3d5:\n  *(char *)((long)puVar7 + lVar12) = (char)param_1;\n  *(undefined *)((long)puVar7 + (long)(iVar5 + 1)) = 0;\n  return puVar7;\n}\n\n",
  "command_errstr": "\nchar * command_errstr(int param_1)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = \"unknown command error\";\n  if (param_1 < 4) {\n    pcVar1 = (&PTR_s_unknown_command_error_00234b20)[param_1];\n  }\n  return pcVar1;\n}\n\n",
  "rl_reset_line_state": "\nundefined8 rl_reset_line_state(void)\n\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR_DAT_00240520;\n  if (*(undefined **)PTR_DAT_00240520 != (undefined *)0x0) {\n    **(undefined **)PTR_DAT_00240520 = 0;\n  }\n  _rl_last_v_pos = 0;\n  _rl_last_c_pos = 0;\n  DAT_0024a8c0 = 0;\n  _rl_vis_botlin = 0;\n  if (*(undefined8 **)(puVar1 + 0x10) != (undefined8 *)0x0) {\n    **(undefined8 **)(puVar1 + 0x10) = 0;\n  }\n  DAT_0024a888 = 0;\n  DAT_0024a8b0 = 1;\n  rl_display_prompt = rl_prompt;\n  if (rl_prompt == (undefined *)0x0) {\n    rl_display_prompt = &DAT_00213d70;\n  }\n  return 0;\n}\n\n",
  "_rl_null_function": "\nundefined8 _rl_null_function(void)\n\n{\n  return 0;\n}\n\n",
  "setpwent": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid setpwent(void)\n\n{\n  (*(code *)PTR_setpwent_00237b28)();\n  return;\n}\n\n",
  "FUN_0015bdf0": "\nvoid FUN_0015bdf0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 uVar1;\n  char *__s;\n  size_t sVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  undefined auStack_48 [24];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = fmtumax(param_2,10,auStack_48,0x16,0);\n  __s = (char *)array_variable_name(param_1,0,0,0);\n  sVar2 = strlen(__s);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 0x19,\"expr.c\",0x17d);\n  __sprintf_chk(pcVar3,1,0xffffffffffffffff,\"%s[%s]\",__s,uVar1);\n  if (*pcVar3 != '\\0') {\n    FUN_0015bd90(pcVar3,param_3);\n  }\n  sh_xfree(__s,\"expr.c\",0x183);\n  sh_xfree(pcVar3,\"expr.c\",0x184);\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "remove_history": "\nlong remove_history(int param_1)\n\n{\n  long *__dest;\n  long lVar1;\n  \n  if ((-1 < param_1) && (param_1 < history_length)) {\n    lVar1 = DAT_0024b6e8;\n    if (DAT_0024b6e8 != 0) {\n      __dest = (long *)(DAT_0024b6e8 + (long)param_1 * 8);\n      lVar1 = *__dest;\n      memmove(__dest,__dest + 1,(long)(history_length - param_1) << 3);\n      history_length = history_length + -1;\n    }\n    return lVar1;\n  }\n  return 0;\n}\n\n",
  "sh_modcase": "\nundefined * sh_modcase(char *param_1,long param_2,uint param_3)\n\n{\n  mbstate_t mVar1;\n  byte bVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  size_t sVar7;\n  long lVar8;\n  undefined8 uVar9;\n  ushort **ppuVar10;\n  __int32_t **pp_Var11;\n  int iVar12;\n  uint uVar13;\n  byte *__s;\n  wchar_t wVar14;\n  uint uVar15;\n  byte *__dest;\n  int iVar16;\n  undefined *puVar17;\n  uint uVar18;\n  uint uVar19;\n  long in_FS_OFFSET;\n  undefined *local_98;\n  wchar_t local_70;\n  wchar_t local_6c;\n  mbstate_t local_68;\n  mbstate_t local_60;\n  char local_58 [24];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_1 == (char *)0x0) || (*param_1 == '\\0')) {\n    local_98 = (undefined *)sh_xmalloc(1,\"casemod.c\",0x79);\n    *local_98 = 0;\n  }\n  else {\n    local_68.__count = 0;\n    local_68.__value = (_union_27)0x0;\n    sVar7 = strlen(param_1);\n    iVar3 = (int)sVar7;\n    sVar7 = __ctype_get_mb_cur_max();\n    iVar4 = (int)sVar7;\n    local_98 = (undefined *)sh_xmalloc((long)(iVar3 * 2 + 1),\"casemod.c\",0x86);\n    uVar13 = param_3 & 0xffffefff;\n    param_3 = param_3 & 0x1000;\n    puVar17 = local_98;\n    if (0 < iVar3) {\n      iVar16 = 0;\n      iVar12 = 0;\n      uVar19 = 0;\n      do {\n        while( true ) {\n          sVar7 = __ctype_get_mb_cur_max();\n          __s = (byte *)(param_1 + iVar12);\n          wVar14 = (wchar_t)(char)*__s;\n          if (((sVar7 != 1) &&\n              ((*(uint *)(is_basic_table + (ulong)((uint)wVar14 >> 5 & 7) * 4) >> (*__s & 0x1f) & 1)\n               == 0)) && (iVar12 < iVar3 + -1)) {\n            local_60.__count = 0;\n            local_60.__value = (_union_27)0x0;\n            sVar7 = mbrtowc(&local_6c,(char *)__s,(long)(iVar3 - iVar12),&local_60);\n            wVar14 = local_6c;\n            if (0xfffffffffffffffc < sVar7 - 1) {\n              wVar14 = (wchar_t)(char)*__s;\n            }\n          }\n          local_70 = wVar14;\n          iVar5 = iswalnum(wVar14);\n          mVar1 = local_68;\n          if (iVar5 == 0) {\n            uVar19 = 0;\n          }\n          if (param_2 == 0) break;\n          iVar5 = iVar12 + 1;\n          local_68 = mVar1;\n          if (locale_mb_cur_max < 2) goto LAB_001cb767;\n          bVar2 = *__s;\n          if ((*(uint *)(is_basic_table + (ulong)(bVar2 >> 5) * 4) >> (bVar2 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale == 0) || ((char)bVar2 < '\\0')) {\n              sVar7 = mbrtowc((wchar_t *)0x0,(char *)__s,(long)(iVar3 - iVar12),&local_68);\n              if (sVar7 < 0xfffffffffffffffe) {\n                iVar5 = (int)sVar7;\n                if (sVar7 == 0) goto LAB_001cb763;\n                goto LAB_001cb9e5;\n              }\n              iVar5 = iVar12 + 1;\n              local_68 = mVar1;\n            }\n            else {\n              if (bVar2 != 0) goto LAB_001cb9e0;\nLAB_001cb763:\n              iVar5 = iVar12 + 1;\n            }\n          }\n          else {\nLAB_001cb9e0:\n            iVar5 = 1;\nLAB_001cb9e5:\n            iVar5 = iVar12 + iVar5;\n          }\nLAB_001cb767:\n          uVar9 = substring(param_1,iVar12,iVar5);\n          iVar6 = strmatch(param_2,uVar9,0x20);\n          sh_xfree(uVar9,\"casemod.c\",0x9b);\n          if (iVar6 != 1) break;\n          lVar8 = (long)iVar16;\n          iVar16 = iVar16 + (iVar5 - iVar12);\n          uVar18 = 1;\n          memcpy(local_98 + lVar8,__s,(long)(iVar5 - iVar12));\n          iVar12 = iVar5;\nLAB_001cb67b:\n          uVar19 = uVar18;\n          if (iVar3 <= iVar12) goto LAB_001cb9a9;\n        }\n        if (uVar13 == 4) {\n          if (param_3 == 0) {\njoined_r0x001cbb72:\n            if (0 < iVar12) goto joined_r0x001cba0a;\n          }\n          else if (uVar19 == 0) goto joined_r0x001cba0a;\nLAB_001cb7c7:\n          if (iVar4 == 1) {\n            uVar18 = 1;\nLAB_001cb7dd:\n            wVar14 = local_70;\n            ppuVar10 = __ctype_b_loc();\n            if (((*(byte *)((long)*ppuVar10 + (ulong)(uint)(wVar14 & 0xff) * 2 + 1) & 1) != 0) &&\n               ((uint)(wVar14 + L'\\x80') < 0x180)) {\n              pp_Var11 = __ctype_tolower_loc();\n              wVar14 = (*pp_Var11)[wVar14];\n            }\n            goto LAB_001cb620;\n          }\n          uVar15 = 1;\nLAB_001cbb26:\n          uVar18 = 1;\nLAB_001cb83b:\n          sVar7 = mbrtowc(&local_70,(char *)__s,(long)(iVar3 - iVar12),&local_68);\n          if (0xfffffffffffffffd < sVar7) {\n            wVar14 = (wchar_t)*__s;\n            local_70 = wVar14;\n            if (uVar15 == 0x10) {\n              iVar5 = iswupper(wVar14);\n              goto joined_r0x001cbab9;\n            }\nLAB_001cb5f0:\n            wVar14 = local_70;\n            if ((int)uVar15 < 0x11) {\n              if (uVar15 == 1) goto LAB_001cb7dd;\n              if (uVar15 == 2) goto LAB_001cba16;\n            }\n            else if (uVar15 == 0x20) goto LAB_001cb600;\n            goto LAB_001cb620;\n          }\n          if (sVar7 == 0) {\n            local_70 = L'\\0';\n          }\n          wVar14 = local_70;\n          if (uVar15 == 2) {\nLAB_001cb972:\n            iVar5 = iswlower(wVar14);\n            if (iVar5 != 0) {\n              wVar14 = towupper(wVar14);\n            }\nLAB_001cb8a8:\n            __dest = local_98 + iVar16;\n            if (L'' < wVar14) goto LAB_001cb920;\nLAB_001cb8b8:\n            bVar2 = (byte)wVar14;\n            if ((*(uint *)(is_basic_table + (ulong)(bVar2 >> 5) * 4) >> (bVar2 & 0x1f) & 1) == 0)\n            goto LAB_001cb920;\n            *__dest = bVar2;\n            iVar16 = iVar16 + 1;\n          }\n          else {\n            if ((int)uVar15 < 3) {\n              if ((uVar15 == 1) && (iVar5 = iswupper(local_70), iVar5 != 0)) {\n                wVar14 = towlower(wVar14);\n              }\n              goto LAB_001cb8a8;\n            }\n            if ((uVar15 - 0x10 & 0xffffffef) != 0) goto LAB_001cb8a8;\n            iVar5 = iswupper(local_70);\n            if (iVar5 == 0) goto LAB_001cb972;\n            wVar14 = towlower(wVar14);\n            __dest = local_98 + iVar16;\n            if (wVar14 < L'') goto LAB_001cb8b8;\nLAB_001cb920:\n            sVar7 = wcrtomb(local_58,wVar14,&local_68);\n            iVar5 = (int)sVar7;\n            if (0 < iVar5) {\n              local_58[iVar5] = '\\0';\n            }\n            iVar16 = iVar16 + iVar5;\n            strncpy((char *)__dest,local_58,(long)iVar5);\n          }\n        }\n        else {\n          if (uVar13 == 8) {\n            if (param_3 == 0) goto joined_r0x001cbb72;\n            if (uVar19 != 0) goto joined_r0x001cba0a;\n            goto LAB_001cb7c7;\n          }\n          if (uVar13 == 0x40) {\n            if (param_3 != 0) {\n              if (uVar19 == 0) goto joined_r0x001cba0a;\nLAB_001cbb05:\n              if (iVar4 == 1) goto LAB_001cbb10;\nLAB_001cbc10:\n              uVar15 = 0;\n              uVar18 = 1;\n              goto LAB_001cb83b;\n            }\n            if (iVar12 < 1) {\njoined_r0x001cba0a:\n              if (iVar4 != 1) {\n                uVar15 = 2;\n                uVar18 = 1;\n                goto LAB_001cb83b;\n              }\n              uVar18 = 1;\nLAB_001cba16:\n              ppuVar10 = __ctype_b_loc();\n              wVar14 = local_70;\n              if (((*(byte *)((long)*ppuVar10 + (ulong)(uint)(local_70 & 0xff) * 2 + 1) & 2) != 0)\n                 && ((uint)(local_70 + L'\\x80') < 0x180)) {\n                pp_Var11 = __ctype_toupper_loc();\n                wVar14 = (*pp_Var11)[wVar14];\n              }\n            }\n            else {\n              if (iVar4 != 1) goto LAB_001cbc10;\nLAB_001cbb10:\n              uVar18 = 1;\n              wVar14 = local_70;\n            }\n            goto LAB_001cb620;\n          }\n          if (uVar13 == 0x80) {\n            if (param_3 == 0) {\n              uVar18 = 1;\n              uVar15 = (uint)(iVar12 < 1);\n            }\n            else {\n              uVar18 = 1;\n              uVar15 = uVar19 ^ 1;\n            }\nLAB_001cb5e0:\n            if (iVar4 != 1) goto LAB_001cb83b;\n            goto LAB_001cb5f0;\n          }\n          uVar18 = uVar19;\n          uVar15 = uVar13;\n          if (uVar13 != 0x10) goto LAB_001cb5e0;\n          if (uVar19 != 0) goto LAB_001cbb05;\n          if (iVar4 != 1) goto LAB_001cbb26;\n          uVar18 = 1;\nLAB_001cb600:\n          wVar14 = local_70;\n          iVar5 = iswupper(local_70);\njoined_r0x001cbab9:\n          if (iVar5 == 0) {\n            iVar5 = iswlower(wVar14);\n            if (iVar5 != 0) {\n              wVar14 = towupper(wVar14);\n            }\n          }\n          else {\n            wVar14 = towlower(wVar14);\n          }\nLAB_001cb620:\n          lVar8 = (long)iVar16;\n          iVar16 = iVar16 + 1;\n          local_98[lVar8] = (char)wVar14;\n        }\n        mVar1 = local_68;\n        if (locale_mb_cur_max < 2) {\nLAB_001cb678:\n          iVar12 = iVar12 + 1;\n          goto LAB_001cb67b;\n        }\n        bVar2 = *__s;\n        if ((*(uint *)(is_basic_table + (ulong)(bVar2 >> 5) * 4) >> (bVar2 & 0x1f) & 1) == 0) {\n          if ((locale_utf8locale != 0) && (-1 < (char)bVar2)) {\n            if (bVar2 == 0) goto LAB_001cb678;\n            goto LAB_001cb998;\n          }\n          sVar7 = mbrtowc((wchar_t *)0x0,(char *)__s,(long)(iVar3 - iVar12),&local_68);\n          if (0xfffffffffffffffd < sVar7) {\n            iVar12 = iVar12 + 1;\n            local_68 = mVar1;\n            goto LAB_001cb67b;\n          }\n          if (sVar7 == 0) goto LAB_001cb678;\n          iVar12 = iVar12 + (int)sVar7;\n        }\n        else {\nLAB_001cb998:\n          iVar12 = iVar12 + 1;\n        }\n        uVar19 = uVar18;\n      } while (iVar12 < iVar3);\nLAB_001cb9a9:\n      puVar17 = local_98 + iVar16;\n    }\n    *puVar17 = 0;\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_98;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "sh_single_quote": "\nvoid sh_single_quote(char *param_1)\n\n{\n  size_t sVar1;\n  undefined2 *puVar2;\n  char cVar3;\n  \n  sVar1 = strlen(param_1);\n  puVar2 = (undefined2 *)sh_xmalloc(sVar1 * 4 + 3,\"shquote.c\",0x66);\n  if ((*param_1 == '\\'') && (param_1[1] == '\\0')) {\n    *(undefined *)(puVar2 + 1) = 0;\n    *puVar2 = 0x275c;\n    return;\n  }\n  *(undefined *)puVar2 = 0x27;\n  cVar3 = *param_1;\n  puVar2 = (undefined2 *)((long)puVar2 + 1);\n  while (cVar3 != '\\0') {\n    while (*(char *)puVar2 = cVar3, cVar3 != '\\'') {\n      cVar3 = param_1[1];\n      param_1 = param_1 + 1;\n      puVar2 = (undefined2 *)((long)puVar2 + 1);\n      if (cVar3 == '\\0') goto LAB_001c8918;\n    }\n    param_1 = param_1 + 1;\n    *(undefined *)((long)puVar2 + 3) = 0x27;\n    *(undefined2 *)((long)puVar2 + 1) = 0x275c;\n    puVar2 = puVar2 + 2;\n    cVar3 = *param_1;\n  }\nLAB_001c8918:\n  *puVar2 = 0x27;\n  return;\n}\n\n",
  "FUN_00151490": "\nundefined8 FUN_00151490(undefined8 param_1,char *param_2)\n\n{\n  size_t sVar1;\n  char *__dest;\n  \n  if ((rl_completer_word_break_characters != (undefined *)0x0) &&\n     (rl_completer_word_break_characters != rl_basic_word_break_characters)) {\n    sh_xfree(rl_completer_word_break_characters,\"variables.c\",0x669);\n  }\n  sVar1 = strlen(param_2);\n  __dest = (char *)sh_xmalloc(sVar1 + 1,\"variables.c\",0x66b);\n  rl_completer_word_break_characters = strcpy(__dest,param_2);\n  return param_1;\n}\n\n",
  "rl_on_new_line_with_prompt": "\nundefined  [16] rl_on_new_line_with_prompt(void)\n\n{\n  ulong uVar1;\n  undefined auVar2 [16];\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  size_t sVar6;\n  char *__s;\n  size_t sVar7;\n  int *piVar8;\n  int iVar9;\n  int *piVar10;\n  int *piVar11;\n  int iVar12;\n  char *pcVar13;\n  undefined *puVar14;\n  \n  sVar6 = strlen(rl_prompt);\n  FUN_001e0710((int)sVar6 + 1);\n  puVar14 = PTR_DAT_00240520;\n  pcVar13 = DAT_0024a8a0;\n  if (DAT_0024a8a0 == (char *)0x0) {\n    pcVar13 = rl_prompt;\n  }\n  strcpy(*(char **)PTR_DAT_00240520,pcVar13);\n  strcpy(*(char **)PTR_DAT_00240518,pcVar13);\n  pcVar13 = rl_prompt;\n  __s = strrchr(rl_prompt,10);\n  if (__s == (char *)0x0) {\n    __s = pcVar13;\n  }\n  sVar6 = strlen(__s);\n  iVar3 = (int)sVar6;\n  sVar7 = __ctype_get_mb_cur_max();\n  if ((sVar7 < 2) || (rl_byte_oriented != 0)) {\n    iVar12 = (uint)(_rl_term_autowrap == 0) + _rl_screenwidth;\n    _rl_last_v_pos = iVar3 / iVar12;\n    uVar1 = (long)iVar3 % (long)iVar12;\n    _rl_last_c_pos = iVar3;\n    if (iVar3 < 1) goto LAB_001e1b58;\nLAB_001e1ab8:\n    if (iVar3 % iVar12 == 0) {\n      _rl_output_some_chars(&DAT_001ff6d2,1);\n      puVar14 = PTR_DAT_00240520;\n    }\n  }\n  else {\n    if (0 < iVar3) {\n      sVar7 = __ctype_get_mb_cur_max();\n      iVar5 = iVar3;\n      if ((sVar7 != 1) && (rl_byte_oriented == 0)) {\n        iVar5 = FUN_001e08f0(__s,0,sVar6 & 0xffffffff);\n      }\n      iVar12 = (uint)(_rl_term_autowrap == 0) + _rl_screenwidth;\n      _rl_last_v_pos = iVar3 / iVar12;\n      _rl_last_c_pos = iVar5;\n      goto LAB_001e1ab8;\n    }\n    _rl_last_c_pos = 0;\n    iVar12 = (uint)(_rl_term_autowrap == 0) + _rl_screenwidth;\n    _rl_last_v_pos = iVar3 / iVar12;\n    uVar1 = (long)iVar3 % (long)iVar12;\nLAB_001e1b58:\n    piVar10 = (int *)(uVar1 & 0xffffffff);\n    DAT_0024a8c0 = 0;\n    piVar8 = *(int **)(puVar14 + 0x10);\n    if (iVar3 != 0) goto LAB_001e1b08;\n  }\n  DAT_0024a8c0 = 0;\n  piVar8 = *(int **)(puVar14 + 0x10);\n  piVar10 = piVar8;\n  iVar5 = 0;\n  iVar9 = 0;\n  do {\n    _rl_vis_botlin = iVar9;\n    iVar4 = iVar5;\n    piVar11 = piVar10;\n    *piVar11 = iVar4;\n    iVar9 = _rl_vis_botlin + 1;\n    piVar10 = piVar11 + 1;\n    iVar5 = iVar4 + iVar12;\n  } while (iVar4 + iVar12 <= iVar3);\n  *piVar11 = iVar4;\n  piVar8 = piVar8 + iVar9;\nLAB_001e1b08:\n  *piVar8 = iVar3;\n  DAT_0024a888 = 0;\n  rl_display_prompt = rl_prompt;\n  auVar2._8_8_ = 0;\n  auVar2._0_8_ = piVar10;\n  return auVar2 << 0x40;\n}\n\n",
  "FUN_001a2c10": "\nuint FUN_001a2c10(undefined *param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  long lVar3;\n  \n  uVar1 = array_needs_making;\n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_00213d70;\n  }\n  lVar3 = bind_variable(&DAT_001fc3d5,param_1,0);\n  uVar2 = 0;\n  if (lVar3 != 0) {\n    if ((*(uint *)(lVar3 + 0x28) & 2) != 0) {\n      return 1;\n    }\n    uVar2 = 0;\n    if (((uVar1 == 0) && (uVar2 = array_needs_making, array_needs_making != 0)) &&\n       (uVar2 = *(uint *)(lVar3 + 0x28) & 1, uVar2 != 0)) {\n      update_export_env_inplace(&DAT_0020f217,4,param_1);\n      uVar2 = 0;\n      array_needs_making = 0;\n    }\n  }\n  return uVar2;\n}\n\n",
  "nchars_avail": "\nundefined8 nchars_avail(uint param_1,uint param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  long lVar4;\n  ulong uVar5;\n  __fd_mask *p_Var6;\n  long in_FS_OFFSET;\n  int local_24c;\n  ulong local_248 [16];\n  ulong local_1c8 [16];\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((int)(param_2 | param_1) < 0) {\nLAB_001cbea1:\n    uVar3 = 0xffffffff;\n  }\n  else {\n    if (param_2 == 0) {\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        uVar3 = FUN_001cbc80();\n        return uVar3;\n      }\n      goto LAB_001cbf03;\n    }\n    local_24c = 0;\n    p_Var6 = (__fd_mask *)local_248;\n    for (lVar4 = 0x10; lVar4 != 0; lVar4 = lVar4 + -1) {\n      *p_Var6 = 0;\n      p_Var6 = p_Var6 + 1;\n    }\n    p_Var6 = (__fd_mask *)local_1c8;\n    for (lVar4 = 0x10; lVar4 != 0; lVar4 = lVar4 + -1) {\n      *p_Var6 = 0;\n      p_Var6 = p_Var6 + 1;\n    }\n    lVar4 = __fdelt_chk((long)(int)param_1);\n    uVar5 = 1L << ((byte)param_1 & 0x3f);\n    local_248[lVar4] = local_248[lVar4] | uVar5;\n    lVar4 = __fdelt_chk();\n    local_1c8[lVar4] = local_1c8[lVar4] | uVar5;\n    sigprocmask(0,(sigset_t *)0x0,&local_148);\n    sigaddset(&local_148,0x11);\n    sigemptyset(&local_c8);\n    do {\n      iVar1 = pselect(param_1 + 1,(fd_set *)local_248,(fd_set *)0x0,(fd_set *)local_1c8,\n                      (timespec *)0x0,&local_148);\n      if (iVar1 < 0) goto LAB_001cbea1;\n      piVar2 = __errno_location();\n      *piVar2 = 0;\n      iVar1 = ioctl(param_1,0x541b,&local_24c);\n      if ((iVar1 == -1) && (*piVar2 == 5)) goto LAB_001cbea1;\n    } while (local_24c < (int)param_2);\n    uVar3 = 0;\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\nLAB_001cbf03:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001a1120": "\nvoid FUN_001a1120(long param_1)\n\n{\n  if (*(long *)(param_1 + 0x18) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x18),\"pcomplib.c\",0x4e);\n  }\n  if (*(long *)(param_1 + 0x20) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x20),\"pcomplib.c\",0x4f);\n  }\n  if (*(long *)(param_1 + 0x28) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x28),\"pcomplib.c\",0x50);\n  }\n  if (*(long *)(param_1 + 0x30) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x30),\"pcomplib.c\",0x51);\n  }\n  if (*(long *)(param_1 + 0x38) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x38),\"pcomplib.c\",0x52);\n  }\n  if (*(long *)(param_1 + 0x40) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x40),\"pcomplib.c\",0x53);\n  }\n  if (*(long *)(param_1 + 0x48) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x48),\"pcomplib.c\",0x54);\n  }\n  if (*(long *)(param_1 + 0x50) != 0) {\n    sh_xfree(*(long *)(param_1 + 0x50),\"pcomplib.c\",0x55);\n  }\n  sh_xfree(param_1,\"pcomplib.c\",0x57);\n  return;\n}\n\n",
  "FUN_001d7d30": "\nvoid FUN_001d7d30(int param_1,long *param_2)\n\n{\n  long lVar1;\n  long *plVar2;\n  \n  if (param_1 != 2) {\n    return;\n  }\n  if (param_2 != (long *)0x0) {\n    if (*param_2 != 0) {\n      plVar2 = param_2 + 1;\n      do {\n        xfree();\n        lVar1 = *plVar2;\n        plVar2 = plVar2 + 1;\n      } while (lVar1 != 0);\n    }\n    xfree(param_2);\n  }\n  DAT_0024a728 = 1;\n  return;\n}\n\n",
  "strnlen": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strnlen(char *__string,size_t __maxlen)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strnlen_00237a78)();\n  return sVar1;\n}\n\n",
  "strlist_copy": "\nlong * strlist_copy(long *param_1)\n\n{\n  long lVar1;\n  int iVar2;\n  long *plVar3;\n  size_t sVar4;\n  char *__dest;\n  char *__s;\n  int iVar5;\n  long lVar6;\n  long lVar7;\n  \n  if (param_1 == (long *)0x0) {\n    plVar3 = (long *)0x0;\n  }\n  else {\n    plVar3 = (long *)strlist_create(*(undefined4 *)(param_1 + 1));\n    lVar6 = *param_1;\n    iVar5 = *(int *)(param_1 + 1);\n    if ((lVar6 == 0) || (lVar7 = 0, iVar5 < 1)) {\n      lVar6 = *plVar3;\n    }\n    else {\n      while( true ) {\n        __s = *(char **)(lVar6 + lVar7 * 8);\n        lVar1 = lVar7 * 8;\n        if (__s != (char *)0x0) {\n          sVar4 = strlen(__s);\n          __dest = (char *)sh_xmalloc(sVar4 + 1,\"stringlist.c\",0x86);\n          __s = strcpy(__dest,__s);\n          iVar5 = *(int *)(param_1 + 1);\n        }\n        lVar6 = *plVar3;\n        lVar7 = lVar7 + 1;\n        *(char **)(lVar6 + lVar1) = __s;\n        if (iVar5 <= (int)lVar7) break;\n        lVar6 = *param_1;\n      }\n    }\n    iVar2 = *(int *)((long)param_1 + 0xc);\n    *(int *)(plVar3 + 1) = iVar5;\n    *(int *)((long)plVar3 + 0xc) = iVar2;\n    if (lVar6 != 0) {\n      *(undefined8 *)(lVar6 + (long)iVar2 * 8) = 0;\n    }\n  }\n  return plVar3;\n}\n\n",
  "FUN_0015c4c0": "\nulong FUN_0015c4c0(void)\n\n{\n  byte bVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  byte bVar5;\n  char cVar6;\n  ulong uVar7;\n  long lVar8;\n  ulong uVar9;\n  long lVar10;\n  long lVar11;\n  bool bVar12;\n  \n  uVar7 = FUN_0015c330();\n  uVar2 = DAT_00242448;\n  while ((uVar2 - 0x2b & 0xfffffffd) == 0) {\n    DAT_00242448 = uVar2;\n    FUN_0015d330();\n    lVar8 = FUN_0015c330();\n    DAT_00242444 = 6;\n    lVar10 = -lVar8;\n    if (uVar2 == 0x2b) {\n      lVar10 = lVar8;\n    }\n    uVar7 = uVar7 + lVar10;\n    uVar2 = DAT_00242448;\n  }\n  while (DAT_00242448 = uVar2, uVar2 - 9 < 2) {\n    FUN_0015d330();\n    bVar5 = FUN_0015c330();\n    while (uVar3 = DAT_00242448, (DAT_00242448 - 0x2b & 0xfffffffd) == 0) {\n      FUN_0015d330();\n      cVar6 = FUN_0015c330();\n      DAT_00242444 = 6;\n      bVar1 = bVar5 + cVar6;\n      bVar5 = bVar5 - cVar6;\n      if (uVar3 == 0x2b) {\n        bVar5 = bVar1;\n      }\n    }\n    DAT_00242444 = 6;\n    uVar9 = uVar7 << (bVar5 & 0x3f);\n    bVar12 = uVar2 == 9;\n    uVar7 = (long)uVar7 >> (bVar5 & 0x3f);\n    uVar2 = DAT_00242448;\n    if (bVar12) {\n      uVar7 = uVar9;\n    }\n  }\n  if (((uVar2 & 0xfffffffd) == 0x3c) || (uVar2 - 3 < 2)) {\n    do {\n      uVar2 = DAT_00242448;\n      FUN_0015d330();\n      lVar10 = FUN_0015c330();\n      while (uVar3 = DAT_00242448, (DAT_00242448 - 0x2b & 0xfffffffd) == 0) {\n        FUN_0015d330();\n        lVar11 = FUN_0015c330();\n        DAT_00242444 = 6;\n        lVar8 = lVar10 + lVar11;\n        lVar10 = lVar10 - lVar11;\n        if (uVar3 == 0x2b) {\n          lVar10 = lVar8;\n        }\n      }\n      while (DAT_00242448 = uVar3, uVar3 - 9 < 2) {\n        FUN_0015d330();\n        bVar5 = FUN_0015c330();\n        while (uVar4 = DAT_00242448, (DAT_00242448 - 0x2b & 0xfffffffd) == 0) {\n          FUN_0015d330();\n          cVar6 = FUN_0015c330();\n          DAT_00242444 = 6;\n          bVar1 = bVar5 + cVar6;\n          bVar5 = bVar5 - cVar6;\n          if (uVar4 == 0x2b) {\n            bVar5 = bVar1;\n          }\n        }\n        DAT_00242444 = 6;\n        lVar8 = lVar10 << (bVar5 & 0x3f);\n        bVar12 = uVar3 == 9;\n        lVar10 = lVar10 >> (bVar5 & 0x3f);\n        uVar3 = DAT_00242448;\n        if (bVar12) {\n          lVar10 = lVar8;\n        }\n      }\n      if (uVar2 == 3) {\n        uVar7 = (ulong)((long)uVar7 <= lVar10);\n      }\n      else if (uVar2 == 4) {\n        uVar7 = (ulong)(lVar10 <= (long)uVar7);\n      }\n      else if (uVar2 == 0x3c) {\n        uVar7 = (ulong)((long)uVar7 < lVar10);\n      }\n      else {\n        uVar7 = (ulong)(lVar10 < (long)uVar7);\n      }\n      DAT_00242444 = 6;\n    } while ((uVar3 - 3 < 2) || ((uVar3 & 0xfffffffd) == 0x3c));\n  }\n  return uVar7;\n}\n\n",
  "show_var_attributes": "\nundefined8 show_var_attributes(char **param_1,undefined8 param_2,int param_3)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  undefined8 uVar4;\n  char *pcVar5;\n  char *__s;\n  char **ppcVar6;\n  long in_FS_OFFSET;\n  char local_48 [24];\n  long local_30;\n  \n  iVar3 = (int)param_2;\n  pcVar5 = local_48;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  ppcVar6 = param_1;\n  iVar2 = var_attribute_string(param_1,param_2,local_48);\n  if (((*(byte *)(ppcVar6 + 5) & 8) == 0) || (param_3 != 0)) {\n    if (iVar3 != 0) {\nLAB_001b3091:\n      if (posixly_correct != 0) goto LAB_001b309f;\n    }\nLAB_001b2f8d:\n    pcVar5 = \"-\";\n    if (iVar2 != 0) {\n      pcVar5 = local_48;\n    }\nLAB_001b2f9b:\n    __printf_chk(1,\"declare -%s \",pcVar5);\n  }\n  else {\n    if (iVar3 == 0) {\n      __s = (char *)named_function_string(*ppcVar6,ppcVar6[1],3);\n      puts(__s);\n      if (iVar2 != 1) {\n        param_3 = 1;\n        goto LAB_001b2f8d;\n      }\n      if (local_48[0] == 'f') goto LAB_001b303d;\n      param_3 = 1;\n      goto LAB_001b2f9b;\n    }\n    if (posixly_correct == 0) {\n      param_3 = 1;\n      pcVar5 = (char *)named_function_string(*ppcVar6,ppcVar6[1],3);\n      puts(pcVar5);\n      goto LAB_001b3091;\n    }\nLAB_001b309f:\n    if (iVar2 == 0) {\n      __printf_chk(1,&DAT_002111d0,this_command_name);\n    }\n    else {\n      __printf_chk(1,\"%s -%s \",this_command_name,local_48);\n    }\n  }\n  uVar1 = *(uint *)(param_1 + 5);\n  if (((uVar1 & 0x1000) == 0) || ((uVar1 & 0x44) == 0)) {\n    if ((uVar1 & 4) != 0) {\n      print_array_assignment(param_1,0);\n      goto LAB_001b303d;\n    }\n    if ((uVar1 & 0x40) != 0) {\n      print_assoc_assignment(param_1,0);\n      goto LAB_001b303d;\n    }\n    if (param_3 == 0) {\n      if ((uVar1 & 8) == 0) {\n        if (((uVar1 & 0x1000) == 0) && (param_1[1] != (char *)0x0)) {\n          iVar3 = ansic_shouldquote();\n          if (iVar3 == 0) {\n            uVar4 = sh_double_quote();\n          }\n          else {\n            uVar4 = ansic_quote(param_1[1],0,0);\n          }\n          __printf_chk(1,\"%s=%s\\n\",*param_1,uVar4);\n          sh_xfree(uVar4,\"./setattr.def\",0x212);\n          goto LAB_001b303d;\n        }\n      }\n      else if ((iVar3 == 0) || (posixly_correct == 0)) {\n        pcVar5 = (char *)named_function_string(*param_1,param_1[1],3);\n        puts(pcVar5);\n        goto LAB_001b303d;\n      }\n    }\n  }\n  puts(*param_1);\nLAB_001b303d:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "rl_discard_keymap": "\nvoid rl_discard_keymap(long param_1)\n\n{\n  if (param_1 != 0) {\n    FUN_001d42a0();\n    return;\n  }\n  return;\n}\n\n",
  "sv_terminal": "\nvoid sv_terminal(void)\n\n{\n  long lVar1;\n  \n  if ((interactive_shell != 0) && (no_line_editing == 0)) {\n    lVar1 = find_variable(\"TERM\");\n    if (lVar1 != 0) {\n      lVar1 = get_variable_value(lVar1);\n    }\n    rl_reset_terminal(lVar1);\n    return;\n  }\n  return;\n}\n\n",
  "coproc_reap": "\nvoid coproc_reap(void)\n\n{\n  if (((byte)DAT_0023843c & 2) == 0) {\n    return;\n  }\n  FUN_0014a430(&sh_coproc);\n  return;\n}\n\n",
  "which_set_flags": "\nvoid which_set_flags(void)\n\n{\n  int **ppiVar1;\n  char cVar2;\n  long lVar3;\n  char cVar4;\n  int **ppiVar5;\n  int iVar6;\n  int *piVar7;\n  long lVar8;\n  char cVar9;\n  \n  lVar3 = sh_xmalloc((long)read_from_stdin + 0x17 + (long)want_pending_command,\"flags.c\",0x12e);\n  ppiVar5 = (int **)(shell_flags + 0x18);\n  iVar6 = 0;\n  piVar7 = &mark_modified_vars;\n  cVar2 = 'b';\n  cVar9 = 'a';\n  while( true ) {\n    cVar4 = cVar2;\n    if (*piVar7 != 0) {\n      lVar8 = (long)iVar6;\n      iVar6 = iVar6 + 1;\n      *(char *)(lVar3 + lVar8) = cVar9;\n    }\n    if (cVar4 == '\\0') break;\n    ppiVar1 = ppiVar5 + 1;\n    piVar7 = *ppiVar5;\n    ppiVar5 = ppiVar5 + 2;\n    cVar2 = *(char *)ppiVar1;\n    cVar9 = cVar4;\n  }\n  if (want_pending_command != 0) {\n    lVar8 = (long)iVar6;\n    iVar6 = iVar6 + 1;\n    *(undefined *)(lVar3 + lVar8) = 99;\n  }\n  if (read_from_stdin != 0) {\n    lVar8 = (long)iVar6;\n    iVar6 = iVar6 + 1;\n    *(undefined *)(lVar3 + lVar8) = 0x73;\n  }\n  *(undefined *)(lVar3 + iVar6) = 0;\n  return;\n}\n\n",
  "assoc_subrange": "\nundefined8 *\nassoc_subrange(long param_1,long param_2,long param_3,int param_4,undefined4 param_5,\n              undefined4 param_6)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  long lVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  undefined8 *puVar6;\n  \n  if ((*(int *)(param_1 + 0xc) == 0) ||\n     (puVar2 = (undefined8 *)FUN_0018d590(param_1,0), puVar2 == (undefined8 *)0x0)) {\n    return (undefined8 *)0x0;\n  }\n  lVar3 = 1;\n  puVar4 = puVar2;\n  do {\n    if (param_2 <= lVar3) {\n      lVar3 = 0;\n      puVar1 = puVar4;\n      puVar5 = puVar4;\n      goto LAB_0018dbeb;\n    }\n    puVar4 = (undefined8 *)*puVar4;\n    lVar3 = lVar3 + 1;\n  } while (puVar4 != (undefined8 *)0x0);\n  goto LAB_0018dbb2;\n  while( true ) {\n    puVar1 = (undefined8 *)*puVar6;\n    lVar3 = lVar3 + 1;\n    puVar5 = puVar6;\n    if (puVar1 == (undefined8 *)0x0) break;\nLAB_0018dbeb:\n    puVar6 = puVar1;\n    if (param_3 <= lVar3) {\n      *puVar5 = 0;\n      puVar4 = (undefined8 *)\n               string_list_pos_params((-(param_4 == 0) & 0x16U) + 0x2a,puVar4,param_5,param_6);\n      if (puVar6 != puVar5) goto LAB_0018dc76;\n      goto LAB_0018dbb2;\n    }\n  }\n  puVar6 = puVar1;\n  if (param_4 == 0) {\n    puVar4 = (undefined8 *)string_list_pos_params(0x40,puVar4,param_5,param_6);\n  }\n  else {\n    puVar4 = (undefined8 *)string_list_pos_params(0x2a,puVar4,param_5,param_6);\n  }\nLAB_0018dc76:\n  *puVar5 = puVar6;\nLAB_0018dbb2:\n  dispose_words(puVar2);\n  return puVar4;\n}\n\n",
  "FUN_001944d0": "\nlong FUN_001944d0(undefined1 *param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  if (DAT_00248820 == 0) {\n    DAT_00248820 = rl_make_bare_keymap();\n    *(undefined *)(DAT_00248820 + 0x180) = 1;\n    uVar2 = rl_make_bare_keymap();\n    lVar1 = DAT_00248820;\n    *(undefined8 *)(DAT_00248820 + 0x188) = uVar2;\n    *(undefined *)(lVar1 + 0x1b0) = 1;\n    uVar2 = rl_make_bare_keymap();\n    *(undefined8 *)(DAT_00248820 + 0x1b8) = uVar2;\n    DAT_00248818 = rl_make_bare_keymap();\n    DAT_00248810 = rl_make_bare_keymap();\n  }\n  if (param_1 == emacs_standard_keymap) {\n    return DAT_00248820;\n  }\n  if (param_1 == emacs_meta_keymap) {\n    return *(long *)(DAT_00248820 + 0x1b8);\n  }\n  if (param_1 != emacs_ctlx_keymap) {\n    if (param_1 != &vi_insertion_keymap) {\n      lVar1 = 0;\n      if (param_1 == vi_movement_keymap) {\n        lVar1 = DAT_00248810;\n      }\n      return lVar1;\n    }\n    return DAT_00248818;\n  }\n  return *(long *)(DAT_00248820 + 0x188);\n}\n\n",
  "set_bash_input_fd": "\nundefined8 set_bash_input_fd(undefined4 param_1)\n\n{\n  if (bash_input != 4) {\n    if (interactive_shell == 0) {\n      default_buffered_input = param_1;\n    }\n    return 0;\n  }\n  DAT_00240a70._0_4_ = param_1;\n  return 0;\n}\n\n",
  "udequote_pathname": "\nvoid udequote_pathname(char *param_1)\n\n{\n  char cVar1;\n  char *pcVar2;\n  int iVar3;\n  int iVar4;\n  \n  iVar4 = 0;\n  iVar3 = 0;\n  pcVar2 = param_1;\n  while( true ) {\n    if (param_1 == (char *)0x0) {\n      return;\n    }\n    cVar1 = param_1[iVar3];\n    if (cVar1 == '\\0') break;\n    iVar4 = iVar4 + 1;\n    if (cVar1 == '\\\\') {\n      cVar1 = param_1[iVar3 + 1];\n      *pcVar2 = cVar1;\n      iVar3 = iVar3 + 2;\n      if (cVar1 == '\\0') break;\n    }\n    else {\n      *pcVar2 = cVar1;\n      iVar3 = iVar3 + 1;\n    }\n    pcVar2 = pcVar2 + 1;\n  }\n  param_1[iVar4] = '\\0';\n  return;\n}\n\n",
  "_rl_vi_set_last": "\nvoid _rl_vi_set_last(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  _rl_vi_last_command = param_1;\n  DAT_0023b36c = param_2;\n  DAT_0023b368 = param_3;\n  return;\n}\n\n",
  "maybe_make_export_env": "\nvoid maybe_make_export_env(void)\n\n{\n  if (array_needs_making != 0) {\n    FUN_00156bc0();\n    return;\n  }\n  return;\n}\n\n",
  "optimize_subshell_command": "\nvoid optimize_subshell_command(int *param_1)\n\n{\n  uint *puVar1;\n  long lVar2;\n  int iVar3;\n  \n  iVar3 = *param_1;\n  if ((running_trap == 0) && (iVar3 == 4)) {\n    iVar3 = signal_is_trapped(0);\n    if ((iVar3 == 0) &&\n       ((((iVar3 = signal_is_trapped(0x42), iVar3 == 0 && (iVar3 = any_signals_trapped(), iVar3 < 0)\n          ) && (*(long *)(param_1 + 4) == 0)) &&\n        ((puVar1 = *(uint **)(param_1 + 6), *(long *)(puVar1 + 4) == 0 &&\n         ((param_1[1] & 0x84U) == 0)))))) {\n      param_1[1] = param_1[1] | 0x40;\n      *puVar1 = *puVar1 | 0x40;\n      return;\n    }\n    iVar3 = *param_1;\n  }\n  if (iVar3 == 6) {\n    iVar3 = *(int *)(*(long *)(param_1 + 6) + 0x18);\n    if (((iVar3 - 0x120U < 2) || (iVar3 == 0x3b)) &&\n       ((**(int **)(*(long *)(param_1 + 6) + 0x10) == 4 &&\n        (iVar3 = parser_expanding_alias(), iVar3 == 0)))) {\n      lVar2 = *(long *)(*(long *)(param_1 + 6) + 0x10);\n      puVar1 = (uint *)(lVar2 + 4);\n      *puVar1 = *puVar1 | 0x8000;\n      puVar1 = *(uint **)(lVar2 + 0x18);\n      *puVar1 = *puVar1 | 0x8000;\n      return;\n    }\n  }\n  return;\n}\n\n",
  "FUN_00147eb0": "\nvoid FUN_00147eb0(long **param_1)\n\n{\n  uint uVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  char *pcVar8;\n  long lVar9;\n  char **ppcVar10;\n  char *__s;\n  long **pplVar11;\n  \n  if (param_1 == (long **)0x0) {\n    return;\n  }\n  while (ppcVar10 = (char **)param_1[1], (*(uint *)(ppcVar10 + 1) & 4) != 0) {\n    param_1 = (long **)*param_1;\n    if (param_1 == (long **)0x0) {\n      return;\n    }\n  }\n  if (posixly_correct != 0) {\n    do {\n      pcVar8 = *ppcVar10;\n      if (((pcVar8 == (char *)0x0) || (*pcVar8 != 'c')) ||\n         (iVar5 = strcmp(pcVar8,\"command\"), iVar5 != 0)) break;\n      param_1 = (long **)*param_1;\n      if (param_1 == (long **)0x0) {\n        return;\n      }\n      ppcVar10 = (char **)param_1[1];\n    } while (ppcVar10 != (char **)0x0);\n  }\n  bVar3 = false;\n  bVar2 = false;\n  lVar9 = 0;\n  bVar4 = false;\n  pplVar11 = param_1;\n  do {\n    uVar6 = *(uint *)(ppcVar10 + 1);\n    if ((uVar6 & 4) == 0) {\n      if ((**ppcVar10 == '-') && (pcVar8 = strpbrk(*ppcVar10 + 1,\"Aag\"), pcVar8 != (char *)0x0)) {\n        if (lVar9 == 0) {\n          lVar9 = builtin_address_internal(*param_1[1],0);\n          if (lVar9 == 0) {\n            return;\n          }\n          if ((*(byte *)(lVar9 + 0x10) & 0x10) == 0) {\n            return;\n          }\n          *(uint *)(param_1[1] + 1) = *(uint *)(param_1[1] + 1) | 0x10000;\n        }\n        else if ((*(byte *)((long)param_1[1] + 10) & 1) == 0) goto LAB_00147fa4;\n        __s = (char *)(*pplVar11[1] + 1);\n        pcVar8 = strchr(__s,0x41);\n        if (pcVar8 == (char *)0x0) {\n          pcVar8 = strchr(__s,0x61);\n          if (pcVar8 != (char *)0x0) {\n            bVar4 = true;\n          }\n        }\n        else {\n          bVar3 = true;\n        }\n        pcVar8 = strchr(__s,0x67);\n        if (pcVar8 != (char *)0x0) {\n          bVar2 = true;\n        }\n      }\n    }\n    else {\n      if (lVar9 == 0) {\n        lVar9 = builtin_address_internal(*param_1[1],0);\n        if (lVar9 == 0) {\n          return;\n        }\n        uVar1 = *(uint *)(lVar9 + 0x10);\n        if ((uVar1 & 0x10) == 0) {\n          return;\n        }\n        ppcVar10 = (char **)pplVar11[1];\n        *(uint *)(param_1[1] + 1) = *(uint *)(param_1[1] + 1) | 0x10000;\n        uVar6 = *(uint *)(ppcVar10 + 1);\n      }\n      else {\n        uVar1 = *(uint *)(lVar9 + 0x10);\n      }\n      uVar7 = uVar6 | 0x200b0;\n      if (bVar3) {\n        uVar7 = uVar6 | 0x4200b0;\n      }\n      *(uint *)(ppcVar10 + 1) = uVar7;\n      if (bVar4) {\n        *(uint *)(ppcVar10 + 1) = *(uint *)(ppcVar10 + 1) | 0x800000;\n      }\n      if (bVar2) {\n        *(uint *)(ppcVar10 + 1) = *(uint *)(ppcVar10 + 1) | 0x2000000;\n      }\n      if ((uVar1 & 0x50) == 0x10) {\n        *(uint *)(ppcVar10 + 1) = *(uint *)(ppcVar10 + 1) | 0x12000000;\n      }\n      else if (((uVar1 & 0x50) == 0x50) && (variable_context != 0)) {\n        *(uint *)(ppcVar10 + 1) = *(uint *)(ppcVar10 + 1) | 0x20000000;\n      }\n    }\nLAB_00147fa4:\n    pplVar11 = (long **)*pplVar11;\n    if (pplVar11 == (long **)0x0) {\n      return;\n    }\n    ppcVar10 = (char **)pplVar11[1];\n  } while( true );\n}\n\n",
  "rl_vi_subst": "\nvoid rl_vi_subst(undefined4 param_1,int param_2)\n\n{\n  if (_rl_vi_redoing == 0) {\n    rl_stuff_char((param_2 != 0x53) * '\\t' + 'c');\n  }\n  rl_vi_change_to(param_1,99);\n  return;\n}\n\n",
  "get_history_event": "\nundefined8 get_history_event(long param_1,int *param_2,int param_3)\n\n{\n  void *pvVar1;\n  char cVar2;\n  int iVar3;\n  size_t sVar4;\n  char *pcVar5;\n  char *pcVar6;\n  undefined8 *puVar7;\n  long *__ptr;\n  int iVar8;\n  byte *__src;\n  byte *pbVar9;\n  code *pcVar10;\n  long lVar11;\n  long *plVar12;\n  undefined8 uVar13;\n  byte bVar14;\n  ulong uVar15;\n  int iVar16;\n  long in_FS_OFFSET;\n  bool bVar17;\n  int local_6c;\n  int local_4c;\n  undefined8 local_48;\n  long local_40;\n  \n  iVar3 = *param_2;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*(byte *)(param_1 + iVar3) == history_expansion_char) {\n    iVar16 = iVar3 + 1;\n    pbVar9 = (byte *)(param_1 + iVar16);\n    bVar14 = *pbVar9;\n    uVar15 = (ulong)bVar14;\n    if (history_expansion_char == bVar14) {\n      iVar16 = history_length + -1 + history_base;\n      *param_2 = iVar3 + 2;\n      puVar7 = (undefined8 *)history_get(iVar16);\njoined_r0x001f309a:\n      if (puVar7 != (undefined8 *)0x0) {\n        uVar13 = *puVar7;\n        goto LAB_001f2d99;\n      }\n    }\n    else {\n      iVar8 = 1;\n      if (bVar14 == 0x2d) {\n        if ((byte)(*(char *)(param_1 + 1 + (long)iVar16) - 0x30U) < 10) {\n          iVar16 = iVar3 + 2;\n          iVar8 = -1;\n          pbVar9 = (byte *)(iVar16 + param_1);\n          bVar14 = *pbVar9;\n          uVar15 = (ulong)bVar14;\n          goto joined_r0x001f2e42;\n        }\n        bVar17 = false;\n        __src = pbVar9;\n        local_6c = iVar16;\nLAB_001f2be7:\n        pbVar9 = __src;\n        iVar16 = local_6c;\n        do {\n          sVar4 = __ctype_get_mb_cur_max();\n          if ((sVar4 < 2) || (rl_byte_oriented != 0)) {\nLAB_001f2ca4:\n            if (!bVar17) {\n              bVar14 = (byte)uVar15;\n              if ((0x3a < bVar14) || ((0x400000100000200U >> (uVar15 & 0x3f) & 1) == 0)) {\n                if (local_6c < iVar16) {\n                  if (bVar14 != 0x2d) {\nLAB_001f2c27:\n                    pcVar5 = strchr(\"^$*%-\",(int)(char)bVar14);\n                    if (pcVar5 == (char *)0x0) goto LAB_001f2c40;\n                  }\n                }\n                else {\n                  if (bVar14 != 0x2d) goto LAB_001f2c27;\nLAB_001f2c40:\n                  if ((((history_search_delimiter_chars == (char *)0x0) ||\n                       (pcVar5 = strchr(history_search_delimiter_chars,(int)(char)bVar14),\n                       pcVar5 == (char *)0x0)) && ((char)*pbVar9 != param_3)) && (*pbVar9 != 10))\n                  goto LAB_001f2c74;\n                }\n                local_6c = iVar16 - local_6c;\n                pcVar5 = (char *)xmalloc((long)(local_6c + 1));\n                if (local_6c != 0) goto LAB_001f2f01;\n                *pcVar5 = '\\0';\n                goto LAB_001f2f24;\n              }\n              break;\n            }\n            if ((*pbVar9 == 0x3f) || (*pbVar9 == 10)) {\n              local_6c = iVar16 - local_6c;\n              pcVar5 = (char *)xmalloc((long)(local_6c + 1));\n              if (local_6c != 0) goto LAB_001f2f01;\n              *pcVar5 = '\\0';\n              goto LAB_001f2cd9;\n            }\n          }\n          else {\n            local_48 = 0;\n            _rl_adjust_point(param_1,iVar16,&local_48);\n            iVar3 = _rl_get_char_len(pbVar9,&local_48);\n            if (iVar3 < 2) goto LAB_001f2ca4;\n            iVar16 = iVar3 + -1 + iVar16;\n          }\nLAB_001f2c74:\n          iVar16 = iVar16 + 1;\n          pbVar9 = (byte *)(iVar16 + param_1);\n          uVar15 = (ulong)*pbVar9;\n        } while (*pbVar9 != 0);\n        local_6c = iVar16 - local_6c;\n        pcVar6 = (char *)xmalloc((long)(local_6c + 1));\n        pcVar5 = pcVar6;\n        if (local_6c != 0) {\nLAB_001f2f01:\n          strncpy(pcVar5,(char *)__src,(long)local_6c);\n          pcVar6 = pcVar5 + local_6c;\n        }\n      }\n      else {\njoined_r0x001f2e42:\n        if ((byte)(bVar14 - 0x30) < 10) {\n          iVar3 = 0;\n          lVar11 = (long)(iVar16 + 1);\n          do {\n            cVar2 = (char)uVar15;\n            pbVar9 = (byte *)(param_1 + lVar11);\n            uVar15 = (ulong)*pbVar9;\n            iVar16 = (int)lVar11;\n            lVar11 = lVar11 + 1;\n            iVar3 = (int)(char)(cVar2 + -0x30) + iVar3 * 10;\n          } while ((byte)(*pbVar9 - 0x30) < 10);\n          *param_2 = iVar16;\n          if (iVar8 == -1) {\n            iVar3 = (history_base + history_length) - iVar3;\n          }\n          puVar7 = (undefined8 *)history_get(iVar3);\n          goto joined_r0x001f309a;\n        }\n        bVar17 = (char)uVar15 == '?';\n        if (bVar17) {\n          iVar16 = iVar16 + 1;\n          pbVar9 = (byte *)(iVar16 + param_1);\n          uVar15 = (ulong)*pbVar9;\n        }\n        __src = pbVar9;\n        local_6c = iVar16;\n        if ((char)uVar15 != '\\0') goto LAB_001f2be7;\n        pcVar6 = (char *)xmalloc(1);\n        pcVar5 = pcVar6;\n      }\n      *pcVar6 = '\\0';\n      if (bVar17) {\nLAB_001f2cd9:\n        *param_2 = iVar16 + (uint)(*pbVar9 == 0x3f);\n        if (*pcVar5 == '\\0') {\n          if (DAT_0024b710 == (char *)0x0) {\n            history_offset = history_length;\n            xfree(pcVar5);\n            uVar13 = 0;\n            goto LAB_001f2d99;\n          }\n          bVar17 = true;\n          xfree(pcVar5);\n          pcVar5 = DAT_0024b710;\n          sVar4 = strlen(DAT_0024b710);\n          pcVar6 = (char *)xmalloc(sVar4 + 1);\n          pcVar5 = strcpy(pcVar6,pcVar5);\n          pcVar10 = history_search;\n        }\n        else {\n          pcVar10 = history_search;\n          bVar17 = true;\n        }\n      }\n      else {\nLAB_001f2f24:\n        pcVar10 = history_search_prefix;\n        bVar17 = false;\n        *param_2 = iVar16;\n      }\n      while( true ) {\n        iVar3 = (*pcVar10)(pcVar5,0xffffffff);\n        if (iVar3 < 0) break;\n        if ((iVar3 == 0) || (bVar17)) {\n          puVar7 = (undefined8 *)current_history();\n          history_offset = history_length;\n          if (puVar7 == (undefined8 *)0x0) {\n            xfree(pcVar5);\n            uVar13 = 0;\n          }\n          else {\n            if (bVar17) {\n              if (DAT_0024b710 != (char *)0x0) {\n                free(DAT_0024b710);\n              }\n              DAT_0024b710 = pcVar5;\n              if (DAT_0024b708 != (void *)0x0) {\n                free(DAT_0024b708);\n              }\n              __ptr = (long *)FUN_001f2720(*puVar7,iVar3,&local_4c);\n              if (local_4c == -1) {\n                if (__ptr == (long *)0x0) goto LAB_001f3121;\n                lVar11 = *__ptr;\n                plVar12 = __ptr;\n                while (lVar11 != 0) {\n                  plVar12 = plVar12 + 1;\n                  xfree();\n                  lVar11 = *plVar12;\n                }\n                free(__ptr);\n                DAT_0024b708 = (void *)0x0;\n              }\n              else if (__ptr == (long *)0x0) {\nLAB_001f3121:\n                DAT_0024b708 = (void *)0x0;\n              }\n              else {\n                pvVar1 = (void *)__ptr[local_4c];\n                if (0 < local_4c) {\n                  lVar11 = 0;\n                  do {\n                    plVar12 = __ptr + lVar11;\n                    lVar11 = lVar11 + 1;\n                    xfree(*plVar12);\n                  } while ((int)lVar11 < local_4c);\n                }\n                lVar11 = __ptr[local_4c + 1];\n                plVar12 = __ptr + (long)(local_4c + 1) + 1;\n                while (lVar11 != 0) {\n                  xfree();\n                  lVar11 = *plVar12;\n                  plVar12 = plVar12 + 1;\n                }\n                xfree(__ptr);\n                DAT_0024b708 = pvVar1;\n              }\n            }\n            else {\n              xfree(pcVar5);\n            }\n            uVar13 = *puVar7;\n          }\n          goto LAB_001f2d99;\n        }\n        if (history_offset == 0) break;\n        history_offset = history_offset + -1;\n      }\n      history_offset = history_length;\n      xfree(pcVar5);\n    }\n  }\n  uVar13 = 0;\nLAB_001f2d99:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar13;\n}\n\n",
  "rl_do_lowercase_version": "\nundefined8 rl_do_lowercase_version(void)\n\n{\n  return 99999;\n}\n\n",
  "sh_notfound": "\nvoid sh_notfound(undefined8 param_1)\n\n{\n  builtin_error(\"%s: not found\",param_1);\n  return;\n}\n\n",
  "rl_kill_full_line": "\nundefined8 rl_kill_full_line(void)\n\n{\n  rl_begin_undo_group();\n  rl_point = 0;\n  rl_kill_text(0,rl_end);\n  rl_mark = 0;\n  rl_end_undo_group();\n  return 0;\n}\n\n",
  "programming_error": "\nvoid programming_error_noreturn_\n               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n               undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n               undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  char *pcVar1;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined8 local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  give_terminal_to(shell_pgrp,0);\n  local_d0 = &stack0x00000008;\n  local_d8 = 8;\n  local_c8 = local_b8;\n  local_d4 = 0x30;\n  __vfprintf_chk(stderr,1,param_9,&local_d8);\n  fputc(10,stderr);\n  if (remember_on_history != 0) {\n    pcVar1 = (char *)last_history_line();\n    if (pcVar1 == (char *)0x0) {\n      pcVar1 = \"(null)\";\n    }\n    __fprintf_chk(stderr,1,\"last command: %s\\n\",pcVar1);\n  }\n  fwrite(\"Aborting...\",1,0xb,stderr);\n  fflush(stderr);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "endgrent": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid endgrent(void)\n\n{\n  (*(code *)PTR_endgrent_00237800)();\n  return;\n}\n\n",
  "puts": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint puts(char *__s)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_puts_002378b8)();\n  return iVar1;\n}\n\n",
  "_rl_pure_alphabetic": "\nushort _rl_pure_alphabetic(uint param_1)\n\n{\n  ushort **ppuVar1;\n  \n  ppuVar1 = __ctype_b_loc();\n  return (*ppuVar1)[param_1 & 0xff] >> 10 & 1;\n}\n\n",
  "munmap": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint munmap(void *__addr,size_t __len)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_munmap_00237cb8)();\n  return iVar1;\n}\n\n",
  "rename": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint rename(char *__old,char *__new)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_rename_00237d98)();\n  return iVar1;\n}\n\n",
  "terminate_stopped_jobs": "\nvoid terminate_stopped_jobs(void)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  \n  if (DAT_0023877c < 1) {\n    return;\n  }\n  lVar3 = 0;\n  do {\n    while( true ) {\n      lVar1 = lVar3 * 8;\n      lVar2 = *(long *)(jobs + lVar3 * 8);\n      if ((lVar2 != 0) && (*(int *)(lVar2 + 0x14) == 2)) break;\n      lVar3 = lVar3 + 1;\n      if (DAT_0023877c <= (int)lVar3) {\n        return;\n      }\n    }\n    lVar3 = lVar3 + 1;\n    killpg(*(__pid_t *)(lVar2 + 0x10),0xf);\n    killpg(*(__pid_t *)(*(long *)(jobs + lVar1) + 0x10),0x12);\n  } while ((int)lVar3 < DAT_0023877c);\n  return;\n}\n\n",
  "FUN_001e0710": "\nvoid FUN_001e0710(ulong param_1)\n\n{\n  int *piVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  undefined8 uVar4;\n  int iVar5;\n  \n  if ((*(long *)PTR_DAT_00240518 == 0) &&\n     (iVar5 = (int)param_1, param_1 = param_1 & 0xffffffff, iVar5 < (int)DAT_0024a8ac)) {\n    param_1 = (ulong)DAT_0024a8ac;\n  }\n  FUN_001e05c0(param_1);\n  puVar3 = PTR_DAT_00240520;\n  puVar2 = PTR_DAT_00240518;\n  if (*(long *)(PTR_DAT_00240520 + 0x10) == 0) {\n    *(undefined4 *)(PTR_DAT_00240520 + 0x18) = 0x100;\n    *(undefined4 *)(puVar2 + 0x18) = 0x100;\n    *(undefined4 *)(puVar3 + 0x1c) = 0x100;\n    uVar4 = xmalloc(0x400);\n    *(undefined8 *)(puVar3 + 0x20) = uVar4;\n    puVar2 = PTR_DAT_00240518;\n    piVar1 = (int *)(PTR_DAT_00240518 + 0x18);\n    *(int *)(PTR_DAT_00240518 + 0x1c) = *piVar1;\n    uVar4 = xmalloc((long)*piVar1 << 2);\n    *(undefined8 *)(puVar2 + 0x20) = uVar4;\n    puVar2 = PTR_DAT_00240518;\n    uVar4 = xmalloc((long)*(int *)(PTR_DAT_00240518 + 0x18) << 2);\n    *(undefined8 *)(puVar2 + 0x10) = uVar4;\n    puVar2 = PTR_DAT_00240520;\n    uVar4 = xmalloc((long)*(int *)(PTR_DAT_00240520 + 0x18) << 2);\n    DAT_0024a8dc = 1;\n    *(undefined8 *)(puVar2 + 0x10) = uVar4;\n    **(undefined4 **)(PTR_DAT_00240520 + 0x10) = 0;\n    **(undefined4 **)(PTR_DAT_00240518 + 0x10) = 0;\n    return;\n  }\n  DAT_0024a8dc = 1;\n  return;\n}\n\n",
  "_rl_next_macro_key": "\nint _rl_next_macro_key(void)\n\n{\n  char cVar1;\n  \n  if (rl_executing_macro == 0) {\n    return 0;\n  }\n  do {\n    cVar1 = *(char *)(rl_executing_macro + DAT_0024b1a0);\n    if (cVar1 != '\\0') {\n      DAT_0024b1a0 = DAT_0024b1a0 + 1;\n      if ((((rl_readline_state & 0x80000) != 0) && ((rl_readline_state & 0x48) != 0)) &&\n         (*(char *)(rl_executing_macro + DAT_0024b1a0) == '\\0')) {\n        _rl_pop_executing_macro();\n      }\n      return (int)cVar1;\n    }\n    _rl_pop_executing_macro();\n  } while (rl_executing_macro != 0);\n  return 0;\n}\n\n",
  "strrchr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strrchr_00237a30)();\n  return pcVar1;\n}\n\n",
  "rl_expand_prompt": "\nundefined4 rl_expand_prompt(char *param_1)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  char *pcVar4;\n  size_t sVar5;\n  \n  if (DAT_0024a8a0 != (char *)0x0) {\n    free(DAT_0024a8a0);\n  }\n  if (DAT_0024a898 != (void *)0x0) {\n    free(DAT_0024a898);\n  }\n  DAT_0024a898 = (void *)0x0;\n  DAT_0024a8a0 = (char *)0x0;\n  DAT_0024a894 = 0;\n  DAT_0024a878 = 0;\n  DAT_0024a880 = 0;\n  DAT_0024a870 = 0;\n  DAT_0024a88c = 0;\n  uVar3 = DAT_0024a894;\n  uVar2 = 0;\n  if ((param_1 != (char *)0x0) && (*param_1 != '\\0')) {\n    pcVar4 = strrchr(param_1,10);\n    if (pcVar4 == (char *)0x0) {\n      DAT_0024a8a0 = (char *)FUN_001e0bd0(param_1,0,&DAT_0024a88c,&DAT_0024a880,&DAT_0024a878,\n                                          &DAT_0024a870);\n      DAT_0024a898 = (void *)0x0;\n      uVar3 = 0;\n      if (DAT_0024a8a0 != (char *)0x0) {\n        sVar5 = strlen(DAT_0024a8a0);\n        uVar3 = (undefined4)sVar5;\n      }\n      DAT_0024a894 = uVar3;\n      return DAT_0024a88c;\n    }\n    cVar1 = pcVar4[1];\n    pcVar4[1] = '\\0';\n    DAT_0024a898 = (void *)FUN_001e0bd0(param_1,1,&DAT_0024a890,0,0,0);\n    pcVar4[1] = cVar1;\n    DAT_0024a8a0 = (char *)FUN_001e0bd0(pcVar4 + 1,1,&DAT_0024a88c,&DAT_0024a880,&DAT_0024a878,\n                                        &DAT_0024a870);\n    uVar3 = 0;\n    uVar2 = DAT_0024a890;\n    if (DAT_0024a8a0 != (char *)0x0) {\n      sVar5 = strlen(DAT_0024a8a0);\n      uVar3 = (int)sVar5;\n      uVar2 = DAT_0024a890;\n    }\n  }\n  DAT_0024a894 = uVar3;\n  return uVar2;\n}\n\n",
  "FUN_0015eb60": "\nchar * FUN_0015eb60(void)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  pcVar1 = (char *)get_string_value(&DAT_001fc3d5);\n  if ((pcVar1 == (char *)0x0) &&\n     ((the_current_working_directory == (char *)0x0 ||\n      (pcVar1 = the_current_working_directory, no_symbolic_links == 0)))) {\n    pcVar1 = getcwd(&DAT_002465c0,0x1000);\n    pcVar2 = \"<unknown>\";\n    if (pcVar1 != (char *)0x0) {\n      pcVar2 = &DAT_002465c0;\n    }\n    return pcVar2;\n  }\n  return pcVar1;\n}\n\n",
  "kill_builtin": "\nulong kill_builtin(long **param_1)\n\n{\n  long lVar1;\n  byte bVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  ushort **ppuVar6;\n  ulong uVar7;\n  int *piVar8;\n  char *pcVar9;\n  byte *pbVar10;\n  char *pcVar11;\n  char cVar12;\n  char cVar13;\n  long in_FS_OFFSET;\n  int local_160;\n  ulong local_150;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (long **)0x0) {\nLAB_001ada6b:\n    builtin_usage();\n    uVar7 = 0x102;\n  }\n  else {\n    pcVar9 = (char *)*param_1[1];\n    cVar13 = *pcVar9;\n    if ((cVar13 != '-') || (iVar3 = strcmp(pcVar9,\"--help\"), iVar3 != 0)) {\n      local_160 = 0;\n      pbVar10 = (byte *)0x1fe9a3;\n      cVar12 = (posixly_correct == 0) + '\\x02';\n      iVar3 = 0xf;\n      iVar4 = 0;\nLAB_001ad888:\n      if (cVar13 != '-') goto LAB_001ad892;\n      bVar2 = pcVar9[1];\n      if ((bVar2 & 0xdf) == 0x4c) {\n        if (pcVar9[2] == '\\0') {\n          local_160 = local_160 + 1;\n          param_1 = (long **)*param_1;\n          goto LAB_001ad970;\n        }\nLAB_001ad998:\n        if (bVar2 == 0x2d) {\n          if (pcVar9[2] != '\\0') goto LAB_001ad9ab;\n          param_1 = (long **)*param_1;\n          goto LAB_001ad892;\n        }\n        if ((bVar2 == 0x3f) && (pcVar9[2] == '\\0')) goto LAB_001ada6b;\n      }\n      else {\n        if ((bVar2 != 0x73) && (bVar2 != 0x6e)) goto LAB_001ad998;\n        if (pcVar9[2] == '\\0') {\n          param_1 = (long **)*param_1;\n          if (param_1 != (long **)0x0) {\n            pbVar10 = (byte *)*param_1[1];\n            bVar2 = *pbVar10;\nLAB_001ad9f0:\n            if ((bVar2 != 0x30) || (iVar3 = 0, pbVar10[1] != 0)) {\n              iVar3 = decode_signal(pbVar10,cVar12);\n            }\n            param_1 = (long **)*param_1;\n            iVar4 = iVar4 + 1;\n            goto LAB_001ad970;\n          }\n          sh_needarg(pcVar9);\n          uVar7 = 1;\n          goto LAB_001ad91b;\n        }\n        if (bVar2 == 0x73) {\n          ppuVar6 = __ctype_b_loc();\n          bVar2 = pcVar9[2];\n          if ((*(byte *)((long)*ppuVar6 + (ulong)bVar2 * 2 + 1) & 4) != 0) {\n            pbVar10 = (byte *)(pcVar9 + 2);\n            goto LAB_001ad9f0;\n          }\n        }\n        else {\n          if (bVar2 != 0x6e) goto LAB_001ad998;\n          ppuVar6 = __ctype_b_loc();\n          bVar2 = pcVar9[2];\n          if ((*(byte *)((long)*ppuVar6 + (ulong)bVar2 * 2 + 1) & 8) != 0) {\n            pbVar10 = (byte *)(pcVar9 + 2);\n            goto LAB_001ad9f0;\n          }\n        }\n      }\nLAB_001ad9ab:\n      if (iVar4 != 0) goto LAB_001ad892;\n      pbVar10 = (byte *)(pcVar9 + 1);\n      iVar3 = decode_signal(pbVar10,cVar12);\n      param_1 = (long **)*param_1;\n      iVar4 = 1;\nLAB_001ad970:\n      if (param_1 == (long **)0x0) goto LAB_001ad892;\n      pcVar9 = (char *)*param_1[1];\n      cVar13 = *pcVar9;\n      goto LAB_001ad888;\n    }\n    builtin_help();\n    uVar7 = 0x102;\n  }\n  goto LAB_001ad91b;\nLAB_001ad892:\n  if (local_160 != 0) {\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar7 = display_signal_list(param_1,0);\n      return uVar7;\n    }\n    goto LAB_001add17;\n  }\n  if (iVar3 == -1) {\n    sh_invalidsig(pbVar10);\n    uVar7 = 1;\n  }\n  else {\n    if (param_1 == (long **)0x0) goto LAB_001ada6b;\n    do {\n      while( true ) {\n        pcVar9 = (char *)*param_1[1];\n        if (*pcVar9 == '-') break;\n        pcVar11 = pcVar9;\n        if (*pcVar9 != '\\0') goto LAB_001ada83;\nLAB_001ad8c8:\n        sh_badpid();\nLAB_001ad8cd:\n        param_1 = (long **)*param_1;\n        if (param_1 == (long **)0x0) goto LAB_001ad910;\n      }\n      pcVar11 = pcVar9 + 1;\n      if (pcVar9[1] != '\\0') {\nLAB_001ada83:\n        iVar4 = legal_number(pcVar9,&local_150);\n        uVar7 = local_150;\n        if (iVar4 != 0) {\n          if (local_150 != (long)(int)local_150) goto LAB_001adaa3;\n          iVar4 = kill_pid(local_150 & 0xffffffff,iVar3,(int)local_150 < -1);\n          if (iVar4 < 0) {\n            piVar8 = __errno_location();\n            if (*piVar8 == 0x16) {\nLAB_001adc56:\n              sh_invalidsig(pbVar10);\n            }\n            else {\n              pcVar9 = strerror(*piVar8);\n              if (pcVar9 == (char *)0x0) {\n                pcVar9 = \"Unknown error\";\n              }\n              builtin_error(\"(%ld) - %s\",uVar7,pcVar9);\n            }\n          }\n          else {\nLAB_001adb66:\n            local_160 = local_160 + 1;\n          }\n          goto LAB_001ad8cd;\n        }\nLAB_001adaa3:\n        pcVar9 = (char *)*param_1[1];\n        if ((*pcVar9 != '\\0') && (*pcVar9 != '%')) goto LAB_001ad8f3;\n        if (*pcVar11 == '\\0') goto LAB_001ad8c8;\n        sigemptyset(&local_148);\n        sigaddset(&local_148,0x11);\n        sigemptyset(&local_c8);\n        sigprocmask(0,&local_148,&local_c8);\n        iVar4 = get_job_spec(param_1);\n        if (iVar4 < 0) {\n          if (iVar4 != -2) goto LAB_001adbd0;\n        }\n        else {\n          if ((iVar4 < DAT_0023877c) && (lVar1 = *(long *)(jobs + (long)iVar4 * 8), lVar1 != 0)) {\n            if ((*(byte *)(lVar1 + 0x18) & 4) == 0) {\n              iVar4 = *(int *)(*(long *)(lVar1 + 8) + 8);\n            }\n            else {\n              iVar4 = *(int *)(lVar1 + 0x10);\n            }\n            sigprocmask(2,&local_c8,(sigset_t *)0x0);\n            iVar5 = kill_pid(iVar4,iVar3,1);\n            if (-1 < iVar5) goto LAB_001adb66;\n            piVar8 = __errno_location();\n            if (*piVar8 == 0x16) goto LAB_001adc56;\n            pcVar9 = strerror(*piVar8);\n            if (pcVar9 == (char *)0x0) {\n              pcVar9 = \"Unknown error\";\n            }\n            builtin_error(\"(%ld) - %s\",(long)iVar4,pcVar9);\n            goto LAB_001ad8cd;\n          }\nLAB_001adbd0:\n          sh_badjob(*param_1[1]);\n        }\n        sigprocmask(2,&local_c8,(sigset_t *)0x0);\n        goto LAB_001ad8cd;\n      }\nLAB_001ad8f3:\n      builtin_error(\"%s: arguments must be process or job IDs\",pcVar9);\n      param_1 = (long **)*param_1;\n    } while (param_1 != (long **)0x0);\nLAB_001ad910:\n    uVar7 = (ulong)(local_160 == 0);\n  }\nLAB_001ad91b:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar7;\n  }\nLAB_001add17:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "start_job": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 start_job(int param_1,int param_2)\n\n{\n  uint *puVar1;\n  int iVar2;\n  char *__s2;\n  int iVar3;\n  undefined4 uVar4;\n  char *pcVar5;\n  long **pplVar6;\n  long *plVar7;\n  undefined8 uVar8;\n  long lVar9;\n  undefined *puVar10;\n  long *plVar11;\n  char **ppcVar12;\n  long lVar13;\n  long **pplVar14;\n  long in_FS_OFFSET;\n  sigset_t local_148;\n  sigset_t local_c8;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_148);\n  sigaddset(&local_148,0x11);\n  sigemptyset(&local_c8);\n  sigprocmask(0,&local_148,&local_c8);\n  if ((((byte)subshell_environment & 4) == 0) || (pipeline_pgrp != shell_pgrp)) {\n    lVar13 = (long)param_1;\n    iVar2 = *(int *)(*(long *)(jobs + lVar13 * 8) + 0x14);\n    if (iVar2 != 4) {\n      if ((iVar2 == 1) && (param_2 == 0)) {\n        internal_error(\"%s: job %d already in background\",this_command_name,param_1 + 1);\n      }\n      else {\n        pcVar5 = (char *)FUN_0015eb60();\n        lVar9 = *(long *)(jobs + lVar13 * 8);\n        puVar1 = (uint *)(lVar9 + 0x18);\n        *puVar1 = *puVar1 & 0xfffffffd;\n        if (param_2 == 0) {\n          pplVar14 = *(long ***)(lVar9 + 8);\n          puVar10 = &DAT_001fdb1c;\n          if (((posixly_correct == 0) && (puVar10 = &DAT_001fcf7d, DAT_00238790 != param_1)) &&\n             (puVar10 = &DAT_0020fcdf, DAT_00238794 != param_1)) {\n            puVar10 = &DAT_001fdb1c;\n          }\n          __printf_chk(1,\"[%d]%s\",param_1 + 1,puVar10);\n          pplVar6 = *(long ***)(*(long *)(jobs + lVar13 * 8) + 8);\n        }\n        else {\n          FUN_0015e860(param_1);\n          lVar9 = *(long *)(jobs + lVar13 * 8);\n          pplVar6 = *(long ***)(lVar9 + 8);\n          puVar1 = (uint *)(lVar9 + 0x18);\n          *puVar1 = *puVar1 | 1;\n          pplVar14 = pplVar6;\n        }\n        do {\n          plVar11 = pplVar14[3];\n          puVar10 = &DAT_00213d70;\n          if ((long **)*pplVar14 != pplVar6) {\n            puVar10 = &DAT_001fc763;\n          }\n          if (plVar11 == (long *)0x0) {\n            plVar11 = (long *)&DAT_00213d70;\n          }\n          __printf_chk(1,&DAT_001fc632,plVar11,puVar10);\n          pplVar14 = (long **)*pplVar14;\n          ppcVar12 = *(char ***)(jobs + lVar13 * 8);\n          pplVar6 = (long **)ppcVar12[1];\n        } while (pplVar6 != pplVar14);\n        if (param_2 == 0) {\n          __printf_chk(1,&DAT_001fdb60);\n          ppcVar12 = *(char ***)(jobs + lVar13 * 8);\n        }\n        __s2 = *ppcVar12;\n        iVar3 = strcmp(pcVar5,__s2);\n        if (iVar3 != 0) {\n          uVar8 = polite_directory_format(__s2);\n          __printf_chk(1,\"\\t(wd: %s)\",uVar8);\n        }\n        putchar(10);\n        if (iVar2 == 1) {\n          if (param_2 != 0) {\n            get_tty_state();\n            DAT_00246590 = DAT_00247610;\n            _DAT_00246560 = _DAT_002475e0;\n            uRam0000000000246564 = DAT_002475e0_4;\n            uRam0000000000246568 = (undefined4)uRam00000000002475e8;\n            uRam000000000024656c = uRam00000000002475e8._4_4_;\n            DAT_00246598 = DAT_00247618;\n            _DAT_00246570 = _DAT_002475f0;\n            uRam0000000000246574 = DAT_002475f0_4;\n            uRam0000000000246578 = (undefined4)uRam00000000002475f8;\n            uRam000000000024657c = uRam00000000002475f8._4_4_;\n            lVar9 = *(long *)(jobs + lVar13 * 8);\n            _DAT_00246580 = _DAT_00247600;\n            uRam0000000000246584 = DAT_00247600_4;\n            uRam0000000000246588 = (undefined4)uRam0000000000247608;\n            uRam000000000024658c = uRam0000000000247608._4_4_;\n            if ((*(byte *)(lVar9 + 0x18) & 4) != 0) goto LAB_00164cc0;\n            goto LAB_00164ba6;\n          }\n          puVar1 = (uint *)(*(long *)(jobs + lVar13 * 8) + 0x18);\n          *puVar1 = *puVar1 & 0xfffffffe;\n        }\n        else {\n          lVar9 = *(long *)(jobs + lVar13 * 8);\n          plVar11 = *(long **)(lVar9 + 8);\n          plVar7 = plVar11;\n          do {\n            if (*(char *)((long)plVar7 + 0xc) == '\\x7f') {\n              *(undefined4 *)(plVar7 + 2) = 1;\n            }\n            plVar7 = (long *)*plVar7;\n          } while (plVar11 != plVar7);\n          *(undefined4 *)(lVar9 + 0x14) = 1;\n          if (param_2 != 0) {\n            get_tty_state();\n            DAT_00246590 = DAT_00247610;\n            _DAT_00246560 = _DAT_002475e0;\n            uRam0000000000246564 = DAT_002475e0_4;\n            uRam0000000000246568 = (undefined4)uRam00000000002475e8;\n            uRam000000000024656c = uRam00000000002475e8._4_4_;\n            DAT_00246598 = DAT_00247618;\n            _DAT_00246570 = _DAT_002475f0;\n            uRam0000000000246574 = DAT_002475f0_4;\n            uRam0000000000246578 = (undefined4)uRam00000000002475f8;\n            uRam000000000024657c = uRam00000000002475f8._4_4_;\n            lVar9 = *(long *)(jobs + lVar13 * 8);\n            _DAT_00246580 = _DAT_00247600;\n            uRam0000000000246584 = DAT_00247600_4;\n            uRam0000000000246588 = (undefined4)uRam0000000000247608;\n            uRam000000000024658c = uRam0000000000247608._4_4_;\n            if ((*(byte *)(lVar9 + 0x18) & 4) != 0) {\nLAB_00164cc0:\n              DAT_00246590 = DAT_00247610;\n              DAT_00246598 = DAT_00247618;\n              give_terminal_to(*(undefined4 *)(lVar9 + 0x10),0);\n              lVar9 = *(long *)(jobs + lVar13 * 8);\n              if (iVar2 == 1) goto LAB_00164ba6;\n            }\n            *(uint *)(lVar9 + 0x18) = *(uint *)(lVar9 + 0x18) | 2;\n            killpg(*(__pid_t *)(lVar9 + 0x10),0x12);\n            lVar9 = *(long *)(jobs + lVar13 * 8);\nLAB_00164ba6:\n            plVar11 = *(long **)(lVar9 + 8);\n            do {\n              plVar7 = plVar11;\n              if (plVar7 == (long *)0x0) {\n                do {\n                  invalidInstructionException();\n                } while( true );\n              }\n              plVar11 = (long *)*plVar7;\n            } while (*(long **)(lVar9 + 8) != (long *)*plVar7);\n            uVar4 = *(undefined4 *)(plVar7 + 1);\n            sigprocmask(2,&local_c8,(sigset_t *)0x0);\n            uVar4 = wait_for(uVar4,0);\n            _DAT_002475e0 = CONCAT44(uRam0000000000246564,_DAT_00246560);\n            uRam00000000002475e8 = CONCAT44(uRam000000000024656c,uRam0000000000246568);\n            _DAT_002475f0 = CONCAT44(uRam0000000000246574,_DAT_00246570);\n            uRam00000000002475f8 = CONCAT44(uRam000000000024657c,uRam0000000000246578);\n            _DAT_00247600 = CONCAT44(uRam0000000000246584,_DAT_00246580);\n            uRam0000000000247608 = CONCAT44(uRam000000000024658c,uRam0000000000246588);\n            DAT_00247610 = DAT_00246590;\n            DAT_00247618 = DAT_00246598;\n            set_tty_state();\n            goto LAB_001648e9;\n          }\n          *(uint *)(lVar9 + 0x18) = *(uint *)(lVar9 + 0x18) & 0xfffffffe | 2;\n          killpg(*(__pid_t *)(lVar9 + 0x10),0x12);\n        }\n        FUN_0015e940();\n      }\n      uVar4 = 0;\n      sigprocmask(2,&local_c8,(sigset_t *)0x0);\n      goto LAB_001648e9;\n    }\n    pcVar5 = \"%s: job has terminated\";\n  }\n  else {\n    pcVar5 = \"%s: no current jobs\";\n  }\n  uVar4 = 0xffffffff;\n  internal_error(pcVar5,this_command_name);\n  sigprocmask(2,&local_c8,(sigset_t *)0x0);\nLAB_001648e9:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar4;\n}\n\n",
  "freeaddrinfo": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid freeaddrinfo(addrinfo *__ai)\n\n{\n  (*(code *)PTR_freeaddrinfo_00237ec8)();\n  return;\n}\n\n",
  "FUN_001e9520": "\nundefined8 FUN_001e9520(int param_1)\n\n{\n  undefined8 uVar1;\n  \n  if (rl_mark != rl_point) {\n    uVar1 = rl_copy_text();\n    if (param_1 != 0) {\n      rl_delete_text(rl_point,rl_mark);\n    }\n    FUN_001e9370(uVar1,rl_point < rl_mark);\n  }\n  _rl_fix_point(1);\n  _rl_last_command_was_kill = _rl_last_command_was_kill + 1;\n  return 0;\n}\n\n",
  "sv_globignore": "\nvoid sv_globignore(void)\n\n{\n  if (privileged_mode != 0) {\n    return;\n  }\n  setup_glob_ignore();\n  return;\n}\n\n",
  "readline_internal_teardown": "\nchar * readline_internal_teardown(int param_1)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  size_t sVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  \n  if (_rl_caught_signal != 0) {\n    _rl_signal_handler(_rl_caught_signal);\n  }\n  if (param_1 != 0) {\n    rl_readline_state = rl_readline_state | 0x8000000;\n  }\n  lVar2 = current_history();\n  pcVar6 = DAT_0024a320;\n  if (lVar2 == 0) {\nLAB_001cdf18:\n    if (_rl_revert_all_at_newline != 0) goto LAB_001cdf7a;\n  }\n  else {\n    if (rl_undo_list != 0) {\n      sVar3 = strlen(DAT_0024a320);\n      pcVar4 = (char *)xmalloc(sVar3 + 1);\n      pcVar4 = strcpy(pcVar4,pcVar6);\n      rl_revert_line(1,0);\n      pcVar6 = DAT_0024a320;\n      uVar1 = where_history();\n      uVar5 = replace_history_entry(uVar1,pcVar6,0);\n      _rl_free_history_entry(uVar5);\n      strcpy(DAT_0024a320,pcVar4);\n      xfree(pcVar4);\n      goto LAB_001cdf18;\n    }\n    if (_rl_revert_all_at_newline == 0) goto LAB_001cdf31;\nLAB_001cdf7a:\n    _rl_revert_all_lines();\n  }\n  if (rl_undo_list != 0) {\n    rl_free_undo_list();\n  }\nLAB_001cdf31:\n  _rl_disable_meta_key();\n  _rl_set_insert_mode(1,0);\n  pcVar6 = DAT_0024a320;\n  if (param_1 == 0) {\n    sVar3 = strlen(DAT_0024a320);\n    pcVar4 = (char *)xmalloc(sVar3 + 1);\n    pcVar6 = strcpy(pcVar4,pcVar6);\n    return pcVar6;\n  }\n  return (char *)0x0;\n}\n\n",
  "trap_to_sighandler": "\ncode * trap_to_sighandler(int param_1)\n\n{\n  code *pcVar1;\n  \n  pcVar1 = (code *)0x1;\n  if ((((&DAT_00247e40)[param_1] & 0x42) == 0) &&\n     (pcVar1 = trap_handler, ((&DAT_00247e40)[param_1] & 1) == 0)) {\n    pcVar1 = (code *)0x0;\n  }\n  return pcVar1;\n}\n\n",
  "zreadintr": "\nvoid zreadintr(int param_1,void *param_2,size_t param_3)\n\n{\n  check_signals();\n  read(param_1,param_2,param_3);\n  return;\n}\n\n",
  "stop_making_children": "\nvoid stop_making_children(void)\n\n{\n  already_making_children = 0;\n  return;\n}\n\n",
  "posix_readline_initialize": "\nvoid posix_readline_initialize(int param_1)\n\n{\n  undefined *puVar1;\n  \n  if (param_1 != 0) {\n    rl_variable_bind(\"comment-begin\",&DAT_001ff2e3);\n    PTR_rl_complete_00238d88 =\n         (undefined *)rl_function_of_keyseq(&DAT_00238d48,&vi_insertion_keymap,0);\n    rl_bind_key_in_map(9,rl_insert,&vi_insertion_keymap);\n    return;\n  }\n  puVar1 = (undefined *)rl_function_of_keyseq(&DAT_00238d48,&vi_insertion_keymap,0);\n  if (puVar1 != PTR_rl_insert_00237f40) {\n    return;\n  }\n  rl_bind_key_in_map(9,PTR_rl_complete_00238d88,&vi_insertion_keymap);\n  return;\n}\n\n",
  "history_builtin": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nulong history_builtin(undefined8 param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  long *plVar7;\n  tm *__tp;\n  long lVar8;\n  undefined8 *puVar9;\n  uint uVar10;\n  long *plVar11;\n  undefined *puVar12;\n  ulong uVar13;\n  char *unaff_R13;\n  long in_FS_OFFSET;\n  uint local_6c;\n  ulong local_50;\n  char *local_48;\n  long local_40;\n  \n  uVar10 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  reset_internal_getopt();\nLAB_001ac99a:\n  iVar1 = internal_getopt(param_1,\"acd:npsrw\");\n  if (iVar1 != -1) {\n    do {\n      if (iVar1 == -99) {\n        builtin_help();\n        uVar13 = 0x102;\n        goto LAB_001ac9d3;\n      }\n      switch(iVar1) {\n      case 0x61:\n        goto switchD_001ac9c2_caseD_61;\n      default:\n        builtin_usage();\n        uVar13 = 0x102;\n        goto LAB_001ac9d3;\n      case 99:\n        uVar10 = uVar10 | 0x40;\n        goto LAB_001ac99a;\n      case 100:\n        uVar10 = (uint)(byte)((byte)uVar10 | 0x80);\n        unaff_R13 = list_optarg;\n        goto LAB_001ac99a;\n      case 0x6e:\n        uVar10 = uVar10 | 8;\n        goto LAB_001ac99a;\n      case 0x70:\n        uVar10 = uVar10 | 0x20;\n        goto LAB_001ac99a;\n      case 0x72:\n        uVar10 = uVar10 | 2;\n        goto LAB_001ac99a;\n      case 0x73:\n        uVar10 = uVar10 | 0x10;\n        goto LAB_001ac99a;\n      case 0x77:\n        uVar10 = uVar10 | 4;\n        iVar1 = internal_getopt(param_1,\"acd:npsrw\");\n        if (iVar1 == -1) goto LAB_001aca18;\n      }\n    } while( true );\n  }\nLAB_001aca18:\n  plVar7 = loptend;\n  uVar13 = 0x117L >> ((byte)uVar10 & 0xf);\n  if ((uVar13 & 1) == 0) {\n    uVar13 = 1;\n    builtin_error(\"cannot use more than one of -anrw\");\n    goto LAB_001ac9d3;\n  }\n  if ((uVar10 & 0x40) == 0) {\n    if ((uVar10 & 0x10) != 0) {\n      if (loptend != (long *)0x0) goto LAB_001acca2;\n      goto LAB_001acd27;\n    }\n    if ((uVar10 & 0x20) == 0) {\nLAB_001aca53:\n      if ((uVar10 & 0x80) == 0) {\n        local_6c = uVar10 & 0x4f;\n        if ((uVar10 & 0x4f) != 0) {\n          if (plVar7 == (long *)0x0) {\n            pcVar4 = (char *)get_string_value(\"HISTFILE\");\n          }\n          else {\n            pcVar4 = *(char **)plVar7[1];\n          }\n          if ((restricted == 0) || (pcVar6 = strchr(pcVar4,0x2f), pcVar6 == (char *)0x0)) {\n            iVar3 = history_lines_in_file;\n            iVar1 = history_base;\n            if ((uVar10 & 1) == 0) {\n              if ((uVar10 & 4) == 0) {\n                if ((uVar10 & 2) == 0) {\n                  uVar13 = (ulong)(uVar10 & 8);\n                  if ((uVar10 & 8) != 0) {\n                    using_history();\n                    iVar2 = read_history_range(pcVar4,history_lines_in_file,0xffffffff);\n                    using_history();\n                    history_lines_in_file = history_lines_read_from_file;\n                    if (force_append_history == 0) {\n                      history_lines_this_session =\n                           history_lines_this_session +\n                           (((history_lines_read_from_file - iVar3) + history_base) - iVar1);\n                    }\n                    uVar13 = (ulong)(iVar2 != 0);\n                  }\n                }\n                else {\n                  iVar1 = read_history(pcVar4);\n                  history_lines_in_file = history_lines_read_from_file;\n                  uVar13 = (ulong)(iVar1 != 0);\n                }\n              }\n              else {\n                iVar1 = write_history(pcVar4);\n                uVar13 = (ulong)(iVar1 != 0);\n              }\n            }\n            else {\n              iVar1 = maybe_append_history(pcVar4);\n              uVar13 = (ulong)(iVar1 != 0);\n            }\n          }\n          else {\n            uVar13 = 1;\n            sh_restricted(pcVar4);\n          }\n          goto LAB_001ac9d3;\n        }\n        if (plVar7 == (long *)0x0) {\n          local_50 = 0xffffffffffffffff;\nLAB_001acf62:\n          plVar7 = (long *)history_list();\n          if (plVar7 != (long *)0x0) {\n            uVar13 = (ulong)((uint)uVar13 & 1);\n            if (*plVar7 == 0) {\n              iVar1 = 0;\n            }\n            else {\n              do {\n                iVar3 = (int)uVar13;\n                plVar11 = plVar7 + uVar13;\n                uVar13 = uVar13 + 1;\n              } while (*plVar11 != 0);\n              iVar1 = 0;\n              if (-1 < (long)local_50) {\n                iVar1 = 0;\n                if ((long)local_50 < (long)iVar3) {\n                  iVar1 = iVar3 - (int)local_50;\n                }\n              }\n            }\n            pcVar4 = (char *)get_string_value(\"HISTTIMEFORMAT\");\n            plVar11 = plVar7 + iVar1;\n            if (*plVar11 != 0) {\n              plVar7 = plVar7 + (long)iVar1 + 1;\n              do {\n                if (terminating_signal != 0) {\n                  termsig_handler(terminating_signal);\n                }\n                if (interrupt_state != 0) {\n                  throw_to_top_level();\n                }\n                puVar9 = (undefined8 *)*plVar11;\n                if ((pcVar4 == (char *)0x0) || (*pcVar4 == '\\0')) {\n                  uVar5 = *puVar9;\n                  puVar12 = &DAT_00213d70;\n                }\n                else {\n                  local_48 = (char *)history_get_time(puVar9);\n                  if (((local_48 == (char *)0x0) ||\n                      (__tp = localtime((time_t *)&local_48), local_48 == (char *)0x0)) ||\n                     (__tp == (tm *)0x0)) {\n                    pcVar6 = (char *)puVar9[1];\n                    if ((pcVar6 == (char *)0x0) || (*pcVar6 == '\\0')) {\n                      DAT_00248ac2 = 0;\n                      _DAT_00248ac0 = 0x3f3f;\n                    }\n                    else {\n                      __snprintf_chk(&DAT_00248ac0,0x80,1,0x80,\"%s: invalid timestamp\",\n                                     pcVar6 + (*pcVar6 == '#'));\n                    }\n                  }\n                  else {\n                    strftime(&DAT_00248ac0,0x80,pcVar4,__tp);\n                  }\n                  puVar9 = (undefined8 *)*plVar11;\n                  puVar12 = &DAT_00213d70;\n                  if (DAT_00248ac0 != '\\0') {\n                    puVar12 = &DAT_00248ac0;\n                  }\n                  uVar5 = *puVar9;\n                }\n                plVar11 = plVar11 + 1;\n                iVar3 = history_base + iVar1;\n                iVar1 = iVar1 + 1;\n                __printf_chk(1,\"%5d%c %s%s\\n\",iVar3,(-(uint)(puVar9[2] == 0) & 0xfffffff6) + 0x2a,\n                             puVar12,uVar5);\n                lVar8 = *plVar7;\n                plVar7 = plVar7 + 1;\n              } while (lVar8 != 0);\n            }\n          }\n        }\n        else {\n          iVar1 = get_numeric_arg(plVar7,0,&local_50);\n          if (iVar1 != 0) {\n            if ((long)local_50 < 0) {\n              local_50 = -local_50;\n            }\n            goto LAB_001acf62;\n          }\n          local_6c = 1;\n        }\n        if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\nLAB_001ace38:\n          uVar13 = sh_chkwrite(local_6c);\n          return uVar13;\n        }\n        goto LAB_001ad21f;\n      }\n      pcVar4 = strchr(unaff_R13 + (*unaff_R13 == '-'),0x2d);\n      if (pcVar4 == (char *)0x0) {\n        iVar1 = legal_number(unaff_R13,&local_48);\n        if (iVar1 != 0) {\n          if ((*unaff_R13 == '-') && ((long)local_48 < 0)) {\n            iVar1 = (int)local_48 + history_length;\n            pcVar4 = (char *)(ulong)(uint)(history_base + iVar1);\n            if (-1 < iVar1) {\nLAB_001ace87:\n              iVar1 = bash_delete_histent((int)pcVar4 - history_base);\nLAB_001ace90:\n              iVar3 = where_history();\n              if (history_length < iVar3) {\n                history_set_pos();\n              }\n              uVar13 = (ulong)(iVar1 == 0);\n              goto LAB_001ac9d3;\n            }\n          }\n          else if (((long)history_base <= (long)local_48) &&\n                  (pcVar4 = local_48, (long)local_48 < (long)(history_length + history_base)))\n          goto LAB_001ace87;\n        }\nLAB_001acecb:\n        uVar13 = 1;\n        sh_erange(unaff_R13,\"history position\");\n      }\n      else {\n        *pcVar4 = '\\0';\n        iVar1 = legal_number(unaff_R13,&local_50);\n        if (iVar1 != 0) {\n          iVar1 = legal_number(pcVar4 + 1,&local_48);\n          if (iVar1 != 0) {\n            if (*unaff_R13 == '-') {\n              if ((long)local_50 < 0) {\n                local_50 = local_50 + (long)history_length;\n                goto LAB_001acad5;\n              }\n              if (local_50 != 0) goto LAB_001acac6;\n            }\n            else {\n              if (0 < (long)local_50) {\nLAB_001acac6:\n                local_50 = local_50 - (long)history_base;\n              }\nLAB_001acad5:\n              if ((long)local_50 < 0) goto LAB_001acecb;\n            }\n            lVar8 = (long)history_length;\n            if ((long)local_50 < lVar8) {\n              if ((pcVar4[1] == '-') && ((long)local_48 < 0)) {\n                local_48 = local_48 + lVar8;\n              }\n              else if (0 < (long)local_48) {\n                local_48 = local_48 + -(long)history_base;\n              }\n              if ((-1 < (long)local_48) && ((long)local_48 < lVar8)) {\n                iVar1 = bash_delete_history_range\n                                  (local_50 & 0xffffffff,(ulong)local_48 & 0xffffffff);\n                goto LAB_001ace90;\n              }\n              uVar13 = 1;\n              sh_erange(pcVar4 + 1,\"history position\");\n              goto LAB_001ac9d3;\n            }\n            goto LAB_001acecb;\n          }\n        }\n        *pcVar4 = '-';\n        uVar13 = 1;\n        sh_erange(unaff_R13,\"history position\");\n      }\n    }\n    else {\n      if (loptend == (long *)0x0) {\n        if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n          local_6c = 0;\n          goto LAB_001ace38;\n        }\n        goto LAB_001ad21f;\n      }\nLAB_001acbc9:\n      if ((hist_last_line_pushed == 0) && (hist_last_line_added != 0)) {\n        iVar1 = bash_delete_last_history();\n        uVar13 = 1;\n        if (iVar1 == 0) goto LAB_001ac9d3;\n      }\n      uVar13 = 0;\n      do {\n        iVar1 = history_expand(*(undefined8 *)plVar7[1],&local_48);\n        if (iVar1 < 0) {\n          uVar13 = 1;\n          builtin_error(\"%s: history expansion failed\",*(undefined8 *)plVar7[1]);\n        }\n        else {\n          fputs(local_48,stdout);\n          putc(10,stdout);\n        }\n        if (local_48 != (char *)0x0) {\n          sh_xfree(local_48,\"./history.def\",0x1c9);\n        }\n        plVar7 = (long *)*plVar7;\n      } while (plVar7 != (long *)0x0);\n      fflush(stdout);\n    }\n  }\n  else {\n    bash_clear_history();\n    if (plVar7 != (long *)0x0) {\n      if ((uVar10 & 0x10) == 0) {\n        if ((uVar10 & 0x20) != 0) goto LAB_001acbc9;\n        goto LAB_001aca53;\n      }\nLAB_001acca2:\n      if ((((remember_on_history == 0) || (hist_last_line_pushed != 0)) ||\n          ((hist_last_line_added == 0 &&\n           (((current_command_line_count < 1 || (current_command_first_line_saved == 0)) ||\n            (command_oriented_history == 0)))))) || (iVar1 = bash_delete_last_history(), iVar1 != 0)\n         ) {\n        uVar5 = string_list(plVar7);\n        check_add_history(uVar5,1);\n        hist_last_line_pushed = 1;\n        sh_xfree(uVar5,\"./history.def\",0x1ae);\n      }\n    }\nLAB_001acd27:\n    uVar13 = 0;\n  }\nLAB_001ac9d3:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar13;\n  }\nLAB_001ad21f:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\nswitchD_001ac9c2_caseD_61:\n  uVar10 = uVar10 | 1;\n  goto LAB_001ac99a;\n}\n\n",
  "var_lookup": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong var_lookup(undefined8 param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  \n  if (param_2 == 0) {\n    return 0;\n  }\n  while( true ) {\n    uVar1 = *(undefined8 *)(param_2 + 0x20);\n    lVar2 = hash_search(param_1,uVar1,0);\n    if ((lVar2 != 0) && (_DAT_002422f8 = uVar1, *(long *)(lVar2 + 0x10) != 0)) break;\n    param_2 = *(long *)(param_2 + 0x18);\n    if (param_2 == 0) {\n      return 0;\n    }\n  }\n  return *(long *)(lVar2 + 0x10);\n}\n\n",
  "FUN_0017a460": "\n/* WARNING: Removing unreachable block (ram,0x0017a4c3) */\n\nlong * FUN_0017a460(long **param_1)\n\n{\n  undefined8 *puVar1;\n  char cVar2;\n  char cVar3;\n  long **pplVar4;\n  long **pplVar5;\n  char **ppcVar6;\n  uint uVar7;\n  int iVar8;\n  long **pplVar9;\n  long **pplVar10;\n  long lVar11;\n  size_t __n;\n  size_t sVar12;\n  void *__dest;\n  long *plVar13;\n  undefined8 uVar14;\n  undefined8 uVar15;\n  int iVar16;\n  char cVar17;\n  uint uVar18;\n  long lVar19;\n  undefined8 *puVar20;\n  undefined *puVar21;\n  int iVar22;\n  long **pplVar23;\n  char *pcVar24;\n  uint uVar25;\n  long in_FS_OFFSET;\n  byte bVar26;\n  long *local_138;\n  long **local_130;\n  undefined8 local_128;\n  undefined8 *local_120;\n  int local_e0;\n  undefined local_dc [4];\n  undefined2 local_d8;\n  undefined8 local_c8;\n  long local_40;\n  \n  bVar26 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (long **)0x0) {\n    local_138 = (long *)0x0;\nLAB_0017ac0f:\n    if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    return local_138;\n  }\n  local_130 = (long **)0x0;\n  plVar13 = param_1[1];\n  local_138 = (long *)0x0;\n  uVar7 = *(uint *)(plVar13 + 1);\n  pplVar23 = param_1;\n  do {\n    if ((uVar7 & 0x10000) != 0) {\n      local_130 = pplVar23;\n    }\n    do {\n      pplVar4 = (long **)*pplVar23;\n      if ((uVar7 & 0x28000) == 0x28000) {\n        uVar18 = uVar7 & 0x12c00000;\n        if ((uVar7 & 0x12c00000) != 0) {\n          local_d8 = CONCAT11(local_d8._1_1_,0x2d);\n          uVar18 = 1;\n        }\n        if ((uVar7 & 0x2400000) == 0x2400000) {\n          uVar25 = uVar18 + 2;\n          *(undefined *)((long)&local_d8 + (long)(int)uVar18) = 0x67;\n          *(undefined *)((long)&local_d8 + (long)(int)(uVar18 + 1)) = 0x41;\n        }\n        else if ((uVar7 & 0x400000) == 0) {\n          if ((uVar7 & 0x2800000) == 0x2800000) {\n            uVar25 = uVar18 + 2;\n            *(undefined *)((long)&local_d8 + (long)(int)uVar18) = 0x67;\n            *(undefined *)((long)&local_d8 + (long)(int)(uVar18 + 1)) = 0x61;\n          }\n          else if ((uVar7 & 0x800000) == 0) {\n            uVar25 = uVar18;\n            if ((uVar7 & 0x2000000) != 0) {\n              uVar25 = uVar18 + 1;\n              *(undefined *)((long)&local_d8 + (long)(int)uVar18) = 0x67;\n            }\n          }\n          else {\n            *(undefined *)((long)&local_d8 + (long)(int)uVar18) = 0x61;\n            uVar25 = uVar18 + 1;\n          }\n        }\n        else {\n          *(undefined *)((long)&local_d8 + (long)(int)uVar18) = 0x41;\n          uVar25 = uVar18 + 1;\n        }\n        if ((uVar7 & 0x10000000) != 0) {\n          lVar11 = (long)(int)uVar25;\n          uVar25 = uVar25 + 1;\n          *(undefined *)((long)&local_d8 + lVar11) = 0x47;\n        }\n        puVar20 = &local_c8;\n        for (lVar11 = 0x10; lVar11 != 0; lVar11 = lVar11 + -1) {\n          *puVar20 = 0;\n          puVar20 = puVar20 + (ulong)bVar26 * -2 + 1;\n        }\n        pplVar9 = (long **)*local_130;\n        if (pplVar9 == pplVar23) {\n          cVar17 = '\\0';\n        }\n        else {\n          do {\n            ppcVar6 = (char **)pplVar9[1];\n            pcVar24 = *ppcVar6;\n            cVar2 = *pcVar24;\n            cVar17 = (char)local_c8;\n            if ((cVar2 - 0x2bU & 0xfd) != 0) break;\n            cVar3 = pcVar24[1];\n            if ((cVar2 == '-') && (cVar3 == '-')) {\n              if (pcVar24[2] == '\\0') break;\nLAB_0017a686:\n              lVar11 = 2;\n              do {\n                if ((((byte)((int)cVar3 - 0x49U) < 0x2d) &&\n                    ((0x100904000001U >> ((ulong)((int)cVar3 - 0x49U) & 0x3f) & 1) != 0)) &&\n                   (*(undefined *)((long)&local_c8 + (long)cVar3) = 1, uVar25 == 0)) {\n                  local_d8 = CONCAT11(local_d8._1_1_,cVar2);\n                  uVar25 = 1;\n                  pcVar24 = *ppcVar6;\n                }\n                cVar3 = pcVar24[lVar11];\n                lVar11 = lVar11 + 1;\n              } while (cVar3 != '\\0');\n            }\n            else if (cVar3 != '\\0') goto LAB_0017a686;\n            pplVar9 = (long **)*pplVar9;\n            cVar17 = (char)local_c8;\n          } while (pplVar9 != pplVar23);\n        }\n        lVar11 = 0;\n        while( true ) {\n          if (cVar17 != '\\0') {\n            lVar19 = (long)(int)uVar25;\n            uVar25 = uVar25 + 1;\n            *(char *)((long)&local_d8 + lVar19) = (char)lVar11;\n          }\n          lVar11 = lVar11 + 1;\n          if (lVar11 == 0x80) break;\n          cVar17 = *(char *)((long)&local_c8 + lVar11);\n        }\n        if ((*(uint *)(plVar13 + 1) & 0xc00000 | uVar25) == 0) {\n          uVar25 = 2;\n          local_d8 = 0x2d2d;\n        }\n        *(undefined *)((long)&local_d8 + (long)(int)uVar25) = 0;\n        uVar7 = *(uint *)(plVar13 + 1);\n        iVar8 = assignment(*pplVar23[1],0);\n        lVar11 = (long)iVar8;\n        __n = lVar11 + 1;\n        pcVar24 = (char *)(__n + *pplVar23[1]);\n        sVar12 = strlen(pcVar24);\n        local_128 = 0;\n        if (pcVar24[(long)(int)sVar12 + -1] == ')') {\n          local_128 = substring(pcVar24,1,(int)sVar12 + -1);\n        }\n        if ((uVar7 & 0x400000) == 0) {\n          local_120 = (undefined8 *)expand_compound_array_assignment(0,local_128,0);\n          quote_compound_array_list(local_120,0);\n        }\n        else {\n          local_120 = (undefined8 *)parse_string_to_word_list(local_128,1,\"array assign\");\n          iVar16 = kvpair_assignment_p(local_120);\n          puVar20 = local_120;\n          while (puVar20 != (undefined8 *)0x0) {\n            puVar21 = *(undefined **)(undefined8 *)puVar20[1];\n            if (iVar16 == 0) {\n              if ((*(byte *)((undefined8 *)puVar20[1] + 1) & 4) == 0) {\n                if (puVar21 == (undefined *)0x0) {\n                  puVar21 = &DAT_00213d70;\n                }\n                uVar14 = sh_single_quote(puVar21);\n              }\n              else {\n                uVar14 = expand_and_quote_assoc_word(puVar21,1);\n              }\n            }\n            else {\n              uVar14 = expand_and_quote_kvpair_word();\n            }\n            sh_xfree(*(undefined8 *)puVar20[1],\"subst.c\",0x310d);\n            puVar1 = puVar20 + 1;\n            puVar20 = (undefined8 *)*puVar20;\n            *(undefined8 *)*puVar1 = uVar14;\n          }\n        }\n        sh_xfree(local_128,\"subst.c\",0x312d);\n        pcVar24 = (char *)string_list_internal(local_120,&DAT_001fdb1c);\n        dispose_words(local_120);\n        iVar22 = iVar8 + 3;\n        iVar16 = iVar8 + 2;\n        if (pcVar24 == (char *)0x0) {\n          __dest = (void *)sh_xmalloc((long)(iVar8 + 4),\"subst.c\",0x3135);\n          memcpy(__dest,(void *)*pplVar23[1],__n);\n          *(undefined *)((long)__dest + lVar11 + 1) = 0x28;\n        }\n        else {\n          if (*pcVar24 == '\\0') {\n            sVar12 = 0;\n            iVar8 = 0;\n          }\n          else if (pcVar24[1] == '\\0') {\n            sVar12 = 1;\n            iVar8 = 1;\n          }\n          else if (pcVar24[2] == '\\0') {\n            sVar12 = 2;\n            iVar8 = 2;\n          }\n          else {\n            sVar12 = strlen(pcVar24);\n            iVar8 = (int)sVar12;\n            sVar12 = (size_t)iVar8;\n          }\n          __dest = (void *)sh_xmalloc((long)(iVar8 + 1 + iVar22),\"subst.c\",0x3135);\n          memcpy(__dest,(void *)*pplVar23[1],__n);\n          *(undefined *)((long)__dest + lVar11 + 1) = 0x28;\n          memcpy((void *)((long)iVar16 + (long)__dest),pcVar24,sVar12);\n          iVar16 = iVar16 + iVar8;\n          iVar22 = iVar16 + 1;\n        }\n        *(undefined *)((long)__dest + (long)iVar16) = 0x29;\n        *(undefined *)((long)__dest + (long)iVar22) = 0;\n        sh_xfree(*pplVar23[1],\"subst.c\",0x313f);\n        *pplVar23[1] = (long)__dest;\n        sh_xfree(pcVar24,\"subst.c\",0x3142);\n        if (uVar25 == 0) {\nLAB_0017aa87:\n          iVar8 = FUN_00173b20(pplVar23[1],1);\n          if (iVar8 == 0) {\n            last_command_exit_value = 1;\nLAB_0017acc1:\n                    /* WARNING: Subroutine does not return */\n            FUN_001667f0(2);\n          }\n          plVar13 = pplVar23[1];\n        }\n        else {\n          plVar13 = (long *)make_word(*pplVar23[1]);\n          iVar8 = assignment(*plVar13,0);\n          pcVar24 = (char *)(*plVar13 + (long)iVar8);\n          if (*pcVar24 == '=') {\n            *pcVar24 = '\\0';\n            pcVar24 = (char *)(*plVar13 + -1 + (long)iVar8);\n            if (*pcVar24 == '+') {\n              *pcVar24 = '\\0';\n            }\n          }\n          uVar14 = make_word_list(plVar13,0);\n          uVar15 = make_word(&local_d8);\n          uVar14 = make_word_list(uVar15,uVar14);\n          iVar8 = declare_builtin(uVar14);\n          dispose_words(uVar14);\n          if (iVar8 == 0) goto LAB_0017aa87;\n          plVar13 = pplVar23[1];\n          last_command_exit_value = iVar8;\n          if ((*(byte *)((long)plVar13 + 0xb) & 0x20) == 0) goto LAB_0017acc1;\n        }\n        iVar8 = assignment(*plVar13,0);\n        *(undefined *)(*pplVar23[1] + (long)iVar8) = 0;\n        plVar13 = pplVar23[1];\n        pcVar24 = (char *)(*plVar13 + -1 + (long)iVar8);\n        if (*pcVar24 == '+') {\n          *pcVar24 = '\\0';\n          plVar13 = pplVar23[1];\n        }\n        *(uint *)(plVar13 + 1) = *(uint *)(plVar13 + 1) & 0xff3d7feb;\n      }\n      local_e0 = 0;\n      pplVar9 = (long **)FUN_00177e80(plVar13,0,0,local_dc,&local_e0);\n      if (pplVar9 == (long **)&DAT_00247880) {\n        *pplVar23[1] = 0;\n        dispose_words(param_1);\n        dispose_words(local_138);\n        last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n        FUN_001667f0(2);\n      }\n      if (pplVar9 == (long **)&DAT_00247870) {\n        *pplVar23[1] = 0;\n        dispose_words(param_1);\n        dispose_words(local_138);\n        last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n        FUN_001667f0(1);\n      }\n      if ((local_e0 == 0) || ((*(byte *)(pplVar23[1] + 1) & 0x10) != 0)) {\n        pplVar23 = pplVar9;\n        if (pplVar9 == (long **)0x0) goto LAB_0017a5e2;\n        do {\n          remove_quoted_nulls(*pplVar23[1]);\n          pplVar5 = (long **)*pplVar23;\n          *(uint *)(pplVar23[1] + 1) = *(uint *)(pplVar23[1] + 1) & 0xfffbffff;\n          pplVar10 = pplVar9;\n          pplVar23 = pplVar5;\n        } while (pplVar5 != (long **)0x0);\nLAB_0017a568:\n        if (*pplVar10 != (long *)0x0) {\n          pplVar10 = (long **)list_reverse(pplVar10);\n        }\n      }\n      else {\n        pplVar10 = (long **)FUN_00171b00(pplVar9);\n        dispose_words(pplVar9);\n        if (pplVar10 != (long **)0x0) goto LAB_0017a568;\nLAB_0017a5e2:\n        pplVar10 = (long **)0x0;\n      }\n      local_138 = (long *)list_append(pplVar10);\n      if (pplVar4 == (long **)0x0) {\n        dispose_words(param_1);\n        if ((local_138 != (long *)0x0) && (*local_138 != 0)) {\n          local_138 = (long *)list_reverse(local_138);\n        }\n        goto LAB_0017ac0f;\n      }\n      plVar13 = pplVar4[1];\n      uVar7 = *(uint *)(plVar13 + 1);\n      pplVar23 = pplVar4;\n    } while (local_130 != (long **)0x0);\n  } while( true );\n}\n\n",
  "check_signals": "\nvoid check_signals(void)\n\n{\n  check_read_timeout();\n  if (terminating_signal != 0) {\n    termsig_handler(terminating_signal);\n  }\n  if (interrupt_state != 0) {\n    throw_to_top_level();\n    return;\n  }\n  return;\n}\n\n",
  "shell_is_restricted": "\nundefined4 shell_is_restricted(void)\n\n{\n  char cVar1;\n  int iVar2;\n  char *__s1;\n  \n  if (restricted == 0) {\n    __s1 = (char *)base_pathname();\n    cVar1 = *__s1;\n    if (cVar1 == '-') {\n      cVar1 = __s1[1];\n      __s1 = __s1 + 1;\n    }\n    if (cVar1 != 'r') {\n      return 0;\n    }\n    iVar2 = strcmp(__s1,\"rbash\");\n    if (iVar2 != 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\n",
  "unbind_func": "\nundefined8 unbind_func(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = hash_remove(param_1,shell_functions,0);\n  if (lVar1 == 0) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    set_itemlist_dirty(it_functions);\n    if (*(long *)(lVar1 + 0x10) != 0) {\n      if ((*(byte *)(*(long *)(lVar1 + 0x10) + 0x28) & 1) != 0) {\n        array_needs_making = array_needs_making + 1;\n      }\n      dispose_variable();\n    }\n    sh_xfree(*(undefined8 *)(lVar1 + 8),\"variables.c\",0xf4e);\n    sh_xfree(lVar1,\"variables.c\",0xf4f);\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n",
  "FUN_00183ff0": "\nvoid FUN_00183ff0(void **param_1)\n\n{\n  memcpy(*param_1,(void *)((long)param_1 + 0xc),(long)*(int *)(param_1 + 1));\n  return;\n}\n\n",
  "FUN_001935c0": "\nulong FUN_001935c0(long param_1,int param_2,int param_3,uint *param_4)\n\n{\n  char cVar1;\n  uint uVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  ulong uVar6;\n  char *pcVar7;\n  \n  uVar6 = (ulong)param_2;\n  cVar1 = *(char *)(param_1 + uVar6);\n  if (cVar1 != '\\0') {\n    pcVar7 = (char *)(param_1 + 1 + uVar6);\n    do {\n      iVar5 = (int)cVar1;\n      if ((cVar1 != ' ') && (cVar1 != '\\t')) {\n        if (param_3 == 0) {\n          if ((cVar1 != '\\\"') && (cVar1 != '\\'')) goto LAB_00193654;\n        }\n        else {\n          if (cVar1 != '\\\"') goto LAB_001936aa;\n          iVar5 = 0x22;\n        }\n        uVar2 = (int)uVar6 + 1;\n        uVar6 = (ulong)uVar2;\n        *param_4 = uVar2;\n        iVar4 = (int)*(char *)(param_1 + (int)uVar2);\n        if (*(char *)(param_1 + (int)uVar2) != '\\0') goto joined_r0x00193667;\n        goto LAB_00193692;\n      }\n      cVar1 = *pcVar7;\n      pcVar7 = pcVar7 + 1;\n      uVar6 = (ulong)((int)uVar6 + 1);\n    } while (cVar1 != '\\0');\n  }\n  if (param_3 == 0) {\nLAB_00193654:\n    *param_4 = (uint)uVar6;\n    iVar5 = 0;\n    cVar1 = *(char *)(param_1 + (int)(uint)uVar6);\n    iVar4 = (int)cVar1;\n    if (cVar1 != '\\0') {\njoined_r0x00193667:\n      do {\n        iVar3 = (int)uVar6;\n        if (iVar4 != 0x5c) {\n          if (iVar4 == iVar5) {\n            return uVar6;\n          }\n          uVar6 = (ulong)(iVar3 + 1U);\n          cVar1 = *(char *)(param_1 + (int)(iVar3 + 1U));\n          iVar4 = (int)cVar1;\n          if (cVar1 == '\\0') break;\n          goto joined_r0x00193667;\n        }\n        if (*(char *)(param_1 + (int)(iVar3 + 1U)) == '\\0') {\n          uVar6 = (ulong)(iVar3 + 1U);\n          break;\n        }\n        uVar6 = (ulong)(iVar3 + 2U);\n        cVar1 = *(char *)(param_1 + (int)(iVar3 + 2U));\n        iVar4 = (int)cVar1;\n      } while (cVar1 != '\\0');\n      if (iVar5 != 0) {\nLAB_00193692:\n        builtin_error(\"no closing `%c\\' in %s\",iVar5,param_1);\n        uVar6 = 0xffffffff;\n      }\n    }\n  }\n  else {\nLAB_001936aa:\n    builtin_error(\"%s: first non-whitespace character is not `\\\"\\'\",param_1);\n    uVar6 = 0xffffffff;\n  }\n  return uVar6;\n}\n\n",
  "rl_clear_signals": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 rl_clear_signals(void)\n\n{\n  __sigset_t *__set;\n  long in_FS_OFFSET;\n  sigaction sStack_b8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((rl_catch_signals != 0) && (DAT_0024b13c == 1)) {\n    __set = &sStack_b8.sa_mask;\n    sigemptyset(__set);\n    sStack_b8.sa_flags = 0;\n    if (_DAT_0024b0a0 != 1) {\n      sigaction(2,(sigaction *)&DAT_0024b0a0,&sStack_b8);\n    }\n    sigemptyset(__set);\n    sStack_b8.sa_flags = 0;\n    if (_DAT_0024b000 != 1) {\n      sigaction(0xf,(sigaction *)&DAT_0024b000,&sStack_b8);\n    }\n    sigemptyset(__set);\n    sStack_b8.sa_flags = 0;\n    if (_DAT_0024af60 != 1) {\n      sigaction(1,(sigaction *)&DAT_0024af60,&sStack_b8);\n    }\n    sigemptyset(__set);\n    sStack_b8.sa_flags = 0;\n    if (_DAT_0024ae20 != 1) {\n      sigaction(3,(sigaction *)&DAT_0024ae20,&sStack_b8);\n    }\n    sigemptyset(__set);\n    sStack_b8.sa_flags = 0;\n    if (DAT_0024aec0 != 1) {\n      sigaction(0xe,(sigaction *)&DAT_0024aec0,&sStack_b8);\n    }\n    sigemptyset(__set);\n    sStack_b8.sa_flags = 0;\n    if (_DAT_0024ad80 != 1) {\n      sigaction(0x14,(sigaction *)&DAT_0024ad80,&sStack_b8);\n    }\n    sigemptyset(__set);\n    sStack_b8.sa_flags = 0;\n    if (_DAT_0024ace0 != 1) {\n      sigaction(0x16,(sigaction *)&DAT_0024ace0,&sStack_b8);\n    }\n    sigemptyset(__set);\n    sStack_b8.sa_flags = 0;\n    if (_DAT_0024ac40 != 1) {\n      sigaction(0x15,(sigaction *)&DAT_0024ac40,&sStack_b8);\n    }\n    DAT_0024b13c = 0;\n  }\n  if ((rl_catch_sigwinch != 0) && (DAT_0024b138 == 1)) {\n    sigemptyset(&sStack_b8.sa_mask);\n    sigaction(0x1c,(sigaction *)&DAT_0024aba0,&sStack_b8);\n    DAT_0024b138 = 0;\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00152370": "\nlong FUN_00152370(long param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = itos((long)subshell_level);\n  if (*(long *)(param_1 + 8) != 0) {\n    sh_xfree(*(long *)(param_1 + 8),\"variables.c\",0x527);\n  }\n  *(undefined8 *)(param_1 + 8) = uVar1;\n  return param_1;\n}\n\n",
  "strlist_prefix_suffix": "\nlong * strlist_prefix_suffix(long *param_1,char *param_2,char *param_3)\n\n{\n  long lVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  size_t sVar5;\n  char *pcVar6;\n  long lVar7;\n  long lVar8;\n  uint local_50;\n  int local_4c;\n  \n  if (param_1 == (long *)0x0) {\n    return (long *)0x0;\n  }\n  lVar7 = *param_1;\n  if (lVar7 == 0) {\n    return param_1;\n  }\n  iVar2 = *(int *)((long)param_1 + 0xc);\n  if (iVar2 == 0) {\n    return param_1;\n  }\n  if ((param_2 == (char *)0x0) || (*param_2 == '\\0')) {\n    if (param_3 == (char *)0x0) {\n      return param_1;\n    }\n    if (*param_3 == '\\0') {\n      return param_1;\n    }\n    local_50 = 0;\nLAB_001c7a50:\n    if (param_3[1] == '\\0') {\n      uVar3 = 1;\n      goto LAB_001c7aa5;\n    }\n    if (param_3[2] == '\\0') {\n      uVar3 = 2;\n      goto LAB_001c7aa5;\n    }\n    sVar5 = strlen(param_3);\n    uVar3 = (uint)sVar5;\n    uVar4 = uVar3 | local_50;\n  }\n  else {\n    if (param_2[1] == '\\0') {\n      local_50 = 1;\nLAB_001c7a90:\n      if ((param_3 == (char *)0x0) || (*param_3 == '\\0')) {\n        uVar3 = 0;\n        goto LAB_001c7aa5;\n      }\n      goto LAB_001c7a50;\n    }\n    if (param_2[2] == '\\0') {\n      local_50 = 2;\n      goto LAB_001c7a90;\n    }\n    sVar5 = strlen(param_2);\n    uVar4 = (uint)sVar5;\n    local_50 = uVar4;\n    if ((param_3 != (char *)0x0) && (*param_3 != '\\0')) goto LAB_001c7a50;\n    uVar3 = 0;\n  }\n  if (uVar4 == 0) {\n    return param_1;\n  }\nLAB_001c7aa5:\n  if (0 < iVar2) {\n    lVar8 = 0;\n    do {\n      pcVar6 = *(char **)(lVar7 + lVar8 * 8);\n      lVar1 = lVar8 * 8;\n      if ((pcVar6 == (char *)0x0) || (*pcVar6 == '\\0')) {\n        local_4c = 0;\n        uVar4 = local_50;\n      }\n      else if (pcVar6[1] == '\\0') {\n        local_4c = 1;\n        uVar4 = local_50 + 1;\n      }\n      else if (pcVar6[2] == '\\0') {\n        local_4c = 2;\n        uVar4 = local_50 + 2;\n      }\n      else {\n        sVar5 = strlen(pcVar6);\n        local_4c = (int)sVar5;\n        uVar4 = local_4c + local_50;\n      }\n      pcVar6 = (char *)sh_xmalloc((long)(int)(uVar3 + 2 + uVar4),\"stringlist.c\",0xd4);\n      if (local_50 != 0) {\n        strcpy(pcVar6,param_2);\n      }\n      strcpy(pcVar6 + (int)local_50,*(char **)(*param_1 + lVar1));\n      if (uVar3 != 0) {\n        strcpy(pcVar6 + (long)local_4c + (long)(int)local_50,param_3);\n      }\n      lVar8 = lVar8 + 1;\n      sh_xfree(*(undefined8 *)(*param_1 + lVar1),\"stringlist.c\",0xda);\n      lVar7 = *param_1;\n      *(char **)(lVar7 + lVar1) = pcVar6;\n    } while (*(int *)((long)param_1 + 0xc) != (int)lVar8 &&\n             (int)lVar8 <= *(int *)((long)param_1 + 0xc));\n  }\n  return param_1;\n}\n\n",
  "check_mail": "\nvoid check_mail(void)\n\n{\n  long lVar1;\n  char **ppcVar2;\n  long lVar3;\n  int iVar4;\n  char *pcVar5;\n  size_t sVar6;\n  char *pcVar7;\n  char *pcVar8;\n  ulong uVar9;\n  long in_FS_OFFSET;\n  char *local_f0;\n  undefined local_d8 [48];\n  long local_a8;\n  long local_90;\n  long local_80;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar5 = (char *)get_string_value(\"_\");\n  if (pcVar5 == (char *)0x0) {\n    local_f0 = (char *)0x0;\n    if (0 < DAT_002478b0) goto LAB_00180c62;\nLAB_00180ef0:\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      unbind_variable(\"_\");\n      return;\n    }\n  }\n  else {\n    sVar6 = strlen(pcVar5);\n    pcVar7 = (char *)sh_xmalloc(sVar6 + 1,\"mailcheck.c\",0x1a9);\n    local_f0 = strcpy(pcVar7,pcVar5);\n    if (0 < DAT_002478b0) {\nLAB_00180c62:\n      uVar9 = 0;\n      do {\n        lVar1 = uVar9 * 8;\n        ppcVar2 = *(char ***)(DAT_002478b8 + uVar9 * 8);\n        pcVar5 = *ppcVar2;\n        if (*pcVar5 != '\\0') {\n          pcVar7 = ppcVar2[3];\n          iVar4 = mailstat(pcVar5,local_d8);\n          if (iVar4 == 0) {\n            if (local_a8 < 1) {\n              if ((local_a8 == 0) &&\n                 (lVar3 = *(long *)(DAT_002478b8 + lVar1), 0 < *(long *)(lVar3 + 0x20))) {\n                *(long *)(lVar3 + 0x10) = local_90;\n                *(uint *)(lVar3 + 0x28) = *(uint *)(lVar3 + 0x28) | 1;\n                *(long *)(lVar3 + 0x18) = local_80;\n                *(undefined8 *)(lVar3 + 0x20) = 0;\n              }\n            }\n            else if ((long)pcVar7 < local_80) {\n              pcVar7 = *(char **)(*(long *)(DAT_002478b8 + lVar1) + 8);\n              pcVar8 = \"You have mail in $_\";\n              if (pcVar7 != (char *)0x0) {\n                pcVar8 = pcVar7;\n              }\n              bind_variable(\"_\",pcVar5,0);\n              lVar3 = (*(undefined8 **)(DAT_002478b8 + lVar1))[4];\n              iVar4 = mailstat(**(undefined8 **)(DAT_002478b8 + lVar1),local_d8);\n              if ((iVar4 == 0) && (lVar3 < local_a8)) {\n                FUN_001805c0(uVar9 & 0xffffffff);\n                if ((*(long *)(*(long *)(DAT_002478b8 + lVar1) + 0x10) <\n                     *(long *)(*(long *)(DAT_002478b8 + lVar1) + 0x18)) && (pcVar7 == (char *)0x0))\n                {\n                  pcVar8 = \"You have new mail in $_\";\n                }\n              }\n              else {\n                FUN_001805c0(uVar9 & 0xffffffff);\n                if (*(long *)(*(long *)(DAT_002478b8 + lVar1) + 0x18) <=\n                    *(long *)(*(long *)(DAT_002478b8 + lVar1) + 0x10)) goto LAB_00180cea;\n              }\n              pcVar7 = (char *)expand_string_to_string(pcVar8,1);\n              if (pcVar7 == (char *)0x0) {\n                putc(10,stdout);\n              }\n              else {\n                puts(pcVar7);\n                sh_xfree(pcVar7,\"mailcheck.c\",0x1d7);\n              }\n            }\n          }\n          if (mail_warning != 0) {\n            lVar3 = (*(undefined8 **)(DAT_002478b8 + lVar1))[2];\n            iVar4 = mailstat(**(undefined8 **)(DAT_002478b8 + lVar1),local_d8);\n            if (((iVar4 == 0) && (0 < local_a8)) && (lVar3 < local_90)) {\n              FUN_001805c0(uVar9 & 0xffffffff);\n              __printf_chk(1,\"The mail in %s has been read\\n\",pcVar5);\n            }\n          }\n        }\nLAB_00180cea:\n        uVar9 = uVar9 + 1;\n      } while ((int)uVar9 < DAT_002478b0);\n      if (local_f0 == (char *)0x0) goto LAB_00180ef0;\n    }\n    bind_variable(\"_\",local_f0,0);\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      sh_xfree(local_f0,\"mailcheck.c\",0x1e7);\n      return;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "__errno_location": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = (int *)(*(code *)PTR___errno_location_00237878)();\n  return piVar1;\n}\n\n",
  "rl_reverse_search_history": "\nvoid rl_reverse_search_history(int param_1)\n\n{\n  FUN_001e0330(-param_1);\n  return;\n}\n\n",
  "strcasecmp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcasecmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcasecmp_00237850)();\n  return iVar1;\n}\n\n",
  "FUN_001517c0": "\nundefined8 FUN_001517c0(undefined8 param_1)\n\n{\n  FUN_001516e0();\n  return param_1;\n}\n\n",
  "enable_builtin": "\nulong enable_builtin(undefined8 param_1)\n\n{\n  char *__s;\n  long lVar1;\n  long lVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  int iVar7;\n  undefined8 *puVar8;\n  long lVar9;\n  size_t sVar10;\n  long *plVar11;\n  char *pcVar12;\n  code *pcVar13;\n  undefined *__dest;\n  undefined8 uVar14;\n  uint uVar15;\n  undefined8 *puVar16;\n  long lVar17;\n  undefined8 unaff_R12;\n  byte bVar18;\n  int iVar19;\n  ulong uVar20;\n  char *local_40;\n  \n  uVar15 = 0;\n  bVar6 = false;\n  bVar5 = false;\n  bVar3 = false;\n  bVar4 = false;\n  reset_internal_getopt();\nLAB_001a77ba:\n  iVar7 = internal_getopt(param_1,\"adnpsf:\");\n  if (iVar7 != -1) {\n    do {\n      if (iVar7 == -99) {\n        builtin_help();\n        return 0x102;\n      }\n      switch(iVar7) {\n      case 0x61:\n        goto switchD_001a77e2_caseD_61;\n      default:\n        builtin_usage();\n        return 0x102;\n      case 100:\n        uVar15 = uVar15 | 2;\n        goto LAB_001a77ba;\n      case 0x66:\n        uVar15 = uVar15 | 4;\n        unaff_R12 = list_optarg;\n        goto LAB_001a77ba;\n      case 0x6e:\n        bVar4 = true;\n        goto LAB_001a77ba;\n      case 0x70:\n        bVar3 = true;\n        goto LAB_001a77ba;\n      case 0x73:\n        bVar5 = true;\n        iVar7 = internal_getopt(param_1,\"adnpsf:\");\n        if (iVar7 == -1) goto LAB_001a7820;\n      }\n    } while( true );\n  }\nLAB_001a7820:\n  if ((restricted != 0) && (uVar15 != 0)) {\n    sh_restricted(0);\n    return 1;\n  }\n  if ((loptend == (undefined8 *)0x0) || (bVar3)) {\n    bVar18 = 3;\n    if (!bVar6) {\n      bVar18 = bVar4 + 1;\n    }\n    if (bVar5) {\n      bVar18 = bVar18 | 4;\n    }\n    lVar9 = 0;\n    if (num_shell_builtins < 1) goto LAB_001a79b0;\n    do {\n      puVar8 = (undefined8 *)(shell_builtins + lVar9 * 0x30);\n      if (((puVar8[1] != 0) && (uVar15 = *(uint *)(puVar8 + 2), (uVar15 & 2) == 0)) &&\n         (((bVar18 & 4) == 0 || ((uVar15 & 8) != 0)))) {\n        if (!bVar6 && bVar4) {\n          if (((bVar18 & 2) != 0) && ((uVar15 & 1) == 0)) {\nLAB_001a7998:\n            __printf_chk(1,\"enable -n %s\\n\",*puVar8);\n          }\n        }\n        else if ((uVar15 & 1) == 0) {\n          if ((bVar18 & 2) != 0) goto LAB_001a7998;\n        }\n        else {\n          __printf_chk(1,\"enable %s\\n\",*puVar8);\n        }\n      }\n      lVar9 = lVar9 + 1;\n      if (num_shell_builtins <= (int)lVar9) {\nLAB_001a79b0:\n        uVar20 = sh_chkwrite(0);\n        return uVar20;\n      }\n    } while( true );\n  }\n  uVar20 = (ulong)(uVar15 & 4);\n  if ((uVar15 & 4) != 0) {\n    bVar18 = bVar4 + 1U;\n    if (bVar5) {\n      bVar18 = bVar4 + 1U | 4;\n    }\n    iVar7 = FUN_001a7280(loptend,bVar18,unaff_R12);\n    set_itemlist_dirty(it_builtins);\n    return (ulong)(iVar7 != 0);\n  }\n  puVar8 = loptend;\n  if ((uVar15 & 2) != 0) {\n    do {\n      __s = *(char **)puVar8[1];\n      lVar9 = builtin_address_internal(__s,1);\n      iVar7 = num_shell_builtins;\n      if (lVar9 == 0) {\n        uVar20 = 1;\n        sh_notbuiltin(__s);\n      }\n      else if ((*(uint *)(lVar9 + 0x10) & 4) == 0) {\n        lVar1 = *(long *)(lVar9 + 0x28);\n        sVar10 = strlen(__s);\n        lVar17 = (long)(int)sVar10;\n        if (iVar7 < 1) {\n          pcVar12 = (char *)sh_xmalloc(lVar17 + 0x11,\"./enable.def\",0x234);\n          local_40 = strcpy(pcVar12,__s);\n          *(char (*) [16])(local_40 + lVar17) = s__builtin_unload_0020f930;\n          pcVar13 = (code *)dlsym(lVar1,local_40);\n          iVar19 = 0;\n          if (pcVar13 != (code *)0x0) goto LAB_001a7b61;\n          sh_xfree(local_40,\"./enable.def\",0x23b);\n        }\n        else {\n          plVar11 = (long *)(shell_builtins + 0x28);\n          iVar19 = 0;\n          do {\n            lVar2 = *plVar11;\n            plVar11 = plVar11 + 6;\n            iVar19 = iVar19 + (uint)(lVar1 == lVar2);\n          } while ((long *)(shell_builtins + (ulong)(iVar7 - 1) * 0x30 + 0x58) != plVar11);\n          pcVar12 = (char *)sh_xmalloc(lVar17 + 0x11,\"./enable.def\",0x234);\n          local_40 = strcpy(pcVar12,__s);\n          *(char (*) [16])(local_40 + lVar17) = s__builtin_unload_0020f930;\n          pcVar13 = (code *)dlsym(lVar1,local_40);\n          if (pcVar13 != (code *)0x0) {\nLAB_001a7b61:\n            (*pcVar13)(__s);\n          }\n          sh_xfree(local_40,\"./enable.def\",0x23b);\n          if ((iVar19 == 1) && (iVar7 = dlclose(lVar1), iVar7 != 0)) {\n            uVar14 = dlerror();\n            uVar20 = 1;\n            builtin_error(\"%s: cannot delete: %s\",__s,uVar14);\n            goto LAB_001a7c39;\n          }\n        }\n        iVar7 = (int)(lVar9 - (long)shell_builtins >> 4);\n        iVar19 = iVar7 * -0x55555555;\n        __dest = (undefined *)sh_xmalloc((long)(num_shell_builtins * 0x30),\"./enable.def\",499);\n        sVar10 = (long)iVar19 * 0x30;\n        if (iVar19 != 0) {\n          memcpy(__dest,shell_builtins,sVar10);\n        }\n        memcpy(__dest + sVar10,shell_builtins + sVar10 + 0x30,\n               (long)(num_shell_builtins + iVar7 * 0x55555555) * 0x30);\n        if ((undefined **)shell_builtins != &static_shell_builtins) {\n          sh_xfree(shell_builtins,\"./enable.def\",0x200);\n        }\n        num_shell_builtins = num_shell_builtins + -1;\n        shell_builtins = __dest;\n      }\n      else {\n        uVar20 = 1;\n        builtin_error(\"%s: not dynamically loaded\",__s);\n      }\nLAB_001a7c39:\n      puVar8 = (undefined8 *)*puVar8;\n      if (puVar8 == (undefined8 *)0x0) {\n        set_itemlist_dirty(it_builtins);\n        return uVar20;\n      }\n    } while( true );\n  }\n  do {\n    lVar9 = builtin_address_internal(*(undefined8 *)puVar8[1],1);\n    if (lVar9 == 0) {\n      puVar16 = (undefined8 *)*puVar8;\n      *puVar8 = 0;\n      iVar7 = FUN_001a7280(puVar8,(ulong)bVar5 << 2 | 9,*(undefined8 *)puVar8[1]);\n      *puVar8 = puVar16;\n      if (iVar7 == 0) {\n        set_itemlist_dirty(it_builtins);\n      }\n      else {\n        set_itemlist_dirty(it_builtins);\n        uVar20 = 1;\n        sh_notbuiltin(*(undefined8 *)puVar8[1]);\n      }\n    }\n    else {\n      uVar15 = *(uint *)(lVar9 + 0x10);\n      if (bVar4) {\n        uVar15 = uVar15 & 0xfffffffe;\n      }\n      else {\n        if ((restricted != 0) && ((uVar15 & 1) == 0)) {\n          uVar20 = 1;\n          sh_restricted(0);\n          puVar16 = (undefined8 *)*puVar8;\n          goto LAB_001a7a42;\n        }\n        uVar15 = uVar15 | 1;\n      }\n      *(uint *)(lVar9 + 0x10) = uVar15;\n      set_itemlist_dirty(it_enabled);\n      set_itemlist_dirty(it_disabled);\n      puVar16 = (undefined8 *)*puVar8;\n    }\nLAB_001a7a42:\n    puVar8 = puVar16;\n    if (puVar16 == (undefined8 *)0x0) {\n      return uVar20;\n    }\n  } while( true );\nswitchD_001a77e2_caseD_61:\n  bVar6 = true;\n  goto LAB_001a77ba;\n}\n\n",
  "localetrans": "\nchar * localetrans(char *param_1,int param_2,int *param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  \n  if ((param_1 == (char *)0x0) || (*param_1 == '\\0')) {\n    if (param_3 == (int *)0x0) {\n      return (char *)0x0;\n    }\n    *param_3 = 0;\n    return (char *)0x0;\n  }\n  pcVar3 = (char *)get_locale_var(\"LC_MESSAGES\");\n  if ((pcVar3 == (char *)0x0) || (cVar1 = *pcVar3, cVar1 == '\\0')) {\nLAB_0019ae60:\n    uVar4 = 0x1b1;\n  }\n  else {\n    if (cVar1 == 'C') {\n      if (pcVar3[1] == '\\0') goto LAB_0019ae60;\n    }\n    else if ((cVar1 == 'P') && (iVar2 = strcmp(pcVar3,\"POSIX\"), iVar2 == 0)) goto LAB_0019ae60;\n    uVar4 = 0x1c0;\n  }\n  pcVar3 = (char *)sh_xmalloc((long)(param_2 + 1),\"locale.c\",uVar4);\n  pcVar3 = strcpy(pcVar3,param_1);\n  if (param_3 != (int *)0x0) {\n    *param_3 = param_2;\n  }\n  return pcVar3;\n}\n\n",
  "assoc_flush": "\nvoid assoc_flush(undefined8 param_1)\n\n{\n  hash_flush(param_1,0);\n  return;\n}\n\n",
  "getrusage": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint getrusage(__rusage_who_t __who,rusage *__usage)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_getrusage_00237d68)();\n  return iVar1;\n}\n\n",
  "rl_bind_key_if_unbound_in_map": "\nundefined8 rl_bind_key_if_unbound_in_map(undefined param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 = rl_untranslate_keyseq(param_1);\n  if (lVar1 != 0) {\n    uVar2 = FUN_001dbd80(lVar1,param_2,param_3);\n    return uVar2;\n  }\n  return 0;\n}\n\n",
  "expand_arith_string": "\nchar * expand_arith_string(byte *param_1,uint param_2)\n\n{\n  byte bVar1;\n  mbstate_t mVar2;\n  size_t sVar3;\n  size_t sVar4;\n  ulong uVar5;\n  undefined *puVar6;\n  char *pcVar7;\n  long lVar8;\n  byte *__s;\n  undefined8 uVar9;\n  int iVar10;\n  byte bVar11;\n  long in_FS_OFFSET;\n  char *local_58;\n  undefined4 local_50;\n  mbstate_t local_48;\n  long local_40;\n  \n  sVar4 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.__count = 0;\n  local_48.__value = (_union_27)0x0;\n  sVar3 = __ctype_get_mb_cur_max();\n  if (1 < sVar3) {\n    sVar4 = strlen((char *)param_1);\n  }\n  bVar1 = *param_1;\n  if (bVar1 != 0) {\n    bVar11 = 0;\n    iVar10 = 0;\n    lVar8 = 0;\n    __s = param_1;\n    do {\n      mVar2 = local_48;\n      if ('>' < (char)bVar1) {\n        if ((bVar1 != 0x60) && (bVar1 != 0x7e)) {\n          if (bVar1 != 0x5c) goto LAB_0017434e;\nLAB_00174466:\n          bVar11 = bVar1;\n          if (1 < locale_mb_cur_max) goto LAB_0017435b;\n          goto LAB_00174477;\n        }\nLAB_0017438e:\n        local_50 = 0x101000;\n        sVar3 = strlen((char *)param_1);\n        pcVar7 = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",0xfc7);\n        local_58 = strcpy(pcVar7,(char *)param_1);\n        puVar6 = (undefined *)FUN_00177e80(&local_58,param_2,0,0,0);\n        if (puVar6 == &DAT_00247880) {\n          uVar9 = 2;\nLAB_001745a2:\n          local_58 = (char *)0x0;\n          last_command_exit_value = 1;\n                    /* WARNING: Subroutine does not return */\n          FUN_001667f0(uVar9);\n        }\n        if (puVar6 == &DAT_00247870) {\n          uVar9 = 1;\n          goto LAB_001745a2;\n        }\n        if (puVar6 == (undefined *)0x0) {\nLAB_001744f8:\n          pcVar7 = (char *)0x0;\n        }\n        else {\n          lVar8 = FUN_00171b00(puVar6);\n          dispose_words(puVar6);\n          if (lVar8 == 0) goto LAB_001744f8;\n          dequote_list(lVar8);\n          pcVar7 = (char *)string_list_internal(lVar8,&DAT_001fdb1c);\n          dispose_words(lVar8);\n        }\n        if (local_58 != (char *)0x0) {\n          sh_xfree(local_58,\"subst.c\",0xfdb);\n        }\n        goto LAB_001744cd;\n      }\n      if ('\\0' < (char)bVar1) {\n        uVar5 = 1L << (bVar1 & 0x3f);\n        if ((uVar5 & 0x5000001000000002) != 0) goto LAB_0017438e;\n        if ((uVar5 & 0x8400000000) != 0) goto LAB_00174466;\n      }\nLAB_0017434e:\n      if (locale_mb_cur_max < 2) {\nLAB_00174477:\n        iVar10 = iVar10 + 1;\n      }\n      else {\nLAB_0017435b:\n        if ((*(uint *)(is_basic_table + (ulong)(bVar1 >> 5) * 4) >> (bVar1 & 0x1f) & 1) == 0) {\n          if ((locale_utf8locale == 0) || (sVar3 = 1, (char)bVar1 < '\\0')) {\n            sVar3 = mbrtowc((wchar_t *)0x0,(char *)__s,sVar4 - lVar8,&local_48);\n            if (0xfffffffffffffffd < sVar3) {\n              iVar10 = iVar10 + 1;\n              local_48 = mVar2;\n              goto LAB_0017447b;\n            }\n            if (sVar3 == 0) goto LAB_00174477;\n          }\n        }\n        else {\n          sVar3 = 1;\n        }\n        iVar10 = iVar10 + (int)sVar3;\n      }\nLAB_0017447b:\n      lVar8 = (long)iVar10;\n      __s = param_1 + lVar8;\n      bVar1 = *__s;\n    } while (bVar1 != 0);\n    if ((bVar11 != 0) && (((param_2 & 0x100) != 0 || ((param_2 & 3) == 0)))) {\n      pcVar7 = (char *)string_quote_removal(param_1,param_2);\n      goto LAB_001744cd;\n    }\n  }\n  sVar3 = strlen((char *)param_1);\n  pcVar7 = (char *)sh_xmalloc(sVar3 + 1,\"subst.c\",0xfe2);\n  pcVar7 = strcpy(pcVar7,(char *)param_1);\nLAB_001744cd:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pcVar7;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "progcomp_flush": "\nvoid progcomp_flush(void)\n\n{\n  if (prog_completes != 0) {\n    hash_flush(prog_completes,FUN_001a1200);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001f7550": "\nbool FUN_001f7550(uint param_1)\n\n{\n  long lVar1;\n  byte *pbVar2;\n  int iVar3;\n  bool bVar4;\n  \n  bVar4 = false;\n  lVar1 = (&_rl_color_indicator)[(ulong)param_1 * 2];\n  if (lVar1 != 0) {\n    pbVar2 = (&PTR_DAT_002405e8)[(ulong)param_1 * 2];\n    if (lVar1 == 1) {\n      return *pbVar2 != 0x30;\n    }\n    bVar4 = true;\n    if (lVar1 == 2) {\n      iVar3 = *pbVar2 - 0x30;\n      if (iVar3 == 0) {\n        iVar3 = pbVar2[1] - 0x30;\n      }\n      return iVar3 != 0;\n    }\n  }\n  return bVar4;\n}\n\n",
  "zreset": "\nvoid zreset(void)\n\n{\n  DAT_00248ec0 = 0;\n  DAT_00248ec8 = 0;\n  return;\n}\n\n",
  "_rl_disable_tty_signals": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 _rl_disable_tty_signals(void)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  \n  if (DAT_0024a4a0 == 0) {\n    iVar1 = fileno(rl_instream);\n    iVar1 = FUN_001d5280(iVar1,&DAT_0024a500);\n    if (iVar1 < 0) {\n      return 0xffffffff;\n    }\n    _DAT_0024a4f0 = DAT_0024a530;\n    uRam000000000024a4c4 = uRam000000000024a504;\n    uRam000000000024a4c8 = uRam000000000024a508;\n    _DAT_0024a4d0 = _DAT_0024a510;\n    uRam000000000024a4d4 = uRam000000000024a514;\n    uRam000000000024a4d8 = uRam000000000024a518;\n    uRam000000000024a4dc = uRam000000000024a51c;\n    _DAT_0024a4cc = uRam000000000024a50c & 0xfffffffe;\n    _DAT_0024a4c0 = _DAT_0024a500 & 0xfffffbff;\n    _DAT_0024a4f8 = DAT_0024a538;\n    _DAT_0024a4e0 = _DAT_0024a520;\n    uRam000000000024a4e4 = uRam000000000024a524;\n    uRam000000000024a4e8 = uRam000000000024a528;\n    uRam000000000024a4ec = uRam000000000024a52c;\n    iVar1 = fileno(rl_instream);\n    while( true ) {\n      iVar2 = tcsetattr(iVar1,1,(termios *)&DAT_0024a4c0);\n      if (-1 < iVar2) {\n        DAT_0024a4a0 = 1;\n        return 0;\n      }\n      piVar3 = __errno_location();\n      if (*piVar3 != 4) break;\n      *piVar3 = 0;\n    }\n    iVar1 = fileno(rl_instream);\n    while (iVar2 = tcsetattr(iVar1,1,(termios *)&DAT_0024a500), iVar2 < 0) {\n      if (*piVar3 != 4) {\n        return 0xffffffff;\n      }\n      *piVar3 = 0;\n    }\n  }\n  return 0;\n}\n\n",
  "find_variable": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid find_variable(undefined8 param_1)\n\n{\n  long lVar1;\n  bool bVar2;\n  \n  bVar2 = false;\n  _DAT_002422f8 = 0;\n  if (expanding_redir == 0) {\n    bVar2 = (assigning_in_environment | executing_builtin) != 0;\n  }\n  lVar1 = FUN_00152c60(param_1,bVar2);\n  if ((lVar1 != 0) && ((*(byte *)(lVar1 + 0x29) & 8) != 0)) {\n    find_variable_nameref(lVar1);\n    return;\n  }\n  return;\n}\n\n",
  "free_trap_strings": "\nvoid free_trap_strings(void)\n\n{\n  ulong uVar1;\n  undefined4 *puVar2;\n  \n  uVar1 = 0;\n  do {\n    if ((&trap_list)[uVar1] != 1) {\n      FUN_001815b0(uVar1 & 0xffffffff,0);\n      (&DAT_00247e40)[uVar1] = (&DAT_00247e40)[uVar1] & 0xfffffffe;\n    }\n    uVar1 = uVar1 + 1;\n  } while (uVar1 != 0x41);\n  puVar2 = &DAT_00247e40;\n  uVar1 = 0x41;\n  do {\n    if ((*(byte *)(puVar2 + 0x41) & 1) == 0) {\n      FUN_001815b0(uVar1 & 0xffffffff,0);\n      puVar2[0x41] = puVar2[0x41] & 0xfffffffe;\n      (&trap_list)[uVar1] = 0;\n    }\n    uVar1 = uVar1 + 1;\n    puVar2 = puVar2 + 1;\n  } while (uVar1 != 0x44);\n  return;\n}\n\n",
  "sigfillset": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigfillset(sigset_t *__set)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigfillset_00237b68)();\n  return iVar1;\n}\n\n",
  "print_command": "\nvoid print_command(void)\n\n{\n  command_string_index = 0;\n  DAT_00241f28 = 0;\n  DAT_00241f18 = 0;\n  FUN_00146230();\n  __printf_chk(1,&DAT_002102da,the_printed_command);\n  return;\n}\n\n",
  "strlist_create": "\nvoid ** strlist_create(int param_1)\n\n{\n  void **ppvVar1;\n  void *__s;\n  \n  ppvVar1 = (void **)sh_xmalloc(0x10,\"stringlist.c\",0x2e);\n  if (param_1 == 0) {\n    *ppvVar1 = (void *)0x0;\n    *(undefined4 *)(ppvVar1 + 1) = 0;\n  }\n  else {\n    __s = (void *)strvec_create(param_1 + 1);\n    *(int *)(ppvVar1 + 1) = param_1;\n    *ppvVar1 = __s;\n    if (0 < param_1) {\n      memset(__s,0,(long)param_1 << 3);\n    }\n  }\n  *(undefined4 *)((long)ppvVar1 + 0xc) = 0;\n  return ppvVar1;\n}\n\n",
  "_rl_input_available": "\nvoid _rl_input_available(void)\n\n{\n  if (rl_input_available_hook != (code *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x001eb7d0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*rl_input_available_hook)();\n    return;\n  }\n  FUN_001eb6c0();\n  return;\n}\n\n",
  "_malloc_block_signals": "\nvoid _malloc_block_signals(sigset_t *param_1,sigset_t *param_2)\n\n{\n  sigfillset(param_1);\n  sigemptyset(param_2);\n  sigprocmask(0,param_1,param_2);\n  return;\n}\n\n",
  "_start": "\nvoid processEntry _start(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  (*(code *)PTR___libc_start_main_00237f00)(main,param_2,&stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
  "check_read_timeout": "\nundefined8 check_read_timeout(void)\n\n{\n  undefined8 in_RAX;\n  undefined8 uVar1;\n  int iVar2;\n  long *plVar3;\n  \n  if (read_timeout == (long *)0x0) {\n    return in_RAX;\n  }\n  plVar3 = read_timeout;\n  uVar1 = shtimer_chktimeout();\n  iVar2 = (int)plVar3;\n  if ((int)uVar1 == 0) {\n    return uVar1;\n  }\n  FUN_001af770();\n  if (((read_timeout != (long *)0x0) && (*(int *)(read_timeout + 2) == iVar2)) &&\n     ((*read_timeout != 0 || (read_timeout[1] != 0)))) {\n    if ((*(byte *)((long)read_timeout + 0x14) & 1) != 0) {\n      uVar1 = shtimer_alrm();\n      return uVar1;\n    }\n    uVar1 = shtimer_select();\n    return uVar1;\n  }\n  return 0;\n}\n\n",
  "change_flag": "\nuint change_flag(int param_1,int param_2)\n\n{\n  uint uVar1;\n  uint *puVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  \n  if (((restricted == 0) || (param_1 != 0x72)) || (param_2 != 0x2b)) {\n    puVar5 = shell_flags;\n    iVar4 = 0;\n    iVar3 = 0x61;\n    do {\n      puVar5 = puVar5 + 0x10;\n      if (param_1 == iVar3) {\n        puVar2 = *(uint **)(shell_flags + (long)iVar4 * 0x10 + 8);\n        if (puVar2 == (uint *)0x0) {\n          return 0xffffffff;\n        }\n        if ((param_2 - 0x2bU & 0xfffffffd) != 0) {\n          return 0xffffffff;\n        }\n        uVar1 = *puVar2;\n        *puVar2 = (uint)(param_2 == 0x2d);\n        switch(param_1) {\n        case 0x48:\n          history_expansion = histexp_flag;\n          if (param_2 == 0x2d) {\n            bash_initialize_history();\n            return uVar1;\n          }\n          return uVar1;\n        default:\n          return uVar1;\n        case 0x65:\n          if (builtin_ignoring_errexit == 0) {\n            exit_immediately_on_error = errexit_flag;\n            return uVar1;\n          }\n          return uVar1;\n        case 0x6d:\n          set_job_control((uint)(param_2 == 0x2d));\n          return uVar1;\n        case 0x6e:\n          if (interactive_shell != 0) {\n            read_but_dont_execute = 0;\n            return uVar1;\n          }\n          return uVar1;\n        case 0x70:\n          if (param_2 == 0x2b) {\n            disable_priv_mode();\n            return uVar1;\n          }\n          return uVar1;\n        case 0x72:\n          goto switchD_0015e2c8_caseD_72;\n        case 0x76:\n          echo_input_at_read = verbose_flag;\n          return uVar1;\n        }\n      }\n      iVar3 = (int)(char)*puVar5;\n      iVar4 = iVar4 + 1;\n    } while (*puVar5 != '\\0');\n  }\n  return 0xffffffff;\nswitchD_0015e2c8_caseD_72:\n  if (param_2 != 0x2d) {\n    return uVar1;\n  }\n  if (shell_initialized != 0) {\n    maybe_make_restricted(shell_name);\n    return uVar1;\n  }\n  return uVar1;\n}\n\n",
  "binary_test": "\nulong binary_test(byte *param_1,char *param_2,char *param_3,uint param_4)\n\n{\n  byte bVar1;\n  byte bVar2;\n  uint uVar3;\n  int iVar4;\n  ulong uVar5;\n  byte bVar6;\n  \n  bVar1 = *param_1;\n  bVar2 = param_1[1];\n  if (bVar1 == 0x3d) {\n    if (bVar2 == 0) {\nLAB_00186778:\n      if ((param_4 & 1) != 0) {\n        iVar4 = strmatch(param_3,param_2,\n                         (uint)(extended_glob != 0) << 5 | (uint)(match_ignore_case != 0) << 4);\n        return (ulong)(iVar4 == 0);\n      }\n      if (*param_2 != *param_3) {\n        return (ulong)(param_4 & 1);\n      }\n      iVar4 = strcmp(param_2,param_3);\n      return (ulong)(iVar4 == 0);\n    }\n    bVar6 = param_1[2];\n    if (bVar2 == 0x3d) {\n      if (bVar6 == 0) goto LAB_00186778;\n      goto LAB_001866a8;\n    }\n  }\n  else if ((bVar1 & 0xfd) == 0x3c) {\n    if (bVar2 == 0) {\n      if ((shell_compatibility_level < 0x29) || ((param_4 & 4) == 0)) {\n        uVar3 = strcmp(param_2,param_3);\n      }\n      else {\n        uVar3 = strcoll(param_2,param_3);\n      }\n      if (bVar1 != 0x3e) {\n        return (ulong)(uVar3 >> 0x1f);\n      }\n      return (ulong)(0 < (int)uVar3);\n    }\n    bVar6 = param_1[2];\n  }\n  else {\n    bVar6 = param_1[2];\n    if ((bVar1 == 0x21) && (bVar2 == 0x3d)) {\n      if (bVar6 == 0) {\n        if ((param_4 & 1) != 0) {\n          iVar4 = strmatch(param_3,param_2,\n                           (uint)(match_ignore_case != 0) << 4 | (uint)(extended_glob != 0) << 5);\n          return (ulong)(iVar4 != 0);\n        }\n        if (*param_2 != *param_3) {\n          return 1;\n        }\n        iVar4 = strcmp(param_2,param_3);\n        return (ulong)(iVar4 != 0);\n      }\nLAB_001866a8:\n      if (bVar6 == 0x74) {\n        return 0;\n      }\n      goto LAB_0018665e;\n    }\n  }\n  if (bVar6 == 0x74) {\n    if (bVar2 == 0x6e) {\n      uVar5 = FUN_00186290(param_2,param_3,0);\n      return uVar5;\n    }\n    if ((char)bVar2 < 'o') {\n      if (bVar2 == 0x67) {\n        uVar5 = FUN_00186460(param_2,param_3,3);\n        return uVar5;\n      }\n      if (bVar2 == 0x6c) {\n        uVar5 = FUN_00186460(param_2,param_3,2);\n        return uVar5;\n      }\n    }\n    else if (bVar2 == 0x6f) {\n      uVar5 = FUN_00186290(param_2,param_3,1);\n      return uVar5;\n    }\n    return 0;\n  }\n  if (bVar2 == 0x65) {\n    if (bVar6 == 0x66) {\n      uVar5 = FUN_00186290(param_2,param_3,2);\n      return uVar5;\n    }\n    if (bVar6 != 0x71) {\n      return 0;\n    }\n    uVar5 = FUN_00186460(param_2,param_3,0);\n    return uVar5;\n  }\nLAB_0018665e:\n  if (bVar6 == 0x65) {\n    if (bVar2 == 0x6c) {\n      uVar5 = FUN_00186460(param_2,param_3,4);\n      return uVar5;\n    }\n    if (bVar2 == 0x6e) {\n      uVar5 = FUN_00186460(param_2,param_3,1);\n      return uVar5;\n    }\n    if (bVar2 == 0x67) {\n      uVar5 = FUN_00186460(param_2,param_3,5);\n      return uVar5;\n    }\n  }\n  return 0;\n}\n\n",
  "rl_vi_search": "\nundefined8 rl_vi_search(undefined4 param_1,int param_2)\n\n{\n  if (param_2 == 0x2f) {\n    _rl_free_saved_history_line();\n    rl_noninc_reverse_search(param_1,0x2f);\n    return 0;\n  }\n  if (param_2 == 0x3f) {\n    _rl_free_saved_history_line();\n    rl_noninc_forward_search(param_1,0x3f);\n    return 0;\n  }\n  rl_ding();\n  return 0;\n}\n\n",
  "array_value": "\nvoid array_value(undefined8 param_1,undefined8 param_2,uint param_3)\n\n{\n  FUN_0018cd60(param_1,param_2,param_3 | 1);\n  return;\n}\n\n",
  "sh_memalign": "\nulong sh_memalign(long param_1,long param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  \n  uVar1 = FUN_001f85f0(param_1 + param_2,param_3,param_4);\n  uVar2 = uVar1;\n  if ((uVar1 != 0) && ((uVar1 & param_1 - 1U) != 0)) {\n    uVar2 = -param_1 & (param_1 - 1U) + uVar1;\n    *(undefined *)(uVar2 - 0x10) = 0xd6;\n    *(int *)(uVar2 - 0xc) = (int)uVar2 - (int)uVar1;\n  }\n  return uVar2;\n}\n\n",
  "FUN_0019e850": "\nundefined8 FUN_0019e850(uint *param_1)\n\n{\n  undefined4 uVar1;\n  long *plVar2;\n  long lVar3;\n  \n  plVar2 = (long *)strlist_create(0);\n  lVar3 = get_hostname_list();\n  *plVar2 = lVar3;\n  uVar1 = 0;\n  if (lVar3 != 0) {\n    uVar1 = strvec_len();\n  }\n  *(undefined4 *)((long)plVar2 + 0xc) = uVar1;\n  *(undefined4 *)(plVar2 + 1) = uVar1;\n  *(long **)(param_1 + 4) = plVar2;\n  *param_1 = *param_1 | 0x30;\n  return 0;\n}\n\n",
  "rl_delete_or_show_completions": "\nvoid rl_delete_or_show_completions(void)\n\n{\n  if ((rl_end != 0) && (rl_end == rl_point)) {\n    rl_possible_completions();\n    return;\n  }\n  rl_delete();\n  return;\n}\n\n",
  "remove_history_range": "\nvoid * remove_history_range(int param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  long lVar3;\n  void *pvVar4;\n  long lVar5;\n  long lVar6;\n  int iVar7;\n  \n  lVar3 = DAT_0024b6e8;\n  iVar2 = history_length;\n  if (((DAT_0024b6e8 != 0) &&\n      ((byte)((history_length == 0 || history_length <= param_2) |\n              (byte)((byte)((uint)param_1 >> 0x18) | (byte)((uint)param_2 >> 0x18)) >> 7 |\n             history_length <= param_1) == 0)) && (param_1 <= param_2)) {\n    iVar7 = param_2 - param_1;\n    iVar1 = iVar7 + 1;\n    pvVar4 = malloc((long)(iVar7 + 2) << 3);\n    if (pvVar4 != (void *)0x0) {\n      lVar5 = (long)param_1;\n      lVar6 = lVar5;\n      do {\n        *(undefined8 *)((long)pvVar4 + lVar6 * 8 + lVar5 * -8) = *(undefined8 *)(lVar3 + lVar6 * 8);\n        lVar6 = lVar6 + 1;\n      } while ((int)lVar6 <= param_2);\n      if (param_2 < param_1) {\n        iVar7 = 0;\n      }\n      *(undefined8 *)((long)pvVar4 + (long)(iVar7 + 1) * 8) = 0;\n      memmove((void *)(lVar3 + lVar5 * 8),(void *)(lVar3 + (long)(param_2 + 1) * 8),\n              (long)(iVar2 - param_2) << 3);\n      history_length = history_length - iVar1;\n      return pvVar4;\n    }\n  }\n  return (void *)0x0;\n}\n\n",
  "bg_builtin": "\nundefined4 bg_builtin(long param_1)\n\n{\n  char *__s1;\n  int iVar1;\n  long *plVar2;\n  undefined4 uVar3;\n  \n  if ((((param_1 != 0) && (*(char ***)(param_1 + 8) != (char **)0x0)) &&\n      (__s1 = **(char ***)(param_1 + 8), *__s1 == '-')) &&\n     (iVar1 = strcmp(__s1,\"--help\"), iVar1 == 0)) {\n    builtin_help();\n    return 0x102;\n  }\n  if (job_control == 0) {\n    sh_nojobs(0);\n    return 1;\n  }\n  iVar1 = no_options(param_1);\n  if (iVar1 == 0) {\n    uVar3 = 0;\n    plVar2 = loptend;\n    do {\n      iVar1 = FUN_001ab000(plVar2,0);\n      if (iVar1 == 1) {\n        uVar3 = 1;\n      }\n    } while ((plVar2 != (long *)0x0) && (plVar2 = (long *)*plVar2, plVar2 != (long *)0x0));\n    return uVar3;\n  }\n  return 0x102;\n}\n\n",
  "quote_string": "\nundefined2 * quote_string(byte *param_1)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  mbstate_t mVar3;\n  undefined2 *puVar4;\n  size_t sVar5;\n  size_t sVar6;\n  byte bVar7;\n  undefined2 *puVar8;\n  long in_FS_OFFSET;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*param_1 == 0) {\n    puVar4 = (undefined2 *)sh_xmalloc(2,\"subst.c\",0x12e9);\n    *puVar4 = 0x7f;\n  }\n  else {\n    local_48.__count = 0;\n    local_48.__value = (_union_27)0x0;\n    sVar5 = strlen((char *)param_1);\n    pbVar2 = param_1 + sVar5;\n    puVar4 = (undefined2 *)sh_xmalloc(sVar5 * 2 + 1,\"subst.c\",0x12f4);\n    puVar8 = puVar4;\n    if (param_1 < pbVar2) {\n      do {\n        while( true ) {\n          mVar3 = local_48;\n          *(undefined *)puVar8 = 1;\n          pbVar1 = param_1 + 1;\n          if (locale_mb_cur_max < 2) break;\n          bVar7 = *param_1;\n          if ((*(uint *)(is_basic_table + (ulong)(bVar7 >> 5) * 4) >> (bVar7 & 0x1f) & 1) == 0) {\n            if ((locale_utf8locale == 0) || (sVar5 = 1, (char)bVar7 < '\\0')) {\n              sVar6 = mbrtowc((wchar_t *)0x0,(char *)param_1,(long)pbVar2 - (long)param_1,&local_48)\n              ;\n              if (0xfffffffffffffffd < sVar6) {\n                *(byte *)((long)puVar8 + 1) = *param_1;\n                goto LAB_00170425;\n              }\n              bVar7 = *param_1;\n              sVar5 = 1;\n              if (sVar6 != 0) {\n                sVar5 = sVar6;\n              }\n            }\n          }\n          else {\n            sVar5 = 1;\n          }\n          for (sVar6 = 1; *(byte *)((long)puVar8 + sVar6) = bVar7, sVar6 != sVar5; sVar6 = sVar6 + 1\n              ) {\n            bVar7 = param_1[sVar6];\n          }\n          param_1 = param_1 + sVar6;\n          puVar8 = (undefined2 *)((long)puVar8 + sVar6 + 1);\n          if (pbVar2 <= param_1) goto LAB_00170490;\n        }\n        *(byte *)((long)puVar8 + 1) = *param_1;\nLAB_00170425:\n        puVar8 = puVar8 + 1;\n        param_1 = pbVar1;\n        local_48 = mVar3;\n      } while (pbVar1 < pbVar2);\n    }\nLAB_00170490:\n    *(undefined *)puVar8 = 0;\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar4;\n}\n\n",
  "pselect": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint pselect(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,timespec *__timeout,\n           __sigset_t *__sigmask)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_pselect_00237a00)();\n  return iVar1;\n}\n\n",
  "alarm": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuint alarm(uint __seconds)\n\n{\n  uint uVar1;\n  \n  uVar1 = (*(code *)PTR_alarm_00237a88)();\n  return uVar1;\n}\n\n",
  "FUN_00131c12": "\nvoid FUN_00131c12(void)\n\n{\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n",
  "with_input_from_buffered_stream": "\nvoid with_input_from_buffered_stream(undefined4 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  code *pcVar2;\n  \n  lVar1 = fd_to_buffered_stream();\n  pcVar2 = buffered_getchar;\n  if (lVar1 == 0) {\n    pcVar2 = return_EOF;\n  }\n  init_yy_io(pcVar2,buffered_ungetchar,4,param_2,param_1);\n  return;\n}\n\n",
  "FUN_001f7d30": "\nundefined4 FUN_001f7d30(long *param_1,char **param_2,undefined4 param_3,long *param_4)\n\n{\n  byte bVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char cVar4;\n  char cVar5;\n  long lVar6;\n  long lVar7;\n  long lVar8;\n  long lVar9;\n  long lVar10;\n  char *pcVar11;\n  bool bVar12;\n  \n  pcVar2 = *param_2;\n  lVar10 = *param_1;\n  lVar8 = 1;\n  cVar4 = *pcVar2;\n  lVar9 = 0;\n  lVar7 = lVar10 + 1;\n  cVar5 = cVar4 + -0x5c;\n  bVar12 = cVar4 == '\\\\';\n  pcVar3 = pcVar2;\n  lVar6 = lVar7;\n  if (bVar12) goto LAB_001f7d96;\nLAB_001f7d6a:\n  if (bVar12 || SBORROW1(cVar4,'\\\\') != cVar5 < '\\0') {\n    if (cVar4 == '=') {\n      if ((char)param_3 != '\\0') goto LAB_001f7dce;\n    }\n    else if ((cVar4 < '>') && ((cVar4 == '\\0' || (cVar4 == ':')))) {\n      param_3 = 1;\nLAB_001f7dce:\n      *param_1 = lVar10;\n      *param_2 = pcVar2;\n      *param_4 = lVar9;\n      return param_3;\n    }\n  }\n  else if (cVar4 == '^') {\n    bVar1 = pcVar2[1];\n    if ((byte)(bVar1 - 0x40) < 0x3f) {\n      pcVar2 = pcVar2 + 2;\n      lVar7 = lVar6 + 1;\n      lVar8 = lVar8 + 1;\n      *(byte *)(lVar6 + -1) = bVar1 & 0x1f;\n      goto LAB_001f7d86;\n    }\n    pcVar2 = pcVar2 + 1;\n    if (bVar1 == 0x3f) {\n      lVar7 = lVar6 + 1;\n      lVar8 = lVar8 + 1;\n      *(undefined *)(lVar6 + -1) = 0x7f;\n      goto LAB_001f7d86;\n    }\n    param_3 = 0;\n    goto LAB_001f7dce;\n  }\n  pcVar2 = pcVar2 + 1;\n  lVar7 = lVar6;\nLAB_001f7d7b:\n  *(char *)(lVar7 + -1) = cVar4;\n  lVar8 = lVar8 + 1;\n  lVar7 = lVar7 + 1;\nLAB_001f7d86:\n  do {\n    cVar4 = *pcVar2;\n    lVar10 = lVar7 + -1;\n    lVar9 = lVar8 + -1;\n    cVar5 = cVar4 + -0x5c;\n    bVar12 = cVar5 == '\\0';\n    pcVar3 = pcVar2;\n    lVar6 = lVar7;\n    if (!bVar12) goto LAB_001f7d6a;\nLAB_001f7d96:\n    cVar5 = pcVar3[1];\n    pcVar2 = pcVar3 + 2;\n    if (cVar5 == '\\0') {\n      param_3 = 0;\n      goto LAB_001f7dce;\n    }\n    cVar4 = cVar5 + -0x30;\n    switch(cVar4) {\n    case '\\0':\n    case '\\x01':\n    case '\\x02':\n    case '\\x03':\n    case '\\x04':\n    case '\\x05':\n    case '\\x06':\n    case '\\a':\n      cVar5 = *pcVar2;\n      if (7 < (byte)(cVar5 - 0x30U)) goto LAB_001f7d7b;\n      do {\n        pcVar2 = pcVar2 + 1;\n        cVar4 = cVar5 + -0x30 + cVar4 * '\\b';\n        cVar5 = *pcVar2;\n      } while ((byte)(cVar5 - 0x30U) < 8);\n      *(char *)(lVar7 + -1) = cVar4;\n      lVar8 = lVar8 + 1;\n      lVar7 = lVar7 + 1;\n      goto LAB_001f7d86;\n    case '\\x0f':\n      cVar5 = '\\x7f';\n      break;\n    case '(':\n    case 'H':\n      goto switchD_001f7dbb_caseD_28;\n    case '/':\n      cVar5 = ' ';\n      break;\n    case '1':\n      cVar5 = '\\a';\n      break;\n    case '2':\n      cVar5 = '\\b';\n      break;\n    case '5':\n      cVar5 = '\\x1b';\n      break;\n    case '6':\n      cVar5 = '\\f';\n      break;\n    case '>':\n      cVar5 = '\\n';\n      break;\n    case 'B':\n      cVar5 = '\\r';\n      break;\n    case 'D':\n      cVar5 = '\\t';\n      break;\n    case 'F':\n      cVar5 = '\\v';\n    }\n    *(char *)(lVar7 + -1) = cVar5;\n    lVar8 = lVar8 + 1;\n    lVar7 = lVar7 + 1;\n  } while( true );\nswitchD_001f7dbb_caseD_28:\n  cVar5 = pcVar3[2];\n  pcVar11 = pcVar3 + 3;\n  cVar4 = '\\0';\n  pcVar2 = pcVar3 + 2;\n  if ('F' < cVar5) goto LAB_001f7ef2;\n  do {\n    if (cVar5 < 'A') {\n      if (9 < (byte)(cVar5 - 0x30U)) goto LAB_001f7d7b;\n      cVar4 = cVar5 + -0x30 + cVar4 * '\\x10';\n      pcVar2 = pcVar11;\n    }\n    else {\n      cVar4 = cVar5 + -0x37 + cVar4 * '\\x10';\n      pcVar2 = pcVar11;\n    }\n    while( true ) {\n      cVar5 = *pcVar2;\n      pcVar11 = pcVar2 + 1;\n      if (cVar5 < 'G') break;\nLAB_001f7ef2:\n      if (5 < (byte)(cVar5 + 0x9fU)) goto LAB_001f7d7b;\n      cVar4 = cVar5 + -0x57 + cVar4 * '\\x10';\n      pcVar2 = pcVar11;\n    }\n  } while( true );\n}\n\n",
  "expand_compound_array_assignment": "\nlong ** expand_compound_array_assignment(long param_1,char *param_2)\n\n{\n  long *plVar1;\n  char **ppcVar2;\n  byte *__s;\n  long *plVar3;\n  bool bVar4;\n  mbstate_t mVar5;\n  int iVar6;\n  long **pplVar7;\n  long **pplVar8;\n  char *pcVar9;\n  long lVar10;\n  size_t sVar11;\n  undefined2 *puVar12;\n  size_t sVar13;\n  char *pcVar14;\n  byte bVar15;\n  ulong uVar16;\n  size_t sVar17;\n  byte *pbVar18;\n  byte *pbVar19;\n  undefined2 *puVar20;\n  undefined2 *puVar21;\n  undefined2 *puVar22;\n  long in_FS_OFFSET;\n  undefined4 local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar9 = param_2;\n  if (*param_2 == '(') {\n    local_4c = 1;\n    pcVar9 = (char *)extract_array_assignment_list(param_2,&local_4c);\n    if (pcVar9 == (char *)0x0) {\n      pplVar8 = (long **)0x0;\n      goto LAB_0018af44;\n    }\n  }\n  pplVar7 = (long **)parse_string_to_word_list(pcVar9,1,\"array assign\");\n  pplVar8 = pplVar7;\n  if (pplVar7 == (long **)0x0) {\n    if ((param_1 == 0) || ((*(byte *)(param_1 + 0x28) & 0x40) == 0)) {\n      pplVar8 = (long **)0x0;\n      goto LAB_0018af23;\n    }\n  }\n  else {\n    do {\n      while ((*(byte *)(pplVar8[1] + 1) & 2) != 0) {\n        pplVar8 = (long **)*pplVar8;\n        if (pplVar8 == (long **)0x0) goto LAB_0018ae82;\n      }\n      remove_quoted_escapes(*pplVar8[1]);\n      pplVar8 = (long **)*pplVar8;\n    } while (pplVar8 != (long **)0x0);\nLAB_0018ae82:\n    pplVar8 = pplVar7;\n    if ((param_1 == 0) || ((*(byte *)(param_1 + 0x28) & 0x40) == 0)) {\n      do {\n        ppcVar2 = (char **)pplVar8[1];\n        if ((ppcVar2 != (char **)0x0) &&\n           ((((pcVar14 = *ppcVar2, pcVar14 != (char *)0x0 && (*pcVar14 != '\\0')) &&\n             ((*(byte *)(ppcVar2 + 1) & 4) != 0)) &&\n            ((*pcVar14 == '[' && (lVar10 = mbschr(pcVar14,0x3d), lVar10 != 0)))))) {\n          __s = (byte *)*pplVar8[1];\n          local_48.__count = 0;\n          local_48.__value = (_union_27)0x0;\n          sVar11 = strlen((char *)__s);\n          puVar12 = (undefined2 *)sh_xmalloc(sVar11 * 2 + 1,\"arrayfunc.c\",0x396);\n          bVar15 = *__s;\n          puVar20 = puVar12;\n          if (bVar15 != 0) {\n            bVar4 = false;\n            pbVar18 = __s;\nLAB_0018b031:\n            do {\n              if (bVar15 == 0x3d) {\n                bVar15 = *pbVar18;\n                bVar4 = true;\n                puVar21 = (undefined2 *)((long)puVar20 + 1);\n              }\n              else {\n                pbVar19 = pbVar18;\n                if (bVar4) {\n                  bVar15 = *pbVar18;\n                  puVar21 = (undefined2 *)((long)puVar20 + 1);\n                }\n                else {\n                  do {\n                    puVar21 = (undefined2 *)((long)puVar20 + 1);\n                    if (bVar15 != 0x5b) {\n                      iVar6 = glob_char_p();\n                      pbVar18 = pbVar19;\n                      if ((iVar6 == 0) &&\n                         (bVar15 = *pbVar19, *(char *)((long)&ifs_cmap + (ulong)bVar15) == '\\0')) {\n                        bVar4 = false;\n                      }\n                      else {\n                        *(undefined *)puVar20 = 0x5c;\n                        bVar15 = *pbVar19;\n                        puVar22 = puVar20 + 1;\n                        puVar20 = puVar21;\n                        puVar21 = puVar22;\n                      }\n                      goto LAB_0018b04a;\n                    }\n                    uVar16 = (long)pbVar19 - (long)__s;\n                    iVar6 = skipsubscript(__s,uVar16 & 0xffffffff,0);\n                    pbVar18 = pbVar19 + (long)iVar6 + 1;\n                    pcVar14 = (char *)substring(pbVar19,uVar16 & 0xffffffff,iVar6);\n                    *(undefined *)puVar20 = 0x5c;\n                    strcpy((char *)puVar21,pcVar14);\n                    puVar21 = (undefined2 *)((long)puVar21 + (long)(iVar6 - (int)uVar16));\n                    *puVar21 = 0x5d5c;\n                    puVar20 = puVar21 + 1;\n                    sh_xfree(pcVar14,\"arrayfunc.c\",0x3a7);\n                    bVar15 = *pbVar18;\n                    if (bVar15 == 0) goto LAB_0018b0a0;\n                    pbVar19 = pbVar18;\n                  } while (bVar15 != 0x3d);\n                  bVar4 = true;\n                  puVar21 = (undefined2 *)((long)puVar21 + 3);\n                  bVar15 = 0x3d;\n                }\n              }\nLAB_0018b04a:\n              mVar5 = local_48;\n              if (locale_mb_cur_max < 2) {\n                *(byte *)puVar20 = bVar15;\nLAB_0018b02a:\n                bVar15 = pbVar18[1];\n                pbVar18 = pbVar18 + 1;\n                puVar20 = puVar21;\n                local_48 = mVar5;\n                if (bVar15 == 0) break;\n                goto LAB_0018b031;\n              }\n              if (((*(uint *)(is_basic_table + (ulong)(bVar15 >> 5) * 4) >> (bVar15 & 0x1f) & 1) ==\n                   0) && ((locale_utf8locale == 0 || ((char)bVar15 < '\\0')))) {\n                sVar13 = mbrtowc((wchar_t *)0x0,(char *)pbVar18,\n                                 (size_t)(__s + (sVar11 - (long)pbVar18)),&local_48);\n                if (0xfffffffffffffffd < sVar13) {\n                  *(byte *)puVar20 = *pbVar18;\n                  goto LAB_0018b02a;\n                }\n                bVar15 = *pbVar18;\n                sVar17 = 1;\n                if (sVar13 != 0) {\n                  sVar17 = sVar13;\n                }\n                sVar13 = 0;\n                while( true ) {\n                  *(byte *)((long)puVar20 + sVar13) = bVar15;\n                  sVar13 = sVar13 + 1;\n                  if (sVar17 == sVar13) break;\n                  bVar15 = pbVar18[sVar13];\n                }\n              }\n              else {\n                *(byte *)puVar20 = bVar15;\n                sVar13 = 1;\n              }\n              puVar20 = (undefined2 *)((long)puVar20 + sVar13);\n              bVar15 = pbVar18[sVar13];\n              pbVar18 = pbVar18 + sVar13;\n            } while (bVar15 != 0);\n          }\nLAB_0018b0a0:\n          *(undefined *)puVar20 = 0;\n          sh_xfree(*pplVar8[1],\"arrayfunc.c\",1099);\n          plVar3 = pplVar8[1];\n          plVar1 = plVar3 + 1;\n          *(uint *)plVar1 = *(uint *)plVar1 | 0x20;\n          *plVar3 = (long)puVar12;\n        }\n        pplVar8 = (long **)*pplVar8;\n      } while (pplVar8 != (long **)0x0);\n      pplVar8 = (long **)expand_words_no_vars(pplVar7);\nLAB_0018af23:\n      dispose_words(pplVar7);\n      if (pcVar9 != param_2) {\n        sh_xfree(pcVar9,\"arrayfunc.c\",0x26d);\n      }\n      goto LAB_0018af44;\n    }\n  }\n  pplVar8 = pplVar7;\n  if (pcVar9 != param_2) {\n    sh_xfree(pcVar9,\"arrayfunc.c\",0x25b);\n  }\nLAB_0018af44:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return pplVar8;\n}\n\n",
  "coproc_pidchk": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid coproc_pidchk(int param_1,undefined4 param_2)\n\n{\n  if (param_1 == DAT_00238428) {\n    _DAT_00238444 = 0;\n    DAT_0023843c = DAT_0023843c & 0xfffffffe | 2;\n    _DAT_00238440 = param_2;\n  }\n  return;\n}\n\n",
  "rl_clear_pending_input": "\nundefined8 rl_clear_pending_input(void)\n\n{\n  rl_readline_state = rl_readline_state & 0xfffffffffffdffff;\n  rl_pending_input = 0;\n  return 0;\n}\n\n",
  "run_debug_trap": "\nint run_debug_trap(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 uVar4;\n  long in_FS_OFFSET;\n  undefined auStack_38 [8];\n  long local_30;\n  \n  iVar2 = pipeline_pgrp;\n  iVar3 = 0;\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((DAT_00247f44 & 0x51) == 1) {\n    pipeline_pgrp = 0;\n    save_pipeline(1);\n    save_pgrp_pipe(auStack_38,1);\n    stop_making_children();\n    uVar1 = echo_input_at_read;\n    uVar4 = 0;\n    if (suppress_debug_trap_verbose == 0) {\n      uVar4 = echo_input_at_read;\n    }\n    echo_input_at_read = uVar4;\n    iVar3 = FUN_001811f0(0x41,\"debug trap\");\n    echo_input_at_read = uVar1;\n    pipeline_pgrp = iVar2;\n    restore_pipeline(1);\n    close_pgrp_pipe();\n    restore_pgrp_pipe(auStack_38);\n    if ((0 < pipeline_pgrp) && (((byte)subshell_environment & 0x11) == 0)) {\n      give_terminal_to(pipeline_pgrp,1);\n    }\n    notify_and_cleanup();\n    if ((debugging_mode != 0) && (iVar3 == 2)) {\n      if (return_catch_flag != 0) {\n        return_catch_value = 2;\n                    /* WARNING: Subroutine does not return */\n        __longjmp_chk(return_catch,1);\n      }\n      iVar3 = 2;\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "number_of_args": "\nundefined4 number_of_args(void)\n\n{\n  return posparam_count;\n}\n\n",
  "close_buffered_stream": "\nint close_buffered_stream(int *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (int *)0x0) {\n    iVar1 = *param_1;\n    if ((*(byte *)(param_1 + 8) & 0x20) != 0) {\n      *(undefined8 *)(param_1 + 2) = 0;\n    }\n    free_buffered_stream();\n    iVar1 = close(iVar1);\n    return iVar1;\n  }\n  return 0;\n}\n\n",
  "rl_menu_complete": "\nundefined8 rl_menu_complete(int param_1)\n\n{\n  char *pcVar1;\n  uint uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  size_t sVar5;\n  long lVar6;\n  char **ppcVar7;\n  char **ppcVar8;\n  code *pcVar9;\n  long in_FS_OFFSET;\n  undefined4 local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((rl_last_func == rl_backward_menu_complete) || (rl_last_func == rl_menu_complete)) &&\n     (DAT_0024a6b0 == 0)) {\nLAB_001d9dee:\n    if ((DAT_0024a6a0 == (char **)0x0) || (ppcVar8 = DAT_0024a6a0, DAT_0024a698 == 0)) {\nLAB_001d9e08:\n      rl_ding();\n      if (DAT_0024a6a0 != (char **)0x0) {\n        free(DAT_0024a6a0);\n      }\n      DAT_0024a6a0 = (char **)0x0;\n      DAT_0024a730 = 0;\n      goto LAB_001d9ecc;\n    }\nLAB_001d9d87:\n    DAT_0024a694 = param_1 + DAT_0024a694;\n    if (DAT_0024a694 < 0) {\n      do {\n        DAT_0024a694 = DAT_0024a694 + DAT_0024a698;\n        if (-1 < DAT_0024a694) break;\n        DAT_0024a694 = DAT_0024a694 + DAT_0024a698;\n      } while (DAT_0024a694 < 0);\n    }\n    else {\n      DAT_0024a694 = DAT_0024a694 % DAT_0024a698;\n    }\n    if ((DAT_0024a694 == 0) && (1 < DAT_0024a698)) {\n      rl_ding();\n      FUN_001d5f60(*DAT_0024a6a0,DAT_0024a684,2,&DAT_0024a688);\n    }\n    else {\n      FUN_001d5f60(ppcVar8[DAT_0024a694],DAT_0024a684,1,&DAT_0024a688);\n      uVar4 = FUN_001d5e50(DAT_0024a6a8,DAT_0024a6a0[DAT_0024a694]);\n      FUN_001d7d90(DAT_0024a6a0[DAT_0024a694],DAT_0024a68c,(int)DAT_0024a688,uVar4);\n    }\n    DAT_0024a730 = 1;\n  }\n  else {\n    if (DAT_0024a6a8 != (char *)0x0) {\n      free(DAT_0024a6a8);\n    }\n    ppcVar8 = DAT_0024a6a0;\n    if (DAT_0024a6a0 != (char **)0x0) {\n      pcVar1 = *DAT_0024a6a0;\n      ppcVar7 = DAT_0024a6a0;\n      while (pcVar1 != (char *)0x0) {\n        ppcVar7 = ppcVar7 + 1;\n        xfree();\n        pcVar1 = *ppcVar7;\n      }\n      xfree(ppcVar8);\n    }\n    DAT_0024a698 = 0;\n    rl_readline_state = rl_readline_state | 0x4000;\n    DAT_0024a694 = 0;\n    DAT_0024a6a0 = (char **)0x0;\n    DAT_0024a6b0 = 0;\n    rl_filename_completion_desired = 0;\n    rl_filename_quoting_desired = 1;\n    rl_completion_type = 0x25;\n    rl_completion_suppress_quote = 0;\n    rl_completion_suppress_append = 0;\n    rl_completion_append_character = 0x20;\n    rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;\n    DAT_0024a728 = 0;\n    pcVar9 = rl_menu_completion_entry_function;\n    if ((rl_menu_completion_entry_function == (code *)0x0) &&\n       (pcVar9 = rl_completion_entry_function, rl_completion_entry_function == (code *)0x0)) {\n      pcVar9 = rl_filename_completion_function;\n    }\n    DAT_0024a688 = '\\0';\n    DAT_0024a68c = 0;\n    DAT_0024a690 = rl_point;\n    local_34 = 0;\n    iVar3 = 0;\n    if (rl_point != 0) {\n      DAT_0024a688 = _rl_find_completion_word(&local_34,&DAT_0024a68c);\n      iVar3 = DAT_0024a690;\n    }\n    DAT_0024a684 = rl_point;\n    rl_point = iVar3;\n    DAT_0024a6a8 = (char *)rl_copy_text();\n    DAT_0024a6a0 = (char **)FUN_001d8df0(DAT_0024a6a8,DAT_0024a684,DAT_0024a690,pcVar9,local_34,\n                                         (int)DAT_0024a688);\n    if (DAT_0024a6a0 == (char **)0x0) {\n      DAT_0024a680 = 0;\n    }\n    else {\n      iVar3 = FUN_001d5e50(DAT_0024a6a8,*DAT_0024a6a0);\n      DAT_0024a680 = (uint)(iVar3 != 0);\n      if ((DAT_0024a6a0 != (char **)0x0) &&\n         (iVar3 = FUN_001d74a0(&DAT_0024a6a0,rl_filename_completion_desired), iVar3 != 0)) {\n        rl_readline_state = rl_readline_state & 0xffffffffffffbfff;\n        DAT_0024a698 = 0;\n        pcVar1 = *DAT_0024a6a0;\n        lVar6 = 1;\n        if (pcVar1 == (char *)0x0) {\n          rl_ding();\n          if (DAT_0024a6a0 != (char **)0x0) {\n            free(DAT_0024a6a0);\n          }\n          DAT_0024a6a0 = (char **)0x0;\n          DAT_0024a694 = 0;\n          DAT_0024a730 = 0;\n          goto LAB_001d9ecc;\n        }\n        do {\n          DAT_0024a698 = (int)lVar6;\n          ppcVar8 = DAT_0024a6a0 + lVar6;\n          lVar6 = lVar6 + 1;\n        } while (*ppcVar8 != (char *)0x0);\n        ppcVar8 = DAT_0024a6a0;\n        uVar2 = DAT_0024a730;\n        if (*pcVar1 != '\\0') {\n          FUN_001d5f60(pcVar1,DAT_0024a684,2 - (uint)(DAT_0024a6a0[1] == (char *)0x0),&DAT_0024a688)\n          ;\n          ppcVar8 = DAT_0024a6a0;\n          pcVar1 = *DAT_0024a6a0;\n          sVar5 = strlen(pcVar1);\n          DAT_0024a690 = (int)sVar5 + DAT_0024a684;\n          uVar2 = 1;\n          if (*DAT_0024a6a8 == *pcVar1) {\n            iVar3 = strcmp(DAT_0024a6a8,pcVar1);\n            uVar2 = (uint)(iVar3 != 0);\n          }\n        }\n        DAT_0024a730 = uVar2;\n        if (DAT_0024a698 < 2) {\n          FUN_001d7d90(*ppcVar8,DAT_0024a68c,(int)DAT_0024a688,DAT_0024a680);\n          DAT_0024a6b0 = 1;\n          goto LAB_001d9ecc;\n        }\n        if (_rl_complete_show_all == 0) {\n          if (_rl_menu_complete_prefix_first == 0) {\n            if (ppcVar8 == (char **)0x0) goto LAB_001d9e08;\n            goto LAB_001d9d87;\n          }\n        }\n        else {\n          FUN_001d8aa0(ppcVar8);\n          if ((0 < rl_completion_query_items) && (rl_completion_query_items <= DAT_0024a698)) {\n            rl_ding();\n            if (DAT_0024a6a0 != (char **)0x0) {\n              free(DAT_0024a6a0);\n            }\n            DAT_0024a6a0 = (char **)0x0;\n            DAT_0024a6b0 = 1;\n            goto LAB_001d9ecc;\n          }\n          if (_rl_menu_complete_prefix_first == 0) goto LAB_001d9dee;\n        }\n        rl_ding();\n        goto LAB_001d9ecc;\n      }\n    }\n    rl_ding();\n    if (DAT_0024a6a0 != (char **)0x0) {\n      free(DAT_0024a6a0);\n    }\n    DAT_0024a6a0 = (char **)0x0;\n    if (DAT_0024a6a8 != (char *)0x0) {\n      free(DAT_0024a6a8);\n    }\n    rl_readline_state = rl_readline_state & 0xffffffffffffbfff;\n    DAT_0024a6a8 = (char *)0x0;\n    DAT_0024a730 = 0;\n  }\nLAB_001d9ecc:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "list_running_jobs": "\nvoid list_running_jobs(undefined4 param_1)\n\n{\n  if (DAT_0023877c == 0) {\n    return;\n  }\n  if (DAT_00247660 == 0) {\n    FUN_001626a0();\n    if (DAT_0023877c == 0) {\n      return;\n    }\n  }\n  FUN_0015f750(param_1,1);\n  return;\n}\n\n",
  "ignore_glob_matches": "\nvoid ignore_glob_matches(char **param_1)\n\n{\n  long *plVar1;\n  int iVar2;\n  long *plVar3;\n  char *pcVar4;\n  long lVar5;\n  long lVar6;\n  char cVar7;\n  undefined8 uVar8;\n  char **ppcVar9;\n  int iVar10;\n  long *plVar11;\n  char *__s;\n  bool bVar12;\n  bool bVar13;\n  \n  if (DAT_00238b30 == 0) {\n    return;\n  }\n  if (*param_1 == (char *)0x0) {\n    iVar10 = 1;\n  }\n  else {\n    lVar6 = 1;\n    do {\n      iVar10 = (int)lVar6;\n      ppcVar9 = param_1 + lVar6;\n      lVar6 = lVar6 + 1;\n    } while (*ppcVar9 != (char *)0x0);\n    iVar10 = iVar10 + 1;\n  }\n  plVar3 = (long *)strvec_create(iVar10);\n  __s = *param_1;\n  if (__s == (char *)0x0) {\n    *plVar3 = 0;\n  }\n  else {\n    iVar10 = 0;\n    ppcVar9 = param_1;\n    do {\n      pcVar4 = strrchr(__s,0x2f);\n      if (pcVar4 == (char *)0x0) {\nLAB_0018519e:\n        cVar7 = *__s;\n        pcVar4 = __s;\n      }\n      else {\n        cVar7 = pcVar4[1];\n        pcVar4 = pcVar4 + 1;\n        if (cVar7 == '\\0') goto LAB_0018519e;\n      }\n      if ((cVar7 == '.') && ((pcVar4[1] == '\\0' || ((pcVar4[1] == '.' && (pcVar4[2] == '\\0')))))) {\nLAB_00185208:\n        sh_xfree(*ppcVar9,\"pathexp.c\",0x20c);\n      }\n      else {\n        bVar12 = extended_glob == 0;\n        bVar13 = glob_ignore_case != 0;\n        lVar6 = *DAT_00238b28;\n        plVar11 = DAT_00238b28;\n        while (lVar6 != 0) {\n          iVar2 = strmatch(lVar6,__s,(uint)bVar13 << 4 | (-(uint)bVar12 & 0xffffffe0) + 0x21);\n          if (iVar2 != 1) goto LAB_00185208;\n          plVar1 = plVar11 + 2;\n          plVar11 = plVar11 + 2;\n          lVar6 = *plVar1;\n        }\n        lVar6 = (long)iVar10;\n        iVar10 = iVar10 + 1;\n        plVar3[lVar6] = (long)*ppcVar9;\n      }\n      __s = ppcVar9[1];\n      ppcVar9 = ppcVar9 + 1;\n    } while (__s != (char *)0x0);\n    plVar3[iVar10] = 0;\n    if (iVar10 != 0) {\n      lVar6 = *plVar3;\n      lVar5 = 0;\n      if (lVar6 != 0) {\n        do {\n          *(long *)((long)param_1 + lVar5) = lVar6;\n          lVar5 = lVar5 + 8;\n          lVar6 = *(long *)((long)plVar3 + lVar5);\n        } while (lVar6 != 0);\n        param_1 = (char **)((long)param_1 + lVar5);\n      }\n      *param_1 = (char *)0x0;\n      uVar8 = 0x21d;\n      goto LAB_00185275;\n    }\n  }\n  *param_1 = (char *)0x0;\n  uVar8 = 0x214;\nLAB_00185275:\n  sh_xfree(plVar3,\"pathexp.c\",uVar8);\n  return;\n}\n\n",
  "set_lang": "\nundefined8 set_lang(undefined8 param_1,char *param_2)\n\n{\n  size_t sVar1;\n  char *__dest;\n  undefined8 uVar2;\n  \n  if (DAT_002489a8 != (char *)0x0) {\n    sh_xfree(DAT_002489a8,\"locale.c\",0x135);\n  }\n  if (param_2 == (char *)0x0) {\n    DAT_002489a8 = (char *)sh_xmalloc(1,\"locale.c\",0x13a);\n    *DAT_002489a8 = '\\0';\n  }\n  else {\n    sVar1 = strlen(param_2);\n    __dest = (char *)sh_xmalloc(sVar1 + 1,\"locale.c\",0x137);\n    DAT_002489a8 = strcpy(__dest,param_2);\n  }\n  if ((DAT_002489b0 != (char *)0x0) && (*DAT_002489b0 != '\\0')) {\n    return 0;\n  }\n  uVar2 = FUN_0019a780();\n  return uVar2;\n}\n\n",
  "rl_alphabetic": "\nuint rl_alphabetic(uint param_1)\n\n{\n  uint uVar1;\n  ushort **ppuVar2;\n  char *pcVar3;\n  \n  ppuVar2 = __ctype_b_loc();\n  uVar1 = 1;\n  if (((*(byte *)(*ppuVar2 + (param_1 & 0xff)) & 8) == 0) &&\n     (uVar1 = _rl_allow_pathname_alphabetic_chars, _rl_allow_pathname_alphabetic_chars != 0)) {\n    pcVar3 = strchr(\"/-_=~.#$\",param_1);\n    uVar1 = (uint)(pcVar3 != (char *)0x0);\n  }\n  return uVar1;\n}\n\n",
  "FUN_0015ccc0": "\nulong FUN_0015ccc0(void)\n\n{\n  int iVar1;\n  ulong __numer;\n  size_t sVar2;\n  char *pcVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  ulong __denom;\n  byte bVar6;\n  long lVar7;\n  imaxdiv_t iVar8;\n  \n  __numer = FUN_0015cb50();\n  iVar1 = DAT_00242440;\n  pcVar4 = DAT_00242438;\n  if ((DAT_00242448 != 0x3d) && (DAT_00242448 != 0xb)) {\n    return __numer;\n  }\n  if (DAT_00242444 != 5) {\n                    /* WARNING: Subroutine does not return */\n    FUN_0015bcf0(\"attempted assignment to non-variable\");\n  }\n  if (DAT_00242448 != 0xb) {\n    if (DAT_00242438 != (char *)0x0) {\n      sVar2 = strlen(DAT_00242438);\n      pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"expr.c\",0x217);\n      pcVar4 = strcpy(pcVar3,pcVar4);\n      lVar7 = DAT_002386d8;\n      FUN_0015d330();\n      __numer = FUN_0015ccc0();\n      goto switchD_0015cf3e_caseD_2a;\n    }\nLAB_0015d025:\n                    /* WARNING: Subroutine does not return */\n    FUN_0015bcf0(\"syntax error in variable assignment\");\n  }\n  if (DAT_00242438 == (char *)0x0) goto LAB_0015d025;\n  sVar2 = strlen(DAT_00242438);\n  pcVar3 = (char *)sh_xmalloc(sVar2 + 1,\"expr.c\",0x217);\n  pcVar4 = strcpy(pcVar3,pcVar4);\n  lVar7 = DAT_002386d8;\n  FUN_0015d330();\n  __denom = FUN_0015ccc0();\n  if ((iVar1 == 0x25 || iVar1 == 0x2f) && (__denom == 0)) {\n    if (DAT_00242428 == 0) {\n                    /* WARNING: Subroutine does not return */\n      FUN_0015bcf0(\"division by 0\");\n    }\n    if (0x2f < iVar1) {\n      if (iVar1 != 0x5e) {\n        if (iVar1 != 0x7c) goto switchD_0015cea5_caseD_b;\n        __denom = 1;\nLAB_0015cec9:\n        __numer = __numer | __denom;\n        goto switchD_0015cf3e_caseD_2a;\n      }\n      __denom = 1;\nLAB_0015ceb5:\n      __numer = __numer ^ __denom;\n      goto switchD_0015cf3e_caseD_2a;\n    }\n    if (iVar1 < 9) {\nswitchD_0015cea5_caseD_b:\n      sh_xfree(pcVar4,\"expr.c\",0x251);\n                    /* WARNING: Subroutine does not return */\n      FUN_0015bcf0(\"bug: bad expassign token\");\n    }\n    switch(iVar1) {\n    case 9:\n      bVar6 = 1;\n      break;\n    case 10:\n      bVar6 = 1;\nLAB_0015cfdd:\n      __numer = (long)__numer >> (bVar6 & 0x3f);\n      goto switchD_0015cf3e_caseD_2a;\n    default:\n      goto switchD_0015cea5_caseD_b;\n    case 0x25:\n    case 0x2f:\n      __denom = 1;\nLAB_0015cff4:\n      iVar8 = imaxdiv(__numer,__denom);\n      __numer = iVar8.quot;\n      if (iVar1 != 0x2f) {\n        __numer = iVar8.rem;\n      }\n      goto switchD_0015cf3e_caseD_2a;\n    case 0x26:\n      __denom = 1;\nswitchD_0015cea5_caseD_26:\n      __numer = __numer & __denom;\n    case 0x2a:\n      goto switchD_0015cf3e_caseD_2a;\n    case 0x2b:\n      __denom = 1;\nswitchD_0015cea5_caseD_2b:\n      __numer = __numer + __denom;\n      goto switchD_0015cf3e_caseD_2a;\n    case 0x2d:\n      __denom = 1;\nswitchD_0015cea5_caseD_2d:\n      __numer = __numer - __denom;\n      goto switchD_0015cf3e_caseD_2a;\n    }\n  }\n  else {\n    if (0x2f < iVar1) {\n      if (iVar1 != 0x5e) {\n        if (iVar1 != 0x7c) goto switchD_0015cea5_caseD_b;\n        goto LAB_0015cec9;\n      }\n      goto LAB_0015ceb5;\n    }\n    if (iVar1 < 9) goto switchD_0015cea5_caseD_b;\n    bVar6 = (byte)__denom;\n    switch(iVar1) {\n    case 9:\n      break;\n    case 10:\n      goto LAB_0015cfdd;\n    default:\n      goto switchD_0015cea5_caseD_b;\n    case 0x25:\n    case 0x2f:\n      if ((__numer == 0x8000000000000000) && (__denom == 0xffffffffffffffff)) {\n        __numer = (ulong)(iVar1 == 0x2f) << 0x3f;\n        goto switchD_0015cf3e_caseD_2a;\n      }\n      goto LAB_0015cff4;\n    case 0x26:\n      goto switchD_0015cea5_caseD_26;\n    case 0x2a:\n      __numer = __numer * __denom;\n      goto switchD_0015cf3e_caseD_2a;\n    case 0x2b:\n      goto switchD_0015cea5_caseD_2b;\n    case 0x2d:\n      goto switchD_0015cea5_caseD_2d;\n    }\n  }\n  __numer = __numer << (bVar6 & 0x3f);\nswitchD_0015cf3e_caseD_2a:\n  uVar5 = itos(__numer);\n  if (DAT_00242428 == 0) {\n    if (lVar7 == -1) {\n      if (*pcVar4 != '\\0') {\n        FUN_0015bd90(pcVar4,uVar5);\n      }\n    }\n    else {\n      FUN_0015bdf0(pcVar4,lVar7,uVar5);\n    }\n  }\n  if ((DAT_002386c0 != (char *)0x0) && (DAT_002386c0 == DAT_00242438)) {\n    DAT_002386c0 = (char *)0x0;\n    DAT_002386d0 = 0;\n    DAT_002386d8 = -1;\n    DAT_002386c8 = 0xffffffffffffffff;\n  }\n  sh_xfree(uVar5,\"expr.c\",0x265);\n  sh_xfree(pcVar4,\"expr.c\",0x266);\n  if (DAT_00242438 != (char *)0x0) {\n    sh_xfree(DAT_00242438,\"expr.c\",0x267);\n  }\n  DAT_00242438 = (char *)0x0;\n  return __numer;\n}\n\n",
  "FUN_00152360": "\nundefined8 FUN_00152360(undefined8 param_1)\n\n{\n  return param_1;\n}\n\n",
  "get_group_array": "\nlong get_group_array(int *param_1)\n\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  long lVar5;\n  \n  lVar5 = DAT_00240e60;\n  if (DAT_00240e60 != 0) {\n    if (param_1 == (int *)0x0) {\n      return DAT_00240e60;\n    }\n    *param_1 = DAT_00240e84;\n    return lVar5;\n  }\n  lVar5 = (long)DAT_00240e84;\n  if (DAT_00240e84 == 0) {\n    FUN_00141070();\n    lVar5 = (long)DAT_00240e84;\n    if (DAT_00240e84 < 1) goto LAB_00142b52;\n  }\n  else if (DAT_00240e84 < 1) {\nLAB_00142b52:\n    if (param_1 != (int *)0x0) {\n      *param_1 = 0;\n      return 0;\n    }\n    return 0;\n  }\n  lVar2 = sh_xmalloc(lVar5 << 2,\"general.c\",0x569);\n  iVar1 = DAT_00240e84;\n  lVar5 = DAT_00240e78;\n  DAT_00240e60 = lVar2;\n  if (0 < DAT_00240e84) {\n    lVar4 = (long)DAT_00240e84;\n    lVar3 = 0;\n    do {\n      *(undefined4 *)(lVar2 + lVar3 * 4) = *(undefined4 *)(lVar5 + lVar3 * 4);\n      lVar3 = lVar3 + 1;\n    } while (lVar4 != lVar3);\n  }\n  if (param_1 == (int *)0x0) {\n    return lVar2;\n  }\n  *param_1 = iVar1;\n  return lVar2;\n}\n\n",
  "eaccess": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint eaccess(char *__name,int __type)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_eaccess_002379c0)();\n  return iVar1;\n}\n\n",
  "strncpy": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strncpy(char *__dest,char *__src,size_t __n)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strncpy_00237880)();\n  return pcVar1;\n}\n\n",
  "assoc_to_assign": "\nundefined * assoc_to_assign(long *param_1,int param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  undefined *puVar4;\n  char *__s;\n  size_t sVar5;\n  char *__s_00;\n  undefined *puVar6;\n  int iVar7;\n  undefined8 *puVar8;\n  long lVar9;\n  int iVar10;\n  int iVar11;\n  long lVar12;\n  long local_50;\n  \n  if (param_1 == (long *)0x0) {\n    puVar6 = (undefined *)0x0;\n  }\n  else {\n    puVar6 = (undefined *)0x0;\n    if (*(int *)((long)param_1 + 0xc) != 0) {\n      puVar4 = (undefined *)sh_xmalloc(0x80,\"assoc.c\",0x1c6);\n      *puVar4 = 0x28;\n      if (*(int *)(param_1 + 1) < 1) {\n        lVar9 = 2;\n        lVar12 = 1;\n      }\n      else {\n        local_50 = 0;\n        iVar11 = 1;\n        iVar10 = 0x80;\n        do {\n          for (puVar8 = *(undefined8 **)(*param_1 + local_50 * 8); puVar8 != (undefined8 *)0x0;\n              puVar8 = (undefined8 *)*puVar8) {\nLAB_0018e4e8:\n            iVar3 = ansic_shouldquote(puVar8[1]);\n            if (iVar3 == 0) {\n              iVar3 = sh_contains_shell_metas();\n              if (iVar3 != 0) {\n                __s_00 = (char *)sh_double_quote(puVar8[1]);\n                goto LAB_0018e35c;\n              }\n              __s_00 = (char *)puVar8[1];\n              cVar1 = *__s_00;\n              if (((cVar1 == '@') || (cVar1 == '*')) && (__s_00[1] == '\\0')) {\n                __s_00 = (char *)sh_double_quote(__s_00);\n                goto LAB_0018e35c;\n              }\n              lVar9 = puVar8[2];\n              if (lVar9 != 0) goto LAB_0018e369;\n              iVar3 = 9;\n              __s = (char *)0x0;\n              if (cVar1 == '\\0') goto LAB_0018e3e0;\n              if (__s_00[1] == '\\0') goto LAB_0018e6f0;\n              iVar7 = 10;\n              if (__s_00[2] == '\\0') goto LAB_0018e6e5;\nLAB_0018e560:\n              sVar5 = strlen(__s_00);\n              iVar7 = (int)sVar5 + 8;\nLAB_0018e39d:\n              if (__s == (char *)0x0) {\nLAB_0018e6e5:\n                iVar3 = iVar7 + 1;\n                __s = (char *)0x0;\n              }\n              else {\n                iVar3 = iVar7 + 1;\n                if (((*__s != '\\0') && (iVar3 = iVar7 + 2, __s[1] != '\\0')) &&\n                   (iVar3 = iVar7 + 3, __s[2] != '\\0')) {\n                  sVar5 = strlen(__s);\n                  iVar3 = iVar7 + 1 + (int)sVar5;\n                }\n              }\n            }\n            else {\n              __s_00 = (char *)ansic_quote(puVar8[1],0,0);\nLAB_0018e35c:\n              lVar9 = puVar8[2];\n              if (lVar9 != 0) {\nLAB_0018e369:\n                iVar3 = ansic_shouldquote(lVar9);\n                if (iVar3 == 0) {\n                  __s = (char *)sh_double_quote(puVar8[2]);\n                }\n                else {\n                  __s = (char *)ansic_quote(puVar8[2],0,0);\n                }\n                iVar7 = 8;\n                if ((__s_00 != (char *)0x0) && (*__s_00 != '\\0')) {\n                  if (__s_00[1] == '\\0') {\n                    iVar7 = 9;\n                  }\n                  else {\nLAB_0018e663:\n                    iVar7 = 10;\n                    if (__s_00[2] != '\\0') goto LAB_0018e560;\n                  }\n                }\n                goto LAB_0018e39d;\n              }\n              iVar3 = 9;\n              __s = (char *)0x0;\n              if (__s_00 != (char *)0x0) {\n                if (*__s_00 != '\\0') {\n                  if (__s_00[1] != '\\0') goto LAB_0018e663;\nLAB_0018e6f0:\n                  __s = (char *)0x0;\n                  iVar3 = 10;\n                  goto LAB_0018e3e0;\n                }\n                iVar7 = 8;\n                goto LAB_0018e6e5;\n              }\n            }\nLAB_0018e3e0:\n            iVar3 = iVar3 + iVar11;\n            iVar7 = iVar10;\n            if (iVar10 <= iVar3) {\n              do {\n                iVar10 = iVar7 * 2;\n                iVar2 = iVar7 * -2;\n                iVar7 = iVar10;\n              } while (SBORROW4(iVar3,iVar10) == iVar3 + iVar2 < 0);\n              puVar4 = (undefined *)sh_xrealloc(puVar4,(long)iVar10,\"assoc.c\",0x1dc);\n            }\n            puVar4[iVar11] = 0x5b;\n            strcpy(puVar4 + (iVar11 + 1),__s_00);\n            iVar3 = 0;\n            if (((*__s_00 != '\\0') && (iVar3 = 1, __s_00[1] != '\\0')) &&\n               (iVar3 = 2, __s_00[2] != '\\0')) {\n              sVar5 = strlen(__s_00);\n              iVar3 = (int)sVar5;\n            }\n            iVar3 = iVar3 + iVar11 + 1;\n            puVar4[iVar3] = 0x5d;\n            puVar4[iVar3 + 1] = 0x3d;\n            if (__s == (char *)0x0) {\n              puVar4[iVar3 + 2] = ' ';\n              iVar11 = iVar3 + 3;\n              if (__s_00 == (char *)puVar8[1]) goto LAB_0018e4dc;\n              sh_xfree(__s_00,\"assoc.c\",0x1eb);\n              puVar8 = (undefined8 *)*puVar8;\n              if (puVar8 == (undefined8 *)0x0) break;\n              goto LAB_0018e4e8;\n            }\n            strcpy(puVar4 + (iVar3 + 2),__s);\n            iVar7 = 0;\n            if (((*__s != '\\0') && (iVar7 = 1, __s[1] != '\\0')) && (iVar7 = 2, __s[2] != '\\0')) {\n              sVar5 = strlen(__s);\n              iVar7 = (int)sVar5;\n            }\n            iVar7 = iVar7 + iVar3 + 2;\n            iVar11 = iVar7 + 1;\n            puVar4[iVar7] = 0x20;\n            if (__s_00 != (char *)puVar8[1]) {\n              sh_xfree(__s_00,\"assoc.c\",0x1eb);\n            }\n            sh_xfree(__s,\"assoc.c\",0x1ed);\nLAB_0018e4dc:\n          }\n          local_50 = local_50 + 1;\n        } while (*(int *)(param_1 + 1) != (int)local_50 && (int)local_50 <= *(int *)(param_1 + 1));\n        iVar3 = iVar11 + 1;\n        lVar12 = (long)iVar11;\n        lVar9 = (long)iVar3;\n        if (iVar10 <= iVar3) {\n          puVar4 = (undefined *)\n                   sh_xrealloc(puVar4,(long)(int)(iVar10 + 8 + (iVar3 - iVar10 & 0xfffffff8U)),\n                               \"assoc.c\",0x1f0);\n        }\n      }\n      puVar4[lVar12] = 0x29;\n      puVar4[lVar9] = 0;\n      puVar6 = puVar4;\n      if (param_2 != 0) {\n        puVar6 = (undefined *)sh_single_quote(puVar4);\n        sh_xfree(puVar4,\"assoc.c\",0x1f7);\n      }\n    }\n  }\n  return puVar6;\n}\n\n",
  "restore_sigmask": "\nvoid restore_sigmask(void)\n\n{\n  sigprocmask(2,(sigset_t *)top_level_mask,(sigset_t *)0x0);\n  return;\n}\n\n",
  "sh_xrealloc": "\nlong sh_xrealloc(long param_1,undefined8 param_2,undefined8 param_3,undefined4 param_4)\n\n{\n  void *pvVar1;\n  long lVar2;\n  void *pvVar3;\n  \n  if (DAT_00248a48 == 0) {\n    DAT_00248a50 = sbrk(0);\n    DAT_00248a48 = 1;\n  }\n  if (param_1 == 0) {\n    lVar2 = sh_malloc(param_2,param_3,param_4);\n  }\n  else {\n    lVar2 = sh_realloc(param_1,param_2,param_3,param_4);\n  }\n  if (lVar2 == 0) {\n    if (DAT_00248a48 == 0) {\n      DAT_00248a50 = sbrk(0);\n      DAT_00248a48 = 1;\n    }\n    pvVar1 = DAT_00248a50;\n    pvVar3 = sbrk(0);\n    fatal_error(\"%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)\",\"xrealloc\",param_3,\n                param_4,param_2,(long)pvVar3 - (long)pvVar1);\n    return 0;\n  }\n  return lVar2;\n}\n\n",
  "FUN_00131c00": "\nvoid FUN_00131c00(void)\n\n{\n  do {\n    invalidInstructionException();\n  } while( true );\n}\n\n",
  "FUN_00195050": "\nvoid FUN_00195050(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  uVar3 = rl_completion_entry_function;\n  uVar2 = rl_attempted_completion_function;\n  uVar1 = rl_ignore_some_completions_function;\n  rl_completion_entry_function = FUN_00192780;\n  rl_attempted_completion_function = 0;\n  rl_complete_internal(0x2a);\n  rl_completion_entry_function = (code *)uVar3;\n  rl_attempted_completion_function = uVar2;\n  rl_ignore_some_completions_function = uVar1;\n  return;\n}\n\n",
  "absolute_pathname": "\nbool absolute_pathname(char *param_1)\n\n{\n  char cVar1;\n  bool bVar2;\n  \n  if (param_1 == (char *)0x0) {\n    return false;\n  }\n  cVar1 = *param_1;\n  bVar2 = false;\n  if (((cVar1 != '\\0') && (bVar2 = true, cVar1 != '/')) && (bVar2 = false, cVar1 == '.')) {\n    cVar1 = param_1[1];\n    if ((cVar1 == '/') || (cVar1 == '\\0')) {\n      return true;\n    }\n    if (cVar1 == '.') {\n      return param_1[2] == '/' || param_1[2] == '\\0';\n    }\n  }\n  return bVar2;\n}\n\n",
  "getpid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__pid_t getpid(void)\n\n{\n  __pid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_getpid_00237950)();\n  return _Var1;\n}\n\n",
  "return_builtin": "\nundefined8 return_builtin(long param_1)\n\n{\n  char *__s1;\n  int iVar1;\n  \n  if ((((param_1 != 0) && (*(char ***)(param_1 + 8) != (char **)0x0)) &&\n      (__s1 = **(char ***)(param_1 + 8), *__s1 == '-')) &&\n     (iVar1 = strcmp(__s1,\"--help\"), iVar1 == 0)) {\n    builtin_help();\n    return 0x102;\n  }\n  return_catch_value = get_exitstat(param_1);\n  if (return_catch_flag == 0) {\n    builtin_error(\"can only `return\\' from a function or sourced script\");\n    return 0x102;\n  }\n                    /* WARNING: Subroutine does not return */\n  __longjmp_chk(return_catch,1);\n}\n\n",
  "unsetenv": "\nint unsetenv(char *__name)\n\n{\n  char *pcVar1;\n  int *piVar2;\n  \n  if (*__name != '\\0') {\n    pcVar1 = strchr(__name,0x3d);\n    if (pcVar1 == (char *)0x0) {\n      unbind_variable(__name);\n      return 0;\n    }\n  }\n  piVar2 = __errno_location();\n  *piVar2 = 0x16;\n  return -1;\n}\n\n",
  "FUN_00152b20": "\nvoid FUN_00152b20(void)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  bool bVar3;\n  \n  if (shell_variables == (undefined8 *)0x0) {\n    puVar1 = (undefined8 *)sh_xmalloc(0x28,\"variables.c\",0x146b);\n    *puVar1 = 0;\n    *(undefined4 *)((long)puVar1 + 0xc) = 0;\n    puVar1[3] = 0;\n    puVar1[2] = 0;\n    puVar1[4] = 0;\n    *(undefined4 *)(puVar1 + 1) = 0;\n    shell_variables = puVar1;\n    global_variables = puVar1;\n    uVar2 = hash_create(0x400);\n    bVar3 = shell_functions != 0;\n    puVar1[4] = uVar2;\n    if (bVar3) goto LAB_00152b39;\n  }\n  else if (shell_functions != 0) goto LAB_00152b39;\n  shell_functions = hash_create(0x200);\nLAB_00152b39:\n  if (shell_function_defs != 0) {\n    return;\n  }\n  shell_function_defs = hash_create(0x200);\n  return;\n}\n\n"
}