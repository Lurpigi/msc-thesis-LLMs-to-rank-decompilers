{
  "FUN_00118250": "\nvoid FUN_00118250(size_t param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(param_1,param_2);\n  if (pvVar1 != (void *)0x0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_0010ba10": "\nulong FUN_0010ba10(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010ba90;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010ba90:\n  uVar3 = FUN_001089b0();\n  return uVar3;\n}\n\n",
  "FUN_00108f70": "\nvoid FUN_00108f70(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  pcVar1 = param_2[0x10];\n  pcVar2 = param_1[0x10];\n  pcVar3 = param_2[0x11];\n  pcVar4 = param_1[0x11];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_1[0x11] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_1[0x10] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    strcmp(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00112940": "\nint FUN_00112940(byte *param_1,long param_2,uint param_3)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  int iVar3;\n  size_t sVar4;\n  long lVar5;\n  ushort **ppuVar6;\n  int iVar7;\n  long in_FS_OFFSET;\n  wchar_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  pbVar1 = param_1 + param_2;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  sVar4 = __ctype_get_mb_cur_max();\n  if (sVar4 < 2) {\n    iVar7 = 0;\n    if (param_1 < pbVar1) {\n      ppuVar6 = __ctype_b_loc();\n      iVar7 = 0;\n      do {\n        bVar2 = *param_1;\n        param_1 = param_1 + 1;\n        if (((*ppuVar6)[bVar2] & 0x4000) == 0) {\n          if ((param_3 & 2) != 0) goto LAB_00112af0;\n          if (((*ppuVar6)[bVar2] & 2) == 0) goto LAB_00112aca;\n        }\n        else {\nLAB_00112aca:\n          if (iVar7 == 0x7fffffff) break;\n          iVar7 = iVar7 + 1;\n        }\n      } while (pbVar1 != param_1);\n    }\n  }\n  else {\n    iVar7 = 0;\n    if (param_1 < pbVar1) {\n      do {\n        if ((int)(char)*param_1 - 0x20U < 0x5f) {\nLAB_00112998:\n          param_1 = param_1 + 1;\n          iVar7 = iVar7 + 1;\n        }\n        else {\n          local_48.__count = 0;\n          local_48.__value = (_union_27)0x0;\n          do {\n            lVar5 = FUN_001196e0(&local_4c,param_1,(long)pbVar1 - (long)param_1,&local_48);\n            if (lVar5 == -1) {\n              if ((param_3 & 1) != 0) goto LAB_00112af0;\n              goto LAB_00112998;\n            }\n            if (lVar5 == -2) {\n              if ((param_3 & 1) != 0) goto LAB_00112af0;\n              iVar7 = iVar7 + 1;\n              param_1 = pbVar1;\n              break;\n            }\n            if (lVar5 == 0) {\n              lVar5 = 1;\n              iVar3 = wcwidth(local_4c);\n              if (-1 < iVar3) goto LAB_001129d7;\nLAB_00112a38:\n              if ((param_3 & 2) != 0) goto LAB_00112af0;\n              iVar3 = iswcntrl(local_4c);\n              if (iVar3 == 0) {\n                if (iVar7 != 0x7fffffff) {\n                  iVar7 = iVar7 + 1;\n                  goto LAB_001129e6;\n                }\n                goto LAB_00112a60;\n              }\n            }\n            else {\n              if (lVar5 == -3) {\n                lVar5 = 0;\n              }\n              iVar3 = wcwidth(local_4c);\n              if (iVar3 < 0) goto LAB_00112a38;\nLAB_001129d7:\n              if (0x7fffffff - iVar7 < iVar3) {\nLAB_00112a60:\n                iVar7 = 0x7fffffff;\n                goto LAB_00112a66;\n              }\n              iVar7 = iVar7 + iVar3;\n            }\nLAB_001129e6:\n            param_1 = param_1 + lVar5;\n            iVar3 = mbsinit(&local_48);\n          } while (iVar3 == 0);\n        }\n      } while (param_1 < pbVar1);\n    }\n  }\nLAB_00112a66:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return iVar7;\nLAB_00112af0:\n  iVar7 = -1;\n  goto LAB_00112a66;\n}\n\n",
  "strncmp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strncmp_00125cd0)();\n  return iVar1;\n}\n\n",
  "FUN_00107360": "\nbyte * FUN_00107360(byte *param_1,char param_2)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  size_t sVar3;\n  byte *pbVar4;\n  \n  sVar3 = strlen((char *)param_1);\n  pbVar4 = (byte *)FUN_00117f50(3,sVar3 + 1);\n  bVar1 = *param_1;\n  pbVar2 = pbVar4;\n  do {\n    while( true ) {\n      if (bVar1 == 0) {\n        *pbVar2 = 0;\n        return pbVar4;\n      }\n      param_1 = param_1 + 1;\n      if ((bVar1 != 0x2f) || (param_2 == '\\0')) break;\n      *pbVar2 = 0x2f;\nLAB_001073af:\n      bVar1 = *param_1;\n      pbVar2 = pbVar2 + 1;\n    }\n    if ((&DAT_00126fe0)[bVar1] != '\\0') {\n      *pbVar2 = bVar1;\n      goto LAB_001073af;\n    }\n    __sprintf_chk(pbVar2,1,0xffffffffffffffff,\"%%%02x\",bVar1);\n    bVar1 = *param_1;\n    pbVar2 = pbVar2 + 3;\n  } while( true );\n}\n\n",
  "FUN_00110880": "\nvoid FUN_00110880(undefined8 *param_1)\n\n{\n  *(undefined *)(param_1 + 2) = 0;\n  *param_1 = 0x3f80000000000000;\n  param_1[1] = 0x3fb4fdf43f4ccccd;\n  return;\n}\n\n",
  "__memcpy_chk": "\nvoid __memcpy_chk(void)\n\n{\n  (*(code *)PTR___memcpy_chk_00125e50)();\n  return;\n}\n\n",
  "FUN_00108690": "\nulong FUN_00108690(undefined4 param_1)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  long lVar3;\n  \n  if (DAT_0012732d == '\\0') {\n    lVar3 = FUN_00111fc0();\n    if (lVar3 != 0) {\n      uVar1 = FUN_00112b20(lVar3,0);\n      uVar2 = (ulong)uVar1;\n      if ((int)uVar1 < 0) {\n        uVar2 = 0;\n      }\n      return uVar2;\n    }\n  }\n  uVar2 = __snprintf_chk(0,0,1,0xffffffffffffffff,&DAT_0011bd3e,param_1);\n  return uVar2;\n}\n\n",
  "FUN_001165b0": "\nuint FUN_001165b0(undefined *param_1,byte param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_00127520;\n  }\n  uVar1 = *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8);\n  uVar2 = uVar1 >> (param_2 & 0x1f);\n  *(uint *)(param_1 + (ulong)(param_2 >> 5) * 4 + 8) =\n       ((param_3 ^ uVar2) & 1) << (param_2 & 0x1f) ^ uVar1;\n  return uVar2 & 1;\n}\n\n",
  "clock_gettime": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint clock_gettime(clockid_t __clock_id,timespec *__tp)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_clock_gettime_00125d40)();\n  return iVar1;\n}\n\n",
  "FUN_001166d0": "\nundefined8 FUN_001166d0(undefined8 param_1,undefined8 param_2,long *param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  int *piVar2;\n  long lVar3;\n  undefined8 uVar4;\n  uint uVar5;\n  \n  if (param_4 == (undefined4 *)0x0) {\n    param_4 = (undefined4 *)&DAT_00127520;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  uVar5 = (uint)(param_3 == (long *)0x0) | param_4[1];\n  lVar3 = FUN_00114f20(0,0,param_1,param_2,*param_4,uVar5,param_4 + 2,*(undefined8 *)(param_4 + 10),\n                       *(undefined8 *)(param_4 + 0xc));\n  uVar4 = FUN_00117e50(lVar3 + 1);\n  FUN_00114f20(uVar4,lVar3 + 1,param_1,param_2,*param_4,uVar5,param_4 + 2,\n               *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  *piVar2 = iVar1;\n  if (param_3 != (long *)0x0) {\n    *param_3 = lVar3;\n  }\n  return uVar4;\n}\n\n",
  "_ITM_registerTMCloneTable": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_registerTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n",
  "FUN_0010b8a0": "\nulong FUN_0010b8a0(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010b920;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010b920:\n  uVar3 = FUN_00108b10();\n  return uVar3;\n}\n\n",
  "_obstack_begin_1": "\nvoid _obstack_begin_1(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                     undefined8 param_5,undefined8 param_6)\n\n{\n  *(byte *)(param_1 + 0x50) = *(byte *)(param_1 + 0x50) | 1;\n  *(undefined8 *)(param_1 + 0x38) = param_4;\n  *(undefined8 *)(param_1 + 0x40) = param_5;\n  *(undefined8 *)(param_1 + 0x48) = param_6;\n  FUN_00114a40();\n  return;\n}\n\n",
  "FUN_00119590": "\nvoid FUN_00119590(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if (param_1 != (FILE *)0x0) {\n    iVar1 = __freading();\n    if ((iVar1 != 0) && ((param_1->_flags & 0x100U) != 0)) {\n      FUN_001195e0(param_1,0,1);\n      fflush(param_1);\n      return;\n    }\n  }\n  fflush(param_1);\n  return;\n}\n\n",
  "__gmon_start__": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __gmon_start__(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n",
  "FUN_00118b40": "\nlong FUN_00118b40(ulong param_1,long param_2,int param_3,int param_4,int param_5,uint param_6,\n                 int param_7,int param_8,int param_9,int param_10)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  \n  iVar1 = ((int)((long)param_1 >> 2) + 0x1db) - (uint)((param_1 & 3) == 0);\n  iVar4 = ((int)((long)(int)param_6 >> 2) + 0x1db) - (uint)((param_6 & 3) == 0);\n  iVar3 = (iVar1 - (iVar1 >> 0x1f)) / 0x19 + (iVar1 >> 0x1f);\n  iVar2 = (iVar4 - (iVar4 >> 0x1f)) / 0x19 + (iVar4 >> 0x1f);\n  return ((long)param_5 +\n         (((long)param_4 +\n          (((long)param_3 +\n           ((long)(((iVar1 - iVar4) - (iVar3 - iVar2)) + ((iVar3 >> 2) - (iVar2 >> 2))) +\n           (((param_1 - (long)(int)param_6) * 0x16d + param_2) - (long)param_7)) * 0x18) -\n          (long)param_8) * 0x3c) - (long)param_9) * 0x3c) - (long)param_10;\n}\n\n",
  "FUN_00110770": "\nvoid FUN_00110770(ulong **param_1,long param_2,ulong param_3)\n\n{\n  ulong **ppuVar1;\n  ulong *puVar2;\n  ulong uVar3;\n  ulong **ppuVar4;\n  \n  ppuVar4 = (ulong **)*param_1;\n  uVar3 = 0;\n  if (param_1[1] <= ppuVar4) {\n    return;\n  }\n  do {\n    ppuVar1 = ppuVar4;\n    puVar2 = *ppuVar4;\n    while (puVar2 != (ulong *)0x0) {\n      if (param_3 <= uVar3) {\n        return;\n      }\n      uVar3 = uVar3 + 1;\n      *(ulong **)(param_2 + -8 + uVar3 * 8) = *ppuVar1;\n      ppuVar1 = (ulong **)ppuVar1[1];\n      puVar2 = (ulong *)ppuVar1;\n    }\n    ppuVar4 = ppuVar4 + 2;\n  } while (ppuVar4 <= param_1[1] && (ulong **)param_1[1] != ppuVar4);\n  return;\n}\n\n",
  "fileno": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fileno_00125e80)();\n  return iVar1;\n}\n\n",
  "sigemptyset": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigemptyset(sigset_t *__set)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigemptyset_00125e58)();\n  return iVar1;\n}\n\n",
  "_obstack_free": "\nvoid _obstack_free(long param_1,ulong *param_2)\n\n{\n  ulong *puVar1;\n  ulong *puVar2;\n  \n  puVar2 = *(ulong **)(param_1 + 8);\n  while( true ) {\n    if (puVar2 == (ulong *)0x0) {\n      if (param_2 == (ulong *)0x0) {\n        return;\n      }\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    if ((puVar2 < param_2) && (puVar1 = (ulong *)*puVar2, param_2 <= puVar1)) break;\n    puVar1 = (ulong *)puVar2[1];\n    if ((*(byte *)(param_1 + 0x50) & 1) == 0) {\n      (**(code **)(param_1 + 0x40))(puVar2);\n      *(byte *)(param_1 + 0x50) = *(byte *)(param_1 + 0x50) | 2;\n      puVar2 = puVar1;\n    }\n    else {\n      (**(code **)(param_1 + 0x40))(*(undefined8 *)(param_1 + 0x48));\n      *(byte *)(param_1 + 0x50) = *(byte *)(param_1 + 0x50) | 2;\n      puVar2 = puVar1;\n    }\n  }\n  *(ulong **)(param_1 + 0x18) = param_2;\n  *(ulong **)(param_1 + 0x10) = param_2;\n  *(ulong **)(param_1 + 0x20) = puVar1;\n  *(ulong **)(param_1 + 8) = puVar2;\n  return;\n}\n\n",
  "FUN_00108b10": "\nvoid FUN_00108b10(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int *piVar5;\n  \n  pcVar1 = param_1[0x10];\n  pcVar2 = param_2[0x10];\n  pcVar3 = param_1[0x11];\n  pcVar4 = param_2[0x11];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_2[0x11] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_2[0x10] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    pcVar1 = *param_2;\n    pcVar2 = *param_1;\n    piVar5 = __errno_location();\n    *piVar5 = 0;\n    strcoll(pcVar1,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00110d10": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 FUN_00110d10(long param_1,long param_2,long *param_3)\n\n{\n  char cVar1;\n  long lVar2;\n  ulong uVar3;\n  int *piVar4;\n  long *plVar5;\n  ulong uVar6;\n  undefined8 uVar7;\n  long in_FS_OFFSET;\n  float fVar8;\n  float fVar9;\n  long *local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 0) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  lVar2 = FUN_0010ffe0(param_1,param_2,&local_38,0);\n  if (lVar2 != 0) {\n    uVar7 = 0;\n    if (param_3 != (long *)0x0) {\n      *param_3 = lVar2;\n    }\n    goto LAB_00110d5e;\n  }\n  uVar6 = *(ulong *)(param_1 + 0x18);\n  if ((long)uVar6 < 0) {\n    uVar3 = *(ulong *)(param_1 + 0x10);\n    fVar9 = (float)(uVar6 >> 1 | (ulong)((uint)uVar6 & 1));\n    fVar9 = fVar9 + fVar9;\n    if ((long)uVar3 < 0) goto LAB_00110e2e;\nLAB_00110d9f:\n    fVar8 = (float)uVar3;\n  }\n  else {\n    fVar9 = (float)uVar6;\n    uVar3 = *(ulong *)(param_1 + 0x10);\n    if (-1 < (long)uVar3) goto LAB_00110d9f;\nLAB_00110e2e:\n    fVar8 = (float)(uVar3 >> 1 | (ulong)((uint)uVar3 & 1));\n    fVar8 = fVar8 + fVar8;\n  }\n  if (*(float *)(*(long *)(param_1 + 0x28) + 8) * fVar8 < fVar9) {\n    FUN_0010ff50(param_1);\n    lVar2 = *(long *)(param_1 + 0x28);\n    if (fVar9 <= fVar8 * *(float *)(lVar2 + 8)) goto LAB_00110dbe;\n    fVar8 = fVar8 * *(float *)(lVar2 + 0xc);\n    if (*(char *)(lVar2 + 0x10) == '\\0') {\n      fVar8 = fVar8 * *(float *)(lVar2 + 8);\n    }\n    if (_DAT_0011e694 <= fVar8) {\n      piVar4 = __errno_location();\n      uVar7 = 0xffffffff;\n      *piVar4 = 0xc;\n      goto LAB_00110d5e;\n    }\n    if (_DAT_0011e698 <= fVar8) {\n      uVar6 = (long)(fVar8 - _DAT_0011e698) ^ 0x8000000000000000;\n    }\n    else {\n      uVar6 = (ulong)fVar8;\n    }\n    cVar1 = FUN_00110b70(param_1,uVar6);\n    if (cVar1 != '\\0') {\n      lVar2 = FUN_0010ffe0(param_1,param_2,&local_38,0);\n      if (lVar2 != 0) {\n        uVar7 = FUN_00104cef();\n        return uVar7;\n      }\n      goto LAB_00110dbe;\n    }\nLAB_00110ed3:\n    uVar7 = 0xffffffff;\n  }\n  else {\nLAB_00110dbe:\n    if (*local_38 == 0) {\n      *local_38 = param_2;\n      uVar7 = 1;\n      *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + 1;\n      *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n      goto LAB_00110d5e;\n    }\n    plVar5 = *(long **)(param_1 + 0x48);\n    if (plVar5 == (long *)0x0) {\n      plVar5 = (long *)malloc(0x10);\n      if (plVar5 == (long *)0x0) goto LAB_00110ed3;\n    }\n    else {\n      *(long *)(param_1 + 0x48) = plVar5[1];\n    }\n    lVar2 = local_38[1];\n    *plVar5 = param_2;\n    uVar7 = 1;\n    plVar5[1] = lVar2;\n    local_38[1] = (long)plVar5;\n    *(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + 1;\n  }\nLAB_00110d5e:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar7;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "setlocale": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_setlocale_00125ed0)();\n  return pcVar1;\n}\n\n",
  "FUN_00110f50": "\nundefined8 FUN_00110f50(undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_00110d10(param_1,param_2,&local_18);\n  if (iVar1 == -1) {\n    param_2 = 0;\n  }\n  else if (iVar1 == 0) {\n    param_2 = local_18;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "mbsinit": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint mbsinit(mbstate_t *__ps)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_mbsinit_00125f68)();\n  return iVar1;\n}\n\n",
  "FUN_00118270": "\nvoid FUN_00118270(size_t param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(param_1,param_2);\n  if (pvVar1 != (void *)0x0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_00118390": "\nvoid FUN_00118390(void)\n\n{\n  error(DAT_001261f8,0,&DAT_0011e5db,\"memory exhausted\");\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_001089b0": "\nvoid FUN_001089b0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int *piVar5;\n  \n  pcVar1 = param_2[0x10];\n  pcVar2 = param_1[0x10];\n  pcVar3 = param_2[0x11];\n  pcVar4 = param_1[0x11];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_1[0x11] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_1[0x10] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    pcVar1 = *param_1;\n    pcVar2 = *param_2;\n    piVar5 = __errno_location();\n    *piVar5 = 0;\n    strcoll(pcVar1,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00116ec0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00116ec0(undefined4 param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5\n                 )\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long lStack_20;\n  long local_18;\n  long local_10;\n  \n  uStack_40 = uRam0000000000127528;\n  local_38 = _DAT_00127530;\n  uStack_30 = uRam0000000000127538;\n  local_28 = _DAT_00127540;\n  lStack_20 = uRam0000000000127548;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = DAT_00127550;\n  local_48 = CONCAT44((int)((ulong)_DAT_00127520 >> 0x20),10);\n  if ((param_2 != 0) && (param_3 != 0)) {\n    lStack_20 = param_2;\n    local_18 = param_3;\n    FUN_00116340(param_1,param_4,param_5,&local_48);\n    if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return;\n    }\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "__ctype_toupper_loc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__int32_t ** __ctype_toupper_loc(void)\n\n{\n  __int32_t **pp_Var1;\n  \n  pp_Var1 = (__int32_t **)(*(code *)PTR___ctype_toupper_loc_00125c90)();\n  return pp_Var1;\n}\n\n",
  "FUN_001079e0": "\nulong FUN_001079e0(byte **param_1,byte *param_2,undefined8 param_3,int param_4,ulong *param_5,\n                  byte *param_6)\n\n{\n  bool bVar1;\n  byte *pbVar2;\n  byte bVar3;\n  uint uVar4;\n  int iVar5;\n  size_t sVar6;\n  size_t sVar7;\n  ulong uVar8;\n  byte *pbVar9;\n  ushort **ppuVar10;\n  long lVar11;\n  byte *pbVar12;\n  long lVar13;\n  ulong unaff_RBX;\n  byte *pbVar14;\n  byte *pbVar15;\n  long in_FS_OFFSET;\n  byte *local_80;\n  bool local_69;\n  wchar_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_80 = *param_1;\n  uVar4 = FUN_00116570(param_3);\n  if ((uVar4 < 3 & DAT_001272d8) == 0) {\n    bVar1 = false;\n    if (param_4 == 0) {\n      uVar8 = strlen((char *)param_2);\n      local_69 = false;\n      local_80 = param_2;\n    }\n    else {\nLAB_00107a42:\n      sVar6 = FUN_00116650(local_80,0x2000,param_2,0xffffffffffffffff,param_3);\n      if (0x1fff < sVar6) {\n        local_80 = (byte *)FUN_00117e10(sVar6 + 1);\n        FUN_00116650(local_80,sVar6 + 1,param_2,0xffffffffffffffff,param_3);\n      }\n      local_69 = true;\n      if (*param_2 == *local_80) {\n        sVar7 = strlen((char *)param_2);\n        local_69 = sVar6 != sVar7;\n      }\n      uVar8 = sVar6;\n      if (bVar1) goto LAB_00107b89;\n    }\n    if (param_5 == (ulong *)0x0) {\n      if (DAT_001273a8 == 0) {\n        *param_6 = 0;\n        goto LAB_00107c0e;\n      }\nLAB_00107be9:\n      bVar3 = (local_69 ^ 1U) & DAT_001273a9;\n      goto LAB_00107bf7;\n    }\n    sVar6 = __ctype_get_mb_cur_max();\n    if (sVar6 < 2) {\n      if (local_80 < local_80 + uVar8) {\n        ppuVar10 = __ctype_b_loc();\n        unaff_RBX = 0;\n        pbVar9 = local_80;\n        do {\n          unaff_RBX = (unaff_RBX + 1) - (ulong)(((*ppuVar10)[*pbVar9] & 0x4000) == 0);\n          pbVar9 = pbVar9 + 1;\n        } while (local_80 + uVar8 != pbVar9);\n      }\n      else {\n        unaff_RBX = 0;\n      }\n    }\n    else {\n      iVar5 = FUN_00112940(local_80,uVar8,0);\n      unaff_RBX = (ulong)iVar5;\n    }\n    if (DAT_001273a8 != 0) goto LAB_00107be9;\n    *param_6 = 0;\n  }\n  else {\n    if (param_4 != 0) {\n      bVar1 = true;\n      goto LAB_00107a42;\n    }\n    sVar6 = strlen((char *)param_2);\n    if (0x1fff < sVar6) {\n      local_80 = (byte *)FUN_00117e10(sVar6 + 1);\n    }\n    memcpy(local_80,param_2,sVar6 + 1);\n    local_69 = false;\nLAB_00107b89:\n    sVar7 = __ctype_get_mb_cur_max();\n    pbVar9 = local_80 + sVar6;\n    if (sVar7 < 2) {\n      uVar8 = sVar6;\n      if (local_80 < pbVar9) {\n        ppuVar10 = __ctype_b_loc();\n        pbVar12 = local_80;\n        do {\n          if ((*(byte *)((long)*ppuVar10 + (ulong)*pbVar12 * 2 + 1) & 0x40) == 0) {\n            *pbVar12 = 0x3f;\n          }\n          pbVar12 = pbVar12 + 1;\n        } while (pbVar12 != pbVar9);\n      }\n    }\n    else if (local_80 < pbVar9) {\n      sVar6 = 0;\n      pbVar14 = local_80;\n      pbVar12 = local_80;\n      do {\n        bVar3 = *pbVar14;\n        if ((char)bVar3 < '`') {\n          if ('@' < (char)bVar3) goto LAB_00107d44;\n          if ((char)bVar3 < '$') {\n            if ('\\x1f' < (char)bVar3) goto LAB_00107d44;\n          }\n          else if ((byte)(bVar3 - 0x25) < 0x1b) goto LAB_00107d44;\nLAB_00107c85:\n          local_48.__count = 0;\n          local_48.__value = (_union_27)0x0;\n          pbVar15 = pbVar12;\n          do {\n            lVar11 = FUN_00112420(&local_4c,pbVar14,(long)pbVar9 - (long)pbVar14,&local_48);\n            pbVar12 = pbVar15 + 1;\n            if (lVar11 == -1) {\n              pbVar2 = pbVar14 + 1;\nLAB_00107da8:\n              pbVar14 = pbVar2;\n              sVar6 = sVar6 + 1;\n              *pbVar15 = 0x3f;\n              break;\n            }\n            pbVar2 = pbVar9;\n            if (lVar11 == -2) goto LAB_00107da8;\n            lVar13 = 1;\n            if (lVar11 != 0) {\n              lVar13 = lVar11;\n            }\n            iVar5 = wcwidth(local_4c);\n            if (iVar5 < 0) {\n              *pbVar15 = 0x3f;\n              sVar6 = sVar6 + 1;\n            }\n            else {\n              lVar11 = 0;\n              do {\n                pbVar15[lVar11] = pbVar14[lVar11];\n                lVar11 = lVar11 + 1;\n              } while (lVar13 != lVar11);\n              pbVar12 = pbVar15 + lVar13;\n              sVar6 = sVar6 + (long)iVar5;\n            }\n            pbVar14 = pbVar14 + lVar13;\n            iVar5 = mbsinit(&local_48);\n            pbVar15 = pbVar12;\n          } while (iVar5 == 0);\n        }\n        else {\n          if (0x1d < (byte)(bVar3 + 0x9f)) goto LAB_00107c85;\nLAB_00107d44:\n          *pbVar12 = bVar3;\n          pbVar14 = pbVar14 + 1;\n          sVar6 = sVar6 + 1;\n          pbVar12 = pbVar12 + 1;\n        }\n      } while (pbVar14 < pbVar9);\n      uVar8 = (long)pbVar12 - (long)local_80;\n    }\n    else {\n      sVar6 = 0;\n      uVar8 = 0;\n    }\n    unaff_RBX = sVar6;\n    bVar3 = DAT_001273a8;\n    if (DAT_001273a8 != 0) goto LAB_00107be9;\nLAB_00107bf7:\n    *param_6 = bVar3;\n    if (param_5 == (ulong *)0x0) goto LAB_00107c0e;\n  }\n  *param_5 = unaff_RBX;\nLAB_00107c0e:\n  *param_1 = local_80;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar8;\n}\n\n",
  "_DT_INIT": "\nvoid _DT_INIT(void)\n\n{\n  if (PTR___gmon_start___00125fd0 != (undefined *)0x0) {\n    (*(code *)PTR___gmon_start___00125fd0)();\n  }\n  return;\n}\n\n",
  "FUN_00108d50": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00108d50(void)\n\n{\n  uint uVar1;\n  long *plVar2;\n  undefined8 *puVar3;\n  int iVar4;\n  long *plVar5;\n  long *plVar6;\n  long lVar7;\n  ulong uVar8;\n  bool bVar9;\n  \n  uVar8 = DAT_001273b0;\n  if (_DAT_00127398 < (DAT_001273b0 >> 1) + DAT_001273b0) {\n    free(DAT_001273a0);\n    DAT_001273a0 = (long *)FUN_00117f50(uVar8,0x18);\n    _DAT_00127398 = DAT_001273b0 * 3;\n  }\n  uVar8 = DAT_001273b0;\n  if (DAT_001273b0 == 0) {\n    if (DAT_00127330 == 2) goto LAB_00108df9;\nLAB_00108de2:\n    if (((DAT_001272b0 != 0) && (DAT_00127338 - 2U < 2)) && (uVar8 != 0)) goto LAB_00108edb;\n  }\n  else {\n    plVar2 = DAT_001273a0 + DAT_001273b0;\n    plVar5 = DAT_001273a0;\n    lVar7 = DAT_001273c0;\n    do {\n      *plVar5 = lVar7;\n      plVar5 = plVar5 + 1;\n      lVar7 = lVar7 + 0xd0;\n    } while (plVar5 != plVar2);\n    if (DAT_00127330 != 2) goto LAB_00108de2;\nLAB_00108edb:\n    uVar8 = 0;\n    do {\n      puVar3 = (undefined8 *)DAT_001273a0[uVar8];\n      lVar7 = puVar3[0x19];\n      if (lVar7 == 0) {\n        lVar7 = FUN_00107e30(*puVar3,DAT_001272d0,*(undefined4 *)((long)puVar3 + 0xc4));\n      }\n      uVar8 = uVar8 + 1;\n      bVar9 = uVar8 < DAT_001273b0;\n      puVar3[0x19] = lVar7;\n    } while (bVar9);\n  }\n  if (DAT_00127330 == 6) {\n    return;\n  }\nLAB_00108df9:\n  iVar4 = _setjmp((__jmp_buf_tag *)&DAT_00126300);\n  uVar8 = DAT_001273b0;\n  plVar2 = DAT_001273a0;\n  uVar1 = DAT_00127330;\n  if (iVar4 == 0) {\n    iVar4 = 0;\n  }\n  else {\n    if (DAT_00127330 == 4) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"sort_type != sort_version\",\"src/ls.c\",0x1012,\"sort_files\");\n    }\n    if (DAT_001273b0 != 0) {\n      plVar5 = DAT_001273a0 + DAT_001273b0;\n      plVar6 = DAT_001273a0;\n      lVar7 = DAT_001273c0;\n      do {\n        *plVar6 = lVar7;\n        plVar6 = plVar6 + 1;\n        lVar7 = lVar7 + 0xd0;\n      } while (plVar5 != plVar6);\n    }\n    iVar4 = 1;\n  }\n  if (uVar1 == 5) {\n    uVar1 = DAT_00127334 + 5;\n  }\n  FUN_00112e10(plVar2,uVar8,\n               (&PTR_FUN_00124f80)\n               [(ulong)DAT_001272f4 +\n                ((ulong)DAT_0012732f + ((long)iVar4 + (ulong)uVar1 * 2) * 2) * 2]);\n  return;\n}\n\n",
  "FUN_0010b140": "\nint FUN_0010b140(char **param_1,char **param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar1 == 9 || iVar1 == 3) goto LAB_0010b1c0;\n    iVar1 = 1;\n  }\n  else {\n    if (iVar1 == 9 || iVar1 == 3) {\n      return -1;\n    }\n    iVar1 = 0;\n  }\n  iVar1 = iVar1 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar1 != 0) {\n    return iVar1;\n  }\nLAB_0010b1c0:\n  iVar1 = strcmp(*param_1,*param_2);\n  return iVar1;\n}\n\n",
  "__libc_start_main": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n",
  "fputc_unlocked": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputc_unlocked(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fputc_unlocked_00125e40)();\n  return iVar1;\n}\n\n",
  "FUN_00108470": "\nint FUN_00108470(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  pcVar1 = param_1[0xe];\n  pcVar2 = param_2[0xe];\n  pcVar3 = param_1[0xf];\n  pcVar4 = param_2[0xf];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_2[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_2[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 == 0) {\n    iVar5 = strcmp(*param_2,*param_1);\n    return iVar5;\n  }\n  return iVar5;\n}\n\n",
  "FUN_00108590": "\nvoid FUN_00108590(void)\n\n{\n  int __sig;\n  long in_FS_OFFSET;\n  sigset_t sStack_b8;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  while ((DAT_00127218 != 0 || (DAT_00127214 != 0))) {\n    if (DAT_00127310 != '\\0') {\n      FUN_00107940(&DAT_00126060);\n      FUN_00107940(&DAT_00126070);\n    }\n    fflush_unlocked(stdout);\n    sigprocmask(0,(sigset_t *)&DAT_00127220,&sStack_b8);\n    __sig = DAT_00127218;\n    if (DAT_00127214 == 0) {\n      signal(DAT_00127218,(__sighandler_t)0x0);\n    }\n    else {\n      DAT_00127214 = DAT_00127214 + -1;\n      __sig = 0x13;\n    }\n    raise(__sig);\n    sigprocmask(2,&sStack_b8,(sigset_t *)0x0);\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00116a90": "\nvoid FUN_00116a90(int param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long in_FS_OFFSET;\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 10) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  local_44 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  local_18 = 0;\n  local_48 = param_1;\n  FUN_00116340(0,param_2,param_3,&local_48);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001176c0": "\nvoid FUN_001176c0(long *param_1)\n\n{\n  long *plVar1;\n  \n  if (param_1 == (long *)0x1) {\n    return;\n  }\n  if (param_1 != (long *)0x0) {\n    do {\n      plVar1 = (long *)*param_1;\n      free(param_1);\n      param_1 = plVar1;\n    } while (plVar1 != (long *)0x0);\n  }\n  return;\n}\n\n",
  "FUN_00104ca0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00104ca0(void)\n\n{\n  (*_DAT_00125f88)();\n  return;\n}\n\n",
  "FUN_00109440": "\nvoid FUN_00109440(long param_1,undefined param_2)\n\n{\n  long *plVar1;\n  int iVar2;\n  char **ppcVar3;\n  char *pcVar4;\n  long *plVar5;\n  undefined8 *puVar6;\n  undefined8 uVar7;\n  char *pcVar8;\n  void *__ptr;\n  long *plVar9;\n  long lVar10;\n  bool bVar11;\n  \n  if ((param_1 != 0) && (DAT_001273c8 != 0)) {\n    puVar6 = (undefined8 *)FUN_00117e10(0x20);\n    uVar7 = FUN_00118350(param_1);\n    *puVar6 = 0;\n    puVar6[1] = uVar7;\n    *(undefined *)(puVar6 + 2) = 0;\n    puVar6[3] = DAT_00127380;\n    DAT_00127380 = puVar6;\n  }\n  lVar10 = DAT_001273b0 + -1;\n  if (DAT_001273b0 != 0) {\n    do {\n      while( true ) {\n        ppcVar3 = (char **)DAT_001273a0[lVar10];\n        if ((*(int *)(ppcVar3 + 0x15) == 3) || (*(int *)(ppcVar3 + 0x15) == 9)) break;\nLAB_001094b8:\n        bVar11 = lVar10 == 0;\n        lVar10 = lVar10 + -1;\n        if (bVar11) goto LAB_00109570;\n      }\n      pcVar4 = *ppcVar3;\n      if (param_1 == 0) {\nLAB_001095d0:\n        FUN_00107070(pcVar4,ppcVar3[1],param_2);\n      }\n      else {\n        pcVar8 = (char *)FUN_0010e9d0(pcVar4);\n        if ((*pcVar8 == '.') &&\n           ((pcVar8[(ulong)(pcVar8[1] == '.') + 1] == '\\0' ||\n            (pcVar8[(ulong)(pcVar8[1] == '.') + 1] == '/')))) goto LAB_001094b8;\n        if (*pcVar4 == '/') goto LAB_001095d0;\n        __ptr = (void *)FUN_0010f6b0(param_1,pcVar4,0);\n        FUN_00107070(__ptr,ppcVar3[1],param_2);\n        free(__ptr);\n      }\n      if (*(int *)(ppcVar3 + 0x15) != 9) goto LAB_001094b8;\n      free(*ppcVar3);\n      free(ppcVar3[1]);\n      free(ppcVar3[2]);\n      if (ppcVar3[0x16] == &DAT_0012602a) goto LAB_001094b8;\n      freecon();\n      bVar11 = lVar10 != 0;\n      lVar10 = lVar10 + -1;\n    } while (bVar11);\nLAB_00109570:\n    plVar5 = DAT_001273a0;\n    if (DAT_001273b0 != 0) {\n      plVar1 = DAT_001273a0 + DAT_001273b0;\n      DAT_001273b0 = 0;\n      plVar9 = DAT_001273a0;\n      do {\n        iVar2 = *(int *)(*plVar9 + 0xa8);\n        plVar5[DAT_001273b0] = *plVar9;\n        plVar9 = plVar9 + 1;\n        DAT_001273b0 = DAT_001273b0 + (ulong)(iVar2 != 9);\n      } while (plVar1 != plVar9);\n      return;\n    }\n  }\n  DAT_001273b0 = 0;\n  return;\n}\n\n",
  "getenv": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * getenv(char *__name)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_getenv_00125c98)();\n  return pcVar1;\n}\n\n",
  "FUN_0010ff20": "\nulong FUN_0010ff20(ulong param_1,ulong param_2)\n\n{\n  return (param_1 >> 3 | param_1 << 0x3d) % param_2;\n}\n\n",
  "fnmatch": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fnmatch(char *__pattern,char *__name,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fnmatch_00125dd0)();\n  return iVar1;\n}\n\n",
  "FUN_00119490": "\nulong FUN_00119490(uint *param_1)\n\n{\n  uint uVar1;\n  long lVar2;\n  ulong uVar3;\n  int *piVar4;\n  \n  lVar2 = __fpending();\n  uVar1 = *param_1;\n  uVar3 = FUN_00119500(param_1);\n  if ((uVar1 & 0x20) == 0) {\n    if ((int)uVar3 == 0) {\n      return uVar3;\n    }\n    if (lVar2 == 0) {\n      piVar4 = __errno_location();\n      return (ulong)-(uint)(*piVar4 != 9);\n    }\n  }\n  else if ((int)uVar3 == 0) {\n    piVar4 = __errno_location();\n    *piVar4 = 0;\n    return 0xffffffff;\n  }\n  return 0xffffffff;\n}\n\n",
  "FUN_0010afb0": "\nint FUN_0010afb0(char **param_1,char **param_2)\n\n{\n  char *__s1;\n  char *__s2;\n  int iVar1;\n  \n  iVar1 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar1 == 9 || iVar1 == 3) goto LAB_0010b030;\n    iVar1 = 1;\n  }\n  else {\n    if (iVar1 == 9 || iVar1 == 3) {\n      return -1;\n    }\n    iVar1 = 0;\n  }\n  iVar1 = iVar1 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar1 != 0) {\n    return iVar1;\n  }\nLAB_0010b030:\n  __s1 = *param_2;\n  __s2 = *param_1;\n  iVar1 = FUN_0010fce0(__s1,__s2);\n  if (iVar1 == 0) {\n    iVar1 = strcmp(__s1,__s2);\n    return iVar1;\n  }\n  return iVar1;\n}\n\n",
  "FUN_00117ea0": "\nvoid FUN_00117ea0(void *param_1,ulong param_2)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = realloc(param_1,param_2 | param_2 == 0);\n  if (pvVar1 != (void *)0x0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_00108360": "\nvoid FUN_00108360(char **param_1,char **param_2)\n\n{\n  char *__s1;\n  char *__s2;\n  int iVar1;\n  \n  __s1 = *param_2;\n  __s2 = *param_1;\n  iVar1 = FUN_0010fce0(__s1,__s2);\n  if (iVar1 == 0) {\n    strcmp(__s1,__s2);\n    return;\n  }\n  return;\n}\n\n",
  "memcpy": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memcpy_00125e68)();\n  return pvVar1;\n}\n\n",
  "FUN_00109330": "\nvoid FUN_00109330(char **param_1,char **param_2)\n\n{\n  char *__s;\n  char *__s_00;\n  int iVar1;\n  char *__s1;\n  char *__s2;\n  int *piVar2;\n  \n  __s = *param_2;\n  __s1 = strrchr(__s,0x2e);\n  __s_00 = *param_1;\n  __s2 = strrchr(__s_00,0x2e);\n  if (__s2 == (char *)0x0) {\n    __s2 = \"\";\n  }\n  if (__s1 == (char *)0x0) {\n    __s1 = \"\";\n  }\n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  iVar1 = strcoll(__s1,__s2);\n  if (iVar1 == 0) {\n    strcoll(__s,__s_00);\n    return;\n  }\n  return;\n}\n\n",
  "_obstack_allocated_p": "\nulong * _obstack_allocated_p(long param_1,ulong *param_2)\n\n{\n  ulong *puVar1;\n  \n  puVar1 = *(ulong **)(param_1 + 8);\n  if (puVar1 == (ulong *)0x0) {\n    return puVar1;\n  }\n  while ((param_2 <= puVar1 || ((ulong *)*puVar1 < param_2))) {\n    puVar1 = (ulong *)puVar1[1];\n    if (puVar1 == (ulong *)0x0) {\n      return (ulong *)0x0;\n    }\n  }\n  return (ulong *)0x1;\n}\n\n",
  "FUN_00118290": "\nvoid FUN_00118290(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = malloc(param_2);\n  if (__dest != (void *)0x0) {\n    memcpy(__dest,param_1,param_2);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "realloc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_realloc_00125ec8)();\n  return pvVar1;\n}\n\n",
  "FUN_00117fd0": "\nvoid FUN_00117fd0(long param_1,ulong *param_2)\n\n{\n  ulong uVar1;\n  long lVar2;\n  ulong uVar3;\n  ulong uVar4;\n  \n  uVar4 = *param_2;\n  if (param_1 == 0) {\n    if (uVar4 == 0) {\n      uVar4 = 0x80;\n    }\n    lVar2 = reallocarray(0,uVar4,1);\n    if (lVar2 != 0) {\n      *param_2 = uVar4;\n      return;\n    }\n  }\n  else {\n    uVar1 = (uVar4 >> 1) + 1;\n    uVar3 = uVar4 + uVar1;\n    if (!CARRY8(uVar4,uVar1)) {\n      lVar2 = reallocarray(param_1,uVar3,1);\n      if ((lVar2 != 0) || (uVar3 == 0)) {\n        *param_2 = uVar3;\n        return;\n      }\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_00110690": "\nlong FUN_00110690(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  \n  if (param_1[4] == (long *)0x0) {\n    return 0;\n  }\n  plVar2 = *param_1;\n  if (param_1[1] <= plVar2) {\n    lVar1 = FUN_00104cdf();\n    return lVar1;\n  }\n  do {\n    if (*plVar2 != 0) {\n      return *plVar2;\n    }\n    plVar2 = plVar2 + 2;\n  } while (plVar2 < param_1[1]);\n  lVar1 = FUN_00104cdf();\n  return lVar1;\n}\n\n",
  "FUN_0010f520": "\nvoid FUN_0010f520(uint param_1,undefined *param_2)\n\n{\n  byte bVar1;\n  undefined uVar2;\n  char cVar3;\n  uint uVar4;\n  \n  uVar2 = 0x2d;\n  uVar4 = param_1 & 0xf000;\n  if ((((uVar4 != 0x8000) && (uVar2 = 100, uVar4 != 0x4000)) && (uVar2 = 0x62, uVar4 != 0x6000)) &&\n     (((uVar2 = 99, uVar4 != 0x2000 && (uVar2 = 0x6c, uVar4 != 0xa000)) &&\n      ((uVar2 = 0x70, uVar4 != 0x1000 && (uVar2 = 0x73, uVar4 != 0xc000)))))) {\n    uVar2 = 0x3f;\n  }\n  *param_2 = uVar2;\n  param_2[1] = (-((param_1 & 0x100) == 0) & 0xbbU) + 0x72;\n  param_2[2] = (-((param_1 & 0x80) == 0) & 0xb6U) + 0x77;\n  bVar1 = -((param_1 & 0x40) == 0);\n  if ((param_1 & 0x800) == 0) {\n    cVar3 = (bVar1 & 0xb5) + 0x78;\n  }\n  else {\n    cVar3 = (bVar1 & 0xe0) + 0x73;\n  }\n  param_2[3] = cVar3;\n  param_2[4] = (-((param_1 & 0x20) == 0) & 0xbbU) + 0x72;\n  param_2[5] = (-((param_1 & 0x10) == 0) & 0xb6U) + 0x77;\n  bVar1 = -((param_1 & 8) == 0);\n  if ((param_1 & 0x400) == 0) {\n    cVar3 = (bVar1 & 0xb5) + 0x78;\n  }\n  else {\n    cVar3 = (bVar1 & 0xe0) + 0x73;\n  }\n  param_2[6] = cVar3;\n  param_2[7] = (-((param_1 & 4) == 0) & 0xbbU) + 0x72;\n  param_2[8] = (-((param_1 & 2) == 0) & 0xb6U) + 0x77;\n  if ((param_1 & 0x200) != 0) {\n    param_2[9] = (-((param_1 & 1) == 0) & 0xe0U) + 0x74;\n    *(undefined2 *)(param_2 + 10) = 0x20;\n    return;\n  }\n  param_2[9] = (-((param_1 & 1) == 0) & 0xb5U) + 0x78;\n  *(undefined2 *)(param_2 + 10) = 0x20;\n  return;\n}\n\n",
  "strlen": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strlen_00125d70)();\n  return sVar1;\n}\n\n",
  "FUN_00110440": "\nbool FUN_00110440(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  \n  plVar2 = *param_1;\n  plVar3 = (long *)0x0;\n  plVar4 = (long *)0x0;\n  do {\n    while( true ) {\n      if (param_1[1] <= plVar2) {\n        if (param_1[3] != plVar4) {\n          return false;\n        }\n        return param_1[4] == plVar3;\n      }\n      if (*plVar2 != 0) break;\nLAB_00110460:\n      plVar2 = plVar2 + 2;\n    }\n    lVar1 = plVar2[1];\n    plVar4 = (long *)((long)plVar4 + 1);\n    plVar3 = (long *)((long)plVar3 + 1);\n    if (lVar1 == 0) goto LAB_00110460;\n    do {\n      lVar1 = *(long *)(lVar1 + 8);\n      plVar3 = (long *)((long)plVar3 + 1);\n    } while (lVar1 != 0);\n    plVar2 = plVar2 + 2;\n  } while( true );\n}\n\n",
  "memcmp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_memcmp_00125e08)();\n  return iVar1;\n}\n\n",
  "FUN_0010f880": "\nint FUN_0010f880(long param_1,long param_2,long param_3,long param_4)\n\n{\n  byte bVar1;\n  int iVar2;\n  long lVar3;\n  long lVar4;\n  uint uVar5;\n  uint uVar6;\n  char cVar7;\n  int iVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  \n  lVar3 = 0;\n  lVar4 = 0;\nLAB_0010f88c:\n  if (param_2 <= lVar4) goto LAB_0010f9f8;\nLAB_0010f895:\n  bVar1 = *(byte *)(param_1 + lVar4);\n  if ((int)(char)bVar1 - 0x30U < 10) goto LAB_0010f93c;\n  uVar5 = 0;\n  if (bVar1 - 0x30 < 10) goto LAB_0010f8e0;\nLAB_0010f8bc:\n  uVar5 = (uint)bVar1;\n  if ((char)bVar1 < '[') {\n    if ('@' < (char)bVar1) goto LAB_0010f8e0;\n  }\n  else if ((byte)(bVar1 + 0x9f) < 0x1a) goto LAB_0010f8e0;\n  if (bVar1 == 0x7e) {\n    uVar5 = 0xfffffffe;\n  }\n  else {\n    uVar5 = bVar1 + 0x100;\n  }\nLAB_0010f8e0:\n  if (lVar3 == param_4) {\n    uVar10 = 0xffffffff;\nLAB_0010faf2:\n    return uVar5 - uVar10;\n  }\nLAB_0010f8e9:\n  bVar1 = *(byte *)(param_3 + lVar3);\n  uVar9 = (uint)bVar1;\n  uVar11 = (uint)bVar1;\n  uVar10 = 0;\n  uVar6 = uVar5;\n  if (bVar1 - 0x30 < 10) goto LAB_0010f922;\nLAB_0010f8fe:\n  cVar7 = (char)uVar9;\n  uVar10 = uVar11;\n  uVar5 = uVar6;\n  if (cVar7 < '[') {\n    if (cVar7 < 'A') {\nLAB_0010f911:\n      if (cVar7 == '~') {\n        uVar10 = 0xfffffffe;\n      }\n      else {\n        uVar10 = uVar11 + 0x100;\n      }\n    }\n  }\n  else if (0x19 < (byte)(cVar7 + 0x9fU)) goto LAB_0010f911;\nLAB_0010f922:\n  if (uVar10 == uVar5) {\n    lVar4 = lVar4 + 1;\n    lVar3 = lVar3 + 1;\nLAB_0010f933:\n    if (lVar4 < param_2) goto LAB_0010f895;\nLAB_0010f93c:\n    if (lVar3 < param_4) {\n      uVar9 = (uint)(char)*(byte *)(param_3 + lVar3);\n      if (9 < uVar9 - 0x30) goto LAB_0010fa10;\n    }\n    if (lVar4 < param_2) {\n      do {\n        if (*(char *)(param_1 + lVar4) != '0') {\n          if (param_4 <= lVar3) goto LAB_0010fab0;\n          goto LAB_0010f99d;\n        }\n        lVar4 = lVar4 + 1;\n      } while (param_2 != lVar4);\n    }\n    if (lVar3 < param_4) {\nLAB_0010f99d:\n      do {\n        if (*(char *)(param_3 + lVar3) != '0') {\n          iVar8 = 0;\n          iVar2 = 0;\n          if (param_2 <= lVar4) goto LAB_0010fb2f;\n          goto LAB_0010f9af;\n        }\n        lVar3 = lVar3 + 1;\n      } while (param_4 != lVar3);\nLAB_0010fab0:\n      if (lVar4 < param_2) {\n        iVar8 = 0;\n        goto LAB_0010fabc;\n      }\n      goto LAB_0010f9f8;\n    }\n    goto LAB_0010f88c;\n  }\n  goto LAB_0010faf2;\nLAB_0010fa10:\n  if (lVar4 != param_2) goto code_r0x0010fa19;\n  uVar11 = (uint)*(byte *)(param_3 + lVar3);\n  uVar6 = 0xffffffff;\n  uVar5 = 0xffffffff;\n  if (uVar11 - 0x30 < 10) {\n    uVar10 = 0;\n    goto LAB_0010faf2;\n  }\n  goto LAB_0010f8fe;\ncode_r0x0010fa19:\n  bVar1 = *(byte *)(param_1 + lVar4);\n  if (9 < bVar1 - 0x30) goto LAB_0010f8bc;\n  uVar5 = 0;\n  goto LAB_0010f8e9;\n  while( true ) {\n    if (9 < (int)*(char *)(param_3 + lVar3) - 0x30U) {\n      return 1;\n    }\n    if (iVar8 == 0) {\n      iVar8 = (int)*(char *)(param_1 + lVar4) - (int)*(char *)(param_3 + lVar3);\n    }\n    lVar4 = lVar4 + 1;\n    lVar3 = lVar3 + 1;\n    iVar2 = iVar8;\n    if (param_2 <= lVar4) break;\nLAB_0010f9af:\n    iVar8 = iVar2;\n    if (param_4 <= lVar3) goto LAB_0010fb2f;\n    if (9 < (int)*(char *)(param_1 + lVar4) - 0x30U) break;\n  }\n  goto LAB_0010f9cb;\nLAB_0010fb2f:\n  if (lVar4 < param_2) {\nLAB_0010fabc:\n    if ((int)*(char *)(param_1 + lVar4) - 0x30U < 10) {\n      return 1;\n    }\n  }\nLAB_0010f9cb:\n  if ((lVar3 < param_4) && ((int)*(char *)(param_3 + lVar3) - 0x30U < 10)) {\n    return -1;\n  }\n  if (iVar8 == 0) {\n    if (lVar4 < param_2) goto LAB_0010f895;\nLAB_0010f9f8:\n    if (lVar3 < param_4) goto LAB_0010f933;\n    iVar8 = 0;\n  }\n  return iVar8;\n}\n\n",
  "_exit": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid _exit(int __status)\n\n{\n  (*(code *)PTR__exit_00125cd8)();\n  return;\n}\n\n",
  "FUN_001186b0": "\nuint FUN_001186b0(byte *param_1,byte **param_2,uint param_3,uintmax_t *param_4,char *param_5)\n\n{\n  byte bVar1;\n  undefined auVar2 [16];\n  undefined auVar3 [16];\n  undefined auVar4 [16];\n  undefined auVar5 [16];\n  undefined auVar6 [16];\n  undefined auVar7 [16];\n  undefined auVar8 [16];\n  undefined auVar9 [16];\n  undefined auVar10 [16];\n  undefined auVar11 [16];\n  undefined auVar12 [16];\n  undefined auVar13 [16];\n  undefined auVar14 [16];\n  undefined auVar15 [16];\n  undefined auVar16 [16];\n  undefined auVar17 [16];\n  undefined auVar18 [16];\n  undefined auVar19 [16];\n  undefined auVar20 [16];\n  undefined auVar21 [16];\n  undefined auVar22 [16];\n  undefined auVar23 [16];\n  undefined auVar24 [16];\n  undefined auVar25 [16];\n  uint uVar26;\n  int *piVar27;\n  ushort **ppuVar28;\n  byte *pbVar29;\n  ulong uVar30;\n  char *pcVar31;\n  ulong uVar32;\n  byte bVar33;\n  uintmax_t uVar34;\n  int iVar35;\n  int iVar36;\n  uint uVar37;\n  long in_FS_OFFSET;\n  byte *local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (0x24 < param_3) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0 <= strtol_base && strtol_base <= 36\",\"lib/xstrtol.c\",0x56,\"xstrtoumax\");\n  }\n  if (param_2 == (byte **)0x0) {\n    param_2 = &local_48;\n  }\n  piVar27 = __errno_location();\n  *piVar27 = 0;\n  bVar33 = *param_1;\n  ppuVar28 = __ctype_b_loc();\n  pbVar29 = param_1;\n  while ((*(byte *)((long)*ppuVar28 + (ulong)bVar33 * 2 + 1) & 0x20) != 0) {\n    bVar33 = pbVar29[1];\n    pbVar29 = pbVar29 + 1;\n  }\n  if (bVar33 == 0x2d) {\nLAB_001187ab:\n    uVar37 = 4;\n    goto LAB_00118775;\n  }\n  uVar30 = strtoumax((char *)param_1,(char **)param_2,param_3);\n  pbVar29 = *param_2;\n  if (pbVar29 == param_1) {\n    if ((param_5 != (char *)0x0) && (bVar33 = *param_1, bVar33 != 0)) {\n      uVar37 = 0;\n      uVar34 = 1;\n      pcVar31 = strchr(param_5,(int)(char)bVar33);\n      if (pcVar31 != (char *)0x0) goto LAB_001187e9;\n    }\n    goto LAB_001187ab;\n  }\n  if (*piVar27 == 0) {\n    uVar37 = 0;\n  }\n  else {\n    uVar37 = 1;\n    if (*piVar27 != 0x22) goto LAB_001187ab;\n  }\n  if ((param_5 == (char *)0x0) || (bVar33 = *pbVar29, bVar33 == 0)) goto LAB_0011876d;\n  pcVar31 = strchr(param_5,(int)(char)bVar33);\n  uVar34 = uVar30;\n  if (pcVar31 == (char *)0x0) {\nswitchD_00118826_caseD_1:\n    uVar37 = uVar37 | 2;\n    *param_4 = uVar34;\n    goto LAB_00118775;\n  }\nLAB_001187e9:\n  uVar26 = bVar33 - 0x45;\n  iVar36 = 1;\n  uVar32 = 0x400;\n  if (((byte)uVar26 < 0x30) && ((0x81440030b945U >> ((ulong)uVar26 & 0x3f) & 1) != 0)) {\n    pcVar31 = strchr(param_5,0x30);\n    uVar32 = 0x400;\n    iVar36 = 1;\n    if (pcVar31 != (char *)0x0) {\n      bVar1 = pbVar29[1];\n      if (bVar1 == 0x44) {\n        iVar36 = 2;\n        uVar32 = 1000;\n      }\n      else if (bVar1 == 0x69) {\n        iVar36 = (pbVar29[2] == 0x42) + 1 + (uint)(pbVar29[2] == 0x42);\n      }\n      else {\n        iVar36 = (bVar1 == 0x42) + 1;\n        if (bVar1 == 0x42) {\n          uVar32 = 1000;\n        }\n      }\n    }\n  }\n  uVar30 = uVar34;\n  switch(bVar33 - 0x42 & 0xff) {\n  case 0:\n    uVar30 = uVar34 << 10;\n    if (uVar34 >> 0x36 != 0) {\n      uVar37 = 1;\n      uVar30 = 0xffffffffffffffff;\n    }\n    break;\n  default:\n    goto switchD_00118826_caseD_1;\n  case 3:\n    iVar35 = 6;\n    uVar26 = 0;\n    do {\n      auVar8._8_8_ = 0;\n      auVar8._0_8_ = uVar34;\n      auVar20._8_8_ = 0;\n      auVar20._0_8_ = uVar32;\n      uVar34 = SUB168(auVar8 * auVar20,0);\n      if (SUB168(auVar8 * auVar20,8) != 0) {\n        uVar26 = 1;\n        uVar34 = 0xffffffffffffffff;\n      }\n      iVar35 = iVar35 + -1;\n    } while (iVar35 != 0);\n    goto LAB_00118974;\n  case 5:\n  case 0x25:\n    auVar5._8_8_ = 0;\n    auVar5._0_8_ = uVar34;\n    auVar17._8_8_ = 0;\n    auVar17._0_8_ = uVar32;\n    if ((SUB168(auVar5 * auVar17,8) == 0) &&\n       (auVar6._8_8_ = 0, auVar6._0_8_ = SUB168(auVar5 * auVar17,0), auVar18._8_8_ = 0,\n       auVar18._0_8_ = uVar32, uVar30 = SUB168(auVar6 * auVar18,0), SUB168(auVar6 * auVar18,8) == 0)\n       ) goto LAB_00118907;\nLAB_00118939:\n    uVar37 = 1;\n    uVar30 = 0xffffffffffffffff;\n    break;\n  case 9:\n  case 0x29:\n    auVar2._8_8_ = 0;\n    auVar2._0_8_ = uVar34;\n    auVar14._8_8_ = 0;\n    auVar14._0_8_ = uVar32;\n    uVar30 = SUB168(auVar2 * auVar14,0);\n    if (SUB168(auVar2 * auVar14,8) != 0) goto LAB_00118939;\n    break;\n  case 0xb:\n  case 0x2b:\n    auVar3._8_8_ = 0;\n    auVar3._0_8_ = uVar34;\n    auVar15._8_8_ = 0;\n    auVar15._0_8_ = uVar32;\n    uVar30 = SUB168(auVar3 * auVar15,0);\n    if (SUB168(auVar3 * auVar15,8) != 0) goto LAB_00118939;\nLAB_00118907:\n    auVar4._8_8_ = 0;\n    auVar4._0_8_ = uVar30;\n    auVar16._8_8_ = 0;\n    auVar16._0_8_ = uVar32;\n    uVar30 = SUB168(auVar4 * auVar16,0);\n    if (SUB168(auVar4 * auVar16,8) != 0) {\n      uVar37 = 1;\n      uVar30 = 0xffffffffffffffff;\n    }\n    break;\n  case 0xe:\n    iVar35 = 5;\n    uVar26 = 0;\n    do {\n      auVar12._8_8_ = 0;\n      auVar12._0_8_ = uVar34;\n      auVar24._8_8_ = 0;\n      auVar24._0_8_ = uVar32;\n      uVar34 = SUB168(auVar12 * auVar24,0);\n      if (SUB168(auVar12 * auVar24,8) != 0) {\n        uVar26 = 1;\n        uVar34 = 0xffffffffffffffff;\n      }\n      iVar35 = iVar35 + -1;\n    } while (iVar35 != 0);\n    goto LAB_00118974;\n  case 0xf:\n    iVar35 = 10;\n    uVar26 = 0;\n    do {\n      auVar10._8_8_ = 0;\n      auVar10._0_8_ = uVar34;\n      auVar22._8_8_ = 0;\n      auVar22._0_8_ = uVar32;\n      uVar34 = SUB168(auVar10 * auVar22,0);\n      if (SUB168(auVar10 * auVar22,8) != 0) {\n        uVar26 = 1;\n        uVar34 = 0xffffffffffffffff;\n      }\n      iVar35 = iVar35 + -1;\n    } while (iVar35 != 0);\n    goto LAB_00118974;\n  case 0x10:\n    iVar35 = 9;\n    uVar26 = 0;\n    do {\n      auVar9._8_8_ = 0;\n      auVar9._0_8_ = uVar34;\n      auVar21._8_8_ = 0;\n      auVar21._0_8_ = uVar32;\n      uVar34 = SUB168(auVar9 * auVar21,0);\n      if (SUB168(auVar9 * auVar21,8) != 0) {\n        uVar26 = 1;\n        uVar34 = 0xffffffffffffffff;\n      }\n      iVar35 = iVar35 + -1;\n    } while (iVar35 != 0);\n    goto LAB_00118974;\n  case 0x12:\n  case 0x32:\n    iVar35 = 4;\n    uVar26 = 0;\n    do {\n      auVar7._8_8_ = 0;\n      auVar7._0_8_ = uVar34;\n      auVar19._8_8_ = 0;\n      auVar19._0_8_ = uVar32;\n      uVar34 = SUB168(auVar7 * auVar19,0);\n      if (SUB168(auVar7 * auVar19,8) != 0) {\n        uVar26 = 1;\n        uVar34 = 0xffffffffffffffff;\n      }\n      iVar35 = iVar35 + -1;\n    } while (iVar35 != 0);\n    goto LAB_00118974;\n  case 0x17:\n    iVar35 = 8;\n    uVar26 = 0;\n    do {\n      auVar13._8_8_ = 0;\n      auVar13._0_8_ = uVar34;\n      auVar25._8_8_ = 0;\n      auVar25._0_8_ = uVar32;\n      uVar34 = SUB168(auVar13 * auVar25,0);\n      if (SUB168(auVar13 * auVar25,8) != 0) {\n        uVar26 = 1;\n        uVar34 = 0xffffffffffffffff;\n      }\n      iVar35 = iVar35 + -1;\n    } while (iVar35 != 0);\n    goto LAB_00118974;\n  case 0x18:\n    iVar35 = 7;\n    uVar26 = 0;\n    do {\n      auVar11._8_8_ = 0;\n      auVar11._0_8_ = uVar34;\n      auVar23._8_8_ = 0;\n      auVar23._0_8_ = uVar32;\n      uVar34 = SUB168(auVar11 * auVar23,0);\n      if (SUB168(auVar11 * auVar23,8) != 0) {\n        uVar26 = 1;\n        uVar34 = 0xffffffffffffffff;\n      }\n      iVar35 = iVar35 + -1;\n    } while (iVar35 != 0);\nLAB_00118974:\n    uVar37 = uVar37 | uVar26;\n    uVar30 = uVar34;\n    break;\n  case 0x20:\n    uVar30 = uVar34 << 9;\n    if (uVar34 >> 0x37 != 0) {\n      uVar37 = 1;\n      uVar30 = 0xffffffffffffffff;\n    }\n    break;\n  case 0x21:\n    break;\n  case 0x35:\n    uVar30 = uVar34 * 2;\n    if ((long)uVar34 < 0) {\n      uVar37 = 1;\n      uVar30 = 0xffffffffffffffff;\n    }\n  }\n  *param_2 = pbVar29 + iVar36;\n  if (pbVar29[iVar36] != 0) {\n    uVar37 = uVar37 | 2;\n  }\nLAB_0011876d:\n  *param_4 = uVar30;\nLAB_00118775:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar37;\n}\n\n",
  "FUN_001165f0": "\nundefined4 FUN_001165f0(undefined *param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_00127520;\n  }\n  uVar1 = *(undefined4 *)(param_1 + 4);\n  *(undefined4 *)(param_1 + 4) = param_2;\n  return uVar1;\n}\n\n",
  "signal": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__sighandler_t signal(int __sig,__sighandler_t __handler)\n\n{\n  __sighandler_t p_Var1;\n  \n  p_Var1 = (__sighandler_t)(*(code *)PTR_signal_00125e30)();\n  return p_Var1;\n}\n\n",
  "FUN_001175c0": "\nlong * FUN_001175c0(long param_1)\n\n{\n  long *plVar1;\n  int iVar2;\n  char *__s2;\n  long *__ptr;\n  int *piVar3;\n  \n  __s2 = getenv(\"TZ\");\n  if (__s2 == (char *)0x0) {\n    if (*(char *)(param_1 + 8) == '\\0') {\n      return (long *)0x1;\n    }\n  }\n  else if ((*(char *)(param_1 + 8) != '\\0') &&\n          (iVar2 = strcmp((char *)(param_1 + 9),__s2), iVar2 == 0)) {\n    return (long *)0x1;\n  }\n  __ptr = (long *)FUN_001173f0(__s2);\n  if (__ptr != (long *)0x0) {\n    if (*(char *)(param_1 + 8) == '\\0') {\n      iVar2 = unsetenv(\"TZ\");\n    }\n    else {\n      iVar2 = setenv(\"TZ\",(char *)(param_1 + 9),1);\n    }\n    if (iVar2 != 0) {\n      piVar3 = __errno_location();\n      iVar2 = *piVar3;\n      if (__ptr != (long *)0x1) {\n        do {\n          plVar1 = (long *)*__ptr;\n          free(__ptr);\n          __ptr = plVar1;\n        } while (plVar1 != (long *)0x0);\n      }\n      *piVar3 = iVar2;\n      return (long *)0x0;\n    }\n    tzset();\n  }\n  return __ptr;\n}\n\n",
  "FUN_0010fd00": "\nvoid FUN_0010fd00(timespec *param_1)\n\n{\n  clock_gettime(0,param_1);\n  return;\n}\n\n",
  "FUN_0010a6f0": "\nulong FUN_0010a6f0(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010a770;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010a770:\n  uVar3 = FUN_001092a0();\n  return uVar3;\n}\n\n",
  "__snprintf_chk": "\nvoid __snprintf_chk(void)\n\n{\n  (*(code *)PTR___snprintf_chk_00125cb0)();\n  return;\n}\n\n",
  "_DT_FINI": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
  "FUN_0010ff40": "\nbool FUN_0010ff40(long param_1,long param_2)\n\n{\n  return param_2 == param_1;\n}\n\n",
  "FUN_00118060": "\nvoid FUN_00118060(long param_1,ulong *param_2,ulong param_3)\n\n{\n  undefined auVar1 [16];\n  ulong uVar2;\n  long lVar3;\n  ulong uVar4;\n  ulong uVar5;\n  \n  uVar5 = *param_2;\n  if (param_1 == 0) {\n    if (uVar5 == 0) {\n      auVar1._8_8_ = 0;\n      auVar1._0_8_ = param_3;\n      uVar5 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(0x80)) / auVar1,0) + (ulong)(0x80 < param_3);\n    }\n    lVar3 = reallocarray(0,uVar5,param_3);\n    if (lVar3 != 0) {\n      *param_2 = uVar5;\n      return;\n    }\n  }\n  else {\n    uVar2 = (uVar5 >> 1) + 1;\n    uVar4 = uVar5 + uVar2;\n    if (!CARRY8(uVar5,uVar2)) {\n      lVar3 = reallocarray(param_1,uVar4);\n      if (((lVar3 != 0) || (uVar4 == 0)) || (param_3 == 0)) {\n        *param_2 = uVar4;\n        return;\n      }\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "strtoumax": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nuintmax_t strtoumax(char *__nptr,char **__endptr,int __base)\n\n{\n  uintmax_t uVar1;\n  \n  uVar1 = (*(code *)PTR_strtoumax_00125f10)();\n  return uVar1;\n}\n\n",
  "FUN_0010bb80": "\nlong FUN_0010bb80(byte *param_1,undefined8 param_2,undefined4 param_3,long param_4,char param_5,\n                 long param_6,long param_7)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  char cVar3;\n  size_t sVar4;\n  void *__ptr;\n  char *pcVar5;\n  char *pcVar6;\n  long *plVar7;\n  long lVar8;\n  size_t sVar9;\n  char cVar10;\n  long in_FS_OFFSET;\n  byte local_2051;\n  byte *local_2050;\n  byte local_2048 [8200];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2050 = local_2048;\n  sVar4 = FUN_001079e0(&local_2050,param_1,param_2,param_3,0);\n  if ((local_2051 != 0) && (param_5 != '\\0')) {\n    DAT_001271f8 = DAT_001271f8 + 1;\n    pcVar5 = stdout->_IO_write_ptr;\n    if (pcVar5 < stdout->_IO_write_end) {\n      stdout->_IO_write_ptr = pcVar5 + 1;\n      *pcVar5 = ' ';\n    }\n    else {\n      __overflow(stdout,0x20);\n    }\n  }\n  if (param_4 != 0) {\n    cVar3 = FUN_00106d60(4);\n    if (cVar3 != '\\0') {\n      FUN_00107940(&DAT_00126060);\n      FUN_00107940(&DAT_00126070);\n    }\n    FUN_00107940(&DAT_00126060);\n    FUN_00107940(param_4);\n    FUN_00107940(&DAT_00126070);\n  }\n  cVar3 = DAT_001273a9;\n  sVar9 = sVar4;\n  if (param_7 == 0) {\n    lVar8 = 0;\n    cVar3 = '\\0';\n  }\n  else {\n    cVar10 = DAT_001273a8;\n    if ((DAT_001273a8 == '\\0') || (cVar10 = DAT_001273a9, DAT_001273a9 == '\\0')) {\n      lVar8 = 0;\n      cVar3 = cVar10;\n    }\n    else if (local_2051 == 0) {\n      bVar1 = *local_2050;\n      pbVar2 = (byte *)stdout->_IO_write_ptr;\n      sVar9 = sVar4 - 2;\n      if (pbVar2 < stdout->_IO_write_end) {\n        lVar8 = 1;\n        stdout->_IO_write_ptr = (char *)(pbVar2 + 1);\n        *pbVar2 = bVar1;\n      }\n      else {\n        __overflow(stdout,(uint)bVar1);\n        lVar8 = 1;\n      }\n    }\n    else {\n      lVar8 = 0;\n      cVar3 = '\\0';\n    }\n    __ptr = (void *)FUN_00107360(DAT_00127388,0);\n    pcVar5 = (char *)FUN_00107360(param_7,1);\n    pcVar6 = \"\";\n    if (*pcVar5 != '/') {\n      pcVar6 = \"/\";\n    }\n    __printf_chk(1,&DAT_0011bdbb,__ptr,pcVar6);\n    free(__ptr);\n    free(pcVar5);\n  }\n  if (param_6 == 0) {\n    fwrite_unlocked(local_2050 + lVar8,1,sVar9,stdout);\n    DAT_001271f8 = DAT_001271f8 + sVar4;\n  }\n  else {\n    if (DAT_00127318 != '\\0') {\n      plVar7 = *(long **)(param_6 + 0x18);\n      if ((ulong)(*(long *)(param_6 + 0x20) - (long)plVar7) < 8) {\n        _obstack_newchunk(param_6,8);\n        plVar7 = *(long **)(param_6 + 0x18);\n      }\n      *plVar7 = DAT_001271f8;\n      *(long *)(param_6 + 0x18) = *(long *)(param_6 + 0x18) + 8;\n    }\n    fwrite_unlocked(local_2050 + lVar8,1,sVar9,stdout);\n    DAT_001271f8 = DAT_001271f8 + sVar4;\n    if (DAT_00127318 != '\\0') {\n      plVar7 = *(long **)(param_6 + 0x18);\n      if ((ulong)(*(long *)(param_6 + 0x20) - (long)plVar7) < 8) {\n        _obstack_newchunk(param_6,8);\n        plVar7 = *(long **)(param_6 + 0x18);\n      }\n      *plVar7 = DAT_001271f8;\n      *(long *)(param_6 + 0x18) = *(long *)(param_6 + 0x18) + 8;\n    }\n  }\n  if ((param_7 != 0) && (fwrite_unlocked(&DAT_0011bdcf,1,6,stdout), cVar3 != '\\0')) {\n    bVar1 = local_2050[sVar4 - 1];\n    pbVar2 = (byte *)stdout->_IO_write_ptr;\n    if (pbVar2 < stdout->_IO_write_end) {\n      stdout->_IO_write_ptr = (char *)(pbVar2 + 1);\n      *pbVar2 = bVar1;\n    }\n    else {\n      __overflow(stdout,(uint)bVar1);\n    }\n  }\n  if ((local_2050 != param_1) && (local_2050 != local_2048)) {\n    free(local_2050);\n  }\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_2051 + sVar4;\n}\n\n",
  "FUN_0010e680": "\nlong FUN_0010e680(char *param_1,char **param_2)\n\n{\n  int iVar1;\n  long lVar2;\n  char *__s1;\n  \n  __s1 = *param_2;\n  if (__s1 != (char *)0x0) {\n    lVar2 = 0;\n    do {\n      iVar1 = strcmp(__s1,param_1);\n      if (iVar1 == 0) {\n        return lVar2;\n      }\n      lVar2 = lVar2 + 1;\n      __s1 = param_2[lVar2];\n    } while (__s1 != (char *)0x0);\n  }\n  return -1;\n}\n\n",
  "FUN_0010e560": "\nvoid FUN_0010e560(void)\n\n{\n  FUN_0010dc80(1);\n  return;\n}\n\n",
  "FUN_00104cd5": "\nvoid FUN_00104cd5(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_0010a5c0": "\nulong FUN_0010a5c0(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010a640;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010a640:\n  uVar3 = FUN_00109330();\n  return uVar3;\n}\n\n",
  "FUN_0010b6b0": "\nulong FUN_0010b6b0(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010b730;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010b730:\n  uVar3 = FUN_00108930();\n  return uVar3;\n}\n\n",
  "FUN_0010b7d0": "\nint FUN_0010b7d0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  iVar5 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar5 == 9 || iVar5 == 3) goto LAB_0010b850;\n    iVar5 = 1;\n  }\n  else {\n    if (iVar5 == 9 || iVar5 == 3) {\n      return -1;\n    }\n    iVar5 = 0;\n  }\n  iVar5 = iVar5 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar5 != 0) {\n    return iVar5;\n  }\nLAB_0010b850:\n  pcVar1 = param_2[0xe];\n  pcVar2 = param_1[0xe];\n  pcVar3 = param_2[0xf];\n  pcVar4 = param_1[0xf];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_1[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_1[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 != 0) {\n    return iVar5;\n  }\n  iVar5 = strcmp(*param_1,*param_2);\n  return iVar5;\n}\n\n",
  "FUN_0010fd10": "\n__time_t FUN_0010fd10(void)\n\n{\n  long in_FS_OFFSET;\n  timespec local_28;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  clock_gettime(0,&local_28);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_28.tv_sec;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00112e10": "\nvoid FUN_00112e10(undefined8 *param_1,ulong param_2,code *param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int iVar3;\n  \n  if (2 < param_2) {\n    FUN_00112b50(param_1,param_2,param_1 + param_2,param_3);\n    return;\n  }\n  if (param_2 == 2) {\n    uVar1 = param_1[1];\n    uVar2 = *param_1;\n    iVar3 = (*param_3)(uVar2,uVar1);\n    if (0 < iVar3) {\n      *param_1 = uVar1;\n      param_1[1] = uVar2;\n      return;\n    }\n  }\n  return;\n}\n\n",
  "fseeko": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fseeko(FILE *__stream,__off_t __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fseeko_00125f08)();\n  return iVar1;\n}\n\n",
  "FUN_0010ff50": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 FUN_0010ff50(long param_1)\n\n{\n  float fVar1;\n  float *pfVar2;\n  float fVar3;\n  \n  pfVar2 = *(float **)(param_1 + 0x28);\n  if (pfVar2 == (float *)&DAT_0011e670) {\n    return 1;\n  }\n  fVar1 = pfVar2[2];\n  if ((((_DAT_0011e684 < fVar1) && (fVar1 < DAT_0011e688)) && (_DAT_0011e68c < pfVar2[3])) &&\n     (_DAT_0011e6a0 <= *pfVar2)) {\n    fVar3 = *pfVar2 + _DAT_0011e684;\n    if (((fVar3 < pfVar2[1]) && (pfVar2[1] <= DAT_0011e690)) && (fVar3 < fVar1)) {\n      return 1;\n    }\n  }\n  *(undefined **)(param_1 + 0x28) = &DAT_0011e670;\n  return 0;\n}\n\n",
  "wcwidth": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcwidth(wchar_t __c)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wcwidth_00125e98)();\n  return iVar1;\n}\n\n",
  "FUN_00108c70": "\nvoid FUN_00108c70(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int *piVar5;\n  \n  pcVar1 = param_1[0xe];\n  pcVar2 = param_2[0xe];\n  pcVar3 = param_1[0xf];\n  pcVar4 = param_2[0xf];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_2[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_2[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    pcVar1 = *param_2;\n    pcVar2 = *param_1;\n    piVar5 = __errno_location();\n    *piVar5 = 0;\n    strcoll(pcVar1,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00117ed0": "\nvoid FUN_00117ed0(long param_1,long param_2,long param_3)\n\n{\n  long lVar1;\n  \n  lVar1 = reallocarray();\n  if ((lVar1 == 0) && ((param_1 == 0 || ((param_2 != 0 && (param_3 != 0)))))) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00118390();\n  }\n  return;\n}\n\n",
  "FUN_00108a30": "\nvoid FUN_00108a30(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int *piVar5;\n  \n  pcVar1 = param_2[0xe];\n  pcVar2 = param_1[0xe];\n  pcVar3 = param_2[0xf];\n  pcVar4 = param_1[0xf];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_1[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_1[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    pcVar1 = *param_1;\n    pcVar2 = *param_2;\n    piVar5 = __errno_location();\n    *piVar5 = 0;\n    strcoll(pcVar1,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00112890": "\nvoid * FUN_00112890(undefined8 param_1,ulong *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  ulong __size;\n  ulong uVar1;\n  void *__ptr;\n  ulong uVar2;\n  void *__ptr_00;\n  \n  uVar1 = *param_2;\n  uVar2 = uVar1;\n  __ptr_00 = (void *)0x0;\n  while( true ) {\n    __size = uVar2 + 1;\n    __ptr = realloc(__ptr_00,__size);\n    if (__ptr == (void *)0x0) {\n      free(__ptr_00);\n      return (void *)0x0;\n    }\n    *param_2 = uVar1;\n    uVar2 = FUN_001124b0(param_1,__ptr,__size,param_2,param_3,param_4);\n    if (uVar2 == 0xffffffffffffffff) break;\n    __ptr_00 = __ptr;\n    if (uVar2 < __size) {\n      return __ptr;\n    }\n  }\n  free(__ptr);\n  return (void *)0x0;\n}\n\n",
  "FUN_0010d240": "\nvoid FUN_0010d240(void)\n\n{\n  long lVar1;\n  byte *pbVar2;\n  byte bVar3;\n  char cVar4;\n  ulong uVar5;\n  long lVar6;\n  ulong uVar7;\n  ulong uVar8;\n  long lVar9;\n  undefined8 uVar10;\n  long lVar11;\n  long lVar12;\n  ulong local_40;\n  \n  switch(DAT_00127338) {\n  case 0:\n    uVar5 = 0;\n    if (DAT_001273b0 == 0) {\n      return;\n    }\n    do {\n      if ((DAT_00127312 != '\\0') && (cVar4 = FUN_00106d60(4), cVar4 != '\\0')) {\n        FUN_00107940(&DAT_00126060);\n        FUN_00107940(&DAT_001260a0);\n        FUN_00107940(&DAT_00126070);\n      }\n      FUN_0010c800(DAT_001273a0[uVar5]);\n      bVar3 = DAT_00126019;\n      DAT_001271f8 = DAT_001271f8 + 1;\n      pbVar2 = (byte *)stdout->_IO_write_ptr;\n      if (pbVar2 < stdout->_IO_write_end) {\n        stdout->_IO_write_ptr = (char *)(pbVar2 + 1);\n        *pbVar2 = bVar3;\n      }\n      else {\n        __overflow(stdout,(uint)DAT_00126019);\n      }\n      uVar5 = uVar5 + 1;\n    } while (uVar5 < DAT_001273b0);\n    return;\n  case 1:\n    uVar5 = 0;\n    if (DAT_001273b0 != 0) {\n      do {\n        FUN_0010c430(DAT_001273a0[uVar5],0);\n        bVar3 = DAT_00126019;\n        pbVar2 = (byte *)stdout->_IO_write_ptr;\n        if (pbVar2 < stdout->_IO_write_end) {\n          stdout->_IO_write_ptr = (char *)(pbVar2 + 1);\n          *pbVar2 = bVar3;\n        }\n        else {\n          __overflow(stdout,(uint)DAT_00126019);\n        }\n        uVar5 = uVar5 + 1;\n      } while (uVar5 < DAT_001273b0);\n    }\n    return;\n  case 2:\n    if (DAT_001272b0 != 0) {\n      uVar5 = FUN_001080a0(1);\n      local_40 = 0;\n      lVar1 = DAT_00127208 + uVar5 * 0x18;\n      uVar5 = (DAT_001273b0 / uVar5 + 1) - (ulong)(DAT_001273b0 % uVar5 == 0);\n      if (uVar5 == 0) {\n        return;\n      }\n      do {\n        lVar6 = 0;\n        uVar8 = local_40;\n        lVar11 = 0;\n        while( true ) {\n          uVar10 = DAT_001273a0[uVar8];\n          lVar12 = FUN_00107ed0();\n          lVar9 = *(long *)(*(long *)(lVar1 + -8) + lVar6);\n          lVar6 = lVar6 + 8;\n          FUN_0010c430(uVar10,lVar11);\n          bVar3 = DAT_00126019;\n          uVar8 = uVar8 + uVar5;\n          if (DAT_001273b0 <= uVar8) break;\n          lVar9 = lVar9 + lVar11;\n          FUN_00107420(lVar12 + lVar11,lVar9);\n          lVar11 = lVar9;\n        }\n        pbVar2 = (byte *)stdout->_IO_write_ptr;\n        if (pbVar2 < stdout->_IO_write_end) {\n          stdout->_IO_write_ptr = (char *)(pbVar2 + 1);\n          *pbVar2 = bVar3;\n        }\n        else {\n          __overflow(stdout,(uint)DAT_00126019);\n        }\n        local_40 = local_40 + 1;\n      } while (uVar5 != local_40);\n      return;\n    }\n    break;\n  case 3:\n    if (DAT_001272b0 != 0) {\n      uVar5 = FUN_001080a0(0);\n      lVar1 = DAT_00127208 + -0x18 + uVar5 * 0x18;\n      uVar10 = *DAT_001273a0;\n      lVar6 = FUN_00107ed0(uVar10);\n      lVar11 = **(long **)(lVar1 + 0x10);\n      FUN_0010c430(uVar10,0);\n      if (1 < DAT_001273b0) {\n        uVar8 = 1;\n        lVar9 = 0;\n        do {\n          bVar3 = DAT_00126019;\n          uVar7 = uVar8 % uVar5;\n          if (uVar7 == 0) {\n            pbVar2 = (byte *)stdout->_IO_write_ptr;\n            if (pbVar2 < stdout->_IO_write_end) {\n              lVar12 = 0;\n              stdout->_IO_write_ptr = (char *)(pbVar2 + 1);\n              *pbVar2 = bVar3;\n            }\n            else {\n              lVar12 = 0;\n              __overflow(stdout,(uint)DAT_00126019);\n            }\n          }\n          else {\n            lVar12 = lVar11 + lVar9;\n            FUN_00107420(lVar9 + lVar6,lVar12);\n          }\n          uVar10 = DAT_001273a0[uVar8];\n          uVar8 = uVar8 + 1;\n          FUN_0010c430(uVar10,lVar12);\n          lVar6 = FUN_00107ed0(uVar10);\n          lVar11 = *(long *)(*(long *)(lVar1 + 0x10) + uVar7 * 8);\n          lVar9 = lVar12;\n        } while (uVar8 < DAT_001273b0);\n      }\n      bVar3 = DAT_00126019;\n      pbVar2 = (byte *)stdout->_IO_write_ptr;\n      if (pbVar2 < stdout->_IO_write_end) {\n        stdout->_IO_write_ptr = (char *)(pbVar2 + 1);\n        *pbVar2 = bVar3;\n        return;\n      }\n      __overflow(stdout,(uint)DAT_00126019);\n      return;\n    }\n    break;\n  case 4:\n    uVar10 = 0x2c;\n    goto LAB_0010d375;\n  default:\n    return;\n  }\n  uVar10 = 0x20;\nLAB_0010d375:\n  FUN_0010c640(uVar10);\n  return;\n}\n\n",
  "FUN_0010e570": "\nlong FUN_0010e570(char *param_1,char **param_2,void *param_3,size_t param_4)\n\n{\n  bool bVar1;\n  long lVar2;\n  int iVar3;\n  size_t __n;\n  size_t sVar4;\n  long lVar5;\n  void *__s2;\n  char *__s1;\n  long local_58;\n  \n  __n = strlen(param_1);\n  __s1 = *param_2;\n  if (__s1 == (char *)0x0) {\n    local_58 = -1;\n    lVar5 = local_58;\n  }\n  else {\n    bVar1 = false;\n    lVar5 = 0;\n    local_58 = -1;\n    __s2 = param_3;\n    do {\n      iVar3 = strncmp(__s1,param_1,__n);\n      lVar2 = local_58;\n      if (iVar3 == 0) {\n        sVar4 = strlen(__s1);\n        if (sVar4 == __n) {\n          return lVar5;\n        }\n        lVar2 = lVar5;\n        if (local_58 != -1) {\n          if (param_3 == (void *)0x0) {\n            bVar1 = true;\n            lVar2 = local_58;\n          }\n          else {\n            iVar3 = memcmp((void *)(local_58 * param_4 + (long)param_3),__s2,param_4);\n            lVar2 = local_58;\n            if (iVar3 != 0) {\n              bVar1 = true;\n            }\n          }\n        }\n      }\n      local_58 = lVar2;\n      lVar5 = lVar5 + 1;\n      __s2 = (void *)((long)__s2 + param_4);\n      __s1 = param_2[lVar5];\n    } while (__s1 != (char *)0x0);\n    lVar5 = -2;\n    if (!bVar1) {\n      lVar5 = local_58;\n    }\n  }\n  local_58 = lVar5;\n  return local_58;\n}\n\n",
  "FUN_0010f420": "\nundefined8 FUN_0010f420(void)\n\n{\n  return 0;\n}\n\n",
  "FUN_00104ce5": "\nvoid FUN_00104ce5(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_001196a0": "\nchar * FUN_001196a0(void)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = nl_langinfo(0xe);\n  if (pcVar1 != (char *)0x0) {\n    if (*pcVar1 == '\\0') {\n      pcVar1 = \"ASCII\";\n    }\n    return pcVar1;\n  }\n  return \"ASCII\";\n}\n\n",
  "caseD_7": "\nvoid switchD_00106c53::caseD_7(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_001109c0": "\nvoid FUN_001109c0(long **param_1)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long *plVar3;\n  long *plVar4;\n  long *plVar5;\n  \n  plVar5 = *param_1;\n  if (*param_1 < param_1[1]) {\n    do {\n      while (*plVar5 != 0) {\n        plVar4 = param_1[8];\n        plVar3 = (long *)plVar5[1];\n        while (plVar3 != (long *)0x0) {\n          if (plVar4 != (long *)0x0) {\n            (*(code *)plVar4)(*plVar3);\n            plVar4 = param_1[8];\n          }\n          plVar1 = (long *)plVar3[1];\n          plVar2 = param_1[9];\n          *plVar3 = 0;\n          plVar3[1] = (long)plVar2;\n          param_1[9] = plVar3;\n          plVar3 = plVar1;\n        }\n        if (plVar4 != (long *)0x0) {\n          (*(code *)plVar4)(*plVar5);\n        }\n        *plVar5 = 0;\n        plVar4 = plVar5 + 2;\n        plVar5[1] = 0;\n        plVar5 = plVar4;\n        if (param_1[1] < plVar4 || param_1[1] == plVar4) goto LAB_00110a5b;\n      }\n      plVar5 = plVar5 + 2;\n    } while (plVar5 <= param_1[1] && param_1[1] != plVar5);\n  }\nLAB_00110a5b:\n  param_1[3] = (long *)0x0;\n  param_1[4] = (long *)0x0;\n  return;\n}\n\n",
  "caseD_b": "\nvoid switchD_00114fc6::caseD_b(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00110240": "\nundefined8 FUN_00110240(long *param_1,long **param_2,char param_3)\n\n{\n  long lVar1;\n  ulong uVar2;\n  long *plVar3;\n  ulong uVar4;\n  long *plVar5;\n  long *plVar6;\n  long *plVar7;\n  long lVar8;\n  \n  plVar6 = *param_2;\n  if (plVar6 < param_2[1]) {\n    do {\n      while (lVar8 = *plVar6, lVar8 != 0) {\n        if ((long *)plVar6[1] != (long *)0x0) {\n          uVar4 = param_1[2];\n          plVar7 = (long *)plVar6[1];\n          do {\n            lVar8 = *plVar7;\n            uVar2 = (*(code *)param_1[6])(lVar8,uVar4);\n            uVar4 = param_1[2];\n            if (uVar4 <= uVar2) goto FUN_00104cd5;\n            plVar3 = (long *)(uVar2 * 0x10 + *param_1);\n            plVar5 = (long *)plVar7[1];\n            if (*plVar3 == 0) {\n              *plVar3 = lVar8;\n              lVar8 = param_1[9];\n              param_1[3] = param_1[3] + 1;\n              *plVar7 = 0;\n              plVar7[1] = lVar8;\n              param_1[9] = (long)plVar7;\n            }\n            else {\n              plVar7[1] = plVar3[1];\n              plVar3[1] = (long)plVar7;\n            }\n            plVar7 = plVar5;\n          } while (plVar5 != (long *)0x0);\n          lVar8 = *plVar6;\n        }\n        plVar6[1] = 0;\n        if (param_3 != '\\0') break;\n        uVar4 = (*(code *)param_1[6])(lVar8,param_1[2]);\n        if ((ulong)param_1[2] <= uVar4) {\nFUN_00104cd5:\n                    /* WARNING: Subroutine does not return */\n          abort();\n        }\n        plVar7 = (long *)(uVar4 * 0x10 + *param_1);\n        if (*plVar7 == 0) {\n          *plVar7 = lVar8;\n          param_1[3] = param_1[3] + 1;\n        }\n        else {\n          plVar5 = (long *)param_1[9];\n          if (plVar5 == (long *)0x0) {\n            plVar5 = (long *)malloc(0x10);\n            if (plVar5 == (long *)0x0) {\n              return 0;\n            }\n          }\n          else {\n            param_1[9] = plVar5[1];\n          }\n          lVar1 = plVar7[1];\n          *plVar5 = lVar8;\n          plVar5[1] = lVar1;\n          plVar7[1] = (long)plVar5;\n        }\n        *plVar6 = 0;\n        plVar6 = plVar6 + 2;\n        param_2[3] = (long *)((long)param_2[3] + -1);\n        if (param_2[1] < plVar6 || param_2[1] == plVar6) {\n          return 1;\n        }\n      }\n      plVar6 = plVar6 + 2;\n    } while (plVar6 <= param_2[1] && param_2[1] != plVar6);\n  }\n  return 1;\n}\n\n",
  "FUN_00104cda": "\nvoid FUN_00104cda(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00104cdf": "\nvoid FUN_00104cdf(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00107070": "\nvoid FUN_00107070(long param_1,long param_2,undefined param_3)\n\n{\n  long *plVar1;\n  \n  plVar1 = (long *)FUN_00117e10(0x20);\n  if (param_2 != 0) {\n    param_2 = FUN_00118350(param_2);\n  }\n  plVar1[1] = param_2;\n  if (param_1 != 0) {\n    param_1 = FUN_00118350(param_1);\n  }\n  *plVar1 = param_1;\n  *(undefined *)(plVar1 + 2) = param_3;\n  plVar1[3] = (long)DAT_00127380;\n  DAT_00127380 = plVar1;\n  return;\n}\n\n",
  "FUN_0010f430": "\nvoid FUN_0010f430(long param_1,undefined8 param_2,undefined8 *param_3)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  \n  if (param_1 == 0) {\n    return;\n  }\n  puVar1 = (undefined8 *)FUN_00117e10(0x18);\n  uVar2 = FUN_00118350(param_2);\n  *puVar1 = uVar2;\n  puVar1[1] = param_3[1];\n  puVar1[2] = *param_3;\n  puVar3 = (undefined8 *)FUN_00110f50(param_1,puVar1);\n  if (puVar3 != (undefined8 *)0x0) {\n    if (puVar1 != puVar3) {\n      FUN_001111c0(puVar1);\n      return;\n    }\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "getgrnam": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ngroup * getgrnam(char *__name)\n\n{\n  group *pgVar1;\n  \n  pgVar1 = (group *)(*(code *)PTR_getgrnam_00125e70)();\n  return pgVar1;\n}\n\n",
  "FUN_00104cf4": "\nvoid FUN_00104cf4(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_001108b0": "\nvoid ** FUN_001108b0(undefined8 param_1,undefined *param_2,code *param_3,code *param_4,void *param_5\n                    )\n\n{\n  char cVar1;\n  void **__ptr;\n  void *__nmemb;\n  void *pvVar2;\n  int *piVar3;\n  void **ppvVar4;\n  \n  if (param_3 == (code *)0x0) {\n    param_3 = FUN_0010ff20;\n  }\n  if (param_4 == (code *)0x0) {\n    param_4 = FUN_0010ff40;\n  }\n  __ptr = (void **)malloc(0x50);\n  ppvVar4 = __ptr;\n  if (__ptr != (void **)0x0) {\n    if (param_2 == (undefined *)0x0) {\n      param_2 = &DAT_0011e670;\n    }\n    __ptr[5] = param_2;\n    cVar1 = FUN_0010ff50(__ptr);\n    if (cVar1 == '\\0') {\n      piVar3 = __errno_location();\n      *piVar3 = 0x16;\n    }\n    else {\n      __nmemb = (void *)FUN_001100f0(param_1,param_2);\n      __ptr[2] = __nmemb;\n      if (__nmemb != (void *)0x0) {\n        pvVar2 = calloc((size_t)__nmemb,0x10);\n        *__ptr = pvVar2;\n        if (pvVar2 != (void *)0x0) {\n          __ptr[6] = param_3;\n          __ptr[7] = param_4;\n          __ptr[1] = (void *)((long)pvVar2 + (long)__nmemb * 0x10);\n          __ptr[3] = (void *)0x0;\n          __ptr[4] = (void *)0x0;\n          __ptr[8] = param_5;\n          __ptr[9] = (void *)0x0;\n          return __ptr;\n        }\n      }\n    }\n    ppvVar4 = (void **)0x0;\n    free(__ptr);\n  }\n  return ppvVar4;\n}\n\n",
  "FUN_00104cef": "\nvoid FUN_00104cef(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00104cea": "\nvoid FUN_00104cea(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00116bc0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00116bc0(undefined8 param_1,byte param_2)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = _DAT_00127520;\n  uStack_40 = uRam0000000000127528;\n  local_18 = DAT_00127550;\n  local_38 = _DAT_00127530;\n  uStack_30 = uRam0000000000127538;\n  local_28 = _DAT_00127540;\n  uStack_20 = uRam0000000000127548;\n  puVar1 = (uint *)((long)&uStack_40 + (ulong)(param_2 >> 5) * 4);\n  uVar2 = *puVar1;\n  *puVar1 = (~(uVar2 >> (param_2 & 0x1f)) & 1) << (param_2 & 0x1f) ^ uVar2;\n  FUN_00116340(0,param_1,0xffffffffffffffff,&local_48);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001087d0": "\nvoid FUN_001087d0(char **param_1,char **param_2)\n\n{\n  char *__s2;\n  char *__s1;\n  int *piVar1;\n  \n  __s2 = *param_2;\n  __s1 = *param_1;\n  piVar1 = __errno_location();\n  *piVar1 = 0;\n  strcoll(__s1,__s2);\n  return;\n}\n\n",
  "FUN_001088f0": "\nvoid FUN_001088f0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  pcVar1 = param_2[9];\n  pcVar2 = param_1[9];\n  if ((long)pcVar2 < (long)pcVar1 == (param_1[9] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) {\n    strcmp(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00117dd0": "\nvoid FUN_00117dd0(long param_1,long param_2,long param_3)\n\n{\n  long lVar1;\n  \n  lVar1 = reallocarray();\n  if ((lVar1 == 0) && ((param_1 == 0 || ((param_2 != 0 && (param_3 != 0)))))) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00118390();\n  }\n  return;\n}\n\n",
  "FUN_00112420": "\nsize_t FUN_00112420(wchar_t *param_1,byte *param_2,size_t param_3,mbstate_t *param_4)\n\n{\n  char cVar1;\n  size_t sVar2;\n  long in_FS_OFFSET;\n  wchar_t local_34;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == (wchar_t *)0x0) {\n    param_1 = &local_34;\n  }\n  sVar2 = mbrtowc(param_1,(char *)param_2,param_3,param_4);\n  if ((0xfffffffffffffffd < sVar2) && (param_3 != 0)) {\n    cVar1 = FUN_0010fea0(0);\n    if (cVar1 == '\\0') {\n      sVar2 = 1;\n      *param_1 = (uint)*param_2;\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return sVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0010adc0": "\nulong FUN_0010adc0(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010ae40;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010ae40:\n  uVar3 = FUN_00109160();\n  return uVar3;\n}\n\n",
  "FUN_0010aee0": "\nint FUN_0010aee0(char **param_1,char **param_2)\n\n{\n  char *__s1;\n  char *__s2;\n  int iVar1;\n  \n  iVar1 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar1 == 9 || iVar1 == 3) goto LAB_0010af60;\n    iVar1 = 1;\n  }\n  else {\n    if (iVar1 == 9 || iVar1 == 3) {\n      return -1;\n    }\n    iVar1 = 0;\n  }\n  iVar1 = iVar1 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar1 != 0) {\n    return iVar1;\n  }\nLAB_0010af60:\n  __s1 = *param_1;\n  __s2 = *param_2;\n  iVar1 = FUN_0010fce0(__s1,__s2);\n  if (iVar1 == 0) {\n    iVar1 = strcmp(__s1,__s2);\n    return iVar1;\n  }\n  return iVar1;\n}\n\n",
  "FUN_0010b4a0": "\nint FUN_0010b4a0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  int iVar3;\n  int *piVar4;\n  \n  iVar3 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar3 == 9 || iVar3 == 3) goto LAB_0010b520;\n    iVar3 = 1;\n  }\n  else {\n    if (iVar3 == 9 || iVar3 == 3) {\n      return -1;\n    }\n    iVar3 = 0;\n  }\n  iVar3 = iVar3 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar3 != 0) {\n    return iVar3;\n  }\nLAB_0010b520:\n  pcVar1 = param_1[9];\n  pcVar2 = param_2[9];\n  iVar3 = (uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_2[9] != pcVar1 && (long)pcVar1 <= (long)pcVar2);\n  if (iVar3 != 0) {\n    return iVar3;\n  }\n  pcVar1 = *param_2;\n  pcVar2 = *param_1;\n  piVar4 = __errno_location();\n  *piVar4 = 0;\n  iVar3 = strcoll(pcVar1,pcVar2);\n  return iVar3;\n}\n\n",
  "FUN_00109020": "\nint FUN_00109020(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  pcVar1 = param_1[0xc];\n  pcVar2 = param_2[0xc];\n  pcVar3 = param_1[0xd];\n  pcVar4 = param_2[0xd];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_2[0xd] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_2[0xc] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 == 0) {\n    iVar5 = strcmp(*param_2,*param_1);\n    return iVar5;\n  }\n  return iVar5;\n}\n\n",
  "FUN_0010b080": "\nint FUN_0010b080(char **param_1,char **param_2)\n\n{\n  char *__s2;\n  char *__s1;\n  int iVar1;\n  int *piVar2;\n  \n  iVar1 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar1 == 3 || iVar1 == 9) goto LAB_0010b100;\n    iVar1 = 1;\n  }\n  else {\n    if (iVar1 == 3 || iVar1 == 9) {\n      return -1;\n    }\n    iVar1 = 0;\n  }\n  iVar1 = iVar1 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar1 != 0) {\n    return iVar1;\n  }\nLAB_0010b100:\n  __s2 = *param_2;\n  __s1 = *param_1;\n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  iVar1 = strcoll(__s1,__s2);\n  return iVar1;\n}\n\n",
  "FUN_001172a0": "\nundefined8 FUN_001172a0(int param_1,undefined *param_2,ulong param_3)\n\n{\n  char *__s;\n  size_t sVar1;\n  undefined8 uVar2;\n  \n  __s = setlocale(param_1,(char *)0x0);\n  if (__s == (char *)0x0) {\n    uVar2 = 0x16;\n    if (param_3 != 0) {\n      *param_2 = 0;\n    }\n  }\n  else {\n    sVar1 = strlen(__s);\n    if (sVar1 < param_3) {\n      memcpy(param_2,__s,sVar1 + 1);\n      return 0;\n    }\n    uVar2 = 0x22;\n    if (param_3 != 0) {\n      memcpy(param_2,__s,param_3 - 1);\n      param_2[param_3 - 1] = 0;\n      return 0x22;\n    }\n  }\n  return uVar2;\n}\n\n",
  "__cxa_finalize": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n",
  "FUN_00116cf0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00116cf0(undefined8 param_1,undefined8 param_2)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = _DAT_00127520;\n  uStack_40._4_4_ = (uint)((ulong)uRam0000000000127528 >> 0x20);\n  local_18 = DAT_00127550;\n  local_38 = _DAT_00127530;\n  uStack_30 = uRam0000000000127538;\n  local_28 = _DAT_00127540;\n  uStack_20 = uRam0000000000127548;\n  uStack_40 = CONCAT44(~uStack_40._4_4_ & 0x4000000 ^ uStack_40._4_4_,(int)uRam0000000000127528);\n  FUN_00116340(0,param_1,param_2,&local_48);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0010e9d0": "\nchar * FUN_0010e9d0(char *param_1)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  char cVar3;\n  \n  cVar3 = *param_1;\n  while (cVar3 == '/') {\n    pcVar2 = param_1 + 1;\n    param_1 = param_1 + 1;\n    cVar3 = *pcVar2;\n  }\n  if (cVar3 != '\\0') {\n    bVar1 = false;\n    pcVar2 = param_1;\n    do {\n      while (cVar3 != '/') {\n        if (bVar1) {\n          bVar1 = false;\n          param_1 = pcVar2;\n        }\n        cVar3 = pcVar2[1];\n        pcVar2 = pcVar2 + 1;\n        if (cVar3 == '\\0') {\n          return param_1;\n        }\n      }\n      cVar3 = pcVar2[1];\n      pcVar2 = pcVar2 + 1;\n      bVar1 = true;\n    } while (cVar3 != '\\0');\n  }\n  return param_1;\n}\n\n",
  "FUN_0010a4f0": "\nint FUN_0010a4f0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  iVar5 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar5 == 9 || iVar5 == 3) goto LAB_0010a570;\n    iVar5 = 1;\n  }\n  else {\n    if (iVar5 == 9 || iVar5 == 3) {\n      return -1;\n    }\n    iVar5 = 0;\n  }\n  iVar5 = iVar5 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar5 != 0) {\n    return iVar5;\n  }\nLAB_0010a570:\n  pcVar1 = param_1[0xc];\n  pcVar2 = param_2[0xc];\n  pcVar3 = param_1[0xd];\n  pcVar4 = param_2[0xd];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_2[0xd] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_2[0xc] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 != 0) {\n    return iVar5;\n  }\n  iVar5 = strcmp(*param_2,*param_1);\n  return iVar5;\n}\n\n",
  "FUN_0010dc80": "\nvoid FUN_0010dc80(int param_1)\n\n{\n  int iVar1;\n  char *pcVar2;\n  undefined8 *puVar3;\n  char *__s1;\n  char *pcVar4;\n  long in_FS_OFFSET;\n  undefined8 local_b8;\n  char *local_b0;\n  char *local_a8 [4];\n  char *local_88;\n  char *local_80;\n  char *local_78;\n  char *local_70;\n  undefined *local_68;\n  char *local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_40;\n  \n  puVar3 = &local_b8;\n  local_40 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    __printf_chk(1,\"Usage: %s [OPTION]... [FILE]...\\n\");\n    __s1 = \"ls\";\n    fwrite_unlocked(\"List information about the FILEs (the current directory by default).\\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\\n\"\n                    ,1,0x8f,stdout);\n    fwrite_unlocked(\"\\nMandatory arguments to long options are mandatory for short options too.\\n\",1\n                    ,0x4a,stdout);\n    fwrite_unlocked(\"  -a, --all                  do not ignore entries starting with .\\n  -A, --almost-all           do not list implied . and ..\\n      --author               with -l, print the author of each file\\n  -b, --escape               print C-style escapes for nongraphic characters\\n\"\n                    ,1,0x10e,stdout);\n    fwrite_unlocked(\"      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;\\n                             e.g., \\'--block-size=M\\'; see SIZE format below\\n\\n\"\n                    ,1,0x9a,stdout);\n    fwrite_unlocked(\"  -B, --ignore-backups       do not list implied entries ending with ~\\n\",1,\n                    0x47,stdout);\n    fwrite_unlocked(\"  -c                         with -lt: sort by, and show, ctime (time of last\\n                             change of file status information);\\n                             with -l: show ctime and sort by name;\\n                             otherwise: sort by ctime, newest first\\n\\n\"\n                    ,1,0x117,stdout);\n    fwrite_unlocked(\"  -C                         list entries by columns\\n      --color[=WHEN]         color the output WHEN; more info below\\n  -d, --directory            list directories themselves, not their contents\\n  -D, --dired                generate output designed for Emacs\\' dired mode\\n\"\n                    ,1,0x112,stdout);\n    fwrite_unlocked(\"  -f                         list all entries in directory order\\n  -F, --classify[=WHEN]      append indicator (one of */=>@|) to entries WHEN\\n      --file-type            likewise, except do not append \\'*\\'\\n\"\n                    ,1,0xcf,stdout);\n    fwrite_unlocked(\"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\\n                             single-column -1, verbose -l, vertical -C\\n\\n\"\n                    ,1,0x93,stdout);\n    fwrite_unlocked(\"      --full-time            like -l --time-style=full-iso\\n\",1,0x3b,stdout);\n    fwrite_unlocked(\"  -g                         like -l, but do not list owner\\n\",1,0x3c,stdout);\n    fwrite_unlocked(\"      --group-directories-first\\n                             group directories before files;\\n                             can be augmented with a --sort option, but any\\n                             use of --sort=none (-U) disables grouping\\n\\n\"\n                    ,1,0xf1,stdout);\n    fwrite_unlocked(\"  -G, --no-group             in a long listing, don\\'t print group names\\n\",1,\n                    0x48,stdout);\n    fwrite_unlocked(\"  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G etc.\\n      --si                   likewise, but use powers of 1000 not 1024\\n\"\n                    ,1,0x95,stdout);\n    fwrite_unlocked(\"  -H, --dereference-command-line\\n                             follow symbolic links listed on the command line\\n\"\n                    ,1,0x6f,stdout);\n    fwrite_unlocked(\"      --dereference-command-line-symlink-to-dir\\n                             follow each command line symbolic link\\n                             that points to a directory\\n\\n\"\n                    ,1,0xad,stdout);\n    fwrite_unlocked(\"      --hide=PATTERN         do not list implied entries matching shell PATTERN\\n                             (overridden by -a or -A)\\n\\n\"\n                    ,1,0x87,stdout);\n    fwrite_unlocked(\"      --hyperlink[=WHEN]     hyperlink file names WHEN\\n\",1,0x37,stdout);\n    fwrite_unlocked(\"      --indicator-style=WORD\\n                             append indicator with style WORD to entry names:\\n                             none (default), slash (-p),\\n                             file-type (--file-type), classify (-F)\\n\\n\"\n                    ,1,0xe9,stdout);\n    fwrite_unlocked(\"  -i, --inode                print the index number of each file\\n  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\\n\"\n                    ,1,0x91,stdout);\n    fwrite_unlocked(\"  -k, --kibibytes            default to 1024-byte blocks for file system usage;\\n                             used only with -s and per directory totals\\n\\n\"\n                    ,1,0x99,stdout);\n    fwrite_unlocked(\"  -l                         use a long listing format\\n\",1,0x37,stdout);\n    fwrite_unlocked(\"  -L, --dereference          when showing file information for a symbolic\\n                             link, show information for the file the link\\n                             references rather than for the link itself\\n\\n\"\n                    ,1,0xdd,stdout);\n    fwrite_unlocked(\"  -m                         fill width with a comma separated list of entries\\n\"\n                    ,1,0x4f,stdout);\n    fwrite_unlocked(\"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\\n  -N, --literal              print entry names without quoting\\n  -o                         like -l, but do not list group information\\n  -p, --indicator-style=slash\\n                             append / indicator to directories\\n\"\n                    ,1,0x12e,stdout);\n    fwrite_unlocked(\"  -q, --hide-control-chars   print ? instead of nongraphic characters\\n\",1,0x46\n                    ,stdout);\n    fwrite_unlocked(\"      --show-control-chars   show nongraphic characters as-is (the default,\\n                             unless program is \\'ls\\' and output is a terminal)\\n\\n\"\n                    ,1,0x9b,stdout);\n    fwrite_unlocked(\"  -Q, --quote-name           enclose entry names in double quotes\\n\",1,0x42,\n                    stdout);\n    fwrite_unlocked(\"      --quoting-style=WORD   use quoting style WORD for entry names:\\n                             literal, locale, shell, shell-always,\\n                             shell-escape, shell-escape-always, c, escape\\n                             (overrides QUOTING_STYLE environment variable)\\n\\n\"\n                    ,1,0x11f,stdout);\n    fwrite_unlocked(\"  -r, --reverse              reverse order while sorting\\n  -R, --recursive            list subdirectories recursively\\n  -s, --size                 print the allocated size of each file, in blocks\\n\"\n                    ,1,0xc4,stdout);\n    fwrite_unlocked(\"  -S                         sort by file size, largest first\\n\",1,0x3e,stdout)\n    ;\n    fwrite_unlocked(\"      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),\\n                             time (-t), version (-v), extension (-X), width\\n\\n\"\n                    ,1,0x9e,stdout);\n    fwrite_unlocked(\"      --time=WORD            select which timestamp used to display or sort;\\n                               access time (-u): atime, access, use;\\n                               metadata change time (-c): ctime, status;\\n                               modified time (default): mtime, modification;\\n                               birth time: birth, creation;\\n                             with -l, WORD determines which time to show;\\n                             with --sort=time, sort by WORD (newest first)\\n\\n\"\n                    ,1,0x1fa,stdout);\n    fwrite_unlocked(\"      --time-style=TIME_STYLE\\n                             time/date format with -l; see TIME_STYLE below\\n\"\n                    ,1,0x6a,stdout);\n    fwrite_unlocked(\"  -t                         sort by time, newest first; see --time\\n  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\\n\"\n                    ,1,0x8c,stdout);\n    fwrite_unlocked(\"  -u                         with -lt: sort by, and show, access time;\\n                             with -l: show access time and sort by name;\\n                             otherwise: sort by access time, newest first\\n\\n\"\n                    ,1,0xdb,stdout);\n    fwrite_unlocked(\"  -U                         do not sort; list entries in directory order\\n\",1,\n                    0x4a,stdout);\n    fwrite_unlocked(\"  -v                         natural sort of (version) numbers within text\\n\",1\n                    ,0x4b,stdout);\n    fwrite_unlocked(\"  -w, --width=COLS           set output width to COLS.  0 means no limit\\n  -x                         list entries by lines instead of by columns\\n  -X                         sort alphabetically by entry extension\\n  -Z, --context              print any security context of each file\\n      --zero                 end each output line with NUL, not newline\\n  -1                         list one file per line\\n\"\n                    ,1,0x197,stdout);\n    fwrite_unlocked(\"      --help        display this help and exit\\n\",1,0x2f,stdout);\n    fwrite_unlocked(\"      --version     output version information and exit\\n\",1,0x38,stdout);\n    fwrite_unlocked(\"\\nThe SIZE argument is an integer and optional unit (example: 10K is 10*1024).\\nUnits are K,M,G,T,P,E,Z,Y,R,Q (powers of 1024) or KB,MB,... (powers of 1000).\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\"\n                    ,1,0xd7,stdout);\n    fwrite_unlocked(\"\\nThe TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\\nFORMAT is interpreted like in date(1).  If FORMAT is FORMAT1<newline>FORMAT2,\\nthen FORMAT1 applies to non-recent files and FORMAT2 to recent files.\\nTIME_STYLE prefixed with \\'posix-\\' takes effect only outside the POSIX locale.\\nAlso the TIME_STYLE environment variable sets the default style to use.\\n\"\n                    ,1,0x177,stdout);\n    fwrite_unlocked(\"\\nThe WHEN argument defaults to \\'always\\' and can also be \\'auto\\' or \\'never\\'.\\n\"\n                    ,1,0x4b,stdout);\n    fwrite_unlocked(\"\\nUsing color to distinguish file types is disabled both by default and\\nwith --color=never.  With --color=auto, ls emits color codes only when\\nstandard output is connected to a terminal.  The LS_COLORS environment\\nvariable can change the settings.  Use the dircolors(1) command to set it.\\n\"\n                    ,1,0x120,stdout);\n    fwrite_unlocked(\"\\nExit status:\\n 0  if OK,\\n 1  if minor problems (e.g., cannot access subdirectory),\\n 2  if serious trouble (e.g., cannot access command-line argument).\\n\"\n                    ,1,0x97,stdout);\n    if ((DAT_001261e0 != 1) && (__s1 = \"dir\", DAT_001261e0 != 2)) {\n      __s1 = \"vdir\";\n    }\n    local_58 = 0;\n    local_b0 = \"test invocation\";\n    local_a8[0] = \"coreutils\";\n    pcVar4 = (char *)((long)&DAT_0011c2b9 + 1);\n    local_a8[1] = \"Multi-call invocation\";\n    local_88 = \"sha256sum\";\n    local_a8[2] = \"sha224sum\";\n    local_78 = \"sha384sum\";\n    local_68 = &DAT_0011be98;\n    local_b8 = 0x11c2ba;\n    local_a8[3] = \"sha2 utilities\";\n    local_80 = \"sha2 utilities\";\n    local_70 = \"sha2 utilities\";\n    local_60 = \"sha2 utilities\";\n    local_50 = 0;\n    do {\n      iVar1 = strcmp(__s1,pcVar4);\n      if (iVar1 == 0) break;\n      pcVar4 = *(char **)((long)puVar3 + 0x10);\n      puVar3 = (undefined8 *)((long)puVar3 + 0x10);\n    } while (pcVar4 != (char *)0x0);\n    pcVar4 = *(char **)((long)puVar3 + 8);\n    if (*(char **)((long)puVar3 + 8) == (char *)0x0) {\n      pcVar4 = __s1;\n    }\n    __printf_chk(1,\"\\n%s online help: <%s>\\n\",\"GNU coreutils\",\n                 \"https://www.gnu.org/software/coreutils/\");\n    pcVar2 = setlocale(5,(char *)0x0);\n    if (pcVar2 != (char *)0x0) {\n      iVar1 = strncmp(pcVar2,\"en_\",3);\n      if (iVar1 != 0) {\n        fwrite_unlocked(\"Report any translation bugs to <https://translationproject.org/team/>\\n\",1,\n                        0x46,stdout);\n      }\n    }\n    iVar1 = strcmp(__s1,(char *)((long)&DAT_0011c2b9 + 1));\n    pcVar2 = \"test\";\n    if (iVar1 != 0) {\n      pcVar2 = __s1;\n    }\n    __printf_chk(1,\"Full documentation <%s%s>\\n\",\"https://www.gnu.org/software/coreutils/\",pcVar2);\n    pcVar2 = \" invocation\";\n    if (__s1 != pcVar4) {\n      pcVar2 = \"\";\n    }\n    __printf_chk(1,\"or available locally via: info \\'(coreutils) %s%s\\'\\n\",pcVar4,pcVar2);\n  }\n  else {\n    __fprintf_chk(stderr,1,\"Try \\'%s --help\\' for more information.\\n\",DAT_00127400);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}\n\n",
  "FUN_00104cfe": "\nvoid FUN_00104cfe(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00112320": "\nchar * FUN_00112320(ulong param_1,long param_2)\n\n{\n  ulong uVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  *(undefined *)(param_2 + 0x14) = 0;\n  pcVar2 = (char *)(param_2 + 0x14);\n  if ((long)param_1 < 0) {\n    do {\n      pcVar3 = pcVar2;\n      uVar1 = (long)param_1 / 10;\n      pcVar3[-1] = ((char)uVar1 * '\\n' + '0') - (char)param_1;\n      param_1 = uVar1;\n      pcVar2 = pcVar3 + -1;\n    } while (uVar1 != 0);\n    pcVar3[-2] = '-';\n    return pcVar3 + -2;\n  }\n  do {\n    pcVar2 = pcVar2 + -1;\n    uVar1 = param_1 / 10;\n    *pcVar2 = (char)param_1 + (char)uVar1 * -10 + '0';\n    param_1 = uVar1;\n  } while (uVar1 != 0);\n  return pcVar2;\n}\n\n",
  "exit": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid exit(int __status)\n\n{\n  (*(code *)PTR_exit_00125f40)();\n  return;\n}\n\n",
  "FUN_001184c0": "\nvoid FUN_001184c0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,undefined8 param_6)\n\n{\n  FUN_001183c0(param_1,10,param_2,param_3,param_4,param_5,param_6);\n  return;\n}\n\n",
  "FUN_00106dd0": "\nuint FUN_00106dd0(void)\n\n{\n  uint uVar1;\n  \n  if (-1 < (char)DAT_00126018) {\n    return DAT_00126018 & 1;\n  }\n  uVar1 = isatty(1);\n  DAT_00126018 = (char)uVar1;\n  return uVar1 & 1;\n}\n\n",
  "__assert_fail": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n  (*(code *)PTR___assert_fail_00125dc8)();\n  return;\n}\n\n",
  "FUN_00108b90": "\nvoid FUN_00108b90(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int *piVar5;\n  \n  pcVar1 = param_2[0xe];\n  pcVar2 = param_1[0xe];\n  pcVar3 = param_2[0xf];\n  pcVar4 = param_1[0xf];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_1[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_1[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    pcVar1 = *param_1;\n    pcVar2 = *param_2;\n    piVar5 = __errno_location();\n    *piVar5 = 0;\n    strcoll(pcVar1,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00112210": "\n__gid_t * FUN_00112210(char *param_1)\n\n{\n  char cVar1;\n  __gid_t *p_Var2;\n  int iVar3;\n  group *pgVar4;\n  size_t sVar5;\n  __gid_t *p_Var6;\n  long lVar7;\n  \n  if (DAT_001273e8 != (__gid_t *)0x0) {\n    cVar1 = *param_1;\n    p_Var6 = DAT_001273e8;\n    do {\n      if ((*(char *)(p_Var6 + 4) == cVar1) &&\n         (iVar3 = strcmp((char *)(p_Var6 + 4),param_1), iVar3 == 0)) {\n        return p_Var6;\n      }\n      p_Var6 = *(__gid_t **)(p_Var6 + 2);\n    } while (p_Var6 != (__gid_t *)0x0);\n  }\n  if (DAT_001273e0 != (__gid_t *)0x0) {\n    cVar1 = *param_1;\n    lVar7 = (long)DAT_001273e0;\n    do {\n      if ((*(char *)(lVar7 + 0x10) == cVar1) &&\n         (iVar3 = strcmp((char *)(lVar7 + 0x10),param_1), iVar3 == 0)) {\n        return (__gid_t *)0x0;\n      }\n      lVar7 = *(long *)(lVar7 + 8);\n    } while (lVar7 != 0);\n  }\n  pgVar4 = getgrnam(param_1);\n  sVar5 = strlen(param_1);\n  p_Var6 = (__gid_t *)FUN_00117e10(sVar5 + 0x18 & 0xfffffffffffffff8);\n  strcpy((char *)(p_Var6 + 4),param_1);\n  if (pgVar4 != (group *)0x0) {\n    *p_Var6 = pgVar4->gr_gid;\n    p_Var2 = p_Var6;\n    *(__gid_t **)(p_Var6 + 2) = DAT_001273e8;\n    DAT_001273e8 = p_Var2;\n    return p_Var6;\n  }\n  *(__gid_t **)(p_Var6 + 2) = DAT_001273e0;\n  DAT_001273e0 = p_Var6;\n  return (__gid_t *)0x0;\n}\n\n",
  "FUN_001075e0": "\nvoid FUN_001075e0(void)\n\n{\n  if (DAT_00127218 == 0) {\n    DAT_00127214 = DAT_00127214 + 1;\n  }\n  return;\n}\n\n",
  "FUN_00117bb0": "\nvoid FUN_00117bb0(void)\n\n{\n  long lVar1;\n  long *in_R8;\n  long lVar2;\n  \n  lVar2 = 0;\n  lVar1 = *in_R8;\n  while (lVar1 != 0) {\n    lVar2 = lVar2 + 1;\n    lVar1 = in_R8[lVar2];\n  }\n  FUN_00117920();\n  return;\n}\n\n",
  "FUN_00107ed0": "\nlong FUN_00107ed0(undefined8 *param_1)\n\n{\n  char cVar1;\n  long lVar2;\n  size_t sVar3;\n  char *pcVar4;\n  long lVar5;\n  long in_FS_OFFSET;\n  undefined auStack_2b8 [664];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_001272fc == '\\0') {\n    lVar5 = 0;\nLAB_00107fa2:\n    if (DAT_0012732c != '\\0') {\n      if (DAT_00127338 != 4) goto LAB_00107f21;\n      lVar2 = 2;\n      if (*(char *)(param_1 + 0x17) != '\\0') {\n        pcVar4 = (char *)FUN_001111e0(param_1[0xb],auStack_2b8,DAT_00127328,0x200,DAT_00127320);\n        sVar3 = strlen(pcVar4);\n        lVar2 = sVar3 + 1;\n      }\nLAB_00107f2c:\n      lVar5 = lVar5 + lVar2;\n    }\n    if (DAT_00127365 != '\\0') {\n      if (DAT_00127338 == 4) {\n        sVar3 = strlen((char *)param_1[0x16]);\n      }\n      else {\nLAB_00108009:\n        sVar3 = (size_t)DAT_00127354;\n      }\n      lVar5 = lVar5 + sVar3 + 1;\n      lVar2 = param_1[0x19];\n      goto joined_r0x00108021;\n    }\n  }\n  else {\n    if (DAT_00127338 == 4) {\n      pcVar4 = (char *)FUN_001123c0(param_1[4],auStack_2b8);\n      sVar3 = strlen(pcVar4);\n      lVar5 = sVar3 + 1;\n      goto LAB_00107fa2;\n    }\n    lVar5 = (long)DAT_00127360 + 1;\n    if (DAT_0012732c != '\\0') {\nLAB_00107f21:\n      lVar2 = (long)DAT_0012735c + 1;\n      goto LAB_00107f2c;\n    }\n    if (DAT_00127365 != '\\0') goto LAB_00108009;\n  }\n  lVar2 = param_1[0x19];\njoined_r0x00108021:\n  if (lVar2 == 0) {\n    lVar2 = FUN_00107e30(*param_1,DAT_001272d0,*(undefined4 *)((long)param_1 + 0xc4));\n  }\n  lVar5 = lVar5 + lVar2;\n  if (DAT_00127314 != 0) {\n    cVar1 = FUN_00107670(*(undefined *)(param_1 + 0x17),*(undefined4 *)(param_1 + 6),\n                         *(undefined4 *)(param_1 + 0x15));\n    lVar5 = (lVar5 + 1) - (ulong)(cVar1 == '\\0');\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return lVar5;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00109160": "\nvoid FUN_00109160(char **param_1,char **param_2)\n\n{\n  int *piVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 = param_1[0x19];\n  if (pcVar3 == (char *)0x0) {\n    pcVar3 = (char *)FUN_00107e30(*param_1,DAT_001272d0,*(undefined4 *)((long)param_1 + 0xc4));\n  }\n  pcVar2 = param_2[0x19];\n  if (pcVar2 == (char *)0x0) {\n    pcVar2 = (char *)FUN_00107e30(*param_2,DAT_001272d0,*(undefined4 *)((long)param_2 + 0xc4));\n  }\n  if ((int)pcVar3 == (int)pcVar2) {\n    piVar1 = __errno_location();\n    pcVar3 = *param_1;\n    pcVar2 = *param_2;\n    *piVar1 = 0;\n    strcoll(pcVar3,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001171a0": "\nint FUN_001171a0(undefined8 param_1,char **param_2)\n\n{\n  char *__s1;\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  \n  iVar1 = lgetfilecon();\n  if (iVar1 == 0) {\n    piVar3 = __errno_location();\n    iVar1 = -1;\n    *piVar3 = 0x5f;\n  }\n  else if (iVar1 == 10) {\n    __s1 = *param_2;\n    iVar2 = strcmp(__s1,\"unlabeled\");\n    if (iVar2 == 0) {\n      iVar1 = -1;\n      freecon(__s1);\n      *param_2 = (char *)0x0;\n      piVar3 = __errno_location();\n      *piVar3 = 0x3d;\n    }\n  }\n  return iVar1;\n}\n\n",
  "FUN_00106cc0": "\nvoid FUN_00106cc0(undefined8 param_1)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 = (undefined8 *)FUN_00117e10(0x10);\n  *puVar1 = param_1;\n  puVar1[1] = DAT_001272e8;\n  DAT_001272e8 = puVar1;\n  return;\n}\n\n",
  "FUN_001196e0": "\nulong FUN_001196e0(uint *param_1,byte *param_2,long param_3,undefined *param_4)\n\n{\n  char cVar1;\n  ulong uVar2;\n  long lVar3;\n  bool bVar4;\n  \n  bVar4 = param_2 == (byte *)0x0;\n  lVar3 = param_3;\n  if (bVar4) {\n    param_1 = (uint *)0x0;\n    param_2 = &DAT_0011bdd5;\n    lVar3 = 1;\n  }\n  if (param_4 == (undefined *)0x0) {\n    param_4 = &DAT_00127568;\n  }\n  uVar2 = mbrtoc32(param_1,param_2,lVar3,param_4);\n  if ((((0xfffffffffffffffd < uVar2) && (bVar4 || param_3 != 0)) &&\n      (cVar1 = FUN_0010fea0(0), cVar1 == '\\0')) && (uVar2 = 1, param_1 != (uint *)0x0)) {\n    *param_1 = (uint)*param_2;\n  }\n  return uVar2;\n}\n\n",
  "malloc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_malloc_00125fd8)();\n  return pvVar1;\n}\n\n",
  "FUN_0010b2a0": "\nint FUN_0010b2a0(char **param_1,char **param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar1 == 9 || iVar1 == 3) goto LAB_0010b320;\n    iVar1 = 1;\n  }\n  else {\n    if (iVar1 == 9 || iVar1 == 3) {\n      return -1;\n    }\n    iVar1 = 0;\n  }\n  iVar1 = iVar1 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar1 != 0) {\n    return iVar1;\n  }\nLAB_0010b320:\n  iVar1 = strcmp(*param_2,*param_1);\n  return iVar1;\n}\n\n",
  "FUN_0010ea30": "\nvoid FUN_0010ea30(char *param_1)\n\n{\n  long lVar1;\n  ulong uVar2;\n  \n  uVar2 = strlen(param_1);\n  do {\n    if (uVar2 < 2) {\n      return;\n    }\n    lVar1 = uVar2 - 1;\n    uVar2 = uVar2 - 1;\n  } while (param_1[lVar1] == '/');\n  return;\n}\n\n",
  "FUN_00114f20": "\n/* WARNING: Type propagation algorithm not settling */\n\nulong FUN_00114f20(undefined *param_1,ulong param_2,char *param_3,ulong param_4,uint param_5,\n                  uint param_6,long param_7,char *param_8,char *param_9)\n\n{\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  int iVar6;\n  ushort **ppuVar7;\n  long lVar8;\n  ulong uVar9;\n  char cVar10;\n  ulong uVar11;\n  byte *pbVar12;\n  ulong uVar13;\n  ulong uVar14;\n  byte bVar15;\n  uint uVar16;\n  ulong uVar17;\n  bool bVar18;\n  ulong uVar19;\n  ulong uVar20;\n  bool bVar21;\n  long in_FS_OFFSET;\n  bool bVar22;\n  bool bVar23;\n  bool bVar24;\n  ulong local_f0;\n  long local_e0;\n  bool local_c9;\n  size_t local_c8;\n  char *local_a0;\n  ulong local_98;\n  size_t local_90;\n  uint local_80;\n  bool local_7c;\n  char *local_70;\n  char *local_68;\n  wint_t local_4c;\n  mbstate_t local_48;\n  long local_40;\n  \n  local_e0 = param_7;\n  local_68 = param_8;\n  local_70 = param_9;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_f0 = param_4;\n  local_80 = param_6;\nLAB_00114f90:\n  local_90 = __ctype_get_mb_cur_max();\n  uVar16 = local_80 & 2;\n  switch(param_5) {\n  case 0:\n    local_c9 = false;\n    bVar21 = false;\n    uVar13 = 0;\n    local_c8 = 0;\n    local_a0 = (char *)0x0;\n    break;\n  case 2:\n    if (uVar16 == 0) {\n      bVar21 = false;\n      goto LAB_00115532;\n    }\n    local_c9 = true;\n    bVar21 = false;\n    uVar13 = 0;\n    local_c8 = 1;\n    local_a0 = \"\\'\";\n    break;\n  case 3:\n    bVar21 = true;\nLAB_001153cd:\n    local_c9 = true;\n    uVar13 = 0;\n    param_5 = 2;\n    local_c8 = 1;\n    local_a0 = \"\\'\";\n    break;\n  case 4:\n    if (uVar16 == 0) {\n      bVar21 = true;\n      goto LAB_00115532;\n    }\n  case 1:\n    bVar21 = false;\n    goto LAB_001153cd;\n  case 5:\n    if (uVar16 == 0) goto LAB_00115370;\n    local_c9 = true;\n    bVar21 = true;\n    uVar13 = 0;\n    local_c8 = 1;\n    local_a0 = \"\\\"\";\n    break;\n  case 6:\n    local_c9 = true;\n    uVar13 = 0;\n    bVar21 = true;\n    local_c8 = 1;\n    param_5 = 5;\n    local_a0 = \"\\\"\";\n    break;\n  case 7:\n    local_c9 = false;\n    bVar21 = true;\n    uVar13 = 0;\n    local_c8 = 0;\n    local_a0 = (char *)0x0;\n    break;\n  case 8:\n  case 9:\n  case 10:\n    if (param_5 != 10) {\n      local_68 = (char *)FUN_00114e40(&DAT_0011e987,param_5);\n      local_70 = (char *)FUN_00114e40(\"\\'\");\n    }\n    uVar13 = 0;\n    if (uVar16 == 0) {\n      cVar10 = *local_68;\n      while (cVar10 != '\\0') {\n        if (uVar13 < param_2) {\n          param_1[uVar13] = cVar10;\n        }\n        uVar13 = uVar13 + 1;\n        cVar10 = local_68[uVar13];\n      }\n    }\n    local_c9 = uVar16 != 0;\n    bVar21 = true;\n    local_c8 = strlen(local_70);\n    local_a0 = local_70;\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  bVar4 = true;\n  bVar5 = false;\n  local_7c = false;\n  local_98 = 0;\nLAB_00115068:\n  uVar19 = 0;\n  uVar20 = param_2;\nLAB_00115070:\n  param_2 = local_98;\n  bVar22 = local_f0 != uVar19;\n  if (local_f0 == 0xffffffffffffffff) {\n    bVar22 = param_3[uVar19] != '\\0';\n  }\n  if (bVar22 == false) {\n    if ((uVar13 == 0 & local_c9 & param_5 == 2) != 0) {\njoined_r0x0011626f:\n      if (bVar21 != false) goto LAB_0011550a;\n      bVar21 = false;\n      local_80 = local_80 & 0xfffffffd;\n      local_90 = __ctype_get_mb_cur_max();\n      local_e0 = 0;\n      param_2 = uVar20;\n      goto LAB_00115532;\n    }\n    bVar3 = (bool)(param_5 == 2 & (local_c9 ^ 1U));\n    bVar22 = (bool)(local_c9 ^ 1U);\n    if ((bVar3 != false) && (bVar22 = bVar3, local_7c != false)) {\n      if (bVar4 != false) {\n        uVar13 = 0;\n        param_5 = 5;\n        local_90 = __ctype_get_mb_cur_max();\n        local_c8 = 1;\n        local_a0 = \"\\\"\";\n        if ((local_80 & 2) == 0) {\nLAB_00115370:\n          local_c9 = false;\n          uVar13 = 1;\n          bVar5 = false;\n          local_a0 = \"\\\"\";\n          param_5 = 5;\n          bVar21 = true;\n          local_c8 = 1;\n          local_7c = false;\n          bVar4 = true;\n          local_98 = 0;\n          if (param_2 != 0) {\n            *param_1 = 0x22;\n          }\n        }\n        else {\n          local_7c = false;\n          bVar5 = false;\n          local_98 = 0;\n          local_c9 = bVar4;\n          bVar21 = bVar4;\n        }\n        goto LAB_00115068;\n      }\n      bVar3 = uVar20 == 0 && local_98 != 0;\n      bVar22 = local_7c;\n      if (uVar20 == 0 && local_98 != 0) goto LAB_00115d7e;\n    }\n    uVar19 = uVar13;\n    if (((local_a0 != (char *)0x0) && (bVar22 != false)) && (cVar10 = *local_a0, cVar10 != '\\0')) {\n      do {\n        if (uVar19 < uVar20) {\n          param_1[uVar19] = cVar10;\n        }\n        uVar19 = uVar19 + 1;\n        cVar10 = local_a0[uVar19 - uVar13];\n      } while (cVar10 != '\\0');\n    }\n    if (uVar19 < uVar20) {\n      param_1[uVar19] = 0;\n    }\n    if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    return uVar19;\n  }\n  bVar2 = (bool)(param_5 != 2 & bVar21);\n  pbVar12 = (byte *)(param_3 + uVar19);\n  uVar14 = uVar13;\n  bVar18 = bVar2;\n  bVar3 = bVar5;\n  bVar23 = bVar21;\n  bVar24 = bVar21;\n  if (bVar2 != false) {\n    bVar1 = local_c9;\n    if (local_c8 == 0) {\nLAB_00115ae0:\n      bVar15 = *pbVar12;\n      uVar17 = (ulong)bVar15;\n      uVar11 = uVar17;\n      if ('?' < (char)bVar15) {\n        if ('z' < (char)bVar15) {\n          if (bVar15 == 0x7d) {\n            uVar11 = 0x7d;\n            bVar2 = false;\n          }\n          else {\n            if ('}' < (char)bVar15) {\n              bVar18 = false;\n              if (bVar15 == 0x7e) goto LAB_00115c08;\n              goto switchD_00115b0f_caseD_1;\n            }\n            uVar11 = 0x7b;\n            bVar2 = false;\n            bVar18 = false;\n            if (bVar15 != 0x7b) {\n              uVar11 = 0x7c;\n              bVar2 = false;\n              if (bVar15 != 0x7c) goto switchD_0011518a_caseD_1;\n              goto LAB_00115ad0;\n            }\n          }\nLAB_00115ab2:\n          bVar18 = bVar2;\n          if (local_f0 == 0xffffffffffffffff) goto LAB_00115c5f;\nLAB_00115ac0:\n          bVar2 = bVar18;\n          if (local_f0 == 1) goto LAB_00115641;\nLAB_00115ad0:\n          bVar23 = param_5 == 2;\n          bVar22 = false;\n          goto LAB_00115329;\n        }\n        if (bVar15 == 0x40) goto switchD_00115b0f_caseD_1;\n        uVar9 = 1L << (bVar15 + 0xbf & 0x3f);\n        bVar18 = false;\n        if ((uVar9 & 0x3ffffff53ffffff) != 0) goto LAB_00115198;\n        bVar2 = false;\n        bVar18 = false;\n        if ((uVar9 & 0xa4000000) != 0) goto LAB_00115ad0;\nLAB_00115b84:\n        if ((char)uVar17 == '\\\\') {\n          if (((bVar21 & local_c9) != 0) && (local_c8 != 0)) goto LAB_00115baa;\n          bVar15 = 0x5c;\n          goto LAB_001154d2;\n        }\nswitchD_0011518a_caseD_1:\n        uVar11 = uVar17;\n        if (local_90 != 1) goto LAB_00115823;\nLAB_001152c0:\n        ppuVar7 = __ctype_b_loc();\n        uVar17 = 1;\n        bVar23 = (*(byte *)((long)*ppuVar7 + uVar11 * 2 + 1) & 0x40) == 0;\n        bVar22 = !bVar23;\n        bVar23 = (bool)(bVar23 & bVar21);\n        bVar18 = bVar2;\n        goto LAB_0011530e;\n      }\n      switch(uVar17) {\n      case 0:\n        goto switchD_00115b0f_caseD_0;\n      default:\nswitchD_00115b0f_caseD_1:\n        bVar2 = false;\n        goto switchD_0011518a_caseD_1;\n      case 7:\nswitchD_0011518a_caseD_7:\n        bVar15 = 0x61;\n        if (local_c9 == false) goto LAB_00115597;\n        goto LAB_001154ff;\n      case 8:\nswitchD_0011518a_caseD_8:\n        bVar15 = 0x62;\n        goto LAB_00115589;\n      case 9:\n        bVar2 = false;\nswitchD_0011518a_caseD_9:\n        uVar11 = 9;\n        bVar15 = 0x74;\n        goto LAB_00115668;\n      case 10:\nswitchD_0011518a_caseD_a:\n        bVar15 = 0x6e;\n        break;\n      case 0xb:\nswitchD_0011518a_caseD_b:\n        bVar15 = 0x76;\n        break;\n      case 0xc:\nswitchD_0011518a_caseD_c:\n        bVar15 = 0x66;\nLAB_00115589:\n        if (local_c9 != false) goto LAB_001154ff;\nLAB_00115597:\n        bVar22 = false;\n        goto LAB_0011521b;\n      case 0xd:\nswitchD_0011518a_caseD_d:\n        bVar15 = 0x72;\n        break;\n      case 0x20:\n        bVar18 = false;\nLAB_00115695:\n        uVar11 = 0x20;\n        goto LAB_00115198;\n      case 0x21:\n      case 0x22:\n      case 0x24:\n      case 0x26:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n        bVar2 = false;\n        bVar22 = false;\n        goto LAB_00115261;\n      case 0x23:\n        uVar11 = 0x23;\n        bVar2 = false;\n        goto LAB_00115641;\n      case 0x25:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n        bVar18 = false;\nLAB_00115198:\n        bVar23 = false;\n        goto LAB_001151a8;\n      case 0x27:\n        bVar18 = false;\n        goto switchD_0011518a_caseD_27;\n      case 0x3f:\n        bVar18 = false;\n        goto switchD_0011518a_caseD_3f;\n      }\n      goto LAB_001154d2;\n    }\n    if ((local_f0 == 0xffffffffffffffff) && (1 < local_c8)) {\n      local_f0 = strlen(param_3);\n    }\n    if ((local_f0 < uVar19 + local_c8) || (iVar6 = memcmp(pbVar12,local_a0,local_c8), iVar6 != 0))\n    goto LAB_00115ae0;\n    if (local_c9 == false) {\n      bVar15 = *pbVar12;\n      uVar17 = (ulong)bVar15;\n      uVar11 = uVar17;\n      if ((char)bVar15 < '@') {\n        switch(uVar17) {\n        case 0:\n          goto switchD_0011518a_caseD_0;\n        default:\n          goto switchD_0011518a_caseD_1;\n        case 7:\n          goto switchD_0011518a_caseD_7;\n        case 8:\n          goto switchD_0011518a_caseD_8;\n        case 9:\n          goto switchD_0011518a_caseD_9;\n        case 10:\n          goto switchD_0011518a_caseD_a;\n        case 0xb:\n          goto switchD_0011518a_caseD_b;\n        case 0xc:\n          goto switchD_0011518a_caseD_c;\n        case 0xd:\n          goto switchD_0011518a_caseD_d;\n        case 0x20:\n          goto LAB_00115695;\n        case 0x21:\n        case 0x22:\n        case 0x24:\n        case 0x26:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x3b:\n        case 0x3c:\n        case 0x3d:\n        case 0x3e:\n          goto switchD_0011518a_caseD_21;\n        case 0x23:\n          goto switchD_0011518a_caseD_23;\n        case 0x25:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x2f:\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n          break;\n        case 0x27:\n          goto switchD_0011518a_caseD_27;\n        case 0x3f:\n          goto switchD_0011518a_caseD_3f;\n        }\n        goto LAB_00115198;\n      }\n      if ((char)bVar15 < '{') {\n        if (bVar15 == 0x40) goto switchD_0011518a_caseD_1;\n        uVar9 = 1L << (bVar15 + 0xbf & 0x3f);\n        if ((uVar9 & 0x3ffffff53ffffff) != 0) goto LAB_00115198;\n        if ((uVar9 & 0xa4000000) == 0) goto LAB_00115b84;\n        goto LAB_00115ad0;\n      }\n      if (bVar15 == 0x7d) goto LAB_00115c50;\n      if ((char)bVar15 < '~') {\n        uVar11 = 0x7b;\n        if (bVar15 == 0x7b) goto LAB_00115ab2;\n        uVar11 = 0x7c;\n        if (bVar15 == 0x7c) goto LAB_00115ad0;\n        goto switchD_0011518a_caseD_1;\n      }\n      if (bVar15 != 0x7e) goto switchD_0011518a_caseD_1;\nLAB_00115c08:\n      if (uVar19 == 0) {\n        bVar23 = param_5 == 2;\n        uVar11 = 0x7e;\n        bVar22 = bVar2;\n        goto LAB_00115329;\n      }\n      uVar11 = 0x7e;\nLAB_00115c16:\n      bVar23 = param_5 == 2;\n      bVar22 = false;\n      goto LAB_00115329;\n    }\n    goto LAB_00115296;\n  }\n  bVar15 = *pbVar12;\n  uVar17 = (ulong)bVar15;\n  uVar11 = uVar17;\n  if ('?' < (char)bVar15) {\n    if ('z' < (char)bVar15) {\n      if (bVar15 == 0x7d) {\nLAB_00115c50:\n        uVar11 = 0x7d;\n        if (local_f0 != 0xffffffffffffffff) goto LAB_00115ac0;\nLAB_00115c5f:\n        bVar2 = bVar18;\n        if (param_3[1] != '\\0') goto LAB_00115ad0;\n        goto LAB_00115641;\n      }\n      if ((char)bVar15 < '~') {\n        uVar11 = 0x7b;\n        if (bVar15 != 0x7b) {\n          if (bVar15 == 0x7c) goto switchD_0011518a_caseD_21;\n          goto switchD_0011518a_caseD_1;\n        }\n        goto LAB_00115ab2;\n      }\n      uVar11 = 0x7e;\n      if (bVar15 == 0x7e) goto LAB_00115641;\n      uVar11 = uVar17;\n      if (local_90 == 1) goto LAB_001152c0;\nLAB_00115823:\n      local_48.__count = 0;\n      local_48.__value = (_union_27)0x0;\n      if (local_f0 == 0xffffffffffffffff) {\n        local_f0 = strlen(param_3);\n      }\n      uVar17 = 0;\n      do {\n        uVar9 = uVar19 + uVar17;\n        lVar8 = FUN_001196e0(&local_4c,param_3 + uVar9,local_f0 - uVar9,&local_48);\n        if (lVar8 == 0) break;\n        if (lVar8 == -1) {\n          bVar22 = false;\n          goto LAB_00115968;\n        }\n        if (lVar8 == -2) goto joined_r0x001160bb;\n        if (lVar8 != -3) {\n          if ((param_5 == 2) && (local_c9 != false)) {\n            if (lVar8 == 1) {\n              uVar17 = uVar17 + 1;\n              goto LAB_00115908;\n            }\n            pbVar12 = (byte *)(param_3 + uVar9 + 1);\n            do {\n              if (((byte)(*pbVar12 - 0x5b) < 0x22) &&\n                 ((0x20000002bU >> ((ulong)(*pbVar12 - 0x5b) & 0x3f) & 1) != 0))\n              goto joined_r0x0011626f;\n              pbVar12 = pbVar12 + 1;\n            } while ((byte *)(param_3 + uVar9 + lVar8) != pbVar12);\n          }\n          uVar17 = uVar17 + lVar8;\n        }\nLAB_00115908:\n        iVar6 = iswprint(local_4c);\n        if (iVar6 == 0) {\n          bVar22 = false;\n        }\n        iVar6 = mbsinit(&local_48);\n      } while (iVar6 == 0);\n      bVar23 = (bool)((bVar22 ^ 1U) & bVar21);\n      goto LAB_00115968;\n    }\n    if (bVar15 == 0x40) goto switchD_0011518a_caseD_1;\n    uVar9 = 1L << (bVar15 + 0xbf & 0x3f);\n    if ((uVar9 & 0x3ffffff53ffffff) != 0) goto LAB_00115327;\n    if ((uVar9 & 0xa4000000) != 0) goto switchD_0011518a_caseD_21;\n    if (bVar15 != 0x5c) goto switchD_0011518a_caseD_1;\n    if (param_5 == 2) {\n      if (local_c9 != false) goto joined_r0x00115290;\n    }\n    else if ((bVar21 & local_c9 & local_c8 != 0) == 0) {\n      uVar11 = 0x5c;\n      bVar15 = 0x5c;\n      bVar2 = false;\n      goto LAB_00115668;\n    }\nLAB_00115baa:\n    uVar19 = uVar19 + 1;\n    bVar22 = false;\n    bVar15 = 0x5c;\n    goto LAB_00115bc0;\n  }\n  switch(bVar15) {\n  case 0:\n    if (bVar21 == false) {\n      bVar2 = false;\n      uVar11 = 0;\n      if ((local_80 & 1) != 0) goto code_r0x0011572f;\n      goto LAB_00115673;\n    }\nswitchD_00115b0f_caseD_0:\n    if (local_c9 == false) {\n      bVar18 = false;\nswitchD_0011518a_caseD_0:\n      bVar24 = param_5 == 2;\n      bVar3 = (bool)((bVar5 ^ 1U) & bVar24);\n      if (bVar3 == false) {\n        if (uVar13 < uVar20) goto LAB_00115e3b;\n      }\n      else {\n        if (uVar13 < uVar20) {\n          param_1[uVar13] = 0x27;\n        }\n        if (uVar13 + 1 < uVar20) {\n          param_1[uVar13 + 1] = 0x24;\n        }\n        if (uVar13 + 2 < uVar20) {\n          param_1[uVar13 + 2] = 0x27;\n        }\n        uVar14 = uVar13 + 3;\n        bVar5 = bVar3;\n        if (uVar20 <= uVar13 + 3) {\n          bVar15 = 0x30;\n          uVar13 = uVar13 + 4;\n          bVar23 = bVar3;\n          bVar22 = false;\n          goto joined_r0x00115353;\n        }\nLAB_00115e3b:\n        param_1[uVar14] = 0x5c;\n        uVar13 = uVar14;\n      }\n      uVar14 = uVar13 + 1;\n      if (param_5 != 2) {\n        uVar11 = 0x30;\n        if ((uVar19 + 1 < local_f0) && ((byte)(param_3[uVar19 + 1] - 0x30U) < 10)) {\n          if (uVar14 < uVar20) {\n            param_1[uVar14] = 0x30;\n          }\n          if (uVar13 + 2 < uVar20) {\n            param_1[uVar13 + 2] = 0x30;\n          }\n          uVar14 = uVar13 + 3;\n          uVar11 = 0x30;\n        }\n        goto LAB_00115e7a;\n      }\n      bVar15 = 0x30;\n      uVar13 = uVar14;\n      bVar3 = bVar5;\n      bVar23 = bVar22;\n      bVar22 = false;\n      goto joined_r0x00115353;\n    }\n    if (param_5 != 2) goto LAB_00115296;\n    goto LAB_0011550a;\n  default:\n    goto switchD_0011518a_caseD_1;\n  case 7:\n    uVar11 = 7;\n    bVar15 = 0x61;\n    break;\n  case 8:\n    uVar11 = 8;\n    bVar15 = 0x62;\n    break;\n  case 9:\n    uVar11 = 9;\n    bVar15 = 0x74;\n    goto LAB_001156ec;\n  case 10:\n    uVar11 = 10;\n    bVar15 = 0x6e;\n    goto LAB_001156ec;\n  case 0xb:\n    uVar11 = 0xb;\n    bVar15 = 0x76;\n    break;\n  case 0xc:\n    uVar11 = 0xc;\n    bVar15 = 0x66;\n    break;\n  case 0xd:\n    goto switchD_001156d3_caseD_d;\n  case 0x20:\n    uVar11 = 0x20;\n    goto LAB_00115261;\n  case 0x21:\n  case 0x22:\n  case 0x24:\n  case 0x26:\n  case 0x28:\n  case 0x29:\n  case 0x2a:\n  case 0x3b:\n  case 0x3c:\n  case 0x3d:\n  case 0x3e:\nswitchD_0011518a_caseD_21:\n    bVar22 = false;\n    uVar11 = uVar17;\n    goto LAB_00115261;\n  case 0x23:\nswitchD_0011518a_caseD_23:\n    uVar11 = 0x23;\nLAB_00115641:\n    bVar18 = bVar2;\n    if (uVar19 != 0) goto LAB_00115c16;\nLAB_00115261:\n    bVar18 = bVar2;\n    if ((param_5 == 2) && (local_c9 != false)) goto LAB_00115279;\n  case 0x25:\n  case 0x2b:\n  case 0x2c:\n  case 0x2d:\n  case 0x2e:\n  case 0x2f:\n  case 0x30:\n  case 0x31:\n  case 0x32:\n  case 0x33:\n  case 0x34:\n  case 0x35:\n  case 0x36:\n  case 0x37:\n  case 0x38:\n  case 0x39:\n  case 0x3a:\n    goto LAB_00115327;\n  case 0x27:\nswitchD_0011518a_caseD_27:\n    local_7c = bVar22;\n    if (param_5 != 2) {\n      bVar23 = false;\n      uVar11 = 0x27;\n      goto LAB_00115329;\n    }\n    if (local_c9 == false) {\n      if ((uVar20 == 0) || (uVar14 = 0, uVar11 = uVar20, local_98 != 0)) {\n        if (uVar13 < uVar20) {\n          param_1[uVar13] = 0x27;\n        }\n        if (uVar13 + 1 < uVar20) {\n          param_1[uVar13 + 1] = 0x5c;\n        }\n        uVar14 = uVar20;\n        uVar11 = local_98;\n        if (uVar13 + 2 < uVar20) {\n          param_1[uVar13 + 2] = 0x27;\n        }\n      }\n      bVar15 = 0x27;\n      uVar13 = uVar13 + 3;\n      uVar20 = uVar14;\n      local_98 = uVar11;\n      bVar3 = false;\n      bVar23 = false;\n      goto joined_r0x00115353;\n    }\n    goto joined_r0x00115290;\n  case 0x3f:\nswitchD_0011518a_caseD_3f:\n    if (param_5 != 2) {\n      if ((((param_5 != 5) || ((local_80 & 4) == 0)) || (uVar17 = uVar19 + 2, local_f0 <= uVar17))\n         || (param_3[uVar19 + 1] != '?')) {\nLAB_001154a0:\n        bVar23 = false;\n        bVar22 = false;\n        uVar11 = 0x3f;\n        goto LAB_00115329;\n      }\n      bVar15 = param_3[uVar17];\n      uVar11 = (ulong)bVar15;\n      if (0x3e < bVar15) goto LAB_001154a0;\n      uVar9 = 0x7000a38200000000 >> (bVar15 & 0x3f);\n      bVar23 = (bool)((byte)uVar9 & 1);\n      if ((uVar9 & 1) == 0) {\n        bVar22 = false;\n        uVar11 = 0x3f;\n        goto LAB_00115329;\n      }\n      if (local_c9 == false) {\n        if (uVar13 < uVar20) {\n          param_1[uVar13] = 0x3f;\n        }\n        if (uVar13 + 1 < uVar20) {\n          param_1[uVar13 + 1] = 0x22;\n        }\n        if (uVar13 + 2 < uVar20) {\n          param_1[uVar13 + 2] = 0x22;\n        }\n        if (uVar13 + 3 < uVar20) {\n          param_1[uVar13 + 3] = 0x3f;\n        }\n        uVar14 = uVar13 + 4;\n        bVar24 = false;\n        bVar22 = false;\n        uVar19 = uVar17;\nLAB_00115e7a:\n        bVar15 = (byte)uVar11;\n        bVar2 = false;\n        bVar23 = bVar22;\n        uVar13 = uVar14;\n        bVar3 = bVar5;\n        bVar22 = bVar2;\n        if ((byte)(bVar21 ^ 1U | bVar24) != 0) goto joined_r0x00115353;\n        goto LAB_001151a8;\n      }\n      goto LAB_00115296;\n    }\n    if (local_c9 == false) {\n      bVar15 = 0x3f;\n      bVar23 = false;\n      bVar22 = false;\n      goto joined_r0x00115353;\n    }\n    goto joined_r0x00115290;\n  }\nLAB_00115668:\n  if (bVar21 == false) {\nLAB_00115673:\n    bVar15 = (byte)uVar11;\n    bVar18 = bVar2;\n    bVar2 = false;\n    goto joined_r0x00115340;\n  }\nLAB_001154d2:\n  bVar22 = false;\n  goto joined_r0x001154e3;\nswitchD_001156d3_caseD_d:\n  uVar11 = 0xd;\n  bVar15 = 0x72;\nLAB_001156ec:\n  bVar2 = (bool)(param_5 == 2 & local_c9);\n  if (bVar2 == false) goto LAB_00115668;\nLAB_00115279:\n  param_5 = 2;\njoined_r0x00115290:\n  if (bVar24 != false) goto LAB_0011550a;\nLAB_00115296:\n  local_80 = local_80 & 0xfffffffd;\n  local_e0 = 0;\n  param_2 = uVar20;\n  goto LAB_00114f90;\njoined_r0x001160bb:\n  while ((uVar9 < local_f0 && (param_3[uVar9] != '\\0'))) {\n    uVar17 = uVar17 + 1;\n    uVar9 = uVar19 + uVar17;\n  }\n  bVar22 = false;\nLAB_00115968:\n  bVar18 = bVar2;\n  if (1 < uVar17) {\nLAB_00115972:\n    bVar18 = false;\n    uVar17 = uVar17 + uVar19;\n    uVar14 = uVar19;\n    do {\n      bVar15 = (byte)uVar11;\n      if (bVar23 == false) {\n        bVar5 = (bool)((bVar18 ^ 1U) & bVar3);\n        if (bVar2 != false) {\n          if (uVar13 < uVar20) {\n            param_1[uVar13] = 0x5c;\n          }\n          uVar13 = uVar13 + 1;\n        }\n        uVar19 = uVar14 + 1;\n        if (uVar17 <= uVar19) goto LAB_00115bc0;\n        if (bVar5 == false) {\n          bVar2 = false;\n          bVar5 = bVar3;\n        }\n        else {\n          if (uVar13 < uVar20) {\n            param_1[uVar13] = 0x27;\n          }\n          if (uVar13 + 1 < uVar20) {\n            param_1[uVar13 + 1] = 0x27;\n          }\n          uVar13 = uVar13 + 2;\n          bVar2 = false;\n          bVar5 = false;\n        }\n      }\n      else {\n        bVar24 = param_5 == 2;\n        if (local_c9 != false) goto joined_r0x00115290;\n        bVar24 = (bool)((bVar3 ^ 1U) & bVar24);\n        bVar5 = bVar3;\n        if (bVar24 != false) {\n          if (uVar13 < uVar20) {\n            param_1[uVar13] = 0x27;\n          }\n          if (uVar13 + 1 < uVar20) {\n            param_1[uVar13 + 1] = 0x24;\n          }\n          if (uVar13 + 2 < uVar20) {\n            param_1[uVar13 + 2] = 0x27;\n          }\n          uVar13 = uVar13 + 3;\n          bVar5 = bVar24;\n        }\n        if (uVar13 < uVar20) {\n          param_1[uVar13] = 0x5c;\n        }\n        if (uVar13 + 1 < uVar20) {\n          param_1[uVar13 + 1] = (char)(uVar11 >> 6) + '0';\n        }\n        if (uVar13 + 2 < uVar20) {\n          param_1[uVar13 + 2] = ((byte)(uVar11 >> 3) & 7) + 0x30;\n        }\n        uVar19 = uVar14 + 1;\n        uVar13 = uVar13 + 3;\n        bVar15 = (bVar15 & 7) + 0x30;\n        bVar18 = bVar23;\n        if (uVar17 <= uVar19) goto LAB_0011522e;\n      }\n      uVar14 = uVar14 + 1;\n      if (uVar13 < uVar20) {\n        param_1[uVar13] = bVar15;\n      }\n      uVar11 = (ulong)(byte)param_3[uVar14];\n      uVar13 = uVar13 + 1;\n      bVar3 = bVar5;\n    } while( true );\n  }\nLAB_0011530e:\n  if (bVar23 != false) {\n    bVar22 = false;\n    bVar23 = bVar21;\n    bVar2 = bVar18;\n    goto LAB_00115972;\n  }\nLAB_00115327:\n  bVar23 = param_5 == 2;\nLAB_00115329:\n  bVar15 = (byte)uVar11;\n  bVar23 = (bool)(bVar23 | bVar21 ^ 1U);\n  bVar2 = bVar22;\n  if (bVar23 == false) {\nLAB_001151a8:\n    bVar15 = (byte)uVar11;\n    uVar13 = uVar14;\n    bVar3 = bVar5;\n    bVar22 = bVar2;\n    if ((local_e0 == 0) || ((*(uint *)(local_e0 + (uVar11 >> 5) * 4) >> (bVar15 & 0x1f) & 1) == 0))\n    goto joined_r0x00115353;\n  }\n  else {\njoined_r0x00115340:\n    bVar23 = false;\n    if (local_c9 != false) goto LAB_001151a8;\n    bVar23 = false;\n    bVar22 = bVar2;\njoined_r0x00115353:\n    bVar5 = bVar3;\n    if (bVar18 == false) {\n      uVar19 = uVar19 + 1;\n      bVar5 = (bool)((bVar23 ^ 1U) & bVar3);\nLAB_00115bc0:\n      bVar2 = bVar5 != false;\n      bVar5 = bVar3;\n      if (bVar2) {\n        if (uVar13 < uVar20) {\n          param_1[uVar13] = 0x27;\n        }\n        if (uVar13 + 1 < uVar20) {\n          param_1[uVar13 + 1] = 0x27;\n        }\n        uVar13 = uVar13 + 2;\n        bVar5 = false;\n      }\n      goto LAB_0011522e;\n    }\n  }\njoined_r0x001154e3:\n  bVar1 = bVar21;\n  if (local_c9 != false) {\nLAB_001154ff:\n    bVar24 = (bool)(param_5 == 2 & bVar1);\n    goto joined_r0x00115290;\n  }\n  bVar3 = (bool)((bVar5 ^ 1U) & param_5 == 2);\n  if (bVar3 != false) {\n    if (uVar13 < uVar20) {\n      param_1[uVar13] = 0x27;\n    }\n    if (uVar13 + 1 < uVar20) {\n      param_1[uVar13 + 1] = 0x24;\n    }\n    if (uVar13 + 2 < uVar20) {\n      param_1[uVar13 + 2] = 0x27;\n    }\n    uVar13 = uVar13 + 3;\n    bVar5 = bVar3;\n  }\nLAB_0011521b:\n  if (uVar13 < uVar20) {\n    param_1[uVar13] = 0x5c;\n  }\n  uVar13 = uVar13 + 1;\n  uVar19 = uVar19 + 1;\nLAB_0011522e:\n  if (uVar13 < uVar20) {\n    param_1[uVar13] = bVar15;\n  }\n  uVar13 = uVar13 + 1;\n  if (bVar22 == false) {\n    bVar4 = false;\n  }\n  goto LAB_00115070;\ncode_r0x0011572f:\n  uVar19 = uVar19 + 1;\n  goto LAB_00115070;\nLAB_0011550a:\n  bVar21 = true;\n  local_80 = local_80 & 0xfffffffd;\n  local_90 = __ctype_get_mb_cur_max();\n  local_e0 = 0;\n  param_2 = uVar20;\nLAB_00115532:\n  local_c9 = false;\n  uVar13 = 1;\n  bVar5 = false;\n  local_a0 = \"\\'\";\n  param_5 = 2;\n  local_c8 = 1;\n  local_7c = false;\n  bVar4 = true;\n  if (param_2 == 0) {\n    local_98 = 0;\n  }\n  else {\n    local_98 = 0;\n    bVar3 = false;\nLAB_00115d7e:\n    uVar13 = 1;\n    param_5 = 2;\n    *param_1 = 0x27;\n    local_c9 = false;\n    local_c8 = 1;\n    local_a0 = \"\\'\";\n    local_7c = bVar3;\n  }\n  goto LAB_00115068;\n}\n\n",
  "FUN_00114e00": "\nundefined8 FUN_00114e00(undefined8 param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  \n  uVar2 = FUN_001196a0();\n  iVar1 = FUN_00119420(uVar2,\"UTF-8\");\n  if (iVar1 != 0) {\n    param_2 = param_1;\n  }\n  return param_2;\n}\n\n",
  "FUN_001107c0": "\nlong FUN_001107c0(long **param_1,code *param_2,undefined8 param_3)\n\n{\n  char cVar1;\n  long *plVar2;\n  long lVar3;\n  long lVar4;\n  long *plVar5;\n  \n  plVar5 = *param_1;\n  if (plVar5 < param_1[1]) {\n    lVar4 = 0;\n    do {\n      lVar3 = *plVar5;\n      plVar2 = plVar5;\n      if (lVar3 != 0) {\n        while( true ) {\n          cVar1 = (*param_2)(lVar3,param_3);\n          if (cVar1 == '\\0') {\n            return lVar4;\n          }\n          plVar2 = (long *)plVar2[1];\n          lVar4 = lVar4 + 1;\n          if (plVar2 == (long *)0x0) break;\n          lVar3 = *plVar2;\n        }\n      }\n      plVar5 = plVar5 + 2;\n    } while (plVar5 <= param_1[1] && param_1[1] != plVar5);\n  }\n  else {\n    lVar4 = 0;\n  }\n  return lVar4;\n}\n\n",
  "FUN_0010fd60": "\nundefined8 FUN_0010fd60(void **param_1)\n\n{\n  void *__size;\n  void *pvVar1;\n  int *piVar2;\n  \n  pvVar1 = param_1[1];\n  __size = (void *)((long)pvVar1 * 2);\n  if ((void **)*param_1 != param_1 + 2) {\n    free(*param_1);\n    pvVar1 = param_1[1];\n  }\n  if (__size < pvVar1) {\n    piVar2 = __errno_location();\n    *piVar2 = 0xc;\n  }\n  else {\n    pvVar1 = malloc((size_t)__size);\n    if (pvVar1 != (void *)0x0) {\n      *param_1 = pvVar1;\n      param_1[1] = __size;\n      return 1;\n    }\n  }\n  *param_1 = param_1 + 2;\n  param_1[1] = (void *)0x400;\n  return 0;\n}\n\n",
  "FUN_001086e0": "\nvoid FUN_001086e0(void)\n\n{\n  void **ppvVar1;\n  ulong uVar2;\n  \n  if (DAT_001273b0 != 0) {\n    uVar2 = 0;\n    do {\n      ppvVar1 = *(void ***)(DAT_001273a0 + uVar2 * 8);\n      free(*ppvVar1);\n      free(ppvVar1[1]);\n      free(ppvVar1[2]);\n      if ((undefined *)ppvVar1[0x16] != &DAT_0012602a) {\n        freecon();\n      }\n      uVar2 = uVar2 + 1;\n    } while (uVar2 < DAT_001273b0);\n  }\n  DAT_001273a9 = 0;\n  DAT_001273b0 = 0;\n  DAT_00127364 = 0;\n  DAT_00127360 = 0;\n  DAT_0012735c = 0;\n  DAT_00127358 = 0;\n  DAT_00127350 = 0;\n  DAT_0012734c = 0;\n  DAT_00127348 = 0;\n  DAT_00127354 = 0;\n  DAT_00127344 = 0;\n  DAT_00127340 = 0;\n  DAT_0012733c = 0;\n  return;\n}\n\n",
  "FUN_00108fd0": "\nvoid FUN_00108fd0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  pcVar1 = param_2[0xe];\n  pcVar2 = param_1[0xe];\n  pcVar3 = param_2[0xf];\n  pcVar4 = param_1[0xf];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_1[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_1[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    strcmp(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "rawmemchr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * rawmemchr(void *__s,int __c)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_rawmemchr_00125e20)();\n  return pvVar1;\n}\n\n",
  "FUN_001173f0": "\nundefined8 * FUN_001173f0(char *param_1)\n\n{\n  ulong __n;\n  size_t sVar1;\n  ulong uVar2;\n  undefined8 *puVar3;\n  \n  if (param_1 == (char *)0x0) {\n    puVar3 = (undefined8 *)malloc(0x80);\n    if (puVar3 != (undefined8 *)0x0) {\n      *puVar3 = 0;\n      *(undefined2 *)(puVar3 + 1) = 0;\n      return puVar3;\n    }\n  }\n  else {\n    sVar1 = strlen(param_1);\n    __n = sVar1 + 1;\n    uVar2 = 0x76;\n    if (0x75 < __n) {\n      uVar2 = __n;\n    }\n    puVar3 = (undefined8 *)malloc(uVar2 + 0x11 & 0xfffffffffffffff8);\n    if (puVar3 != (undefined8 *)0x0) {\n      *puVar3 = 0;\n      *(undefined2 *)(puVar3 + 1) = 1;\n      memcpy((void *)((long)puVar3 + 9),param_1,__n);\n      *(undefined *)((long)puVar3 + sVar1 + 10) = 0;\n    }\n  }\n  return puVar3;\n}\n\n",
  "FUN_0010abb0": "\nint FUN_0010abb0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  int iVar3;\n  \n  iVar3 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar3 == 9 || iVar3 == 3) goto LAB_0010ac30;\n    iVar3 = 1;\n  }\n  else {\n    if (iVar3 == 9 || iVar3 == 3) {\n      return -1;\n    }\n    iVar3 = 0;\n  }\n  iVar3 = iVar3 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar3 != 0) {\n    return iVar3;\n  }\nLAB_0010ac30:\n  pcVar1 = param_2[9];\n  pcVar2 = param_1[9];\n  iVar3 = (uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_1[9] != pcVar1 && (long)pcVar1 <= (long)pcVar2);\n  if (iVar3 != 0) {\n    return iVar3;\n  }\n  iVar3 = strcmp(*param_1,*param_2);\n  return iVar3;\n}\n\n",
  "FUN_00117900": "\nvoid FUN_00117900(long param_1)\n\n{\n  *(undefined4 *)(param_1 + 0x20) = 0;\n  FUN_00118e40(param_1,PTR_gmtime_r_00125fc0,&DAT_00127558);\n  return;\n}\n\n",
  "FUN_001183c0": "\nulong FUN_001183c0(undefined8 param_1,undefined4 param_2,ulong param_3,ulong param_4,\n                  undefined8 param_5,undefined8 param_6,int param_7)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  ulong local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_001186b0(param_1,0,param_2,&local_48);\n  if (iVar1 != 0) goto LAB_00118460;\n  if ((param_3 <= local_48) && (local_48 <= param_4)) {\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return local_48;\n    }\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  piVar2 = __errno_location();\n  *piVar2 = (-(uint)(local_48 < 0x40000000) & 0xffffffd7) + 0x4b;\n  do {\n    while( true ) {\n      if (param_7 == 0) {\n        param_7 = 1;\n      }\n      uVar3 = FUN_00117100(param_1);\n      iVar1 = *piVar2;\n      if (iVar1 == 0x16) {\n        iVar1 = 0;\n      }\n      iVar1 = error(param_7,iVar1,\"%s: %s\",param_6,uVar3);\nLAB_00118460:\n      piVar2 = __errno_location();\n      if (iVar1 == 1) break;\n      if (iVar1 == 3) {\n        *piVar2 = 0;\n      }\n    }\n    *piVar2 = 0x4b;\n  } while( true );\n}\n\n",
  "fflush": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fflush_00125ea0)();\n  return iVar1;\n}\n\n",
  "FUN_00117bd0": "\nvoid FUN_00117bd0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 uint *param_5)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long lVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  long local_68 [11];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar4 = 0;\n  do {\n    uVar1 = *param_5;\n    if (uVar1 < 0x30) {\n      *param_5 = uVar1 + 8;\n      lVar3 = *(long *)((ulong)uVar1 + *(long *)(param_5 + 4));\n      local_68[lVar4] = lVar3;\n    }\n    else {\n      plVar2 = *(long **)(param_5 + 2);\n      *(long **)(param_5 + 2) = plVar2 + 1;\n      lVar3 = *plVar2;\n      local_68[lVar4] = lVar3;\n    }\n  } while ((lVar3 != 0) && (lVar4 = lVar4 + 1, lVar4 != 10));\n  FUN_00117920(param_1,param_2,param_3,param_4);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "FUN_0010b3d0": "\nint FUN_0010b3d0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  iVar5 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar5 == 9 || iVar5 == 3) goto LAB_0010b450;\n    iVar5 = 1;\n  }\n  else {\n    if (iVar5 == 9 || iVar5 == 3) {\n      return -1;\n    }\n    iVar5 = 0;\n  }\n  iVar5 = iVar5 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar5 != 0) {\n    return iVar5;\n  }\nLAB_0010b450:\n  pcVar1 = param_2[0xe];\n  pcVar2 = param_1[0xe];\n  pcVar3 = param_2[0xf];\n  pcVar4 = param_1[0xf];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_1[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_1[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 != 0) {\n    return iVar5;\n  }\n  iVar5 = strcmp(*param_1,*param_2);\n  return iVar5;\n}\n\n",
  "_obstack_memory_used": "\nlong _obstack_memory_used(long param_1)\n\n{\n  long *plVar1;\n  long lVar2;\n  \n  lVar2 = 0;\n  for (plVar1 = *(long **)(param_1 + 8); plVar1 != (long *)0x0; plVar1 = (long *)plVar1[1]) {\n    lVar2 = lVar2 + (*plVar1 - (long)plVar1);\n  }\n  return lVar2;\n}\n\n",
  "getpwuid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\npasswd * getpwuid(__uid_t __uid)\n\n{\n  passwd *ppVar1;\n  \n  ppVar1 = (passwd *)(*(code *)PTR_getpwuid_00125d60)();\n  return ppVar1;\n}\n\n",
  "FUN_001195e0": "\nint FUN_001195e0(FILE *param_1,__off_t param_2,int param_3)\n\n{\n  int iVar1;\n  __off_t _Var2;\n  \n  if (((param_1->_IO_read_end == param_1->_IO_read_ptr) &&\n      (param_1->_IO_write_ptr == param_1->_IO_write_base)) &&\n     (param_1->_IO_save_base == (char *)0x0)) {\n    iVar1 = fileno(param_1);\n    _Var2 = lseek(iVar1,param_2,param_3);\n    if (_Var2 == -1) {\n      iVar1 = -1;\n    }\n    else {\n      param_1->_flags = param_1->_flags & 0xffffffef;\n      param_1->_offset = _Var2;\n      iVar1 = 0;\n    }\n    return iVar1;\n  }\n  iVar1 = fseeko(param_1,param_2,param_3);\n  return iVar1;\n}\n\n",
  "FUN_001184f0": "\nchar * FUN_001184f0(void)\n\n{\n  int iVar1;\n  uint *puVar2;\n  char *__name;\n  long lVar3;\n  size_t sVar4;\n  char *__ptr;\n  long in_FS_OFFSET;\n  long local_a0;\n  char local_98 [104];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  __name = local_98;\n  local_a0 = 100;\n  puVar2 = (uint *)__errno_location();\n  lVar3 = 100;\n  __ptr = (char *)0x0;\n  while( true ) {\n    __name[lVar3 + -1] = '\\0';\n    *puVar2 = 0;\n    iVar1 = gethostname(__name,lVar3 - 1U);\n    if (iVar1 == 0) {\n      sVar4 = strlen(__name);\n      if ((long)(sVar4 + 1) < (long)(lVar3 - 1U)) {\n        if (__ptr == (char *)0x0) {\n          __ptr = (char *)FUN_001182d0(__name,sVar4 + 1);\n        }\n        goto LAB_001185b6;\n      }\n      *puVar2 = 0;\n    }\n    free(__ptr);\n    if ((0x24 < *puVar2) || ((0xffffffefffbfeffeU >> ((ulong)*puVar2 & 0x3f) & 1) != 0)) break;\n    __name = (char *)FUN_001180f0(0,&local_a0,1,0xffffffffffffffff,1);\n    lVar3 = local_a0;\n    __ptr = __name;\n  }\n  __ptr = (char *)0x0;\nLAB_001185b6:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return __ptr;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "raise": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint raise(int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_raise_00125cb8)();\n  return iVar1;\n}\n\n",
  "FUN_00110b70": "\nundefined4 FUN_00110b70(void **param_1,undefined8 param_2)\n\n{\n  int iVar1;\n  void *pvVar2;\n  char cVar3;\n  undefined4 uVar4;\n  void *__nmemb;\n  int *piVar5;\n  long in_FS_OFFSET;\n  void *local_88;\n  void *local_80;\n  void *local_78;\n  void *local_70;\n  undefined8 local_68;\n  void *local_60;\n  void *local_58;\n  void *local_50;\n  void *local_48;\n  void *local_40;\n  long local_30;\n  \n  pvVar2 = param_1[5];\n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  __nmemb = (void *)FUN_001100f0(param_2,pvVar2);\n  if (__nmemb != (void *)0x0) {\n    if (param_1[2] == __nmemb) {\n      uVar4 = 1;\n      goto LAB_00110c86;\n    }\n    local_88 = calloc((size_t)__nmemb,0x10);\n    if (local_88 != (void *)0x0) {\n      local_80 = (void *)((long)local_88 + (long)__nmemb * 0x10);\n      local_58 = param_1[6];\n      local_70 = (void *)0x0;\n      local_50 = param_1[7];\n      local_68 = 0;\n      local_48 = param_1[8];\n      local_40 = param_1[9];\n      local_78 = __nmemb;\n      local_60 = pvVar2;\n      uVar4 = FUN_00110240(&local_88,param_1,0);\n      if ((char)uVar4 == '\\0') {\n        piVar5 = __errno_location();\n        iVar1 = *piVar5;\n        param_1[9] = local_40;\n        cVar3 = FUN_00110240(param_1,&local_88,1);\n        if (cVar3 != '\\0') {\n          cVar3 = FUN_00110240(param_1,&local_88,0);\n          if (cVar3 != '\\0') {\n            free(local_88);\n            *piVar5 = iVar1;\n            goto LAB_00110c86;\n          }\n        }\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n      free(*param_1);\n      *param_1 = local_88;\n      param_1[1] = local_80;\n      param_1[2] = local_78;\n      param_1[3] = local_70;\n      param_1[9] = local_40;\n      goto LAB_00110c86;\n    }\n  }\n  uVar4 = 0;\nLAB_00110c86:\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00112e70": "\n/* WARNING: Type propagation algorithm not settling */\n\nlong FUN_00112e70(undefined8 *param_1,long param_2,char *param_3,undefined8 *param_4,char param_5,\n                 uint param_6,int param_7,undefined8 param_8,int param_9)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  long lVar4;\n  char cVar5;\n  bool bVar6;\n  uint uVar7;\n  int *piVar8;\n  ulong uVar9;\n  __int32_t **pp_Var10;\n  long *plVar11;\n  byte bVar12;\n  long lVar13;\n  long lVar14;\n  char cVar15;\n  uint uVar16;\n  uint uVar17;\n  ulong uVar18;\n  size_t sVar19;\n  size_t sVar20;\n  char *pcVar21;\n  char cVar22;\n  char cVar23;\n  int iVar24;\n  char *pcVar25;\n  int iVar26;\n  char *pcVar27;\n  int iVar28;\n  uint uVar29;\n  uint uVar30;\n  char *__s;\n  long lVar31;\n  undefined8 *puVar32;\n  int iVar33;\n  ulong uVar34;\n  long in_FS_OFFSET;\n  bool bVar35;\n  ulong local_4c0;\n  size_t local_4b8;\n  int local_4a8;\n  undefined8 local_488;\n  undefined8 uStack_480;\n  undefined8 local_478;\n  long lStack_470;\n  undefined8 local_468;\n  undefined8 uStack_460;\n  undefined8 local_458;\n  undefined8 uStack_450;\n  undefined8 local_448;\n  char local_432 [1010];\n  long local_40;\n  \n  uVar34 = (ulong)param_7;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar8 = __errno_location();\n  __s = (char *)param_4[6];\n  uVar29 = *(uint *)(param_4 + 1);\n  iVar1 = *piVar8;\n  if (__s == (char *)0x0) {\n    __s = \"\";\n  }\n  if ((int)uVar29 < 0xd) {\n    if (uVar29 == 0) {\n      uVar29 = 0xc;\n    }\n  }\n  else {\n    uVar29 = uVar29 - 0xc;\n  }\n  cVar5 = *param_3;\n  lVar31 = 0;\njoined_r0x00112f03:\n  if (cVar5 != '\\0') {\n    pcVar21 = param_3;\n    if (cVar5 != '%') {\n      uVar9 = 0;\n      if (-1 < (int)uVar34) {\n        uVar9 = uVar34;\n      }\n      uVar18 = 1;\n      if (uVar9 != 0) {\n        uVar18 = uVar9;\n      }\n      if ((ulong)(param_2 - lVar31) <= uVar18) goto LAB_00112f90;\n      if (param_1 != (undefined8 *)0x0) {\n        puVar32 = param_1;\n        if (1 < (int)uVar34) {\n          puVar32 = (undefined8 *)((long)param_1 + (uVar9 - 1));\n          memset(param_1,0x20,uVar9 - 1);\n        }\n        param_1 = (undefined8 *)((long)puVar32 + 1);\n        *(char *)puVar32 = *param_3;\n      }\n      lVar31 = lVar31 + uVar18;\n      goto LAB_00112f58;\n    }\n    uVar7 = 0;\n    uVar17 = 0;\n    cVar5 = param_5;\n    do {\n      while( true ) {\n        do {\n          uVar30 = uVar17;\n          cVar15 = (char)uVar7;\n          pcVar27 = pcVar21 + 1;\n          uVar16 = (uint)*pcVar27;\n          pcVar21 = pcVar21 + 1;\n          bVar12 = *pcVar27 - 0x23;\n          if (0x3c < bVar12) goto LAB_00113063;\n          uVar9 = 1L << (bVar12 & 0x3f);\n          uVar17 = uVar16;\n        } while ((uVar9 & 0x1000000000002500) != 0);\n        uVar17 = uVar30;\n        if (bVar12 != 0x3b) break;\n        cVar5 = '\\x01';\n      }\n      uVar7 = (uint)uVar9 & 1;\n    } while ((uVar9 & 1) != 0);\nLAB_00113063:\n    if (uVar16 - 0x30 < 10) {\n      uVar34 = 0;\n      do {\n        lVar13 = (long)(int)uVar34 * 10;\n        iVar33 = (int)lVar13;\n        if ((iVar33 != lVar13) ||\n           (uVar34 = (ulong)(uint)(iVar33 + *pcVar21 + -0x30), SCARRY4(iVar33,*pcVar21 + -0x30))) {\n          uVar34 = 0x7fffffff;\n        }\n        uVar16 = (uint)pcVar21[1];\n        pcVar21 = pcVar21 + 1;\n      } while (uVar16 - 0x30 < 10);\n    }\n    uVar9 = (ulong)uVar16;\n    if (((char)uVar16 == 'E') || ((char)uVar16 == 'O')) {\n      uVar9 = (ulong)(byte)pcVar21[1];\n      pcVar21 = pcVar21 + 1;\n    }\n    else {\n      uVar16 = 0;\n    }\n    cVar23 = (char)uVar9;\n    iVar33 = (int)uVar34;\n    pcVar27 = pcVar21;\n    uVar17 = uVar29;\n    switch(uVar9 & 0xff) {\n    case 0:\n      pcVar27 = pcVar21 + -1;\n      break;\n    case 0x25:\n      pcVar27 = pcVar21 + -1;\n      if (pcVar27 == param_3) {\n        if ((uVar30 == 0x2d) || (iVar33 < 0)) {\n          if (1 < (ulong)(param_2 - lVar31)) {\n            uVar34 = 1;\n            if (param_1 != (undefined8 *)0x0) goto LAB_00114578;\n            goto LAB_00113a98;\n          }\n        }\n        else {\n          uVar9 = (ulong)iVar33;\n          uVar34 = 1;\n          if (uVar9 != 0) {\n            uVar34 = uVar9;\n          }\n          if (uVar34 < (ulong)(param_2 - lVar31)) {\n            if (param_1 != (undefined8 *)0x0) {\n              if (1 < iVar33) {\n                sVar19 = uVar9 - 1;\n                if ((uVar30 == 0x30) || (uVar30 == 0x2b)) {\n                  memset(param_1,0x30,sVar19);\n                  param_1 = (undefined8 *)((long)param_1 + sVar19);\n                }\n                else {\n                  memset(param_1,0x20,sVar19);\n                  param_1 = (undefined8 *)((long)param_1 + sVar19);\n                }\n              }\nLAB_00114578:\n              *(char *)param_1 = *pcVar21;\n              param_1 = (undefined8 *)((long)param_1 + 1);\n            }\n            goto LAB_00113a98;\n          }\n        }\n        goto LAB_00112f90;\n      }\n      break;\n    case 0x3a:\n      pcVar25 = pcVar21 + 1;\n      uVar34 = 1;\n      cVar15 = pcVar21[1];\n      while (cVar15 == ':') {\n        uVar34 = uVar34 + 1;\n        pcVar25 = pcVar21 + uVar34;\n        cVar15 = pcVar21[uVar34];\n      }\n      if (cVar15 == 'z') goto LAB_001140ec;\n      break;\n    case 0x41:\n    case 0x61:\n      if (uVar16 != 0) break;\n      if (cVar15 != '\\0') {\n        cVar5 = cVar15;\n      }\n      cVar22 = '\\0';\n      pcVar27 = (char *)((long)&uStack_450 + 5);\n      goto LAB_00113252;\n    case 0x42:\n      if (uVar16 != 0x45) {\n        if (cVar15 != '\\0') {\n          cVar5 = cVar15;\n        }\n        cVar22 = '\\0';\n        goto LAB_00113233;\n      }\n      break;\n    case 0x43:\n      if (uVar16 != 0x45) {\n        uVar7 = *(uint *)((long)param_4 + 0x14);\n        local_4b8._0_1_ = (int)uVar7 < -0x76c;\n        uVar17 = (int)((-(uint)(uVar7 + 0x76c < 0x76c) & 0xffffff9d) + uVar7) / 100 + 0x13;\n        bVar6 = -0x76d < (int)uVar7;\n        if (uVar30 == 0) {\n          uVar30 = param_6;\n          if (param_6 == 0x2b) {\nLAB_001146b2:\n            local_4a8 = 2;\n            uVar7 = 99;\nLAB_001145ff:\n            if (uVar17 <= uVar7) goto LAB_001145bc;\n            bVar35 = true;\n            uVar30 = 0x2b;\n            bVar6 = (bool)(local_4b8._0_1_ ^ 1);\n            goto LAB_001134f3;\n          }\n        }\n        else if (uVar30 == 0x2b) goto LAB_001146b2;\n        bVar35 = false;\n        local_4a8 = 2;\nLAB_001134f3:\n        uVar7 = 0;\n        goto LAB_00113500;\n      }\n      goto LAB_00113511;\n    case 0x44:\n      if (uVar16 == 0) {\n        pcVar27 = \"%m/%d/%y\";\n        iVar26 = -1;\n        goto LAB_00113b4f;\n      }\n      break;\n    case 0x46:\n      if (uVar16 != 0) break;\n      if ((-1 < iVar33) || (uVar30 != 0)) {\n        pcVar27 = \"%Y-%m-%d\";\n        iVar26 = 0;\n        if (-1 < iVar33 + -6) {\n          iVar26 = iVar33 + -6;\n        }\n        goto LAB_00113b4f;\n      }\n      uVar34 = FUN_00112e70(0,0xffffffffffffffff,\"%Y-%m-%d\",param_4,cVar5,0x2b,4,param_8,param_9,\n                            (long)&switchD_0011309d::switchdataD_0011e72c +\n                            (long)(int)(&switchD_0011309d::switchdataD_0011e72c)[uVar9 & 0xff]);\n      pcVar27 = \"%Y-%m-%d\";\n      uVar9 = 0;\n      uVar30 = 0x2b;\n      iVar26 = 4;\n      local_4c0 = uVar34;\n      goto LAB_00113bcd;\n    case 0x47:\n    case 0x56:\n    case 0x67:\n      if (uVar16 != 0x45) {\n        uVar7 = *(uint *)((long)param_4 + 0x14);\n        uVar2 = *(uint *)((long)param_4 + 0x1c);\n        uVar3 = *(uint *)(param_4 + 3);\n        iVar26 = (uVar2 - uVar3) + 0x17e;\n        uVar17 = (uVar7 - 100) + ((int)uVar7 >> 0x1f & 400U);\n        iVar26 = (uVar2 - iVar26) + 3 + (iVar26 / 7) * 7;\n        if (iVar26 < 0) {\n          uVar17 = uVar17 - 1;\n          iVar26 = 0x16d;\n          if (((uVar17 & 3) == 0) &&\n             (iVar26 = 0x16e,\n             (uVar17 * -0x3d70a3d7 + 0x51eb850 >> 2 | uVar17 * 0x40000000) < 0x28f5c29)) {\n            iVar26 = 0x16e - (uint)((int)uVar17 % 400 != 0);\n          }\n          iVar28 = ((iVar26 + uVar2) - uVar3) + 0x17e;\n          iVar26 = ((iVar26 + uVar2) - iVar28) + 3 + (iVar28 / 7) * 7;\n          iVar28 = -1;\n        }\n        else {\n          iVar28 = 0x16d;\n          if (((uVar17 & 3) == 0) &&\n             (iVar28 = 0x16e,\n             (uVar17 * -0x3d70a3d7 + 0x51eb850 >> 2 | uVar7 * 0x40000000) < 0x28f5c29)) {\n            iVar28 = 0x16e - (uint)((int)uVar17 % 400 != 0);\n          }\n          iVar24 = ((uVar2 - iVar28) - uVar3) + 0x17e;\n          iVar28 = ((uVar2 - iVar28) - iVar24) + 3 + (iVar24 / 7) * 7;\n          if (-1 < iVar28) {\n            iVar26 = iVar28;\n          }\n          iVar28 = (iVar28 >> 0x1f) + 1;\n        }\n        if (cVar23 == 'G') {\n          uVar17 = uVar7 + 0x76c + iVar28;\n          local_4b8._0_1_ = (int)uVar7 < -0x76c - iVar28;\n          if (uVar30 == 0) {\n            if (param_6 == 0x2b) {\nLAB_00114884:\n              local_4a8 = 4;\n              uVar7 = 9999;\n              goto LAB_001145ff;\n            }\n            bVar35 = false;\n            local_4a8 = 4;\n            bVar6 = -0x76c - iVar28 <= (int)uVar7;\n            uVar30 = param_6;\n          }\n          else {\nLAB_001145e8:\n            local_4a8 = 4;\n            uVar7 = 9999;\n            if (uVar30 == 0x2b) goto LAB_001145ff;\n            bVar35 = false;\n            bVar6 = (bool)(local_4b8._0_1_ ^ 1);\n          }\n          goto LAB_001134f3;\n        }\n        if (cVar23 == 'g') {\n          uVar17 = ((int)uVar7 % 100 + iVar28) % 100;\n          if ((int)uVar17 < 0) {\n            if ((int)uVar7 < -0x76c - iVar28) {\n              uVar17 = -uVar17;\n            }\n            else {\n              uVar17 = uVar17 + 100;\n            }\n          }\n          goto joined_r0x00114032;\n        }\n        local_4a8 = 2;\n        uVar17 = iVar26 / 7 + 1;\n        goto LAB_00113740;\n      }\n      break;\n    case 0x48:\n      if (uVar16 != 0x45) {\n        local_4a8 = 2;\n        uVar17 = *(uint *)(param_4 + 1);\n        goto LAB_00113740;\n      }\n      break;\n    case 0x49:\n      if (uVar16 != 0x45) {\n        local_4a8 = 2;\n        goto LAB_00113740;\n      }\n      break;\n    case 0x4d:\n      if (uVar16 != 0x45) {\n        local_4a8 = 2;\n        uVar17 = *(uint *)((long)param_4 + 4);\n        goto LAB_00113740;\n      }\n      break;\n    case 0x4e:\n      if (uVar16 != 0x45) {\n        iVar28 = 9;\n        iVar26 = param_9;\n        if (iVar33 < 1) {\n          iVar33 = 9;\n        }\n        do {\n          if (iVar28 <= iVar33) {\n            if (iVar28 == 1) {\n              uVar34 = 1;\n              goto LAB_001135e5;\n            }\n            if (iVar26 % 10 != 0) goto code_r0x001135d7;\n          }\n          iVar28 = iVar28 + -1;\n          iVar26 = iVar26 / 10;\n        } while( true );\n      }\n      break;\n    case 0x50:\n      cVar22 = '\\x01';\n      goto LAB_001141c3;\n    case 0x52:\n      pcVar27 = \"%H:%M\";\n      iVar26 = -1;\n      goto LAB_00113b4f;\n    case 0x53:\n      if (uVar16 != 0x45) {\n        local_4a8 = 2;\n        uVar17 = *(uint *)param_4;\n        goto LAB_00113740;\n      }\n      break;\n    case 0x54:\n      pcVar27 = \"%H:%M:%S\";\n      iVar26 = -1;\nLAB_00113b4f:\n      uVar34 = FUN_00112e70(0,0xffffffffffffffff,pcVar27,param_4,cVar5,uVar30,iVar26,param_8,param_9\n                           );\n      if ((uVar30 == 0x2d) || (iVar33 < 0)) {\n        uVar9 = 0;\n        local_4c0 = uVar34;\n      }\n      else {\n        uVar9 = (ulong)iVar33;\n        local_4c0 = uVar9;\n        if (uVar9 <= uVar34) {\n          local_4c0 = uVar34;\n        }\n      }\nLAB_00113bcd:\n      if ((ulong)(param_2 - lVar31) <= local_4c0) goto LAB_00112f90;\n      if (param_1 != (undefined8 *)0x0) {\n        puVar32 = param_1;\n        if (uVar34 < uVar9) {\n          sVar19 = uVar9 - uVar34;\n          puVar32 = (undefined8 *)((long)param_1 + sVar19);\n          if ((uVar30 == 0x30) || (uVar30 == 0x2b)) {\n            memset(param_1,0x30,sVar19);\n          }\n          else {\n            memset(param_1,0x20,sVar19);\n          }\n        }\n        param_1 = (undefined8 *)((long)puVar32 + uVar34);\n        FUN_00112e70(puVar32,param_2 - lVar31,pcVar27,param_4,cVar5,uVar30,iVar26,param_8,param_9);\n      }\n      lVar31 = lVar31 + local_4c0;\n      goto LAB_00112f58;\n    case 0x55:\n      if (uVar16 != 0x45) {\n        iVar26 = (*(uint *)((long)param_4 + 0x1c) - *(uint *)(param_4 + 3)) + 7;\nLAB_001137f3:\n        local_4a8 = 2;\n        uVar17 = iVar26 / 7;\n        goto LAB_00113740;\n      }\n      break;\n    case 0x57:\n      if (uVar16 != 0x45) {\n        iVar26 = (((int)(*(uint *)(param_4 + 3) + 6) / 7) * 7 - (*(uint *)(param_4 + 3) + 6)) + 7 +\n                 *(uint *)((long)param_4 + 0x1c);\n        goto LAB_001137f3;\n      }\n      break;\n    case 0x58:\n    case 99:\n    case 0x78:\n      if (uVar16 != 0x4f) goto switchD_0011309d_caseD_72;\n      break;\n    case 0x59:\n      if (uVar16 != 0x45) {\n        if (uVar16 == 0x4f) break;\n        local_4b8._0_1_ = (int)*(uint *)((long)param_4 + 0x14) < -0x76c;\n        uVar17 = *(uint *)((long)param_4 + 0x14) + 0x76c;\n        if (uVar30 != 0) goto LAB_001145e8;\n        if (param_6 == 0x2b) goto LAB_00114884;\n        bVar35 = false;\n        uVar7 = 0;\n        local_4a8 = 4;\n        uVar30 = param_6;\n        goto LAB_00113ee8;\n      }\n      goto LAB_00113511;\n    case 0x5a:\n      if (cVar15 != '\\0') {\n        cVar5 = '\\0';\n      }\n      sVar19 = strlen(__s);\n      if ((uVar30 == 0x2d) || (iVar33 < 0)) {\n        uVar34 = 0;\n        local_4b8 = sVar19;\n      }\n      else {\n        uVar34 = (ulong)iVar33;\n        local_4b8 = uVar34;\n        if (uVar34 <= sVar19) {\n          local_4b8 = sVar19;\n        }\n      }\n      if ((ulong)(param_2 - lVar31) <= local_4b8) goto LAB_00112f90;\n      if (param_1 != (undefined8 *)0x0) {\n        puVar32 = param_1;\n        if (sVar19 < uVar34) {\n          sVar20 = uVar34 - sVar19;\n          puVar32 = (undefined8 *)((long)param_1 + sVar20);\n          if ((uVar30 == 0x30) || (uVar30 == 0x2b)) {\n            memset(param_1,0x30,sVar20);\n          }\n          else {\n            memset(param_1,0x20,sVar20);\n          }\n        }\n        if (cVar15 == '\\0') {\n          if (cVar5 == '\\0') {\n            memcpy(puVar32,__s,sVar19);\n          }\n          else if (sVar19 != 0) {\n            pp_Var10 = __ctype_toupper_loc();\n            sVar20 = sVar19;\n            do {\n              sVar20 = sVar20 - 1;\n              *(char *)((long)puVar32 + sVar20) = (char)(*pp_Var10)[(byte)__s[sVar20]];\n            } while (sVar20 != 0);\n          }\n        }\n        else if (sVar19 != 0) {\n          plVar11 = (long *)FUN_00104ca0();\n          sVar20 = sVar19;\n          do {\n            sVar20 = sVar20 - 1;\n            *(char *)((long)puVar32 + sVar20) =\n                 (char)*(undefined4 *)(*plVar11 + (ulong)(byte)__s[sVar20] * 4);\n          } while (sVar20 != 0);\n        }\n        param_1 = (undefined8 *)((long)puVar32 + sVar19);\n      }\n      lVar31 = lVar31 + local_4b8;\n      goto LAB_00112f58;\n    case 0x62:\n    case 0x68:\n      if (cVar15 != '\\0') {\n        cVar5 = cVar15;\n      }\n      if (uVar16 != 0x45) goto switchD_0011309d_caseD_72;\n      break;\n    case 100:\n      if (uVar16 != 0x45) {\n        local_4a8 = 2;\n        uVar17 = *(uint *)((long)param_4 + 0xc);\n        goto LAB_00113740;\n      }\n      break;\n    case 0x65:\n      if (uVar16 != 0x45) {\n        uVar17 = *(uint *)((long)param_4 + 0xc);\nLAB_00113da8:\n        local_4a8 = 2;\n        if (uVar30 == 0) {\n          uVar30 = 0x5f;\n        }\n        goto LAB_00113740;\n      }\n      break;\n    case 0x6a:\n      if (uVar16 != 0x45) {\n        bVar35 = false;\n        local_4a8 = 3;\n        uVar7 = *(uint *)((long)param_4 + 0x1c);\n        uVar17 = uVar7 + 1;\n        local_4b8._0_1_ = (int)uVar7 < -1;\n        bVar6 = -2 < (int)uVar7;\n        uVar7 = 0;\n        goto LAB_00113500;\n      }\n      break;\n    case 0x6b:\n      if (uVar16 != 0x45) {\n        uVar17 = *(uint *)(param_4 + 1);\n        goto LAB_00113da8;\n      }\n      break;\n    case 0x6c:\n      if (uVar16 != 0x45) goto LAB_00113da8;\n      break;\n    case 0x6d:\n      if (uVar16 != 0x45) {\n        bVar35 = false;\n        local_4a8 = 2;\n        uVar7 = *(uint *)(param_4 + 2);\n        uVar17 = uVar7 + 1;\n        local_4b8._0_1_ = (int)uVar7 < -1;\n        bVar6 = -2 < (int)uVar7;\n        uVar7 = 0;\n        goto LAB_00113500;\n      }\n      break;\n    case 0x6e:\n      if ((uVar30 == 0x2d) || (iVar33 < 0)) {\n        if (1 < (ulong)(param_2 - lVar31)) {\n          uVar34 = 1;\n          if (param_1 != (undefined8 *)0x0) goto LAB_00113e66;\n          goto LAB_00113a98;\n        }\n      }\n      else {\n        uVar9 = (ulong)iVar33;\n        uVar34 = 1;\n        if (uVar9 != 0) {\n          uVar34 = uVar9;\n        }\n        if (uVar34 < (ulong)(param_2 - lVar31)) {\n          if (param_1 != (undefined8 *)0x0) {\n            if (1 < iVar33) {\n              sVar19 = uVar9 - 1;\n              if ((uVar30 == 0x30) || (uVar30 == 0x2b)) {\n                memset(param_1,0x30,sVar19);\n                param_1 = (undefined8 *)((long)param_1 + sVar19);\n              }\n              else {\n                memset(param_1,0x20,sVar19);\n                param_1 = (undefined8 *)((long)param_1 + sVar19);\n              }\n            }\nLAB_00113e66:\n            *(char *)param_1 = '\\n';\n            param_1 = (undefined8 *)((long)param_1 + 1);\n          }\nLAB_00113a98:\n          lVar31 = lVar31 + uVar34;\n          goto LAB_00112f58;\n        }\n      }\n      goto LAB_00112f90;\n    case 0x70:\n      cVar22 = '\\0';\nLAB_001141c3:\n      cVar23 = 'p';\n      if (cVar15 != '\\0') {\n        cVar5 = '\\0';\n        cVar22 = cVar15;\n      }\nLAB_00113233:\n      if (uVar16 != 0) goto LAB_00113520;\n      pcVar27 = (char *)((long)&uStack_450 + 5);\n      goto LAB_00113252;\n    case 0x71:\n      if (uVar16 != 0x4f) {\n        bVar35 = false;\n        uVar7 = 0;\n        local_4a8 = 1;\n        local_4b8._0_1_ = false;\n        uVar17 = ((int)(*(uint *)(param_4 + 2) * 0xb) >> 5) + 1;\n        goto LAB_00113d00;\n      }\n      goto LAB_00113511;\n    case 0x72:\nswitchD_0011309d_caseD_72:\n      cVar22 = '\\0';\n      goto LAB_00113233;\n    case 0x73:\n      local_468 = param_4[4];\n      uStack_460 = param_4[5];\n      local_488 = *param_4;\n      uStack_480 = param_4[1];\n      local_478 = param_4[2];\n      local_458 = param_4[6];\n      lStack_470 = CONCAT44(0xffffffff,(int)param_4[3]);\n      lVar13 = FUN_001177b0(param_8,&local_488);\n      if (-1 < lStack_470) {\n        local_4b8._0_1_ = SUB81((ulong)lVar13 >> 0x3f,0);\n        pcVar27 = local_432 + 1;\n        lVar14 = lVar13;\n        do {\n          lVar4 = lVar14 / 10;\n          cVar15 = (char)lVar14 + (char)lVar4 * -10;\n          if (lVar13 < 0) {\n            cVar15 = -cVar15;\n          }\n          pcVar27 = pcVar27 + -1;\n          *pcVar27 = cVar15 + '0';\n          lVar14 = lVar4;\n        } while (lVar4 != 0);\n        bVar35 = false;\n        local_4a8 = 1;\n        goto LAB_00113900;\n      }\n      *piVar8 = 0x4b;\n      goto LAB_00112f9b;\n    case 0x74:\n      if ((uVar30 == 0x2d) || (iVar33 < 0)) {\n        if (1 < (ulong)(param_2 - lVar31)) {\n          uVar34 = 1;\n          if (param_1 != (undefined8 *)0x0) goto LAB_00113a90;\n          goto LAB_00113a98;\n        }\n      }\n      else {\n        uVar9 = (ulong)iVar33;\n        uVar34 = 1;\n        if (uVar9 != 0) {\n          uVar34 = uVar9;\n        }\n        if (uVar34 < (ulong)(param_2 - lVar31)) {\n          if (param_1 != (undefined8 *)0x0) {\n            if (1 < iVar33) {\n              sVar19 = uVar9 - 1;\n              if ((uVar30 == 0x30) || (uVar30 == 0x2b)) {\n                memset(param_1,0x30,sVar19);\n                param_1 = (undefined8 *)((long)param_1 + sVar19);\n              }\n              else {\n                memset(param_1,0x20,sVar19);\n                param_1 = (undefined8 *)((long)param_1 + sVar19);\n              }\n            }\nLAB_00113a90:\n            *(char *)param_1 = '\\t';\n            param_1 = (undefined8 *)((long)param_1 + 1);\n          }\n          goto LAB_00113a98;\n        }\n      }\n      goto LAB_00112f90;\n    case 0x75:\n      local_4a8 = 1;\n      uVar17 = (int)(*(uint *)(param_4 + 3) + 6) % 7 + 1;\nLAB_00113740:\n      bVar35 = false;\n      uVar7 = 0;\n      bVar12 = (byte)(uVar17 >> 0x18);\n      local_4b8._0_1_ = (bool)(bVar12 >> 7);\n      bVar6 = (bool)((byte)~bVar12 >> 7);\nLAB_00113500:\n      if ((uVar16 == 0x4f) && (bVar6 != false)) goto LAB_00113511;\nLAB_00113ee8:\n      if (local_4b8._0_1_ != false) {\n        uVar17 = -uVar17;\n      }\nLAB_00113d00:\n      uVar34 = (ulong)uVar17;\n      pcVar25 = local_432 + 1;\n      while( true ) {\n        if ((uVar7 & 1) != 0) {\n          pcVar25[-1] = ':';\n          pcVar25 = pcVar25 + -1;\n        }\n        uVar7 = (int)uVar7 >> 1;\n        pcVar27 = pcVar25 + -1;\n        pcVar25[-1] = (char)uVar34 + (char)(uVar34 / 10) * -10 + '0';\n        if (((uint)uVar34 < 10) && (uVar7 == 0)) break;\n        uVar34 = uVar34 / 10;\n        pcVar25 = pcVar27;\n      }\nLAB_00113900:\n      uVar17 = uVar30;\n      if (uVar30 == 0) {\n        uVar17 = 0x30;\n      }\n      if (iVar33 < 0) {\n        iVar33 = local_4a8;\n      }\n      iVar26 = ((int)local_432 + 1) - (int)pcVar27;\n      if (local_4b8._0_1_ != false) {\n        cVar15 = '-';\nLAB_00114245:\n        iVar24 = iVar33 + -1;\n        iVar28 = iVar24 - iVar26;\n        if ((iVar28 < 1) || (uVar30 == 0x2d)) {\n          iVar28 = 0;\n        }\n        if (uVar17 == 0x5f) {\n          sVar19 = (size_t)iVar28;\n          lVar31 = lVar31 + sVar19;\n          if (param_1 == (undefined8 *)0x0) {\n            if (1 < (ulong)(param_2 - lVar31)) {\n              lVar31 = lVar31 + 1;\n              iVar33 = (iVar33 - iVar28) + -1;\n              goto LAB_0011428a;\n            }\n          }\n          else {\n            memset(param_1,0x20,sVar19);\n            param_1 = (undefined8 *)((long)param_1 + sVar19);\n            if (1 < (ulong)(param_2 - lVar31)) {\n              iVar24 = (iVar33 - iVar28) + -1;\n              goto LAB_00114276;\n            }\n          }\n        }\n        else if (1 < (ulong)(param_2 - lVar31)) {\n          if (param_1 != (undefined8 *)0x0) {\nLAB_00114276:\n            *(char *)param_1 = cVar15;\n            param_1 = (undefined8 *)((long)param_1 + 1);\n          }\n          lVar31 = lVar31 + 1;\n          iVar33 = iVar24;\n          if (uVar17 == 0x2d) goto LAB_001142be;\nLAB_0011428a:\n          uVar9 = (ulong)iVar26;\n          uVar34 = 0;\n          if (-1 < iVar33) goto LAB_00113949;\n          goto LAB_00113956;\n        }\n        goto LAB_00112f90;\n      }\n      if (bVar35) {\n        cVar15 = '+';\n        goto LAB_00114245;\n      }\n      if (((iVar26 < iVar33) && (uVar30 != 0x2d)) || (uVar17 != 0x2d)) {\nLAB_00113949:\n        uVar34 = (ulong)iVar33;\n        uVar9 = (long)iVar26;\n        if ((ulong)(long)iVar26 <= uVar34) {\n          uVar9 = uVar34;\n        }\n      }\n      else {\nLAB_001142be:\n        uVar9 = (ulong)iVar26;\n        uVar34 = 0;\n      }\nLAB_00113956:\n      uVar18 = (ulong)iVar26;\n      if ((ulong)(param_2 - lVar31) <= uVar9) goto LAB_00112f90;\n      if (param_1 != (undefined8 *)0x0) {\n        puVar32 = param_1;\n        if (uVar18 < uVar34) {\n          sVar19 = uVar34 - uVar18;\n          puVar32 = (undefined8 *)((long)param_1 + sVar19);\n          if ((uVar17 == 0x30) || (uVar17 == 0x2b)) {\n            memset(param_1,0x30,sVar19);\n          }\n          else {\n            memset(param_1,0x20,sVar19);\n          }\n        }\n        if (cVar5 == '\\0') {\n          memcpy(puVar32,pcVar27,uVar18);\n        }\n        else if (uVar18 != 0) {\n          pp_Var10 = __ctype_toupper_loc();\n          uVar34 = uVar18;\n          do {\n            uVar34 = uVar34 - 1;\n            *(char *)((long)puVar32 + uVar34) = (char)(*pp_Var10)[(byte)pcVar27[uVar34]];\n          } while (uVar34 != 0);\n        }\n        param_1 = (undefined8 *)((long)puVar32 + uVar18);\n      }\n      goto LAB_00113367;\n    case 0x77:\n      if (uVar16 != 0x45) {\n        local_4a8 = 1;\n        uVar17 = *(uint *)(param_4 + 3);\n        goto LAB_00113740;\n      }\n      break;\n    case 0x79:\n      if (uVar16 != 0x45) {\n        uVar7 = (int)*(uint *)((long)param_4 + 0x14) % 100;\n        uVar17 = uVar7;\n        if ((int)uVar7 < 0) {\n          uVar17 = uVar7 + 100;\n          if ((int)*(uint *)((long)param_4 + 0x14) < -0x76c) {\n            uVar17 = -uVar7;\n          }\n        }\njoined_r0x00114032:\n        if (uVar30 == 0) {\n          uVar30 = param_6;\n          if (param_6 == 0x2b) goto LAB_001145af;\n        }\n        else if (uVar30 == 0x2b) {\nLAB_001145af:\n          local_4b8._0_1_ = false;\n          local_4a8 = 2;\nLAB_001145bc:\n          bVar35 = local_4a8 < iVar33;\n          bVar6 = (bool)(local_4b8._0_1_ ^ 1);\n          uVar30 = 0x2b;\n          goto LAB_001134f3;\n        }\n        bVar35 = false;\n        bVar6 = true;\n        local_4b8._0_1_ = false;\n        local_4a8 = 2;\n        goto LAB_001134f3;\n      }\nLAB_00113511:\n      cVar22 = '\\0';\nLAB_00113520:\n      uStack_450._5_1_ = (undefined)uVar16;\n      pcVar27 = (char *)((long)&uStack_450 + 6);\nLAB_00113252:\n      uStack_450._3_2_ = 0x2520;\n      *pcVar27 = cVar23;\n      pcVar27[1] = '\\0';\n      lVar13 = FUN_00104b60(&local_448,0x400,(long)&uStack_450 + 3,param_4);\n      if (lVar13 != 0) {\n        uVar34 = lVar13 - 1;\n        if ((uVar30 == 0x2d) || (iVar33 < 0)) {\n          uVar18 = 0;\n          uVar9 = uVar34;\n        }\n        else {\n          uVar18 = (ulong)iVar33;\n          uVar9 = uVar18;\n          if (uVar18 <= uVar34) {\n            uVar9 = uVar34;\n          }\n        }\n        if (uVar9 < (ulong)(param_2 - lVar31)) {\n          if (param_1 != (undefined8 *)0x0) {\n            puVar32 = param_1;\n            if (uVar34 < uVar18) {\n              sVar19 = uVar18 - uVar34;\n              puVar32 = (undefined8 *)((long)param_1 + sVar19);\n              if ((uVar30 == 0x30) || (uVar30 == 0x2b)) {\n                memset(param_1,0x30,sVar19);\n              }\n              else {\n                memset(param_1,0x20,sVar19);\n              }\n            }\n            if (cVar22 == '\\0') {\n              if (cVar5 == '\\0') {\n                memcpy(puVar32,(void *)((long)&local_448 + 1),uVar34);\n              }\n              else {\n                lVar13 = lVar13 + -2;\n                if (uVar34 != 0) {\n                  pp_Var10 = __ctype_toupper_loc();\n                  do {\n                    *(char *)((long)puVar32 + lVar13) =\n                         (char)(*pp_Var10)[*(byte *)((long)&local_448 + lVar13 + 1)];\n                    bVar35 = lVar13 != 0;\n                    lVar13 = lVar13 + -1;\n                  } while (bVar35);\n                }\n              }\n            }\n            else {\n              lVar13 = lVar13 + -2;\n              if (uVar34 != 0) {\n                plVar11 = (long *)FUN_00104ca0();\n                do {\n                  *(char *)((long)puVar32 + lVar13) =\n                       (char)*(undefined4 *)\n                              (*plVar11 + (ulong)*(byte *)((long)&local_448 + lVar13 + 1) * 4);\n                  bVar35 = lVar13 != 0;\n                  lVar13 = lVar13 + -1;\n                } while (bVar35);\n              }\n            }\n            param_1 = (undefined8 *)((long)puVar32 + uVar34);\n          }\nLAB_00113367:\n          lVar31 = lVar31 + uVar9;\n          goto LAB_00112f58;\n        }\n        goto LAB_00112f90;\n      }\n      goto LAB_00112f58;\n    case 0x7a:\n      uVar34 = 0;\n      pcVar25 = pcVar21;\nLAB_001140ec:\n      pcVar21 = pcVar25;\n      if (-1 < (int)*(uint *)(param_4 + 4)) {\n        local_4b8._0_1_ = true;\n        iVar26 = (int)param_4[5];\n        if ((-1 < iVar26) && (local_4b8._0_1_ = false, iVar26 == 0)) {\n          local_4b8._0_1_ = *__s == '-';\n        }\n        uVar17 = iVar26 / 0xe10;\n        iVar28 = (iVar26 / 0x3c) % 0x3c;\n        if (uVar34 == 2) {\nLAB_00114796:\n          bVar35 = true;\n          local_4a8 = 9;\n          bVar6 = (bool)(local_4b8._0_1_ ^ 1);\n          uVar7 = 0x14;\n          uVar17 = uVar17 * 10000 + iVar28 * 100 + iVar26 % 0x3c;\n        }\n        else if (uVar34 < 3) {\n          if (uVar34 == 0) {\n            bVar35 = true;\n            local_4a8 = 5;\n            bVar6 = (bool)(local_4b8._0_1_ ^ 1);\n            uVar17 = uVar17 * 100 + iVar28;\n            uVar7 = 0;\n          }\n          else {\nLAB_00114192:\n            bVar35 = true;\n            local_4a8 = 6;\n            bVar6 = (bool)(local_4b8._0_1_ ^ 1);\n            uVar17 = uVar17 * 100 + iVar28;\n            uVar7 = 4;\n          }\n        }\n        else {\n          pcVar27 = pcVar25;\n          if (uVar34 != 3) break;\n          if (iVar26 % 0x3c != 0) goto LAB_00114796;\n          if (iVar28 != 0) goto LAB_00114192;\n          bVar35 = true;\n          local_4a8 = 3;\n          bVar6 = (bool)(local_4b8._0_1_ ^ 1);\n          uVar7 = 0;\n        }\n        goto LAB_00113500;\n      }\n      goto LAB_00112f58;\n    }\n    lVar13 = (long)pcVar27 - (long)param_3;\n    uVar34 = lVar13 + 1;\n    if ((iVar33 < 0) || (uVar30 == 0x2d)) {\n      uVar18 = 0;\n      uVar9 = uVar34;\n    }\n    else {\n      uVar18 = (ulong)iVar33;\n      uVar9 = uVar18;\n      if (uVar18 <= uVar34) {\n        uVar9 = uVar34;\n      }\n    }\n    if ((ulong)(param_2 - lVar31) <= uVar9) goto LAB_00112f90;\n    if (param_1 != (undefined8 *)0x0) {\n      puVar32 = param_1;\n      if (uVar34 < uVar18) {\n        sVar19 = uVar18 - uVar34;\n        puVar32 = (undefined8 *)((long)param_1 + sVar19);\n        if ((uVar30 == 0x30) || (uVar30 == 0x2b)) {\n          memset(param_1,0x30,sVar19);\n        }\n        else {\n          memset(param_1,0x20,sVar19);\n        }\n      }\n      if (cVar5 == '\\0') {\n        memcpy(puVar32,param_3,uVar34);\n      }\n      else if (uVar34 != 0) {\n        pp_Var10 = __ctype_toupper_loc();\n        do {\n          *(char *)((long)puVar32 + lVar13) = (char)(*pp_Var10)[(byte)param_3[lVar13]];\n          bVar35 = lVar13 != 0;\n          lVar13 = lVar13 + -1;\n        } while (bVar35);\n      }\n      param_1 = (undefined8 *)((long)puVar32 + uVar34);\n    }\n    lVar31 = lVar31 + uVar9;\n    pcVar21 = pcVar27;\n    goto LAB_00112f58;\n  }\n  if ((param_1 != (undefined8 *)0x0) && (param_2 != 0)) {\n    *(char *)param_1 = '\\0';\n  }\n  *piVar8 = iVar1;\nLAB_00112f9e:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return lVar31;\ncode_r0x001135d7:\n  uVar34 = (ulong)iVar28;\n  if (iVar28 == 0) {\n    uVar34 = 0;\n  }\n  else {\nLAB_001135e5:\n    pcVar27 = (char *)((long)&local_448 + uVar34);\n    do {\n      pcVar27 = pcVar27 + -1;\n      *pcVar27 = (char)iVar26 + (char)(iVar26 / 10) * -10 + '0';\n      iVar26 = iVar26 / 10;\n    } while (pcVar27 != (char *)((long)&uStack_450 + (uVar34 - (iVar28 - 1)) + 7));\n  }\n  if (uVar30 == 0) {\n    uVar30 = 0x30;\n  }\n  if ((ulong)(param_2 - lVar31) <= uVar34) {\nLAB_00112f90:\n    *piVar8 = 0x22;\nLAB_00112f9b:\n    lVar31 = 0;\n    goto LAB_00112f9e;\n  }\n  if (param_1 != (undefined8 *)0x0) {\n    if (cVar5 == '\\0') {\n      if (uVar34 < 8) {\n        if ((uVar34 & 4) == 0) {\n          if (uVar34 != 0) {\n            *(char *)param_1 = (char)local_448;\n            if ((uVar34 & 2) != 0) {\n              *(undefined2 *)((long)param_1 + (uVar34 - 2)) =\n                   *(undefined2 *)((long)&uStack_450 + uVar34 + 6);\n            }\n          }\n        }\n        else {\n          *(undefined4 *)param_1 = (undefined4)local_448;\n          *(undefined4 *)((long)param_1 + (uVar34 - 4)) =\n               *(undefined4 *)((long)&uStack_450 + uVar34 + 4);\n        }\n      }\n      else {\n        *param_1 = CONCAT44(local_448._4_4_,(undefined4)local_448);\n        *(undefined8 *)((long)param_1 + (uVar34 - 8)) = *(undefined8 *)((long)&uStack_450 + uVar34);\n        lVar13 = (long)param_1 - ((ulong)(param_1 + 1) & 0xfffffffffffffff8);\n        uVar9 = lVar13 + uVar34 & 0xfffffffffffffff8;\n        if (7 < uVar9) {\n          uVar18 = 0;\n          do {\n            *(undefined8 *)(((ulong)(param_1 + 1) & 0xfffffffffffffff8) + uVar18) =\n                 *(undefined8 *)((long)&local_448 + (uVar18 - lVar13));\n            uVar18 = uVar18 + 8;\n          } while (uVar18 < uVar9);\n        }\n      }\n    }\n    else if (uVar34 != 0) {\n      pp_Var10 = __ctype_toupper_loc();\n      uVar9 = uVar34;\n      do {\n        uVar18 = uVar9 - 1;\n        *(char *)((long)param_1 + uVar18) =\n             (char)(*pp_Var10)[*(byte *)((long)&uStack_450 + uVar9 + 7)];\n        uVar9 = uVar18;\n      } while (uVar18 != 0);\n    }\n    param_1 = (undefined8 *)((long)param_1 + uVar34);\n  }\n  lVar31 = lVar31 + uVar34;\n  if ((uVar30 == 0x2d) || (iVar33 - iVar28 < 0)) {\n    if (param_2 == lVar31) goto LAB_00112f90;\n  }\n  else {\n    uVar34 = (ulong)(iVar33 - iVar28);\n    if ((ulong)(param_2 - lVar31) <= uVar34) goto LAB_00112f90;\n    if (param_1 == (undefined8 *)0x0) {\n      lVar31 = lVar31 + uVar34;\n    }\n    else if (uVar34 != 0) {\n      lVar31 = lVar31 + uVar34;\n      if ((uVar30 == 0x30) || (uVar30 == 0x2b)) {\n        memset(param_1,0x30,uVar34);\n        param_1 = (undefined8 *)((long)param_1 + uVar34);\n      }\n      else {\n        memset(param_1,0x20,uVar34);\n        param_1 = (undefined8 *)((long)param_1 + uVar34);\n      }\n    }\n  }\nLAB_00112f58:\n  cVar5 = pcVar21[1];\n  param_3 = pcVar21 + 1;\n  uVar34 = 0xffffffffffffffff;\n  goto joined_r0x00112f03;\n}\n\n",
  "FUN_001074f0": "\nvoid FUN_001074f0(void *param_1,size_t param_2)\n\n{\n  DAT_001271f8 = DAT_001271f8 + param_2;\n  fwrite_unlocked(param_1,1,param_2,stdout);\n  return;\n}\n\n",
  "FUN_00106910": "\nulong FUN_00106910(ulong *param_1,ulong param_2)\n\n{\n  return *param_1 % param_2;\n}\n\n",
  "faccessat": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint faccessat(int __fd,char *__file,int __type,int __flag)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_faccessat_00125d28)();\n  return iVar1;\n}\n\n",
  "FUN_00111150": "\nulong FUN_00111150(undefined8 *param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 = FUN_00119660(*param_1);\n  return (uVar1 ^ param_1[1]) % param_2;\n}\n\n",
  "FUN_0010fb40": "\nulong FUN_0010fb40(char *param_1,long param_2,char *param_3,long param_4)\n\n{\n  long lVar1;\n  uint uVar2;\n  long lVar3;\n  long lVar4;\n  ulong uVar5;\n  bool bVar6;\n  bool bVar7;\n  long local_28;\n  long local_20;\n  \n  bVar6 = param_2 == 0;\n  if (param_2 < 0) {\n    bVar6 = *param_1 == '\\0';\n  }\n  bVar7 = param_4 == 0;\n  if (param_4 < 0) {\n    bVar7 = *param_3 == '\\0';\n  }\n  if (bVar6) {\nLAB_0010fc10:\n    return (ulong)(bVar7 - 1);\n  }\n  if (bVar7 != false) {\n    return 1;\n  }\n  if (*param_1 == '.') {\n    if (*param_3 == '.') {\n      bVar6 = param_2 == 1;\n      if (param_2 < 0) {\n        bVar6 = param_1[1] == '\\0';\n      }\n      bVar7 = param_4 == 1;\n      if (param_4 < 0) {\n        bVar7 = param_3[1] == '\\0';\n      }\n      if (bVar6) goto LAB_0010fc10;\n      if (bVar7 != false) {\n        return 1;\n      }\n      if (param_1[1] == '.') {\n        if (param_2 < 0) {\n          if (param_1[2] == '\\0') goto LAB_0010fcab;\n          goto LAB_0010fc70;\n        }\n        if (param_2 != 2) goto LAB_0010fc70;\nLAB_0010fcab:\n        if (param_3[1] != '.') goto LAB_0010fc91;\n        uVar2 = 1;\n      }\n      else {\nLAB_0010fc70:\n        if (param_3[1] != '.') goto LAB_0010fba4;\n        uVar2 = 0;\n      }\n      if (param_4 < 0) {\n        if (param_3[2] == '\\0') goto LAB_0010fcc8;\n      }\n      else if (param_4 == 2) {\nLAB_0010fcc8:\n        return (ulong)(uVar2 ^ 1);\n      }\n      if (uVar2 == 0) goto LAB_0010fba4;\n    }\nLAB_0010fc91:\n    uVar5 = 0xffffffff;\n  }\n  else {\n    if (*param_3 == '.') {\n      return 1;\n    }\nLAB_0010fba4:\n    local_28 = param_4;\n    local_20 = param_2;\n    lVar3 = FUN_0010f7d0(param_1,&local_20);\n    lVar4 = FUN_0010f7d0(param_3,&local_28);\n    lVar1 = local_20;\n    if (((local_20 == lVar3) && (local_28 == lVar4)) ||\n       (uVar5 = FUN_0010f880(param_1,lVar3,param_3,lVar4), lVar4 = local_28, (int)uVar5 == 0)) {\n      uVar5 = FUN_0010f880(param_1,lVar1,param_3,lVar4);\n    }\n  }\n  return uVar5;\n}\n\n",
  "FUN_001083a0": "\nvoid FUN_001083a0(char **param_1,char **param_2)\n\n{\n  char *__s1;\n  char *__s2;\n  int iVar1;\n  \n  __s1 = *param_1;\n  __s2 = *param_2;\n  iVar1 = FUN_0010fce0(__s1,__s2);\n  if (iVar1 == 0) {\n    strcmp(__s1,__s2);\n    return;\n  }\n  return;\n}\n\n",
  "memset": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memset_00125dd8)();\n  return pvVar1;\n}\n\n",
  "FUN_001072b0": "\nvoid FUN_001072b0(char **param_1,char **param_2,code *UNRECOVERED_JUMPTABLE)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar2 = strrchr(*param_1,0x2e);\n  pcVar3 = strrchr(*param_2,0x2e);\n  if (pcVar3 == (char *)0x0) {\n    pcVar3 = \"\";\n  }\n  if (pcVar2 == (char *)0x0) {\n    pcVar2 = \"\";\n  }\n  iVar1 = (*UNRECOVERED_JUMPTABLE)(pcVar2,pcVar3);\n  if (iVar1 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00107317. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    (*UNRECOVERED_JUMPTABLE)(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_0010acf0": "\nint FUN_0010acf0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  iVar5 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar5 == 9 || iVar5 == 3) goto LAB_0010ad70;\n    iVar5 = 1;\n  }\n  else {\n    if (iVar5 == 9 || iVar5 == 3) {\n      return -1;\n    }\n    iVar5 = 0;\n  }\n  iVar5 = iVar5 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar5 != 0) {\n    return iVar5;\n  }\nLAB_0010ad70:\n  pcVar1 = param_1[0xe];\n  pcVar2 = param_2[0xe];\n  pcVar3 = param_1[0xf];\n  pcVar4 = param_2[0xf];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_2[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_2[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 != 0) {\n    return iVar5;\n  }\n  iVar5 = strcmp(*param_2,*param_1);\n  return iVar5;\n}\n\n",
  "FUN_00106cf0": "\nlong FUN_00106cf0(undefined8 param_1)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_001186b0(param_1,0,0,&local_18,&DAT_0011bdd5);\n  if (iVar1 == 0) {\n    if (local_18 < 0) {\n      local_18 = 0;\n    }\n  }\n  else {\n    local_18 = -(ulong)(iVar1 != 1);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_18;\n}\n\n",
  "entry": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  (*(code *)PTR___libc_start_main_00125fa8)\n            (FUN_00104d40,param_2,&stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
  "FUN_001170b0": "\nvoid FUN_001170b0(void)\n\n{\n  FUN_00116340();\n  return;\n}\n\n",
  "FUN_00117920": "\nlong FUN_00117920(FILE *param_1,long param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 *param_5,ulong param_6)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  undefined8 uVar9;\n  undefined8 uVar10;\n  \n  if (param_2 == 0) {\n    __fprintf_chk(param_1,1,\"%s %s\\n\",param_3,param_4);\n  }\n  else {\n    __fprintf_chk(param_1,1,\"%s (%s) %s\\n\",param_2,param_3,param_4);\n  }\n  __fprintf_chk(param_1,1,\"Copyright %s %d Free Software Foundation, Inc.\",&DAT_0011ed5b,0x7e7);\n  fputc_unlocked(10,param_1);\n  __fprintf_chk(param_1,1,\n                \"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\"\n                ,\"https://gnu.org/licenses/gpl.html\");\n  fputc_unlocked(10,param_1);\n  if (9 < param_6) {\n    uVar6 = param_5[2];\n    pcVar4 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\";\n    uVar5 = param_5[1];\n    uVar2 = param_5[7];\n    uVar3 = *param_5;\n    uVar10 = param_5[6];\n    uVar9 = param_5[5];\n    uVar8 = param_5[4];\n    uVar7 = param_5[3];\n    goto LAB_001179f5;\n  }\n  lVar1 = (long)&switchD_001179c8::switchdataD_0011f048 +\n          (long)(int)(&switchD_001179c8::switchdataD_0011f048)[param_6];\n  switch(param_6) {\n  case 0:\n    goto switchD_001179c8_caseD_0;\n  case 1:\n    lVar1 = __fprintf_chk(param_1,1,\"Written by %s.\\n\",*param_5);\n    return lVar1;\n  case 2:\n    lVar1 = __fprintf_chk(param_1,1,\"Written by %s and %s.\\n\",*param_5,param_5[1]);\n    return lVar1;\n  case 3:\n    lVar1 = __fprintf_chk(param_1,1,\"Written by %s, %s, and %s.\\n\",*param_5,param_5[1],param_5[2]);\n    return lVar1;\n  case 4:\n    lVar1 = param_5[3];\n    uVar2 = *param_5;\n    pcVar4 = \"Written by %s, %s, %s,\\nand %s.\\n\";\n    uVar6 = param_5[2];\n    uVar5 = param_5[1];\n    goto LAB_00117ae9;\n  case 5:\n    uVar6 = param_5[2];\n    pcVar4 = \"Written by %s, %s, %s,\\n%s, and %s.\\n\";\n    uVar5 = param_5[1];\n    lVar1 = param_5[3];\n    uVar2 = *param_5;\nLAB_00117ae9:\n    __fprintf_chk(param_1,1,pcVar4,uVar2,uVar5,uVar6);\n    return lVar1;\n  case 6:\n    uVar2 = param_5[5];\n    uVar3 = *param_5;\n    pcVar4 = \"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\";\n    uVar6 = param_5[2];\n    uVar10 = param_5[4];\n    uVar5 = param_5[1];\n    uVar9 = param_5[3];\n    goto LAB_00117b3f;\n  case 7:\n    uVar6 = param_5[2];\n    pcVar4 = \"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\";\n    uVar5 = param_5[1];\n    uVar2 = param_5[5];\n    uVar3 = *param_5;\n    uVar10 = param_5[4];\n    uVar9 = param_5[3];\nLAB_00117b3f:\n    lVar1 = __fprintf_chk(param_1,1,pcVar4,uVar3,uVar5,uVar6,uVar9,uVar10,uVar2);\n    return lVar1;\n  case 8:\n    uVar2 = param_5[7];\n    uVar3 = *param_5;\n    pcVar4 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\";\n    uVar6 = param_5[2];\n    uVar10 = param_5[6];\n    uVar5 = param_5[1];\n    uVar9 = param_5[5];\n    uVar8 = param_5[4];\n    uVar7 = param_5[3];\n    break;\n  case 9:\n    uVar6 = param_5[2];\n    pcVar4 = \"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\";\n    uVar5 = param_5[1];\n    uVar2 = param_5[7];\n    uVar3 = *param_5;\n    uVar10 = param_5[6];\n    uVar9 = param_5[5];\n    uVar8 = param_5[4];\n    uVar7 = param_5[3];\n  }\nLAB_001179f5:\n  lVar1 = __fprintf_chk(param_1,1,pcVar4,uVar3,uVar5,uVar6,uVar7,uVar8,uVar9,uVar10,uVar2);\nswitchD_001179c8_caseD_0:\n  return lVar1;\n}\n\n",
  "FUN_0010f370": "\nvoid FUN_0010f370(undefined8 param_1)\n\n{\n  DAT_001273d8 = param_1;\n  return;\n}\n\n",
  "FUN_00112b20": "\nvoid FUN_00112b20(char *param_1,undefined4 param_2)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(param_1);\n  FUN_00112940(param_1,sVar1,param_2);\n  return;\n}\n\n",
  "FUN_001084d0": "\nint FUN_001084d0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  pcVar1 = param_1[0x10];\n  pcVar2 = param_2[0x10];\n  pcVar3 = param_1[0x11];\n  pcVar4 = param_2[0x11];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_2[0x11] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_2[0x10] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 == 0) {\n    iVar5 = strcmp(*param_2,*param_1);\n    return iVar5;\n  }\n  return iVar5;\n}\n\n",
  "__ctype_b_loc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nushort ** __ctype_b_loc(void)\n\n{\n  ushort **ppuVar1;\n  \n  ppuVar1 = (ushort **)(*(code *)PTR___ctype_b_loc_00125f90)();\n  return ppuVar1;\n}\n\n",
  "sigaddset": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigaddset(sigset_t *__set,int __signo)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigaddset_00125f80)();\n  return iVar1;\n}\n\n",
  "FUN_00109080": "\nvoid FUN_00109080(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  pcVar1 = param_2[0xe];\n  pcVar2 = param_1[0xe];\n  pcVar3 = param_2[0xf];\n  pcVar4 = param_1[0xf];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_1[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_1[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    strcmp(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00106920": "\nundefined8 FUN_00106920(long *param_1,long *param_2)\n\n{\n  if (*param_1 != *param_2) {\n    return 0;\n  }\n  return CONCAT71((int7)((ulong)param_2[1] >> 8),param_1[1] == param_2[1]);\n}\n\n",
  "FUN_0010ea60": "\nint FUN_0010ea60(long param_1,long param_2,long param_3)\n\n{\n  uint uVar1;\n  long lVar2;\n  byte bVar3;\n  byte bVar4;\n  uint uVar5;\n  \n  if ((param_1 != param_2) && (param_3 != 0)) {\n    lVar2 = 0;\n    do {\n      bVar4 = *(byte *)(param_1 + lVar2);\n      uVar1 = (uint)bVar4;\n      if (bVar4 - 0x41 < 0x1a) {\n        uVar1 = uVar1 + 0x20;\n        bVar4 = bVar4 + 0x20;\n      }\n      bVar3 = *(byte *)(param_2 + lVar2);\n      uVar5 = (uint)bVar3;\n      if (bVar3 - 0x41 < 0x1a) {\n        uVar5 = bVar3 + 0x20;\n        bVar3 = bVar3 + 0x20;\n      }\n    } while (((lVar2 != param_3 + -1) && (uVar1 != 0)) && (lVar2 = lVar2 + 1, bVar4 == bVar3));\n    return uVar1 - uVar5;\n  }\n  return 0;\n}\n\n",
  "FUN_00116970": "\nvoid FUN_00116970(undefined8 param_1,int param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long in_FS_OFFSET;\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 10) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  local_44 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  local_18 = 0;\n  local_48 = param_2;\n  FUN_00116340(param_1,param_3,param_4,&local_48);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00116610": "\nvoid FUN_00116610(undefined4 *param_1,long param_2,long param_3)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_00127520;\n  }\n  *param_1 = 10;\n  if ((param_2 != 0) && (param_3 != 0)) {\n    *(long *)(param_1 + 10) = param_2;\n    *(long *)(param_1 + 0xc) = param_3;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00106be0": "\nuint FUN_00106be0(void)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar1 = (-(uint)(DAT_001272fc == '\\0') & 0xffffff00) + 0x102;\n  if (DAT_0012732c != '\\0') {\n    uVar1 = uVar1 | 0x400;\n  }\n  if (DAT_00127338 == 0) {\n    uVar2 = *(uint *)(&DAT_0011a640 + (ulong)DAT_00127334 * 4);\n    if ((DAT_00126029 == '\\0') && (DAT_0012732e == '\\0')) {\n      uVar1 = uVar1 | uVar2 | 0x204;\n    }\n    else {\n      uVar1 = uVar1 | uVar2 | 0x20c;\n    }\n    if (DAT_00126028 != '\\0') {\n      uVar1 = uVar1 | 0x10;\n    }\n    switch(DAT_00127330) {\n    case 0:\n    case 1:\n    case 2:\n    case 4:\n    case 6:\n      goto switchD_00106c53_caseD_0;\n    case 3:\nswitchD_00106c53_caseD_3:\n      return uVar1 | 0x200;\n    case 5:\nswitchD_00106c53_caseD_5:\n      return uVar1 | uVar2;\n    default:\nswitchD_00106c53_caseD_7:\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n  }\n  switch(DAT_00127330) {\n  case 0:\n  case 1:\n  case 2:\n  case 4:\n  case 6:\nswitchD_00106c53_caseD_0:\n    return uVar1;\n  case 3:\n    goto switchD_00106c53_caseD_3;\n  case 5:\n    uVar2 = *(uint *)(&DAT_0011a640 + (ulong)DAT_00127334 * 4);\n    goto switchD_00106c53_caseD_5;\n  default:\n    goto switchD_00106c53_caseD_7;\n  }\n}\n\n",
  "FUN_001170c0": "\nvoid FUN_001170c0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00116340(0,param_1,param_2,&DAT_00126220);\n  return;\n}\n\n",
  "FUN_001182d0": "\nvoid FUN_001182d0(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = malloc(param_2);\n  if (__dest != (void *)0x0) {\n    memcpy(__dest,param_1,param_2);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_00110fb0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong FUN_00110fb0(long param_1,undefined8 param_2)\n\n{\n  float *pfVar1;\n  void *pvVar2;\n  void *__ptr;\n  char cVar3;\n  long lVar4;\n  ulong uVar5;\n  ulong uVar6;\n  long in_FS_OFFSET;\n  float fVar7;\n  float fVar8;\n  long *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  lVar4 = FUN_0010ffe0(param_1,param_2,&local_28,1);\n  if ((lVar4 == 0) || (*(long *)(param_1 + 0x20) = *(long *)(param_1 + 0x20) + -1, *local_28 != 0))\n  goto LAB_00110ff3;\n  uVar5 = *(long *)(param_1 + 0x18) - 1;\n  *(ulong *)(param_1 + 0x18) = uVar5;\n  if ((long)uVar5 < 0) {\n    uVar6 = *(ulong *)(param_1 + 0x10);\n    fVar8 = (float)(uVar5 >> 1 | (ulong)((uint)uVar5 & 1));\n    fVar8 = fVar8 + fVar8;\n    if (-1 < (long)uVar6) goto LAB_00111040;\nLAB_001110f6:\n    fVar7 = (float)(uVar6 >> 1 | (ulong)((uint)uVar6 & 1));\n    fVar7 = fVar7 + fVar7;\n  }\n  else {\n    fVar8 = (float)uVar5;\n    uVar6 = *(ulong *)(param_1 + 0x10);\n    if ((long)uVar6 < 0) goto LAB_001110f6;\nLAB_00111040:\n    fVar7 = (float)uVar6;\n  }\n  if (fVar8 < **(float **)(param_1 + 0x28) * fVar7) {\n    FUN_0010ff50(param_1);\n    pfVar1 = *(float **)(param_1 + 0x28);\n    if (fVar8 < *pfVar1 * fVar7) {\n      fVar7 = fVar7 * pfVar1[1];\n      if (*(char *)(pfVar1 + 4) == '\\0') {\n        fVar7 = fVar7 * pfVar1[2];\n      }\n      if (_DAT_0011e698 <= fVar7) {\n        uVar5 = (long)(fVar7 - _DAT_0011e698) ^ 0x8000000000000000;\n      }\n      else {\n        uVar5 = (ulong)fVar7;\n      }\n      cVar3 = FUN_00110b70(param_1,uVar5);\n      if (cVar3 == '\\0') {\n        __ptr = *(void **)(param_1 + 0x48);\n        while (__ptr != (void *)0x0) {\n          pvVar2 = *(void **)((long)__ptr + 8);\n          free(__ptr);\n          __ptr = pvVar2;\n        }\n        *(undefined8 *)(param_1 + 0x48) = 0;\n      }\n    }\n  }\nLAB_00110ff3:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return lVar4;\n}\n\n",
  "FUN_00110a70": "\nvoid FUN_00110a70(long **param_1)\n\n{\n  int iVar1;\n  void *pvVar2;\n  void *__ptr;\n  int *piVar3;\n  long *plVar4;\n  long *plVar5;\n  long lVar6;\n  long *plVar7;\n  \n  piVar3 = __errno_location();\n  plVar7 = *param_1;\n  iVar1 = *piVar3;\n  plVar4 = param_1[1];\n  if ((param_1[8] != (long *)0x0) && (param_1[4] != (long *)0x0)) {\n    if (plVar4 <= plVar7) goto LAB_00110b23;\n    do {\n      while (lVar6 = *plVar7, plVar5 = plVar7, lVar6 != 0) {\n        while( true ) {\n          (*(code *)param_1[8])(lVar6);\n          plVar5 = (long *)plVar5[1];\n          if (plVar5 == (long *)0x0) break;\n          lVar6 = *plVar5;\n        }\n        plVar4 = param_1[1];\n        plVar7 = plVar7 + 2;\n        if (plVar4 <= plVar7) goto LAB_00110aec;\n      }\n      plVar7 = plVar7 + 2;\n    } while (plVar7 < plVar4);\nLAB_00110aec:\n    plVar7 = *param_1;\n  }\n  if (plVar7 < plVar4) {\n    do {\n      __ptr = (void *)plVar7[1];\n      while (__ptr != (void *)0x0) {\n        pvVar2 = *(void **)((long)__ptr + 8);\n        free(__ptr);\n        __ptr = pvVar2;\n      }\n      plVar7 = plVar7 + 2;\n    } while (plVar7 <= param_1[1] && param_1[1] != plVar7);\n  }\nLAB_00110b23:\n  plVar7 = param_1[9];\n  while (plVar7 != (long *)0x0) {\n    plVar4 = (long *)plVar7[1];\n    free(plVar7);\n    plVar7 = plVar4;\n  }\n  free(*param_1);\n  free(param_1);\n  *piVar3 = iVar1;\n  return;\n}\n\n",
  "FUN_0010f380": "\nvoid FUN_0010f380(undefined param_1)\n\n{\n  DAT_001273d0 = param_1;\n  return;\n}\n\n",
  "mbstowcs": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbstowcs(wchar_t *__pwcs,char *__s,size_t __n)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_mbstowcs_00125d30)();\n  return sVar1;\n}\n\n",
  "FUN_0010f6a0": "\nvoid FUN_0010f6a0(long param_1)\n\n{\n  FUN_0010f520(*(undefined4 *)(param_1 + 0x18));\n  return;\n}\n\n",
  "FUN_001106e0": "\nlong FUN_001106e0(long *param_1,long param_2)\n\n{\n  long lVar1;\n  ulong uVar2;\n  long *plVar3;\n  long *plVar4;\n  \n  uVar2 = (*(code *)param_1[6])(param_2,param_1[2]);\n  if ((ulong)param_1[2] <= uVar2) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  plVar3 = (long *)(uVar2 * 0x10 + *param_1);\n  plVar4 = plVar3;\n  do {\n    lVar1 = *plVar4;\n    plVar4 = (long *)plVar4[1];\n    if (lVar1 == param_2) {\n      if (plVar4 != (long *)0x0) {\n        return *plVar4;\n      }\n      break;\n    }\n  } while (plVar4 != (long *)0x0);\n  do {\n    plVar3 = plVar3 + 2;\n    if ((long *)param_1[1] <= plVar3) {\n      return 0;\n    }\n  } while (*plVar3 == 0);\n  return *plVar3;\n}\n\n",
  "fgetfilecon": "\nvoid fgetfilecon(void)\n\n{\n  (*(code *)PTR_fgetfilecon_00125ca0)();\n  return;\n}\n\n",
  "getfilecon": "\nvoid getfilecon(void)\n\n{\n  (*(code *)PTR_getfilecon_00125f58)();\n  return;\n}\n\n",
  "FUN_0010a820": "\nulong FUN_0010a820(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010a8a0;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010a8a0:\n  uVar3 = FUN_00108aa0();\n  return uVar3;\n}\n\n",
  "FUN_00117700": "\ntm * FUN_00117700(long param_1,time_t *param_2,tm *param_3)\n\n{\n  char cVar1;\n  long lVar2;\n  tm *ptVar3;\n  \n  if (param_1 == 0) {\n    ptVar3 = gmtime_r(param_2,param_3);\n    return ptVar3;\n  }\n  lVar2 = FUN_001175c0();\n  if (lVar2 != 0) {\n    ptVar3 = localtime_r(param_2,param_3);\n    if ((ptVar3 == (tm *)0x0) || (cVar1 = FUN_00117490(param_1,param_3), cVar1 == '\\0')) {\n      if (lVar2 != 1) {\n        FUN_00117360(lVar2);\n      }\n    }\n    else if ((lVar2 == 1) || (cVar1 = FUN_00117360(lVar2), cVar1 != '\\0')) {\n      return param_3;\n    }\n  }\n  return (tm *)0x0;\n}\n\n",
  "FUN_0010baa0": "\nint FUN_0010baa0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  iVar5 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar5 == 9 || iVar5 == 3) goto LAB_0010bb20;\n    iVar5 = 1;\n  }\n  else {\n    if (iVar5 == 9 || iVar5 == 3) {\n      return -1;\n    }\n    iVar5 = 0;\n  }\n  iVar5 = iVar5 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar5 != 0) {\n    return iVar5;\n  }\nLAB_0010bb20:\n  pcVar1 = param_2[0x10];\n  pcVar2 = param_1[0x10];\n  pcVar3 = param_2[0x11];\n  pcVar4 = param_1[0x11];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_1[0x11] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_1[0x10] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 != 0) {\n    return iVar5;\n  }\n  iVar5 = strcmp(*param_1,*param_2);\n  return iVar5;\n}\n\n",
  "FUN_00106940": "\nvoid FUN_00106940(int param_1)\n\n{\n  if (DAT_00127218 == 0) {\n    DAT_00127218 = param_1;\n  }\n  return;\n}\n\n",
  "FUN_00114e40": "\nchar * FUN_00114e40(char *param_1,int param_2)\n\n{\n  byte *pbVar1;\n  char *pcVar2;\n  \n  pbVar1 = (byte *)FUN_001196a0();\n  if ((*pbVar1 & 0xdf) == 0x55) {\n    if (((((pbVar1[1] & 0xdf) == 0x54) && ((pbVar1[2] & 0xdf) == 0x46)) && (pbVar1[3] == 0x2d)) &&\n       ((pbVar1[4] == 0x38 && (pbVar1[5] == 0)))) {\n      pcVar2 = &DAT_0011e983;\n      if (*param_1 != '`') {\n        pcVar2 = &DAT_0011e976;\n      }\n      return pcVar2;\n    }\n  }\n  else if (((((*pbVar1 & 0xdf) == 0x47) && ((pbVar1[1] & 0xdf) == 0x42)) && (pbVar1[2] == 0x31)) &&\n          (((pbVar1[3] == 0x38 && (pbVar1[4] == 0x30)) &&\n           ((pbVar1[5] == 0x33 && ((pbVar1[6] == 0x30 && (pbVar1[7] == 0)))))))) {\n    pcVar2 = &DAT_0011e97f;\n    if (*param_1 != '`') {\n      pcVar2 = &DAT_0011e97a;\n    }\n    return pcVar2;\n  }\n  pcVar2 = \"\\\"\";\n  if (param_2 != 9) {\n    pcVar2 = \"\\'\";\n  }\n  return pcVar2;\n}\n\n",
  "_obstack_newchunk": "\nulong * _obstack_newchunk(ulong **param_1,ulong param_2)\n\n{\n  byte bVar1;\n  ulong **ppuVar2;\n  ulong *puVar3;\n  ulong *puVar4;\n  ulong *puVar5;\n  ulong __n;\n  ulong *puVar6;\n  bool bVar7;\n  \n  __n = (long)param_1[3] - (long)param_1[2];\n  puVar4 = param_1[1];\n  bVar7 = CARRY8(param_2 + __n,(ulong)param_1[6]);\n  puVar5 = (ulong *)(param_2 + __n + (long)param_1[6]);\n  puVar6 = (ulong *)CONCAT71((int7)((ulong)param_1 >> 8),bVar7);\n  puVar3 = (ulong *)((long)puVar5 + (__n >> 3) + 100);\n  if (puVar5 < *param_1) {\n    puVar5 = *param_1;\n  }\n  if (puVar5 <= puVar3) {\n    puVar5 = puVar3;\n  }\n  puVar3 = puVar5;\n  if ((CARRY8(param_2,__n) == false) && (puVar6 = (ulong *)(ulong)bVar7, puVar6 == (ulong *)0x0)) {\n    if ((*(byte *)(param_1 + 10) & 1) == 0) {\n      puVar6 = puVar5;\n      ppuVar2 = (ulong **)(*(code *)param_1[7])();\n    }\n    else {\n      puVar6 = param_1[9];\n      ppuVar2 = (ulong **)(*(code *)param_1[7])();\n    }\n    if (ppuVar2 != (ulong **)0x0) {\n      param_1[1] = (ulong *)ppuVar2;\n      puVar3 = param_1[2];\n      ppuVar2[1] = puVar4;\n      param_1[4] = (ulong *)((long)ppuVar2 + (long)puVar5);\n      *ppuVar2 = (ulong *)((long)ppuVar2 + (long)puVar5);\n      puVar6 = (ulong *)((long)(ppuVar2 + 2) + (long)param_1[6] & ~(ulong)param_1[6]);\n      puVar3 = (ulong *)memcpy(puVar6,puVar3,__n);\n      bVar1 = *(byte *)(param_1 + 10);\n      if ((bVar1 & 2) == 0) {\n        puVar3 = (ulong *)(~(ulong)param_1[6] & (long)(puVar4 + 2) + (long)param_1[6]);\n        if (param_1[2] == puVar3) {\n          ppuVar2[1] = (ulong *)puVar4[1];\n          if ((bVar1 & 1) == 0) {\n            puVar3 = (ulong *)(*(code *)param_1[8])(puVar4);\n          }\n          else {\n            puVar3 = (ulong *)(*(code *)param_1[8])(param_1[9],puVar4);\n          }\n        }\n      }\n      param_1[2] = puVar6;\n      param_1[3] = (ulong *)((long)puVar6 + __n);\n      *(byte *)(param_1 + 10) = *(byte *)(param_1 + 10) & 0xfd;\n      return puVar3;\n    }\n  }\n  (*(code *)obstack_alloc_failed_handler)();\n  puVar4 = (ulong *)puVar6[1];\n  if (puVar4 == (ulong *)0x0) {\n    return puVar4;\n  }\n  while ((puVar3 <= puVar4 || ((ulong *)*puVar4 < puVar3))) {\n    puVar4 = (ulong *)puVar4[1];\n    if (puVar4 == (ulong *)0x0) {\n      return (ulong *)0x0;\n    }\n  }\n  return (ulong *)0x1;\n}\n\n",
  "__fpending": "\nvoid __fpending(void)\n\n{\n  (*(code *)PTR___fpending_00125cf0)();\n  return;\n}\n\n",
  "FUN_0010f390": "\nvoid FUN_0010f390(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  \n  iVar1 = FUN_00119490(stdout);\n  if (iVar1 != 0) {\n    piVar2 = __errno_location();\n    if ((DAT_001273d0 == '\\0') || (*piVar2 != 0x20)) {\n      if (DAT_001273d8 == 0) {\n        error(0,*piVar2,&DAT_0011e5db,\"write error\");\n      }\n      else {\n        uVar3 = FUN_00116c60();\n        error(0,*piVar2,\"%s: %s\",uVar3,\"write error\");\n      }\n      goto LAB_0010f3fa;\n    }\n  }\n  iVar1 = FUN_00119490(stderr);\n  if (iVar1 == 0) {\n    return;\n  }\nLAB_0010f3fa:\n                    /* WARNING: Subroutine does not return */\n  _exit(DAT_001261f8);\n}\n\n",
  "FUN_0010f7d0": "\nulong FUN_0010f7d0(long param_1,ulong *param_2)\n\n{\n  ulong uVar1;\n  char cVar2;\n  ulong uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  \n  uVar3 = *param_2;\n  uVar5 = 0;\n  uVar4 = 0;\nLAB_0010f7e4:\n  if ((long)uVar3 < 0) goto LAB_0010f845;\nLAB_0010f7e9:\n  if (uVar3 == uVar4) {\nLAB_0010f84b:\n    *param_2 = uVar4;\n    return uVar5;\n  }\n  do {\n    uVar5 = uVar4 + 1;\n    uVar1 = uVar4 + 2;\n    uVar4 = uVar5;\n    if (uVar3 <= uVar1) goto LAB_0010f7e4;\n    do {\n      if (*(char *)(param_1 + uVar4) != '.') goto LAB_0010f7e4;\n      cVar2 = *(char *)(param_1 + 1 + uVar4);\n      if (cVar2 < '[') {\n        if (cVar2 < 'A') goto LAB_0010f7e4;\n      }\n      else if ((0x19 < (byte)(cVar2 + 0x9fU)) && (cVar2 != '~')) goto LAB_0010f7e4;\n      for (uVar4 = uVar4 + 2; uVar4 < uVar3; uVar4 = uVar4 + 1) {\n        cVar2 = *(char *)(param_1 + uVar4);\n        if (cVar2 < '[') {\n          if ((cVar2 < 'A') && (9 < (byte)(cVar2 - 0x30U))) break;\n        }\n        else if ((0x19 < (byte)(cVar2 + 0x9fU)) && (cVar2 != '~')) break;\n      }\n    } while (uVar4 + 1 < uVar3);\n    if (-1 < (long)uVar3) goto LAB_0010f7e9;\nLAB_0010f845:\n    if (*(char *)(param_1 + uVar4) == '\\0') goto LAB_0010f84b;\n  } while( true );\n}\n\n",
  "FUN_001104b0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_001104b0(long **param_1,undefined8 param_2)\n\n{\n  long *plVar1;\n  long *plVar2;\n  long lVar3;\n  long *plVar4;\n  ulong uVar5;\n  ulong uVar6;\n  double dVar7;\n  double dVar8;\n  \n  uVar6 = 0;\n  plVar1 = param_1[2];\n  plVar2 = param_1[3];\n  for (plVar4 = *param_1; plVar4 < param_1[1]; plVar4 = plVar4 + 2) {\n    while (*plVar4 != 0) {\n      uVar5 = 1;\n      for (lVar3 = plVar4[1]; lVar3 != 0; lVar3 = *(long *)(lVar3 + 8)) {\n        uVar5 = uVar5 + 1;\n      }\n      if (uVar6 < uVar5) {\n        uVar6 = uVar5;\n      }\n      plVar4 = plVar4 + 2;\n      if (param_1[1] <= plVar4) goto LAB_0011051d;\n    }\n  }\nLAB_0011051d:\n  __fprintf_chk(param_2,1,\"# entries:         %lu\\n\",param_1[4]);\n  __fprintf_chk(param_2,1,\"# buckets:         %lu\\n\",plVar1);\n  if ((long)plVar2 < 0) {\n    dVar7 = (double)((ulong)plVar2 >> 1 | (ulong)((uint)plVar2 & 1));\n    dVar7 = dVar7 + dVar7;\n  }\n  else {\n    dVar7 = (double)(long)plVar2;\n  }\n  if ((long)plVar1 < 0) {\n    dVar8 = (double)((ulong)plVar1 >> 1 | (ulong)((uint)plVar1 & 1));\n    dVar8 = dVar8 + dVar8;\n  }\n  else {\n    dVar8 = (double)(long)plVar1;\n  }\n  __fprintf_chk((dVar7 * _DAT_0011e6a0) / dVar8,param_2,1,\"# buckets used:    %lu (%.2f%%)\\n\",plVar2\n               );\n  __fprintf_chk(param_2,1,\"max bucket length: %lu\\n\",uVar6);\n  return;\n}\n\n",
  "FUN_0010f6b0": "\nvoid FUN_0010f6b0(void)\n\n{\n  long lVar1;\n  \n  lVar1 = FUN_0010f6d0();\n  if (lVar1 != 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "_FINI_0": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_001262c8 == '\\0') {\n    if (PTR___cxa_finalize_00125fe8 != (undefined *)0x0) {\n      FUN_001046a0(PTR_LOOP_00126008);\n    }\n    FUN_00106850();\n    DAT_001262c8 = 1;\n    return;\n  }\n  return;\n}\n\n",
  "mempcpy": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * mempcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_mempcpy_00125ef0)();\n  return pvVar1;\n}\n\n",
  "FUN_0010e6e0": "\nvoid FUN_0010e6e0(undefined8 param_1,undefined8 param_2,long param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  pcVar3 = \"invalid argument %s for %s\";\n  if (param_3 != -1) {\n    pcVar3 = \"ambiguous argument %s for %s\";\n  }\n  uVar1 = FUN_001170e0(1,param_1);\n  uVar2 = FUN_001168e0(0,8,param_2);\n  error(0,0,pcVar3,uVar2,uVar1);\n  return;\n}\n\n",
  "strchr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strchr_00125d98)();\n  return pcVar1;\n}\n\n",
  "FUN_00111180": "\nundefined8 FUN_00111180(char **param_1,char **param_2)\n\n{\n  int iVar1;\n  undefined4 extraout_var;\n  \n  if ((param_1[1] == param_2[1]) && (param_1[2] == param_2[2])) {\n    iVar1 = strcmp(*param_1,*param_2);\n    return CONCAT71((int7)(CONCAT44(extraout_var,iVar1) >> 8),iVar1 == 0);\n  }\n  return 0;\n}\n\n",
  "fwrite_unlocked": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite_unlocked(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_fwrite_unlocked_00125ec0)();\n  return sVar1;\n}\n\n",
  "FUN_00116870": "\nvoid FUN_00116870(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00116340(param_1,param_2,0xffffffffffffffff,&DAT_00127520);\n  return;\n}\n\n",
  "FUN_0010aae0": "\nint FUN_0010aae0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  int iVar3;\n  int *piVar4;\n  \n  iVar3 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar3 == 9 || iVar3 == 3) goto LAB_0010ab60;\n    iVar3 = 1;\n  }\n  else {\n    if (iVar3 == 9 || iVar3 == 3) {\n      return -1;\n    }\n    iVar3 = 0;\n  }\n  iVar3 = iVar3 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar3 != 0) {\n    return iVar3;\n  }\nLAB_0010ab60:\n  pcVar1 = param_2[9];\n  pcVar2 = param_1[9];\n  iVar3 = (uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_1[9] != pcVar1 && (long)pcVar1 <= (long)pcVar2);\n  if (iVar3 != 0) {\n    return iVar3;\n  }\n  pcVar1 = *param_1;\n  pcVar2 = *param_2;\n  piVar4 = __errno_location();\n  *piVar4 = 0;\n  iVar3 = strcoll(pcVar1,pcVar2);\n  return iVar3;\n}\n\n",
  "FUN_001170e0": "\nvoid FUN_001170e0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00116340(param_1,param_2,0xffffffffffffffff,&DAT_00126220);\n  return;\n}\n\n",
  "FUN_00112b50": "\nvoid FUN_00112b50(undefined8 *param_1,ulong param_2,undefined8 *param_3,code *param_4)\n\n{\n  undefined8 *puVar1;\n  ulong uVar2;\n  int iVar3;\n  ulong uVar4;\n  ulong uVar5;\n  ulong uVar6;\n  undefined8 uVar7;\n  undefined8 *puVar8;\n  undefined8 *puVar9;\n  undefined8 uVar10;\n  long lVar11;\n  long lVar12;\n  ulong local_68;\n  ulong local_48;\n  \n  uVar4 = param_2 >> 1;\n  uVar5 = param_2 - uVar4;\n  puVar1 = param_1 + uVar4;\n  if (uVar5 < 3) {\n    if (uVar5 == 2) {\n      uVar10 = *puVar1;\n      uVar7 = puVar1[1];\n      iVar3 = (*param_4)(uVar10,uVar7);\n      if (0 < iVar3) {\n        *puVar1 = uVar7;\n        puVar1[1] = uVar10;\n      }\n    }\n  }\n  else {\n    FUN_00112b50(puVar1,uVar5,param_3);\n  }\n  if (param_2 == 3) {\n    uVar10 = *param_1;\n    *param_3 = uVar10;\n    goto LAB_00112bac;\n  }\n  uVar5 = param_2 >> 2;\n  uVar6 = uVar4 - uVar5;\n  puVar8 = param_1 + uVar5;\n  if (uVar6 < 3) {\n    if (uVar6 == 2) {\n      uVar10 = *puVar8;\n      uVar7 = puVar8[1];\n      iVar3 = (*param_4)(uVar10,uVar7);\n      if (0 < iVar3) {\n        *puVar8 = uVar7;\n        puVar8[1] = uVar10;\n      }\n    }\n  }\n  else {\n    FUN_00112b50(puVar8,uVar6,param_3,param_4);\n  }\n  if (uVar5 < 3) {\n    uVar10 = *param_1;\n    uVar7 = uVar10;\n    if (uVar5 == 2) {\n      uVar7 = param_1[1];\n      iVar3 = (*param_4)(uVar10,uVar7);\n      if (iVar3 < 1) goto LAB_00112da9;\n      param_1[1] = uVar10;\n      *param_1 = uVar7;\n    }\n  }\n  else {\n    FUN_00112b50(param_1,uVar5,param_3,param_4);\nLAB_00112da9:\n    uVar7 = *param_1;\n  }\n  uVar10 = *puVar8;\n  local_68 = 0;\n  uVar6 = uVar5;\n  puVar8 = param_3;\n  while( true ) {\n    iVar3 = (*param_4)(uVar7,uVar10);\n    puVar9 = puVar8;\n    while (puVar8 = puVar9 + 1, 0 < iVar3) {\n      *puVar9 = uVar10;\n      uVar6 = uVar6 + 1;\n      local_48 = uVar5;\n      if (uVar4 == uVar6) goto LAB_00112d3e;\n      uVar10 = param_1[uVar6];\n      iVar3 = (*param_4)(uVar7,uVar10);\n      puVar9 = puVar8;\n    }\n    uVar2 = local_68 + 1;\n    *puVar9 = uVar7;\n    local_68 = uVar6;\n    local_48 = uVar4;\n    if (uVar5 == uVar2) break;\n    uVar7 = param_1[uVar2];\n    local_68 = uVar2;\n  }\nLAB_00112d3e:\n  memcpy(puVar8,param_1 + local_68,(local_48 - local_68) * 8);\n  uVar10 = *param_3;\nLAB_00112bac:\n  local_68 = 0;\n  lVar11 = 0;\n  uVar7 = *puVar1;\n  uVar5 = uVar4;\n  while( true ) {\n    iVar3 = (*param_4)(uVar10,uVar7);\n    lVar12 = lVar11;\n    while (lVar11 = lVar12 + 1, 0 < iVar3) {\n      param_1[lVar12] = uVar7;\n      uVar5 = uVar5 + 1;\n      if (param_2 == uVar5) {\n        memcpy(param_1 + lVar11,param_3 + local_68,(uVar4 - local_68) * 8);\n        return;\n      }\n      uVar7 = param_1[uVar5];\n      iVar3 = (*param_4)(uVar10,uVar7);\n      lVar12 = lVar11;\n    }\n    local_68 = local_68 + 1;\n    param_1[lVar12] = uVar10;\n    if (uVar4 == local_68) break;\n    uVar10 = param_3[local_68];\n  }\n  return;\n}\n\n",
  "FUN_001083e0": "\nvoid FUN_001083e0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  pcVar1 = param_1[9];\n  pcVar2 = param_2[9];\n  if ((long)pcVar2 < (long)pcVar1 == (param_2[9] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) {\n    strcmp(*param_2,*param_1);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_0010b1e0": "\nint FUN_0010b1e0(char **param_1,char **param_2)\n\n{\n  char *__s2;\n  char *__s1;\n  int iVar1;\n  int *piVar2;\n  \n  iVar1 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar1 == 3 || iVar1 == 9) goto LAB_0010b260;\n    iVar1 = 1;\n  }\n  else {\n    if (iVar1 == 3 || iVar1 == 9) {\n      return -1;\n    }\n    iVar1 = 0;\n  }\n  iVar1 = iVar1 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar1 != 0) {\n    return iVar1;\n  }\nLAB_0010b260:\n  __s2 = *param_1;\n  __s1 = *param_2;\n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  iVar1 = strcoll(__s1,__s2);\n  return iVar1;\n}\n\n",
  "FUN_0010b930": "\nint FUN_0010b930(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  iVar5 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar5 == 9 || iVar5 == 3) goto LAB_0010b9b0;\n    iVar5 = 1;\n  }\n  else {\n    if (iVar5 == 9 || iVar5 == 3) {\n      return -1;\n    }\n    iVar5 = 0;\n  }\n  iVar5 = iVar5 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar5 != 0) {\n    return iVar5;\n  }\nLAB_0010b9b0:\n  pcVar1 = param_1[0x10];\n  pcVar2 = param_2[0x10];\n  pcVar3 = param_1[0x11];\n  pcVar4 = param_2[0x11];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_2[0x11] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_2[0x10] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 != 0) {\n    return iVar5;\n  }\n  iVar5 = strcmp(*param_2,*param_1);\n  return iVar5;\n}\n\n",
  "statx": "\nvoid statx(void)\n\n{\n  (*(code *)PTR_statx_00125ee0)();\n  return;\n}\n\n",
  "FUN_001193f0": "\nvoid FUN_001193f0(undefined8 param_1)\n\n{\n  tzset();\n  FUN_00118e40(param_1,PTR_localtime_r_00125fb8,&DAT_00127560);\n  return;\n}\n\n",
  "FUN_00104d03": "\nvoid FUN_00104d03(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00106960": "\nundefined4 FUN_00106960(long *param_1,char **param_2,undefined4 param_3,long *param_4)\n\n{\n  byte bVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char cVar4;\n  char cVar5;\n  long lVar6;\n  long lVar7;\n  long lVar8;\n  long lVar9;\n  long lVar10;\n  char *pcVar11;\n  bool bVar12;\n  \n  pcVar2 = *param_2;\n  lVar10 = *param_1;\n  lVar8 = 1;\n  cVar4 = *pcVar2;\n  lVar9 = 0;\n  lVar7 = lVar10 + 1;\n  cVar5 = cVar4 + -0x5c;\n  bVar12 = cVar4 == '\\\\';\n  pcVar3 = pcVar2;\n  lVar6 = lVar7;\n  if (bVar12) goto LAB_001069c6;\nLAB_0010699a:\n  if (bVar12 || SBORROW1(cVar4,'\\\\') != cVar5 < '\\0') {\n    if (cVar4 == '=') {\n      if ((char)param_3 != '\\0') goto LAB_001069fe;\n    }\n    else if ((cVar4 < '>') && ((cVar4 == '\\0' || (cVar4 == ':')))) {\n      param_3 = 1;\nLAB_001069fe:\n      *param_1 = lVar10;\n      *param_2 = pcVar2;\n      *param_4 = lVar9;\n      return param_3;\n    }\n  }\n  else if (cVar4 == '^') {\n    bVar1 = pcVar2[1];\n    if ((byte)(bVar1 - 0x40) < 0x3f) {\n      pcVar2 = pcVar2 + 2;\n      lVar8 = lVar8 + 1;\n      lVar7 = lVar6 + 1;\n      *(byte *)(lVar6 + -1) = bVar1 & 0x1f;\n      goto LAB_001069b6;\n    }\n    pcVar2 = pcVar2 + 1;\n    if (bVar1 == 0x3f) {\n      lVar8 = lVar8 + 1;\n      lVar7 = lVar6 + 1;\n      *(undefined *)(lVar6 + -1) = 0x7f;\n      goto LAB_001069b6;\n    }\n    param_3 = 0;\n    goto LAB_001069fe;\n  }\n  pcVar2 = pcVar2 + 1;\n  lVar7 = lVar6;\nLAB_001069ab:\n  *(char *)(lVar7 + -1) = cVar4;\n  lVar8 = lVar8 + 1;\n  lVar7 = lVar7 + 1;\nLAB_001069b6:\n  do {\n    cVar4 = *pcVar2;\n    lVar10 = lVar7 + -1;\n    lVar9 = lVar8 + -1;\n    cVar5 = cVar4 + -0x5c;\n    bVar12 = cVar5 == '\\0';\n    pcVar3 = pcVar2;\n    lVar6 = lVar7;\n    if (!bVar12) goto LAB_0010699a;\nLAB_001069c6:\n    cVar5 = pcVar3[1];\n    pcVar2 = pcVar3 + 2;\n    if (cVar5 == '\\0') {\n      param_3 = 0;\n      goto LAB_001069fe;\n    }\n    cVar4 = cVar5 + -0x30;\n    switch(cVar4) {\n    case '\\0':\n    case '\\x01':\n    case '\\x02':\n    case '\\x03':\n    case '\\x04':\n    case '\\x05':\n    case '\\x06':\n    case '\\a':\n      cVar5 = *pcVar2;\n      if (7 < (byte)(cVar5 - 0x30U)) goto LAB_001069ab;\n      do {\n        pcVar2 = pcVar2 + 1;\n        cVar4 = cVar5 + -0x30 + cVar4 * '\\b';\n        cVar5 = *pcVar2;\n      } while ((byte)(cVar5 - 0x30U) < 8);\n      *(char *)(lVar7 + -1) = cVar4;\n      lVar8 = lVar8 + 1;\n      lVar7 = lVar7 + 1;\n      goto LAB_001069b6;\n    case '\\x0f':\n      cVar5 = '\\x7f';\n      break;\n    case '(':\n    case 'H':\n      goto switchD_001069eb_caseD_28;\n    case '/':\n      cVar5 = ' ';\n      break;\n    case '1':\n      cVar5 = '\\a';\n      break;\n    case '2':\n      cVar5 = '\\b';\n      break;\n    case '5':\n      cVar5 = '\\x1b';\n      break;\n    case '6':\n      cVar5 = '\\f';\n      break;\n    case '>':\n      cVar5 = '\\n';\n      break;\n    case 'B':\n      cVar5 = '\\r';\n      break;\n    case 'D':\n      cVar5 = '\\t';\n      break;\n    case 'F':\n      cVar5 = '\\v';\n    }\n    *(char *)(lVar7 + -1) = cVar5;\n    lVar8 = lVar8 + 1;\n    lVar7 = lVar7 + 1;\n  } while( true );\nswitchD_001069eb_caseD_28:\n  cVar5 = pcVar3[2];\n  pcVar11 = pcVar3 + 3;\n  cVar4 = '\\0';\n  pcVar2 = pcVar3 + 2;\n  if ('F' < cVar5) goto LAB_00106b22;\n  do {\n    if (cVar5 < 'A') {\n      if (9 < (byte)(cVar5 - 0x30U)) goto LAB_001069ab;\n      cVar4 = cVar5 + -0x30 + cVar4 * '\\x10';\n      pcVar2 = pcVar11;\n    }\n    else {\n      cVar4 = cVar5 + -0x37 + cVar4 * '\\x10';\n      pcVar2 = pcVar11;\n    }\n    while( true ) {\n      cVar5 = *pcVar2;\n      pcVar11 = pcVar2 + 1;\n      if (cVar5 < 'G') break;\nLAB_00106b22:\n      if (5 < (byte)(cVar5 + 0x9fU)) goto LAB_001069ab;\n      cVar4 = cVar5 + -0x57 + cVar4 * '\\x10';\n      pcVar2 = pcVar11;\n    }\n  } while( true );\n}\n\n",
  "mbrtowc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t mbrtowc(wchar_t *__pwc,char *__s,size_t __n,mbstate_t *__p)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_mbrtowc_00125d88)();\n  return sVar1;\n}\n\n",
  "FUN_00104d09": "\nvoid FUN_00104d09(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_001103b0": "\nundefined8 FUN_001103b0(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x10);\n}\n\n",
  "FUN_0010f6d0": "\nvoid * FUN_0010f6d0(void *param_1,char *param_2,void **param_3)\n\n{\n  size_t __n;\n  long lVar1;\n  long lVar2;\n  size_t __n_00;\n  void *__dest;\n  undefined *puVar3;\n  ulong uVar4;\n  undefined local_41;\n  \n  lVar1 = FUN_0010e9d0();\n  lVar2 = FUN_0010ea30(lVar1);\n  __n = (lVar1 - (long)param_1) + lVar2;\n  __n_00 = strlen(param_2);\n  if (lVar2 == 0) {\n    local_41 = 0x2e;\n    if (*param_2 != '/') {\n      local_41 = 0;\n    }\n    uVar4 = (ulong)(*param_2 == '/');\n  }\n  else if (*(char *)((long)param_1 + (__n - 1)) == '/') {\n    local_41 = 0;\n    uVar4 = 0;\n  }\n  else {\n    local_41 = 0x2f;\n    if (*param_2 == '/') {\n      local_41 = 0;\n    }\n    uVar4 = (ulong)(*param_2 != '/');\n  }\n  __dest = malloc(__n + 1 + __n_00 + uVar4);\n  if (__dest != (void *)0x0) {\n    puVar3 = (undefined *)mempcpy(__dest,param_1,__n);\n    *puVar3 = local_41;\n    if (param_3 != (void **)0x0) {\n      *param_3 = puVar3 + uVar4;\n    }\n    puVar3 = (undefined *)mempcpy(puVar3 + uVar4,param_2,__n_00);\n    *puVar3 = 0;\n  }\n  return __dest;\n}\n\n",
  "FUN_00116530": "\nvoid FUN_00116530(undefined *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  if (param_1 == (undefined *)0x0) {\n    param_1 = &DAT_00127520;\n  }\n  FUN_00118290(param_1,0x38);\n  *piVar2 = iVar1;\n  return;\n}\n\n",
  "FUN_00112170": "\n__gid_t * FUN_00112170(__gid_t param_1)\n\n{\n  __gid_t *p_Var1;\n  group *pgVar2;\n  size_t sVar3;\n  __gid_t *p_Var4;\n  ulong uVar5;\n  char *__s;\n  \n  p_Var4 = DAT_001273e8;\n  if (DAT_001273e8 != (__gid_t *)0x0) {\n    do {\n      if (*p_Var4 == param_1) goto LAB_0011219d;\n      p_Var4 = *(__gid_t **)(p_Var4 + 2);\n    } while (p_Var4 != (__gid_t *)0x0);\n  }\n  __s = \"\";\n  pgVar2 = getgrgid(param_1);\n  uVar5 = 0x18;\n  if (pgVar2 != (group *)0x0) {\n    __s = pgVar2->gr_name;\n    sVar3 = strlen(__s);\n    uVar5 = sVar3 + 0x18 & 0xfffffffffffffff8;\n  }\n  p_Var4 = (__gid_t *)FUN_00117e10(uVar5);\n  *p_Var4 = param_1;\n  strcpy((char *)(p_Var4 + 4),__s);\n  p_Var1 = p_Var4;\n  *(__gid_t **)(p_Var4 + 2) = DAT_001273e8;\n  DAT_001273e8 = p_Var1;\nLAB_0011219d:\n  p_Var1 = (__gid_t *)0x0;\n  if (*(char *)(p_Var4 + 4) != '\\0') {\n    p_Var1 = p_Var4 + 4;\n  }\n  return p_Var1;\n}\n\n",
  "FUN_00116890": "\nvoid FUN_00116890(void)\n\n{\n  FUN_00116340();\n  return;\n}\n\n",
  "FUN_001093c0": "\nvoid FUN_001093c0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  pcVar2 = param_1[0x19];\n  if (pcVar2 == (char *)0x0) {\n    pcVar2 = (char *)FUN_00107e30(*param_1,DAT_001272d0,*(undefined4 *)((long)param_1 + 0xc4));\n  }\n  pcVar1 = param_2[0x19];\n  if (pcVar1 == (char *)0x0) {\n    pcVar1 = (char *)FUN_00107e30(*param_2,DAT_001272d0,*(undefined4 *)((long)param_2 + 0xc4));\n  }\n  if ((int)pcVar2 == (int)pcVar1) {\n    strcmp(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00116650": "\nvoid FUN_00116650(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined4 *param_5)\n\n{\n  int iVar1;\n  int *piVar2;\n  \n  if (param_5 == (undefined4 *)0x0) {\n    param_5 = (undefined4 *)&DAT_00127520;\n  }\n  piVar2 = __errno_location();\n  iVar1 = *piVar2;\n  FUN_00114f20(param_1,param_2,param_3,param_4,*param_5,param_5[1],param_5 + 2,\n               *(undefined8 *)(param_5 + 10),*(undefined8 *)(param_5 + 0xc));\n  *piVar2 = iVar1;\n  return;\n}\n\n",
  "FUN_001092a0": "\nvoid FUN_001092a0(char **param_1,char **param_2)\n\n{\n  char *__s;\n  char *__s_00;\n  int iVar1;\n  char *__s1;\n  char *__s2;\n  int *piVar2;\n  \n  __s = *param_1;\n  __s1 = strrchr(__s,0x2e);\n  __s_00 = *param_2;\n  __s2 = strrchr(__s_00,0x2e);\n  if (__s2 == (char *)0x0) {\n    __s2 = \"\";\n  }\n  if (__s1 == (char *)0x0) {\n    __s1 = \"\";\n  }\n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  iVar1 = strcoll(__s1,__s2);\n  if (iVar1 == 0) {\n    strcoll(__s,__s_00);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00104d18": "\nvoid FUN_00104d18(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00111fc0": "\n__uid_t * FUN_00111fc0(__uid_t param_1)\n\n{\n  __uid_t *p_Var1;\n  passwd *ppVar2;\n  size_t sVar3;\n  __uid_t *p_Var4;\n  ulong uVar5;\n  char *__s;\n  \n  p_Var4 = DAT_001273f8;\n  if (DAT_001273f8 != (__uid_t *)0x0) {\n    do {\n      if (*p_Var4 == param_1) goto LAB_00111fed;\n      p_Var4 = *(__uid_t **)(p_Var4 + 2);\n    } while (p_Var4 != (__uid_t *)0x0);\n  }\n  __s = \"\";\n  ppVar2 = getpwuid(param_1);\n  uVar5 = 0x18;\n  if (ppVar2 != (passwd *)0x0) {\n    __s = ppVar2->pw_name;\n    sVar3 = strlen(__s);\n    uVar5 = sVar3 + 0x18 & 0xfffffffffffffff8;\n  }\n  p_Var4 = (__uid_t *)FUN_00117e10(uVar5);\n  *p_Var4 = param_1;\n  strcpy((char *)(p_Var4 + 4),__s);\n  p_Var1 = p_Var4;\n  *(__uid_t **)(p_Var4 + 2) = DAT_001273f8;\n  DAT_001273f8 = p_Var1;\nLAB_00111fed:\n  p_Var1 = (__uid_t *)0x0;\n  if (*(char *)(p_Var4 + 4) != '\\0') {\n    p_Var1 = p_Var4 + 4;\n  }\n  return p_Var1;\n}\n\n",
  "FUN_001181f0": "\nvoid FUN_001181f0(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(param_1,1);\n  if (pvVar1 != (void *)0x0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_00104d13": "\nvoid FUN_00104d13(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00107940": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00107940(size_t *param_1)\n\n{\n  __pid_t _Var1;\n  \n  if (DAT_00127310 == '\\0') {\n    DAT_00127310 = '\\x01';\n    _Var1 = tcgetpgrp(1);\n    if (-1 < _Var1) {\n      FUN_00107770(1);\n    }\n    if (_DAT_00126088 == 0) {\n      FUN_00107940(&DAT_00126060);\n      FUN_00107940(&DAT_00126090);\n      FUN_00107940(&DAT_00126070);\n    }\n    else {\n      FUN_00107940(&DAT_00126080);\n    }\n  }\n  fwrite_unlocked((void *)param_1[1],*param_1,1,stdout);\n  return;\n}\n\n",
  "FUN_00106850": "\n/* WARNING: Removing unreachable block (ram,0x00106863) */\n/* WARNING: Removing unreachable block (ram,0x0010686f) */\n\nvoid FUN_00106850(void)\n\n{\n  return;\n}\n\n",
  "free": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid free(void *__ptr)\n\n{\n  (*(code *)PTR_free_00125fa0)();\n  return;\n}\n\n",
  "FUN_00108ce0": "\nvoid FUN_00108ce0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int *piVar5;\n  \n  pcVar1 = param_1[0xc];\n  pcVar2 = param_2[0xc];\n  pcVar3 = param_1[0xd];\n  pcVar4 = param_2[0xd];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_2[0xd] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_2[0xc] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    pcVar1 = *param_2;\n    pcVar2 = *param_1;\n    piVar5 = __errno_location();\n    *piVar5 = 0;\n    strcoll(pcVar1,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00108aa0": "\nvoid FUN_00108aa0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int *piVar5;\n  \n  pcVar1 = param_1[0xe];\n  pcVar2 = param_2[0xe];\n  pcVar3 = param_1[0xf];\n  pcVar4 = param_2[0xf];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_2[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_2[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    pcVar1 = *param_2;\n    pcVar2 = *param_1;\n    piVar5 = __errno_location();\n    *piVar5 = 0;\n    strcoll(pcVar1,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00114d50": "\nvoid FUN_00114d50(char *param_1)\n\n{\n  char *pcVar1;\n  int iVar2;\n  char *pcVar3;\n  \n  if (param_1 == (char *)0x0) {\n    fwrite(\"A NULL argv[0] was passed through an exec system call.\\n\",1,0x37,stderr);\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  pcVar3 = strrchr(param_1,0x2f);\n  if ((((pcVar3 != (char *)0x0) && (pcVar1 = pcVar3 + 1, 6 < (long)pcVar1 - (long)param_1)) &&\n      (iVar2 = strncmp(pcVar3 + -6,\"/.libs/\",7), iVar2 == 0)) &&\n     (((param_1 = pcVar1, pcVar3[1] == 'l' && (pcVar3[2] == 't')) && (pcVar3[3] == '-')))) {\n    program_invocation_short_name = pcVar3 + 4;\n    param_1 = program_invocation_short_name;\n  }\n  DAT_00127400 = param_1;\n  program_invocation_name = param_1;\n  return;\n}\n\n",
  "FUN_001080a0": "\nulong FUN_001080a0(char param_1)\n\n{\n  ulong *puVar1;\n  undefined8 *puVar2;\n  undefined auVar3 [16];\n  undefined auVar4 [16];\n  ulong uVar5;\n  long lVar6;\n  undefined8 *puVar7;\n  ulong uVar8;\n  ulong uVar9;\n  long lVar10;\n  ulong uVar11;\n  ulong uVar12;\n  char *pcVar13;\n  ulong uVar14;\n  ulong uVar15;\n  bool bVar16;\n  \n  uVar15 = DAT_001273b0;\n  if (DAT_00127200 == 0) {\n    if (DAT_001262e0 < DAT_001273b0) {\nLAB_001080e5:\n      DAT_00127208 = (char *)FUN_00117ed0(DAT_00127208,uVar15,0x30);\n      uVar12 = uVar15 * 2;\n      goto LAB_00108104;\n    }\nLAB_0010832c:\n    if (DAT_001273b0 == 0) goto LAB_00108338;\nLAB_0010819c:\n    uVar12 = DAT_001273b0;\n    pcVar13 = DAT_00127208;\n    lVar6 = 3;\n    uVar14 = 0;\n    do {\n      puVar2 = *(undefined8 **)(pcVar13 + lVar6 * 8 + -8);\n      pcVar13[lVar6 * 8 + -0x18] = '\\x01';\n      *(long *)(pcVar13 + lVar6 * 8 + -0x10) = lVar6;\n      puVar7 = puVar2;\n      do {\n        *puVar7 = 3;\n        bVar16 = puVar2 + uVar14 != puVar7;\n        puVar7 = puVar7 + 1;\n      } while (bVar16);\n      uVar14 = uVar14 + 1;\n      lVar6 = lVar6 + 3;\n    } while (uVar14 < uVar15);\n    if (uVar12 == 0) goto LAB_001082ed;\n  }\n  else {\n    if (DAT_00127200 < DAT_001273b0) {\n      uVar15 = DAT_00127200;\n      if (DAT_00127200 <= DAT_001262e0) goto LAB_0010819c;\n      if (DAT_00127200 < DAT_00127200 >> 1) goto LAB_001080e5;\n    }\n    else {\n      if (DAT_001273b0 <= DAT_001262e0) goto LAB_0010832c;\n      if (DAT_001273b0 < DAT_00127200 >> 1) goto LAB_001080e5;\n    }\n    DAT_00127208 = (char *)FUN_00117ed0(DAT_00127208,DAT_00127200,0x18);\n    uVar12 = DAT_00127200;\nLAB_00108104:\n    auVar3._8_8_ = 0;\n    auVar3._0_8_ = uVar12 - DAT_001262e0;\n    auVar4._8_8_ = 0;\n    auVar4._0_8_ = DAT_001262e0 + 1 + uVar12;\n    if ((CARRY8(DAT_001262e0 + 1,uVar12) != false) || (SUB168(auVar3 * auVar4,8) != 0)) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00118390();\n    }\n    lVar6 = FUN_00117f50(SUB168(auVar3 * auVar4,0) >> 1,8);\n    pcVar13 = DAT_00127208;\n    if (DAT_001262e0 < uVar12) {\n      lVar10 = DAT_001262e0 * 8 + 8;\n      do {\n        *(long *)(pcVar13 + lVar10 * 3 + -8) = lVar6;\n        lVar6 = lVar6 + lVar10;\n        lVar10 = lVar10 + 8;\n      } while (uVar12 * 8 + 8 != lVar10);\n    }\n    DAT_001262e0 = uVar12;\n    if (uVar15 != 0) goto LAB_0010819c;\nLAB_00108338:\n    if (DAT_001273b0 == 0) {\n      return uVar15;\n    }\n  }\n  uVar12 = 0;\n  do {\n    lVar6 = FUN_00107ed0(*(undefined8 *)(DAT_001273a0 + uVar12 * 8));\n    uVar5 = DAT_001273b0;\n    uVar14 = DAT_001272b0;\n    if (uVar15 != 0) {\n      uVar8 = 0;\n      pcVar13 = DAT_00127208;\n      do {\n        uVar9 = uVar8 + 1;\n        if (*pcVar13 != '\\0') {\n          if (param_1 == '\\0') {\n            uVar11 = uVar12 % uVar9;\n          }\n          else {\n            uVar11 = uVar12 / (((uVar5 - 1) + uVar9) / uVar9);\n          }\n          puVar1 = (ulong *)(*(long *)(pcVar13 + 0x10) + uVar11 * 8);\n          uVar8 = lVar6 + (ulong)(uVar11 != uVar8) * 2;\n          uVar11 = *puVar1;\n          if (uVar11 < uVar8) {\n            *(ulong *)(pcVar13 + 8) = *(long *)(pcVar13 + 8) + (uVar8 - uVar11);\n            *puVar1 = uVar8;\n            *pcVar13 = *(ulong *)(pcVar13 + 8) < uVar14;\n          }\n        }\n        pcVar13 = pcVar13 + 0x18;\n        uVar8 = uVar9;\n      } while (uVar15 != uVar9);\n    }\n    uVar12 = uVar12 + 1;\n  } while (uVar12 < uVar5);\nLAB_001082ed:\n  if (1 < uVar15) {\n    pcVar13 = DAT_00127208 + uVar15 * 0x18 + -0x18;\n    do {\n      if (*pcVar13 != '\\0') {\n        return uVar15;\n      }\n      uVar15 = uVar15 - 1;\n      pcVar13 = pcVar13 + -0x18;\n    } while (uVar15 != 1);\n  }\n  return uVar15;\n}\n\n",
  "FUN_00104d0e": "\nvoid FUN_00104d0e(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "stat": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_stat_00125e60)();\n  return iVar1;\n}\n\n",
  "FUN_001103c0": "\nundefined8 FUN_001103c0(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x18);\n}\n\n",
  "FUN_00104d22": "\nvoid FUN_00104d22(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "gmtime_r": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntm * gmtime_r(time_t *__timer,tm *__tp)\n\n{\n  tm *ptVar1;\n  \n  ptVar1 = (tm *)(*(code *)PTR_gmtime_r_00125fc0)();\n  return ptVar1;\n}\n\n",
  "mbrtoc32": "\nvoid mbrtoc32(void)\n\n{\n  (*(code *)PTR_mbrtoc32_00125df0)();\n  return;\n}\n\n",
  "FUN_00112060": "\n__uid_t * FUN_00112060(char *param_1)\n\n{\n  char cVar1;\n  __uid_t *p_Var2;\n  int iVar3;\n  passwd *ppVar4;\n  size_t sVar5;\n  __uid_t *p_Var6;\n  long lVar7;\n  \n  if (DAT_001273f8 != (__uid_t *)0x0) {\n    cVar1 = *param_1;\n    p_Var6 = DAT_001273f8;\n    do {\n      if ((*(char *)(p_Var6 + 4) == cVar1) &&\n         (iVar3 = strcmp((char *)(p_Var6 + 4),param_1), iVar3 == 0)) {\n        return p_Var6;\n      }\n      p_Var6 = *(__uid_t **)(p_Var6 + 2);\n    } while (p_Var6 != (__uid_t *)0x0);\n  }\n  if (DAT_001273f0 != (__uid_t *)0x0) {\n    cVar1 = *param_1;\n    lVar7 = (long)DAT_001273f0;\n    do {\n      if ((*(char *)(lVar7 + 0x10) == cVar1) &&\n         (iVar3 = strcmp((char *)(lVar7 + 0x10),param_1), iVar3 == 0)) {\n        return (__uid_t *)0x0;\n      }\n      lVar7 = *(long *)(lVar7 + 8);\n    } while (lVar7 != 0);\n  }\n  ppVar4 = getpwnam(param_1);\n  sVar5 = strlen(param_1);\n  p_Var6 = (__uid_t *)FUN_00117e10(sVar5 + 0x18 & 0xfffffffffffffff8);\n  strcpy((char *)(p_Var6 + 4),param_1);\n  if (ppVar4 != (passwd *)0x0) {\n    *p_Var6 = ppVar4->pw_uid;\n    p_Var2 = p_Var6;\n    *(__uid_t **)(p_Var6 + 2) = DAT_001273f8;\n    DAT_001273f8 = p_Var2;\n    return p_Var6;\n  }\n  *(__uid_t **)(p_Var6 + 2) = DAT_001273f0;\n  DAT_001273f0 = p_Var6;\n  return (__uid_t *)0x0;\n}\n\n",
  "FUN_00118600": "\nvoid FUN_00118600(uint param_1,int param_2,undefined param_3,long param_4,undefined8 param_5)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  char *pcVar3;\n  long in_FS_OFFSET;\n  undefined local_12;\n  undefined local_11;\n  undefined8 local_10;\n  \n  local_10 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  if (param_1 < 4) {\n    if (param_1 < 2) {\n      if (param_1 != 1) {\n                    /* WARNING: Subroutine does not return */\n        abort();\n      }\n      pcVar3 = \"%s%s argument \\'%s\\' too large\";\n    }\n    else {\n      pcVar3 = \"invalid suffix in %s%s argument \\'%s\\'\";\n    }\n  }\n  else {\n    if (param_1 != 4) {\n                    /* WARNING: Subroutine does not return */\n      abort();\n    }\n    pcVar3 = \"invalid %s%s argument \\'%s\\'\";\n  }\n  if (param_2 < 0) {\n    puVar2 = &DAT_0011f0e7 + -(long)param_2;\n    local_11 = 0;\n    puVar1 = &local_12;\n    local_12 = param_3;\n  }\n  else {\n    puVar1 = *(undefined **)(param_4 + (long)param_2 * 0x20);\n    puVar2 = &DAT_0011f0e7;\n  }\n  error(DAT_001261f8,0,pcVar3,puVar2,puVar1,param_5);\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_0010c800": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_0010c800(long param_1)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  byte *pbVar3;\n  undefined4 uVar4;\n  byte bVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  long lVar9;\n  long lVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  undefined *puVar13;\n  char *pcVar14;\n  char *pcVar15;\n  undefined1 *puVar16;\n  char *pcVar17;\n  int iVar18;\n  long in_FS_OFFSET;\n  bool bVar19;\n  undefined8 local_1340;\n  ulong local_1338;\n  ulong local_1330;\n  undefined local_1328 [16];\n  int local_1318;\n  undefined local_12e8 [16];\n  int local_12d8;\n  char local_12a4;\n  undefined8 local_12a3;\n  ushort local_129b;\n  undefined local_1299;\n  undefined local_1298 [32];\n  undefined local_1278 [1008];\n  char local_e88 [3656];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (*(char *)(param_1 + 0xb8) == '\\0') {\n    local_1299 = 0;\n    local_129b = 0x3f3f;\n    local_12a4 = \"?pcdb-lswd\"[*(uint *)(param_1 + 0xa8)];\n    local_12a3 = 0x3f3f3f3f3f3f3f3f;\n  }\n  else {\n    FUN_0010f6a0(param_1 + 0x18,&local_12a4);\n  }\n  if (DAT_00127364 == '\\0') {\n    local_129b = local_129b & 0xff;\nLAB_0010c869:\n    if (DAT_00127334 == 2) goto LAB_0010caa0;\nLAB_0010c878:\n    if (DAT_00127334 < 3) {\n      if (DAT_00127334 == 0) {\n        local_1330 = *(ulong *)(param_1 + 0x78);\n        local_1338 = *(ulong *)(param_1 + 0x70);\n        bVar19 = true;\n      }\n      else {\n        local_1330 = *(ulong *)(param_1 + 0x88);\n        local_1338 = *(ulong *)(param_1 + 0x80);\n        bVar19 = true;\n      }\n    }\n    else {\n      local_1338 = *(ulong *)(param_1 + 0x70);\n      local_1330 = *(ulong *)(param_1 + 0x78);\n      bVar19 = (local_1338 & local_1330) != 0xffffffffffffffff;\n    }\n  }\n  else {\n    if (*(int *)(param_1 + 0xbc) == 1) {\n      local_129b = CONCAT11(0x2e,(undefined)local_129b);\n      goto LAB_0010c869;\n    }\n    if (*(int *)(param_1 + 0xbc) != 2) goto LAB_0010c869;\n    local_129b = CONCAT11(0x2b,(undefined)local_129b);\n    if (DAT_00127334 != 2) goto LAB_0010c878;\nLAB_0010caa0:\n    local_1330 = *(ulong *)(param_1 + 0x68);\n    local_1338 = *(ulong *)(param_1 + 0x60);\n    bVar19 = true;\n  }\n  if (DAT_001272fc == '\\0') {\n    pcVar14 = local_e88;\n  }\n  else {\n    puVar16 = &DAT_0011bdd6;\n    if ((*(char *)(param_1 + 0xb8) != '\\0') && (*(long *)(param_1 + 0x20) != 0)) {\n      puVar16 = (undefined1 *)FUN_001123c0(*(long *)(param_1 + 0x20),local_1278);\n    }\n    iVar6 = __sprintf_chk(local_e88,1,0xe3b,&DAT_0011bde8,DAT_00127360,puVar16);\n    pcVar14 = local_e88 + iVar6;\n  }\n  if (DAT_0012732c != '\\0') {\n    pcVar17 = \"?\";\n    if (*(char *)(param_1 + 0xb8) != '\\0') {\n      pcVar17 = (char *)FUN_001111e0(*(undefined8 *)(param_1 + 0x58),local_1278,DAT_00127328,0x200,\n                                     DAT_00127320);\n    }\n    iVar6 = DAT_0012735c;\n    iVar7 = FUN_00112b20(pcVar17,0);\n    iVar6 = iVar6 - iVar7;\n    if (0 < iVar6) {\n      memset(pcVar14,0x20,(long)iVar6);\n      pcVar14 = pcVar14 + iVar6;\n    }\n    do {\n      pcVar15 = pcVar14;\n      cVar1 = *pcVar17;\n      pcVar17 = pcVar17 + 1;\n      pcVar14 = pcVar15 + 1;\n      *pcVar15 = cVar1;\n    } while (cVar1 != '\\0');\n    *pcVar15 = ' ';\n  }\n  puVar16 = &DAT_0011bdd6;\n  if (*(char *)(param_1 + 0xb8) != '\\0') {\n    puVar16 = (undefined1 *)FUN_001123c0(*(undefined8 *)(param_1 + 0x28),local_1278);\n  }\n  iVar6 = __sprintf_chk(pcVar14,1,0xffffffffffffffff,\"%s %*s \",&local_12a4,DAT_00127358,puVar16);\n  pcVar14 = pcVar14 + iVar6;\n  if (DAT_00127318 != '\\0') {\n    FUN_001074f0(&DAT_0011bde0,2);\n  }\n  if ((((DAT_00126029 != '\\0') || (DAT_00126028 != '\\0')) || (DAT_0012732e != '\\0')) ||\n     (DAT_00127365 != '\\0')) {\n    FUN_001074f0(local_e88,(long)pcVar14 - (long)local_e88);\n    uVar4 = DAT_00127350;\n    if (DAT_00126029 != '\\0') {\n      puVar16 = &DAT_0011bdd6;\n      uVar2 = *(undefined4 *)(param_1 + 0x34);\n      if ((*(char *)(param_1 + 0xb8) != '\\0') && (puVar16 = (undefined1 *)0x0, DAT_0012732d == '\\0')\n         ) {\n        puVar16 = (undefined1 *)FUN_00111fc0(uVar2);\n      }\n      FUN_001091f0(puVar16,uVar2,uVar4);\n    }\n    uVar4 = DAT_0012734c;\n    if (DAT_00126028 != '\\0') {\n      puVar16 = &DAT_0011bdd6;\n      uVar2 = *(undefined4 *)(param_1 + 0x38);\n      if ((*(char *)(param_1 + 0xb8) != '\\0') && (puVar16 = (undefined1 *)0x0, DAT_0012732d == '\\0')\n         ) {\n        puVar16 = (undefined1 *)FUN_00112170(uVar2);\n      }\n      FUN_001091f0(puVar16,uVar2,uVar4);\n    }\n    uVar4 = DAT_00127348;\n    if (DAT_0012732e != '\\0') {\n      puVar16 = &DAT_0011bdd6;\n      uVar2 = *(undefined4 *)(param_1 + 0x34);\n      if ((*(char *)(param_1 + 0xb8) != '\\0') && (puVar16 = (undefined1 *)0x0, DAT_0012732d == '\\0')\n         ) {\n        puVar16 = (undefined1 *)FUN_00111fc0(uVar2);\n      }\n      FUN_001091f0(puVar16,uVar2,uVar4);\n    }\n    pcVar14 = local_e88;\n    if (DAT_00127365 != '\\0') {\n      FUN_001091f0(*(undefined8 *)(param_1 + 0xb0),0,DAT_00127354);\n    }\n  }\n  if (*(char *)(param_1 + 0xb8) == '\\0') {\n    pcVar17 = \"?\";\nLAB_0010cb17:\n    iVar6 = DAT_0012733c;\n    iVar7 = FUN_00112b20(pcVar17,0);\n    iVar6 = iVar6 - iVar7;\n    if (0 < iVar6) {\n      memset(pcVar14,0x20,(long)iVar6);\n      pcVar14 = pcVar14 + iVar6;\n    }\n    do {\n      pcVar15 = pcVar14;\n      cVar1 = *pcVar17;\n      pcVar17 = pcVar17 + 1;\n      pcVar14 = pcVar15 + 1;\n      *pcVar15 = cVar1;\n    } while (cVar1 != '\\0');\n    *pcVar15 = ' ';\n  }\n  else {\n    if ((*(uint *)(param_1 + 0x30) & 0xb000) != 0x2000) {\n      pcVar17 = (char *)FUN_001111e0(*(undefined8 *)(param_1 + 0x48),local_1278,DAT_0012731c,1,\n                                     DAT_00126020);\n      goto LAB_0010cb17;\n    }\n    iVar18 = DAT_0012733c - (DAT_00127344 + 2 + DAT_00127340);\n    uVar11 = FUN_001123c0((uint)((*(ulong *)(param_1 + 0x40) >> 0x14) << 8) |\n                          (uint)*(ulong *)(param_1 + 0x40) & 0xff,local_1278);\n    iVar6 = DAT_00127340;\n    uVar12 = FUN_001123c0((uint)((ulong)*(undefined8 *)(param_1 + 0x40) >> 0x20) & 0xfffff000 |\n                          (uint)((ulong)*(undefined8 *)(param_1 + 0x40) >> 8) & 0xfff,local_1298);\n    iVar7 = 0;\n    if (-1 < iVar18) {\n      iVar7 = iVar18;\n    }\n    iVar6 = __sprintf_chk(pcVar14,1,0xffffffffffffffff,&DAT_0011bde3,iVar7 + DAT_00127344,uVar12,\n                          iVar6,uVar11);\n    pcVar14 = pcVar14 + iVar6;\n  }\n  *pcVar14 = '\\x01';\n  if ((*(char *)(param_1 + 0xb8) == '\\0') || (!bVar19)) {\nLAB_0010cb79:\n    puVar16 = &DAT_0011bdd6;\nLAB_0010cb80:\n    if (DAT_00126014 < 0) {\n      local_1340 = 0;\n      lVar9 = FUN_00117700(DAT_001272a8,&local_1340,local_12e8);\n      if (lVar9 != 0) {\n        puVar13 = PTR_DAT_00126040;\n        if (DAT_001263c8 != '\\0') {\n          puVar13 = &DAT_001263e0 + (long)local_12d8 * 0x80;\n        }\n        lVar9 = FUN_001149e0(local_1278,0x3e9,puVar13,local_12e8,DAT_001272a8,0);\n        if (lVar9 != 0) {\n          DAT_00126014 = FUN_00112940(local_1278,lVar9,0);\n        }\n      }\n      if (DAT_00126014 < 0) {\n        DAT_00126014 = 0;\n      }\n    }\n    iVar6 = __sprintf_chk(pcVar14,1,0xffffffffffffffff,&DAT_0011bde8,DAT_00126014,puVar16);\n    pcVar14 = pcVar14 + iVar6;\n  }\n  else {\n    lVar9 = FUN_00117700(DAT_001272a8,&local_1338,local_1328);\n    if (lVar9 == 0) {\nLAB_0010d190:\n      if (*pcVar14 != '\\0') {\n        if (*(char *)(param_1 + 0xb8) == '\\0') goto LAB_0010cb79;\n        puVar16 = (undefined1 *)FUN_00112320(local_1338,local_1298);\n        goto LAB_0010cb80;\n      }\n    }\n    else {\n      bVar19 = (long)local_1330 < _DAT_00127378;\n      uVar8 = (uint)(_DAT_00127378 < (long)local_1330);\n      iVar6 = (uint)bVar19 - (uint)(_DAT_00127378 < (long)local_1330);\n      if ((int)(iVar6 + ((uint)((long)local_1338 < DAT_00127370) -\n                        (uint)(DAT_00127370 < (long)local_1338)) * 2) < 0) {\n        FUN_0010fd00(&DAT_00127370);\n        bVar19 = (long)local_1330 < _DAT_00127378;\n        uVar8 = (uint)(_DAT_00127378 < (long)local_1330);\n        iVar6 = bVar19 - uVar8;\n      }\n      uVar8 = (uVar8 - bVar19) +\n              ((uint)(DAT_00127370 < (long)local_1338) - (uint)((long)local_1338 < DAT_00127370)) *\n              2 & iVar6 + ((uint)((long)local_1338 < DAT_00127370 + -0xf0c2ac) -\n                          (uint)(DAT_00127370 + -0xf0c2ac < (long)local_1338)) * 2;\n      if (DAT_001263c8 == '\\0') {\n        puVar13 = (&PTR_DAT_00126040)[uVar8 >> 0x1f];\n      }\n      else {\n        puVar13 = &DAT_001263e0 + ((long)local_1318 + (ulong)((int)uVar8 >> 0x1f & 0xc)) * 0x80;\n      }\n      lVar9 = FUN_001149e0(pcVar14,0x3e9,puVar13,local_1328,DAT_001272a8);\n      if (lVar9 == 0) goto LAB_0010d190;\n      pcVar14 = pcVar14 + lVar9;\n    }\n    *pcVar14 = ' ';\n    pcVar14 = pcVar14 + 1;\n  }\n  lVar9 = (long)pcVar14 - (long)local_e88;\n  FUN_001074f0(local_e88,lVar9);\n  lVar10 = FUN_0010bf80(param_1,0,&DAT_001271a0,lVar9);\n  if (*(int *)(param_1 + 0xa8) == 6) {\n    if (*(long *)(param_1 + 8) == 0) goto LAB_0010cbfa;\n    FUN_001074f0(&DAT_0011bded,4);\n    FUN_0010bf80(param_1,1,0,lVar9 + 4 + lVar10);\n    if (DAT_00127314 == 0) goto LAB_0010cbfa;\n    bVar5 = FUN_00107670(1,*(undefined4 *)(param_1 + 0xac),0);\n  }\n  else {\n    if (DAT_00127314 == 0) goto LAB_0010cbfa;\n    bVar5 = FUN_00107670(*(undefined *)(param_1 + 0xb8),*(undefined4 *)(param_1 + 0x30));\n  }\n  if (bVar5 != 0) {\n    DAT_001271f8 = DAT_001271f8 + 1;\n    pbVar3 = (byte *)stdout->_IO_write_ptr;\n    if (pbVar3 < stdout->_IO_write_end) {\n      stdout->_IO_write_ptr = (char *)(pbVar3 + 1);\n      *pbVar3 = bVar5;\n    }\n    else {\n      __overflow(stdout,(uint)bVar5);\n    }\n  }\nLAB_0010cbfa:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}\n\n",
  "FUN_0010fea0": "\nundefined8 FUN_0010fea0(undefined8 param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  int local_118;\n  short local_114;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = FUN_001172a0(param_1,&local_118,0x101);\n  uVar2 = 0;\n  if (((iVar1 == 0) && ((short)local_118 != 0x43)) &&\n     ((local_118 != 0x49534f50 || (uVar2 = 0, local_114 != 0x58)))) {\n    uVar2 = 1;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}\n\n",
  "FUN_00104d27": "\nvoid FUN_00104d27(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "strftime": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strftime(char *__s,size_t __maxsize,char *__format,tm *__tp)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n",
  "FUN_0010a980": "\nulong FUN_0010a980(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010aa00;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010aa00:\n  uVar3 = FUN_00108c00();\n  return uVar3;\n}\n\n",
  "_setjmp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint _setjmp(__jmp_buf_tag *__env)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR__setjmp_00125e10)();\n  return iVar1;\n}\n\n",
  "iswprint": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswprint(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswprint_00125f78)();\n  return iVar1;\n}\n\n",
  "FUN_00108800": "\nvoid FUN_00108800(char **param_1,char **param_2)\n\n{\n  char *__s2;\n  char *__s1;\n  int *piVar1;\n  \n  __s2 = *param_1;\n  __s1 = *param_2;\n  piVar1 = __errno_location();\n  *piVar1 = 0;\n  strcoll(__s1,__s2);\n  return;\n}\n\n",
  "FUN_00116e20": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00116e20(undefined8 param_1,long param_2,long param_3,undefined8 param_4)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long lStack_20;\n  long local_18;\n  long local_10;\n  \n  uStack_40 = uRam0000000000127528;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = _DAT_00127530;\n  uStack_30 = uRam0000000000127538;\n  local_28 = _DAT_00127540;\n  lStack_20 = uRam0000000000127548;\n  local_18 = DAT_00127550;\n  local_48 = CONCAT44((int)((ulong)_DAT_00127520 >> 0x20),10);\n  if ((param_2 != 0) && (param_3 != 0)) {\n    lStack_20 = param_2;\n    local_18 = param_3;\n    FUN_00116340(param_1,param_4,0xffffffffffffffff,&local_48);\n    if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return;\n    }\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00117f10": "\nvoid FUN_00117f10(undefined8 param_1,long param_2,long param_3)\n\n{\n  long lVar1;\n  \n  if ((param_2 == 0) || (param_3 == 0)) {\n    param_2 = 1;\n    param_3 = 1;\n  }\n  lVar1 = reallocarray(param_1,param_2,param_3);\n  if (lVar1 != 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_00114a00": "\nvoid FUN_00114a00(void)\n\n{\n  __fprintf_chk(stderr,1,\"%s\\n\",\"memory exhausted\");\n                    /* WARNING: Subroutine does not return */\n  exit(DAT_001261f8);\n}\n\n",
  "localtime_r": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ntm * localtime_r(time_t *__timer,tm *__tp)\n\n{\n  tm *ptVar1;\n  \n  ptVar1 = (tm *)(*(code *)PTR_localtime_r_00125fb8)();\n  return ptVar1;\n}\n\n",
  "FUN_00104d1d": "\nvoid FUN_00104d1d(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_001070e0": "\nvoid FUN_001070e0(char **param_1,char **param_2)\n\n{\n  strcmp(*param_1,*param_2);\n  return;\n}\n\n",
  "tzset": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid tzset(void)\n\n{\n  (*(code *)PTR_tzset_00125e78)();\n  return;\n}\n\n",
  "FUN_00104d31": "\nvoid FUN_00104d31(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "localeconv": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nlconv * localeconv(void)\n\n{\n  lconv *plVar1;\n  \n  plVar1 = (lconv *)(*(code *)PTR_localeconv_00125d20)();\n  return plVar1;\n}\n\n",
  "__fprintf_chk": "\nvoid __fprintf_chk(void)\n\n{\n  (*(code *)PTR___fprintf_chk_00125f50)();\n  return;\n}\n\n",
  "nl_langinfo": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * nl_langinfo(nl_item __item)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_nl_langinfo_00125ea8)();\n  return pcVar1;\n}\n\n",
  "_obstack_begin": "\nvoid _obstack_begin(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                   undefined8 param_5)\n\n{\n  *(byte *)(param_1 + 0x50) = *(byte *)(param_1 + 0x50) & 0xfe;\n  *(undefined8 *)(param_1 + 0x38) = param_4;\n  *(undefined8 *)(param_1 + 0x40) = param_5;\n  FUN_00114a40();\n  return;\n}\n\n",
  "FUN_001180f0": "\nvoid FUN_001180f0(void *param_1,long *param_2,long param_3,long param_4,long param_5)\n\n{\n  long lVar1;\n  void *pvVar2;\n  long lVar3;\n  size_t __size;\n  long lVar4;\n  \n  lVar1 = *param_2;\n  lVar3 = (lVar1 >> 1) + lVar1;\n  if (SCARRY8(lVar1 >> 1,lVar1)) {\n    lVar3 = 0x7fffffffffffffff;\n  }\n  lVar4 = param_4;\n  if (lVar3 <= param_4) {\n    lVar4 = lVar3;\n  }\n  if (-1 < param_4) {\n    lVar3 = lVar4;\n  }\n  __size = lVar3 * param_5;\n  if (SEXT816((long)__size) == SEXT816(lVar3) * SEXT816(param_5)) {\n    if (0x7f < (long)__size) goto joined_r0x001181ae;\n    lVar4 = 0x80;\n  }\n  else {\n    lVar4 = 0x7fffffffffffffff;\n  }\n  lVar3 = lVar4 / param_5;\n  __size = lVar4 - lVar4 % param_5;\njoined_r0x001181ae:\n  if (param_1 == (void *)0x0) {\n    *param_2 = 0;\n  }\n  if (((param_3 <= lVar3 - lVar1) ||\n      ((lVar3 = lVar1 + param_3, !SCARRY8(lVar1,param_3) &&\n       (((lVar3 <= param_4 || (param_4 < 0)) &&\n        (__size = lVar3 * param_5, SEXT816((long)__size) == SEXT816(lVar3) * SEXT816(param_5)))))))\n     && ((pvVar2 = realloc(param_1,__size), pvVar2 != (void *)0x0 ||\n         ((param_1 != (void *)0x0 && (__size == 0)))))) {\n    *param_2 = lVar3;\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_00107600": "\nvoid FUN_00107600(char param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 uVar1;\n  int *piVar2;\n  \n  uVar1 = FUN_00116a00(4,param_3);\n  piVar2 = __errno_location();\n  error(0,*piVar2,param_2,uVar1);\n  if (param_1 == '\\0') {\n    if (DAT_00127210 == 0) {\n      DAT_00127210 = 1;\n      return;\n    }\n  }\n  else {\n    DAT_00127210 = 2;\n  }\n  return;\n}\n\n",
  "FUN_00108930": "\nvoid FUN_00108930(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  pcVar2 = param_2[0x19];\n  if (pcVar2 == (char *)0x0) {\n    pcVar2 = (char *)FUN_00107e30(*param_2,DAT_001272d0,*(undefined4 *)((long)param_2 + 0xc4));\n  }\n  pcVar1 = param_1[0x19];\n  if (pcVar1 == (char *)0x0) {\n    pcVar1 = (char *)FUN_00107e30(*param_1,DAT_001272d0,*(undefined4 *)((long)param_1 + 0xc4));\n  }\n  if ((int)pcVar2 == (int)pcVar1) {\n    strcmp(*param_2,*param_1);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_001103d0": "\nundefined8 FUN_001103d0(long param_1)\n\n{\n  return *(undefined8 *)(param_1 + 0x20);\n}\n\n",
  "FUN_001149e0": "\nvoid FUN_001149e0(void)\n\n{\n  FUN_00112e70();\n  return;\n}\n\n",
  "FUN_001070f0": "\nvoid FUN_001070f0(char **param_1,char **param_2)\n\n{\n  strcmp(*param_2,*param_1);\n  return;\n}\n\n",
  "FUN_0010e3d0": "\nchar * FUN_0010e3d0(char *param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  char *pcVar2;\n  int *piVar3;\n  char *__ptr;\n  ulong __len;\n  long in_FS_OFFSET;\n  char local_c8 [136];\n  long local_40;\n  \n  __len = 0x80;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((param_2 != 0) && (__len = param_2 + 1, 0x400 < param_2)) {\n    __len = 0x401;\n  }\n  while (((__len == 0x80 && (pcVar2 = local_c8, __ptr = (char *)0x0, param_2 == 0)) ||\n         (pcVar2 = (char *)malloc(__len), __ptr = pcVar2, pcVar2 != (char *)0x0))) {\n    uVar1 = readlink(param_1,pcVar2,__len);\n    if ((long)uVar1 < 0) {\n      free(__ptr);\n      __ptr = (char *)0x0;\n      goto LAB_0010e4cb;\n    }\n    if (uVar1 < __len) {\n      pcVar2[uVar1] = '\\0';\n      uVar1 = uVar1 + 1;\n      if (__ptr == (char *)0x0) {\n        __ptr = (char *)malloc(uVar1);\n        if (__ptr != (char *)0x0) {\n          memcpy(__ptr,pcVar2,uVar1);\n        }\n      }\n      else if ((uVar1 < __len) && (pcVar2 = (char *)realloc(__ptr,uVar1), pcVar2 != (char *)0x0)) {\n        __ptr = pcVar2;\n      }\n      goto LAB_0010e4cb;\n    }\n    free(__ptr);\n    if (__len < 0x4000000000000000) {\n      __len = __len * 2;\n    }\n    else {\n      if (__len == 0x7fffffffffffffff) break;\n      __len = 0x7fffffffffffffff;\n    }\n  }\n  piVar3 = __errno_location();\n  *piVar3 = 0xc;\n  __ptr = (char *)0x0;\nLAB_0010e4cb:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return __ptr;\n}\n\n",
  "FUN_0010f4c0": "\nbool FUN_0010f4c0(long param_1,undefined8 param_2,undefined8 *param_3)\n\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  bool bVar2;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  bVar2 = false;\n  if (param_1 != 0) {\n    local_20 = param_3[1];\n    local_18 = *param_3;\n    local_28 = param_2;\n    lVar1 = FUN_00110610(param_1,&local_28);\n    bVar2 = lVar1 != 0;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00104d2c": "\nvoid FUN_00104d2c(void)\n\n{\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00106e00": "\nvoid FUN_00106e00(void)\n\n{\n  char *pcVar1;\n  bool bVar2;\n  char cVar3;\n  uint uVar4;\n  char *pcVar5;\n  byte *__s;\n  ushort **ppuVar6;\n  ulong uVar7;\n  char cVar8;\n  undefined *puVar9;\n  undefined *puVar10;\n  ulong uVar11;\n  long lVar12;\n  int __item;\n  ulong uVar13;\n  long in_FS_OFFSET;\n  long local_678;\n  ulong local_660;\n  char *local_658;\n  long local_650;\n  undefined local_648 [1536];\n  undefined local_48 [8];\n  long local_40;\n  \n  lVar12 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  do {\n    pcVar5 = *(char **)((long)&PTR_DAT_00126040 + lVar12);\n    cVar3 = *pcVar5;\n    while (cVar3 != '\\0') {\n      cVar8 = pcVar5[1];\n      if (cVar3 == '%') {\n        if (cVar8 == '%') {\n          cVar8 = pcVar5[2];\n          pcVar5 = pcVar5 + 1;\n        }\n        else if (cVar8 == 'b') goto LAB_00106e6e;\n      }\n      pcVar5 = pcVar5 + 1;\n      cVar3 = cVar8;\n    }\n    pcVar5 = (char *)0x0;\nLAB_00106e6e:\n    *(char **)((long)&local_658 + lVar12) = pcVar5;\n    lVar12 = lVar12 + 8;\n  } while (lVar12 != 0x10);\n  if ((local_658 != (char *)0x0) || (local_650 != 0)) {\n    uVar13 = 0xc;\n    do {\n      __item = 0x2000e;\n      uVar11 = 0;\n      puVar9 = local_648;\n      do {\n        local_660 = uVar13;\n        __s = (byte *)nl_langinfo(__item);\n        pcVar5 = strchr((char *)__s,0x25);\n        if (pcVar5 != (char *)0x0) goto LAB_00106f54;\n        ppuVar6 = __ctype_b_loc();\n        uVar7 = FUN_001124b0(__s,puVar9,0x80,&local_660,(*ppuVar6)[*__s] >> 0xb & 1,0);\n        if (0x7f < uVar7) goto LAB_00106f54;\n        if (uVar11 < local_660) {\n          uVar11 = local_660;\n        }\n        __item = __item + 1;\n        puVar9 = puVar9 + 0x80;\n      } while (puVar9 != local_48);\n      bVar2 = uVar11 < uVar13;\n      uVar13 = uVar11;\n    } while (bVar2);\n    local_678 = 0;\n    while( true ) {\n      puVar9 = (&PTR_DAT_00126040)[local_678];\n      pcVar1 = (&local_658)[local_678];\n      pcVar5 = &DAT_001263e0 + local_678 * 0x600;\n      puVar10 = local_648;\n      do {\n        if (pcVar1 == (char *)0x0) {\n          uVar4 = snprintf(pcVar5,0x80,\"%s\",puVar9);\n        }\n        else {\n          if (0x80 < (long)pcVar1 - (long)puVar9) goto LAB_00106f54;\n          uVar4 = __snprintf_chk(pcVar5,0x80,1,0xffffffffffffffff,\"%.*s%s%s\",\n                                 (long)pcVar1 - (long)puVar9,puVar9,puVar10,pcVar1 + 2);\n        }\n        if (0x7f < uVar4) goto LAB_00106f54;\n        puVar10 = puVar10 + 0x80;\n        pcVar5 = pcVar5 + 0x80;\n      } while (puVar10 != local_48);\n      if (local_678 == 1) break;\n      local_678 = 1;\n    }\n    DAT_001263c8 = 1;\n  }\nLAB_00106f54:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "__ctype_tolower_loc": "\n/* WARNING: Control flow encountered bad instruction data */\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__int32_t ** __ctype_tolower_loc(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n",
  "FUN_00104d40": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined4 FUN_00104d40(uint param_1,undefined8 *param_2)\n\n{\n  size_t *psVar1;\n  void *__s1;\n  byte bVar2;\n  undefined *puVar3;\n  undefined *puVar4;\n  char cVar5;\n  byte bVar6;\n  int iVar7;\n  int iVar8;\n  uint uVar9;\n  void *pvVar10;\n  undefined8 uVar11;\n  char **ppcVar12;\n  undefined8 uVar13;\n  long lVar14;\n  ulong uVar15;\n  size_t sVar16;\n  size_t *psVar17;\n  undefined **ppuVar18;\n  undefined8 extraout_RDX;\n  char *pcVar19;\n  long lVar20;\n  void **__ptr;\n  char *pcVar21;\n  undefined8 *puVar22;\n  undefined8 *puVar23;\n  char *in_R9;\n  undefined8 *in_R10;\n  size_t *psVar24;\n  long in_FS_OFFSET;\n  bool bVar25;\n  uint local_94;\n  int local_90;\n  int local_8c;\n  ulong local_88;\n  char *local_80;\n  undefined *local_78;\n  int local_70;\n  char *local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined2 local_43;\n  undefined local_41;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  FUN_00114d50(*param_2);\n  setlocale(6,\"\");\n  DAT_001261f8 = 2;\n  FUN_00119780(FUN_0010f390);\n  DAT_001272b8 = 1;\n  DAT_00127210 = 0;\n  DAT_00127380 = (void **)0x0;\n  DAT_00127370 = 0x8000000000000000;\n  _DAT_00127378 = 0xffffffffffffffff;\n  local_88 = 0xffffffffffffffff;\n  local_78 = (undefined *)0xffffffffffffffff;\n  local_8c = -1;\n  local_90 = -1;\n  local_70 = -1;\n  local_94 = 0xffffffff;\n  bVar25 = false;\n  local_80 = (char *)0x0;\nLAB_00104e30:\n  do {\n    ppuVar18 = &PTR_s_all_00125300;\n    local_58 = (undefined *)CONCAT44(local_58._4_4_,0xffffffff);\n    puVar22 = param_2;\n    pcVar19 = (char *)(ulong)param_1;\n    puVar23 = &local_58;\n    iVar7 = getopt_long((char *)(ulong)param_1,param_2,\"abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1\"\n                       );\n    if (iVar7 == -1) {\n      if (DAT_00127320 == 0) {\n        pcVar19 = getenv(\"LS_BLOCK_SIZE\");\n        FUN_00111dd0(pcVar19,&DAT_00127328,&DAT_00127320);\n        if ((pcVar19 != (char *)0x0) || (pcVar19 = getenv(\"BLOCK_SIZE\"), pcVar19 != (char *)0x0)) {\n          DAT_0012731c = DAT_00127328;\n          DAT_00126020 = DAT_00127320;\n        }\n        if (bVar25) {\n          DAT_00127328 = 0;\n          DAT_00127320 = 0x400;\n        }\n      }\n      if ((int)local_94 < 0) {\n        if (DAT_001261e0 == 1) goto LAB_001063b0;\n        if (DAT_001261e0 == 2) goto LAB_001062f2;\n        DAT_00127338 = 0;\n        goto LAB_001052c1;\n      }\n      DAT_00127338 = local_94;\n      if (2 < local_94 - 2) goto LAB_001052c1;\n      goto LAB_00104ec8;\n    }\n    switch(iVar7) {\n    case 0x31:\n      local_94 = (uint)(local_94 != 0);\n      break;\n    case 0x41:\n      DAT_001272f0 = 1;\n      break;\n    case 0x42:\n      FUN_00106cc0(&DAT_0011bf0d);\n      FUN_00106cc0(&DAT_0011bf0c);\n      break;\n    case 0x43:\n      local_94 = 2;\n      break;\n    case 0x44:\n      DAT_00127318 = 1;\n      break;\n    case 0x46:\n      if (optarg != (char *)0x0) {\n        in_R9 = (char *)0x1;\n        in_R10 = puVar23;\n        lVar20 = FUN_0010e860(\"--classify\",optarg,&PTR_s_always_001251c0,&DAT_0011a6e0,4,\n                              PTR_FUN_001261f0,1,puVar23);\n        if ((*(int *)(&DAT_0011a6e0 + lVar20 * 4) != 1) &&\n           ((*(int *)(&DAT_0011a6e0 + lVar20 * 4) != 2 || (cVar5 = FUN_00106dd0(), cVar5 == '\\0'))))\n        break;\n      }\n      DAT_00127314 = 3;\n      break;\n    case 0x47:\n      DAT_00126028 = 0;\n      break;\n    case 0x48:\n      DAT_001272f8 = 2;\n      break;\n    case 0x49:\n      FUN_00106cc0(optarg);\n      break;\n    case 0x4c:\n      DAT_001272f8 = 4;\n      break;\n    case 0x4e:\n      local_90 = 0;\n      break;\n    case 0x51:\n      local_90 = 5;\n      break;\n    case 0x52:\n      DAT_001272f6 = '\\x01';\n      break;\n    case 0x53:\n      local_8c = 3;\n      break;\n    case 0x54:\n      in_R9 = \"invalid tab size\";\n      local_78 = (undefined *)\n                 FUN_001183c0(optarg,0,0,0x7fffffffffffffff,&DAT_0011bdd5,\"invalid tab size\",2,\n                              ppuVar18);\n      break;\n    case 0x55:\n      local_8c = 6;\n      break;\n    case 0x58:\n      local_8c = 1;\n      break;\n    case 0x5a:\n      DAT_00127365 = '\\x01';\n      break;\n    case 0x61:\n      DAT_001272f0 = 2;\n      break;\n    case 0x62:\n      local_90 = 7;\n      break;\n    case 99:\n      DAT_00127334 = 1;\n      break;\n    case 100:\n      DAT_001272f5 = '\\x01';\n      break;\n    case 0x66:\n      DAT_001272f0 = 2;\n      if (local_94 == 0) {\n        local_94 = 0xffffffff;\n      }\n      DAT_00127312 = 0;\n      DAT_00127311 = 0;\n      DAT_0012732c = '\\0';\n      local_8c = 6;\n      break;\n    case 0x67:\n      DAT_00126029 = 0;\n      local_94 = 0;\n      break;\n    case 0x68:\n      DAT_00127328 = 0xb0;\n      DAT_0012731c = 0xb0;\n      DAT_00127320 = 1;\n      DAT_00126020 = 1;\n      break;\n    case 0x69:\n      DAT_001272fc = 1;\n      break;\n    case 0x6b:\n      bVar25 = true;\n      break;\n    case 0x6c:\n      local_94 = 0;\n      break;\n    case 0x6d:\n      local_94 = 4;\n      break;\n    case 0x6e:\n      DAT_0012732d = 1;\n      local_94 = 0;\n      break;\n    case 0x6f:\n      DAT_00126028 = 0;\n      local_94 = 0;\n      break;\n    case 0x70:\n      DAT_00127314 = 1;\n      break;\n    case 0x71:\n      local_70 = 1;\n      break;\n    case 0x72:\n      DAT_0012732f = 1;\n      break;\n    case 0x73:\n      DAT_0012732c = '\\x01';\n      break;\n    case 0x74:\n      local_8c = 5;\n      break;\n    case 0x75:\n      DAT_00127334 = 2;\n      break;\n    case 0x76:\n      local_8c = 4;\n      break;\n    case 0x77:\n      local_88 = FUN_00106cf0(optarg);\n      if (-1 < (long)local_88) break;\n      uVar11 = FUN_00117100(optarg);\n      error(2,0,\"%s: %s\",\"invalid line width\",uVar11);\n    case 0x80:\n      DAT_0012732e = 1;\n      break;\n    case 0x78:\n      local_94 = 3;\n      break;\n    case 0x81:\n      iVar7 = FUN_00111dd0(optarg,&DAT_00127328,&DAT_00127320);\n      if (iVar7 != 0) {\n        FUN_00118600(iVar7,(ulong)local_58 & 0xffffffff,0,&PTR_s_all_00125300,optarg);\n        goto LAB_00106800;\n      }\n      DAT_0012731c = DAT_00127328;\n      DAT_00126020 = DAT_00127320;\n      break;\n    case 0x82:\n      if (optarg == (char *)0x0) {\nLAB_00105ba1:\n        bVar6 = 1;\n      }\n      else {\n        in_R9 = PTR_FUN_001261f0;\n        lVar20 = FUN_0010e860(\"--color\",optarg,&PTR_s_always_001251c0,&DAT_0011a6e0,4,\n                              PTR_FUN_001261f0,1);\n        if (*(int *)(&DAT_0011a6e0 + lVar20 * 4) == 1) goto LAB_00105ba1;\n        bVar6 = 0;\n        if (*(int *)(&DAT_0011a6e0 + lVar20 * 4) == 2) {\n          bVar6 = FUN_00106dd0();\n        }\n      }\n      DAT_00127312 = bVar6 & 1;\n      break;\n    case 0x83:\n      DAT_001272f8 = 3;\n      break;\n    case 0x84:\n      DAT_00127314 = 2;\n      break;\n    case 0x85:\n      in_R9 = PTR_FUN_001261f0;\n      lVar20 = FUN_0010e860(\"--format\",optarg,&PTR_s_verbose_001252c0,&DAT_0011a770,4,\n                            PTR_FUN_001261f0,1,puVar22);\n      local_94 = *(uint *)(&DAT_0011a770 + lVar20 * 4);\n      break;\n    case 0x86:\n      local_94 = 0;\n      local_80 = \"full-iso\";\n      break;\n    case 0x87:\n      DAT_001272f4 = 1;\n      break;\n    case 0x88:\n      ppcVar12 = (char **)FUN_00117e10(0x10);\n      *ppcVar12 = optarg;\n      ppcVar12[1] = (char *)DAT_001272e0;\n      DAT_001272e0 = ppcVar12;\n      break;\n    case 0x89:\n      if (optarg == (char *)0x0) {\nLAB_00105b8a:\n        bVar6 = 1;\n      }\n      else {\n        in_R9 = PTR_FUN_001261f0;\n        lVar20 = FUN_0010e860(\"--hyperlink\",optarg,&PTR_s_always_001251c0,&DAT_0011a6e0,4,\n                              PTR_FUN_001261f0,1,in_R10);\n        if (*(int *)(&DAT_0011a6e0 + lVar20 * 4) == 1) goto LAB_00105b8a;\n        bVar6 = 0;\n        if (*(int *)(&DAT_0011a6e0 + lVar20 * 4) == 2) {\n          bVar6 = FUN_00106dd0();\n        }\n      }\n      DAT_00127311 = bVar6 & 1;\n      break;\n    case 0x8a:\n      in_R9 = pcVar19;\n      lVar20 = FUN_0010e860(\"--indicator-style\",optarg,&PTR_DAT_00125980,&DAT_0011a790,4,\n                            PTR_FUN_001261f0,1,pcVar19);\n      DAT_00127314 = *(uint *)(&DAT_0011a790 + lVar20 * 4);\n      break;\n    case 0x8b:\n      in_R9 = PTR_FUN_001261f0;\n      lVar20 = FUN_0010e860(\"--quoting-style\",optarg,&PTR_s_literal_00125a20,&DAT_0011ed20,4,\n                            PTR_FUN_001261f0,1,extraout_RDX);\n      local_90 = *(int *)(&DAT_0011ed20 + lVar20 * 4);\n      break;\n    case 0x8c:\n      goto switchD_00104e68_caseD_8c;\n    case 0x8d:\n      DAT_00127328 = 0x90;\n      DAT_0012731c = 0x90;\n      DAT_00127320 = 1;\n      DAT_00126020 = 1;\n      break;\n    case 0x8e:\n      in_R9 = PTR_FUN_001261f0;\n      lVar20 = FUN_0010e860(\"--sort\",optarg,&DAT_00125280,&DAT_0011a750,4,PTR_FUN_001261f0,1,\n                            (long)&switchD_00104e68::switchdataD_0011a190 +\n                            (long)(int)(&switchD_00104e68::switchdataD_0011a190)[iVar7 + 0x83]);\n      local_8c = *(int *)(&DAT_0011a750 + lVar20 * 4);\n      break;\n    case 0x8f:\n      in_R10 = (undefined8 *)0x1;\n      pcVar19 = PTR_FUN_001261f0;\n      lVar20 = FUN_0010e860(\"--time\",optarg,&PTR_s_atime_00125220,&DAT_0011a720,4,PTR_FUN_001261f0,1\n                            ,in_R9);\n      DAT_00127334 = *(int *)(&DAT_0011a720 + lVar20 * 4);\n      in_R9 = pcVar19;\n      break;\n    case 0x90:\n      goto switchD_00104e68_caseD_90;\n    case 0x91:\n      DAT_00126019 = '\\0';\n      DAT_00127312 = 0;\n      local_94 = (uint)(local_94 != 0);\n      local_90 = 0;\nswitchD_00104e68_caseD_8c:\n      local_70 = 0;\n      break;\n    case -0x83:\n      uVar11 = FUN_00114e00(\"David MacKenzie\",\"David MacKenzie\");\n      uVar13 = FUN_00114e00(\"Richard M. Stallman\",\"Richard M. Stallman\");\n      pcVar19 = \"ls\";\n      iVar7 = DAT_001261e0;\n      if (DAT_001261e0 != 1) {\n        pcVar19 = \"dir\";\n        iVar7 = 0x11be3b;\n        if (DAT_001261e0 != 2) {\n          pcVar19 = \"vdir\";\n        }\n      }\n      FUN_00117c70(stdout,pcVar19,\"GNU coreutils\",PTR_DAT_001261e8,uVar13,uVar11,0,iVar7);\n                    /* WARNING: Subroutine does not return */\n      exit(0);\n    case -0x82:\n      goto switchD_00104e68_caseD_ffffff7e;\n    default:\n      goto switchD_00104e68_caseD_ffffff7f;\n    }\n  } while( true );\nswitchD_00104e68_caseD_90:\n  local_80 = optarg;\n  goto LAB_00104e30;\nswitchD_00104e68_caseD_ffffff7e:\n  FUN_0010dc80(0);\nLAB_001063b0:\n  cVar5 = FUN_00106dd0();\n  if (cVar5 == '\\0') {\n    DAT_00127338 = 1;\nLAB_001052c1:\n    if (DAT_00127312 != 0) goto LAB_00104ec8;\n    if (local_88 != 0xffffffffffffffff) goto LAB_00104ed4;\nLAB_001052da:\n    local_88 = 0x50;\n  }\n  else {\nLAB_001062f2:\n    DAT_00127338 = 2;\nLAB_00104ec8:\n    if (local_88 == 0xffffffffffffffff) {\n      cVar5 = FUN_00106dd0();\n      if ((cVar5 != '\\0') && (iVar7 = ioctl(1,0x5413,&local_58), -1 < iVar7)) {\n        local_88 = (ulong)local_58._2_2_;\n        if (local_58._2_2_ != 0) goto LAB_00104ed4;\n      }\n      pcVar19 = getenv(\"COLUMNS\");\n      if ((pcVar19 != (char *)0x0) && (*pcVar19 != '\\0')) {\n        local_88 = FUN_00106cf0(pcVar19);\n        if (-1 < (long)local_88) goto LAB_00104ed4;\n        uVar11 = FUN_00117100(pcVar19);\n        error(0,0,\"ignoring invalid width in environment variable COLUMNS: %s\",uVar11);\n      }\n      goto LAB_001052da;\n    }\n  }\nLAB_00104ed4:\n  DAT_001272b0 = local_88;\n  DAT_00127200 = (local_88 / 3 + 1) - (ulong)(local_88 % 3 == 0);\n  puVar4 = DAT_001272c0;\n  if ((DAT_00127338 - 2 < 3) && (puVar4 = local_78, (long)local_78 < 0)) {\n    DAT_001272c0 = (undefined *)0x8;\n    pcVar19 = getenv(\"TABSIZE\");\n    puVar4 = DAT_001272c0;\n    if ((pcVar19 != (char *)0x0) &&\n       (iVar7 = FUN_001186b0(pcVar19,0,0,&local_58,&DAT_0011bdd5), puVar4 = local_58, iVar7 != 0)) {\n      uVar11 = FUN_00117100(pcVar19);\n      error(0,0,\"ignoring invalid tab size in environment variable TABSIZE: %s\",uVar11);\n      puVar4 = DAT_001272c0;\n    }\n  }\n  DAT_001272c0 = puVar4;\n  bVar6 = (byte)local_70;\n  if ((local_70 == -1) && (bVar6 = 0, DAT_001261e0 == 1)) {\n    bVar6 = FUN_00106dd0();\n  }\n  DAT_001272d8 = bVar6 & 1;\n  if (local_90 < 0) {\n    pcVar19 = getenv(\"QUOTING_STYLE\");\n    if (pcVar19 != (char *)0x0) {\n      iVar7 = FUN_0010e570(pcVar19,&PTR_s_literal_00125a20,&DAT_0011ed20,4);\n      if (iVar7 < 0) {\n        uVar11 = FUN_00117100(pcVar19);\n        error(0,0,\"ignoring invalid value of environment variable QUOTING_STYLE: %s\",uVar11);\n      }\n      else {\n        local_90 = *(int *)(&DAT_0011ed20 + (long)iVar7 * 4);\n        if (-1 < local_90) goto LAB_00104f3f;\n      }\n    }\n    local_90 = 7;\n    if (DAT_001261e0 != 1) goto LAB_00104f3f;\n    cVar5 = FUN_00106dd0();\n    if (cVar5 != '\\0') {\n      local_90 = 3;\n      goto LAB_00104f3f;\n    }\n  }\n  else {\nLAB_00104f3f:\n    FUN_00116590(0,local_90);\n  }\n  iVar7 = FUN_00116570(0);\n  if (((DAT_00127338 == 0) || ((DAT_00127338 - 2 < 2 && (DAT_001272b0 != 0)))) &&\n     ((iVar7 == 3 || ((iVar7 == 6 || (iVar7 == 1)))))) {\n    DAT_001273a8 = 1;\n    DAT_001272d0 = FUN_00116530(0);\n  }\n  else {\n    DAT_001273a8 = 0;\n    DAT_001272d0 = FUN_00116530(0);\n    if (iVar7 == 7) {\n      FUN_001165b0(DAT_001272d0,0x20,1);\n    }\n  }\n  if (1 < DAT_00127314) {\n    pcVar19 = \"*=>@|\" + (DAT_00127314 - 2);\n    cVar5 = \"*=>@|\"[DAT_00127314 - 2];\n    while (cVar5 != '\\0') {\n      pcVar19 = pcVar19 + 1;\n      FUN_001165b0(DAT_001272d0,(int)cVar5,1);\n      cVar5 = *pcVar19;\n    }\n  }\n  DAT_001272c8 = FUN_00116530(0);\n  FUN_001165b0(DAT_001272c8,0x3a,1);\n  DAT_00127318 = (DAT_00127311 ^ 1) & DAT_00127338 == 0 & DAT_00127318;\n  if ((int)DAT_00126019 < (int)(uint)DAT_00127318) goto LAB_00106800;\n  DAT_00127330 = local_8c;\n  if (local_8c < 0) {\n    if (DAT_00127338 != 0) {\n      if (2 < DAT_00127334 - 1U) {\n        DAT_00127330 = 0;\n        goto LAB_00105030;\n      }\n      DAT_00127330 = 5;\n      goto LAB_0010503e;\n    }\n    DAT_00127330 = 0;\n  }\n  else {\nLAB_00105030:\n    if (DAT_00127338 != 0) goto LAB_0010503e;\n  }\n  if ((local_80 == (char *)0x0) && (local_80 = getenv(\"TIME_STYLE\"), local_80 == (char *)0x0)) {\n    local_80 = \"locale\";\n  }\n  else {\n    while (iVar7 = strncmp(local_80,\"posix-\",6), iVar7 == 0) {\n      cVar5 = FUN_0010fea0(2);\n      if (cVar5 == '\\0') goto LAB_0010503e;\n      local_80 = local_80 + 6;\n    }\n    if (*local_80 == '+') {\n      local_80 = local_80 + 1;\n      pcVar21 = strchr(local_80,10);\n      pcVar19 = local_80;\n      if (pcVar21 == (char *)0x0) goto LAB_00105d26;\n      pcVar19 = strchr(pcVar21 + 1,10);\n      if (pcVar19 == (char *)0x0) {\n        *pcVar21 = '\\0';\n        pcVar19 = pcVar21 + 1;\n        goto LAB_00105d26;\n      }\n      uVar11 = FUN_00117100(local_80);\n      error(2,0,\"invalid time style format %s\",uVar11);\n      goto LAB_00106765;\n    }\n  }\n  ppuVar18 = &PTR_s_full_iso_001259c0;\n  lVar20 = FUN_0010e570(local_80,&PTR_s_full_iso_001259c0,&DAT_0011a7a0,4);\n  if (-1 < lVar20) goto code_r0x00105cf2;\n  FUN_0010e6e0(\"time style\",local_80,lVar20);\n  fwrite_unlocked(\"Valid arguments are:\\n\",1,0x15,stderr);\n  pcVar19 = \"full-iso\";\n  do {\n    ppuVar18 = ppuVar18 + 1;\n    __fprintf_chk(stderr,1,\"  - [posix-]%s\\n\",pcVar19);\n    pcVar19 = *ppuVar18;\n  } while (pcVar19 != (char *)0x0);\n  fwrite_unlocked(\"  - +FORMAT (e.g., +%H:%M) for a \\'date\\'-style format\\n\",1,0x35,stderr);\nswitchD_00104e68_caseD_ffffff7f:\n  FUN_0010dc80();\n  goto switchD_00104e68_caseD_ffffff7e;\nLAB_00106800:\n  error(2,0,\"--dired and --zero are incompatible\");\n  goto LAB_00106815;\nLAB_00106439:\n  while (psVar24 = psVar17, psVar24 != (size_t *)0x0) {\n    bVar2 = 0;\n    psVar17 = (size_t *)psVar24[5];\n    for (psVar1 = psVar17; psVar1 != (size_t *)0x0; psVar1 = (size_t *)psVar1[5]) {\n      sVar16 = *psVar1;\n      if ((sVar16 != 0xffffffffffffffff) && (sVar16 == *psVar24)) {\n        pvVar10 = (void *)psVar1[1];\n        __s1 = (void *)psVar24[1];\n        iVar8 = memcmp(__s1,pvVar10,sVar16);\n        if (iVar8 == 0) {\nLAB_00106542:\n          *psVar1 = 0xffffffffffffffff;\n        }\n        else {\n          iVar8 = FUN_0010ea60(__s1,pvVar10,sVar16);\n          if (iVar8 == 0) {\n            if (bVar2 != 0) goto LAB_00106542;\n            if ((psVar24[2] == psVar1[2]) &&\n               (iVar8 = memcmp((void *)psVar24[3],(void *)psVar1[3],psVar24[2]), iVar8 == 0)) {\n              *psVar1 = 0xffffffffffffffff;\n              bVar2 = bVar6;\n            }\n            else {\n              *(undefined *)(psVar24 + 4) = 1;\n              *(undefined *)(psVar1 + 4) = 1;\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_00105442:\n  if ((_DAT_001260d0 == 6) && (iVar8 = strncmp(PTR_s_01_36_001260d8,\"target\",6), iVar8 == 0)) {\n    DAT_00127390 = '\\x01';\n  }\nLAB_00105450:\n  if (DAT_00127312 == 0) goto LAB_00105058;\n  DAT_001272c0 = (undefined *)0x0;\n  if ((((DAT_001272f4 != 0) || (cVar5 = FUN_00106d60(0xd), cVar5 != '\\0')) ||\n      ((cVar5 = FUN_00106d60(0xe), cVar5 != '\\0' && (DAT_00127390 != '\\0')))) ||\n     ((cVar5 = FUN_00106d60(0xc), cVar5 != '\\0' && (DAT_00127338 == 0)))) goto LAB_001054a0;\n  goto LAB_00105065;\ncode_r0x00105cf2:\n  if (lVar20 == 2) {\n    PTR_DAT_00126040 = s__Y__m__d_0011c04f;\n    PTR_s__b__e__H__M_00126048 = &DAT_0011c043;\n    local_80 = PTR_DAT_00126040;\n    pcVar19 = PTR_s__b__e__H__M_00126048;\n  }\n  else {\n    local_80 = PTR_DAT_00126040;\n    pcVar19 = PTR_s__b__e__H__M_00126048;\n    if (lVar20 < 3) {\n      if (lVar20 == 0) {\n        PTR_s__b__e__H__M_00126048 = s__Y__m__d__H__M__S__N__z_0011c028;\n        PTR_DAT_00126040 = s__Y__m__d__H__M__S__N__z_0011c028;\n        local_80 = PTR_DAT_00126040;\n        pcVar19 = PTR_s__b__e__H__M_00126048;\n      }\n      else if (lVar20 == 1) {\n        PTR_s__b__e__H__M_00126048 = &DAT_0011c040;\n        PTR_DAT_00126040 = &DAT_0011c040;\n        local_80 = PTR_DAT_00126040;\n        pcVar19 = PTR_s__b__e__H__M_00126048;\n      }\n    }\n    else if (lVar20 == 3) {\n      FUN_0010fea0(2);\n      local_80 = PTR_DAT_00126040;\n      pcVar19 = PTR_s__b__e__H__M_00126048;\n    }\n  }\nLAB_00105d26:\n  PTR_s__b__e__H__M_00126048 = pcVar19;\n  PTR_DAT_00126040 = local_80;\n  FUN_00106e00();\nLAB_0010503e:\n  bVar6 = DAT_00127312;\n  iVar7 = optind;\n  if (DAT_00127312 != 0) {\n    local_60 = getenv(\"LS_COLORS\");\n    if ((local_60 != (char *)0x0) && (*local_60 != '\\0')) {\n      local_43 = 0x3f3f;\n      local_41 = 0;\n      DAT_00127300 = (undefined *)FUN_00118350(local_60);\n      local_58 = DAT_00127300;\n      do {\n        while( true ) {\n          while (cVar5 = *local_60, cVar5 == '*') {\n            pcVar19 = local_60 + 1;\n            psVar17 = (size_t *)FUN_00117e10(0x30);\n            *(undefined *)(psVar17 + 4) = 0;\n            psVar17[5] = (size_t)DAT_00127308;\n            DAT_00127308 = psVar17;\n            psVar17[1] = (size_t)local_58;\n            local_60 = pcVar19;\n            cVar5 = FUN_00106960(&local_58,&local_60,1,psVar17);\n            if ((cVar5 == '\\0') ||\n               (pcVar19 = local_60 + 1, cVar5 = *local_60, local_60 = pcVar19, cVar5 != '='))\n            goto LAB_00105403;\n            psVar17[3] = (size_t)local_58;\n            cVar5 = FUN_00106960(&local_58,&local_60,0,psVar17 + 2);\n            if (cVar5 == '\\0') goto LAB_00105403;\n          }\n          if (cVar5 != ':') break;\n          local_60 = local_60 + 1;\n        }\n        psVar17 = DAT_00127308;\n        if (cVar5 == '\\0') goto LAB_00106439;\n        local_43 = CONCAT11(local_43._1_1_,cVar5);\n        if (local_60[1] == '\\0') goto LAB_00105403;\n        local_43 = CONCAT11(local_60[1],cVar5);\n        pcVar19 = local_60 + 2;\n        local_60 = local_60 + 3;\n        if (*pcVar19 != '=') goto LAB_00105403;\n        lVar20 = 0;\n        pcVar19 = \"lc\";\n        while (iVar8 = strcmp((char *)&local_43,pcVar19), iVar8 != 0) {\n          lVar20 = lVar20 + 1;\n          pcVar19 = (&PTR_DAT_001258a0)[lVar20];\n          if (pcVar19 == (char *)0x0) goto LAB_001053e1;\n        }\n        (&PTR_DAT_00126068)[(long)(int)lVar20 * 2] = local_58;\n        cVar5 = FUN_00106960(&local_58,&local_60,0);\n      } while (cVar5 != '\\0');\nLAB_001053e1:\n      uVar11 = FUN_00117100(&local_43);\n      error(0,0,\"unrecognized prefix: %s\",uVar11);\nLAB_00105403:\n      error(0,0,\"unparsable value for LS_COLORS environment variable\");\n      free(DAT_00127300);\n      psVar17 = DAT_00127308;\n      while (psVar17 != (size_t *)0x0) {\n        psVar24 = (size_t *)psVar17[5];\n        free(psVar17);\n        psVar17 = psVar24;\n      }\n      DAT_00127312 = 0;\n      goto LAB_00105442;\n    }\n    pcVar19 = getenv(\"COLORTERM\");\n    if ((pcVar19 == (char *)0x0) || (*pcVar19 == '\\0')) {\n      pcVar19 = getenv(\"TERM\");\n      if ((pcVar19 != (char *)0x0) && (*pcVar19 != '\\0')) {\n        pcVar21 = \"# Configuration file for dircolors, a utility to help you set the\";\n        do {\n          iVar8 = strncmp(pcVar21,\"TERM \",5);\n          if ((iVar8 == 0) && (iVar8 = fnmatch(pcVar21 + 5,pcVar19,0), iVar8 == 0))\n          goto LAB_00105450;\n          sVar16 = strlen(pcVar21);\n          pcVar21 = pcVar21 + sVar16 + 1;\n        } while (pcVar21 + -0x11a7c0 < (char *)0x1569);\n      }\n      DAT_00127312 = 0;\n    }\n    goto LAB_00105450;\n  }\nLAB_00105058:\n  if (DAT_001272f4 != 0) {\nLAB_001054a0:\n    DAT_001272fd = 1;\n  }\nLAB_00105065:\n  lVar20 = (long)iVar7;\n  if (((DAT_001272f8 == 0) && (DAT_001272f8 = 1, DAT_001272f5 == '\\0')) && (DAT_00127314 != 3)) {\n    DAT_001272f8 = (-(uint)(DAT_00127338 == 0) & 0xfffffffe) + 3;\n  }\n  if (DAT_001272f6 != '\\0') {\n    DAT_001273c8 = FUN_001108b0(0x1e,0,FUN_00106910,FUN_00106920,free);\n    if (DAT_001273c8 == 0) {\nLAB_00106815:\n                    /* WARNING: Subroutine does not return */\n      FUN_00118390();\n    }\n    _obstack_begin(&DAT_001270e0,0,0,PTR_malloc_00125fd8,PTR_free_00125fa0);\n  }\n  pcVar19 = getenv(\"TZ\");\n  DAT_001272a8 = FUN_001173f0(pcVar19);\n  puVar3 = PTR_malloc_00125fd8;\n  puVar4 = PTR_free_00125fa0;\n  if ((((DAT_00127330 - 3U & 0xfffffffd) == 0) || (DAT_00127338 == 0)) ||\n     ((DAT_00127365 != '\\0' || (DAT_0012732c != '\\0')))) {\n    DAT_001272a1 = 1;\n    bVar6 = 0;\n  }\n  else {\n    DAT_001272a1 = 0;\n    bVar6 = 1;\n    if (((DAT_001272f6 == '\\0') && (DAT_00127312 == 0)) && (DAT_00127314 == 0)) {\n      bVar6 = DAT_001272f4;\n    }\n  }\n  DAT_001272a0 = bVar6 & 1;\n  if (DAT_00127318 != 0) {\n    _obstack_begin(&DAT_001271a0,0,0,PTR_malloc_00125fd8,PTR_free_00125fa0);\n    _obstack_begin(&DAT_00127140,0,0,puVar3,puVar4);\n  }\n  if (DAT_00127311 != 0) {\n    uVar15 = 0;\nLAB_001060ff:\n    do {\n      iVar8 = (int)uVar15;\n      if (uVar15 < 0x5b) {\n        bVar25 = true;\n        if ((iVar8 < 0x41) && (9 < iVar8 - 0x30U)) goto joined_r0x001060d8;\n      }\n      else {\n        bVar25 = true;\n        if (0x19 < iVar8 - 0x61U) {\njoined_r0x001060d8:\n          if ((iVar8 - 0x2dU < 2) || (iVar8 == 0x7e)) {\n            (&DAT_00126fe0)[uVar15] = (&DAT_00126fe0)[uVar15] | 1;\n            uVar15 = uVar15 + 1;\n            if (uVar15 == 0x100) break;\n            goto LAB_001060ff;\n          }\n          bVar25 = iVar8 == 0x5f;\n        }\n      }\n      (&DAT_00126fe0)[uVar15] = (&DAT_00126fe0)[uVar15] | bVar25;\n      uVar15 = uVar15 + 1;\n    } while (uVar15 != 0x100);\n    DAT_00127388 = (undefined *)FUN_001184f0();\n    if (DAT_00127388 == (undefined *)0x0) {\n      DAT_00127388 = &DAT_0011bdd5;\n    }\n  }\n  _DAT_001273b8 = 100;\n  DAT_001273c0 = FUN_00117f50(100,0xd0);\n  iVar7 = param_1 - iVar7;\n  DAT_001273b0 = 0;\n  FUN_001086e0();\n  if (iVar7 < 1) {\n    if (DAT_001272f5 == '\\0') {\n      FUN_00107070(&DAT_0011c095,0,1);\n    }\n    else {\n      FUN_00109620(&DAT_0011c095,3,1,&DAT_0011bdd5);\n    }\n    if (DAT_001273b0 != 0) goto LAB_0010604b;\nLAB_00105d65:\n    if (DAT_00127380 == (void **)0x0) goto LAB_00105bb8;\n    __ptr = DAT_00127380;\n    if (DAT_00127380[3] == (void *)0x0) {\n      DAT_001272b8 = 0;\n    }\n  }\n  else {\n    do {\n      puVar22 = param_2 + lVar20;\n      lVar20 = lVar20 + 1;\n      FUN_00109620(*puVar22,0,1,&DAT_0011bdd5);\n    } while ((int)lVar20 < (int)param_1);\n    if (DAT_001273b0 == 0) {\nLAB_001051b7:\n      if (1 < iVar7) goto LAB_00105205;\n      goto LAB_00105d65;\n    }\nLAB_0010604b:\n    FUN_00108d50();\n    if (DAT_001272f5 == '\\0') {\n      FUN_00109440(0,1);\n    }\n    if (DAT_001273b0 == 0) goto LAB_001051b7;\n    FUN_0010d240();\n    if (DAT_00127380 == (void **)0x0) goto LAB_00105bb8;\n    DAT_001271f8 = DAT_001271f8 + 1;\n    pcVar19 = stdout->_IO_write_ptr;\n    if (stdout->_IO_write_end <= pcVar19) {\n      __overflow(stdout,10);\n      goto LAB_00105205;\n    }\n    stdout->_IO_write_ptr = pcVar19 + 1;\n    *pcVar19 = '\\n';\n    __ptr = DAT_00127380;\n  }\n  do {\n    DAT_00127380 = (void **)__ptr[3];\n    if ((DAT_001273c8 == 0) || (*__ptr != (void *)0x0)) {\n      FUN_0010d640(*__ptr,__ptr[1],*(undefined *)(__ptr + 2));\n      free(*__ptr);\n      free(__ptr[1]);\n      free(__ptr);\n      DAT_001272b8 = 1;\n    }\n    else {\n      if ((ulong)(DAT_001270f8 - _DAT_001270f0) < 0x10) {\nLAB_00106765:\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"dev_ino_size <= __extension__ ({ struct obstack const *__o = (&dev_ino_obstack); (size_t) (__o->next_free - __o->object_base); })\"\n                      ,\"src/ls.c\",0x41d,\"dev_ino_pop\");\n      }\n      local_58 = *(undefined **)(DAT_001270f8 + -0x10);\n      local_50 = *(undefined8 *)(DAT_001270f8 + -8);\n      DAT_001270f8 = DAT_001270f8 + -0x10;\n      pvVar10 = (void *)FUN_00110fb0(DAT_001273c8,&local_58);\n      if (pvVar10 == (void *)0x0) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"found\",\"src/ls.c\",0x70c,\"main\");\n      }\n      free(pvVar10);\n      free(*__ptr);\n      free(__ptr[1]);\n      free(__ptr);\n    }\nLAB_00105205:\n    __ptr = DAT_00127380;\n  } while (DAT_00127380 != (void **)0x0);\nLAB_00105bb8:\n  if ((DAT_00127312 != 0) && (DAT_00127310 != '\\0')) {\n    if ((_DAT_00126060 != 2) ||\n       (((*(short *)PTR_DAT_00126068 != 0x5b1b || (_DAT_00126070 != 1)) ||\n        (*PTR_DAT_00126078 != 'm')))) {\n      FUN_00107940(&DAT_00126060);\n      FUN_00107940(&DAT_00126070);\n    }\n    fflush_unlocked(stdout);\n    FUN_00107770(0);\n    for (iVar7 = DAT_00127214; iVar7 != 0; iVar7 = iVar7 + -1) {\n      raise(0x13);\n    }\n    if (DAT_00127218 != 0) {\n      raise(DAT_00127218);\n    }\n  }\n  if (DAT_00127318 != 0) {\n    FUN_00107510(\"//DIRED//\",&DAT_001271a0);\n    FUN_00107510(\"//SUBDIRED//\",&DAT_00127140);\n    uVar9 = FUN_00116570(DAT_001272d0);\n    __printf_chk(1,\"//DIRED-OPTIONS// --quoting-style=%s\\n\",(&PTR_s_literal_00125a20)[uVar9]);\n  }\n  lVar20 = DAT_001273c8;\n  if (DAT_001273c8 != 0) {\n    lVar14 = FUN_001103d0(DAT_001273c8);\n    if (lVar14 != 0) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"hash_get_n_entries (active_dir_set) == 0\",\"src/ls.c\",0x740,\"main\");\n    }\n    FUN_00110a70(lVar20);\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return DAT_00127210;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "abort": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid abort(void)\n\n{\n  (*(code *)PTR_abort_00125cc0)();\n  return;\n}\n\n",
  "opendir": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nDIR * opendir(char *__name)\n\n{\n  DIR *pDVar1;\n  \n  pDVar1 = (DIR *)(*(code *)PTR_opendir_00125d58)();\n  return pDVar1;\n}\n\n",
  "closedir": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint closedir(DIR *__dirp)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_closedir_00125e00)();\n  return iVar1;\n}\n\n",
  "FUN_0010ffe0": "\nlong FUN_0010ffe0(long *param_1,long param_2,long **param_3,char param_4)\n\n{\n  undefined8 *puVar1;\n  long *plVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  char cVar6;\n  ulong uVar7;\n  long lVar8;\n  long *plVar9;\n  \n  uVar7 = (*(code *)param_1[6])(param_2,param_1[2]);\n  if ((ulong)param_1[2] <= uVar7) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  plVar9 = (long *)(uVar7 * 0x10 + *param_1);\n  *param_3 = plVar9;\n  lVar8 = *plVar9;\n  if (lVar8 == 0) {\nLAB_0011008f:\n    lVar8 = 0;\n  }\n  else {\n    if (lVar8 != param_2) {\n      cVar6 = (*(code *)param_1[7])(param_2);\n      if (cVar6 == '\\0') {\n        for (; (long *)plVar9[1] != (long *)0x0; plVar9 = (long *)plVar9[1]) {\n          if ((*(long *)plVar9[1] == param_2) ||\n             (cVar6 = (*(code *)param_1[7])(param_2), cVar6 != '\\0')) {\n            plVar2 = (long *)plVar9[1];\n            lVar8 = *plVar2;\n            if (param_4 == '\\0') {\n              return lVar8;\n            }\n            plVar9[1] = plVar2[1];\n            *plVar2 = 0;\n            plVar2[1] = param_1[9];\n            param_1[9] = (long)plVar2;\n            return lVar8;\n          }\n        }\n        goto LAB_0011008f;\n      }\n      lVar8 = *plVar9;\n    }\n    if (param_4 != '\\0') {\n      puVar1 = (undefined8 *)plVar9[1];\n      if (puVar1 != (undefined8 *)0x0) {\n        uVar3 = *(undefined4 *)((long)puVar1 + 4);\n        uVar4 = *(undefined4 *)(puVar1 + 1);\n        uVar5 = *(undefined4 *)((long)puVar1 + 0xc);\n        *(undefined4 *)plVar9 = *(undefined4 *)puVar1;\n        *(undefined4 *)((long)plVar9 + 4) = uVar3;\n        *(undefined4 *)(plVar9 + 1) = uVar4;\n        *(undefined4 *)((long)plVar9 + 0xc) = uVar5;\n        *puVar1 = 0;\n        puVar1[1] = param_1[9];\n        param_1[9] = (long)puVar1;\n        return lVar8;\n      }\n      *plVar9 = 0;\n    }\n  }\n  return lVar8;\n}\n\n",
  "FUN_00117e10": "\nvoid FUN_00117e10(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if (pvVar1 != (void *)0x0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_001103e0": "\nulong FUN_001103e0(long **param_1)\n\n{\n  long lVar1;\n  long *plVar2;\n  ulong uVar3;\n  ulong uVar4;\n  \n  plVar2 = *param_1;\n  uVar4 = 0;\n  do {\n    if (param_1[1] <= plVar2) {\n      return uVar4;\n    }\n    while (*plVar2 != 0) {\n      uVar3 = 1;\n      for (lVar1 = plVar2[1]; lVar1 != 0; lVar1 = *(long *)(lVar1 + 8)) {\n        uVar3 = uVar3 + 1;\n      }\n      if (uVar4 < uVar3) {\n        uVar4 = uVar3;\n      }\n      plVar2 = plVar2 + 2;\n      if (param_1[1] <= plVar2) {\n        return uVar4;\n      }\n    }\n    plVar2 = plVar2 + 2;\n  } while( true );\n}\n\n",
  "FUN_00106880": "\n/* WARNING: Removing unreachable block (ram,0x001068a4) */\n/* WARNING: Removing unreachable block (ram,0x001068b0) */\n\nvoid FUN_00106880(void)\n\n{\n  return;\n}\n\n",
  "lseek": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = (*(code *)PTR_lseek_00125dc0)();\n  return _Var1;\n}\n\n",
  "FUN_001124b0": "\nulong FUN_001124b0(char *param_1,undefined *param_2,long param_3,ulong *param_4,int param_5,\n                  ulong param_6)\n\n{\n  size_t __n;\n  wchar_t *pwVar1;\n  undefined *puVar2;\n  bool bVar3;\n  int iVar4;\n  ulong uVar5;\n  ulong uVar6;\n  undefined *puVar7;\n  size_t sVar8;\n  wchar_t *__s;\n  long lVar9;\n  char *__s_00;\n  ulong uVar10;\n  undefined *puVar11;\n  wchar_t *pwVar13;\n  wchar_t wVar14;\n  ulong uVar15;\n  ulong uVar16;\n  size_t local_48;\n  undefined *puVar12;\n  \n  uVar5 = strlen(param_1);\n  uVar10 = uVar5;\n  if (((param_6 & 2) == 0) && (sVar8 = __ctype_get_mb_cur_max(), 1 < sVar8)) {\n    sVar8 = mbstowcs((wchar_t *)0x0,param_1,0);\n    if (sVar8 == 0xffffffffffffffff) {\n      if ((param_6 & 1) == 0) {\nLAB_0011267a:\n        __s = (wchar_t *)0x0;\n        __s_00 = (char *)0x0;\n        uVar16 = 0xffffffffffffffff;\n        goto LAB_001125d3;\n      }\n      goto LAB_001124ec;\n    }\n    __n = sVar8 + 1;\n    __s = (wchar_t *)malloc(__n * 4);\n    if (__s == (wchar_t *)0x0) {\n      if ((param_6 & 1) == 0) goto LAB_0011267a;\nLAB_00112862:\n      __s_00 = (char *)0x0;\n      goto LAB_001124f5;\n    }\n    lVar9 = __mbstowcs_chk(__s,param_1,__n,0x3fffffffffffffff);\n    if (lVar9 == 0) goto LAB_00112862;\n    __s[sVar8] = L'\\0';\n    wVar14 = *__s;\n    if (wVar14 != L'\\0') {\n      bVar3 = false;\n      pwVar13 = __s;\n      do {\n        iVar4 = iswprint(wVar14);\n        if (iVar4 == 0) {\n          *pwVar13 = L'';\n          bVar3 = true;\n        }\n        wVar14 = pwVar13[1];\n        pwVar13 = pwVar13 + 1;\n      } while (wVar14 != L'\\0');\n      iVar4 = wcswidth(__s,__n);\n      uVar10 = (ulong)iVar4;\n      if (!bVar3) goto LAB_00112839;\n      local_48 = wcstombs((char *)0x0,__s,0);\nLAB_0011277f:\n      local_48 = local_48 + 1;\n      __s_00 = (char *)malloc(local_48);\n      if (__s_00 == (char *)0x0) {\n        uVar16 = 0xffffffffffffffff;\n        if ((param_6 & 1) == 0) goto LAB_001125d3;\n      }\n      else {\n        uVar5 = *param_4;\n        wVar14 = *__s;\n        pwVar13 = __s;\n        uVar10 = 0;\n        while (wVar14 != L'\\0') {\n          iVar4 = wcwidth(wVar14);\n          if (iVar4 == -1) {\n            *pwVar13 = L'';\n            uVar16 = uVar10 + 1;\n          }\n          else {\n            uVar16 = (long)iVar4 + uVar10;\n          }\n          if (uVar5 < uVar16) break;\n          pwVar1 = pwVar13 + 1;\n          pwVar13 = pwVar13 + 1;\n          uVar10 = uVar16;\n          wVar14 = *pwVar1;\n        }\n        *pwVar13 = L'\\0';\n        uVar5 = wcstombs(__s_00,__s,local_48);\n        param_1 = __s_00;\n      }\n      goto LAB_001124f5;\n    }\n    iVar4 = wcswidth(__s,__n);\n    uVar10 = (ulong)iVar4;\nLAB_00112839:\n    uVar16 = *param_4;\n    local_48 = uVar5;\n    if (uVar16 < uVar10) goto LAB_0011277f;\n    __s_00 = (char *)0x0;\nLAB_00112603:\n    uVar6 = uVar10;\n    uVar15 = uVar5;\n    if (uVar16 <= uVar10) goto LAB_0011250b;\n    uVar16 = uVar16 - uVar10;\n    *param_4 = uVar10;\n    if (param_5 != 0) goto LAB_0011251f;\nLAB_00112629:\n    uVar10 = 0;\n    uVar6 = uVar16;\n  }\n  else {\nLAB_001124ec:\n    __s = (wchar_t *)0x0;\n    __s_00 = (char *)0x0;\nLAB_001124f5:\n    uVar16 = *param_4;\n    uVar6 = uVar16;\n    uVar15 = uVar16;\n    if (uVar10 <= uVar16) goto LAB_00112603;\nLAB_0011250b:\n    uVar16 = 0;\n    *param_4 = uVar6;\n    uVar5 = uVar15;\n    if (param_5 == 0) goto LAB_00112629;\nLAB_0011251f:\n    uVar10 = uVar16;\n    uVar6 = 0;\n    if (param_5 != 1) {\n      uVar10 = (ulong)((uint)uVar16 & 1) + (uVar16 >> 1);\n      uVar6 = uVar16 >> 1;\n    }\n  }\n  uVar16 = uVar10 + uVar5;\n  if ((param_6 & 4) != 0) {\n    uVar10 = 0;\n    uVar16 = uVar5;\n  }\n  if ((param_6 & 8) == 0) {\n    uVar16 = uVar16 + uVar6;\n  }\n  else {\n    uVar6 = 0;\n  }\n  if (param_3 != 0) {\n    puVar2 = param_2 + param_3 + -1;\n    puVar11 = param_2;\n    if ((param_2 < puVar2) && (puVar7 = param_2, uVar10 != 0)) {\n      do {\n        puVar11 = puVar7 + 1;\n        *puVar7 = 0x20;\n        if (param_2 + (uVar10 - (long)puVar11) == (undefined *)0x0) break;\n        puVar7 = puVar11;\n      } while (puVar11 < puVar2);\n    }\n    uVar10 = (long)puVar2 - (long)puVar11;\n    if (uVar5 < (ulong)((long)puVar2 - (long)puVar11)) {\n      uVar10 = uVar5;\n    }\n    puVar7 = (undefined *)mempcpy(puVar11,param_1,uVar10);\n    puVar11 = puVar7;\n    if ((puVar7 < puVar2) && (puVar12 = puVar7, uVar6 != 0)) {\n      do {\n        puVar11 = puVar12 + 1;\n        *puVar12 = 0x20;\n        if (puVar7 + (uVar6 - (long)puVar11) == (undefined *)0x0) break;\n        puVar12 = puVar11;\n      } while (puVar11 < puVar2);\n    }\n    *puVar11 = 0;\n  }\nLAB_001125d3:\n  free(__s);\n  free(__s_00);\n  return uVar16;\n}\n\n",
  "readlink": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nssize_t readlink(char *__path,char *__buf,size_t __len)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = (*(code *)PTR_readlink_00125d38)();\n  return sVar1;\n}\n\n",
  "__stack_chk_fail": "\nvoid __stack_chk_fail(void)\n\n{\n  (*(code *)PTR___stack_chk_fail_00125d78)();\n  return;\n}\n\n",
  "__printf_chk": "\nvoid __printf_chk(void)\n\n{\n  (*(code *)PTR___printf_chk_00125ed8)();\n  return;\n}\n\n",
  "calloc": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_calloc_00125e28)();\n  return pvVar1;\n}\n\n",
  "FUN_0010b620": "\nulong FUN_0010b620(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010b6a0;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010b6a0:\n  uVar3 = FUN_001090d0();\n  return uVar3;\n}\n\n",
  "FUN_0010b740": "\nulong FUN_0010b740(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010b7c0;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010b7c0:\n  uVar3 = FUN_00108a30();\n  return uVar3;\n}\n\n",
  "FUN_00111dd0": "\nundefined8 FUN_00111dd0(char *param_1,uint *param_2,long *param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  long lVar5;\n  uint uVar6;\n  long in_FS_OFFSET;\n  char *local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((param_1 == (char *)0x0) && (param_1 = getenv(\"BLOCK_SIZE\"), param_1 == (char *)0x0)) &&\n     (param_1 = getenv(\"BLOCKSIZE\"), param_1 == (char *)0x0)) {\n    pcVar4 = getenv(\"POSIXLY_CORRECT\");\n    if (pcVar4 == (char *)0x0) {\n      *param_3 = 0x400;\n      uVar3 = 0;\n      *param_2 = 0;\n    }\n    else {\n      *param_3 = 0x200;\n      uVar3 = 0;\n      *param_2 = 0;\n    }\n  }\n  else {\n    uVar6 = 0;\n    if (*param_1 == '\\'') {\n      param_1 = param_1 + 1;\n      uVar6 = 4;\n    }\n    iVar2 = FUN_0010e570(param_1,&PTR_s_human_readable_001259f0,&DAT_0011e6e0,4);\n    if (iVar2 < 0) {\n      uVar3 = FUN_001186b0(param_1,&local_38,0,param_3,\"eEgGkKmMpPtTyYzZ0\");\n      if ((int)uVar3 == 0) {\n        cVar1 = *param_1;\n        while (9 < (byte)(cVar1 - 0x30U)) {\n          if (local_38 == param_1) {\n            if (local_38[-1] == 'B') {\n              uVar6 = uVar6 | 0x180;\n              if (local_38[-2] != 'i') break;\n            }\n            else {\n              uVar6 = uVar6 | 0x80;\n            }\n            uVar6 = uVar6 | 0x20;\n            break;\n          }\n          pcVar4 = param_1 + 1;\n          param_1 = param_1 + 1;\n          cVar1 = *pcVar4;\n        }\n        lVar5 = *param_3;\n        *param_2 = uVar6;\n      }\n      else {\n        *param_2 = 0;\n        lVar5 = *param_3;\n      }\n      if (lVar5 == 0) {\n        pcVar4 = getenv(\"POSIXLY_CORRECT\");\n        *param_3 = (ulong)(-(uint)(pcVar4 == (char *)0x0) & 0x200) + 0x200;\n        uVar3 = 4;\n      }\n    }\n    else {\n      *param_3 = 1;\n      uVar3 = 0;\n      *param_2 = uVar6 | *(uint *)(&DAT_0011e6e0 + (long)iVar2 * 4);\n    }\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00116570": "\nundefined4 FUN_00116570(undefined4 *param_1)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_00127520;\n  }\n  return *param_1;\n}\n\n",
  "ioctl": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint ioctl(int __fd,ulong __request,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_ioctl_00125de0)();\n  return iVar1;\n}\n\n",
  "getcwd": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * getcwd(char *__buf,size_t __size)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_getcwd_00125de8)();\n  return pcVar1;\n}\n\n",
  "FUN_0010a650": "\nulong FUN_0010a650(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010a6d0;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010a6d0:\n  uVar3 = FUN_001072b0(param_2,param_1,PTR_strcmp_00125fc8);\n  return uVar3;\n}\n\n",
  "__cxa_atexit": "\nvoid __cxa_atexit(void)\n\n{\n  (*(code *)PTR___cxa_atexit_00125f20)();\n  return;\n}\n\n",
  "FUN_00108830": "\nvoid FUN_00108830(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  int *piVar3;\n  \n  pcVar1 = param_2[9];\n  pcVar2 = param_1[9];\n  if ((long)pcVar2 < (long)pcVar1 == (param_1[9] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) {\n    pcVar1 = *param_1;\n    pcVar2 = *param_2;\n    piVar3 = __errno_location();\n    *piVar3 = 0;\n    strcoll(pcVar1,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00116f70": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00116f70(long param_1,long param_2,undefined8 param_3)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long lStack_20;\n  long local_18;\n  long local_10;\n  \n  uStack_40 = uRam0000000000127528;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38 = _DAT_00127530;\n  uStack_30 = uRam0000000000127538;\n  local_28 = _DAT_00127540;\n  lStack_20 = uRam0000000000127548;\n  local_18 = DAT_00127550;\n  local_48 = CONCAT44((int)((ulong)_DAT_00127520 >> 0x20),10);\n  if ((param_1 != 0) && (param_2 != 0)) {\n    lStack_20 = param_1;\n    local_18 = param_2;\n    FUN_00116340(0,param_3,0xffffffffffffffff,&local_48);\n    if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return;\n    }\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "getpwnam": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\npasswd * getpwnam(char *__name)\n\n{\n  passwd *ppVar1;\n  \n  ppVar1 = (passwd *)(*(code *)PTR_getpwnam_00125e48)();\n  return ppVar1;\n}\n\n",
  "fclose": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fclose_00125d50)();\n  return iVar1;\n}\n\n",
  "__ctype_get_mb_cur_max": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t __ctype_get_mb_cur_max(void)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR___ctype_get_mb_cur_max_00125d68)();\n  return sVar1;\n}\n\n",
  "FUN_00116340": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined * FUN_00116340(uint param_1,undefined8 param_2,undefined8 param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  ulong uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  int *piVar7;\n  undefined4 *puVar8;\n  ulong uVar9;\n  undefined *__ptr;\n  long lVar10;\n  ulong *puVar11;\n  long in_FS_OFFSET;\n  long local_48;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar7 = __errno_location();\n  iVar1 = *piVar7;\n  if (0x7ffffffe < param_1) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  puVar8 = (undefined4 *)PTR_DAT_00126260;\n  if (DAT_00126258 <= (int)param_1) {\n    local_48 = (long)DAT_00126258;\n    lVar10 = (long)(int)((param_1 - DAT_00126258) + 1);\n    if (PTR_DAT_00126260 == &DAT_00126270) {\n      puVar8 = (undefined4 *)FUN_001180f0(0,&local_48,lVar10,0x7fffffff,0x10);\n      uVar6 = PTR_DAT_00126278._4_4_;\n      uVar5 = PTR_DAT_00126278._0_4_;\n      uVar3 = uRam0000000000126274;\n      PTR_DAT_00126260 = (undefined *)puVar8;\n      *puVar8 = _DAT_00126270;\n      puVar8[1] = uVar3;\n      puVar8[2] = uVar5;\n      puVar8[3] = uVar6;\n    }\n    else {\n      puVar8 = (undefined4 *)FUN_001180f0(PTR_DAT_00126260,&local_48,lVar10,0x7fffffff,0x10);\n      PTR_DAT_00126260 = (undefined *)puVar8;\n    }\n    memset(puVar8 + (long)DAT_00126258 * 4,0,(local_48 - DAT_00126258) * 0x10);\n    DAT_00126258 = (int)local_48;\n  }\n  puVar11 = (ulong *)(puVar8 + (long)(int)param_1 * 4);\n  uVar2 = param_4[1];\n  uVar4 = *puVar11;\n  __ptr = (undefined *)puVar11[1];\n  uVar9 = FUN_00114f20(__ptr,uVar4,param_2,param_3,*param_4,uVar2 | 1,param_4 + 2,\n                       *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  if (uVar4 <= uVar9) {\n    uVar9 = uVar9 + 1;\n    *puVar11 = uVar9;\n    if (__ptr != &DAT_00127420) {\n      free(__ptr);\n    }\n    __ptr = (undefined *)FUN_00117e50(uVar9);\n    uVar3 = *param_4;\n    puVar11[1] = (ulong)__ptr;\n    FUN_00114f20(__ptr,uVar9,param_2,param_3,uVar3,uVar2 | 1,param_4 + 2,\n                 *(undefined8 *)(param_4 + 10),*(undefined8 *)(param_4 + 0xc));\n  }\n  *piVar7 = iVar1;\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return __ptr;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0010a780": "\nulong FUN_0010a780(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010a800;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010a800:\n  uVar3 = FUN_001072b0(param_1,param_2,PTR_strcmp_00125fc8);\n  return uVar3;\n}\n\n",
  "sigismember": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigismember(sigset_t *__set,int __signo)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigismember_00125f38)();\n  return iVar1;\n}\n\n",
  "FUN_00107510": "\nvoid FUN_00107510(char *param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  ulong uVar3;\n  ulong uVar4;\n  undefined8 *puVar5;\n  undefined8 *puVar6;\n  \n  puVar6 = *(undefined8 **)(param_2 + 0x18);\n  puVar5 = *(undefined8 **)(param_2 + 0x10);\n  if (7 < (ulong)((long)puVar6 - (long)puVar5)) {\n    if (puVar6 == puVar5) {\n      *(byte *)(param_2 + 0x50) = *(byte *)(param_2 + 0x50) | 2;\n    }\n    uVar3 = (long)puVar6 + *(ulong *)(param_2 + 0x30) & ~*(ulong *)(param_2 + 0x30);\n    uVar4 = *(ulong *)(param_2 + 0x20);\n    if (uVar3 - *(long *)(param_2 + 8) <= *(ulong *)(param_2 + 0x20) - *(long *)(param_2 + 8)) {\n      uVar4 = uVar3;\n    }\n    puVar6 = (undefined8 *)(((long)puVar6 - (long)puVar5 & 0xfffffffffffffff8U) + (long)puVar5);\n    *(ulong *)(param_2 + 0x18) = uVar4;\n    *(ulong *)(param_2 + 0x10) = uVar4;\n    fputs_unlocked(param_1,stdout);\n    do {\n      uVar1 = *puVar5;\n      puVar5 = puVar5 + 1;\n      __printf_chk(1,&DAT_0011bd39,uVar1);\n    } while (puVar5 != puVar6);\n    pcVar2 = stdout->_IO_write_ptr;\n    if (stdout->_IO_write_end <= pcVar2) {\n      __overflow(stdout,10);\n      return;\n    }\n    stdout->_IO_write_ptr = pcVar2 + 1;\n    *pcVar2 = '\\n';\n  }\n  return;\n}\n\n",
  "FUN_00117f50": "\nvoid FUN_00117f50(undefined8 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  \n  lVar1 = reallocarray(0,param_1,param_2);\n  if (lVar1 != 0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_00114a40": "\nundefined8\nFUN_00114a40(long *param_1,long param_2,long param_3,undefined8 param_4,undefined8 param_5)\n\n{\n  long *plVar1;\n  undefined8 uVar2;\n  ulong uVar3;\n  long lVar4;\n  \n  if (param_3 == 0) {\n    lVar4 = 0xf;\n    param_3 = 0x10;\n  }\n  else {\n    lVar4 = param_3 + -1;\n  }\n  param_1[6] = lVar4;\n  if (param_2 == 0) {\n    param_2 = 0xfe0;\n  }\n  *param_1 = param_2;\n  if ((*(byte *)(param_1 + 10) & 1) == 0) {\n    plVar1 = (long *)(*(code *)param_1[7])();\n  }\n  else {\n    param_2 = param_1[9];\n    plVar1 = (long *)(*(code *)param_1[7])();\n  }\n  param_1[1] = (long)plVar1;\n  if (plVar1 != (long *)0x0) {\n    uVar3 = (long)plVar1 + lVar4 + 0x10 & -param_3;\n    param_1[2] = uVar3;\n    param_1[3] = uVar3;\n    lVar4 = *param_1;\n    *plVar1 = lVar4 + (long)plVar1;\n    param_1[4] = lVar4 + (long)plVar1;\n    plVar1[1] = 0;\n    *(byte *)(param_1 + 10) = *(byte *)(param_1 + 10) & 0xf9;\n    return 1;\n  }\n  (*(code *)obstack_alloc_failed_handler)();\n  *(byte *)(param_2 + 0x50) = *(byte *)(param_2 + 0x50) & 0xfe;\n  *(undefined8 *)(param_2 + 0x38) = param_4;\n  *(undefined8 *)(param_2 + 0x40) = param_5;\n  uVar2 = FUN_00114a40();\n  return uVar2;\n}\n\n",
  "FUN_00117e30": "\nvoid FUN_00117e30(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if (pvVar1 != (void *)0x0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "fflush_unlocked": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fflush_unlocked(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fflush_unlocked_00125f60)();\n  return iVar1;\n}\n\n",
  "FUN_00116590": "\nvoid FUN_00116590(undefined4 *param_1,undefined4 param_2)\n\n{\n  if (param_1 == (undefined4 *)0x0) {\n    param_1 = (undefined4 *)&DAT_00127520;\n  }\n  *param_1 = param_2;\n  return;\n}\n\n",
  "FUN_00119500": "\nint FUN_00119500(FILE *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  __off_t _Var4;\n  \n  iVar1 = fileno(param_1);\n  if (-1 < iVar1) {\n    iVar1 = __freading();\n    if (iVar1 != 0) {\n      iVar1 = fileno(param_1);\n      _Var4 = lseek(iVar1,0,1);\n      if (_Var4 == -1) goto LAB_0011956f;\n    }\n    iVar1 = FUN_00119590(param_1);\n    if (iVar1 != 0) {\n      piVar3 = __errno_location();\n      iVar1 = *piVar3;\n      iVar2 = fclose(param_1);\n      if (iVar1 != 0) {\n        *piVar3 = iVar1;\n        iVar2 = -1;\n      }\n      return iVar2;\n    }\n  }\nLAB_0011956f:\n  iVar1 = fclose(param_1);\n  return iVar1;\n}\n\n",
  "strcpy": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strcpy(char *__dest,char *__src)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strcpy_00125ce0)();\n  return pcVar1;\n}\n\n",
  "thunk_FUN_00110fb0": "\nvoid thunk_FUN_00110fb0(void)\n\n{\n  FUN_00110fb0();\n  return;\n}\n\n",
  "getgrgid": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ngroup * getgrgid(__gid_t __gid)\n\n{\n  group *pgVar1;\n  \n  pgVar1 = (group *)(*(code *)PTR_getgrgid_00125da0)();\n  return pgVar1;\n}\n\n",
  "FUN_001168a0": "\nvoid FUN_001168a0(undefined8 param_1)\n\n{\n  FUN_00116340(0,param_1,0xffffffffffffffff,&DAT_00127520);\n  return;\n}\n\n",
  "FUN_0010ae50": "\nulong FUN_0010ae50(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010aed0;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010aed0:\n  uVar3 = FUN_001093c0();\n  return uVar3;\n}\n\n",
  "FUN_001091f0": "\nvoid FUN_001091f0(char *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  char *pcVar1;\n  int iVar2;\n  size_t sVar3;\n  bool bVar4;\n  \n  if (param_1 != (char *)0x0) {\n    iVar2 = FUN_00112b20(param_1,0);\n    iVar2 = (int)param_3 - iVar2;\n    if (iVar2 < 0) {\n      iVar2 = 0;\n    }\n    sVar3 = strlen(param_1);\n    FUN_001074f0(param_1,sVar3);\n    do {\n      DAT_001271f8 = DAT_001271f8 + 1;\n      pcVar1 = stdout->_IO_write_ptr;\n      if (pcVar1 < stdout->_IO_write_end) {\n        stdout->_IO_write_ptr = pcVar1 + 1;\n        *pcVar1 = ' ';\n      }\n      else {\n        __overflow(stdout,0x20);\n      }\n      bVar4 = iVar2 != 0;\n      iVar2 = iVar2 + -1;\n    } while (bVar4);\n    return;\n  }\n  iVar2 = __printf_chk(1,\"%*lu \",param_3,param_2);\n  DAT_001271f8 = DAT_001271f8 + iVar2;\n  return;\n}\n\n",
  "FUN_001090d0": "\nvoid FUN_001090d0(char **param_1,char **param_2)\n\n{\n  int *piVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 = param_2[0x19];\n  if (pcVar3 == (char *)0x0) {\n    pcVar3 = (char *)FUN_00107e30(*param_2,DAT_001272d0,*(undefined4 *)((long)param_2 + 0xc4));\n  }\n  pcVar2 = param_1[0x19];\n  if (pcVar2 == (char *)0x0) {\n    pcVar2 = (char *)FUN_00107e30(*param_1,DAT_001272d0,*(undefined4 *)((long)param_1 + 0xc4));\n  }\n  if ((int)pcVar3 == (int)pcVar2) {\n    piVar1 = __errno_location();\n    pcVar3 = *param_2;\n    pcVar2 = *param_1;\n    *piVar1 = 0;\n    strcoll(pcVar3,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "strspn": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t strspn(char *__s,char *__accept)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_strspn_00125df8)();\n  return sVar1;\n}\n\n",
  "FUN_0010fde0": "\nundefined8 FUN_0010fde0(void **param_1)\n\n{\n  void *__size;\n  void *pvVar1;\n  undefined8 uVar2;\n  void *__dest;\n  int *piVar3;\n  void **__src;\n  \n  pvVar1 = param_1[1];\n  __src = (void **)*param_1;\n  __size = (void *)((long)pvVar1 * 2);\n  if (__src == param_1 + 2) {\n    __dest = malloc((size_t)__size);\n    if (__dest == (void *)0x0) {\n      return 0;\n    }\n    pvVar1 = memcpy(__dest,__src,(size_t)pvVar1);\nLAB_0010fe1c:\n    *param_1 = pvVar1;\n    uVar2 = 1;\n    param_1[1] = __size;\n  }\n  else {\n    if (__size < pvVar1) {\n      piVar3 = __errno_location();\n      *piVar3 = 0xc;\n    }\n    else {\n      pvVar1 = realloc(__src,(size_t)__size);\n      if (pvVar1 != (void *)0x0) goto LAB_0010fe1c;\n      __src = (void **)*param_1;\n    }\n    free(__src);\n    *param_1 = param_1 + 2;\n    uVar2 = 0;\n    param_1[1] = (void *)0x400;\n  }\n  return uVar2;\n}\n\n",
  "FUN_00104020": "\nvoid FUN_00104020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)PTR_00125c88)();\n  return;\n}\n\n",
  "FUN_001123c0": "\nchar * FUN_001123c0(ulong param_1,long param_2)\n\n{\n  bool bVar1;\n  char *pcVar2;\n  \n  *(undefined *)(param_2 + 0x14) = 0;\n  pcVar2 = (char *)(param_2 + 0x14);\n  do {\n    pcVar2 = pcVar2 + -1;\n    *pcVar2 = (char)param_1 + (char)(param_1 / 10) * -10 + '0';\n    bVar1 = 9 < param_1;\n    param_1 = param_1 / 10;\n  } while (bVar1);\n  return pcVar2;\n}\n\n",
  "FUN_00116a00": "\nvoid FUN_00116a00(int param_1,undefined8 param_2)\n\n{\n  long in_FS_OFFSET;\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 10) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  local_44 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  local_18 = 0;\n  local_48 = param_1;\n  FUN_00116340(0,param_2,0xffffffffffffffff,&local_48);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00107770": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00107770(char param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  int iVar3;\n  int *piVar4;\n  long in_FS_OFFSET;\n  undefined local_d8 [12];\n  undefined4 uStack_cc;\n  undefined4 uStack_c8;\n  undefined4 uStack_c4;\n  undefined4 local_c0;\n  undefined4 uStack_bc;\n  undefined4 uStack_b8;\n  undefined4 uStack_b4;\n  undefined4 local_b0;\n  undefined4 uStack_ac;\n  undefined4 uStack_a8;\n  undefined4 uStack_a4;\n  undefined4 local_a0;\n  undefined4 uStack_9c;\n  undefined4 uStack_98;\n  undefined4 uStack_94;\n  undefined4 local_90;\n  undefined4 uStack_8c;\n  undefined4 uStack_88;\n  undefined4 uStack_84;\n  undefined4 local_80;\n  undefined4 uStack_7c;\n  undefined4 uStack_78;\n  undefined4 uStack_74;\n  undefined4 local_70;\n  undefined4 uStack_6c;\n  undefined4 uStack_68;\n  undefined4 uStack_64;\n  undefined4 local_60;\n  undefined4 uStack_5c;\n  undefined4 uStack_58;\n  undefined4 uStack_54;\n  int local_50;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == '\\0') {\n    piVar2 = &DAT_0011a664;\n    iVar3 = 0x14;\n    while( true ) {\n      iVar1 = sigismember((sigset_t *)&DAT_00127220,iVar3);\n      if (iVar1 != 0) {\n        signal(iVar3,(__sighandler_t)0x0);\n      }\n      if (piVar2 == (int *)&DAT_0011a690) break;\n      iVar3 = *piVar2;\n      piVar2 = piVar2 + 1;\n    }\n  }\n  else {\n    piVar2 = &DAT_0011a664;\n    iVar3 = 0x14;\n    piVar4 = &DAT_0011a664;\n    sigemptyset((sigset_t *)&DAT_00127220);\n    while( true ) {\n      sigaction(iVar3,(sigaction *)0x0,(sigaction *)local_d8);\n      if ((__sighandler_t)local_d8._0_8_ != (__sighandler_t)0x1) {\n        sigaddset((sigset_t *)&DAT_00127220,iVar3);\n      }\n      if (piVar4 == (int *)&DAT_0011a690) break;\n      iVar3 = *piVar4;\n      piVar4 = piVar4 + 1;\n    }\n    local_50 = 0x10000000;\n    iVar3 = 0x14;\n    local_d8._8_4_ = _DAT_00127220;\n    uStack_cc = uRam0000000000127224;\n    uStack_c8 = uRam0000000000127228;\n    uStack_c4 = uRam000000000012722c;\n    local_c0 = _DAT_00127230;\n    uStack_bc = uRam0000000000127234;\n    uStack_b8 = uRam0000000000127238;\n    uStack_b4 = uRam000000000012723c;\n    local_b0 = _DAT_00127240;\n    uStack_ac = uRam0000000000127244;\n    uStack_a8 = uRam0000000000127248;\n    uStack_a4 = uRam000000000012724c;\n    local_a0 = _DAT_00127250;\n    uStack_9c = uRam0000000000127254;\n    uStack_98 = uRam0000000000127258;\n    uStack_94 = uRam000000000012725c;\n    local_90 = _DAT_00127260;\n    uStack_8c = uRam0000000000127264;\n    uStack_88 = uRam0000000000127268;\n    uStack_84 = uRam000000000012726c;\n    local_80 = _DAT_00127270;\n    uStack_7c = uRam0000000000127274;\n    uStack_78 = uRam0000000000127278;\n    uStack_74 = uRam000000000012727c;\n    local_70 = _DAT_00127280;\n    uStack_6c = uRam0000000000127284;\n    uStack_68 = uRam0000000000127288;\n    uStack_64 = uRam000000000012728c;\n    local_60 = _DAT_00127290;\n    uStack_5c = uRam0000000000127294;\n    uStack_58 = uRam0000000000127298;\n    uStack_54 = uRam000000000012729c;\n    while( true ) {\n      iVar1 = sigismember((sigset_t *)&DAT_00127220,iVar3);\n      if (iVar1 != 0) {\n        local_d8._0_8_ = FUN_00106940;\n        if (iVar3 == 0x14) {\n          local_d8._0_8_ = FUN_001075e0;\n        }\n        sigaction(iVar3,(sigaction *)local_d8,(sigaction *)0x0);\n      }\n      if (piVar2 == (int *)&DAT_0011a690) break;\n      iVar3 = *piVar2;\n      piVar2 = piVar2 + 1;\n    }\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00116b20": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00116b20(undefined8 param_1,undefined8 param_2,byte param_3)\n\n{\n  uint *puVar1;\n  uint uVar2;\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = _DAT_00127520;\n  uStack_40 = uRam0000000000127528;\n  local_18 = DAT_00127550;\n  local_38 = _DAT_00127530;\n  uStack_30 = uRam0000000000127538;\n  local_28 = _DAT_00127540;\n  uStack_20 = uRam0000000000127548;\n  puVar1 = (uint *)((long)&uStack_40 + (ulong)(param_3 >> 5) * 4);\n  uVar2 = *puVar1;\n  *puVar1 = (~(uVar2 >> (param_3 & 0x1f)) & 1) << (param_3 & 0x1f) ^ uVar2;\n  FUN_00116340(0,param_1,param_2,&local_48);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00117e50": "\nvoid FUN_00117e50(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(param_1);\n  if (pvVar1 != (void *)0x0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "setenv": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint setenv(char *__name,char *__value,int __replace)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_setenv_00125d48)();\n  return iVar1;\n}\n\n",
  "FUN_00117220": "\nint FUN_00117220(undefined8 param_1,char **param_2)\n\n{\n  char *__s1;\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  \n  iVar1 = fgetfilecon();\n  if (iVar1 == 0) {\n    piVar3 = __errno_location();\n    iVar1 = -1;\n    *piVar3 = 0x5f;\n  }\n  else if (iVar1 == 10) {\n    __s1 = *param_2;\n    iVar2 = strcmp(__s1,\"unlabeled\");\n    if (iVar2 == 0) {\n      iVar1 = -1;\n      freecon(__s1);\n      *param_2 = (char *)0x0;\n      piVar3 = __errno_location();\n      *piVar3 = 0x3d;\n    }\n  }\n  return iVar1;\n}\n\n",
  "strcoll": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcoll(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcoll_00125eb0)();\n  return iVar1;\n}\n\n",
  "FUN_00117100": "\nvoid FUN_00117100(undefined8 param_1)\n\n{\n  FUN_00116340(0,param_1,0xffffffffffffffff,&DAT_00126220);\n  return;\n}\n\n",
  "wcswidth": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint wcswidth(wchar_t *__s,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_wcswidth_00125d18)();\n  return iVar1;\n}\n\n",
  "FUN_00118310": "\nvoid FUN_00118310(void *param_1,size_t param_2)\n\n{\n  void *__dest;\n  \n  __dest = malloc(param_2 + 1);\n  if (__dest != (void *)0x0) {\n    *(undefined *)((long)__dest + param_2) = 0;\n    memcpy(__dest,param_1,param_2);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_00117f80": "\nvoid FUN_00117f80(long param_1,long param_2)\n\n{\n  long lVar1;\n  \n  if ((param_1 == 0) || (param_2 == 0)) {\n    param_1 = 1;\n    param_2 = 1;\n  }\n  lVar1 = reallocarray(0,param_1,param_2);\n  if (lVar1 == 0) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00118390();\n  }\n  return;\n}\n\n",
  "readdir": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\ndirent * readdir(DIR *__dirp)\n\n{\n  dirent *pdVar1;\n  \n  pdVar1 = (dirent *)(*(code *)PTR_readdir_00125e90)();\n  return pdVar1;\n}\n\n",
  "_ITM_deregisterTMCloneTable": "\n/* WARNING: Control flow encountered bad instruction data */\n\nvoid _ITM_deregisterTMCloneTable(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n  halt_baddata();\n}\n\n",
  "FUN_00107420": "\nchar * FUN_00107420(ulong param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  uint uVar2;\n  char *in_RAX;\n  char *pcVar3;\n  ulong uVar5;\n  char *pcVar4;\n  \n  if (param_2 <= param_1) {\n    return in_RAX;\n  }\n  do {\n    while( true ) {\n      uVar5 = DAT_001272c0;\n      uVar1 = param_1 + 1;\n      pcVar3 = stdout->_IO_write_ptr;\n      if ((DAT_001272c0 == 0) || (param_2 / DAT_001272c0 <= uVar1 / DAT_001272c0)) break;\n      if (pcVar3 < stdout->_IO_write_end) {\n        stdout->_IO_write_ptr = pcVar3 + 1;\n        *pcVar3 = '\\t';\n      }\n      else {\n        __overflow(stdout,9);\n        uVar5 = DAT_001272c0;\n      }\n      pcVar3 = (char *)(param_1 / uVar5);\n      param_1 = (uVar5 + param_1) - param_1 % uVar5;\n      if (param_2 <= param_1) {\n        return pcVar3;\n      }\n    }\n    if (pcVar3 < stdout->_IO_write_end) {\n      pcVar4 = pcVar3 + 1;\n      stdout->_IO_write_ptr = pcVar4;\n      *pcVar3 = ' ';\n    }\n    else {\n      uVar2 = __overflow(stdout,0x20);\n      pcVar4 = (char *)(ulong)uVar2;\n    }\n    param_1 = uVar1;\n  } while (uVar1 < param_2);\n  return pcVar4;\n}\n\n",
  "FUN_001111c0": "\nvoid FUN_001111c0(void **param_1)\n\n{\n  free(*param_1);\n  free(param_1);\n  return;\n}\n\n",
  "FUN_00104b60": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00104b60(void)\n\n{\n  (*_DAT_00125ee8)();\n  return;\n}\n\n",
  "FUN_00107e30": "\nlong FUN_00107e30(undefined *param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  long in_FS_OFFSET;\n  byte local_2039;\n  undefined *local_2038;\n  long local_2030;\n  undefined local_2028 [8200];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2038 = local_2028;\n  FUN_001079e0(&local_2038,param_1,param_2,param_3,&local_2030,&local_2039);\n  if ((local_2038 != local_2028) && (local_2038 != param_1)) {\n    free(local_2038);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return (ulong)local_2039 + local_2030;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00117350": "\nvoid FUN_00117350(int param_1)\n\n{\n  setlocale(param_1,(char *)0x0);\n  return;\n}\n\n",
  "getopt_long": "\nvoid getopt_long(void)\n\n{\n  (*(code *)PTR_getopt_long_00125d80)();\n  return;\n}\n\n",
  "sigprocmask": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigprocmask(int __how,sigset_t *__set,sigset_t *__oset)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigprocmask_00125ca8)();\n  return iVar1;\n}\n\n",
  "FUN_00107670": "\nbyte FUN_00107670(char param_1,uint param_2,int param_3)\n\n{\n  uint uVar1;\n  bool bVar2;\n  \n  if (param_1 == '\\0') {\n    if (param_3 == 5) {\n      return 0;\n    }\n    if ((param_3 == 3) || (param_3 == 9)) {\n      return 0x2f;\n    }\n    bVar2 = param_3 == 6;\n    if (DAT_00127314 == 1) {\n      return 0;\n    }\n  }\n  else {\n    uVar1 = param_2 & 0xf000;\n    if (uVar1 == 0x8000) {\n      if (DAT_00127314 != 3) {\n        return 0;\n      }\n      return -((param_2 & 0x49) != 0) & 0x2a;\n    }\n    if (uVar1 == 0x4000) {\n      return 0x2f;\n    }\n    bVar2 = uVar1 == 0xa000;\n    if (DAT_00127314 == 1) {\n      return 0;\n    }\n  }\n  if (bVar2) {\n    return 0x40;\n  }\n  if (param_1 == '\\0') {\n    if (param_3 == 1) {\n      return 0x7c;\n    }\n    bVar2 = param_3 == 7;\n  }\n  else {\n    if ((param_2 & 0xf000) == 0x1000) {\n      return 0x7c;\n    }\n    bVar2 = (param_2 & 0xf000) == 0xc000;\n  }\n  return -bVar2 & 0x3d;\n}\n\n",
  "FUN_00117e70": "\nvoid FUN_00117e70(void *param_1,size_t param_2)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = realloc(param_1,param_2);\n  if ((pvVar1 == (void *)0x0) && ((param_1 == (void *)0x0 || (param_2 != 0)))) {\n                    /* WARNING: Subroutine does not return */\n    FUN_00118390();\n  }\n  return;\n}\n\n",
  "FUN_00116c60": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00116c60(undefined8 param_1)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  undefined8 uStack_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = _DAT_00127520;\n  uStack_40._4_4_ = (uint)((ulong)uRam0000000000127528 >> 0x20);\n  local_18 = DAT_00127550;\n  local_38 = _DAT_00127530;\n  uStack_30 = uRam0000000000127538;\n  local_28 = _DAT_00127540;\n  uStack_20 = uRam0000000000127548;\n  uStack_40 = CONCAT44(~uStack_40._4_4_ & 0x4000000 ^ uStack_40._4_4_,(int)uRam0000000000127528);\n  FUN_00116340(0,param_1,0xffffffffffffffff,&local_48);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00116d80": "\nvoid FUN_00116d80(undefined8 param_1,int param_2,undefined8 param_3)\n\n{\n  long in_FS_OFFSET;\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 10) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  local_44 = 0;\n  local_40 = 0x400000000000000;\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  local_18 = 0;\n  local_48 = param_2;\n  FUN_00116340(param_1,param_3,0xffffffffffffffff,&local_48);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0010c640": "\nvoid FUN_0010c640(char param_1)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  byte *pbVar4;\n  ulong uVar5;\n  byte bVar6;\n  ulong uVar7;\n  ulong uVar8;\n  \n  if (DAT_001273b0 != 0) {\n    uVar7 = 0;\n    uVar8 = 0;\n    do {\n      uVar2 = *(undefined8 *)(DAT_001273a0 + uVar7 * 8);\n      if (DAT_001272b0 == 0) {\n        uVar5 = uVar8;\n        if (uVar7 != 0) {\n          uVar1 = uVar8 + 2;\nLAB_0010c6f0:\n          uVar5 = uVar1;\n          uVar8 = uVar8 + 2;\n          bVar6 = 0x20;\n          goto LAB_0010c6fa;\n        }\n      }\n      else {\n        uVar5 = FUN_00107ed0(uVar2);\n        if (uVar7 == 0) {\n          uVar5 = uVar8 + uVar5;\n        }\n        else {\n          uVar1 = uVar5 + uVar8 + 2;\n          if ((DAT_001272b0 == 0) || ((uVar1 < DAT_001272b0 && (uVar8 <= -uVar5 - 3))))\n          goto LAB_0010c6f0;\n          uVar8 = 0;\n          bVar6 = DAT_00126019;\nLAB_0010c6fa:\n          pcVar3 = stdout->_IO_write_ptr;\n          if (pcVar3 < stdout->_IO_write_end) {\n            stdout->_IO_write_ptr = pcVar3 + 1;\n            *pcVar3 = param_1;\n          }\n          else {\n            __overflow(stdout,(int)param_1);\n          }\n          pbVar4 = (byte *)stdout->_IO_write_ptr;\n          if (pbVar4 < stdout->_IO_write_end) {\n            stdout->_IO_write_ptr = (char *)(pbVar4 + 1);\n            *pbVar4 = bVar6;\n          }\n          else {\n            __overflow(stdout,(uint)bVar6);\n          }\n        }\n      }\n      uVar7 = uVar7 + 1;\n      FUN_0010c430(uVar2,uVar8);\n      uVar8 = uVar5;\n    } while (uVar7 < DAT_001273b0);\n  }\n  bVar6 = DAT_00126019;\n  pbVar4 = (byte *)stdout->_IO_write_ptr;\n  if (stdout->_IO_write_end <= pbVar4) {\n    __overflow(stdout,(uint)DAT_00126019);\n    return;\n  }\n  stdout->_IO_write_ptr = (char *)(pbVar4 + 1);\n  *pbVar4 = bVar6;\n  return;\n}\n\n",
  "FUN_001046a0": "\nvoid FUN_001046a0(void)\n\n{\n  (*(code *)PTR___cxa_finalize_00125fe8)();\n  return;\n}\n\n",
  "strrchr": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = (char *)(*(code *)PTR_strrchr_00125db8)();\n  return pcVar1;\n}\n\n",
  "FUN_0010a460": "\nulong FUN_0010a460(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010a4e0;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010a4e0:\n  uVar3 = FUN_00108ce0();\n  return uVar3;\n}\n\n",
  "FUN_0010fce0": "\nvoid FUN_0010fce0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_0010fb40(param_1,0xffffffffffffffff,param_2,0xffffffffffffffff);\n  return;\n}\n\n",
  "FUN_001168c0": "\nvoid FUN_001168c0(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00116340(0,param_1,param_2,&DAT_00127520);\n  return;\n}\n\n",
  "__sprintf_chk": "\nvoid __sprintf_chk(void)\n\n{\n  (*(code *)PTR___sprintf_chk_00125f98)();\n  return;\n}\n\n",
  "FUN_00117d50": "\nvoid FUN_00117d50(void)\n\n{\n  fputc_unlocked(10,stdout);\n  __printf_chk(1,\"Report bugs to: %s\\n\",\"bug-coreutils@gnu.org\");\n  __printf_chk(1,\"%s home page: <%s>\\n\",\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  __printf_chk(1,\"General help using GNU software: <%s>\\n\",\"https://www.gnu.org/gethelp/\");\n  return;\n}\n\n",
  "FUN_00118e40": "\nulong FUN_00118e40(undefined8 *param_1,code *param_2,long *param_3)\n\n{\n  ulong uVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  ulong uVar7;\n  ulong uVar8;\n  long lVar9;\n  int *piVar10;\n  ulong uVar11;\n  int iVar12;\n  ulong uVar13;\n  long lVar14;\n  int iVar15;\n  ulong uVar16;\n  int iVar17;\n  int iVar18;\n  int iVar19;\n  long in_FS_OFFSET;\n  bool bVar20;\n  bool bVar21;\n  ulong local_150;\n  int local_130;\n  ulong local_d0;\n  long local_c8;\n  ulong local_c0;\n  int local_b8;\n  undefined4 uStack_b4;\n  undefined4 uStack_b0;\n  undefined4 uStack_ac;\n  int local_a8;\n  int iStack_a4;\n  int iStack_a0;\n  int iStack_9c;\n  uint local_98;\n  int iStack_94;\n  int iStack_90;\n  int iStack_8c;\n  undefined8 local_88;\n  ulong local_78;\n  undefined4 local_70;\n  undefined4 local_64;\n  undefined4 local_5c;\n  int local_58;\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = *(int *)param_1;\n  iVar3 = *(int *)((long)param_1 + 4);\n  iVar4 = *(int *)(param_1 + 1);\n  uVar5 = *(uint *)(param_1 + 4);\n  iVar15 = *(int *)(param_1 + 2) % 0xc;\n  uVar6 = iVar15 >> 0x1f;\n  uVar1 = (long)(int)(*(int *)(param_1 + 2) / 0xc + uVar6) + (long)*(int *)((long)param_1 + 0x14);\n  uVar11 = 0;\n  if (((uVar1 & 3) == 0) &&\n     (uVar11 = 1,\n     (uVar1 * -0x70a3d70a3d70a3d7 + 0x51eb851eb851eb8 >> 2 | uVar1 * -0x70a3d70a3d70a3d7 << 0x3e) <\n     0x28f5c28f5c28f5d)) {\n    uVar11 = (ulong)(((uint)((long)uVar1 / 100) & 3) == 1);\n  }\n  lVar14 = (long)*(int *)((long)param_1 + 0xc) +\n           (long)(int)(*(ushort *)\n                        (&DAT_0011f240 + ((long)(int)((uVar6 & 0xc) + iVar15) + uVar11 * 0xd) * 2) -\n                      1);\n  uVar11 = 0x3b;\n  if (iVar2 < 0x3c) {\n    uVar11 = (long)iVar2;\n  }\n  if ((int)uVar11 < 0) {\n    uVar11 = 0;\n  }\n  iVar17 = (int)uVar11;\n  local_150._0_4_ = (int)*param_3;\n  iVar15 = -(int)local_150;\n  uVar8 = FUN_00118b40(uVar1,lVar14,iVar4,iVar3,uVar11 & 0xffffffff,0x46,0,0,0,iVar15);\n  local_130 = 6;\n  bVar20 = false;\n  uVar7 = uVar8;\n  local_150 = uVar8;\n  local_d0 = uVar8;\n  while( true ) {\n    uVar13 = uVar7;\n    lVar9 = FUN_00118c40(param_2,&local_d0,&local_b8);\n    iVar19 = local_b8;\n    if (lVar9 == 0) goto LAB_0011915b;\n    lVar9 = FUN_00118b40(uVar1,lVar14,iVar4,iVar3,uVar11 & 0xffffffff,iStack_a4,iStack_9c,uStack_b0,\n                         uStack_b4,local_b8);\n    uVar7 = local_d0;\n    uVar16 = local_d0;\n    if (lVar9 == 0) break;\n    if ((uVar13 != local_d0) && (local_150 == local_d0)) {\n      if ((int)local_98 < 0) goto LAB_001190a0;\n      if ((int)uVar5 < 0) {\n        if (bVar20 <= (local_98 != 0)) goto LAB_001190a0;\n      }\n      else if ((uVar5 != 0) != (local_98 != 0)) goto LAB_001190a0;\n    }\n    local_130 = local_130 + -1;\n    if (local_130 == 0) goto LAB_00119150;\n    bVar20 = local_98 != 0;\n    local_150 = uVar13;\n    local_d0 = lVar9 + local_d0;\n  }\n  bVar20 = uVar5 == 0;\n  bVar21 = local_98 == 0;\n  if ((bVar21 == bVar20) || ((int)(local_98 | uVar5) < 0)) goto LAB_001190a0;\n  iVar19 = 0x92c70;\n  do {\n    iVar18 = 2;\n    iVar12 = -iVar19;\n    while( true ) {\n      local_c8 = (long)iVar12 + uVar7;\n      if (!SCARRY8((long)iVar12,uVar7)) {\n        lVar9 = FUN_00118c40(param_2,&local_c8,&local_78);\n        if (lVar9 == 0) goto LAB_0011915b;\n        if ((bVar20 == (local_58 == 0)) || (local_58 < 0)) {\n          lVar9 = FUN_00118b40(uVar1,lVar14,iVar4,iVar3,iVar17,local_64,local_5c,local_70,\n                               local_78 >> 0x20,local_78 & 0xffffffff);\n          uVar16 = lVar9 + local_c8;\n          local_c0 = uVar16;\n          lVar9 = (*param_2)(&local_c0,&local_b8);\n          if (lVar9 != 0) {\n            uVar11 = (ulong)iVar17;\n            iVar19 = local_b8;\n            goto LAB_001190a0;\n          }\n          piVar10 = __errno_location();\n          if (*piVar10 != 0x4b) goto LAB_0011915b;\n        }\n      }\n      iVar12 = iVar12 + iVar19 * 2;\n      if (iVar18 == 1) break;\n      iVar18 = 1;\n    }\n    iVar19 = iVar19 + 0x92c70;\n  } while (iVar19 != 0xdb04f20);\n  uVar11 = (ulong)iVar17;\n  uVar16 = uVar7 + (long)(int)(((uint)bVar20 - (uint)bVar21) * 0xe10);\n  local_d0 = uVar16;\n  local_78 = uVar16;\n  lVar14 = (*param_2)(&local_78,&local_b8);\n  iVar19 = local_b8;\n  if (lVar14 == 0) {\nLAB_00119150:\n    piVar10 = __errno_location();\n    *piVar10 = 0x4b;\n  }\n  else {\nLAB_001190a0:\n    *param_3 = uVar16 - ((long)iVar15 + uVar8);\n    if (iVar2 == iVar19) {\nLAB_0011910f:\n      *param_1 = CONCAT44(uStack_b4,local_b8);\n      param_1[1] = CONCAT44(uStack_ac,uStack_b0);\n      param_1[6] = local_88;\n      *(int *)(param_1 + 2) = local_a8;\n      *(int *)((long)param_1 + 0x14) = iStack_a4;\n      *(int *)(param_1 + 3) = iStack_a0;\n      *(int *)((long)param_1 + 0x1c) = iStack_9c;\n      *(uint *)(param_1 + 4) = local_98;\n      *(int *)((long)param_1 + 0x24) = iStack_94;\n      *(int *)(param_1 + 5) = iStack_90;\n      *(int *)((long)param_1 + 0x2c) = iStack_8c;\n      goto LAB_00119162;\n    }\n    lVar14 = (long)iVar2 + ((iVar2 < 1 && iVar19 == 0x3c) - uVar11);\n    bVar20 = SCARRY8(lVar14,uVar16);\n    uVar16 = lVar14 + uVar16;\n    local_d0 = uVar16;\n    if (bVar20) goto LAB_00119150;\n    local_78 = uVar16;\n    lVar14 = (*param_2)(&local_78,&local_b8);\n    if (lVar14 != 0) goto LAB_0011910f;\n  }\nLAB_0011915b:\n  uVar16 = 0xffffffffffffffff;\nLAB_00119162:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar16;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00119780": "\nvoid FUN_00119780(undefined8 param_1)\n\n{\n  __cxa_atexit(param_1,0,PTR_LOOP_00126008);\n  return;\n}\n\n",
  "FUN_00119660": "\nulong FUN_00119660(char *param_1,ulong param_2)\n\n{\n  char cVar1;\n  ulong uVar2;\n  \n  cVar1 = *param_1;\n  if (cVar1 != '\\0') {\n    uVar2 = 0;\n    do {\n      param_1 = param_1 + 1;\n      uVar2 = (uVar2 << 9 | uVar2 >> 0x37) + (long)cVar1;\n      cVar1 = *param_1;\n    } while (cVar1 != '\\0');\n    return uVar2 % param_2;\n  }\n  return 0;\n}\n\n",
  "FUN_00117360": "\nundefined8 FUN_00117360(long *param_1)\n\n{\n  long *plVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  undefined8 uVar5;\n  \n  piVar3 = __errno_location();\n  iVar4 = *piVar3;\n  if (*(char *)(param_1 + 1) == '\\0') {\n    iVar2 = unsetenv(\"TZ\");\n  }\n  else {\n    iVar2 = setenv(\"TZ\",(char *)((long)param_1 + 9),1);\n  }\n  if (iVar2 == 0) {\n    tzset();\n    uVar5 = 1;\n  }\n  else {\n    iVar4 = *piVar3;\n    uVar5 = 0;\n  }\n  do {\n    plVar1 = (long *)*param_1;\n    free(param_1);\n    param_1 = plVar1;\n  } while (plVar1 != (long *)0x0);\n  *piVar3 = iVar4;\n  return uVar5;\n}\n\n",
  "__freading": "\nvoid __freading(void)\n\n{\n  (*(code *)PTR___freading_00125eb8)();\n  return;\n}\n\n",
  "iswcntrl": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint iswcntrl(wint_t __wc)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_iswcntrl_00125d08)();\n  return iVar1;\n}\n\n",
  "fputs_unlocked": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint fputs_unlocked(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_fputs_unlocked_00125e18)();\n  return iVar1;\n}\n\n",
  "isatty": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_isatty_00125cf8)();\n  return iVar1;\n}\n\n",
  "FUN_00117120": "\nint FUN_00117120(undefined8 param_1,char **param_2)\n\n{\n  char *__s1;\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  \n  iVar1 = getfilecon();\n  if (iVar1 == 0) {\n    piVar3 = __errno_location();\n    iVar1 = -1;\n    *piVar3 = 0x5f;\n  }\n  else if (iVar1 == 10) {\n    __s1 = *param_2;\n    iVar2 = strcmp(__s1,\"unlabeled\");\n    if (iVar2 == 0) {\n      iVar1 = -1;\n      freecon(__s1);\n      *param_2 = (char *)0x0;\n      piVar3 = __errno_location();\n      *piVar3 = 0x3d;\n    }\n  }\n  return iVar1;\n}\n\n",
  "_INIT_0": "\nvoid _INIT_0(void)\n\n{\n  FUN_00106880();\n  return;\n}\n\n",
  "FUN_00119420": "\nint FUN_00119420(long param_1,long param_2)\n\n{\n  uint uVar1;\n  byte bVar2;\n  long lVar3;\n  uint uVar4;\n  \n  if (param_1 == param_2) {\n    return 0;\n  }\n  lVar3 = 0;\n  do {\n    uVar1 = (uint)*(byte *)(param_1 + lVar3);\n    bVar2 = *(byte *)(param_2 + lVar3);\n    uVar4 = (uint)bVar2;\n    if (uVar1 - 0x41 < 0x1a) {\n      uVar1 = uVar1 + 0x20;\n      if (uVar4 - 0x41 < 0x1a) goto LAB_0011943d;\n    }\n    else {\n      if (uVar4 - 0x41 < 0x1a) {\nLAB_0011943d:\n        uVar4 = uVar4 + 0x20;\n        bVar2 = bVar2 + 0x20;\n      }\n      if (uVar1 == 0) break;\n    }\n    lVar3 = lVar3 + 1;\n  } while ((byte)uVar1 == bVar2);\n  return uVar1 - uVar4;\n}\n\n",
  "FUN_00108890": "\nvoid FUN_00108890(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  int *piVar3;\n  \n  pcVar1 = param_1[9];\n  pcVar2 = param_2[9];\n  if ((long)pcVar2 < (long)pcVar1 == (param_2[9] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) {\n    pcVar1 = *param_2;\n    pcVar2 = *param_1;\n    piVar3 = __errno_location();\n    *piVar3 = 0;\n    strcoll(pcVar1,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00109620": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 FUN_00109620(byte *param_1,uint param_2,uint param_3,char *param_4)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  undefined8 *puVar3;\n  int iVar4;\n  undefined uVar5;\n  char cVar6;\n  char cVar7;\n  undefined4 uVar8;\n  int iVar9;\n  uint uVar10;\n  undefined8 uVar11;\n  byte *pbVar12;\n  char *pcVar13;\n  size_t sVar14;\n  int *piVar15;\n  undefined8 uVar16;\n  long lVar17;\n  size_t sVar18;\n  ulong uVar19;\n  undefined *puVar20;\n  undefined *puVar21;\n  undefined *puVar22;\n  undefined *puVar23;\n  byte bVar24;\n  undefined8 *puVar25;\n  byte bVar26;\n  byte *pbVar27;\n  byte *pbVar28;\n  long in_FS_OFFSET;\n  bool bVar29;\n  byte bVar30;\n  undefined auStack_398 [6];\n  char local_392;\n  byte local_391;\n  undefined4 local_390;\n  uint local_38c;\n  undefined local_388 [24];\n  undefined4 local_370;\n  undefined local_2f8 [32];\n  byte local_2d8 [664];\n  long local_40;\n  \n  bVar30 = 0;\n  puVar23 = auStack_398;\n  puVar22 = auStack_398;\n  puVar20 = auStack_398;\n  puVar21 = auStack_398;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_38c = param_3;\n  if (DAT_001273b0 == _DAT_001273b8) {\n    DAT_001273c0 = FUN_00117ed0(DAT_001273c0,DAT_001273b0,0x1a0);\n    _DAT_001273b8 = _DAT_001273b8 << 1;\n  }\n  puVar3 = (undefined8 *)(DAT_001273c0 + DAT_001273b0 * 0xd0);\n  *puVar3 = 0;\n  puVar3[0x19] = 0;\n  puVar25 = (undefined8 *)((ulong)(puVar3 + 1) & 0xfffffffffffffff8);\n  for (uVar19 = (ulong)(((int)puVar3 - (int)(undefined8 *)((ulong)(puVar3 + 1) & 0xfffffffffffffff8)\n                        ) + 0xd0U >> 3); uVar19 != 0; uVar19 = uVar19 - 1) {\n    *puVar25 = 0;\n    puVar25 = puVar25 + (ulong)bVar30 * -2 + 1;\n  }\n  *(uint *)(puVar3 + 0x15) = param_2;\n  *(undefined4 *)((long)puVar3 + 0xc4) = 0xffffffff;\n  if ((DAT_001273a9 == '\\0') && (DAT_001273a8 != '\\0')) {\n    sVar14 = FUN_00116650(local_2d8,2,param_1,0xffffffffffffffff,DAT_001272d0);\n    if ((*param_1 == local_2d8[0]) && (sVar18 = strlen((char *)param_1), sVar14 == sVar18)) {\n      *(undefined4 *)((long)puVar3 + 0xc4) = 0;\n    }\n    else {\n      *(undefined4 *)((long)puVar3 + 0xc4) = 1;\n      DAT_001273a9 = '\\x01';\n    }\n  }\n  pbVar27 = param_1;\n  if ((char)local_38c == '\\0') {\n    if (DAT_00127311 != '\\0') {\n      if ((*param_1 != 0x2f) &&\n         (cVar6 = *param_4, puVar23 = auStack_398, bVar30 = *param_1, cVar7 = DAT_00127311,\n         cVar6 != '\\0')) goto LAB_00109941;\n      goto LAB_00109d6e;\n    }\n    cVar7 = DAT_00127311;\n    if ((DAT_001272a1 != '\\0') ||\n       (((param_2 == 3 && (DAT_00127312 != '\\0')) &&\n        ((cVar6 = FUN_00106d60(0x13), cVar6 != '\\0' ||\n         ((cVar6 = FUN_00106d60(0x12), cVar6 != '\\0' || (cVar6 = FUN_00106d60(0x14), cVar6 != '\\0'))\n         )))))) goto LAB_00109920;\n    if (DAT_001272fc != '\\0') {\n      if ((0x41UL >> ((ulong)param_2 & 0x3f) & 1) == 0) {\nLAB_00109920:\n        bVar30 = *param_1;\n        puVar22 = auStack_398;\n        if (bVar30 != 0x2f) {\nLAB_00109931:\n          cVar6 = *param_4;\n          puVar22 = auStack_398;\n          if (cVar6 != '\\0') goto LAB_00109941;\n        }\n        goto LAB_00109709;\n      }\nLAB_0010987f:\n      if (DAT_001272f8 != 4) {\n        if (((DAT_00127390 == '\\0') && (DAT_001272fd == '\\0')) && (DAT_001272fc == '\\0'))\n        goto LAB_001098a6;\n        goto LAB_00109920;\n      }\n      bVar30 = *param_1;\n      if (bVar30 != 0x2f) goto LAB_00109931;\n      uVar8 = FUN_00106be0();\n      goto LAB_00109b2a;\n    }\n    if (DAT_001272a0 == '\\0') {\nLAB_0010a228:\n      uVar16 = 0;\n    }\n    else {\n      if ((0x41UL >> ((ulong)param_2 & 0x3f) & 1) != 0) goto LAB_0010987f;\nLAB_001098a6:\n      if (DAT_001272a0 == '\\0') goto LAB_0010a228;\n      if ((param_2 == 0) ||\n         ((uVar16 = 0, puVar20 = auStack_398, param_2 == 5 &&\n          ((DAT_00127314 == 3 ||\n           ((puVar20 = auStack_398, DAT_00127312 != '\\0' &&\n            (((cVar6 = FUN_00106d60(0xe), cVar6 != '\\0' ||\n              (cVar6 = FUN_00106d60(0x10), cVar6 != '\\0')) ||\n             ((cVar6 = FUN_00106d60(0x11), cVar6 != '\\0' ||\n              (cVar6 = FUN_00106d60(0x15), puVar20 = auStack_398, cVar6 != '\\0'))))))))))))\n      goto LAB_00109920;\n    }\n  }\n  else {\n    puVar20 = auStack_398;\n    cVar7 = DAT_00127311;\n    if ((*param_1 != 0x2f) &&\n       (cVar6 = *param_4, puVar20 = auStack_398, bVar30 = *param_1, cVar6 != '\\0')) {\nLAB_00109941:\n      local_392 = cVar7;\n      local_391 = bVar30;\n      local_390 = CONCAT31(local_390._1_3_,cVar6);\n      sVar14 = strlen((char *)param_1);\n      sVar18 = strlen(param_4);\n      bVar30 = local_391;\n      cVar7 = local_392;\n      uVar19 = sVar14 + 0x19 + sVar18;\n      bVar26 = (byte)local_390;\n      for (; puVar21 != auStack_398 + -(uVar19 & 0xfffffffffffff000); puVar21 = puVar21 + -0x1000) {\n        *(undefined8 *)(puVar21 + -8) = *(undefined8 *)(puVar21 + -8);\n      }\n      uVar19 = (ulong)((uint)uVar19 & 0xff0);\n      lVar17 = -uVar19;\n      puVar20 = puVar21 + lVar17;\n      if (uVar19 != 0) {\n        *(undefined8 *)(puVar21 + -8) = *(undefined8 *)(puVar21 + -8);\n      }\n      bVar24 = param_4[1];\n      pbVar27 = (byte *)((ulong)(puVar21 + lVar17 + 0xf) & 0xfffffffffffffff0);\n      pcVar13 = param_4;\n      pbVar28 = pbVar27;\n      pbVar12 = param_1;\n      if ((bVar26 != 0x2e) || (pbVar2 = pbVar27, bVar24 != 0)) {\n        while( true ) {\n          pbVar2 = pbVar28 + 1;\n          *pbVar28 = bVar26;\n          if (bVar24 == 0) break;\n          pbVar1 = (byte *)(pcVar13 + 2);\n          pcVar13 = pcVar13 + 1;\n          pbVar28 = pbVar2;\n          bVar26 = bVar24;\n          bVar24 = *pbVar1;\n        }\n        if ((param_4 < pcVar13 + 1) && (*pcVar13 != '/')) {\n          *pbVar2 = 0x2f;\n          pbVar2 = pbVar28 + 2;\n        }\n      }\n      while (bVar30 != 0) {\n        *pbVar2 = bVar30;\n        bVar30 = pbVar12[1];\n        pbVar2 = pbVar2 + 1;\n        pbVar12 = pbVar12 + 1;\n      }\n      *pbVar2 = 0;\n    }\n    puVar22 = puVar20;\n    puVar23 = puVar20;\n    if (cVar7 != '\\0') {\nLAB_00109d6e:\n      *(undefined8 *)(puVar23 + -8) = 0x109d7b;\n      lVar17 = FUN_0010eae0(pbVar27,2);\n      puVar3[2] = lVar17;\n      puVar22 = puVar23;\n      if (lVar17 == 0) {\n        uVar5 = (char)local_38c;\n        *(undefined8 *)(puVar23 + -8) = 0x109da0;\n        FUN_00107600(uVar5,\"error canonicalizing %s\",pbVar27);\n      }\n    }\nLAB_00109709:\n    *(undefined8 *)(puVar22 + -8) = 0x109719;\n    uVar10 = DAT_001272f8;\n    uVar8 = FUN_00106be0();\n    if (uVar10 < 4) {\n      if ((uVar10 < 2) || ((char)local_38c == '\\0')) {\nLAB_0010972d:\n        *(undefined8 *)(puVar22 + -8) = 0x109732;\n        uVar8 = FUN_00106be0();\n        *(undefined8 *)(puVar22 + -8) = 0x10974a;\n        iVar9 = FUN_00107110(0xffffff9c,pbVar27,puVar3 + 3,0x100,uVar8);\n        cVar6 = '\\0';\n        puVar20 = puVar22;\n        uVar10 = local_38c;\n        goto joined_r0x00109b46;\n      }\n      local_390 = uVar10;\n      *(undefined8 *)(puVar22 + -8) = 0x109d09;\n      iVar9 = FUN_00107110(0xffffff9c,pbVar27,puVar3 + 3,0,uVar8);\n      if (local_390 != 2) {\n        if (-1 < iVar9) {\n          if ((*(uint *)(puVar3 + 6) & 0xf000) != 0x4000) goto LAB_0010972d;\n          goto LAB_00109d33;\n        }\n        *(undefined8 *)(puVar22 + -8) = 0x10a1dd;\n        piVar15 = __errno_location();\n        if ((*piVar15 == 2) || (*piVar15 == 0x28)) goto LAB_0010972d;\nLAB_0010a1f8:\n        uVar16 = 0;\n        *(undefined8 *)(puVar22 + -8) = 0x10a20f;\n        FUN_00107600(1,\"cannot access %s\",pbVar27);\n        puVar3[0x16] = &DAT_0012602a;\n        goto LAB_0010980c;\n      }\nLAB_00109d33:\n      if (iVar9 != 0) goto LAB_0010a1f8;\n      cVar6 = (char)local_38c;\n    }\n    else {\n      if (uVar10 != 4) goto LAB_0010972d;\nLAB_00109b2a:\n      *(undefined8 *)(puVar22 + -8) = 0x109b3f;\n      iVar9 = FUN_00107110(0xffffff9c,pbVar27,puVar3 + 3,0,uVar8);\n      cVar6 = '\\x01';\n      puVar20 = puVar22;\n      uVar10 = local_38c;\njoined_r0x00109b46:\n      puVar22 = puVar20;\n      local_38c = uVar10;\n      if (iVar9 != 0) {\n        uVar16 = 0;\n        *(undefined8 *)(puVar20 + -8) = 0x109b69;\n        FUN_00107600(uVar10 & 0xff,\"cannot access %s\",pbVar27);\n        puVar3[0x16] = &DAT_0012602a;\n        if ((char)uVar10 != '\\0') goto LAB_0010980c;\n        goto LAB_001097f9;\n      }\n    }\n    *(undefined *)(puVar3 + 0x17) = 1;\n    if (((param_2 == 5) || ((*(uint *)(puVar3 + 6) & 0xf000) == 0x8000)) && (DAT_00127312 != '\\0'))\n    {\n      local_390 = CONCAT31(local_390._1_3_,cVar6);\n      *(undefined8 *)(puVar22 + -8) = 0x109c95;\n      cVar7 = FUN_00106d60(0x15);\n      cVar6 = (byte)local_390;\n      if (cVar7 != '\\0') {\n        *(undefined8 *)(puVar22 + -8) = 0x109ca9;\n        piVar15 = __errno_location();\n        lVar17 = puVar3[3];\n        bVar29 = lVar17 != _DAT_001262f8;\n        *piVar15 = 0x5f;\n        if (bVar29) {\n          _DAT_001262f8 = lVar17;\n        }\n        *(undefined *)(puVar3 + 0x18) = 0;\n        cVar6 = (byte)local_390;\n      }\n    }\n    if ((DAT_00127338 == 0) || (DAT_00127365 != '\\0')) {\n      if (puVar3[3] == DAT_001262f0) {\n        *(undefined8 *)(puVar22 + -8) = 0x10a433;\n        piVar15 = __errno_location();\n        *piVar15 = 0x5f;\n        puVar3[0x16] = &DAT_0012602a;\nLAB_00109e32:\n        if (DAT_00127338 == 0) {\n          local_391 = 0;\n          if (DAT_001262e8 == puVar3[3]) {\n            *piVar15 = 0x5f;\nLAB_0010a3b7:\n            *(undefined4 *)((long)puVar3 + 0xbc) = 0;\n          }\n          else {\nLAB_00109f7e:\n            *piVar15 = 0;\n            *(undefined8 *)(puVar22 + -8) = 0x109f91;\n            iVar9 = FUN_0010f420(pbVar27,puVar3 + 3);\n            if (iVar9 < 1) {\n              if (((*piVar15 - 0x16U & 0xffffffef) == 0) || (*piVar15 == 0x5f)) {\n                DAT_001262e8 = puVar3[3];\n              }\n              if (local_391 != 0) {\n                DAT_00127364 = local_391;\n              }\n              *(uint *)((long)puVar3 + 0xbc) = local_391 & 1;\n              if (iVar9 < 0) {\n                *(undefined8 *)(puVar22 + -8) = 0x10a27e;\n                piVar15 = __errno_location();\n                goto LAB_0010a15a;\n              }\n            }\n            else {\n              *(undefined4 *)((long)puVar3 + 0xbc) = 2;\n              DAT_00127364 = 1;\n            }\n          }\n        }\n        else {\nLAB_00109e42:\n          *(undefined4 *)((long)puVar3 + 0xbc) = 0;\n        }\n      }\n      else if (cVar6 == '\\0') {\n        *(undefined8 *)(puVar22 + -8) = 0x109de5;\n        iVar9 = FUN_001171a0(pbVar27,puVar3 + 0x16);\n        if (iVar9 < 0) goto LAB_00109ded;\nLAB_00109bb8:\n        pcVar13 = (char *)puVar3[0x16];\n        *(undefined8 *)(puVar22 + -8) = 0x109bcb;\n        uVar10 = strcmp(\"unlabeled\",pcVar13);\n        if (DAT_00127338 != 0) {\n          if (uVar10 == 0) goto LAB_00109e42;\n          uVar10 = *(uint *)(puVar3 + 6);\n          DAT_00127364 = 1;\n          *(undefined4 *)((long)puVar3 + 0xbc) = 1;\n          goto joined_r0x00109c01;\n        }\n        local_391 = uVar10 != 0;\n        local_390 = uVar10;\n        *(undefined8 *)(puVar22 + -8) = 0x109f64;\n        piVar15 = __errno_location();\n        if (puVar3[3] != DAT_001262e8) goto LAB_00109f7e;\n        *piVar15 = 0x5f;\n        if (local_390 == 0) goto LAB_0010a3b7;\n        *(undefined4 *)((long)puVar3 + 0xbc) = 1;\n        DAT_00127364 = 1;\n      }\n      else {\n        *(undefined8 *)(puVar22 + -8) = 0x109bb0;\n        iVar9 = FUN_00117120();\n        if (-1 < iVar9) goto LAB_00109bb8;\nLAB_00109ded:\n        *(undefined8 *)(puVar22 + -8) = 0x109df2;\n        piVar15 = __errno_location();\n        iVar9 = *piVar15;\n        if (((iVar9 - 0x16U & 0xffffffef) == 0) || (iVar9 == 0x5f)) {\n          DAT_001262f0 = puVar3[3];\n        }\n        puVar3[0x16] = &DAT_0012602a;\n        if (iVar9 == 0x3d || iVar9 == 0x5f) goto LAB_00109e32;\n        *(undefined4 *)((long)puVar3 + 0xbc) = 0;\nLAB_0010a15a:\n        *(undefined8 *)(puVar22 + -8) = 0x10a169;\n        uVar16 = FUN_00116d80(0,3,pbVar27);\n        iVar9 = *piVar15;\n        *(undefined8 *)(puVar22 + -8) = 0x10a180;\n        error(0,iVar9,&DAT_0011e5db,uVar16);\n      }\n      uVar10 = *(uint *)(puVar3 + 6) & 0xf000;\n      if (uVar10 != 0xa000) goto LAB_001097a8;\n      if (DAT_00127338 != 0) goto LAB_00109c07;\nLAB_00109c10:\n      uVar16 = puVar3[9];\n      *(undefined8 *)(puVar22 + -8) = 0x109c1c;\n      pbVar12 = (byte *)FUN_0010e3d0(pbVar27,uVar16);\n      puVar3[1] = pbVar12;\n      if (pbVar12 == (byte *)0x0) {\n        uVar5 = (char)local_38c;\n        *(undefined8 *)(puVar22 + -8) = 0x10a2a6;\n        FUN_00107600(uVar5,\"cannot read symbolic link %s\",pbVar27);\n        pbVar12 = (byte *)puVar3[1];\n        if (pbVar12 != (byte *)0x0) goto LAB_00109c2c;\n      }\n      else {\nLAB_00109c2c:\n        if (*(int *)((long)puVar3 + 0xc4) == 0) {\n          *(undefined8 *)(puVar22 + -8) = 0x10a362;\n          sVar14 = FUN_00116650(local_2d8,2,pbVar12,0xffffffffffffffff,DAT_001272d0);\n          if (*pbVar12 == local_2d8[0]) {\n            *(undefined8 *)(puVar22 + -8) = 0x10a420;\n            sVar18 = strlen((char *)pbVar12);\n            if (sVar14 != sVar18) goto LAB_0010a376;\n          }\n          else {\nLAB_0010a376:\n            *(undefined4 *)((long)puVar3 + 0xc4) = 0xffffffff;\n          }\n          if (puVar3[1] == 0) goto LAB_00109c54;\n        }\n        if ((1 < DAT_00127314) || (DAT_001272fd != '\\0')) {\n          *(undefined8 *)(puVar22 + -8) = 0x10a05c;\n          iVar9 = FUN_00107110(0xffffff9c,pbVar27,local_388,0,2);\n          if (iVar9 == 0) {\n            *(undefined *)((long)puVar3 + 0xb9) = 1;\n            *(undefined4 *)((long)puVar3 + 0xac) = local_370;\n          }\n        }\n      }\nLAB_00109c54:\n      uVar10 = *(uint *)(puVar3 + 6) & 0xf000;\n      if (uVar10 != 0xa000) goto LAB_001097a8;\nLAB_00109c67:\n      iVar9 = 6;\n    }\n    else {\n      uVar10 = *(uint *)(puVar3 + 6);\njoined_r0x00109c01:\n      uVar10 = uVar10 & 0xf000;\n      if (uVar10 == 0xa000) {\nLAB_00109c07:\n        if (DAT_001272fd != '\\0') goto LAB_00109c10;\n        goto LAB_00109c67;\n      }\nLAB_001097a8:\n      iVar9 = 5;\n      if (uVar10 == 0x4000) {\n        iVar9 = 3;\n        if ((char)local_38c != '\\0') {\n          iVar9 = (-(uint)(DAT_001272f5 == '\\0') & 6) + 3;\n        }\n      }\n    }\n    iVar4 = DAT_00127338;\n    uVar16 = puVar3[0xb];\n    *(int *)(puVar3 + 0x15) = iVar9;\n    if ((iVar4 == 0) || (DAT_0012732c != '\\0')) {\n      *(undefined8 *)(puVar22 + -8) = 0x1099d9;\n      uVar11 = FUN_001111e0(uVar16,local_2d8,DAT_00127328,0x200,DAT_00127320);\n      *(undefined8 *)(puVar22 + -8) = 0x1099e3;\n      iVar9 = FUN_00112b20(uVar11,0);\n      if (DAT_0012735c < iVar9) {\n        DAT_0012735c = iVar9;\n      }\n      if (DAT_00127338 != 0) goto LAB_001097dd;\n      if (DAT_00126029 != '\\0') {\n        uVar8 = *(undefined4 *)((long)puVar3 + 0x34);\n        *(undefined8 *)(puVar22 + -8) = 0x10a0c8;\n        iVar9 = FUN_00108690(uVar8);\n        if (DAT_00127350 < iVar9) {\n          DAT_00127350 = iVar9;\n        }\n      }\n      if (DAT_00126028 != '\\0') {\n        uVar8 = *(undefined4 *)(puVar3 + 7);\n        if (DAT_0012732d == '\\0') {\n          *(undefined8 *)(puVar22 + -8) = 0x10a318;\n          lVar17 = FUN_00112170(uVar8);\n          if (lVar17 == 0) goto LAB_0010a111;\n          *(undefined8 *)(puVar22 + -8) = 0x10a32b;\n          iVar9 = FUN_00112b20(lVar17,0);\n          if (iVar9 < 0) {\n            iVar9 = 0;\n          }\n        }\n        else {\nLAB_0010a111:\n          *(undefined8 *)(puVar22 + -8) = 0x10a132;\n          iVar9 = __snprintf_chk(0,0,1,0xffffffffffffffff,&DAT_0011bd3e,uVar8);\n        }\n        if (DAT_0012734c < iVar9) {\n          DAT_0012734c = iVar9;\n        }\n      }\n      if (DAT_0012732e != '\\0') {\n        uVar8 = *(undefined4 *)((long)puVar3 + 0x34);\n        *(undefined8 *)(puVar22 + -8) = 0x10a0e8;\n        iVar9 = FUN_00108690(uVar8);\n        if (DAT_00127348 < iVar9) {\n          DAT_00127348 = iVar9;\n        }\n      }\n      if (DAT_00127365 != '\\0') goto LAB_00109a2f;\nLAB_00109a47:\n      if (DAT_00127338 == 0) {\n        uVar11 = puVar3[5];\n        *(undefined8 *)(puVar22 + -8) = 0x109a65;\n        pcVar13 = (char *)FUN_001123c0(uVar11,local_2f8);\n        *(undefined8 *)(puVar22 + -8) = 0x109a6d;\n        sVar14 = strlen(pcVar13);\n        if (DAT_00127358 < (int)sVar14) {\n          DAT_00127358 = (int)sVar14;\n        }\n        if ((*(uint *)(puVar3 + 6) & 0xb000) == 0x2000) {\n          uVar11 = puVar3[8];\n          *(undefined8 *)(puVar22 + -8) = 0x109ab9;\n          pcVar13 = (char *)FUN_001123c0((uint)((ulong)uVar11 >> 0x20) & 0xfffff000 |\n                                         (uint)((ulong)uVar11 >> 8) & 0xfff,local_2d8);\n          *(undefined8 *)(puVar22 + -8) = 0x109ac1;\n          sVar14 = strlen(pcVar13);\n          if (DAT_00127344 < (int)sVar14) {\n            DAT_00127344 = (int)sVar14;\n          }\n          uVar19 = puVar3[8];\n          *(undefined8 *)(puVar22 + -8) = 0x109ae8;\n          pcVar13 = (char *)FUN_001123c0((uint)((uVar19 >> 0x14) << 8) | (uint)uVar19 & 0xff,\n                                         local_2d8);\n          *(undefined8 *)(puVar22 + -8) = 0x109af0;\n          sVar14 = strlen(pcVar13);\n          if (DAT_00127340 < (int)sVar14) {\n            DAT_00127340 = (int)sVar14;\n          }\n          iVar9 = DAT_00127340 + 2 + DAT_00127344;\n          if (DAT_0012733c < iVar9) {\nLAB_00109f38:\n            DAT_0012733c = iVar9;\n          }\n        }\n        else {\n          uVar11 = puVar3[9];\n          *(undefined8 *)(puVar22 + -8) = 0x109f22;\n          uVar11 = FUN_001111e0(uVar11,local_2d8,DAT_0012731c,1,DAT_00126020);\n          *(undefined8 *)(puVar22 + -8) = 0x109f2c;\n          iVar9 = FUN_00112b20(uVar11,0);\n          if (DAT_0012733c < iVar9) goto LAB_00109f38;\n        }\n      }\n    }\n    else {\nLAB_001097dd:\n      if (DAT_00127365 != '\\0') {\nLAB_00109a2f:\n        pcVar13 = (char *)puVar3[0x16];\n        *(undefined8 *)(puVar22 + -8) = 0x109a3b;\n        sVar14 = strlen(pcVar13);\n        if (DAT_00127354 < (int)sVar14) {\n          DAT_00127354 = (int)sVar14;\n        }\n        goto LAB_00109a47;\n      }\n    }\n    puVar20 = puVar22;\n    if (DAT_001272fc != '\\0') {\n      uVar11 = puVar3[4];\n      *(undefined8 *)(puVar22 + -8) = 0x109db8;\n      pcVar13 = (char *)FUN_001123c0(uVar11,local_2d8);\n      *(undefined8 *)(puVar22 + -8) = 0x109dc0;\n      sVar14 = strlen(pcVar13);\n      if (DAT_00127360 < (int)sVar14) {\n        DAT_00127360 = (int)sVar14;\n      }\n    }\n  }\nLAB_001097f9:\n  *(undefined8 *)(puVar20 + -8) = 0x109801;\n  uVar11 = FUN_00118350(param_1);\n  DAT_001273b0 = DAT_001273b0 + 1;\n  *puVar3 = uVar11;\n  puVar22 = puVar20;\nLAB_0010980c:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar16;\n  }\n                    /* WARNING: Subroutine does not return */\n  *(undefined **)(puVar22 + -8) = &UNK_0010a454;\n  __stack_chk_fail();\n}\n\n",
  "freecon": "\nvoid freecon(void)\n\n{\n  (*(code *)PTR_freecon_00125d90)();\n  return;\n}\n\n",
  "FUN_00110840": "\nulong FUN_00110840(byte *param_1,ulong param_2)\n\n{\n  byte bVar1;\n  ulong uVar2;\n  \n  uVar2 = 0;\n  bVar1 = *param_1;\n  while (bVar1 != 0) {\n    param_1 = param_1 + 1;\n    uVar2 = (uVar2 * 0x1f + (ulong)bVar1) % param_2;\n    bVar1 = *param_1;\n  }\n  return uVar2;\n}\n\n",
  "FUN_001100f0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nulong FUN_001100f0(ulong param_1,long param_2)\n\n{\n  undefined auVar1 [16];\n  int *piVar2;\n  ulong uVar3;\n  ulong uVar4;\n  long lVar5;\n  ulong uVar6;\n  float fVar7;\n  \n  if (*(char *)(param_2 + 0x10) == '\\0') {\n    if ((long)param_1 < 0) {\n      fVar7 = (float)(param_1 >> 1 | (ulong)((uint)param_1 & 1));\n      fVar7 = fVar7 + fVar7;\n    }\n    else {\n      fVar7 = (float)param_1;\n    }\n    fVar7 = fVar7 / *(float *)(param_2 + 8);\n    if (_DAT_0011e694 <= fVar7) goto LAB_001101dc;\n    if (fVar7 < _DAT_0011e698) {\n      param_1 = (ulong)fVar7;\n    }\n    else {\n      param_1 = (long)(fVar7 - _DAT_0011e698) ^ 0x8000000000000000;\n    }\n  }\n  uVar6 = 10;\n  if (9 < param_1) {\n    uVar6 = param_1;\n  }\n  for (uVar6 = uVar6 | 1; uVar6 != 0xffffffffffffffff; uVar6 = uVar6 + 2) {\n    auVar1._8_8_ = 0;\n    auVar1._0_8_ = uVar6;\n    if (uVar6 < 10) {\n      uVar3 = 3;\nLAB_001101c5:\n      if (uVar6 % uVar3 != 0) {\n        if (((uVar6 >> 0x3c & 1) == 0) && (uVar6 >> 0x3d == 0)) {\n          return uVar6;\n        }\n        break;\n      }\n    }\n    else if (uVar6 != (SUB168(auVar1 * ZEXT816(0xaaaaaaaaaaaaaaab),8) & 0xfffffffffffffffe) +\n                      uVar6 / 3) {\n      lVar5 = 0x10;\n      uVar4 = 9;\n      uVar3 = 3;\n      do {\n        uVar3 = uVar3 + 2;\n        uVar4 = uVar4 + lVar5;\n        if (uVar6 <= uVar4) goto LAB_001101c5;\n        lVar5 = lVar5 + 8;\n      } while (uVar6 % uVar3 != 0);\n    }\n  }\nLAB_001101dc:\n  piVar2 = __errno_location();\n  *piVar2 = 0xc;\n  return 0;\n}\n\n",
  "FUN_001111e0": "\n/* WARNING: Type propagation algorithm not settling */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nundefined8 * FUN_001111e0(ulong param_1,char *param_2,uint param_3,ulong param_4,ulong param_5)\n\n{\n  uint uVar1;\n  byte bVar2;\n  bool bVar3;\n  undefined auVar4 [16];\n  undefined auVar5 [16];\n  undefined auVar6 [16];\n  undefined auVar7 [16];\n  undefined auVar8 [16];\n  ulong uVar9;\n  float fVar10;\n  float fVar11;\n  char cVar12;\n  uint uVar13;\n  uint uVar14;\n  lconv *plVar15;\n  ulong uVar16;\n  size_t sVar17;\n  ulong uVar18;\n  long lVar19;\n  uint uVar20;\n  uint uVar21;\n  uint uVar22;\n  ulong uVar23;\n  undefined8 *puVar24;\n  undefined8 *__dest;\n  uint uVar25;\n  undefined *__src;\n  ulong uVar26;\n  size_t sVar27;\n  byte *pbVar28;\n  ulong uVar29;\n  char *__s;\n  undefined8 *puVar30;\n  long in_FS_OFFSET;\n  undefined8 *local_c0;\n  uint local_b8;\n  undefined local_78 [56];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar20 = param_3 & 0x20;\n  local_b8 = param_3 & 3;\n  uVar13 = (-(uint)(uVar20 == 0) & 0xffffffe8) + 0x400;\n  plVar15 = localeconv();\n  puVar30 = (undefined8 *)plVar15->decimal_point;\n  uVar16 = strlen((char *)puVar30);\n  pbVar28 = (byte *)plVar15->grouping;\n  __s = plVar15->thousands_sep;\n  if (0xf < uVar16 - 1) {\n    uVar16 = 1;\n    puVar30 = (undefined8 *)&DAT_0011c095;\n  }\n  sVar17 = strlen(__s);\n  if (0x10 < sVar17) {\n    __s = \"\";\n  }\n  local_c0 = (undefined8 *)(param_2 + 0x287);\n  uVar14 = (uint)uVar16;\n  puVar24 = local_c0;\n  if (param_4 < param_5) {\n    if ((param_4 == 0) || (uVar29 = param_5 / param_4, param_5 % param_4 != 0)) goto LAB_001112c4;\n    uVar18 = param_1 / uVar29;\n    uVar23 = (param_1 % uVar29) * 10;\n    uVar9 = uVar23 / uVar29;\n    uVar26 = (uVar23 % uVar29) * 2;\n    auVar8._8_8_ = uVar26;\n    auVar8._0_8_ = uVar18;\n    uVar23 = uVar9 & 0xffffffff;\n    uVar21 = (uint)uVar9;\n    if (uVar26 < uVar29) {\n      uVar25 = (uint)(uVar26 != 0);\n    }\n    else {\n      uVar25 = 2;\n      if (uVar29 < uVar26) {\n        uVar25 = 3;\n      }\n    }\n    if ((param_3 & 0x10) == 0) goto LAB_0011185b;\nLAB_001115f4:\n    uVar21 = (uint)uVar23;\n    uVar18 = auVar8._0_8_;\n    uVar26 = (ulong)uVar13;\n    uVar22 = 0;\n    uVar29 = uVar18;\n    if (uVar18 < uVar26) goto LAB_00111607;\n    while( true ) {\n      uVar18 = uVar29 / uVar26;\n      uVar21 = (int)uVar23 + (int)(uVar29 % uVar26) * 10;\n      uVar23 = uVar21 / uVar26;\n      uVar1 = ((int)uVar25 >> 1) + (uVar21 % uVar13) * 2;\n      uVar21 = (uint)uVar23;\n      uVar25 = uVar25 + uVar1;\n      if (uVar1 < uVar13) {\n        uVar25 = (uint)(uVar25 != 0);\n      }\n      else {\n        uVar25 = (uVar13 < uVar25) + 2;\n      }\n      uVar22 = uVar22 + 1;\n      if (uVar18 < uVar26) break;\n      uVar29 = uVar18;\n      if (uVar22 == 10) goto LAB_00111607;\n    }\n    if (9 < uVar18) goto LAB_00111607;\n    uVar29 = uVar18;\n    if (local_b8 == 1) {\n      if (2 < (uVar21 & 1) + uVar25) goto LAB_00111be7;\nLAB_00111c5c:\n      if (uVar21 == 0) {\nLAB_00111c64:\n        if ((param_3 & 8) != 0) goto LAB_00111c2c;\n        cVar12 = '0';\n        uVar29 = uVar18;\n      }\n      else {\n        cVar12 = (char)uVar23 + '0';\n      }\n    }\n    else {\n      if ((local_b8 != 0) || (uVar25 == 0)) goto LAB_00111c5c;\nLAB_00111be7:\n      if (uVar21 == 9) {\n        uVar29 = uVar18 + 1;\n        if (uVar18 != 9) {\n          uVar25 = 0;\n          uVar18 = uVar29;\n          goto LAB_00111c64;\n        }\n        goto LAB_00111c2a;\n      }\n      cVar12 = (char)uVar23 + '1';\n    }\n    param_2[0x286] = cVar12;\n    uVar23 = uVar16 & 0xffffffff;\n    puVar24 = (undefined8 *)(param_2 + (0x286 - uVar16));\n    if (uVar14 < 8) {\n      if ((uVar16 & 4) == 0) {\n        if ((uVar14 != 0) && (*(undefined *)puVar24 = *(undefined *)puVar30, (uVar16 & 2) != 0)) {\n          *(undefined2 *)((long)puVar24 + (uVar23 - 2)) =\n               *(undefined2 *)((long)puVar30 + (uVar23 - 2));\n        }\n      }\n      else {\n        *(undefined4 *)puVar24 = *(undefined4 *)puVar30;\n        *(undefined4 *)((long)puVar24 + (uVar23 - 4)) =\n             *(undefined4 *)((long)puVar30 + (uVar23 - 4));\n      }\n    }\n    else {\n      *puVar24 = *puVar30;\n      *(undefined8 *)((long)puVar24 + ((uVar16 & 0xffffffff) - 8)) =\n           *(undefined8 *)((long)puVar30 + ((uVar16 & 0xffffffff) - 8));\n      lVar19 = (long)puVar24 - ((ulong)(puVar24 + 1) & 0xfffffffffffffff8);\n      uVar21 = (int)lVar19 + uVar14 & 0xfffffff8;\n      if (7 < uVar21) {\n        uVar25 = 0;\n        do {\n          uVar23 = (ulong)uVar25;\n          uVar25 = uVar25 + 8;\n          *(undefined8 *)(((ulong)(puVar24 + 1) & 0xfffffffffffffff8) + uVar23) =\n               *(undefined8 *)((long)puVar30 + (uVar23 - lVar19));\n        } while (uVar25 < uVar21);\n      }\n    }\nLAB_00111c2a:\n    uVar25 = 0;\n    uVar18 = uVar29;\nLAB_00111c2c:\n    uVar21 = 0;\n    __dest = puVar24;\n    if (local_b8 == 1) goto LAB_00111650;\nLAB_00111617:\n    __dest = puVar24;\n    if ((local_b8 == 0) && (0 < (int)(uVar25 + uVar21))) {\nLAB_00111627:\n      uVar18 = uVar18 + 1;\n      puVar24 = __dest;\n      if ((((param_3 & 0x10) == 0) || (uVar13 != uVar18)) || (uVar22 == 10)) goto LAB_00111650;\n      uVar22 = uVar22 + 1;\n      if ((param_3 & 8) == 0) {\n        *(undefined *)((long)__dest + -1) = 0x30;\n        __dest = (undefined8 *)((long)__dest + ~uVar16);\n        uVar29 = uVar16 & 0xffffffff;\n        if (uVar14 < 8) {\n          if ((uVar16 & 4) == 0) {\n            if ((uVar14 != 0) && (*(undefined *)__dest = *(undefined *)puVar30, (uVar16 & 2) != 0))\n            {\n              *(undefined2 *)((long)__dest + (uVar29 - 2)) =\n                   *(undefined2 *)((long)puVar30 + (uVar29 - 2));\n            }\n          }\n          else {\n            *(undefined4 *)__dest = *(undefined4 *)puVar30;\n            *(undefined4 *)((long)__dest + (uVar29 - 4)) =\n                 *(undefined4 *)((long)puVar30 + (uVar29 - 4));\n          }\n        }\n        else {\n          *__dest = *puVar30;\n          *(undefined8 *)((long)__dest + ((uVar16 & 0xffffffff) - 8)) =\n               *(undefined8 *)((long)puVar30 + ((uVar16 & 0xffffffff) - 8));\n          lVar19 = (long)__dest - ((ulong)(__dest + 1) & 0xfffffffffffffff8);\n          uVar14 = (int)lVar19 + uVar14 & 0xfffffff8;\n          if (7 < uVar14) {\n            uVar21 = 0;\n            do {\n              uVar16 = (ulong)uVar21;\n              uVar21 = uVar21 + 8;\n              *(undefined8 *)(((ulong)(__dest + 1) & 0xfffffffffffffff8) + uVar16) =\n                   *(undefined8 *)((long)puVar30 + (uVar16 - lVar19));\n            } while (uVar21 < uVar14);\n          }\n        }\n      }\n      *(undefined *)((long)__dest + -1) = 0x31;\n      puVar24 = (undefined8 *)((long)__dest + -1);\n    }\n    else {\nLAB_00111650:\n      do {\n        puVar24 = (undefined8 *)((long)puVar24 + -1);\n        *(char *)puVar24 = (char)uVar18 + (char)(uVar18 / 10) * -10 + '0';\n        bVar3 = 9 < uVar18;\n        uVar18 = uVar18 / 10;\n      } while (bVar3);\n    }\n  }\n  else {\n    auVar4._8_8_ = 0;\n    auVar4._0_8_ = param_5;\n    auVar5._8_8_ = 0;\n    auVar5._0_8_ = param_4;\n    if (param_4 % param_5 == 0) {\n      auVar6._8_8_ = 0;\n      auVar6._0_8_ = SUB168(auVar5 / auVar4,0);\n      auVar7._8_8_ = 0;\n      auVar7._0_8_ = param_1;\n      auVar8 = auVar6 * auVar7;\n      uVar18 = auVar8._0_8_;\n      if (auVar8._8_8_ == 0) {\n        uVar25 = 0;\n        uVar23 = 0;\n        uVar21 = 0;\n        if ((param_3 & 0x10) != 0) goto LAB_001115f4;\nLAB_0011185b:\n        uVar22 = 0xffffffff;\nLAB_00111607:\n        if (local_b8 != 1) goto LAB_00111617;\n        __dest = local_c0;\n        if (5 < (int)((((uint)uVar18 & 1) + uVar25 != 0) + uVar21)) goto LAB_00111627;\n        goto LAB_00111650;\n      }\n    }\nLAB_001112c4:\n    fVar10 = (float)param_4;\n    if ((long)param_4 < 0) {\n      fVar10 = fVar10 + _DAT_0011e694;\n    }\n    if ((long)param_5 < 0) {\n      fVar10 = fVar10 / ((float)param_5 + _DAT_0011e694);\n      if (-1 < (long)param_1) goto LAB_00111301;\nLAB_00111400:\n      fVar10 = ((float)param_1 + _DAT_0011e694) * fVar10;\n      if ((param_3 & 0x10) != 0) goto LAB_0011130e;\nLAB_001114da:\n      __sprintf_chk(param_2,1,0xffffffffffffffff,\"%.0Lf\");\n      uVar22 = 0xffffffff;\n      sVar17 = strlen(param_2);\n      sVar27 = sVar17;\n    }\n    else {\n      fVar10 = fVar10 / (float)param_5;\n      if ((long)param_1 < 0) goto LAB_00111400;\nLAB_00111301:\n      fVar10 = (float)param_1 * fVar10;\n      if ((param_3 & 0x10) == 0) goto LAB_001114da;\nLAB_0011130e:\n      uVar22 = 0;\n      fVar11 = (float)uVar13;\n      do {\n        uVar22 = uVar22 + 1;\n        fVar11 = fVar11 * (float)uVar13;\n        if (fVar10 < fVar11) break;\n      } while (uVar22 != 10);\n      if (local_b8 == 1) {\n        __sprintf_chk(param_2,1,0xffffffffffffffff,\"%.1Lf\");\n        sVar17 = strlen(param_2);\n      }\n      else {\n        __sprintf_chk(param_2,1,0xffffffffffffffff,\"%.1Lf\");\n        sVar17 = strlen(param_2);\n      }\n      if ((uVar16 + 2 + (ulong)(uVar20 == 0) < sVar17) ||\n         (((param_3 & 8) != 0 && (param_2[sVar17 - 1] == '0')))) {\n        __sprintf_chk(param_2,1,0xffffffffffffffff,\"%.0Lf\");\n        sVar17 = strlen(param_2);\n        sVar27 = sVar17;\n      }\n      else {\n        sVar27 = sVar17 - (uVar16 + 1);\n      }\n    }\n    puVar24 = (undefined8 *)((long)local_c0 - sVar17);\n    memmove(puVar24,param_2,sVar17);\n    __dest = (undefined8 *)((long)puVar24 + sVar27);\n  }\n  if ((param_3 & 4) != 0) {\n    uVar29 = 0xffffffffffffffff;\n    sVar17 = strlen(__s);\n    __memcpy_chk(local_78,puVar24,(long)__dest - (long)puVar24,0x29);\n    uVar16 = (long)__dest - (long)puVar24;\n    while( true ) {\n      bVar2 = *pbVar28;\n      if (bVar2 == 0) {\n        if (uVar16 < uVar29) {\n          uVar29 = uVar16;\n        }\n        uVar23 = uVar16 - uVar29;\n        __src = local_78 + uVar23;\n      }\n      else {\n        if (bVar2 < 0x7f) {\n          uVar29 = (ulong)bVar2;\n          if (uVar16 < bVar2) {\n            uVar29 = uVar16;\n          }\n          uVar23 = uVar16 - uVar29;\n          __src = local_78 + uVar23;\n          uVar16 = uVar29;\n        }\n        else {\n          uVar23 = 0;\n          __src = local_78;\n        }\n        pbVar28 = pbVar28 + 1;\n        uVar29 = uVar16;\n      }\n      puVar24 = (undefined8 *)((long)__dest - uVar29);\n      memcpy(puVar24,__src,uVar29);\n      if (uVar23 == 0) break;\n      __dest = (undefined8 *)((long)puVar24 - sVar17);\n      memcpy(__dest,__s,sVar17);\n      uVar16 = uVar23;\n    }\n  }\n  puVar30 = local_c0;\n  if ((param_3 & 0x80) == 0) goto LAB_0011155f;\n  if (uVar22 == 0xffffffff) {\n    if (param_5 < 2) {\n      uVar22 = 0;\n      goto LAB_0011154c;\n    }\n    uVar22 = 1;\n    uVar16 = 1;\n    do {\n      uVar16 = uVar16 * uVar13;\n      if (param_5 <= uVar16) break;\n      uVar22 = uVar22 + 1;\n    } while (uVar22 != 10);\n    if ((param_3 & 0x40) != 0) goto LAB_001118a9;\nLAB_001118c8:\n    puVar30 = (undefined8 *)((long)local_c0 + 1);\n    if ((uVar20 == 0) && (uVar22 == 1)) {\n      *(undefined *)local_c0 = 0x6b;\n      goto joined_r0x00111bb5;\n    }\n    *(undefined *)local_c0 = (&DAT_0011e6e8)[(int)uVar22];\n    if ((param_3 & 0x100) == 0) goto LAB_0011155f;\n    if (uVar20 != 0) {\n      *(undefined *)((long)local_c0 + 1) = 0x69;\n      puVar30 = (undefined8 *)((long)local_c0 + 2);\n    }\n  }\n  else {\nLAB_0011154c:\n    if ((param_3 & 0x100 | uVar22) == 0) goto LAB_0011155f;\n    if ((param_3 & 0x40) != 0) {\nLAB_001118a9:\n      local_c0 = (undefined8 *)(param_2 + 0x288);\n      param_2[0x287] = ' ';\n    }\n    puVar30 = local_c0;\n    if (uVar22 != 0) goto LAB_001118c8;\njoined_r0x00111bb5:\n    if ((param_3 & 0x100) == 0) goto LAB_0011155f;\n  }\n  *(undefined *)puVar30 = 0x42;\n  puVar30 = (undefined8 *)((long)puVar30 + 1);\nLAB_0011155f:\n  local_c0 = puVar30;\n  *(undefined *)local_c0 = 0;\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return puVar24;\n}\n\n",
  "__errno_location": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = (int *)(*(code *)PTR___errno_location_00125cc8)();\n  return piVar1;\n}\n\n",
  "FUN_0010eae0": "\nvoid * FUN_0010eae0(char *param_1,uint param_2)\n\n{\n  char cVar1;\n  bool bVar2;\n  char cVar3;\n  int iVar4;\n  char *pcVar5;\n  int *piVar6;\n  void *pvVar7;\n  void *pvVar8;\n  char *pcVar9;\n  undefined2 *puVar10;\n  size_t __n;\n  ulong uVar11;\n  size_t sVar12;\n  char *pcVar13;\n  undefined2 *puVar14;\n  undefined *__dest;\n  undefined2 *puVar15;\n  long lVar16;\n  undefined2 *__path;\n  uint uVar17;\n  long in_FS_OFFSET;\n  bool bVar18;\n  char *local_d68;\n  int local_d24;\n  long local_d18;\n  stat local_d08;\n  undefined2 *local_c78;\n  size_t local_c70;\n  undefined local_c68;\n  undefined2 local_c67 [511];\n  undefined *local_868;\n  ulong local_860;\n  undefined local_858 [1024];\n  char *local_458;\n  long local_450;\n  char local_448 [1032];\n  long local_40;\n  \n  uVar17 = param_2 & 3;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_c70 = 0x400;\n  local_868 = local_858;\n  local_458 = local_448;\n  local_860 = 0x400;\n  local_450 = 0x400;\n  local_c78 = (undefined2 *)&local_c68;\n  if (((uVar17 - 1 & uVar17) == 0) && (param_1 != (char *)0x0)) {\n    if (*param_1 != '\\0') {\n      if (*param_1 != '/') {\n        do {\n          __path = local_c78;\n          pcVar5 = getcwd((char *)local_c78,local_c70);\n          if (pcVar5 != (char *)0x0) {\n            puVar10 = (undefined2 *)rawmemchr(__path,0);\n            cVar3 = *param_1;\n            if (cVar3 != '\\0') goto LAB_0010ec90;\n            puVar15 = (undefined2 *)((long)puVar10 + 1);\n            puVar14 = puVar10;\n            if (puVar10 <= (undefined2 *)((long)__path + 1)) goto LAB_0010ed9d;\n            pvVar7 = (void *)0x0;\n            goto LAB_0010ed79;\n          }\n          piVar6 = __errno_location();\n          if (*piVar6 == 0xc) break;\n          pvVar8 = (void *)0x0;\n          if (*piVar6 != 0x22) goto LAB_0010ebdb;\n          cVar3 = FUN_0010fd60(&local_c78);\n        } while (cVar3 != '\\0');\nLAB_0010ee4e:\n                    /* WARNING: Subroutine does not return */\n        FUN_00118390();\n      }\n      local_c68 = 0x2f;\n      puVar10 = local_c67;\n      cVar3 = '/';\n      __path = (undefined2 *)&local_c68;\nLAB_0010ec90:\n      bVar2 = false;\n      pvVar7 = (void *)0x0;\n      local_d24 = 0;\n      puVar15 = puVar10;\nLAB_0010ecba:\n      do {\n        local_d68 = param_1;\n        puVar10 = puVar15;\n        if (cVar3 == '/') {\n          do {\n            cVar3 = param_1[1];\n            param_1 = param_1 + 1;\n          } while (cVar3 == '/');\n          local_d68 = param_1;\n          if (cVar3 == '\\0') break;\n        }\n        do {\n          pcVar5 = param_1;\n          cVar1 = pcVar5[1];\n          param_1 = pcVar5 + 1;\n          if (cVar1 == '\\0') break;\n        } while (cVar1 != '/');\n        sVar12 = (long)param_1 - (long)local_d68;\n        if (sVar12 == 0) break;\n        if (sVar12 == 1) {\n          bVar18 = cVar3 != '.';\n          cVar3 = cVar1;\n          if (bVar18) goto LAB_0010edd5;\nLAB_0010ed60:\n          puVar10 = puVar15;\n          if (cVar3 == '\\0') break;\n          goto LAB_0010ecba;\n        }\n        if (((cVar3 == '.') && (sVar12 == 2)) && (local_d68[1] == '.')) {\n          cVar3 = cVar1;\n          if (((undefined2 *)((long)__path + 1) < puVar15) &&\n             (puVar15 = (undefined2 *)((long)puVar15 + -1), __path < puVar15)) {\n            do {\n              if (*(char *)((long)puVar15 + -1) == '/') break;\n              puVar15 = (undefined2 *)((long)puVar15 + -1);\n            } while (puVar15 != __path);\n          }\n          goto LAB_0010ed60;\n        }\nLAB_0010edd5:\n        if (*(char *)((long)puVar15 + -1) != '/') {\n          *(char *)puVar15 = '/';\n          puVar15 = (undefined2 *)((long)puVar15 + 1);\n        }\n        pcVar9 = (char *)((long)__path + (local_c70 - (long)puVar15));\n        while (pcVar9 < (char *)(sVar12 + 2)) {\n          lVar16 = (long)puVar15 - (long)__path;\n          cVar3 = FUN_0010fde0(&local_c78);\n          if (cVar3 == '\\0') goto LAB_0010ee4e;\n          puVar15 = (undefined2 *)((long)local_c78 + lVar16);\n          __path = local_c78;\n          pcVar9 = (char *)(local_c70 - lVar16);\n        }\n        puVar10 = (undefined2 *)mempcpy(puVar15,local_d68,sVar12);\n        *(char *)puVar10 = '\\0';\n        puVar15 = puVar10;\n        if ((param_2 & 4) == 0) {\n          while (pcVar9 = local_458, sVar12 = local_450 - 1,\n                __n = readlink((char *)__path,local_458,sVar12), (long)sVar12 <= (long)__n) {\n            cVar3 = FUN_0010fd60(&local_458);\n            if (cVar3 == '\\0') goto LAB_0010ee4e;\n          }\n          if ((long)__n < 0) goto LAB_0010ee9e;\n          if (local_d24 < 0x14) {\n            local_d24 = local_d24 + 1;\nLAB_0010f161:\n            __dest = local_868;\n            pcVar9[__n] = '\\0';\n            if (bVar2) {\n              local_d18 = (long)param_1 - (long)local_868;\n              local_d68 = (char *)strlen(param_1);\n              uVar11 = (long)local_d68 + __n;\n              if (local_860 <= uVar11) {\nLAB_0010f1bf:\n                do {\n                  cVar3 = FUN_0010fde0(&local_868);\n                  if (cVar3 == '\\0') goto LAB_0010ee4e;\n                } while (local_860 <= uVar11);\n                __dest = local_868;\n                if (!bVar2) goto LAB_0010f258;\n              }\n              param_1 = __dest + local_d18;\n            }\n            else {\n              local_d68 = (char *)strlen(param_1);\n              uVar11 = (long)local_d68 + __n;\n              if (local_860 <= uVar11) goto LAB_0010f1bf;\n            }\nLAB_0010f258:\n            memmove(__dest + __n,param_1,(long)local_d68 + 1);\n            param_1 = (char *)memcpy(__dest,pcVar9,__n);\n            puVar15 = (undefined2 *)((long)__path + 1);\n            if (*pcVar9 == '/') {\n              *(char *)__path = '/';\n              bVar2 = true;\n              cVar3 = *param_1;\n            }\n            else {\n              bVar2 = true;\n              bVar18 = puVar15 < puVar10;\n              puVar15 = puVar10;\n              cVar3 = *param_1;\n              if (bVar18) {\n                do {\n                  puVar15 = (undefined2 *)((long)puVar10 + -1);\n                  if (puVar15 == __path) break;\n                  puVar14 = puVar10 + -1;\n                  puVar10 = puVar15;\n                } while (*(char *)puVar14 != '/');\n                bVar2 = true;\n              }\n            }\n            goto LAB_0010ed60;\n          }\n          if (*local_d68 == '\\0') goto LAB_0010f161;\n          pcVar13 = (char *)(((long)local_d68 - (long)param_1) + (long)puVar10);\n          *pcVar13 = '\\0';\n          puVar14 = (undefined2 *)&DAT_0011c095;\n          if (*(char *)__path != '\\0') {\n            puVar14 = __path;\n          }\n          iVar4 = stat((char *)puVar14,&local_d08);\n          if (iVar4 == 0) {\n            *pcVar13 = *local_d68;\n            if ((pvVar7 != (void *)0x0) ||\n               (pvVar7 = (void *)FUN_001108b0(7,0,FUN_00111150,FUN_00111180,FUN_001111c0),\n               pvVar7 != (void *)0x0)) {\n              cVar3 = FUN_0010f4c0(pvVar7,local_d68,&local_d08);\n              if (cVar3 == '\\0') {\n                FUN_0010f430(pvVar7,local_d68,&local_d08);\n                goto LAB_0010f161;\n              }\n              if (uVar17 != 2) {\n                piVar6 = __errno_location();\n                *piVar6 = 0x28;\n                goto LAB_0010efb4;\n              }\n              goto LAB_0010ef20;\n            }\n            goto LAB_0010ee4e;\n          }\nLAB_0010efb4:\n          pvVar8 = pvVar7;\n          if (pvVar7 != (void *)0x0) {\n            pvVar8 = (void *)0x0;\n            FUN_00110a70(pvVar7);\n          }\n          goto LAB_0010ebdb;\n        }\nLAB_0010ee9e:\n        if (uVar17 != 2) {\n          cVar3 = *param_1;\n          pcVar9 = param_1;\n          cVar1 = cVar3;\n          do {\n            if (cVar1 != '/') goto LAB_0010ef60;\n            do {\n              pcVar13 = pcVar9;\n              cVar1 = pcVar13[1];\n              pcVar9 = pcVar13 + 1;\n            } while (cVar1 == '/');\n            pcVar9 = pcVar13 + 2;\n            if (cVar1 == '\\0') goto LAB_0010f058;\n            if (cVar1 != '.') goto LAB_0010ef60;\n            cVar1 = pcVar13[2];\n            if (cVar1 == '\\0') goto LAB_0010f058;\n          } while (cVar1 != '.');\n          if ((pcVar13[3] == '\\0') || (pcVar13[3] == '/')) {\nLAB_0010f058:\n            *puVar10 = DAT_0011e5de;\nLAB_0010ef00:\n            iVar4 = faccessat(-100,(char *)__path,0,0x200);\n            if (iVar4 == 0) goto LAB_0010ef20;\n          }\n          else {\nLAB_0010ef60:\n            if ((param_2 & 4) != 0) {\n              if (cVar3 == '\\0') goto LAB_0010ef00;\n              goto LAB_0010ecba;\n            }\n            piVar6 = __errno_location();\n            if (*piVar6 == 0x16) goto LAB_0010ef20;\n          }\n          if (((uVar17 == 1) && (piVar6 = __errno_location(), *piVar6 == 2)) &&\n             (sVar12 = strspn(param_1,\"/\"), param_1[sVar12] == '\\0')) {\n            cVar3 = pcVar5[1];\n            goto LAB_0010ed60;\n          }\n          goto LAB_0010efb4;\n        }\nLAB_0010ef20:\n        cVar3 = pcVar5[1];\n      } while (cVar3 != '\\0');\n      puVar15 = (undefined2 *)((long)puVar10 + 1);\n      puVar14 = puVar10;\n      if ((undefined2 *)((long)__path + 1) < puVar10) {\nLAB_0010ed79:\n        puVar14 = puVar10;\n        puVar15 = (undefined2 *)((long)puVar10 + 1);\n        if (*(char *)((long)puVar10 + -1) == '/') {\n          puVar14 = (undefined2 *)((long)puVar10 + -1);\n          puVar15 = puVar10;\n        }\n      }\n      if (pvVar7 != (void *)0x0) {\n        FUN_00110a70(pvVar7);\n      }\nLAB_0010ed9d:\n      *(char *)puVar14 = '\\0';\n      pvVar7 = malloc((long)puVar15 - (long)__path);\n      if (pvVar7 == (void *)0x0) goto LAB_0010ee4e;\n      pvVar8 = memcpy(pvVar7,__path,(long)puVar15 - (long)__path);\nLAB_0010ebdb:\n      if (local_458 != local_448) {\n        free(local_458);\n      }\n      if (local_868 != local_858) {\n        free(local_868);\n      }\n      goto LAB_0010ec03;\n    }\n    piVar6 = __errno_location();\n    *piVar6 = 2;\n  }\n  else {\n    piVar6 = __errno_location();\n    *piVar6 = 0x16;\n  }\n  pvVar8 = (void *)0x0;\nLAB_0010ec03:\n  if (local_c78 != (undefined2 *)&local_c68) {\n    free(local_c78);\n  }\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pvVar8;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_00108530": "\nint FUN_00108530(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  pcVar1 = param_1[0xe];\n  pcVar2 = param_2[0xe];\n  pcVar3 = param_1[0xf];\n  pcVar4 = param_2[0xf];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_2[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_2[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 == 0) {\n    iVar5 = strcmp(*param_2,*param_1);\n    return iVar5;\n  }\n  return iVar5;\n}\n\n",
  "strcmp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_strcmp_00125fc8)();\n  return iVar1;\n}\n\n",
  "FUN_00106d60": "\nbool FUN_00106d60(uint param_1)\n\n{\n  long lVar1;\n  byte *pbVar2;\n  int iVar3;\n  bool bVar4;\n  \n  bVar4 = false;\n  lVar1 = *(long *)(&DAT_00126060 + (ulong)param_1 * 0x10);\n  if (lVar1 != 0) {\n    pbVar2 = (&PTR_DAT_00126068)[(ulong)param_1 * 2];\n    if (lVar1 == 1) {\n      return *pbVar2 != 0x30;\n    }\n    bVar4 = true;\n    if (lVar1 == 2) {\n      iVar3 = *pbVar2 - 0x30;\n      if (iVar3 == 0) {\n        iVar3 = pbVar2[1] - 0x30;\n      }\n      return iVar3 != 0;\n    }\n  }\n  return bVar4;\n}\n\n",
  "FUN_0010bf80": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nlong FUN_0010bf80(char **param_1,byte param_2,undefined8 param_3,ulong param_4)\n\n{\n  size_t __n;\n  char cVar1;\n  uint uVar2;\n  int iVar3;\n  long lVar4;\n  size_t sVar5;\n  size_t *psVar6;\n  uint uVar7;\n  ulong uVar8;\n  char *__s;\n  \n  if (param_2 == 0) {\n    __s = *param_1;\n    if (DAT_00127312 == '\\0') goto LAB_0010bfb3;\n    uVar2 = (uint)*(byte *)((long)param_1 + 0xb9);\n    if ((DAT_00127390 == '\\0') || (*(byte *)((long)param_1 + 0xb9) == 0)) {\n      uVar8 = (ulong)*(uint *)(param_1 + 6);\n    }\n    else {\n      uVar8 = (ulong)*(uint *)((long)param_1 + 0xac);\n    }\nLAB_0010c053:\n    cVar1 = *(char *)(param_1 + 0x17);\n    if (cVar1 == '\\0') goto LAB_0010c063;\nLAB_0010c1a2:\n    uVar7 = (uint)uVar8 & 0xf000;\n    if (uVar7 == 0x8000) {\n      if (((uVar8 & 0x800) != 0) && (cVar1 = FUN_00106d60(0x10), cVar1 != '\\0')) {\n        lVar4 = 0x100;\n        goto LAB_0010c0bb;\n      }\n      uVar2 = (uint)uVar8;\n      if (((uVar8 & 0x400) != 0) && (cVar1 = FUN_00106d60(0x11), cVar1 != '\\0')) {\n        lVar4 = 0x110;\n        goto LAB_0010c0bb;\n      }\n      cVar1 = FUN_00106d60(0x15);\n      if ((cVar1 != '\\0') && (*(char *)(param_1 + 0x18) != '\\0')) {\n        lVar4 = 0x150;\n        goto LAB_0010c0bb;\n      }\n      if (((uVar2 & 0x49) != 0) && (cVar1 = FUN_00106d60(0xe), cVar1 != '\\0')) {\n        lVar4 = 0xe0;\n        goto LAB_0010c0bb;\n      }\n      if (((char *)0x1 < param_1[5]) && (cVar1 = FUN_00106d60(0x16), cVar1 != '\\0')) {\n        lVar4 = 0x160;\n        goto LAB_0010c0bb;\n      }\n      goto LAB_0010c250;\n    }\n    if (uVar7 != 0x4000) {\n      if (uVar7 != 0xa000) {\n        lVar4 = 0x80;\n        if ((((uVar7 != 0x1000) && (lVar4 = 0x90, uVar7 != 0xc000)) &&\n            (lVar4 = 0xa0, uVar7 != 0x6000)) && (lVar4 = 0xb0, uVar7 != 0x2000)) {\n          lVar4 = 0xd0;\n        }\n        goto LAB_0010c0bb;\n      }\n      uVar8 = 7;\n      goto LAB_0010c083;\n    }\n    if (((uint)uVar8 & 0x202) == 0x202) {\n      cVar1 = FUN_00106d60(0x14);\n      lVar4 = 0x140;\n      if (cVar1 != '\\0') goto LAB_0010c0bb;\n    }\n    uVar2 = (uint)uVar8;\n    if ((uVar8 & 2) != 0) {\n      cVar1 = FUN_00106d60(0x13);\n      lVar4 = 0x130;\n      if (cVar1 != '\\0') goto LAB_0010c0bb;\n    }\n    lVar4 = 0x60;\n    if ((uVar2 & 0x200) != 0) {\n      cVar1 = FUN_00106d60(0x12);\n      lVar4 = (-(ulong)(cVar1 == '\\0') & 0xffffffffffffff40) + 0x120;\n    }\n  }\n  else {\n    __s = param_1[1];\n    if (DAT_00127312 == '\\0') goto LAB_0010bfb3;\n    uVar8 = (ulong)*(uint *)((long)param_1 + 0xac);\n    if (*(char *)((long)param_1 + 0xb9) == '\\0') {\n      cVar1 = FUN_00106d60(0xc);\n      if (cVar1 == '\\0') {\n        uVar2 = 0xffffffff;\n        goto LAB_0010c053;\n      }\n      lVar4 = 0xc0;\n      goto LAB_0010c0bb;\n    }\n    cVar1 = *(char *)(param_1 + 0x17);\n    uVar2 = 0;\n    if (cVar1 != '\\0') goto LAB_0010c1a2;\nLAB_0010c063:\n    uVar7 = *(uint *)(&DAT_0011a6a0 + (ulong)*(uint *)(param_1 + 0x15) * 4);\n    uVar8 = (ulong)uVar7;\n    cVar1 = uVar7 == 7;\n    if (uVar7 == 5) {\nLAB_0010c250:\n      sVar5 = strlen(__s);\n      for (psVar6 = DAT_00127308; psVar6 != (size_t *)0x0; psVar6 = (size_t *)psVar6[5]) {\n        __n = *psVar6;\n        if (__n <= sVar5) {\n          if (*(char *)(psVar6 + 4) == '\\0') {\n            iVar3 = FUN_0010ea60();\n          }\n          else {\n            iVar3 = strncmp(__s + (sVar5 - __n),(char *)psVar6[1],__n);\n          }\n          if (iVar3 == 0) {\n            psVar6 = psVar6 + 2;\n            goto LAB_0010c0c5;\n          }\n        }\n      }\n      lVar4 = 0x50;\n    }\n    else {\nLAB_0010c083:\n      if ((uVar2 == 0) && (cVar1 != '\\0')) {\n        lVar4 = 0xd0;\n        if (DAT_00127390 == '\\0') {\n          cVar1 = FUN_00106d60(0xd);\n          lVar4 = (-(ulong)(cVar1 == '\\0') & 0xffffffffffffffa0) + 0xd0;\n        }\n      }\n      else {\n        lVar4 = uVar8 << 4;\n      }\n    }\n  }\nLAB_0010c0bb:\n  psVar6 = (size_t *)(&DAT_00126060 + lVar4);\nLAB_0010c0c5:\n  if (psVar6[1] == 0) {\n    cVar1 = FUN_00106d60(4);\n    if (cVar1 == '\\0') {\nLAB_0010bfb3:\n      lVar4 = FUN_0010bb80(__s,DAT_001272d0,*(undefined4 *)((long)param_1 + 0xc4),0,param_2 ^ 1,\n                           param_3,param_1[2]);\n      FUN_00108590();\n      return lVar4;\n    }\n    psVar6 = (size_t *)0x0;\n  }\n  lVar4 = FUN_0010bb80(__s,DAT_001272d0,*(undefined4 *)((long)param_1 + 0xc4),psVar6,param_2 ^ 1,\n                       param_3,param_1[2]);\n  FUN_00108590();\n  if (_DAT_00126088 == 0) {\n    FUN_00107940(&DAT_00126060);\n    FUN_00107940(&DAT_00126090);\n    FUN_00107940(&DAT_00126070);\n  }\n  else {\n    FUN_00107940(&DAT_00126080);\n  }\n  if (DAT_001272b0 == 0) {\n    return lVar4;\n  }\n  uVar8 = lVar4 + -1 + param_4;\n  if (param_4 / DAT_001272b0 == uVar8 / DAT_001272b0) {\n    return lVar4;\n  }\n  FUN_00107940(&DAT_001261d0,param_4 / DAT_001272b0,uVar8 % DAT_001272b0);\n  return lVar4;\n}\n\n",
  "FUN_00117490": "\nundefined8 FUN_00117490(long *param_1,char *param_2)\n\n{\n  char *__s2;\n  long *plVar1;\n  int iVar2;\n  size_t sVar3;\n  long lVar4;\n  char *__s1;\n  \n  __s2 = *(char **)(param_2 + 0x30);\n  if (__s2 == (char *)0x0) {\n    return 1;\n  }\n  if ((__s2 < param_2) || (param_2 + 0x38 <= __s2)) {\n    __s1 = (char *)((long)param_1 + 9);\n    if (*__s2 != '\\0') {\n      do {\n        iVar2 = strcmp(__s1,__s2);\n        while( true ) {\n          if (iVar2 == 0) goto LAB_00117528;\n          if ((*__s1 == '\\0') &&\n             ((__s1 != (char *)((long)param_1 + 9) || (*(char *)(param_1 + 1) == '\\0')))) {\n            sVar3 = strlen(__s2);\n            if ((long)(sVar3 + 1) < (long)param_1 + (0x80 - (long)__s1)) {\n              memcpy(__s1,__s2,sVar3 + 1);\n              __s1[sVar3 + 1] = '\\0';\n            }\n            else {\n              lVar4 = FUN_001173f0(__s2);\n              *param_1 = lVar4;\n              if (lVar4 == 0) {\n                return 0;\n              }\n              *(undefined *)(lVar4 + 8) = 0;\n              __s1 = (char *)(lVar4 + 9);\n            }\n            goto LAB_00117528;\n          }\n          sVar3 = strlen(__s1);\n          __s1 = __s1 + sVar3 + 1;\n          if ((*__s1 != '\\0') || (plVar1 = (long *)*param_1, plVar1 == (long *)0x0)) break;\n          __s1 = (char *)((long)plVar1 + 9);\n          iVar2 = strcmp(__s1,__s2);\n          param_1 = plVar1;\n        }\n      } while( true );\n    }\n    __s1 = \"\";\nLAB_00117528:\n    *(char **)(param_2 + 0x30) = __s1;\n  }\n  return 1;\n}\n\n",
  "FUN_0010aa10": "\nint FUN_0010aa10(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  iVar5 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar5 == 9 || iVar5 == 3) goto LAB_0010aa90;\n    iVar5 = 1;\n  }\n  else {\n    if (iVar5 == 9 || iVar5 == 3) {\n      return -1;\n    }\n    iVar5 = 0;\n  }\n  iVar5 = iVar5 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar5 != 0) {\n    return iVar5;\n  }\nLAB_0010aa90:\n  pcVar1 = param_2[0xc];\n  pcVar2 = param_1[0xc];\n  pcVar3 = param_2[0xd];\n  pcVar4 = param_1[0xd];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_1[0xd] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_1[0xc] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 != 0) {\n    return iVar5;\n  }\n  iVar5 = strcmp(*param_1,*param_2);\n  return iVar5;\n}\n\n",
  "gethostname": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint gethostname(char *__name,size_t __len)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_gethostname_00125f30)();\n  return iVar1;\n}\n\n",
  "sigaction": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint sigaction(int __sig,sigaction *__act,sigaction *__oact)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_sigaction_00125d00)();\n  return iVar1;\n}\n\n",
  "FUN_00117010": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_00117010(long param_1,long param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long in_FS_OFFSET;\n  undefined8 local_48;\n  undefined8 uStack_40;\n  undefined8 local_38;\n  undefined8 uStack_30;\n  undefined8 local_28;\n  long lStack_20;\n  long local_18;\n  long local_10;\n  \n  uStack_40 = uRam0000000000127528;\n  local_38 = _DAT_00127530;\n  uStack_30 = uRam0000000000127538;\n  local_28 = _DAT_00127540;\n  lStack_20 = uRam0000000000127548;\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_18 = DAT_00127550;\n  local_48 = CONCAT44((int)((ulong)_DAT_00127520 >> 0x20),10);\n  if ((param_1 != 0) && (param_2 != 0)) {\n    lStack_20 = param_1;\n    local_18 = param_2;\n    FUN_00116340(0,param_3,param_4,&local_48);\n    if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return;\n    }\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n                    /* WARNING: Subroutine does not return */\n  abort();\n}\n\n",
  "FUN_00118220": "\nvoid FUN_00118220(size_t param_1)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(param_1,1);\n  if (pvVar1 != (void *)0x0) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "FUN_0010b570": "\nint FUN_0010b570(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  int iVar3;\n  \n  iVar3 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar3 == 9 || iVar3 == 3) goto LAB_0010b5f0;\n    iVar3 = 1;\n  }\n  else {\n    if (iVar3 == 9 || iVar3 == 3) {\n      return -1;\n    }\n    iVar3 = 0;\n  }\n  iVar3 = iVar3 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar3 != 0) {\n    return iVar3;\n  }\nLAB_0010b5f0:\n  pcVar1 = param_1[9];\n  pcVar2 = param_2[9];\n  iVar3 = (uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_2[9] != pcVar1 && (long)pcVar1 <= (long)pcVar2);\n  if (iVar3 != 0) {\n    return iVar3;\n  }\n  iVar3 = strcmp(*param_2,*param_1);\n  return iVar3;\n}\n\n",
  "memmove": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = (void *)(*(code *)PTR_memmove_00125ef8)();\n  return pvVar1;\n}\n\n",
  "FUN_00110610": "\nlong FUN_00110610(long *param_1,long param_2)\n\n{\n  char cVar1;\n  ulong uVar2;\n  long *plVar3;\n  long lVar4;\n  \n  uVar2 = (*(code *)param_1[6])(param_2,param_1[2]);\n  if ((ulong)param_1[2] <= uVar2) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  plVar3 = (long *)(uVar2 * 0x10 + *param_1);\n  lVar4 = *plVar3;\n  if (lVar4 != 0) {\n    while( true ) {\n      if (lVar4 == param_2) {\n        return param_2;\n      }\n      cVar1 = (*(code *)param_1[7])(param_2);\n      if (cVar1 != '\\0') break;\n      plVar3 = (long *)plVar3[1];\n      if (plVar3 == (long *)0x0) {\n        return 0;\n      }\n      lVar4 = *plVar3;\n    }\n    return *plVar3;\n  }\n  return 0;\n}\n\n",
  "FUN_001168e0": "\nvoid FUN_001168e0(undefined8 param_1,int param_2,undefined8 param_3)\n\n{\n  long in_FS_OFFSET;\n  int local_48;\n  undefined4 local_44;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_2 == 10) {\n                    /* WARNING: Subroutine does not return */\n    abort();\n  }\n  local_44 = 0;\n  local_40 = 0;\n  local_38 = 0;\n  local_30 = 0;\n  local_28 = 0;\n  local_20 = 0;\n  local_18 = 0;\n  local_48 = param_2;\n  FUN_00116340(param_1,param_3,0xffffffffffffffff,&local_48);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "dirfd": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint dirfd(DIR *__dirp)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_dirfd_00125e38)();\n  return iVar1;\n}\n\n",
  "FUN_001167c0": "\nvoid FUN_001167c0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  FUN_001166d0(param_1,param_2,0,param_3);\n  return;\n}\n\n",
  "FUN_00108420": "\nvoid FUN_00108420(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  pcVar1 = param_2[0xc];\n  pcVar2 = param_1[0xc];\n  pcVar3 = param_2[0xd];\n  pcVar4 = param_1[0xd];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_1[0xd] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_1[0xc] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    strcmp(*param_1,*param_2);\n    return;\n  }\n  return;\n}\n\n",
  "FUN_00107330": "\nvoid FUN_00107330(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_001072b0(param_2,param_1,PTR_strcmp_00125fc8);\n  return;\n}\n\n",
  "FUN_0010ac60": "\nulong FUN_0010ac60(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010ace0;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010ace0:\n  uVar3 = FUN_00108c70();\n  return uVar3;\n}\n\n",
  "FUN_00118350": "\nvoid FUN_00118350(char *param_1)\n\n{\n  size_t sVar1;\n  void *__dest;\n  \n  sVar1 = strlen(param_1);\n  __dest = malloc(sVar1 + 1);\n  if (__dest != (void *)0x0) {\n    memcpy(__dest,param_1,sVar1 + 1);\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  FUN_00118390();\n}\n\n",
  "lgetfilecon": "\nvoid lgetfilecon(void)\n\n{\n  (*(code *)PTR_lgetfilecon_00125f70)();\n  return;\n}\n\n",
  "error": "\nvoid error(void)\n\n{\n  (*(code *)PTR_error_00125f00)();\n  return;\n}\n\n",
  "FUN_0010e970": "\nlong FUN_0010e970(void *param_1,long *param_2,void *param_3,size_t param_4)\n\n{\n  int iVar1;\n  long lVar2;\n  \n  lVar2 = *param_2;\n  if (lVar2 != 0) {\n    param_2 = param_2 + 1;\n    do {\n      iVar1 = memcmp(param_1,param_3,param_4);\n      if (iVar1 == 0) {\n        return lVar2;\n      }\n      lVar2 = *param_2;\n      param_3 = (void *)((long)param_3 + param_4);\n      param_2 = param_2 + 1;\n    } while (lVar2 != 0);\n  }\n  return lVar2;\n}\n\n",
  "wcstombs": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t wcstombs(char *__s,wchar_t *__pwcs,size_t __n)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_wcstombs_00125f28)();\n  return sVar1;\n}\n\n",
  "__overflow": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint __overflow(_IO_FILE *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR___overflow_00125db0)();\n  return iVar1;\n}\n\n",
  "tcgetpgrp": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\n__pid_t tcgetpgrp(int __fd)\n\n{\n  __pid_t _Var1;\n  \n  _Var1 = (*(code *)PTR_tcgetpgrp_00125e88)();\n  return _Var1;\n}\n\n",
  "FUN_0010b340": "\nulong FUN_0010b340(long param_1,long param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  iVar2 = *(int *)(param_1 + 0xa8);\n  if (((*(int *)(param_2 + 0xa8) == 3) || (*(int *)(param_2 + 0xa8) == 9)) ||\n     ((*(uint *)(param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar2 == 9 || iVar2 == 3) goto LAB_0010b3c0;\n    iVar2 = 1;\n  }\n  else {\n    if (iVar2 == 9 || iVar2 == 3) {\n      return 0xffffffff;\n    }\n    iVar2 = 0;\n  }\n  uVar1 = iVar2 - (uint)((*(uint *)(param_1 + 0xac) & 0xf000) == 0x4000);\n  if (uVar1 != 0) {\n    return (ulong)uVar1;\n  }\nLAB_0010b3c0:\n  uVar3 = FUN_00108b90();\n  return uVar3;\n}\n\n",
  "FUN_0010c430": "\nvoid FUN_0010c430(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  byte *pbVar1;\n  char cVar2;\n  byte bVar3;\n  undefined1 *puVar4;\n  undefined4 uVar5;\n  undefined8 extraout_RDX;\n  undefined8 extraout_RDX_00;\n  long in_FS_OFFSET;\n  undefined auStack_2b8 [664];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (DAT_00127312 != '\\0') {\n    cVar2 = FUN_00106d60(4);\n    param_3 = extraout_RDX;\n    if (cVar2 != '\\0') {\n      FUN_00107940(&DAT_00126060);\n      FUN_00107940(&DAT_001260a0);\n      FUN_00107940(&DAT_00126070);\n      param_3 = extraout_RDX_00;\n    }\n  }\n  if (DAT_001272fc != '\\0') {\n    puVar4 = &DAT_0011bdd6;\n    if ((*(char *)(param_1 + 0xb8) != '\\0') && (*(long *)(param_1 + 0x20) != 0)) {\n      puVar4 = (undefined1 *)\n               FUN_001123c0(*(long *)(param_1 + 0x20),auStack_2b8,param_3,&DAT_0011bdd6);\n    }\n    uVar5 = 0;\n    if (DAT_00127338 != 4) {\n      uVar5 = DAT_00127360;\n    }\n    __printf_chk(1,&DAT_0011bde8,uVar5,puVar4);\n  }\n  if (DAT_0012732c != '\\0') {\n    puVar4 = &DAT_0011bdd6;\n    if (*(char *)(param_1 + 0xb8) != '\\0') {\n      puVar4 = (undefined1 *)\n               FUN_001111e0(*(undefined8 *)(param_1 + 0x58),auStack_2b8,DAT_00127328,0x200,\n                            DAT_00127320);\n    }\n    uVar5 = 0;\n    if (DAT_00127338 != 4) {\n      uVar5 = DAT_0012735c;\n    }\n    __printf_chk(1,&DAT_0011bde8,uVar5,puVar4);\n  }\n  if (DAT_00127365 != '\\0') {\n    uVar5 = 0;\n    if (DAT_00127338 != 4) {\n      uVar5 = DAT_00127354;\n    }\n    __printf_chk(1,&DAT_0011bde8,uVar5,*(undefined8 *)(param_1 + 0xb0));\n  }\n  FUN_0010bf80(param_1,0,0,param_2);\n  if (DAT_00127314 != 0) {\n    bVar3 = FUN_00107670(*(undefined *)(param_1 + 0xb8),*(undefined4 *)(param_1 + 0x30),\n                         *(undefined4 *)(param_1 + 0xa8));\n    if (bVar3 != 0) {\n      DAT_001271f8 = DAT_001271f8 + 1;\n      pbVar1 = (byte *)stdout->_IO_write_ptr;\n      if (pbVar1 < stdout->_IO_write_end) {\n        stdout->_IO_write_ptr = (char *)(pbVar1 + 1);\n        *pbVar1 = bVar3;\n      }\n      else {\n        __overflow(stdout,(uint)bVar3);\n      }\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_0010d640": "\nvoid FUN_0010d640(char *param_1,char *param_2,undefined param_3)\n\n{\n  undefined8 uVar1;\n  char **ppcVar2;\n  char **ppcVar3;\n  char cVar4;\n  byte bVar5;\n  int iVar6;\n  int *piVar7;\n  DIR *__dirp;\n  undefined8 *puVar8;\n  undefined8 *puVar9;\n  undefined8 uVar10;\n  dirent *pdVar11;\n  void *__ptr;\n  char *pcVar12;\n  size_t sVar13;\n  long lVar14;\n  undefined4 uVar15;\n  long in_FS_OFFSET;\n  bool bVar16;\n  long local_378;\n  undefined8 local_368;\n  undefined8 local_360;\n  undefined local_2d7 [663];\n  long local_40;\n  \n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar7 = __errno_location();\n  *piVar7 = 0;\n  __dirp = opendir(param_1);\n  if (__dirp == (DIR *)0x0) {\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      FUN_00107600(param_3,\"cannot open directory %s\",param_1);\n      return;\n    }\n    goto LAB_0010dc73;\n  }\n  if (DAT_001273c8 != 0) {\n    iVar6 = dirfd(__dirp);\n    if (iVar6 < 0) {\n      iVar6 = FUN_00107110(0xffffff9c,param_1,&local_368,0,0x100);\n      uVar10 = local_368;\n      uVar1 = local_360;\n    }\n    else {\n      iVar6 = FUN_00107110(iVar6,&DAT_0011bdd5,&local_368,0x1000,0x100);\n      uVar10 = local_368;\n      uVar1 = local_360;\n    }\n    if (iVar6 < 0) {\n      FUN_00107600(param_3,\"cannot determine device and inode of %s\",param_1);\n      if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n        closedir(__dirp);\n        return;\n      }\n      goto LAB_0010dc73;\n    }\n    puVar8 = (undefined8 *)FUN_00117e10(0x10);\n    lVar14 = DAT_001273c8;\n    puVar8[1] = uVar10;\n    *puVar8 = uVar1;\n    puVar9 = (undefined8 *)FUN_00110f50(lVar14,puVar8);\n    if (puVar9 == (undefined8 *)0x0) {\n                    /* WARNING: Subroutine does not return */\n      FUN_00118390();\n    }\n    if (puVar8 != puVar9) {\n      free(puVar8);\n      uVar10 = FUN_00116d80(0,3,param_1);\n      error(0,0,\"%s: not listing already-listed directory\",uVar10);\n      closedir(__dirp);\n      DAT_00127210 = 2;\n      goto LAB_0010d764;\n    }\n    puVar8 = DAT_001270f8;\n    if ((ulong)(DAT_00127100 - (long)DAT_001270f8) < 0x10) {\n      _obstack_newchunk(&DAT_001270e0,0x10);\n      puVar8 = DAT_001270f8;\n    }\n    DAT_001270f8 = puVar8 + 2;\n    puVar8[1] = uVar10;\n    *puVar8 = uVar1;\n  }\n  FUN_001086e0();\n  cVar4 = DAT_00127318;\n  if (DAT_001272f6 == '\\0') {\n    if (DAT_001272b8 == '\\0') goto LAB_0010d84b;\n    if (DAT_00126010 == '\\0') goto LAB_0010d904;\nLAB_0010d7de:\n    DAT_00126010 = '\\0';\n    cVar4 = DAT_00127318;\n  }\n  else {\n    if (DAT_00126010 != '\\0') goto LAB_0010d7de;\nLAB_0010d904:\n    DAT_001271f8 = DAT_001271f8 + 1;\n    pcVar12 = stdout->_IO_write_ptr;\n    if (stdout->_IO_write_end <= pcVar12) {\n      __overflow(stdout,10);\n      goto LAB_0010d7de;\n    }\n    DAT_00126010 = '\\0';\n    stdout->_IO_write_ptr = pcVar12 + 1;\n    *pcVar12 = '\\n';\n  }\n  if (cVar4 != '\\0') {\n    FUN_001074f0(&DAT_0011bde0,2);\n  }\n  __ptr = (void *)0x0;\n  if ((DAT_00127311 != '\\0') && (__ptr = (void *)FUN_0010eae0(param_1,2), __ptr == (void *)0x0)) {\n    FUN_00107600(param_3,\"error canonicalizing %s\",param_1);\n  }\n  if (param_2 == (char *)0x0) {\n    param_2 = param_1;\n  }\n  FUN_0010bb80(param_2,DAT_001272c8,0xffffffff,0,1,&DAT_00127140,__ptr);\n  free(__ptr);\n  FUN_001074f0(\":\\n\",2);\nLAB_0010d84b:\n  local_378 = 0;\n  do {\n    *piVar7 = 0;\n    pdVar11 = readdir(__dirp);\n    if (pdVar11 == (dirent *)0x0) {\n      if ((*piVar7 == 0) || (FUN_00107600(param_3,\"reading directory %s\",param_1), *piVar7 != 0x4b))\n      break;\n    }\n    else {\n      pcVar12 = pdVar11->d_name;\n      ppcVar3 = DAT_001272e8;\n      if (DAT_001272f0 != 2) {\n        if (pdVar11->d_name[0] == '.') {\n          if ((DAT_001272f0 == 0) ||\n             (pdVar11->d_name[(ulong)(pdVar11->d_name[1] == '.') + 1] == '\\0')) goto LAB_0010d8e0;\n        }\n        else {\n          ppcVar2 = DAT_001272e0;\n          if (DAT_001272f0 == 0) {\n            for (; ppcVar3 = DAT_001272e8, ppcVar2 != (char **)0x0; ppcVar2 = (char **)ppcVar2[1]) {\n              iVar6 = fnmatch(*ppcVar2,pcVar12,4);\n              if (iVar6 == 0) goto LAB_0010d8e0;\n            }\n          }\n        }\n      }\n      for (; ppcVar3 != (char **)0x0; ppcVar3 = (char **)ppcVar3[1]) {\n        iVar6 = fnmatch(*ppcVar3,pcVar12,4);\n        if (iVar6 == 0) goto LAB_0010d8e0;\n      }\n      uVar15 = 0;\n      bVar5 = pdVar11->d_type - 1;\n      if (bVar5 < 0xe) {\n        uVar15 = *(undefined4 *)(&DAT_0011a600 + (ulong)bVar5 * 4);\n      }\n      lVar14 = FUN_00109620(pcVar12,uVar15,0,param_1);\n      local_378 = local_378 + lVar14;\n      if ((((DAT_00127338 == 1) && (DAT_00127330 == 6)) && (DAT_0012732c == '\\0')) &&\n         (DAT_001272f6 == '\\0')) {\n        FUN_00108d50();\n        FUN_0010d240();\n        FUN_001086e0();\n      }\n    }\nLAB_0010d8e0:\n    FUN_00108590();\n  } while( true );\n  iVar6 = closedir(__dirp);\n  if (iVar6 != 0) {\n    FUN_00107600(param_3,\"closing directory %s\",param_1);\n  }\n  FUN_00108d50();\n  if (DAT_001272f6 != '\\0') {\n    FUN_00109440(param_1,0);\n  }\n  if ((DAT_00127338 == 0) || (DAT_0012732c != '\\0')) {\n    pcVar12 = (char *)FUN_001111e0(local_378,local_2d7,DAT_00127328,0x200,DAT_00127320);\n    sVar13 = strlen(pcVar12);\n    cVar4 = DAT_00126019;\n    pcVar12[-1] = ' ';\n    bVar16 = DAT_00127318 != '\\0';\n    pcVar12[sVar13] = cVar4;\n    if (bVar16) {\n      FUN_001074f0(&DAT_0011bde0,2);\n    }\n    FUN_001074f0(\"total\",5);\n    FUN_001074f0(pcVar12 + -1,pcVar12 + sVar13 + (1 - (long)(pcVar12 + -1)));\n  }\n  if (DAT_001273b0 != 0) {\n    if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n      FUN_0010d240();\n      return;\n    }\n    goto LAB_0010dc73;\n  }\nLAB_0010d764:\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\nLAB_0010dc73:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001167d0": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_001167d0(void)\n\n{\n  void **ppvVar1;\n  void *__ptr;\n  undefined *__ptr_00;\n  void **ppvVar2;\n  \n  __ptr_00 = PTR_DAT_00126260;\n  if (1 < DAT_00126258) {\n    ppvVar2 = (void **)(PTR_DAT_00126260 + 0x18);\n    ppvVar1 = (void **)(PTR_DAT_00126260 + (ulong)(DAT_00126258 - 2) * 0x10 + 0x28);\n    do {\n      __ptr = *ppvVar2;\n      ppvVar2 = ppvVar2 + 2;\n      free(__ptr);\n    } while (ppvVar2 != ppvVar1);\n  }\n  if (*(undefined **)(__ptr_00 + 8) != &DAT_00127420) {\n    free(*(undefined **)(__ptr_00 + 8));\n    PTR_DAT_00126278 = &DAT_00127420;\n    _DAT_00126270 = 0x100;\n  }\n  if (__ptr_00 != &DAT_00126270) {\n    free(__ptr_00);\n    PTR_DAT_00126260 = &DAT_00126270;\n  }\n  DAT_00126258 = 1;\n  return;\n}\n\n",
  "FUN_0010a8b0": "\nint FUN_0010a8b0(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int iVar5;\n  \n  iVar5 = *(int *)(param_1 + 0x15);\n  if (((*(int *)(param_2 + 0x15) == 3) || (*(int *)(param_2 + 0x15) == 9)) ||\n     ((*(uint *)((long)param_2 + 0xac) & 0xf000) == 0x4000)) {\n    if (iVar5 == 9 || iVar5 == 3) goto LAB_0010a930;\n    iVar5 = 1;\n  }\n  else {\n    if (iVar5 == 9 || iVar5 == 3) {\n      return -1;\n    }\n    iVar5 = 0;\n  }\n  iVar5 = iVar5 - (uint)((*(uint *)((long)param_1 + 0xac) & 0xf000) == 0x4000);\n  if (iVar5 != 0) {\n    return iVar5;\n  }\nLAB_0010a930:\n  pcVar1 = param_1[0xe];\n  pcVar2 = param_2[0xe];\n  pcVar3 = param_1[0xf];\n  pcVar4 = param_2[0xf];\n  iVar5 = ((uint)((long)pcVar4 < (long)pcVar3) -\n          (uint)(param_2[0xf] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n          ((uint)((long)pcVar2 < (long)pcVar1) -\n          (uint)(param_2[0xe] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2;\n  if (iVar5 != 0) {\n    return iVar5;\n  }\n  iVar5 = strcmp(*param_2,*param_1);\n  return iVar5;\n}\n\n",
  "snprintf": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint snprintf(char *__s,size_t __maxlen,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_snprintf_00125da8)();\n  return iVar1;\n}\n\n",
  "reallocarray": "\nvoid reallocarray(void)\n\n{\n  (*(code *)PTR_reallocarray_00125d10)();\n  return;\n}\n\n",
  "FUN_00108c00": "\nvoid FUN_00108c00(char **param_1,char **param_2)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  char *pcVar4;\n  int *piVar5;\n  \n  pcVar1 = param_2[0xc];\n  pcVar2 = param_1[0xc];\n  pcVar3 = param_2[0xd];\n  pcVar4 = param_1[0xd];\n  if (((uint)((long)pcVar4 < (long)pcVar3) -\n      (uint)(param_1[0xd] != pcVar3 && (long)pcVar3 <= (long)pcVar4)) +\n      ((uint)((long)pcVar2 < (long)pcVar1) -\n      (uint)(param_1[0xc] != pcVar1 && (long)pcVar1 <= (long)pcVar2)) * 2 == 0) {\n    pcVar1 = *param_1;\n    pcVar2 = *param_2;\n    piVar5 = __errno_location();\n    *piVar5 = 0;\n    strcoll(pcVar1,pcVar2);\n    return;\n  }\n  return;\n}\n\n",
  "__mbstowcs_chk": "\nvoid __mbstowcs_chk(void)\n\n{\n  (*(code *)PTR___mbstowcs_chk_00125ce8)();\n  return;\n}\n\n",
  "fwrite": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = (*(code *)PTR_fwrite_00125f48)();\n  return sVar1;\n}\n\n",
  "FUN_0010e860": "\nlong FUN_0010e860(undefined8 param_1,char *param_2,char **param_3,undefined8 param_4,\n                 undefined8 param_5,code *param_6,char param_7)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  long lVar5;\n  \n  if (param_7 == '\\0') {\n    lVar5 = 0;\n    pcVar4 = *param_3;\n    while (pcVar4 != (char *)0x0) {\n      iVar1 = strcmp(pcVar4,param_2);\n      if (iVar1 == 0) {\n        return lVar5;\n      }\n      lVar5 = lVar5 + 1;\n      pcVar4 = param_3[lVar5];\n    }\n    pcVar4 = \"invalid argument %s for %s\";\n  }\n  else {\n    lVar5 = FUN_0010e570(param_2,param_3,param_4,param_5);\n    if (-1 < lVar5) {\n      return lVar5;\n    }\n    pcVar4 = \"ambiguous argument %s for %s\";\n    if (lVar5 == -1) {\n      pcVar4 = \"invalid argument %s for %s\";\n    }\n  }\n  uVar2 = FUN_001170e0(1,param_1);\n  uVar3 = FUN_001168e0(0,8,param_2);\n  error(0,0,pcVar4,uVar3,uVar2);\n  FUN_0010e740(param_3,param_4,param_5);\n  (*param_6)();\n  return -1;\n}\n\n",
  "FUN_00107350": "\nvoid FUN_00107350(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_001072b0(param_1,param_2,PTR_strcmp_00125fc8);\n  return;\n}\n\n",
  "FUN_0010e740": "\nvoid FUN_0010e740(long *param_1,void *param_2,size_t param_3)\n\n{\n  long lVar1;\n  char *pcVar2;\n  int iVar3;\n  undefined8 uVar4;\n  long lVar5;\n  void *__s1;\n  \n  __s1 = (void *)0x0;\n  fwrite_unlocked(\"Valid arguments are:\",1,0x14,stderr);\n  lVar5 = 0;\n  lVar1 = *param_1;\n  while (lVar1 != 0) {\n    if ((lVar5 == 0) || (iVar3 = memcmp(__s1,param_2,param_3), iVar3 != 0)) {\n      uVar4 = FUN_00117100(lVar1);\n      __fprintf_chk(stderr,1,\"\\n  - %s\",uVar4);\n      __s1 = param_2;\n    }\n    else {\n      uVar4 = FUN_00117100(lVar1);\n      __fprintf_chk(stderr,1,&DAT_0011e5d9,uVar4);\n    }\n    lVar5 = lVar5 + 1;\n    param_2 = (void *)((long)param_2 + param_3);\n    lVar1 = param_1[lVar5];\n  }\n  pcVar2 = stderr->_IO_write_ptr;\n  if (pcVar2 < stderr->_IO_write_end) {\n    stderr->_IO_write_ptr = pcVar2 + 1;\n    *pcVar2 = '\\n';\n    return;\n  }\n  __overflow(stderr,10);\n  return;\n}\n\n",
  "FUN_00118c40": "\nint * FUN_00118c40(code *param_1,long *param_2,int *param_3)\n\n{\n  int *piVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  long lVar5;\n  long in_FS_OFFSET;\n  int local_94;\n  int local_90;\n  int local_8c;\n  undefined8 local_88;\n  int local_80;\n  int local_7c;\n  int local_78;\n  int local_74;\n  int local_70;\n  int local_6c;\n  undefined8 local_68;\n  int *local_60;\n  long local_48;\n  long local_40;\n  \n  lVar5 = *param_2;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48 = lVar5;\n  local_60 = (int *)(*param_1)(&local_48,param_3);\n  if (local_60 == (int *)0x0) {\n    piVar1 = __errno_location();\n    if (((*piVar1 == 0x4b) && (lVar3 = (ulong)((uint)lVar5 & 1) + (lVar5 >> 1), lVar5 != lVar3)) &&\n       (lVar3 != 0)) {\n      lVar4 = 0;\n      local_94 = -1;\n      do {\n        local_48 = lVar3;\n        lVar2 = (*param_1)(&local_48,param_3);\n        if (lVar2 == 0) {\n          lVar5 = lVar3;\n          if (*piVar1 != 0x4b) goto LAB_00118c8e;\n        }\n        else {\n          local_94 = *param_3;\n          local_6c = param_3[1];\n          local_70 = param_3[2];\n          local_74 = param_3[3];\n          local_78 = param_3[4];\n          local_8c = param_3[5];\n          local_80 = param_3[6];\n          local_7c = param_3[7];\n          local_90 = param_3[8];\n          local_88 = *(undefined8 *)(param_3 + 10);\n          local_68 = *(undefined8 *)(param_3 + 0xc);\n          lVar4 = lVar3;\n        }\n        lVar3 = (lVar4 >> 1) + (lVar5 >> 1) + (ulong)(((uint)lVar4 | (uint)lVar5) & 1);\n      } while ((lVar3 != lVar4) && (lVar3 != lVar5));\n      if (-1 < local_94) {\n        *param_2 = lVar4;\n        *param_3 = local_94;\n        param_3[1] = local_6c;\n        param_3[2] = local_70;\n        param_3[3] = local_74;\n        param_3[4] = local_78;\n        param_3[5] = local_8c;\n        param_3[6] = local_80;\n        param_3[7] = local_7c;\n        param_3[8] = local_90;\n        *(undefined8 *)(param_3 + 10) = local_88;\n        *(undefined8 *)(param_3 + 0xc) = local_68;\n        local_60 = param_3;\n      }\n    }\n  }\n  else {\n    *param_2 = lVar5;\n  }\nLAB_00118c8e:\n  if (local_40 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_60;\n}\n\n",
  "FUN_00117c70": "\nvoid FUN_00117c70(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,undefined8 param_6)\n\n{\n  long lVar1;\n  ulong uVar2;\n  long *plVar3;\n  long lVar4;\n  long in_FS_OFFSET;\n  long local_98 [11];\n  long local_40;\n  long local_38 [4];\n  long local_18 [2];\n  \n  uVar2 = 0x20;\n  local_18[0] = param_5;\n  plVar3 = (long *)&stack0x00000008;\n  local_18[1] = param_6;\n  lVar4 = 0;\n  local_40 = *(long *)(in_FS_OFFSET + 0x28);\n  do {\n    if ((uint)uVar2 < 0x30) {\n      lVar1 = *(long *)((long)local_38 + uVar2);\n      local_98[lVar4] = lVar1;\n      uVar2 = (ulong)((uint)uVar2 + 8);\n    }\n    else {\n      lVar1 = *plVar3;\n      local_98[lVar4] = lVar1;\n      plVar3 = plVar3 + 1;\n    }\n  } while ((lVar1 != 0) && (lVar4 = lVar4 + 1, lVar4 != 10));\n  FUN_00117920(param_1,param_2,param_3);\n  if (local_40 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "FUN_001177b0": "\nundefined8 FUN_001177b0(long param_1,undefined8 *param_2)\n\n{\n  char cVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 local_68;\n  undefined8 uStack_60;\n  undefined8 local_58;\n  undefined4 uStack_50;\n  int iStack_4c;\n  undefined4 local_48;\n  undefined4 uStack_44;\n  undefined4 uStack_40;\n  undefined4 uStack_3c;\n  undefined8 local_38;\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 == 0) {\n    if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n      uVar3 = FUN_00117900(param_2);\n      return uVar3;\n    }\n    goto LAB_001178f5;\n  }\n  lVar2 = FUN_001175c0();\n  if (lVar2 == 0) {\nLAB_00117840:\n    uVar3 = 0xffffffffffffffff;\n  }\n  else {\n    local_68 = *param_2;\n    iStack_4c = -1;\n    uStack_60 = param_2[1];\n    local_58 = param_2[2];\n    local_48 = *(undefined4 *)(param_2 + 4);\n    uVar3 = FUN_001193f0(&local_68);\n    if ((iStack_4c < 0) || (cVar1 = FUN_00117490(param_1,&local_68), cVar1 == '\\0')) {\n      if (lVar2 != 1) {\n        FUN_00117360(lVar2);\n      }\n      goto LAB_00117840;\n    }\n    if ((lVar2 != 1) && (cVar1 = FUN_00117360(lVar2), cVar1 == '\\0')) goto LAB_00117840;\n    *(undefined4 *)param_2 = (undefined4)local_68;\n    *(undefined4 *)((long)param_2 + 4) = local_68._4_4_;\n    *(undefined4 *)(param_2 + 1) = (undefined4)uStack_60;\n    *(undefined4 *)((long)param_2 + 0xc) = uStack_60._4_4_;\n    param_2[6] = local_38;\n    *(undefined4 *)(param_2 + 2) = (undefined4)local_58;\n    *(undefined4 *)((long)param_2 + 0x14) = local_58._4_4_;\n    *(undefined4 *)(param_2 + 3) = uStack_50;\n    *(int *)((long)param_2 + 0x1c) = iStack_4c;\n    *(undefined4 *)(param_2 + 4) = local_48;\n    *(undefined4 *)((long)param_2 + 0x24) = uStack_44;\n    *(undefined4 *)(param_2 + 5) = uStack_40;\n    *(undefined4 *)((long)param_2 + 0x2c) = uStack_3c;\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\nLAB_001178f5:\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n",
  "unsetenv": "\n/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n\nint unsetenv(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = (*(code *)PTR_unsetenv_00125f18)();\n  return iVar1;\n}\n\n",
  "FUN_00107110": "\nvoid FUN_00107110(undefined8 param_1,undefined8 param_2,ulong *param_3,uint param_4,uint param_5)\n\n{\n  int iVar1;\n  long in_FS_OFFSET;\n  undefined uStack_128;\n  byte local_127;\n  uint local_124;\n  uint local_118;\n  undefined8 local_114;\n  ushort local_10c;\n  ulong local_108;\n  ulong local_100;\n  ulong local_f8;\n  ulong local_e8;\n  uint local_e0;\n  ulong local_d8;\n  uint local_d0;\n  ulong local_c8;\n  uint local_c0;\n  ulong local_b8;\n  uint local_b0;\n  uint local_a8;\n  uint local_a4;\n  uint local_a0;\n  uint local_9c;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = statx(param_1,param_2,param_4 | 0x800,param_5,&uStack_128);\n  if (-1 < iVar1) {\n    *param_3 = ((ulong)local_9c & 0xffffff00) << 0xc |\n               ((ulong)local_a0 & 0xfffff000) << 0x20 | (ulong)((local_a0 & 0xfff) << 8) |\n               (ulong)(byte)local_9c;\n    param_3[2] = (ulong)local_118;\n    param_3[1] = local_108;\n    *(uint *)(param_3 + 3) = (uint)local_10c;\n    *(undefined8 *)((long)param_3 + 0x1c) = local_114;\n    param_3[5] = ((ulong)local_a4 & 0xffffff00) << 0xc |\n                 ((ulong)local_a8 & 0xfffff000) << 0x20 | (ulong)((local_a8 & 0xfff) << 8) |\n                 (ulong)(byte)local_a4;\n    param_3[7] = (ulong)local_124;\n    param_3[6] = local_100;\n    param_3[10] = (ulong)local_e0;\n    param_3[8] = local_f8;\n    param_3[0xc] = (ulong)local_b0;\n    param_3[9] = local_e8;\n    param_3[0xe] = (ulong)local_c0;\n    param_3[0xb] = local_b8;\n    param_3[0xd] = local_c8;\n    if ((param_5 & 0x800) != 0) {\n      if ((local_127 & 8) == 0) {\n        param_3[0xc] = 0xffffffffffffffff;\n        param_3[0xb] = 0xffffffffffffffff;\n      }\n      else {\n        param_3[0xb] = local_d8;\n        param_3[0xc] = (ulong)local_d0;\n      }\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}\n\n"
}