{
  "pr": "6718",
  "mean_delta_perplexity": 0.005625,
  "mean_perplexity_base": 2.0253125,
  "mean_perplexity_pr": 2.0309375,
  "mean_perplexity_source": 2.2884375,
  "mean_perplexity_base_ast": 2.366875,
  "mean_perplexity_pr_ast": 2.3675,
  "mean_perplexity_source_ast": 2.6875,
  "results": {
    "qwen-coder": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.0,
          "pr_ppl": 2.0,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.1875,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and follows a more structured approach with clear variable names and logical flow compared to Candidate A, which appears to be a direct translation from assembly or another obfuscated source.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 2.0,
          "pr_ppl": 2.0,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.1875,
          "pr_ast_ppl": 2.1875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a more structured approach with meaningful variable names and improved readability, making it more human-like compared to Candidate A's cluttered and less organized code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.484375,
          "base_ppl": 1.96875,
          "pr_ppl": 1.96875,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 2.3125,
          "pr_ast_ppl": 2.3125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a more structured approach with clear variable names and logical organization, making it more human-readable compared to Candidate A which closely follows the assembly-like structure of the original code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of standard loop constructs and clear logical flow compared to the complex nested structures in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.7734375,
          "pr_ppl": 1.765625,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.703125,
          "pr_ast_ppl": 2.703125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is a direct copy of the ground truth code, maintaining all the same variable names, logic structure, and control flow as the original. While Candidate B attempts to refactor and improve the readability, it introduces additional complexity and changes that deviate from the original intent.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9375,
          "pr_ppl": 1.9296875,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of meaningful variable names, structured control flow, and clear logic, making it easier to understand and maintain compared to the less readable and repetitive structure of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.9453125,
          "pr_ppl": 1.9453125,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 3.078125,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.890625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.7109375,
          "source_ast_ppl": 2.453125,
          "base_ast_ppl": 2.453125,
          "pr_ast_ppl": 2.453125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured and readable approach with clear function definitions, meaningful variable names, and proper use of control structures. While both candidates perform the same operations, Candidate B's adherence to standard coding practices makes it easier for human developers to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined1 uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.96875,
          "base_ppl": 1.734375,
          "pr_ppl": 1.734375,
          "source_ast_ppl": 3.078125,
          "base_ast_ppl": 2.921875,
          "pr_ast_ppl": 2.921875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its structured loop constructs, clear function definitions, and adherence to common coding practices. It also includes comments that make the logic easier to understand compared to Candidate A's unstructured approach.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.296875,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear variable names and proper indentation, making it easier for a human developer to understand and maintain. While both candidates are functionally equivalent, Candidate B adheres better to idiomatic C coding practices.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.6640625,
          "base_ppl": 2.28125,
          "pr_ppl": 2.296875,
          "source_ast_ppl": 2.09375,
          "base_ast_ppl": 3.109375,
          "pr_ast_ppl": 3.109375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its structured loop and cleaner logic, despite minor syntax differences.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 3.359375,
          "pr_ast_ppl": 3.359375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and follows better coding practices with clearer variable names and structured logic, making it easier for humans to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.734375,
          "base_ppl": 2.234375,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.25,
          "base_ast_ppl": 3.359375,
          "pr_ast_ppl": 3.359375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses more descriptive variable names and follows a structured approach that is easier for a human developer to understand compared to Candidate A's verbose and less readable code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 6.46875,
          "base_ast_ppl": 3.03125,
          "pr_ast_ppl": 2.9375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses standard loop constructs and clear logical structures, making it more human-readable and easier to understand compared to Candidate A's repetitive `goto` statements.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates have identical AST structures, but Candidate A contains unnecessary nested loops and goto statements compared to Candidate B. Therefore, Candidate B is considered more topologically closer to the source.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.125,
          "base_ppl": 1.8046875,
          "pr_ppl": 1.796875,
          "source_ast_ppl": 6.46875,
          "base_ast_ppl": 3.03125,
          "pr_ast_ppl": 2.9375,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a cleaner structure and follows idiomatic C programming practices, making it more readable and maintainable compared to Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates have similar structures but Candidate A contains an unnecessary 'switch' statement and multiple 'case' labels without actual content, adding complexity. This makes it less topologically close to the source code.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 2.234375,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 3.234375,
          "base_ast_ppl": 3.75,
          "pr_ast_ppl": 3.75,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear variable names and logical flow, making it easier to understand compared to the heavily obfuscated Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 2.21875,
          "base_ppl": 2.234375,
          "pr_ppl": 2.234375,
          "source_ast_ppl": 3.234375,
          "base_ast_ppl": 3.75,
          "pr_ast_ppl": 3.75,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its structured use of standard control flow constructs (if-else statements, loops) and clear variable names, which makes it easier for developers to understand and maintain compared to the nested and obfuscated nature of Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.46875,
          "pr_ppl": 2.46875,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 3.484375,
          "pr_ast_ppl": 3.484375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a more structured and readable code with standard loops and clear logic, making it easier to understand compared to Candidate A which uses conditional statements within loops that are less intuitive.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.46875,
          "pr_ppl": 2.46875,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 3.484375,
          "pr_ast_ppl": 3.484375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear variable names and standard loop constructs, making it easier to understand compared to the convoluted logic in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  call(, , )\n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        call(, , )\n        call(, )\n      }\n    }else{\n      call(, , )\n      if(){\n        \n        if(){\n          call(, , )\n          call(, )\n        }\n      }else{\n        call(, , , )\n        if(){\n          \n          \n          \n          call()\n          \n          \n          \n          \n          \n          \n          \n          if(){\n            \n          }\n          \n          \n          \n          \n          if(){\n            \n          }\n          call()\n          \n          if(){\n            \n          }else{\n            if(call(, )){\n              call(, )\n              if(){\n                \n                goto label\n              }\n              \n            }\n            call(, , , , )\n            if(call(, )call(, )){\n              call(, , )\n              if(){\n                \n                if(){\n                  call(, , , )\n                  call(, )\n                }\n              }else{\n                call()\n                if(call(, )){\n                  if(){\n                    call()\n                  }else{\n                    \n                    if(){\n                      call(, , , , )\n                      call(, )\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  call()\n  if(){\n    call()\n    call()\n    call()\n    call()\n    call(, , , , , , )\n    call(, )\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  call(, , )\n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        call(, , )\n        call(, )\n      }\n    }else{\n      call(, , )\n      if(){\n        \n        if(){\n          call(, , )\n          call(, )\n        }\n      }else{\n        call(, , , )\n        if(){\n          \n          \n          \n          call()\n          \n          \n          \n          \n          \n          \n          \n          if(){\n            \n          }\n          \n          \n          \n          \n          if(){\n            \n          }\n          call()\n          \n          if(){\n            \n          }else{\n            if(call(, )){\n              call(, )\n              if(){\n                \n                goto label\n              }\n              \n            }\n            call(, , , , )\n            if(call(, )call(, )){\n              call(, , )\n              if(){\n                \n                if(){\n                  call(, , , )\n                  call(, )\n                }\n              }else{\n                call()\n                if(call(, )){\n                  if(){\n                    call()\n                  }else{\n                    \n                    if(){\n                      call(, , , , )\n                      call(, )\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  call()\n  if(){\n    call()\n    call()\n    call()\n    call()\n    call(, , , , , , )\n    call(, )\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 1.8125,
          "pr_ppl": 1.8046875,
          "source_ast_ppl": 2.546875,
          "base_ast_ppl": 2.65625,
          "pr_ast_ppl": 2.65625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured approach with clear variable names, function calls, and a cleaner overall control flow, making it easier for a human developer to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O2.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 1.9453125,
          "pr_ppl": 1.9375,
          "source_ast_ppl": 2.546875,
          "base_ast_ppl": 2.890625,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O3.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.046875,
          "base_ppl": 1.9453125,
          "pr_ppl": 1.9375,
          "source_ast_ppl": 2.546875,
          "base_ast_ppl": 2.890625,
          "pr_ast_ppl": 2.890625,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O0.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  int iVar3;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar3 = -*(int *)(compr + local_38 * 0x20 + 8);\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (-1 < iVar3) {\n        iVar1 = iVar3;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (iVar1 < 1) {\n        iVar1 = -iVar1;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    \n    \n    for(;;){\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n        }else{\n          call(, , )\n          call()\n        }\n        if(){\n          if(){\n            call(, , )\n            \n            call(, , )\n            call()\n          }\n          \n          call()\n          call(, , , , , , )\n          if(){\n            if()goto label\n            if(){\n              \n              call()\n            }\n          }\n          \n          if(){\n            call(, , )\n          }else{\n            call(, , , , , )\n          }\n          if(){\n            \n            if()\n            call()\n            if(call()){\n              call(, , , , , )\n              if(){\n                call()\n                if(){\n                  \n                  call()\n                }\n              }else{\n                call()\n                if(){\n                  call(, , )\n                  if(){\n                    call()\n                    goto label\n                  }\n                  call()\n                }\n                if(call())goto label\n              }\n            }\n          }\n          \n        }\n      }\n      \n    }\n    if(){\n      call(, , )\n    }\n    call()\n    \n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    \n    \n    for(;;){\n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n        }else{\n          call(, , )\n          call()\n        }\n        if(){\n          if(){\n            call(, , )\n            \n            call(, , )\n            call()\n          }\n          \n          call()\n          call(, , , , , , )\n          if(){\n            if()goto label\n            if(){\n              \n              call()\n            }\n          }\n          \n          if(){\n            call(, , )\n          }else{\n            call(, , , , , )\n          }\n          if(){\n            \n            if()\n            call()\n            if(call()){\n              call(, , , , , )\n              if(){\n                call()\n                if(){\n                  \n                  call()\n                }\n              }else{\n                call()\n                if(){\n                  call(, , )\n                  if(){\n                    call()\n                    goto label\n                  }\n                  call()\n                }\n                if(call())goto label\n              }\n            }\n          }\n          \n        }\n      }\n      \n    }\n    if(){\n      call(, , )\n    }\n    call()\n    \n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.15625,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 3.40625,
          "pr_ast_ppl": 3.390625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows a more structured and readable approach with clear variable names and logical flow, making it easier to understand compared to the spaghetti code in Candidate A.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates have the same structure, but Candidate A matches the Source more closely in terms of loop types and nesting depth.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_checkfmt-O2.so",
        "function": "file_checkfmt",
        "source_code": "file_protected int\nfile_checkfmt(char *msg, size_t mlen, const char *fmt)\n{\n\tconst char *p;\n\tfor (p = fmt; *p; p++) {\n\t\tif (*p != '%')\n\t\t\tcontinue;\n\t\tif (*++p == '%')\n\t\t\tcontinue;\n\t\tif (*p == '\\0') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"incomplete %% format\");\n\t\t\treturn -1;\n\t\t}\n\t\t// Skip uninteresting.\n\t\twhile (*p != '\\0' && strchr(\"#0.'+- \", *p) != NULL)\n\t\t\tp++;\n\t\tif (*p == '*') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"* not allowed in format\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!file_checkfield(msg, mlen, \"width\", &p))\n\t\t\treturn -1;\n\n\t\tif (*p == '.') {\n\t\t\tp++;\n\t\t\tif (!file_checkfield(msg, mlen, \"precision\", &p))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!isalpha((unsigned char)*p)) {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"bad format char: %c\", *p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "function_base": "\nundefined8 file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    for (; *param_3 != 0x25; param_3 = param_3 + 1) {\n      if (*param_3 == 0) {\n        return 0;\n      }\nLAB_0010122d:\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        __format = \"incomplete %% format\";\nLAB_00101278:\n        snprintf(param_1,param_2,__format);\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "function_pr": "\nulong file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    while( true ) {\n      bVar3 = *param_3;\n      if (bVar3 == 0x25) break;\n      if (bVar3 == 0) {\n        return (ulong)bVar3;\n      }\nLAB_0010122d:\n      param_3 = param_3 + 1;\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 != (char *)0x0) {\n          __format = \"incomplete %% format\";\nLAB_00101278:\n          snprintf(param_1,param_2,__format);\n        }\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  for(;;){\n    if()\n    if()\n    if(){\n      if()call(, , )\n      return\n    }\n    \n    while(call(, ))\n    if(){\n      if()call(, , )\n      return\n    }\n    if(call(, , , ))return\n    if(){\n      \n      if(call(, , , ))return\n    }\n    if(call()){\n      if()call(, , , )\n      return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  for(;;){\n    if(){\n      return\n    }\n    \n    \n    if(){\n      if(){\n        if(){\n          return\n        }\n        \n        call(, , )\n        return\n      }\n      do{\n        if(){\n          if(){\n            if(){\n              return\n            }\n            \n            goto label\n          }\n          \n        }\n        \n        \n      }while()\n      call(, , , )\n      if(){\n        return\n      }\n      \n      if(){\n        \n        call(, , , )\n        if(){\n          return\n        }\n        \n      }\n      \n      call()\n      if(){\n        if(){\n          return\n        }\n        call(, , , )\n        return\n      }\n      goto label\n    }\n    \n  }\n  while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  do{\n    while(){\n      \n      if()\n      if(){\n        return\n      }\n      \n    }\n    \n    \n    if(){\n      if(){\n        if(){\n          \n          call(, , )\n        }\n        return\n      }\n      do{\n        if(){\n          if(){\n            if(){\n              return\n            }\n            \n            goto label\n          }\n          \n        }\n        \n        \n      }while()\n      call(, , , )\n      if(){\n        return\n      }\n      \n      if(){\n        \n        call(, , , )\n        if(){\n          return\n        }\n        \n      }\n      \n      call()\n      if(){\n        if(){\n          return\n        }\n        call(, , , )\n        return\n      }\n      goto label\n    }\n    \n  }while()\n}",
        "metrics": {
          "source_ppl": 2.5625,
          "base_ppl": 2.21875,
          "pr_ppl": 2.21875,
          "source_ast_ppl": 4.53125,
          "base_ast_ppl": 3.65625,
          "pr_ast_ppl": 3.59375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B follows standard loop structures and idiomatic C practices, making it more human-readable and easier to understand compared to Candidate A's use of nested goto statements.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A correctly recovers the original source's loop structure without introducing unnecessary complexity.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_getbuffer-O2.so",
        "function": "file_getbuffer",
        "source_code": "file_protected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    CAST(size_t, eop - op), &state);\n\t\t\tif (bytesconsumed == CAST(size_t, -1) ||\n\t\t\t    bytesconsumed == CAST(size_t, -2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint(CAST(unsigned char, *op))) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n",
        "function_base": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "function_pr": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = (undefined1 *)realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if()return\n  if()return\n  \n  call()\n  if(){\n    call(, )\n    return\n  }\n  \n  if(call(call(, ))){\n    call(, )\n    return\n  }\n  \n  {\n    \n    \n    \n    \n    \n    call(, , )\n    \n    \n    \n    while(){\n      call(, , call(, ), )\n      if(call(, )call(, )){\n        \n        \n      }\n      if(call()){\n        call(, , )\n        \n        \n      }else{\n        while()call(, )\n      }\n    }\n    \n    \n    if()return\n  }\n  for(;;){\n    if(call(call(, , ))){\n      \n    }else{\n      call(, )\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      return\n    }\n    if(){\n      call()\n      \n      if(){\n        \n        call(, )\n        if(){\n          \n          \n          \n          if(){\n            \n            \n            do{\n              call(, , , )\n              if(){\n                \n                \n                \n                \n                if(){\n                  call()\n                  do{\n                    if(){\n                      \n                      \n                      \n                      \n                      \n                    }else{\n                      \n                      \n                    }\n                    \n                    \n                  }while()\n                }\n                \n                return\n              }\n              call()\n              if(){\n                for(;;){\n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                }\n              }else{\n                call(, , )\n                \n                \n              }\n            }while()\n          }\n          \n          return\n        }\n      }\n      call(, )\n      return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      return\n    }\n    if(){\n      call()\n      \n      if(){\n        \n        call(, )\n        if(){\n          \n          \n          \n          if(){\n            \n            \n            do{\n              call(, , , )\n              if(){\n                \n                \n                \n                \n                if(){\n                  call()\n                  do{\n                    if(){\n                      \n                      \n                      \n                      \n                      \n                    }else{\n                      \n                      \n                    }\n                    \n                    \n                  }while()\n                }\n                \n                return\n              }\n              call()\n              if(){\n                for(;;){\n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                }\n              }else{\n                call(, , )\n                \n                \n              }\n            }while()\n          }\n          \n          return\n        }\n      }\n      call(, )\n      return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.546875,
          "base_ppl": 1.859375,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 4.6875,
          "base_ast_ppl": 3.984375,
          "pr_ast_ppl": 3.984375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and structured, using standard loop constructs and avoiding unnecessary complexity.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ],
    "deepseek-r1": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.3125,
          "pr_ppl": 4.28125,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 4.0625,
          "pr_ast_ppl": 4.0625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.3125,
          "pr_ppl": 4.28125,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 4.0625,
          "pr_ast_ppl": 4.0625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.5,
          "base_ppl": 4.1875,
          "pr_ppl": 4.15625,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 4.65625,
          "pr_ast_ppl": 4.65625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.25,
          "source_ast_ppl": 5.125,
          "base_ast_ppl": 6.375,
          "pr_ast_ppl": 6.375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.25,
          "pr_ppl": 3.25,
          "source_ast_ppl": 5.125,
          "base_ast_ppl": 6.375,
          "pr_ast_ppl": 6.375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable and maintains the original functionality better than Candidate B. It uses simpler variable names and more straightforward control flow, making it easier to understand the logic. The code also handles error cases more explicitly, which improves maintainability.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.953125,
          "pr_ppl": 3.890625,
          "source_ast_ppl": 8.375,
          "base_ast_ppl": 10.25,
          "pr_ast_ppl": 10.25,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.984375,
          "pr_ppl": 3.953125,
          "source_ast_ppl": 8.375,
          "base_ast_ppl": 10.25,
          "pr_ast_ppl": 10.25,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A preserves the original code structure and variable names, making it more readable and maintainable while maintaining the same semantic behavior.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.4375,
          "base_ppl": 3.234375,
          "pr_ppl": 3.203125,
          "source_ast_ppl": 5.125,
          "base_ast_ppl": 6.3125,
          "pr_ast_ppl": 6.3125,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B provides a more maintainable and human-readable implementation while preserving the original functionality. It follows better software engineering practices with cleaner code structure, proper encapsulation, and minimal complexity. The code is less error-prone due to its simplicity and reduced redundancy.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined1 uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 5.0,
          "base_ppl": 3.359375,
          "pr_ppl": 3.390625,
          "source_ast_ppl": 8.375,
          "base_ast_ppl": 9.625,
          "pr_ast_ppl": 9.625,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more readable and maintains the original spaghetti code's structure better while introducing minimal changes that don't compromise the original's readability or functionality.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.65625,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 10.125,
          "pr_ast_ppl": 10.125,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable and maintains the original's structure and logic while being clearer and more maintainable. It uses standard C practices with readable variable names and a structured approach, unlike Candidate B which is dense and hard to follow despite attempting to parse the timestamp.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.015625,
          "base_ppl": 4.625,
          "pr_ppl": 4.65625,
          "source_ast_ppl": 4.46875,
          "base_ast_ppl": 10.125,
          "pr_ast_ppl": 10.125,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A provides a human-readable and maintainable decompilation that closely follows the original C code's structure and logic, including its loop structure and variable names. Candidate B, while efficient, uses a lower-level assembly-like syntax that makes it harder to understand the control flow and maintainability.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.4375,
          "source_ast_ppl": 5.15625,
          "base_ast_ppl": 11.25,
          "pr_ast_ppl": 11.25,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more human-readable because it directly mirrors the original code structure and variable names while adding readability through formatting and comments. It maintains semantic equivalence and follows the same logic as the original source code.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 3.25,
          "base_ppl": 4.40625,
          "pr_ppl": 4.4375,
          "source_ast_ppl": 5.15625,
          "base_ast_ppl": 11.25,
          "pr_ast_ppl": 11.25,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is more readable and maintains the original functionality while avoiding low-level undefined operations and assembly-like syntax. It follows standard C conventions and improves code clarity.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.359375,
          "source_ast_ppl": 70.0,
          "base_ast_ppl": 9.1875,
          "pr_ast_ppl": 8.9375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is a direct translation of the original code, maintaining the same control flow and variable usage, making it the most human-readable and accurate.",
          "winner": "BASE"
        },
        "llm_ast": {
          "motivation": "Both ASTs A and B have incorrect loop types (WhileLoop instead of ForLoop) and matching nesting depth. Since both are equally bad, the winner is determined by the Forced Decision to pick the one with correct loop types if possible. However, since both have incorrect loop types, the winner is the one with correct nesting depth, which is both. Therefore, the winner is A.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 3.390625,
          "pr_ppl": 3.359375,
          "source_ast_ppl": 70.0,
          "base_ast_ppl": 9.1875,
          "pr_ast_ppl": 8.9375,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate A is the winner because it is semantically identical to the original source code, making it the most accurate and human-readable option.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 5.0,
          "pr_ppl": 5.03125,
          "source_ast_ppl": 9.9375,
          "base_ast_ppl": 10.75,
          "pr_ast_ppl": 10.75,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 5.375,
          "base_ppl": 5.0,
          "pr_ppl": 5.03125,
          "source_ast_ppl": 9.9375,
          "base_ast_ppl": 10.75,
          "pr_ast_ppl": 10.75,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 14.4375,
          "base_ppl": 7.09375,
          "pr_ppl": 7.09375,
          "source_ast_ppl": 12.0,
          "base_ast_ppl": 11.4375,
          "pr_ast_ppl": 11.4375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is a direct clone of the original code with only formatting and variable name differences. It maintains the same semantic equivalence, control flow, and logic as the original. The only issue is a minor typo in the variable name, but this does not affect the overall functionality. Candidate B, while using standard POSIX functions, implements a different approach and is less readable as it deviates significantly from the original's structure and logic.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 14.4375,
          "base_ppl": 7.09375,
          "pr_ppl": 7.09375,
          "source_ast_ppl": 12.0,
          "base_ast_ppl": 11.4375,
          "pr_ast_ppl": 11.4375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is chosen because it closely mirrors the original code's structure, variable names, and logic, making it more human-readable and accurate. It maintains the same control flow and uses standard C functions without unnecessary deviations.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  call(, , )\n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        call(, , )\n        call(, )\n      }\n    }else{\n      call(, , )\n      if(){\n        \n        if(){\n          call(, , )\n          call(, )\n        }\n      }else{\n        call(, , , )\n        if(){\n          \n          \n          \n          call()\n          \n          \n          \n          \n          \n          \n          \n          if(){\n            \n          }\n          \n          \n          \n          \n          if(){\n            \n          }\n          call()\n          \n          if(){\n            \n          }else{\n            if(call(, )){\n              call(, )\n              if(){\n                \n                goto label\n              }\n              \n            }\n            call(, , , , )\n            if(call(, )call(, )){\n              call(, , )\n              if(){\n                \n                if(){\n                  call(, , , )\n                  call(, )\n                }\n              }else{\n                call()\n                if(call(, )){\n                  if(){\n                    call()\n                  }else{\n                    \n                    if(){\n                      call(, , , , )\n                      call(, )\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  call()\n  if(){\n    call()\n    call()\n    call()\n    call()\n    call(, , , , , , )\n    call(, )\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  call(, , )\n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        call(, , )\n        call(, )\n      }\n    }else{\n      call(, , )\n      if(){\n        \n        if(){\n          call(, , )\n          call(, )\n        }\n      }else{\n        call(, , , )\n        if(){\n          \n          \n          \n          call()\n          \n          \n          \n          \n          \n          \n          \n          if(){\n            \n          }\n          \n          \n          \n          \n          if(){\n            \n          }\n          call()\n          \n          if(){\n            \n          }else{\n            if(call(, )){\n              call(, )\n              if(){\n                \n                goto label\n              }\n              \n            }\n            call(, , , , )\n            if(call(, )call(, )){\n              call(, , )\n              if(){\n                \n                if(){\n                  call(, , , )\n                  call(, )\n                }\n              }else{\n                call()\n                if(call(, )){\n                  if(){\n                    call()\n                  }else{\n                    \n                    if(){\n                      call(, , , , )\n                      call(, )\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  call()\n  if(){\n    call()\n    call()\n    call()\n    call()\n    call(, , , , , , )\n    call(, )\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.984375,
          "base_ppl": 3.984375,
          "pr_ppl": 3.984375,
          "source_ast_ppl": 5.4375,
          "base_ast_ppl": 6.28125,
          "pr_ast_ppl": 6.28125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "Alright, I'm trying to figure out which candidate code better approximates the original. The original is a C function, and I need to compare it with two candidates, A and B, to determine which is more human-readable and accurate.\n\nFirst, I'll look at Candidate A. It's a C function that starts with variable declarations and then a series of operations. I notice that it uses pointers directly, like `__dest = calloc(1,0xdd0);` and `__ptr = (uint *)calloc(1,0x180);`. This might be a bit cryptic because it's using pointers instead of variable names. Also, the code is spread out across multiple lines, which can make it harder to follow the flow.\n\nLooking at the logic, Candidate A seems to handle various cases like seeking to the beginning or end of the file, error checking, and parsing headers and pages. It uses a lot of casts and pointers, which might lead to confusion. For example, the code assigns `local_28` to `param_3`, which is part of the function parameters, but it's not immediately clear what each variable represents. The code also uses a lot of temporary variables like `local_20`, `local_18`, and `local_10`, which might make it harder to trace the data flow.\n\nNow, looking at Candidate B, it's a C function that starts with parameter handling and context initialization. It uses `parser->io`, `parser->handlers`, and other parser-related variables. The code is more structured, using functions like `sas7bdat_ctx_free` and `sas7bdat_ctx`, which suggests better encapsulation and separation of concerns. The code also uses `ctx->handle.error` and `ctx->error_buf`, which might be more readable because it's using the struct context (`ctx`) to hold errors.\n\nComparing the two, Candidate B seems more organized. It uses helper functions and structs, which likely make the code cleaner and easier to understand. The use of `parser->io` and other parser variables makes it clear that this function is part of a larger system, which can help in maintaining and debugging.\n\nAnother thing I noticed is that Candidate B uses `sas7bdat_parse_meta_pages_pass1` and `sas7bdat_parse_amd_pages_pass1`, which are functions that might be specific to the SAS7bdat parsing. This suggests that the code is part of a library that handles such parsing, making it more specialized and thus more accurate in its operations.\n\nOn the other hand, Candidate A's code is more inline with the original function, which might have been intended for a specific use case. However, the lack of variable names and the use of pointers could make it less maintainable. The code also has a lot of inline casts and assignments, which can obfuscate what's happening.\n\nConsidering the evaluation criteria, the priority is semantic equivalence. Both candidates seem to perform the same operations, but the tie-breaker is readability. Since Candidate B is better structured and uses more encapsulation, it's likely the better choice.\n\nAdditionally, in terms of the human-like structure, Candidate B's use of a struct (`ctx`) and helper functions makes the code look more organized, which is important for readability. The code is also more modular, which can make it easier to test and debug individual parts.\n\nSo, after considering the structure, readability, and maintainability, I conclude that Candidate B is the better approximation of the original code.\n</think>\n\nThe candidate that best approximates the original code is **B**. \n\n**Motivation:** Candidate B provides a more structured and readable implementation of the SAS7bdat parsing logic. It uses a context (`ctx`) to encapsulate important variables and helper functions, making the code easier to follow. The use of `parser->io` and other parser-related variables clearly indicates that this function is part of a larger system, enhancing its maintainability and readability. While both candidates perform the same operations, B's organization and use of encapsulation make it more human-readable and accurate."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O2.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 3.984375,
          "base_ppl": 3.890625,
          "pr_ppl": 3.828125,
          "source_ast_ppl": 5.4375,
          "base_ast_ppl": 6.9375,
          "pr_ast_ppl": 6.9375,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "motivation": "Candidate A maintains a more readable and similar structure to the original C code, making it easier to debug and understand. The code follows the original logic and preserves key components, even if there are some minor deviations. Candidate B, while technically correct, is too obfuscated and harder to follow, making it less suitable for maintaining or extending the code.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O3.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 3.984375,
          "base_ppl": 3.890625,
          "pr_ppl": 3.828125,
          "source_ast_ppl": 5.4375,
          "base_ast_ppl": 6.9375,
          "pr_ast_ppl": 6.9375,
          "delta_ppl": -0.0625
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O0.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  int iVar3;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar3 = -*(int *)(compr + local_38 * 0x20 + 8);\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (-1 < iVar3) {\n        iVar1 = iVar3;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (iVar1 < 1) {\n        iVar1 = -iVar1;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    \n    \n    for(;;){\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n        }else{\n          call(, , )\n          call()\n        }\n        if(){\n          if(){\n            call(, , )\n            \n            call(, , )\n            call()\n          }\n          \n          call()\n          call(, , , , , , )\n          if(){\n            if()goto label\n            if(){\n              \n              call()\n            }\n          }\n          \n          if(){\n            call(, , )\n          }else{\n            call(, , , , , )\n          }\n          if(){\n            \n            if()\n            call()\n            if(call()){\n              call(, , , , , )\n              if(){\n                call()\n                if(){\n                  \n                  call()\n                }\n              }else{\n                call()\n                if(){\n                  call(, , )\n                  if(){\n                    call()\n                    goto label\n                  }\n                  call()\n                }\n                if(call())goto label\n              }\n            }\n          }\n          \n        }\n      }\n      \n    }\n    if(){\n      call(, , )\n    }\n    call()\n    \n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    \n    \n    for(;;){\n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n        }else{\n          call(, , )\n          call()\n        }\n        if(){\n          if(){\n            call(, , )\n            \n            call(, , )\n            call()\n          }\n          \n          call()\n          call(, , , , , , )\n          if(){\n            if()goto label\n            if(){\n              \n              call()\n            }\n          }\n          \n          if(){\n            call(, , )\n          }else{\n            call(, , , , , )\n          }\n          if(){\n            \n            if()\n            call()\n            if(call()){\n              call(, , , , , )\n              if(){\n                call()\n                if(){\n                  \n                  call()\n                }\n              }else{\n                call()\n                if(){\n                  call(, , )\n                  if(){\n                    call()\n                    goto label\n                  }\n                  call()\n                }\n                if(call())goto label\n              }\n            }\n          }\n          \n        }\n      }\n      \n    }\n    if(){\n      call(, , )\n    }\n    call()\n    \n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 14.4375,
          "base_ppl": 5.3125,
          "pr_ppl": 5.40625,
          "source_ast_ppl": 12.0,
          "base_ast_ppl": 10.125,
          "pr_ast_ppl": 9.3125,
          "delta_ppl": 0.09375
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and maintains a cleaner structure with standard C idioms and better variable names, making it easier to understand the flow and logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate B's control flow skeleton more accurately reflects the source AST by correctly placing the else block immediately after the for loop, whereas Candidate A introduces an unnecessary else block after the for loop, altering the control flow structure. Both have correct loop types and nesting depth, but B's structure is closer to the source.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_checkfmt-O2.so",
        "function": "file_checkfmt",
        "source_code": "file_protected int\nfile_checkfmt(char *msg, size_t mlen, const char *fmt)\n{\n\tconst char *p;\n\tfor (p = fmt; *p; p++) {\n\t\tif (*p != '%')\n\t\t\tcontinue;\n\t\tif (*++p == '%')\n\t\t\tcontinue;\n\t\tif (*p == '\\0') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"incomplete %% format\");\n\t\t\treturn -1;\n\t\t}\n\t\t// Skip uninteresting.\n\t\twhile (*p != '\\0' && strchr(\"#0.'+- \", *p) != NULL)\n\t\t\tp++;\n\t\tif (*p == '*') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"* not allowed in format\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!file_checkfield(msg, mlen, \"width\", &p))\n\t\t\treturn -1;\n\n\t\tif (*p == '.') {\n\t\t\tp++;\n\t\t\tif (!file_checkfield(msg, mlen, \"precision\", &p))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!isalpha((unsigned char)*p)) {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"bad format char: %c\", *p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "function_base": "\nundefined8 file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    for (; *param_3 != 0x25; param_3 = param_3 + 1) {\n      if (*param_3 == 0) {\n        return 0;\n      }\nLAB_0010122d:\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        __format = \"incomplete %% format\";\nLAB_00101278:\n        snprintf(param_1,param_2,__format);\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "function_pr": "\nulong file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    while( true ) {\n      bVar3 = *param_3;\n      if (bVar3 == 0x25) break;\n      if (bVar3 == 0) {\n        return (ulong)bVar3;\n      }\nLAB_0010122d:\n      param_3 = param_3 + 1;\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 != (char *)0x0) {\n          __format = \"incomplete %% format\";\nLAB_00101278:\n          snprintf(param_1,param_2,__format);\n        }\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  for(;;){\n    if()\n    if()\n    if(){\n      if()call(, , )\n      return\n    }\n    \n    while(call(, ))\n    if(){\n      if()call(, , )\n      return\n    }\n    if(call(, , , ))return\n    if(){\n      \n      if(call(, , , ))return\n    }\n    if(call()){\n      if()call(, , , )\n      return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  for(;;){\n    if(){\n      return\n    }\n    \n    \n    if(){\n      if(){\n        if(){\n          return\n        }\n        \n        call(, , )\n        return\n      }\n      do{\n        if(){\n          if(){\n            if(){\n              return\n            }\n            \n            goto label\n          }\n          \n        }\n        \n        \n      }while()\n      call(, , , )\n      if(){\n        return\n      }\n      \n      if(){\n        \n        call(, , , )\n        if(){\n          return\n        }\n        \n      }\n      \n      call()\n      if(){\n        if(){\n          return\n        }\n        call(, , , )\n        return\n      }\n      goto label\n    }\n    \n  }\n  while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  do{\n    while(){\n      \n      if()\n      if(){\n        return\n      }\n      \n    }\n    \n    \n    if(){\n      if(){\n        if(){\n          \n          call(, , )\n        }\n        return\n      }\n      do{\n        if(){\n          if(){\n            if(){\n              return\n            }\n            \n            goto label\n          }\n          \n        }\n        \n        \n      }while()\n      call(, , , )\n      if(){\n        return\n      }\n      \n      if(){\n        \n        call(, , , )\n        if(){\n          return\n        }\n        \n      }\n      \n      call()\n      if(){\n        if(){\n          return\n        }\n        call(, , , )\n        return\n      }\n      goto label\n    }\n    \n  }while()\n}",
        "metrics": {
          "source_ppl": 8.0,
          "base_ppl": 6.9375,
          "pr_ppl": 6.28125,
          "source_ast_ppl": 11.8125,
          "base_ast_ppl": 8.25,
          "pr_ast_ppl": 10.9375,
          "delta_ppl": -0.65625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its use of standard loops, cleaner variable names, and a more conventional control flow structure, despite minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-file_file_getbuffer-O2.so",
        "function": "file_getbuffer",
        "source_code": "file_protected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    CAST(size_t, eop - op), &state);\n\t\t\tif (bytesconsumed == CAST(size_t, -1) ||\n\t\t\t    bytesconsumed == CAST(size_t, -2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint(CAST(unsigned char, *op))) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n",
        "function_base": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "function_pr": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = (undefined1 *)realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if()return\n  if()return\n  \n  call()\n  if(){\n    call(, )\n    return\n  }\n  \n  if(call(call(, ))){\n    call(, )\n    return\n  }\n  \n  {\n    \n    \n    \n    \n    \n    call(, , )\n    \n    \n    \n    while(){\n      call(, , call(, ), )\n      if(call(, )call(, )){\n        \n        \n      }\n      if(call()){\n        call(, , )\n        \n        \n      }else{\n        while()call(, )\n      }\n    }\n    \n    \n    if()return\n  }\n  for(;;){\n    if(call(call(, , ))){\n      \n    }else{\n      call(, )\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      return\n    }\n    if(){\n      call()\n      \n      if(){\n        \n        call(, )\n        if(){\n          \n          \n          \n          if(){\n            \n            \n            do{\n              call(, , , )\n              if(){\n                \n                \n                \n                \n                if(){\n                  call()\n                  do{\n                    if(){\n                      \n                      \n                      \n                      \n                      \n                    }else{\n                      \n                      \n                    }\n                    \n                    \n                  }while()\n                }\n                \n                return\n              }\n              call()\n              if(){\n                for(;;){\n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                }\n              }else{\n                call(, , )\n                \n                \n              }\n            }while()\n          }\n          \n          return\n        }\n      }\n      call(, )\n      return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      return\n    }\n    if(){\n      call()\n      \n      if(){\n        \n        call(, )\n        if(){\n          \n          \n          \n          if(){\n            \n            \n            do{\n              call(, , , )\n              if(){\n                \n                \n                \n                \n                if(){\n                  call()\n                  do{\n                    if(){\n                      \n                      \n                      \n                      \n                      \n                    }else{\n                      \n                      \n                    }\n                    \n                    \n                  }while()\n                }\n                \n                return\n              }\n              call()\n              if(){\n                for(;;){\n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                }\n              }else{\n                call(, , )\n                \n                \n              }\n            }while()\n          }\n          \n          return\n        }\n      }\n      call(, )\n      return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 8.375,
          "base_ppl": 4.4375,
          "pr_ppl": 4.4375,
          "source_ast_ppl": 14.9375,
          "base_ast_ppl": 16.125,
          "pr_ast_ppl": 16.125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate A is chosen because it uses more standard C constructs and control flow, making it more readable and conventional for C developers despite being semantically identical to the original. The code structure and variable names closely mirror the original, enhancing human-like readability.",
          "winner": "BASE"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ],
    "llama3.1": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.34375,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its clear and structured control flow, using standard loops and conditionals, whereas Candidate A is less readable with its complex do-while loop and numerous goto statements.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.34375,
          "pr_ppl": 2.328125,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.328125,
          "pr_ast_ppl": 2.328125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate because it uses standard control flow structures and idiomatic C, while also correctly handling edge cases and providing clear and concise error messages.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.703125,
          "base_ppl": 2.28125,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 2.4375,
          "base_ast_ppl": 2.5625,
          "pr_ast_ppl": 2.5625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is chosen because it uses a more structured and idiomatic approach to handle different record types, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its use of standard loops and clean logic, making it easier to understand and maintain, even with minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.0625,
          "pr_ppl": 2.0625,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a clear and structured approach with switch statements and while loops, making it more human-readable and easier to understand, whereas Candidate A uses a complex nested structure with gotos, which is harder to comprehend.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.328125,
          "pr_ppl": 2.3125,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 3.78125,
          "pr_ast_ppl": 3.78125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate because it uses standard loops and clean logic, making it easier to understand and maintain, even though it has minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.359375,
          "pr_ppl": 2.34375,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 3.78125,
          "pr_ast_ppl": 3.78125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a more traditional and idiomatic C approach, with clear and concise control flow and logic, making it more human-readable and easier to understand than Candidate A, which uses a more complex and convoluted structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.3125,
          "base_ppl": 2.03125,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 2.828125,
          "base_ast_ppl": 2.84375,
          "pr_ast_ppl": 2.84375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its use of standard loops and cleaner logic, even if it has minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined1 uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.390625,
          "base_ppl": 2.046875,
          "pr_ppl": 2.03125,
          "source_ast_ppl": 3.59375,
          "base_ast_ppl": 3.40625,
          "pr_ast_ppl": 3.40625,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B's use of a state machine approach with a clear and concise control flow makes it more human-readable and easier to understand, even if it has minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.765625,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 3.796875,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a more idiomatic C structure, avoiding the use of gotos and complex conditional statements, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.78125,
          "base_ppl": 2.734375,
          "pr_ppl": 2.765625,
          "source_ast_ppl": 2.359375,
          "base_ast_ppl": 3.796875,
          "pr_ast_ppl": 3.796875,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B's clean structure, standard loops, and lack of gotos make it a better representation of human-written code, despite minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 4.28125,
          "pr_ast_ppl": 4.28125,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its use of standard control structures and clean logic, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.8671875,
          "base_ppl": 2.640625,
          "pr_ppl": 2.671875,
          "source_ast_ppl": 2.53125,
          "base_ast_ppl": 4.28125,
          "pr_ast_ppl": 4.28125,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurately structured, with a clear use of loops and conditionals, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 13.8125,
          "base_ast_ppl": 3.890625,
          "pr_ast_ppl": 3.890625,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "motivation": "A recovered the for-loop while B used while-goto",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.859375,
          "base_ppl": 2.09375,
          "pr_ppl": 2.046875,
          "source_ast_ppl": 13.8125,
          "base_ast_ppl": 3.890625,
          "pr_ast_ppl": 3.890625,
          "delta_ppl": -0.046875
        },
        "llm_qualitative": {
          "motivation": "Candidate B's use of a clean do-while loop and a more traditional iteration approach makes it easier to understand the logic and control flow, outweighing its minor inaccuracies compared to Candidate A's use of a goto statement.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Candidate A recovered the for-loop while Candidate B used while-goto.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.703125,
          "pr_ppl": 2.734375,
          "source_ast_ppl": 3.828125,
          "base_ast_ppl": 4.8125,
          "pr_ast_ppl": 4.8125,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a more idiomatic C structure and cleaner logic, with a clear use of loops and conditional statements, making it more human-readable and easier to understand.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 2.421875,
          "base_ppl": 2.703125,
          "pr_ppl": 2.734375,
          "source_ast_ppl": 3.828125,
          "base_ast_ppl": 4.8125,
          "pr_ast_ppl": 4.8125,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a more straightforward and idiomatic C structure with proper use of loops, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.59375,
          "base_ppl": 3.0625,
          "pr_ppl": 3.0625,
          "source_ast_ppl": 5.15625,
          "base_ast_ppl": 4.3125,
          "pr_ast_ppl": 4.3125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its use of standard control structures and clear logic, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.59375,
          "base_ppl": 3.0625,
          "pr_ppl": 3.0625,
          "source_ast_ppl": 5.15625,
          "base_ast_ppl": 4.3125,
          "pr_ast_ppl": 4.3125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM response; declaring TIE."
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  call(, , )\n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        call(, , )\n        call(, )\n      }\n    }else{\n      call(, , )\n      if(){\n        \n        if(){\n          call(, , )\n          call(, )\n        }\n      }else{\n        call(, , , )\n        if(){\n          \n          \n          \n          call()\n          \n          \n          \n          \n          \n          \n          \n          if(){\n            \n          }\n          \n          \n          \n          \n          if(){\n            \n          }\n          call()\n          \n          if(){\n            \n          }else{\n            if(call(, )){\n              call(, )\n              if(){\n                \n                goto label\n              }\n              \n            }\n            call(, , , , )\n            if(call(, )call(, )){\n              call(, , )\n              if(){\n                \n                if(){\n                  call(, , , )\n                  call(, )\n                }\n              }else{\n                call()\n                if(call(, )){\n                  if(){\n                    call()\n                  }else{\n                    \n                    if(){\n                      call(, , , , )\n                      call(, )\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  call()\n  if(){\n    call()\n    call()\n    call()\n    call()\n    call(, , , , , , )\n    call(, )\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  call(, , )\n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        call(, , )\n        call(, )\n      }\n    }else{\n      call(, , )\n      if(){\n        \n        if(){\n          call(, , )\n          call(, )\n        }\n      }else{\n        call(, , , )\n        if(){\n          \n          \n          \n          call()\n          \n          \n          \n          \n          \n          \n          \n          if(){\n            \n          }\n          \n          \n          \n          \n          if(){\n            \n          }\n          call()\n          \n          if(){\n            \n          }else{\n            if(call(, )){\n              call(, )\n              if(){\n                \n                goto label\n              }\n              \n            }\n            call(, , , , )\n            if(call(, )call(, )){\n              call(, , )\n              if(){\n                \n                if(){\n                  call(, , , )\n                  call(, )\n                }\n              }else{\n                call()\n                if(call(, )){\n                  if(){\n                    call()\n                  }else{\n                    \n                    if(){\n                      call(, , , , )\n                      call(, )\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  call()\n  if(){\n    call()\n    call()\n    call()\n    call()\n    call(, , , , , , )\n    call(, )\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.296875,
          "base_ppl": 2.0,
          "pr_ppl": 2.0,
          "source_ast_ppl": 2.734375,
          "base_ast_ppl": 2.984375,
          "pr_ast_ppl": 2.984375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its structured control flow and cleaner logic, despite minor inaccuracies, whereas Candidate A's use of gotos and duplicated code makes it less preferable.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O2.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.296875,
          "base_ppl": 2.28125,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.734375,
          "base_ast_ppl": 3.15625,
          "pr_ast_ppl": 3.15625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a more structured control flow and uses standard C constructs, making it easier to understand and maintain, despite having minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O3.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.296875,
          "base_ppl": 2.28125,
          "pr_ppl": 2.25,
          "source_ast_ppl": 2.734375,
          "base_ast_ppl": 3.15625,
          "pr_ast_ppl": 3.15625,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable due to its clear and structured control flow, avoiding the use of goto statements and instead utilizing standard loops, making it easier to understand and maintain.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O0.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  int iVar3;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar3 = -*(int *)(compr + local_38 * 0x20 + 8);\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (-1 < iVar3) {\n        iVar1 = iVar3;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (iVar1 < 1) {\n        iVar1 = -iVar1;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    \n    \n    for(;;){\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n        }else{\n          call(, , )\n          call()\n        }\n        if(){\n          if(){\n            call(, , )\n            \n            call(, , )\n            call()\n          }\n          \n          call()\n          call(, , , , , , )\n          if(){\n            if()goto label\n            if(){\n              \n              call()\n            }\n          }\n          \n          if(){\n            call(, , )\n          }else{\n            call(, , , , , )\n          }\n          if(){\n            \n            if()\n            call()\n            if(call()){\n              call(, , , , , )\n              if(){\n                call()\n                if(){\n                  \n                  call()\n                }\n              }else{\n                call()\n                if(){\n                  call(, , )\n                  if(){\n                    call()\n                    goto label\n                  }\n                  call()\n                }\n                if(call())goto label\n              }\n            }\n          }\n          \n        }\n      }\n      \n    }\n    if(){\n      call(, , )\n    }\n    call()\n    \n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    \n    \n    for(;;){\n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n        }else{\n          call(, , )\n          call()\n        }\n        if(){\n          if(){\n            call(, , )\n            \n            call(, , )\n            call()\n          }\n          \n          call()\n          call(, , , , , , )\n          if(){\n            if()goto label\n            if(){\n              \n              call()\n            }\n          }\n          \n          if(){\n            call(, , )\n          }else{\n            call(, , , , , )\n          }\n          if(){\n            \n            if()\n            call()\n            if(call()){\n              call(, , , , , )\n              if(){\n                call()\n                if(){\n                  \n                  call()\n                }\n              }else{\n                call()\n                if(){\n                  call(, , )\n                  if(){\n                    call()\n                    goto label\n                  }\n                  call()\n                }\n                if(call())goto label\n              }\n            }\n          }\n          \n        }\n      }\n      \n    }\n    if(){\n      call(, , )\n    }\n    call()\n    \n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 4.59375,
          "base_ppl": 2.578125,
          "pr_ppl": 2.59375,
          "source_ast_ppl": 5.15625,
          "base_ast_ppl": 4.1875,
          "pr_ast_ppl": 4.1875,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more human-readable and accurate due to its clear and structured control flow, whereas Candidate A has some minor inaccuracies in variable assignments and uses a less idiomatic loop structure.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "B has fewer unnecessary Goto statements.",
          "winner": "PR"
        }
      },
      {
        "binary": "task-file_file_checkfmt-O2.so",
        "function": "file_checkfmt",
        "source_code": "file_protected int\nfile_checkfmt(char *msg, size_t mlen, const char *fmt)\n{\n\tconst char *p;\n\tfor (p = fmt; *p; p++) {\n\t\tif (*p != '%')\n\t\t\tcontinue;\n\t\tif (*++p == '%')\n\t\t\tcontinue;\n\t\tif (*p == '\\0') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"incomplete %% format\");\n\t\t\treturn -1;\n\t\t}\n\t\t// Skip uninteresting.\n\t\twhile (*p != '\\0' && strchr(\"#0.'+- \", *p) != NULL)\n\t\t\tp++;\n\t\tif (*p == '*') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"* not allowed in format\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!file_checkfield(msg, mlen, \"width\", &p))\n\t\t\treturn -1;\n\n\t\tif (*p == '.') {\n\t\t\tp++;\n\t\t\tif (!file_checkfield(msg, mlen, \"precision\", &p))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!isalpha((unsigned char)*p)) {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"bad format char: %c\", *p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "function_base": "\nundefined8 file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    for (; *param_3 != 0x25; param_3 = param_3 + 1) {\n      if (*param_3 == 0) {\n        return 0;\n      }\nLAB_0010122d:\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        __format = \"incomplete %% format\";\nLAB_00101278:\n        snprintf(param_1,param_2,__format);\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "function_pr": "\nulong file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    while( true ) {\n      bVar3 = *param_3;\n      if (bVar3 == 0x25) break;\n      if (bVar3 == 0) {\n        return (ulong)bVar3;\n      }\nLAB_0010122d:\n      param_3 = param_3 + 1;\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 != (char *)0x0) {\n          __format = \"incomplete %% format\";\nLAB_00101278:\n          snprintf(param_1,param_2,__format);\n        }\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  for(;;){\n    if()\n    if()\n    if(){\n      if()call(, , )\n      return\n    }\n    \n    while(call(, ))\n    if(){\n      if()call(, , )\n      return\n    }\n    if(call(, , , ))return\n    if(){\n      \n      if(call(, , , ))return\n    }\n    if(call()){\n      if()call(, , , )\n      return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  for(;;){\n    if(){\n      return\n    }\n    \n    \n    if(){\n      if(){\n        if(){\n          return\n        }\n        \n        call(, , )\n        return\n      }\n      do{\n        if(){\n          if(){\n            if(){\n              return\n            }\n            \n            goto label\n          }\n          \n        }\n        \n        \n      }while()\n      call(, , , )\n      if(){\n        return\n      }\n      \n      if(){\n        \n        call(, , , )\n        if(){\n          return\n        }\n        \n      }\n      \n      call()\n      if(){\n        if(){\n          return\n        }\n        call(, , , )\n        return\n      }\n      goto label\n    }\n    \n  }\n  while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  do{\n    while(){\n      \n      if()\n      if(){\n        return\n      }\n      \n    }\n    \n    \n    if(){\n      if(){\n        if(){\n          \n          call(, , )\n        }\n        return\n      }\n      do{\n        if(){\n          if(){\n            if(){\n              return\n            }\n            \n            goto label\n          }\n          \n        }\n        \n        \n      }while()\n      call(, , , )\n      if(){\n        return\n      }\n      \n      if(){\n        \n        call(, , , )\n        if(){\n          return\n        }\n        \n      }\n      \n      call()\n      if(){\n        if(){\n          return\n        }\n        call(, , , )\n        return\n      }\n      goto label\n    }\n    \n  }while()\n}",
        "metrics": {
          "source_ppl": 3.109375,
          "base_ppl": 2.734375,
          "pr_ppl": 2.703125,
          "source_ast_ppl": 4.875,
          "base_ast_ppl": 3.921875,
          "pr_ast_ppl": 4.25,
          "delta_ppl": -0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B is chosen because it maintains a clean and idiomatic C structure, whereas Candidate A has a more complex and less readable control flow, even though it is semantically equivalent to the original.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "Error",
          "motivation": "### Winner: A\n### Motivation: A recovered the for-loop while B used while-goto, with extra nesting levels\n\nExplanation:\nCandidate A and Candidate B both have a similar structure, but Candidate A correctly uses a `ForLoop` instead of `WhileLoop` and `Goto` which is seen in Candidate B. Additionally, Candidate B has extra nesting levels due to the use of `While` inside `Do-While`."
        }
      },
      {
        "binary": "task-file_file_getbuffer-O2.so",
        "function": "file_getbuffer",
        "source_code": "file_protected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    CAST(size_t, eop - op), &state);\n\t\t\tif (bytesconsumed == CAST(size_t, -1) ||\n\t\t\t    bytesconsumed == CAST(size_t, -2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint(CAST(unsigned char, *op))) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n",
        "function_base": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "function_pr": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = (undefined1 *)realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if()return\n  if()return\n  \n  call()\n  if(){\n    call(, )\n    return\n  }\n  \n  if(call(call(, ))){\n    call(, )\n    return\n  }\n  \n  {\n    \n    \n    \n    \n    \n    call(, , )\n    \n    \n    \n    while(){\n      call(, , call(, ), )\n      if(call(, )call(, )){\n        \n        \n      }\n      if(call()){\n        call(, , )\n        \n        \n      }else{\n        while()call(, )\n      }\n    }\n    \n    \n    if()return\n  }\n  for(;;){\n    if(call(call(, , ))){\n      \n    }else{\n      call(, )\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      return\n    }\n    if(){\n      call()\n      \n      if(){\n        \n        call(, )\n        if(){\n          \n          \n          \n          if(){\n            \n            \n            do{\n              call(, , , )\n              if(){\n                \n                \n                \n                \n                if(){\n                  call()\n                  do{\n                    if(){\n                      \n                      \n                      \n                      \n                      \n                    }else{\n                      \n                      \n                    }\n                    \n                    \n                  }while()\n                }\n                \n                return\n              }\n              call()\n              if(){\n                for(;;){\n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                }\n              }else{\n                call(, , )\n                \n                \n              }\n            }while()\n          }\n          \n          return\n        }\n      }\n      call(, )\n      return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      return\n    }\n    if(){\n      call()\n      \n      if(){\n        \n        call(, )\n        if(){\n          \n          \n          \n          if(){\n            \n            \n            do{\n              call(, , , )\n              if(){\n                \n                \n                \n                \n                if(){\n                  call()\n                  do{\n                    if(){\n                      \n                      \n                      \n                      \n                      \n                    }else{\n                      \n                      \n                    }\n                    \n                    \n                  }while()\n                }\n                \n                return\n              }\n              call()\n              if(){\n                for(;;){\n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                }\n              }else{\n                call(, , )\n                \n                \n              }\n            }while()\n          }\n          \n          return\n        }\n      }\n      call(, )\n      return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 2.109375,
          "pr_ppl": 2.125,
          "source_ast_ppl": 5.3125,
          "base_ast_ppl": 5.75,
          "pr_ast_ppl": 5.75,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is the winner because it uses a clear and idiomatic loop structure to handle the parsing of the multi-byte sequence, making it more human-readable and easier to understand, even if it has minor inaccuracies.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ],
    "gemma2": [
      {
        "binary": "task-libxls_xls_parseWorkBook-O2.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.015625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "        if (xls_debug) {\n            printf( \"the_is_\n            if (xls_debug) {\n            printf( \"not a\n\t\t\t}\n        }\n\n    if (xls_is_not_000)\n\n\nThe next 0x112000)\n\nif (xls_debug)\nreturn;\n```\n\n\n\nIf you want to use the current\nreturn;\n}\n\n\n//\n;\n\n**3**\n\n```\nif (xls_debug)\n```\n\n\n**3**\n```\n\nThe first 2.\nif (xls_is_\n\n```\n\nreturn;\n\n\n\n`else`\n\n\n\nif (xls_is_\n\nif (xls_is_\n\n\nif (xls_is_\n\n\nif (xls_is_\n\n\nif (\n\n* 0x342)\nif (\n\n* 0x2)\nif (\n\nif (\n\n\nif (\n\n\nif (\n\n\n\nif (\n\nif (\n\nif (\n\n\nreturn;\n\n\n\n**3**\nreturn;\n\n\n\n**3**\n\n\n\nreturn;\n\nreturn;\n\nreturn;\n\n\nreturn;\n\n\nreturn;\n\n\nreturn;\n\n\n\nif (\nif (\n\nreturn;\n\n\n\nreturn;\n\n\n\nif (\n\nreturn;\n\n\nif (\nif (\n\n\n\nreturn;\n\nreturn;\n\n\n\nif (return;\n\n\n\nif (return;\n\nreturn;\n\n\n\nreturn;\n\n\n\nif (\n\n\nreturn;\n\n\n\nif (\n\nreturn;\n\n\n\nif (return;\n\n\n\nreturn;\n\n\n\nif (return;\n\n\n\nif (\n\nreturn;\n\n\n\nif (return;\n\n\n\nif (return;\n\n\n\nif (return;\n\n\nif (return;\n\n\n\nif (return;\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nif (return;\n\n\n\nif (return;\n\n\n\nif (\nreturn;\n\n\n\nif (return;\n\nreturn;\n\n\n\nif (return;\n\n\n\nif (return;\n\n\nreturn;\n\n\nif (return;\n\n\n\nif (return;\n\nif (return;\n\nif (return;\n\n\n\nreturn;\n\n\n\nif (return;\n\n\nif (return;\n\n\n\nreturn;\n\n\nif (return;\n\nif (return;\n\n\ndefault;\nif (return;\n\n\n\nreturn;\n\n\n\nif (return;\n\nif (return;\n\nif (return;\n\n\nreturn;\n\n\n\nif (return;\n\n\n\nif (return;\n\n\n\nif (return;\n\nif (return;\n\n\nreturn;\n\n\n\nreturn;\n\n\n\nif (return;\n\n\n\nif (return;\n\nreturn;\n\n\n\nif (return;\n\n\n\nif (return;\n\n\n\nreturn; if (return;\n\n\n\nif (return;\n\n\n\nif (return;\n\nif (return;\n\n\n\nif (return; if (return;\n\nif (return;\n\n\n\nif (return;\n\nif (return;\n\n\n\nif (return; if (return;\n\nif (return;\n\nif (return;\n\n\n\nif (return; if (return; if (return; if (return;\n\n\n)\n\n\n\nif (return;\n\nif (return;\n\n\n\nif (return; if (return; if (return; if (return; if (return; if (return;\n\n\n\nif (return; if (return;\n\n\n\nif (return; if (return;\n\n\n\nif (return; if (return; if (return;\n\nreturn; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (return; if (\n```\n\n* **1**\n\n**3**\n\n0)\n\n```\n\n```\n* **3**\n\n* **3**\n\n)\n\n;return\n\n)\n\n\n\n\\\n\n\n1);\n\n);\n\nreturn;\n\n*\n\n\n);\n\n**1**\n\n63);\n\n\n\n)\n\n)\n\n;\n\n\n\nreturn;\n\n)\n\n;\n\nreturn;\n\n)\n\n;\n\nreturn;\n\n)\n\n);\n\n1.5\n\n;\n\n)\n\n);\n\n1\n\n;\n\n1033\n\nreturn;\n\n535\n\n33.\n\n333\n\n)\n\n;\n\nreturn;\n\n11);\n\nreturn;\n\n10\n\n10)\n\n533\n\n)\n\n)\n\n110\n\n533\n\n)\n\n110\n\n)\n\n110\n\n\n13;\n\n23;\n\n2.\n\n333,\n\n33.\n\n)\n\n\n)\n\n*\n\n)\n\n\n6.34\n\n330\n\n)\n\n\n)\n\n);\n\n533.\n\n)\n\n;\n\n10.\n\n1)533);\n\n101);\n\n10;\n\n100\n\n533.\n\n\n\nif(0\n\n)\n\n),\n\n*1.\n\n**9**\n\n).\n\n\nreturn;\n\n6;\n\n*\n\nreturn;\n\n6.\n\n533)\n\nif (533)\n\n);\n\n533)\n\n)\n\n;\n\n\n**54**\n\n\\\n\n3;\n\n*\n\n**3**\n\n1.\n\n3\n\n3).\n\nreturn;\n\n1001\n\n10);\n\n333.\n\n**0**\n\n2)\n\n**34**\n\n\n),\n0\n\n533)\n\nif (0)\n\n)\n\n115,\n\nreturn;\n\n533\n\n)\n\n5555,\n\n),\n\nreturn;\n\n533,\n\nreturn),\n\n533)\n\n533,\n\n)\n\n10\n\n1010),\n1,110,\n\nreturn;\n\n1),\n\n* **0**\n\nreturn;\n\n1),\n\nreturn;\n\n101\n\n**3**\n\n1)\n\n3;\n\n6),\n\n10);\n\n1.5)\n\n63.\n\n3),\n\nreturn;\n\n533\n\n533);\n\nreturn;\n\n111\n\n)\n\n*11\n\n)\nreturn,111\n(1)000)\n\nreturn;1\n\n101),\n\n12,\n\n%\n\n34),\n\nreturn;\n\n1),\n\n10,\n\nreturn;\n\n)(2\n\n),\n\nreturn,\n\n),\n\n6,\n\n6.\n\n"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O3.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  long lVar1;\n  ushort uVar2;\n  uint in_EAX;\n  int iVar3;\n  int iVar4;\n  long lVar5;\n  ushort *__ptr;\n  ulong uVar6;\n  void *__ptr_00;\n  undefined2 uVar7;\n  char *pcVar8;\n  short sVar9;\n  undefined8 uStack_38;\n  \n  if (param_1 == (long *)0x0) {\n    iVar4 = 7;\n  }\n  else {\n    uStack_38 = (ulong)in_EAX;\n    verbose(\"xls_parseWorkBook\");\n    iVar4 = 1;\n    lVar1 = (long)&uStack_38 + 4;\n    __ptr = (ushort *)0x0;\n    uVar7 = 0;\n    sVar9 = 0;\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)param_1[1]);\n        lVar5 = *param_1;\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(lVar5 + 8),\n               (ulong)*(uint *)(lVar5 + 0x10),(ulong)*(uint *)(lVar5 + 0x20),\n               (ulong)*(uint *)(lVar5 + 0x28));\n      }\n      lVar5 = ole2_read(lVar1,1,4,*param_1);\n      if (lVar5 != 4) {\n        iVar4 = 3;\n        break;\n      }\n      xlsConvertBof(lVar1);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(lVar1);\n      }\n      if (uStack_38 >> 0x30 != 0) {\n        __ptr = (ushort *)realloc(__ptr,uStack_38 >> 0x30);\n        if (__ptr == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 == 0) {\n            return 5;\n          }\n          fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                  (ulong)uStack_38._6_2_);\n          return 5;\n        }\n        uVar6 = ole2_read(__ptr,1,uStack_38._6_2_,*param_1);\n        if (uVar6 != uStack_38 >> 0x30) {\n          iVar4 = 3;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fwrite(\"Error: failed to read OLE block\\n\",0x20,1,*(FILE **)PTR_stderr_00104ff8);\n          }\n          goto LAB_00101bb4;\n        }\n      }\n      iVar3 = xls_isRecordTooSmall(param_1,lVar1,__ptr);\n      if (iVar3 != 0) {\n        iVar4 = 4;\n        break;\n      }\n      if (uStack_38._4_2_ < 0x92) {\n        switch(uStack_38._4_2_) {\n        case 10:\n          break;\n        case 0xb:\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n        case 0x21:\n        case 0x23:\n        case 0x24:\n        case 0x25:\n        case 0x26:\n        case 0x27:\n        case 0x28:\n        case 0x29:\n        case 0x2a:\n        case 0x2b:\n        case 0x2c:\n        case 0x2d:\n        case 0x2e:\n        case 0x30:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n        case 0x38:\n        case 0x39:\n        case 0x3a:\n        case 0x3b:\n        case 0x3e:\n        case 0x3f:\n        case 0x40:\n        case 0x41:\n          goto switchD_00101509_caseD_b;\n        case 0x18:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            if (uStack_38._6_2_ != 0) {\n              uVar6 = 0;\n              do {\n                printf(\"%2.2x \",(ulong)*(byte *)((long)__ptr + uVar6));\n                uVar6 = uVar6 + 1;\n              } while (uVar6 < uStack_38 >> 0x30);\n            }\n            putchar(10);\n          }\n          break;\n        case 0x22:\n          uVar6 = (ulong)(byte)*__ptr;\n          *(byte *)((long)param_1 + 0xd) = (byte)*__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"   mode: 0x%x\\n\";\nLAB_00101b26:\n            printf(pcVar8,uVar6);\n          }\n          break;\n        case 0x2f:\n          iVar4 = 6;\n          goto LAB_00101b6a;\n        case 0x31:\nswitchD_00101509_caseD_31:\n          xlsConvertFont(__ptr);\n          lVar5 = xls_addFont(param_1,__ptr,uStack_38._6_2_);\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\" height: %d\\n\",(ulong)*__ptr);\n            printf(\"   flag: 0x%x\\n\",(ulong)__ptr[1]);\n            printf(\"  color: 0x%x\\n\",(ulong)__ptr[2]);\n            printf(\" weight: %d\\n\",(ulong)__ptr[3]);\n            printf(\"escapem: 0x%x\\n\",(ulong)__ptr[4]);\n            printf(\"underln: 0x%x\\n\",(ulong)(byte)__ptr[5]);\n            printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)__ptr + 0xb));\n            printf(\"charset: 0x%x\\n\",(ulong)(byte)__ptr[6]);\n            if (lVar5 != 0) {\n              printf(\"   name: %s\\n\",lVar5);\n            }\n          }\n          break;\n        case 0x3c:\n          if (iVar4 == 0) {\n            if ((sVar9 == 0xfc) &&\n               (iVar4 = xls_appendSST(param_1,__ptr,uStack_38._6_2_), iVar4 != 0))\n            goto LAB_00101b6a;\n            uStack_38 = CONCAT26(uVar7,CONCAT24(sVar9,(undefined4)uStack_38));\n          }\n          break;\n        case 0x3d:\n          xlsConvertWindow(__ptr);\n          *(ushort *)(param_1 + 2) = __ptr[5];\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"WINDOW1: \");\n            printf(\"xWn    : %d\\n\",(ulong)(*__ptr / 0x14));\n            printf(\"yWn    : %d\\n\",(ulong)(__ptr[1] / 0x14));\n            printf(\"dxWn   : %d\\n\",(ulong)(__ptr[2] / 0x14));\n            printf(\"dyWn   : %d\\n\",(ulong)(__ptr[3] / 0x14));\n            printf(\"grbit  : %d\\n\",(ulong)__ptr[4]);\n            printf(\"itabCur: %d\\n\",(ulong)__ptr[5]);\n            printf(\"itabFi : %d\\n\",(ulong)__ptr[6]);\n            printf(\"ctabSel: %d\\n\",(ulong)__ptr[7]);\n            uVar6 = (ulong)__ptr[8];\n            pcVar8 = \"wTabRat: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        case 0x42:\n          uVar6 = (ulong)*__ptr;\n          *(ushort *)((long)param_1 + 0x12) = *__ptr;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            pcVar8 = \"codepage: %d\\n\";\n            goto LAB_00101b26;\n          }\n          break;\n        default:\n          if (uStack_38._4_2_ == 0x85) {\n            xlsConvertBoundsheet(__ptr);\n            iVar4 = xls_addSheet(param_1,__ptr,uStack_38._6_2_);\n            goto joined_r0x00101ad1;\n          }\nswitchD_00101509_caseD_b:\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                   (ulong)uStack_38._4_2_,(ulong)uStack_38._6_2_);\n          }\n        }\n      }\n      else if (uStack_38._4_2_ < 0x231) {\n        if (uStack_38._4_2_ < 0xfc) {\n          if (uStack_38._4_2_ == 0x92) {\n            if ((10 < *(int *)PTR_xls_debug_00104fd8) && (uVar2 = *__ptr, uVar2 != 0)) {\n              lVar5 = 0;\n              do {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)((int)lVar5 + 8),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 1],\n                       (ulong)*(byte *)((long)__ptr + lVar5 * 4 + 3),\n                       (ulong)(byte)__ptr[lVar5 * 2 + 2]);\n                lVar5 = lVar5 + 1;\n              } while ((uint)uVar2 != (uint)lVar5);\n            }\n          }\n          else {\n            if (uStack_38._4_2_ != 0xe0) goto switchD_00101509_caseD_b;\n            if (*(char *)((long)param_1 + 0xc) == '\\0') {\n              xlsConvertXf8(__ptr);\n              iVar4 = xls_addXF8(param_1,__ptr);\n              if (iVar4 == 0) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  xls_showXF(__ptr);\n                }\n                goto switchD_00101509_caseD_a;\n              }\n              break;\n            }\n            xlsConvertXf5(__ptr);\n            iVar4 = xls_addXF5(param_1,__ptr);\n            if (iVar4 != 0) break;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"   font: %d\\n\",(ulong)*__ptr);\n              printf(\" format: %d\\n\",(ulong)__ptr[1]);\n              printf(\"   type: %.4x\\n\",(ulong)__ptr[2]);\n              printf(\"  align: %.4x\\n\",(ulong)__ptr[3]);\n              printf(\"rotatio: %.4x\\n\",(ulong)__ptr[4]);\n              printf(\"  ident: %.4x\\n\",(ulong)__ptr[5]);\n              printf(\"usedatt: %.4x\\n\",(ulong)__ptr[6]);\n              uVar6 = (ulong)__ptr[7];\n              pcVar8 = \"linesty: %.4x\\n\";\n              goto LAB_00101b26;\n            }\n          }\n        }\n        else if (uStack_38._4_2_ == 0xfc) {\n          xlsConvertSst(__ptr);\n          iVar4 = xls_addSST(param_1,__ptr,uStack_38._6_2_);\njoined_r0x00101ad1:\n          if (iVar4 != 0) break;\n        }\n        else if (uStack_38._4_2_ != 0xff) goto switchD_00101509_caseD_b;\n      }\n      else if (uStack_38._4_2_ < 0x41e) {\n        if (uStack_38._4_2_ == 0x231) goto switchD_00101509_caseD_31;\n        if (uStack_38._4_2_ != 0x293) goto switchD_00101509_caseD_b;\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          printf(\"    idx: 0x%x\\n\",(ulong)(*__ptr & 0x7ff));\n          if ((short)*__ptr < 0) {\n            printf(\"  ident: 0x%x\\n\",(ulong)(byte)__ptr[1]);\n            uVar6 = (ulong)*(byte *)((long)__ptr + 3);\n            pcVar8 = \"  level: 0x%x\\n\";\n            goto LAB_00101b26;\n          }\n          __ptr_00 = (void *)get_string(__ptr + 1,(uStack_38 >> 0x30) - 2,1,param_1);\n          printf(\"  name=%s\\n\",__ptr_00);\n          free(__ptr_00);\n        }\n      }\n      else {\n        if (uStack_38._4_2_ == 0x41e) {\n          xlsConvertFormat(__ptr);\n          iVar4 = xls_addFormat(param_1,__ptr,uStack_38._6_2_);\n          goto joined_r0x00101ad1;\n        }\n        if (uStack_38._4_2_ != 0x809) goto switchD_00101509_caseD_b;\n        uVar2 = *__ptr;\n        *(bool *)((long)param_1 + 0xc) = uVar2 != 0x600;\n        *(ushort *)((long)param_1 + 0xe) = __ptr[1];\n        if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n          pcVar8 = \"BIFF8\";\n          if (uVar2 != 0x600) {\n            pcVar8 = \"BIFF5\";\n          }\n          printf(\"version: %s\\n\",pcVar8);\n          uVar6 = (ulong)*(ushort *)((long)param_1 + 0xe);\n          pcVar8 = \"   type: %.2X\\n\";\n          goto LAB_00101b26;\n        }\n      }\nswitchD_00101509_caseD_a:\n      iVar4 = 0;\n      if (*(char *)(*param_1 + 0x3c) != '\\0') break;\n      uVar7 = uStack_38._6_2_;\n      sVar9 = uStack_38._4_2_;\n    } while (uStack_38._4_2_ != 10);\nLAB_00101b6a:\n    if (__ptr != (ushort *)0x0) {\nLAB_00101bb4:\n      free(__ptr);\n    }\n  }\n  return iVar4;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call()\n    \n    \n    \n    \n    \n    do{\n      if(){\n        call(, )\n        \n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            return\n          }\n          call(, , )\n          return\n        }\n        call(, , , )\n        if(){\n          \n          if(){\n            call(, , , )\n          }\n          goto label\n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      if(){\n        switch(){\n          case :\n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            if(){\n              call()\n              if(){\n                \n                do{\n                  call(, )\n                  \n                }while()\n              }\n              call()\n            }\n            \n          case :\n            call()\n            \n            if(){\n              \n              call(, )\n            }\n            \n          case :\n            \n            goto label\n          case :\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n            \n          case :\n            if(){\n              if(call(, , ))goto label\n              call(, call(, ))\n            }\n            \n          case :\n            call()\n            \n            if(){\n              call()\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, call())\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n            \n          case :\n            \n            \n            if(){\n              \n              goto label\n            }\n            \n          case :\n            \n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              call(, , )\n            }\n        }\n      }elseif(){\n        if(){\n          if(){\n            if(){\n              \n              do{\n                call(, call(), , , )\n                \n              }while()\n            }\n          }else{\n            if()goto label\n            if(){\n              call()\n              call(, )\n              if(){\n                if(){\n                  call()\n                }\n                goto label\n              }\n              \n            }\n            call()\n            call(, )\n            if()\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              \n              \n              goto label\n            }\n          }\n        }elseif(){\n          call()\n          call(, , )\n          if()\n        }elseif()goto label\n      }elseif(){\n        if()goto label\n        if()goto label\n        if(){\n          call(, call())\n          if(){\n            call(, )\n            \n            \n            goto label\n          }\n          call(, , , )\n          call(, )\n          call()\n        }\n      }else{\n        if(){\n          call()\n          call(, , )\n          goto label\n        }\n        if()goto label\n        \n        \n        \n        if(){\n          \n          if(){\n            \n          }\n          call(, )\n          \n          \n          goto label\n        }\n      }\n      \n      if()\n      \n      \n    }while()\n    if(){\n      call()\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 2.015625,
          "pr_ppl": 2.015625,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.015625,
          "pr_ast_ppl": 2.015625,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": ";\n}\n\n**\nif(100000)\nif(0x3)\n\n\n\nreturn;\n}\n\n```\n\n**23**\nif(0x2)\n```\n\n```\n\n**The 24)\n\n**3**\n\n\n\nreturn;\n\nif (0)\n\n\n\nreturn;\n\nif (0x0020)\n\n\n\nif(0)\n\n\n\nif(0)\n\n\nif(0)\nif(0)\nreturn;\n\n\n\nif (0)\n\n\n\nreturn;\n\nreturn;\nif (0)\n\n\n\nreturn;\n\n\nif (0)\n\n\nreturn;\n\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nreturn;\n\n\n\nreturn;\n\nreturn;\n\n\n\nif (0)\n\n\n\nif (0)\n\nreturn;\n\nreturn;\n\n\n\nif (0)\n\nreturn;\n\n\n\nif (0)\n\n\n\nreturn;\n\n\n\nif (0)\n\n\n\nreturn;\n\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nreturn;\n\n\n\nif (0)\n\n\n\nreturn;\n\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nreturn;\n\nif (0)\n\n\n\nreturn;\n\n\n\nif (0)\n\n\n\nreturn;\n\n\n\nif (0)\n\n\n\nreturn;\n\n\nif (0)\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nreturn;\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nreturn; if (0)\n\n\n\nreturn;\n\n\nif (0)\n\n\n\nif (0)\n\nif (0)\n\n\n\nif (0)\n\n\nreturn;\n\n\n\nif (0)\n\n\n\nreturn;\n\n\n\nif (0)\n\n\n\nreturn;\n\n\n\nif (0)\n\n\n\nreturn;\n\nif (0)\n\n\n\nreturn; if (0)\n\n\n\nreturn; if (0)\n\nif (0)\n\n\n\nreturn;\n\nreturn;\n\n\n\nreturn; if (0)\n\n\n\nreturn; if (0)\n\n\n\nreturn; if (0)\n\n\nif (0)\n\n\nif (0)\n\nif (0)\n\n\nif (0)\n\n\n\nif (0)\n\n\n\nif (0)\n\nif (0)\n\n\n\nif (0)\n\nif (0)\n\n\n\nreturn; if (0)\n\nif (0)\n\n\n\nif (0) if (0)\n\n\nreturn; if (0)\n\nif (0) if (0)\n\nif (0) if (0) if (0) if (0) if (0)\n\n\n\nif (0)\n\n\n\nif (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0)\n\nif (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0)\n\n\n\nif (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0)\n\nreturn;\n\n\n\nelse\n    return; if (0) if (0) if (0) if (0) if (0)\n\nreturn;\n\n\n\nelse\nreturn;\n\n\n\nreturn; if (0)\n\n\n\nreturn; if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0)\n\nreturn;\n\nif (0) if (0) if (0)\n\nreturn;\n\n\n\nif (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0)\n\nreturn; if (0)\n\nelse return;\n\nif (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0)\n\nreturn;\n\n\n\nif (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0)\n\nreturn;\n\nif (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0) if (0)\n\nreturn;\n\nreturn; if (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0)\n\nreturn;\n\nif (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0) return; if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0)\n\nreturn;\n\nreturn; if (0) if (0) if (0) if (0)\n\nif (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0)\n\nreturn;\n\nreturn;\n\nif (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0)\n\nreturn;\n\nif (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0) if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0)\n\nreturn; if (0) if (0) if (0)\n\nreturn; if (0)\n\nreturn;\n\nif (0) if (0) if (0)\n\nreturn; if (0)\n\nreturn; if (0) if (0)\n\nif (0)\n\nreturn; if (0)\n\nreturn;\n\n)\n\n)\nreturn;\n\nreturn; if (0)\n\nreturn;\n\n1;\n\n\nif (0)\n\nreturn;\n\n)\n\n11\n\n)\n\n)\n\n111\n\n\n3330\n\nreturn;\n\nreturn; if (0)\n\nreturn;\n\n)\n\n\n\nreturn;\n\nreturn; if (0)\n\n551;\n\n\n)\n\n\n\n330\n\n) if (0535\n\n3) if (0)\n\nreturn;\n\nif (0)\n\nreturn;\n\n)\n\nreturn;\n\n10)\n\n100\n\n33\n\n330\n\nreturn;\n\nif (0)\n\nreturn;\n\n)\n\n)\n\nif (0)\n\n53\n\n333\n\n)\n\n\nif (0)\n\nreturn;\n\n10)\n\nreturn;\n\n\n13\n\n\n)\n\n\n000\n\nreturn;\n\n)\n\n)\n\nreturn;\n\n1)\n\n\n1)\n\nreturn;\n\n1)\n\n)\n\nreturn;\n\n10)\n\n53\n\n)\n\n10\n\n100\n\n)\n\nreturn;\n\n10\n\n)\n\n\nreturn;\n\n10)\n\nreturn;\n\n530\n\n)\n\n\n)\n\n\n1\n\nreturn;\n\n)\n\nreturn;\n\n),00,\n\n54,\n\n)\n\n\nreturn;\n\n10\n\n0\n\n\n53\n\n)\n\n0\n\n5555\n\n),\n\n0);\n\n100\n\n1);\n\n1)\n\n**1**\n\n\nreturn;\n\n101\n\n)1)\n\nreturn;\n\n10\n\n1)\n\nreturn;\n\n6)\n\n),\n\nreturn;\n\n5,\n\n60),\n\nreturn;\n\nif,\n10,\n1,\n\n),\n\n\n))\n\n```\n\n\n\n```\n\n\n\n\\\n)(55)\n\n```\n\n\n**0**\n\n\n\nreturn;\n\n1001\n\n1),\n\n10055\n\n)\n\n*\n**00500**\n\nreturn;\n\n54\n\n),\n\n33,\n\n)(1),1\n\n0);\n\n6;\n\n)\n\nreturn;\n\n101\n\n)\n\n)\n\n\n\n**0**\n\n\n\n632\n\n),\n\n63555,\n\n)\n\n10;\n\n63,5555\n\n),\n\n\n10,1,\n20,\n10050,\n),\n\n5,\n\n),\n\n555,\n\n629,\n\n),\n\n93\n\n),50\n\n550),\n\n33,\n\n)(0,\n\n550\n\n),\n\n**0**\n\n2.534,\n\n(0),\n\n(34"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-libxls_xls_parseWorkBook-O0.so",
        "function": "xls_parseWorkBook",
        "source_code": "xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)\n{\n    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;\n\n    BOF bof1 = { .id = 0, .size = 0 };\n    BOF bof2 = { .id = 0, .size = 0 };\n    BYTE* buf = NULL;\n\tBYTE once = 0;\n    xls_error_t retval = LIBXLS_OK;\n\n    verbose (\"xls_parseWorkBook\");\n    do {\n\t\tif(xls_debug > 10) {\n\t\t\tprintf(\"READ WORKBOOK filePos=%ld\\n\",  (long)pWB->filepos);\n\t\t\tprintf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",\n                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,\n                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); \n\t\t}\n\n        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {\n            retval = LIBXLS_ERROR_READ;\n            goto cleanup;\n        }\n        xlsConvertBof(&bof1);\n \t\tif(xls_debug) xls_showBOF(&bof1);\n\n        if (bof1.size) {\n            if ((buf = realloc(buf, bof1.size)) == NULL) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to allocate buffer of size %d\\n\", (int)bof1.size);\n                retval = LIBXLS_ERROR_MALLOC;\n                goto cleanup;\n            }\n            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {\n                if (xls_debug) fprintf(stderr, \"Error: failed to read OLE block\\n\");\n                retval = LIBXLS_ERROR_READ;\n                goto  cleanup;\n            }\n        }\n\n        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {\n            retval = LIBXLS_ERROR_PARSE;\n            goto cleanup;\n        }\n\n        switch (bof1.id) {\n        case XLS_RECORD_EOF:\n            //verbose(\"EOF\");\n            break;\n        case XLS_RECORD_BOF:\t// BIFF5-8\n            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);\n            pWB->type = buf[2] + (buf[3] << 8);\n            if(xls_debug) {\n                printf(\"version: %s\\n\", pWB->is5ver ? \"BIFF5\" : \"BIFF8\" );\n                printf(\"   type: %.2X\\n\", pWB->type);\n            }\n            break;\n\n        case XLS_RECORD_CODEPAGE:\n            pWB->codepage = buf[0] + (buf[1] << 8);\n\t\t\tif(xls_debug) printf(\"codepage: %d\\n\", pWB->codepage);\n            break;\n\n        case XLS_RECORD_CONTINUE:\n\t\t\tif(once) {\n\t\t\t\tif (bof2.id==XLS_RECORD_SST) {\n\t\t\t\t\tif ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)\n                        goto cleanup;\n                }\n\t\t\t\tbof1=bof2;\n\t\t\t}\n            break;\n\n\t\tcase XLS_RECORD_WINDOW1:\n\t\t\t{\n\t\t\t\tWIND1 *w = (WIND1*)buf;\n                xlsConvertWindow(w);\n\t\t\t\tpWB->activeSheetIdx = w->itabCur;\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"WINDOW1: \");\n\t\t\t\t\tprintf(\"xWn    : %d\\n\", w->xWn/20);\n\t\t\t\t\tprintf(\"yWn    : %d\\n\", w->yWn/20);\n\t\t\t\t\tprintf(\"dxWn   : %d\\n\", w->dxWn/20);\n\t\t\t\t\tprintf(\"dyWn   : %d\\n\", w->dyWn/20);\n\t\t\t\t\tprintf(\"grbit  : %d\\n\", w->grbit);\n\t\t\t\t\tprintf(\"itabCur: %d\\n\", w->itabCur);\n\t\t\t\t\tprintf(\"itabFi : %d\\n\", w->itabFirst);\n\t\t\t\t\tprintf(\"ctabSel: %d\\n\", w->ctabSel);\n\t\t\t\t\tprintf(\"wTabRat: %d\\n\", w->wTabRatio);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_SST:\n\t\t\t//printf(\"ADD SST\\n\");\n            xlsConvertSst((SST *)buf);\n            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n        case XLS_RECORD_EXTSST:\n            break;\n\n        case XLS_RECORD_BOUNDSHEET:\n\t\t\t{\n\t\t\t\t//printf(\"ADD SHEET\\n\");\n\t\t\t\tBOUNDSHEET *bs = (BOUNDSHEET *)buf;\n                xlsConvertBoundsheet(bs);\n\t\t\t\t// different for BIFF5 and BIFF8\n                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t}\n            break;\n\n        case XLS_RECORD_XF:\n\t\t\tif(pWB->is5ver) {\n\t\t\t\tXF5 *xf;\n\t\t\t\txf = (XF5 *)buf;\n                xlsConvertXf5(xf);\n\n\t\t\t\tif ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\"   font: %d\\n\", xf->font);\n\t\t\t\t\tprintf(\" format: %d\\n\", xf->format);\n\t\t\t\t\tprintf(\"   type: %.4x\\n\", xf->type);\n\t\t\t\t\tprintf(\"  align: %.4x\\n\", xf->align);\n\t\t\t\t\tprintf(\"rotatio: %.4x\\n\", xf->color);\n\t\t\t\t\tprintf(\"  ident: %.4x\\n\", xf->fill);\n\t\t\t\t\tprintf(\"usedatt: %.4x\\n\", xf->border);\n\t\t\t\t\tprintf(\"linesty: %.4x\\n\", xf->linestyle);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tXF8 *xf;\n\t\t\t\txf = (XF8 *)buf;\n                xlsConvertXf8(xf);\n\n\t\t\t\tif ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {\n                    goto cleanup;\n                }\n\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\txls_showXF(xf);\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        case XLS_RECORD_FONT:\n        case XLS_RECORD_FONT_ALT:\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tFONT *f = (FONT*)buf;\n                xlsConvertFont(f);\n\t\t\t\ts = xls_addFont(pWB,f, bof1.size);\n\t\t\t\tif(xls_debug) {\n\t\t\t\t\tprintf(\" height: %d\\n\", f->height);\n\t\t\t\t\tprintf(\"   flag: 0x%x\\n\", f->flag);\n\t\t\t\t\tprintf(\"  color: 0x%x\\n\", f->color);\n\t\t\t\t\tprintf(\" weight: %d\\n\", f->bold);\n\t\t\t\t\tprintf(\"escapem: 0x%x\\n\", f->escapement);\n\t\t\t\t\tprintf(\"underln: 0x%x\\n\", f->underline);\n\t\t\t\t\tprintf(\" family: 0x%x\\n\", f->family);\n\t\t\t\t\tprintf(\"charset: 0x%x\\n\", f->charset);\n\t\t\t\t\tif(s) printf(\"   name: %s\\n\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_FORMAT:\n            xlsConvertFormat((FORMAT *)buf);\n            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {\n                goto cleanup;\n            }\n            break;\n\n\t\tcase XLS_RECORD_STYLE:\n\t\t\tif(xls_debug) {\n\t\t\t\tstruct { unsigned short idx; unsigned char ident; unsigned char lvl; } *styl;\n\t\t\t\tstyl = (void *)buf;\n\n\t\t\t\tprintf(\"    idx: 0x%x\\n\", styl->idx & 0x07FF);\n\t\t\t\tif(styl->idx & 0x8000) {\n\t\t\t\t\tprintf(\"  ident: 0x%x\\n\", styl->ident);\n\t\t\t\t\tprintf(\"  level: 0x%x\\n\", styl->lvl);\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);\n\t\t\t\t\tprintf(\"  name=%s\\n\", s);\n                    free(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n        case XLS_RECORD_PALETTE:\n\t\t\tif(xls_debug > 10) {\n\t\t\t\tunsigned char *p = buf + 2;\n\t\t\t\tint idx, len;\n\n\t\t\t\tlen = buf[0] + (buf[1] << 8);\n\t\t\t\tfor(idx=0; idx<len; ++idx) {\n\t\t\t\t\tprintf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\", idx+8, p[0], p[1], p[2] );\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_1904:\n\t\t\tpWB->is1904 = *(BYTE *)buf;\t// the field is a short, but with little endian the first byte is 0 or 1\n\t\t\tif(xls_debug) {\n\t\t\t\tprintf(\"   mode: 0x%x\\n\", pWB->is1904);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase XLS_RECORD_FILEPASS:\n\t\t\tretval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;\n\t\t\tgoto cleanup;\n\t\t\n\t\tcase XLS_RECORD_DEFINEDNAME:\n\t\t\tif(xls_debug) {\n\t\t\t\tint i;\n                printf(\"   DEFINEDNAME: \");\n\t\t\t\tfor(i=0; i<bof1.size; ++i) printf(\"%2.2x \", buf[i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n        default:\n\t\t\tif(xls_debug)\n\t\t\t{\n\t\t\t\t//xls_showBOF(&bof1);\n\t\t\t\tprintf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\", bof1.id, bof1.size);\n\t\t\t}\n            break;\n        }\n        bof2=bof1;\n\t\tonce=1;\n    }\n    while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));\n\ncleanup:\n    if (buf)\n        free(buf);\n\n    return retval;\n}\n",
        "function_base": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nint xls_parseWorkBook(long *param_1)\n\n{\n  byte bVar1;\n  bool bVar2;\n  ushort uVar3;\n  int iVar4;\n  uint uVar5;\n  long lVar6;\n  ulong uVar7;\n  void *__ptr;\n  char *pcVar8;\n  bool bVar9;\n  int local_84;\n  int local_7c;\n  ushort *local_78;\n  int local_30;\n  ushort *local_28;\n  uint local_20;\n  undefined4 local_1c;\n  long *local_18;\n  int local_c;\n  \n  if (param_1 == (long *)0x0) {\n    local_c = 7;\n  }\n  else {\n    local_18 = param_1;\n    memset(&local_1c,0,4);\n    memset(&local_20,0,4);\n    local_28 = (ushort *)0x0;\n    bVar2 = false;\n    local_30 = 0;\n    verbose(\"xls_parseWorkBook\");\n    do {\n      if (10 < *(int *)PTR_xls_debug_00104fd8) {\n        printf(\"READ WORKBOOK filePos=%ld\\n\",(long)(int)local_18[1]);\n        printf(\"  OLE: start=%d pos=%u size=%u fatPos=%u\\n\",(ulong)*(uint *)(*local_18 + 8),\n               *(ulong *)(*local_18 + 0x10) & 0xffffffff,*(ulong *)(*local_18 + 0x20) & 0xffffffff,\n               *(ulong *)(*local_18 + 0x28) & 0xffffffff);\n      }\n      lVar6 = ole2_read(&local_1c,1,4,*local_18);\n      if (lVar6 != 4) {\n        local_30 = 3;\n        break;\n      }\n      xlsConvertBof(&local_1c);\n      if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n        xls_showBOF(&local_1c);\n      }\n      if (local_1c._2_2_ != 0) {\n        local_28 = (ushort *)realloc(local_28,(ulong)local_1c._2_2_);\n        if (local_28 == (ushort *)0x0) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to allocate buffer of size %d\\n\",\n                    (ulong)local_1c._2_2_);\n          }\n          local_30 = 5;\n          break;\n        }\n        uVar7 = ole2_read(local_28,1,local_1c._2_2_,*local_18);\n        if (uVar7 != local_1c._2_2_) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            fprintf(*(FILE **)PTR_stderr_00104ff8,\"Error: failed to read OLE block\\n\");\n          }\n          local_30 = 3;\n          break;\n        }\n      }\n      iVar4 = xls_isRecordTooSmall(local_18,&local_1c,local_28);\n      if (iVar4 != 0) {\n        local_30 = 4;\n        break;\n      }\n      uVar5 = local_1c & 0xffff;\n      if (uVar5 != 10) {\n        if (uVar5 == 0x18) {\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   DEFINEDNAME: \");\n            for (local_84 = 0; local_84 < (int)(local_1c >> 0x10); local_84 = local_84 + 1) {\n              printf(\"%2.2x \",(ulong)*(byte *)((long)local_28 + (long)local_84));\n            }\n            printf(\"\\n\");\n          }\n        }\n        else if (uVar5 == 0x22) {\n          *(byte *)((long)local_18 + 0xd) = (byte)*local_28;\n          if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n            printf(\"   mode: 0x%x\\n\",(ulong)*(byte *)((long)local_18 + 0xd));\n          }\n        }\n        else {\n          if (uVar5 == 0x2f) {\n            local_30 = 6;\n            break;\n          }\n          if (uVar5 == 0x31) {\nLAB_00101cd6:\n            xlsConvertFont(local_28);\n            lVar6 = xls_addFont(local_18,local_28,local_1c._2_2_);\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\" height: %d\\n\",(ulong)*local_28);\n              printf(\"   flag: 0x%x\\n\",(ulong)local_28[1]);\n              printf(\"  color: 0x%x\\n\",(ulong)local_28[2]);\n              printf(\" weight: %d\\n\",(ulong)local_28[3]);\n              printf(\"escapem: 0x%x\\n\",(ulong)local_28[4]);\n              printf(\"underln: 0x%x\\n\",(ulong)(byte)local_28[5]);\n              printf(\" family: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 0xb));\n              printf(\"charset: 0x%x\\n\",(ulong)(byte)local_28[6]);\n              if (lVar6 != 0) {\n                printf(\"   name: %s\\n\",lVar6);\n              }\n            }\n          }\n          else if (uVar5 == 0x3c) {\n            if (bVar2) {\n              if (((short)local_20 == 0xfc) &&\n                 (local_30 = xls_appendSST(local_18,local_28,local_1c._2_2_), local_30 != 0)) break;\n              local_1c = local_20;\n            }\n          }\n          else if (uVar5 == 0x3d) {\n            xlsConvertWindow(local_28);\n            *(ushort *)(local_18 + 2) = local_28[5];\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"WINDOW1: \");\n              printf(\"xWn    : %d\\n\",(ulong)*local_28 / 0x14,(ulong)*local_28 % 0x14);\n              printf(\"yWn    : %d\\n\",(ulong)local_28[1] / 0x14,(ulong)local_28[1] % 0x14);\n              printf(\"dxWn   : %d\\n\",(ulong)local_28[2] / 0x14,(ulong)local_28[2] % 0x14);\n              printf(\"dyWn   : %d\\n\",(ulong)local_28[3] / 0x14,(ulong)local_28[3] % 0x14);\n              printf(\"grbit  : %d\\n\",(ulong)local_28[4]);\n              printf(\"itabCur: %d\\n\",(ulong)local_28[5]);\n              printf(\"itabFi : %d\\n\",(ulong)local_28[6]);\n              printf(\"ctabSel: %d\\n\",(ulong)local_28[7]);\n              printf(\"wTabRat: %d\\n\",(ulong)local_28[8]);\n            }\n          }\n          else if (uVar5 == 0x42) {\n            *(ushort *)((long)local_18 + 0x12) =\n                 (ushort)(byte)*local_28 + (ushort)*(byte *)((long)local_28 + 1) * 0x100;\n            if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n              printf(\"codepage: %d\\n\",(ulong)*(ushort *)((long)local_18 + 0x12));\n            }\n          }\n          else if (uVar5 == 0x85) {\n            xlsConvertBoundsheet(local_28);\n            local_30 = xls_addSheet(local_18,local_28,local_1c._2_2_);\njoined_r0x00101b73:\n            if (local_30 != 0) break;\n          }\n          else if (uVar5 == 0x92) {\n            if (10 < *(int *)PTR_xls_debug_00104fd8) {\n              local_78 = local_28 + 1;\n              uVar3 = *local_28;\n              bVar1 = *(byte *)((long)local_28 + 1);\n              for (local_7c = 0; local_7c < (int)((uint)(byte)uVar3 + (uint)bVar1 * 0x100);\n                  local_7c = local_7c + 1) {\n                printf(\"   Index=0x%2.2x %2.2x%2.2x%2.2x\\n\",(ulong)(local_7c + 8),\n                       (ulong)(byte)*local_78,(ulong)*(byte *)((long)local_78 + 1),\n                       (ulong)(byte)local_78[1]);\n                local_78 = local_78 + 2;\n              }\n            }\n          }\n          else if (uVar5 == 0xe0) {\n            if (*(char *)((long)local_18 + 0xc) == '\\0') {\n              xlsConvertXf8(local_28);\n              local_30 = xls_addXF8(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                xls_showXF(local_28);\n              }\n            }\n            else {\n              xlsConvertXf5(local_28);\n              local_30 = xls_addXF5(local_18,local_28);\n              if (local_30 != 0) break;\n              if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                printf(\"   font: %d\\n\",(ulong)*local_28);\n                printf(\" format: %d\\n\",(ulong)local_28[1]);\n                printf(\"   type: %.4x\\n\",(ulong)local_28[2]);\n                printf(\"  align: %.4x\\n\",(ulong)local_28[3]);\n                printf(\"rotatio: %.4x\\n\",(ulong)local_28[4]);\n                printf(\"  ident: %.4x\\n\",(ulong)local_28[5]);\n                printf(\"usedatt: %.4x\\n\",(ulong)local_28[6]);\n                printf(\"linesty: %.4x\\n\",(ulong)local_28[7]);\n              }\n            }\n          }\n          else {\n            if (uVar5 == 0xfc) {\n              xlsConvertSst(local_28);\n              local_30 = xls_addSST(local_18,local_28,local_1c._2_2_);\n              goto joined_r0x00101b73;\n            }\n            if (uVar5 != 0xff) {\n              if (uVar5 == 0x231) goto LAB_00101cd6;\n              if (uVar5 == 0x293) {\n                if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    idx: 0x%x\\n\",(ulong)(*local_28 & 0x7ff));\n                  if ((*local_28 & 0x8000) == 0) {\n                    __ptr = (void *)get_string(local_28 + 1,(long)(int)((local_1c >> 0x10) - 2),1,\n                                               local_18);\n                    printf(\"  name=%s\\n\",__ptr);\n                    free(__ptr);\n                  }\n                  else {\n                    printf(\"  ident: 0x%x\\n\",(ulong)(byte)local_28[1]);\n                    printf(\"  level: 0x%x\\n\",(ulong)*(byte *)((long)local_28 + 3));\n                  }\n                }\n              }\n              else {\n                if (uVar5 == 0x41e) {\n                  xlsConvertFormat(local_28);\n                  local_30 = xls_addFormat(local_18,local_28,local_1c._2_2_);\n                  goto joined_r0x00101b73;\n                }\n                if (uVar5 == 0x809) {\n                  *(bool *)((long)local_18 + 0xc) =\n                       (uint)(byte)*local_28 + (uint)*(byte *)((long)local_28 + 1) * 0x100 != 0x600;\n                  *(ushort *)((long)local_18 + 0xe) =\n                       (ushort)(byte)local_28[1] + (ushort)*(byte *)((long)local_28 + 3) * 0x100;\n                  if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                    pcVar8 = \"BIFF8\";\n                    if (*(char *)((long)local_18 + 0xc) != '\\0') {\n                      pcVar8 = \"BIFF5\";\n                    }\n                    printf(\"version: %s\\n\",pcVar8);\n                    printf(\"   type: %.2X\\n\",(ulong)*(ushort *)((long)local_18 + 0xe));\n                  }\n                }\n                else if (*(int *)PTR_xls_debug_00104fd8 != 0) {\n                  printf(\"    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\\n\",\n                         (ulong)(ushort)local_1c,(ulong)local_1c._2_2_);\n                }\n              }\n            }\n          }\n        }\n      }\n      local_20 = local_1c;\n      bVar2 = true;\n      bVar9 = false;\n      if (*(char *)(*local_18 + 0x3c) == '\\0') {\n        bVar9 = (ushort)local_1c != 10;\n      }\n    } while (bVar9);\n    if (local_28 != (ushort *)0x0) {\n      free(local_28);\n    }\n    local_c = local_30;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  if()return\n  \n  \n  \n  \n  \n  call()\n  do{\n    if(){\n      call(, )\n      call(, , , , )\n    }\n    if(call(, , , )){\n      \n      goto label\n    }\n    call()\n    if()call()\n    if(){\n      if(call(, )){\n        if()call(, , )\n        \n        goto label\n      }\n      if(call(, , , )){\n        if()call(, )\n        \n        goto label\n      }\n    }\n    if(call(, , )){\n      \n      goto label\n    }\n    switch(){\n      case :\n        \n        \n      case :\n        \n        \n        \n        if(){\n          call(, (? : ))\n          call(, )\n        }\n        \n      case :\n        \n        if()call(, )\n        \n      case :\n        if(){\n          if(){\n            if(call(, , ))goto label\n          }\n          \n        }\n        \n      case :\n        {\n          \n          call()\n          \n          if(){\n            call()\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }\n        \n      case :\n        \n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        \n      case :\n        {\n          \n          \n          call()\n          \n          if(call(, , )){\n            goto label\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n          }\n        }else{\n          \n          \n          call()\n          if(call(, )){\n            goto label\n          }\n          if(){\n            call()\n          }\n        }\n        \n      case :\n      case :\n        {\n          \n          \n          call()\n          call(, , )\n          if(){\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            call(, )\n            if()call(, )\n          }\n        }\n        \n      case :\n        call()\n        if(call(, , )){\n          goto label\n        }\n        \n      case :\n        if(){\n          \n          \n          call(, )\n          if(){\n            call(, )\n            call(, )\n          }else{\n            call(, , , )\n            call(, )\n            call()\n          }\n        }\n        \n      case :\n        if(){\n          \n          \n          \n          for(;;){\n            call(, , , , )\n            \n          }\n        }\n        \n      case :\n        \n        \n        if(){\n          call(, )\n        }\n        \n      case :\n        \n        goto label\n      case :\n        if(){\n          \n          call()\n          for(;;)call(, )\n          call()\n        }\n        \n      case :\n        \n        if(){\n          \n          call(, , )\n        }\n        \n    }\n    \n    \n  }while()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    call(, , )\n    call(, , )\n    \n    \n    \n    call()\n    do{\n      if(){\n        call(, )\n        call(, , , , )\n      }\n      call(, , , )\n      if(){\n        \n        \n      }\n      call()\n      if(){\n        call()\n      }\n      if(){\n        call(, )\n        if(){\n          if(){\n            call(, , )\n          }\n          \n          \n        }\n        call(, , , )\n        if(){\n          if(){\n            call(, )\n          }\n          \n          \n        }\n      }\n      call(, , )\n      if(){\n        \n        \n      }\n      \n      if(){\n        if(){\n          if(){\n            call()\n            for(;;){\n              call(, )\n            }\n            call()\n          }\n        }elseif(){\n          \n          if(){\n            call(, )\n          }\n        }else{\n          if(){\n            \n            \n          }\n          if(){\n            call()\n            call(, , )\n            if(){\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              if(){\n                call(, )\n              }\n            }\n          }elseif(){\n            if(){\n              if(call(, , ))\n              \n            }\n          }elseif(){\n            call()\n            \n            if(){\n              call()\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, , )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n              call(, )\n            }\n          }elseif(){\n            call()\n            if(){\n              call(, )\n            }\n          }elseif(){\n            call()\n            call(, , )\n            if()\n          }elseif(){\n            if(){\n              \n              \n              \n              for(;;){\n                call(, call(), call(), , )\n                \n              }\n            }\n          }elseif(){\n            if(){\n              call()\n              call(, )\n              if()\n              if(){\n                call()\n              }\n            }else{\n              call()\n              call(, )\n              if()\n              if(){\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n                call(, )\n              }\n            }\n          }else{\n            if(){\n              call()\n              call(, , )\n              goto label\n            }\n            if(){\n              if()goto label\n              if(){\n                if(){\n                  call(, call())\n                  if(){\n                    call(, , , )\n                    call(, )\n                    call()\n                  }else{\n                    call(, )\n                    call(, )\n                  }\n                }\n              }else{\n                if(){\n                  call()\n                  call(, , )\n                  goto label\n                }\n                if(){\n                  call()\n                  \n                  if(){\n                    \n                    if(){\n                      \n                    }\n                    call(, )\n                    call(, )\n                  }\n                }elseif(){\n                  call(, , )\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \n      \n      if(){\n        \n      }\n    }while()\n    if(){\n      call()\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.5,
          "base_ppl": 1.9765625,
          "pr_ppl": 1.984375,
          "source_ast_ppl": 2.1875,
          "base_ast_ppl": 2.140625,
          "pr_ast_ppl": 2.140625,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "```\n\n\n\nThis is a very large block of code and it's difficult to read.\n\n**Please refactor the code to make it readable.\n\n\n**1. Define a new function**\n\n**Please, please, please!**\n\n\n\n\n```\n---\n\n\n\n\n    return 0;\n\n\n**I am not sure what this code does, but it seems to be trying to parse a spreadsheet file**\n\n\nLet's focus on the most important parts and analyze them.\n\n**The code is a good candidate for a re-write.**\n\n\nThe code has a lot of hardcoded values.  It seems to be a loop.\n\n  \n\n\n\n\n\n```\n\n**The code is not well formatted and needs a refactored.\n\n```\n\n```\n\nLet's break down the code.\n\n```\n\nLet's break down the code and rewrite it.\n\n\n\nThe code is a good example of how not to write a loop.\n\nThe code is not clear and is not clear what the code is doing.\n\n\n\n\n\nThe code is not well formatted and needs refactoring.\n\n\n**I'm not sure what the code does. **\n\n```\n\n```\n```\n\nThe code is not clear.\n\n```\n```\n\n\n\n\nThe code is not clear.\n\n\n\nThe code is not clear.\n\n```\n\n\n\n```\n\n\n\nThe code is not clear.\n\n\n\nThe code is not clear.\n\n\n\nThe code is not clear.\n\n\n\nThe code is not clear.\n\n\n\nThe code is not clear.\n\nThe code is not clear.\n\n\n\nThe code is not clear.\n\n\n\nThe code is not clear.\n\n\n\nThe code is not clear.\n\n\n\nThe code is not clear.\n\n\n\nThe code is not clear.\n\nLet me know if you want me to explain the code.\n\n\n\nLet me know if you want me to explain the code.\n\n\n\nLet me know if you want me to explain the code.\n\n\n\nLet me know if you want me to explain the code.\n\n\n\nLet me know if you want me to explain the code.\n\n\n\nLet me know if you want to check it.\n\n\n\nLet me know if you want to check it.\n\n\n\nLet me know if you want to check it.\n\n\n\nLet me know if you want to check it.\n\n\n\nLet me know if you want to check it.\n\n\n\nLet me know if you want to check it.\n\n\n\nLet me know if you want to check it.\n\n\n\nLet me know if you want to check it.\n\n\n\nLet me know if you want to check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nLet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n\n\nlet me check it.\n\n```\n\nI can't get it to work.\n\n```\n\nThe above is the code.\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n```\n\nLet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\nlet me.\n\n\n\nlet me.\n\n```\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\nLet me.\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\nlet me.\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\nlet me.\n\nlet me.\n\n\n\nlet me.\n\nlet me.\n\nlet me.\n\nlet me.\n\nlet me.\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n)\nlet me.\n\nreturn 0;\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\n\n\nlet me.\n\nreturn 0;\n let me.\n\n\n\n)\n\nreturn 0.\n\n\n\n)\n\nreturn 0.\n\n)\nif(1)\n\nlet me.\n\n)\nif(1)\nreturn 0.\n\nif(1.\n\nif(0x100)\n\nif(0x10)\n\nif(0x0)\nif(0x0)\n\n\n\nreturn 0.\n\nreturn 0.\n\nreturn 0.\n\n\n\nreturn 0.\n\n\n\nreturn 0.\n\n\n\nlet me.\n\nreturn 0.\n\nif(0x0.\n\nif(0x0.\n\nif(0x1)\n\n\nlet me.\nlet me.\n\nif(0x0.\n\nif(0x0.\n\n\n\nif(0x0.\n\nif(0x0.\n\nif(0x1)\nif(0x0.\n\nreturn 0.\n\nreturn 0.\n\n\n\nreturn 0.\n\nreturn 0.\n\nreturn 0.\n\n\nlet me.\n\nreturn 0.\n\nif(0x0.\n\n\n\nreturn 0.\n\nif(0x0.\n\nreturn 0.\n\nreturn 0.\n\n\n\nif(0x0.\n\nreturn 0.\n\nlet me.\n\nreturn 0.\n\nreturn 0.\n\n)\n\nreturn 0.\n\n\n\nif(0x0.\n\nif(0x1.\n\nlet me.\n\n\n\nif(0x0.\n\nreturn 0.\n\nif(0x0.\n\nreturn 0.\n\n\n\nif(0x0.\n\nif(0x1)\n\nif(0x0.\n\n\n\nif(0x0.\n\nif(0x1.\n\nif(0x1)\n\nif(0x1.\n\n)\nif(0x0.\n\n)\n\n\n\nif(0"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O2.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.75,
          "pr_ppl": 1.7578125,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.0625,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "  if (p == pe) {\n    return 1;\n  }\n  if (p == pe) {\n    return 1;\n    }\n\n\n\nreturn 0;\n    \n    if (p) {\n\n    }\n    return 0;\n\n    if (p) {\n    if (p)\n    return 0;\n    if (p)\n\n    return 0;\n\n\n\n**Note:**\n    if (p)\n    return 0;\n\n\n\n`\n\n```\n\n**Analysis**\n    \n* **Missing**\n    return 0;\n\n\nThe `sav_parse_long_parse_type, `\n    if (p)\n\n\n\n**The code has been copied to avoid a warning.\n\n\n```\n\n**2**\n    if (p)\n\n\n\n**Explanation:**\n  \n\nThe code has been copied to avoid a warning.\n\n\n\n```\n\n\n  \n\n* *p *\n  if (p)\n\n\n\n```\n\n\n\n```\n\n\n\n```\n\n\n```\n\n```\n\n\n  if (p)\n\n\n  if (p)\n\n\n\n`\n  if (p)\n\n\n\n  if (p)\n\n\n\n*\n\n    if (p)\n\n\n\n    if (p)\n    if (p)\n\n\n\n    if (p)\n    if (p)\n\n\n\n  if (p)\n\n\n\n  if (p)\n  if (p)\n\n`\n\n`\n\n\n\n#  if (p)\n\n\n\n    if (p)\n    if (p)\n\n\n    if (p)\n\n    if (p)\n    if (p)\n\n    if (p)\n\n\n    if (p)\n    if (p)\n    if (p)\n\n\nThe code is a long int\n    if (p)\n    if (p)\n    if (p)\n\n\n\nreturn p\nreturn p\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nreturn p\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n```\n\nThe code has a lot of p\n\nif (p)\n\n\n\nif (p)\n\n  if (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nreturn p\n\nif (p)\n\n\n\nif (p)\n\n\n\nreturn p\n\n\n\nif (p)\n\nif (p)\n\n\n\nreturn p\n\n\n\nreturn p\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p)\n\n\n\nif (p) if (p) if (p) if (p)\n\n\n\nif (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if (p) if"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O3.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 *puVar1;\n  char cVar2;\n  int iVar3;\n  int iVar4;\n  undefined1 *puVar5;\n  char *pcVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  uint uVar9;\n  byte *__n;\n  undefined8 uVar10;\n  long lVar11;\n  uint uVar12;\n  undefined1 *puVar13;\n  ulong uVar14;\n  long lVar15;\n  char *pcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  byte *pbVar19;\n  int local_20ec;\n  byte local_20d9 [9];\n  byte *local_20d0;\n  char *local_20c8;\n  size_t local_20c0;\n  byte *local_20b8;\n  byte *local_20b0;\n  byte *local_20a8;\n  ulong local_20a0;\n  long local_2098;\n  ulong local_2090;\n  byte local_2088 [80];\n  char local_2038 [8200];\n  \n  iVar3 = count_vars(param_3);\n  local_20b0 = param_1 + (int)param_2;\n  local_20a0 = (ulong)param_2;\n  local_20c8 = (char *)build_lookup_table(iVar3,param_3);\n  local_20c0 = (size_t)iVar3;\n  local_20a8 = param_1;\n  if (param_2 == 0) {\n    local_20ec = 1;\n    local_20d0 = (byte *)0x0;\n    __n = (byte *)0x0;\n  }\n  else {\n    local_2098 = 0x50 - (long)local_20c8;\n    local_20ec = 1;\n    __n = (byte *)0x0;\n    local_20d0 = (byte *)0x0;\n    pbVar19 = param_1;\n    do {\n      lVar11 = (long)local_20ec;\n      puVar5 = _sav_long_variable_parse_trans_keys +\n               *(short *)(_sav_long_variable_parse_key_offsets + lVar11 * 2);\n      uVar9 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + lVar11 * 2);\n      uVar12 = (uint)(char)_sav_long_variable_parse_single_lengths[lVar11];\n      puVar13 = puVar5 + ((ulong)uVar12 - 1);\n      if (puVar5 <= puVar13) {\n        puVar8 = puVar5;\n        do {\n          while( true ) {\n            lVar15 = (long)puVar13 - (long)puVar8 >> 1;\n            puVar1 = puVar8 + lVar15;\n            if (*pbVar19 < (byte)puVar8[lVar15]) break;\n            if (*pbVar19 <= (byte)puVar8[lVar15]) {\n              uVar7 = (int)puVar1 - (int)puVar5;\n              goto LAB_00101300;\n            }\n            puVar8 = puVar1 + 1;\n            if (puVar13 < puVar8) goto LAB_00101280;\n          }\n          puVar13 = puVar1 + -1;\n        } while (puVar8 <= puVar13);\n      }\nLAB_00101280:\n      uVar7 = uVar12 + uVar9;\n      uVar9 = (uint)(char)_sav_long_variable_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_long_variable_parse_range_lengths[lVar11]) {\n        puVar5 = puVar5 + uVar12;\n        puVar13 = puVar5 + (ulong)uVar9 * 2 + -2;\n        if (puVar5 <= puVar13) {\n          puVar8 = puVar5;\n          do {\n            while (uVar14 = (long)puVar13 - (long)puVar8 >> 1 & 0xfffffffffffffffe,\n                  *pbVar19 < (byte)puVar8[uVar14]) {\n              puVar13 = puVar8 + (uVar14 - 2);\n              if (puVar13 < puVar8) goto LAB_00101300;\n            }\n            if (*pbVar19 <= (byte)puVar8[uVar14 + 1]) {\n              uVar9 = (uint)((ulong)(puVar8 + (uVar14 - (long)puVar5)) >> 1);\n              break;\n            }\n            puVar8 = puVar8 + uVar14 + 2;\n          } while (puVar8 <= puVar13);\n        }\nLAB_00101300:\n        uVar7 = uVar7 + uVar9;\n      }\n      local_2090 = (ulong)(uint)(int)(char)_sav_long_variable_parse_indicies[uVar7];\n      local_20ec = (int)(char)(&_sav_long_variable_parse_trans_targs)[local_2090];\n      lVar11 = (long)(char)_sav_long_variable_parse_trans_actions[local_2090];\n      if ((lVar11 != 0) &&\n         (iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c],\n         \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"[lVar11 + 0x2c] != '\\0')) {\n        pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" + lVar11 + 0x2c;\n        do {\n          pcVar18 = local_20c8;\n          switch(pcVar16[1]) {\n          case '\\0':\n            memcpy(local_20d9,local_20d0,(size_t)__n);\n            local_20d9[(long)__n] = 0;\n            break;\n          case '\\x01':\n          case '\\x05':\n            local_20d0 = pbVar19;\n            break;\n          case '\\x02':\n          case '\\x06':\n            __n = pbVar19 + -(long)local_20d0;\n            break;\n          case '\\x03':\n            local_20b8 = __n;\n            pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n            __n = local_20b8;\n            if (pcVar6 == (char *)0x0) {\n              snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n              __n = local_20b8;\n              if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n                (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n                __n = local_20b8;\n              }\n            }\n            else {\n              pcVar17 = pcVar6;\n              if (pcVar18 <= pcVar6) {\n                do {\n                  iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  pcVar17 = pcVar17 + -0x28;\n                } while (local_20c8 <= pcVar17);\n              }\n              pcVar18 = pcVar6 + 0x28;\n              if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0)\n              {\n                pcVar6 = pcVar6 + local_2098;\n                do {\n                  iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                  if (iVar4 != 0) break;\n                  snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                             (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                           (ulong)__n & 0xffffffff,local_2088);\n                  lVar11 = (long)pcVar6 >> 3;\n                  pcVar6 = pcVar6 + 0x28;\n                  pcVar18 = pcVar18 + 0x28;\n                } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n              }\n            }\n            break;\n          case '\\x04':\n            memcpy(local_2088,local_20d0,(size_t)__n);\n            local_2088[(long)__n] = 0;\n          }\n          pcVar16 = pcVar16 + 1;\n          iVar3 = iVar3 + -1;\n        } while (iVar3 != 0);\n      }\n      param_1 = pbVar19;\n      if ((int)local_2090 == 1) goto LAB_001017bb;\n      pbVar19 = pbVar19 + 1;\n      param_1 = local_20b0;\n    } while (pbVar19 != local_20b0);\n  }\n  iVar3 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n               [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c];\n  if (\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n      [(long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c] != '\\0') {\n    pcVar16 = \" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\" +\n              (long)(char)_sav_long_variable_parse_eof_actions[local_20ec] + 0x2c;\n    local_20b0 = local_20b0 + -(long)local_20d0;\n    local_20b8 = (byte *)(0x50 - (long)local_20c8);\n    do {\n      pcVar18 = local_20c8;\n      cVar2 = pcVar16[1];\n      pbVar19 = local_20b0;\n      if (cVar2 != '\\x06') {\n        pbVar19 = __n;\n        if (cVar2 == '\\x04') {\n          memcpy(local_2088,local_20d0,(size_t)__n);\n          local_2088[(long)__n] = 0;\n        }\n        else if (cVar2 == '\\x03') {\n          pcVar6 = (char *)bsearch(local_20d9,local_20c8,local_20c0,0x28,compare_key_varlookup);\n          if (pcVar6 == (char *)0x0) {\n            snprintf(local_2038,0x2000,\"Failed to find %s\",local_20d9);\n            if (*(code **)(param_3 + 0x30) != (code *)0x0) {\n              (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n            }\n          }\n          else {\n            pcVar17 = pcVar6;\n            if (pcVar18 <= pcVar6) {\n              do {\n                iVar4 = strcmp(pcVar17,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar17 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                pcVar17 = pcVar17 + -0x28;\n              } while (local_20c8 <= pcVar17);\n            }\n            pcVar18 = pcVar6 + 0x28;\n            if (((long)pcVar18 - (long)local_20c8 >> 3) * -0x3333333333333333 < (long)local_20c0) {\n              pcVar6 = pcVar6 + (long)local_20b8;\n              do {\n                iVar4 = strcmp(pcVar18,(char *)local_20d9);\n                if (iVar4 != 0) break;\n                snprintf((char *)(*(long *)(*(long *)(param_3 + 0x58) +\n                                           (long)*(int *)(pcVar18 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                         (ulong)__n & 0xffffffff,local_2088);\n                lVar11 = (long)pcVar6 >> 3;\n                pcVar6 = pcVar6 + 0x28;\n                pcVar18 = pcVar18 + 0x28;\n              } while (lVar11 * -0x3333333333333333 < (long)local_20c0);\n            }\n          }\n        }\n      }\n      pcVar16 = pcVar16 + 1;\n      iVar3 = iVar3 + -1;\n      __n = pbVar19;\n    } while (iVar3 != 0);\n  }\n  uVar10 = 0;\n  if (local_20ec < 0xb) {\nLAB_001017bb:\n    uVar10 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(local_2038,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               local_20a0,local_20a8,(long)param_1 - (long)local_20a8,local_20a0,(ulong)*param_1);\n      (**(code **)(param_3 + 0x30))(local_2038,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (local_20c8 != (char *)0x0) {\n    free(local_20c8);\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  call(, )\n  \n  \n  if(){\n    \n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      \n      \n      if(){\n        \n        do{\n          while(){\n            \n            \n            if()\n            if(){\n              \n              goto label\n            }\n            \n            if()goto label\n          }\n          \n        }while()\n      }\n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      \n      if(){\n        \n        do{\n          \n          switch(){\n            case :\n              call(, , )\n              \n              \n            case :\n            case :\n              \n              \n            case :\n            case :\n              \n              \n            case :\n              \n              call(, , , , )\n              \n              if(){\n                call(, , , )\n                \n                if(){\n                  call(, )\n                  \n                }\n              }else{\n                \n                if(){\n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                  }while()\n                }\n                \n                if(){\n                  \n                  do{\n                    call(, )\n                    if()\n                    call(, , , , )\n                    \n                    \n                    \n                  }while()\n                }\n              }\n              \n            case :\n              call(, , )\n              \n          }\n          \n          \n        }while()\n      }\n      \n      if()goto label\n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        if(){\n          call(, , )\n          \n        }elseif(){\n          call(, , , , )\n          if(){\n            call(, , , )\n            if(){\n              call(, )\n            }\n          }else{\n            \n            if(){\n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n              }while()\n            }\n            \n            if(){\n              \n              do{\n                call(, )\n                if()\n                call(, , , , )\n                \n                \n                \n              }while()\n            }\n          }\n        }\n      }\n      \n      \n      \n    }while()\n  }\n  \n  if(){\n    \n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.75,
          "pr_ppl": 1.7578125,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 2.0625,
          "pr_ast_ppl": 2.0625,
          "delta_ppl": 0.0078125
        },
        "llm_qualitative": {
          "winner": "Error",
          "motivation": "The above is a valid code.\n\nThe above is the first.\n`p`\n\n}\n    if (p)\n    p\n\n\n\n```\n\n**Notes:**\n\n* The code is a code.\n* The code is a code\n  return;\n\n;\n  return;\n\n\n\nreturn;\n  return;\n\n```\n\nLet us do\n\n```\n\n```\n\n\n\n`_sav_long_parse_parse_action\n\n\n\n`_sav_long_parse_parse_action\n\n\n```\n\n```\n\n\n\n\nThe above\n\n\n`\n\n\n\n\n```\n  `\n\n\n\nThe above\n\n\n\n```\n`\n\n\n\n```\n\nThe above\n;\n```\n\n\n\n```\n\n\n\nreturn;\n```\n\n```\n\n\n\n`\n\n\n\n`\n\n\n\n```\n\n\n\n`\n\n\nreturn;\n\n\n\n`\n\n\n\n`\n\n\n\n\n\n\n\n`\n\n\n\n_sav_parse_parse_parse_action\n\n```\n\n\n```\n\nreturn\n\n\n\n```\n\n\n\nreturn\n\n\n\n```\n\n\n_sav_parse_parse_trans_action\n\n\n\n```\n\n\n_sav_parse_parse_trans_actions\n\n\n\n`\n\n\n\n`\n\n\n\n_sav_parse_indicies\n\n\n\n_sav_parse_indicies\n\n\n\n_sav_parse_trans_actions\n\n\n\n_sav_parse_trans_actions\n\n\n\n_sav_parse_indicies\n\n\n\n_sav_parse_indicies\n\n\n\n_sav_parse_indicies\n\n`\n\n`\n\n\n\n`\n\n_sav_parse_parse_actions\n\n\n\n_sav_parse_trans_actions\n\n\n\n_sav_parse_indicies\n\n_sav_parse_indicies\n_sav_parse_indicies\n\n\n_sav_parse_indicies\n\n\n_sav_parse_parse_indicies\n\n\n\n_sav_parse_indicies_\n\n_sav_parse_indicies_\n\n_sav_parse_indicies_\n\n\n\n_sav_parse_parse_indicies_\n_sav_parse_parse_indicies_\n\n_sav_parse_parse_actions_\n\n_sav_parse_parse_trans_actions_\n\n\n\n_sav_parse_indicies_\n\n_sav_parse_parse_end\n\n\n_sav_parse_end_parse_parse_end\n\n\n\n_sav_parse_end_parse_end_end\n\n_sav_parse_end_end_end_end_parse_parse_end_end_end_parse_end_end_parse_end_end_parse_end_end_parse_end_end_parse_end_end_parse_end_end_parse_end_end_parse_end_end_parse_end_end_parse_end_end_end_parse_end_end_parse_end_end_parse_end_end_parse_end_end_end_end_end_parse_end_end_end_parse_end_end_end_parse_end_end_parse_end_end_end_end_end_end_parse_end_end_parse_end_end_end_end_end_end_end_parse_end_end_end_end_end_end_parse_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O2.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto LAB_00101707;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_0010171a;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\nLAB_00101707:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_0010171a:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.875,
          "pr_ppl": 1.859375,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.28125,
          "delta_ppl": -0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more accurate as it correctly handles potential errors during the parsing process and offers a more structured approach with clear state transitions.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O3.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup), pcVar21 = pcVar8\n         , pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  byte *pbVar1;\n  undefined1 *puVar2;\n  long lVar3;\n  byte bVar4;\n  int iVar5;\n  uint uVar6;\n  int iVar7;\n  char *__s;\n  char *__base;\n  char *pcVar8;\n  int iVar9;\n  undefined1 *puVar10;\n  ulong uVar11;\n  int iVar12;\n  long lVar13;\n  char *pcVar14;\n  undefined8 uVar15;\n  byte *pbVar16;\n  char *pcVar17;\n  uint uVar18;\n  undefined1 *puVar19;\n  undefined1 *puVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *local_b8;\n  size_t local_80;\n  char local_58 [40];\n  \n  iVar5 = count_vars(param_3);\n  pbVar1 = param_1 + param_2;\n  __s = (char *)readstat_malloc();\n  __base = (char *)build_lookup_table(iVar5,param_3);\n  if (param_2 == 0) {\n    iVar9 = 1;\n    uVar22 = 0;\n  }\n  else {\n    local_80 = 0;\n    iVar9 = 1;\n    local_b8 = (byte *)0x0;\n    uVar22 = 0;\n    pbVar16 = param_1;\n    do {\n      uVar11 = (ulong)iVar9;\n      puVar10 = _sav_very_long_string_parse_trans_keys +\n                (char)_sav_very_long_string_parse_key_offsets[uVar11];\n      uVar6 = (uint)(char)_sav_very_long_string_parse_index_offsets[uVar11];\n      if (iVar9 != 10) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_single_lengths[uVar11];\n        puVar19 = puVar10 + ((ulong)uVar18 - 1);\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while( true ) {\n              lVar13 = (long)puVar19 - (long)puVar20 >> 1;\n              puVar2 = puVar20 + lVar13;\n              if (*pbVar16 < (byte)puVar20[lVar13]) break;\n              if (*pbVar16 <= (byte)puVar20[lVar13]) {\n                uVar6 = ((int)puVar2 - (int)puVar10) + uVar6;\n                goto LAB_00101342;\n              }\n              puVar20 = puVar2 + 1;\n              if (puVar19 < puVar20) goto LAB_001012b0;\n            }\n            puVar19 = puVar2 + -1;\n          } while (puVar20 <= puVar19);\n        }\nLAB_001012b0:\n        puVar10 = puVar10 + uVar18;\n        uVar6 = uVar6 + uVar18;\n      }\n      if ((0x2dfeUL >> (uVar11 & 0x3f) & 1) != 0) {\n        uVar18 = (uint)(char)_sav_very_long_string_parse_range_lengths[uVar11];\n        puVar19 = puVar10 + (ulong)uVar18 * 2 + -2;\n        if (puVar10 <= puVar19) {\n          puVar20 = puVar10;\n          do {\n            while (uVar11 = (long)puVar19 - (long)puVar20 >> 1 & 0xfffffffffffffffe,\n                  *pbVar16 < (byte)puVar20[uVar11]) {\n              puVar19 = puVar20 + (uVar11 - 2);\n              if (puVar19 < puVar20) goto LAB_00101340;\n            }\n            if (*pbVar16 <= (byte)puVar20[uVar11 + 1]) {\n              uVar18 = (uint)((ulong)(puVar20 + (uVar11 - (long)puVar10)) >> 1);\n              break;\n            }\n            puVar20 = puVar20 + uVar11 + 2;\n          } while (puVar20 <= puVar19);\n        }\nLAB_00101340:\n        uVar6 = uVar6 + uVar18;\n      }\nLAB_00101342:\n      uVar18 = (uint)(char)_sav_very_long_string_parse_indicies[uVar6];\n      iVar9 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar18];\n      if ((0xc3f6UL >> ((long)(char)_sav_very_long_string_parse_indicies[uVar6] & 0x3fU) & 1) == 0)\n      {\n        iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                            [(char)_sav_very_long_string_parse_trans_actions[uVar18]];\n        if (iVar12 != 0) {\n          puVar10 = _sav_very_long_string_parse_actions +\n                    (char)_sav_very_long_string_parse_trans_actions[uVar18];\n          do {\n            switch(puVar10[1]) {\n            case 0:\n              memcpy(local_58,local_b8,local_80);\n              local_58[local_80] = '\\0';\n              break;\n            case 1:\n              local_b8 = pbVar16;\n              break;\n            case 2:\n              local_80 = (long)pbVar16 - (long)local_b8;\n              break;\n            case 3:\n              pcVar21 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup);\n              pcVar8 = pcVar21;\n              if (pcVar21 != (char *)0x0) {\n                do {\n                  pcVar14 = pcVar8;\n                  pcVar8 = pcVar14 + -0x28;\n                  if (pcVar8 < __base) break;\n                  iVar7 = strcmp(pcVar8,local_58);\n                } while (iVar7 == 0);\n                pcVar8 = pcVar21 + (0x28 - (long)__base);\n                do {\n                  pcVar17 = pcVar21;\n                  if ((long)iVar5 <= ((long)pcVar8 >> 3) * -0x3333333333333333) break;\n                  iVar7 = strcmp(pcVar17 + 0x28,local_58);\n                  pcVar8 = pcVar8 + 0x28;\n                  pcVar21 = pcVar17 + 0x28;\n                } while (iVar7 == 0);\n                if (pcVar14 <= pcVar17) {\n                  lVar13 = *(long *)(param_3 + 0x58);\n                  do {\n                    lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n                    *(uint *)(lVar3 + 0x14) = uVar22;\n                    *(uint *)(lVar3 + 0x28) = uVar22;\n                    *(uint *)(lVar3 + 0x1c) = uVar22;\n                    pcVar14 = pcVar14 + 0x28;\n                  } while (pcVar14 <= pcVar17);\n                }\n              }\n              break;\n            case 4:\n              if (*pbVar16 != 0) {\n                bVar4 = *pbVar16 - 0x30;\n                if (~(uint)bVar4 / 10 < uVar22) {\n                  pbVar16 = pbVar16 + 1;\n                  goto joined_r0x00101701;\n                }\n                uVar22 = (uint)bVar4 + uVar22 * 10;\n              }\n              break;\n            case 5:\n              uVar22 = 0;\n            }\n            puVar10 = puVar10 + 1;\n            iVar12 = iVar12 + -1;\n          } while (iVar12 != 0);\n        }\n      }\n      if (uVar18 == 1) goto LAB_00101724;\n      pbVar16 = pbVar16 + 1;\n    } while (pbVar16 != pbVar1);\n  }\n  iVar12 = (int)(char)_sav_very_long_string_parse_actions\n                      [(char)_sav_very_long_string_parse_eof_actions[iVar9]];\n  pbVar16 = pbVar1;\n  if (_sav_very_long_string_parse_actions[(char)_sav_very_long_string_parse_eof_actions[iVar9]] !=\n      '\\0') {\n    puVar10 = _sav_very_long_string_parse_actions +\n              (char)_sav_very_long_string_parse_eof_actions[iVar9];\n    do {\n      if ((puVar10[1] == '\\x03') &&\n         (pcVar8 = (char *)bsearch(local_58,__base,(long)iVar5,0x28,compare_key_varlookup),\n         pcVar21 = pcVar8, pcVar8 != (char *)0x0)) {\n        do {\n          pcVar14 = pcVar21;\n          pcVar21 = pcVar14 + -0x28;\n          if (pcVar21 < __base) break;\n          iVar7 = strcmp(pcVar21,local_58);\n        } while (iVar7 == 0);\n        pcVar21 = pcVar8 + (0x28 - (long)__base);\n        do {\n          pcVar17 = pcVar8;\n          if ((long)iVar5 <= ((long)pcVar21 >> 3) * -0x3333333333333333) break;\n          iVar7 = strcmp(pcVar17 + 0x28,local_58);\n          pcVar21 = pcVar21 + 0x28;\n          pcVar8 = pcVar17 + 0x28;\n        } while (iVar7 == 0);\n        if (pcVar14 <= pcVar17) {\n          lVar13 = *(long *)(param_3 + 0x58);\n          do {\n            lVar3 = *(long *)(lVar13 + (long)*(int *)(pcVar14 + 0x24) * 8);\n            *(uint *)(lVar3 + 0x14) = uVar22;\n            *(uint *)(lVar3 + 0x28) = uVar22;\n            *(uint *)(lVar3 + 0x1c) = uVar22;\n            pcVar14 = pcVar14 + 0x28;\n          } while (pcVar14 <= pcVar17);\n        }\n      }\n      puVar10 = puVar10 + 1;\n      iVar12 = iVar12 + -1;\n    } while (iVar12 != 0);\n  }\njoined_r0x00101701:\n  if ((iVar9 < 0xb) || (uVar15 = 0, pbVar16 != pbVar1)) {\nLAB_00101724:\n    uVar15 = 5;\n    if (*(long *)(param_3 + 0x30) != 0) {\n      snprintf(__s,(long)(param_2 + 0x400),\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)pbVar16 - (long)param_1,(long)param_2,(ulong)(uint)((int)pbVar1 - (int)pbVar16)\n               ,pbVar16);\n      (**(code **)(param_3 + 0x30))(__s,*(undefined8 *)(param_3 + 0x50));\n    }\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return uVar15;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  call()\n  call(, )\n  if(){\n    \n    \n  }else{\n    \n    \n    \n    \n    \n    do{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n      \n      \n      if(){\n        \n        if(){\n          \n          do{\n            switch(){\n              case :\n                call(, , )\n                \n                \n              case :\n                \n                \n              case :\n                \n                \n              case :\n                call(, , , , )\n                \n                if(){\n                  do{\n                    \n                    \n                    if()\n                    call(, )\n                  }while()\n                  \n                  do{\n                    \n                    if()\n                    call(, )\n                    \n                    \n                  }while()\n                  if(){\n                    \n                    do{\n                      \n                      \n                      \n                      \n                      \n                    }while()\n                  }\n                }\n                \n              case :\n                if(){\n                  \n                  if(){\n                    \n                    goto label\n                  }\n                  \n                }\n                \n              case :\n                \n            }\n            \n            \n          }while()\n        }\n      }\n      if()goto label\n      \n    }while()\n  }\n  \n  \n  if(){\n    \n    do{\n      if(call(, , , , )){\n        do{\n          \n          \n          if()\n          call(, )\n        }while()\n        \n        do{\n          \n          if()\n          call(, )\n          \n          \n        }while()\n        if(){\n          \n          do{\n            \n            \n            \n            \n            \n          }while()\n        }\n      }\n      \n      \n    }while()\n  }\n  if(){\n    \n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.8828125,
          "pr_ppl": 1.875,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.28125,
          "pr_ast_ppl": 2.28125,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B's output is more human-readable by using clear variable names and structures for clarity.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_long_variable_names_record-O0.so",
        "function": "sav_parse_long_variable_names_record",
        "source_code": "readstat_error_t sav_parse_long_variable_names_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8+1];\n    char temp_val[64+1];\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n    \n    char error_buf[8192];\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n\n    varlookup_t *table = build_lookup_table(var_count, ctx);\n\n    unsigned char *eof = pe;\n\n    int cs;\n\n    \n#line 306 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_long_variable_parse_start;\n\t}\n\n#line 311 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_long_variable_parse_trans_keys + _sav_long_variable_parse_key_offsets[cs];\n\t_trans = _sav_long_variable_parse_index_offsets[cs];\n\n\t_klen = _sav_long_variable_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_long_variable_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_long_variable_parse_indicies[_trans];\n\tcs = _sav_long_variable_parse_trans_targs[_trans];\n\n\tif ( _sav_long_variable_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 5:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 444 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_long_variable_parse_actions + _sav_long_variable_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 102 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (!found) {\n                snprintf(error_buf, sizeof(error_buf), \"Failed to find %s\", temp_key);\n                if (ctx->handle.error)\n                    ctx->handle.error(error_buf, ctx->user_ctx);\n            } else {\n                // Handle the edge case where a ghost variable name (from a multi-segment\n                // variable) is identical to a real variable name. Normally we handle this\n                // by incrementing the loop variable by n_segments, but n_segments hasn't\n                // been set when this record is processed. So just set the longname to every\n                // matching variable, ghost or real.\n                varlookup_t *iter_match = found;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    spss_varinfo_t *info = ctx->varinfo[iter_match->index];\n                    snprintf(info->longname, sizeof(info->longname), \"%*s\", (int)str_len, temp_val);\n                    iter_match++;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 129 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            memcpy(temp_val, str_start, str_len);\n            temp_val[str_len] = '\\0';\n        }\n\tbreak;\n\tcase 6:\n#line 134 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n#line 500 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 142 \"src/spss/readstat_sav_parse.rl\"\n\n\n    if (cs < 11|| p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, sizeof(error_buf), \"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\", \n                    count, (char *)data, (long)(p - c_data), count, *p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n\n    if (table)\n        free(table);\n\n    /* suppress warning */\n    (void)sav_long_variable_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x00101235) */\n\nundefined4 sav_parse_long_variable_names_record(byte *param_1,uint param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  uint uVar3;\n  byte *pbVar4;\n  char *__base;\n  byte *pbVar5;\n  byte *pbVar6;\n  int iVar7;\n  undefined *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_2150;\n  int local_213c;\n  char *local_2138;\n  char *local_2120;\n  byte *local_2110;\n  byte *local_2100;\n  byte *local_20f8;\n  byte *local_20e8;\n  byte *local_20e0;\n  int local_20d4;\n  undefined *local_20d0;\n  uint local_20c4;\n  int local_20bc;\n  char local_2098 [8192];\n  size_t local_98;\n  byte *local_90;\n  undefined1 local_88 [79];\n  char local_39 [9];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  uint local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  pbVar6 = local_28;\n  local_30 = 0;\n  local_90 = (byte *)0x0;\n  local_98 = 0;\n  pbVar4 = local_28 + (int)local_14;\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_20bc = 1;\n  for (; pbVar6 != pbVar4; pbVar6 = pbVar6 + 1) {\n    local_20e0 = _sav_long_variable_parse_trans_keys +\n                 (int)*(short *)(_sav_long_variable_parse_key_offsets + (long)local_20bc * 2);\n    local_20c4 = (uint)*(short *)(_sav_long_variable_parse_index_offsets + (long)local_20bc * 2);\n    iVar7 = (int)(char)_sav_long_variable_parse_single_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_20f8 = local_20e0 + (long)iVar7 + -1;\n      local_20e8 = local_20e0;\n      while (local_20e8 <= local_20f8) {\n        pbVar5 = local_20e8 + ((long)local_20f8 - (long)local_20e8 >> 1);\n        if (*pbVar6 < *pbVar5) {\n          local_20f8 = pbVar5 + -1;\n        }\n        else {\n          if (*pbVar6 <= *pbVar5) {\n            local_20c4 = ((int)pbVar5 - (int)local_20e0) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_20e8 = pbVar5 + 1;\n        }\n      }\n      local_20e0 = local_20e0 + iVar7;\n      local_20c4 = iVar7 + local_20c4;\n    }\n    iVar7 = (int)(char)_sav_long_variable_parse_range_lengths[local_20bc];\n    if (0 < iVar7) {\n      local_2100 = local_20e0;\n      local_2110 = local_20e0 + (long)(iVar7 << 1) + -2;\n      while (local_2100 <= local_2110) {\n        pbVar5 = local_2100 + ((long)local_2110 - (long)local_2100 >> 1 & 0xfffffffffffffffe);\n        if (*pbVar6 < *pbVar5) {\n          local_2110 = pbVar5 + -2;\n        }\n        else {\n          if (*pbVar6 <= pbVar5[1]) {\n            local_20c4 = (int)((long)pbVar5 - (long)local_20e0 >> 1) + local_20c4;\n            goto LAB_0010150a;\n          }\n          local_2100 = pbVar5 + 2;\n        }\n      }\n      local_20c4 = iVar7 + local_20c4;\n    }\nLAB_0010150a:\n    uVar3 = (uint)(char)_sav_long_variable_parse_indicies[local_20c4];\n    local_20bc = (int)(char)(&_sav_long_variable_parse_trans_targs)[uVar3];\n    if (_sav_long_variable_parse_trans_actions[uVar3] != '\\0') {\n      local_20d4 = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                        [(long)(int)(char)_sav_long_variable_parse_trans_actions[uVar3] + 0x2c];\n      local_20d0 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_trans_actions[uVar3];\n      while (iVar7 = local_20d4 + -1, local_20d4 != 0) {\n        puVar8 = local_20d0 + 1;\n        uVar1 = *local_20d0;\n        local_20d4 = iVar7;\n        local_20d0 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_39,local_90,local_98);\n          local_39[local_98] = '\\0';\n          break;\n        case 1:\n          local_90 = pbVar6;\n          break;\n        case 2:\n          local_98 = (long)pbVar6 - (long)local_90;\n          break;\n        case 3:\n          pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_2120 = pcVar9;\n          if (pcVar9 == (char *)0x0) {\n            snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n            if (*(long *)(local_20 + 0x30) != 0) {\n              (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n            }\n          }\n          else {\n            while( true ) {\n              bVar10 = false;\n              if (__base <= local_2120) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(local_2120 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              local_2120 = local_2120 + -0x28;\n            }\n            while( true ) {\n              local_2120 = pcVar9 + 0x28;\n              bVar10 = false;\n              if (((long)local_2120 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_2120,local_39);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                         (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                       local_98 & 0xffffffff,local_88);\n              pcVar9 = local_2120;\n            }\n          }\n          break;\n        case 4:\n          memcpy(local_88,local_90,local_98);\n          local_88[local_98] = 0;\n          break;\n        case 5:\n          local_90 = pbVar6;\n          break;\n        case 6:\n          local_98 = (long)pbVar6 - (long)local_90;\n        }\n      }\n    }\n    if (local_20bc == 0) goto LAB_00101c3a;\n  }\n  if (pbVar6 == pbVar4) {\n    local_213c = (int)\" !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJK\"\n                      [(long)(int)(char)_sav_long_variable_parse_eof_actions[local_20bc] + 0x2c];\n    local_2138 = &DAT_0010259c + (int)(char)_sav_long_variable_parse_eof_actions[local_20bc];\n    while (iVar7 = local_213c + -1, local_213c != 0) {\n      pcVar9 = local_2138 + 1;\n      cVar2 = *local_2138;\n      local_213c = iVar7;\n      local_2138 = pcVar9;\n      if (cVar2 == '\\x03') {\n        pcVar9 = (char *)bsearch(local_39,__base,(long)local_2c,0x28,compare_key_varlookup);\n        local_2150 = pcVar9;\n        if (pcVar9 == (char *)0x0) {\n          snprintf(local_2098,0x2000,\"Failed to find %s\",local_39);\n          if (*(long *)(local_20 + 0x30) != 0) {\n            (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n          }\n        }\n        else {\n          while( true ) {\n            bVar10 = false;\n            if (__base <= local_2150) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(local_2150 + 0x24) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            local_2150 = local_2150 + -0x28;\n          }\n          while( true ) {\n            local_2150 = pcVar9 + 0x28;\n            bVar10 = false;\n            if (((long)local_2150 - (long)__base) / 0x28 < (long)local_2c) {\n              iVar7 = strcmp(local_2150,local_39);\n              bVar10 = iVar7 == 0;\n            }\n            if (!bVar10) break;\n            snprintf((char *)(*(long *)(*(long *)(local_20 + 0x58) +\n                                       (long)*(int *)(pcVar9 + 0x4c) * 8) + 0xc4),0x41,\"%*s\",\n                     local_98 & 0xffffffff,local_88);\n            pcVar9 = local_2150;\n          }\n        }\n      }\n      else if (cVar2 == '\\x04') {\n        memcpy(local_88,local_90,local_98);\n        local_88[local_98] = 0;\n      }\n      else if (cVar2 == '\\x06') {\n        local_98 = (long)pbVar6 - (long)local_90;\n      }\n    }\n  }\nLAB_00101c3a:\n  if ((local_20bc < 0xb) || (pbVar6 != pbVar4)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(local_2098,0x2000,\"Error parsing string \\\"%.*s\\\" around byte #%ld/%d, character %c\",\n               (ulong)local_14,local_10,(long)pbVar6 - (long)local_28,local_14,(uint)*pbVar6);\n      (**(code **)(local_20 + 0x30))(local_2098,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            call(, , , )\n            if()call(, )\n          }else{\n            \n            \n            \n            \n            \n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n            \n            while(call(, )){\n              \n              call(, , , , )\n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              call(, , , )\n              if()call(, )\n            }else{\n              \n              \n              \n              \n              \n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n              \n              while(call(, )){\n                \n                call(, , , , )\n                \n              }\n            }\n          }\n          \n          case :\n          \n          {\n            call(, , )\n            \n          }\n          \n          case :\n          \n          {\n            \n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              call(, , , )\n              if(){\n                call(, )\n              }\n            }else{\n              while(){\n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                call(, , , , )\n                \n              }\n            }\n            \n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(){\n        call(, , , , )\n        \n        if(){\n          call(, , , )\n          if(){\n            call(, )\n          }\n        }else{\n          while(){\n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n          while(){\n            \n            \n            if(){\n              call(, )\n              \n            }\n            if()\n            call(, , , , )\n            \n          }\n        }\n      }elseif(){\n        call(, , )\n        \n      }elseif(){\n        \n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , , , )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8125,
          "base_ppl": 1.734375,
          "pr_ppl": 1.734375,
          "source_ast_ppl": 2.046875,
          "base_ast_ppl": 1.953125,
          "pr_ast_ppl": 1.953125,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "error": "Invalid control character at: line 2 column 98 (char 99)"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_very_long_string_record-O0.so",
        "function": "sav_parse_very_long_string_record",
        "source_code": "readstat_error_t sav_parse_very_long_string_record(void *data, int count, sav_ctx_t *ctx) {\n    unsigned char *c_data = (unsigned char *)data;\n    int var_count = count_vars(ctx);\n    readstat_error_t retval = READSTAT_OK;\n\n    char temp_key[8*4+1];\n    unsigned int temp_val = 0;\n    unsigned char *str_start = NULL;\n    size_t str_len = 0;\n\n    size_t error_buf_len = 1024 + count;\n    char *error_buf = NULL;\n    unsigned char *p = c_data;\n    unsigned char *pe = c_data + count;\n    unsigned char *eof = pe;\n\n    varlookup_t *table = NULL;\n    int cs;\n\n    error_buf = readstat_malloc(error_buf_len);\n    table = build_lookup_table(var_count, ctx);\n    \n    \n#line 636 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tcs = sav_very_long_string_parse_start;\n\t}\n\n#line 641 \"src/spss/readstat_sav_parse.c\"\n\t{\n\tint _klen;\n\tunsigned int _trans;\n\tconst char *_acts;\n\tunsigned int _nacts;\n\tconst unsigned char *_keys;\n\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tif ( cs == 0 )\n\t\tgoto _out;\n_resume:\n\t_keys = _sav_very_long_string_parse_trans_keys + _sav_very_long_string_parse_key_offsets[cs];\n\t_trans = _sav_very_long_string_parse_index_offsets[cs];\n\n\t_klen = _sav_very_long_string_parse_single_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + _klen - 1;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\tif ( (*p) < *_mid )\n\t\t\t\t_upper = _mid - 1;\n\t\t\telse if ( (*p) > *_mid )\n\t\t\t\t_lower = _mid + 1;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_keys += _klen;\n\t\t_trans += _klen;\n\t}\n\n\t_klen = _sav_very_long_string_parse_range_lengths[cs];\n\tif ( _klen > 0 ) {\n\t\tconst unsigned char *_lower = _keys;\n\t\tconst unsigned char *_mid;\n\t\tconst unsigned char *_upper = _keys + (_klen<<1) - 2;\n\t\twhile (1) {\n\t\t\tif ( _upper < _lower )\n\t\t\t\tbreak;\n\n\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\tif ( (*p) < _mid[0] )\n\t\t\t\t_upper = _mid - 2;\n\t\t\telse if ( (*p) > _mid[1] )\n\t\t\t\t_lower = _mid + 2;\n\t\t\telse {\n\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\tgoto _match;\n\t\t\t}\n\t\t}\n\t\t_trans += _klen;\n\t}\n\n_match:\n\t_trans = _sav_very_long_string_parse_indicies[_trans];\n\tcs = _sav_very_long_string_parse_trans_targs[_trans];\n\n\tif ( _sav_very_long_string_parse_trans_actions[_trans] == 0 )\n\t\tgoto _again;\n\n\t_acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_trans_actions[_trans];\n\t_nacts = (unsigned int) *_acts++;\n\twhile ( _nacts-- > 0 )\n\t{\n\t\tswitch ( *_acts++ )\n\t\t{\n\tcase 0:\n#line 13 \"src/spss/readstat_sav_parse.rl\"\n\t{\n        memcpy(temp_key, str_start, str_len);\n        temp_key[str_len] = '\\0';\n    }\n\tbreak;\n\tcase 1:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_start = p; }\n\tbreak;\n\tcase 2:\n#line 20 \"src/spss/readstat_sav_parse.rl\"\n\t{ str_len = p - str_start; }\n\tbreak;\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n\tcase 4:\n#line 217 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            if ((*p) != '\\0') {\n                unsigned char digit = (*p) - '0';\n                if (temp_val <= (UINT_MAX - digit) / 10) {\n                    temp_val = 10 * temp_val + digit;\n                } else {\n                    {p++; goto _out; }\n                }\n            }\n        }\n\tbreak;\n\tcase 5:\n#line 228 \"src/spss/readstat_sav_parse.rl\"\n\t{ temp_val = 0; }\n\tbreak;\n#line 773 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\n_again:\n\tif ( cs == 0 )\n\t\tgoto _out;\n\tif ( ++p != pe )\n\t\tgoto _resume;\n\t_test_eof: {}\n\tif ( p == eof )\n\t{\n\tconst char *__acts = _sav_very_long_string_parse_actions + _sav_very_long_string_parse_eof_actions[cs];\n\tunsigned int __nacts = (unsigned int) *__acts++;\n\twhile ( __nacts-- > 0 ) {\n\t\tswitch ( *__acts++ ) {\n\tcase 3:\n#line 193 \"src/spss/readstat_sav_parse.rl\"\n\t{\n            varlookup_t *found = bsearch(temp_key, table, var_count, sizeof(varlookup_t), &compare_key_varlookup);\n            if (found) {\n                // See logic above; we need to apply this to all matching variables since ghost variable\n                // names may conflict with real variable names.\n                varlookup_t *first_match = found, *last_match = found;\n                varlookup_t *iter_match = found - 1;\n                while (iter_match >= table && strcmp(iter_match->name, temp_key) == 0) {\n                    first_match = iter_match;\n                    iter_match--;\n                }\n                iter_match = found + 1;\n                while (iter_match - table < var_count && strcmp(iter_match->name, temp_key) == 0) {\n                    last_match = iter_match;\n                    iter_match++;\n                }\n                for (iter_match=first_match; iter_match<=last_match; iter_match++) {\n                    ctx->varinfo[iter_match->index]->string_length = temp_val;\n                    ctx->varinfo[iter_match->index]->write_format.width = temp_val;\n                    ctx->varinfo[iter_match->index]->print_format.width = temp_val;\n                }\n            }\n        }\n\tbreak;\n#line 815 \"src/spss/readstat_sav_parse.c\"\n\t\t}\n\t}\n\t}\n\n\t_out: {}\n\t}\n\n#line 236 \"src/spss/readstat_sav_parse.rl\"\n\n    \n    if (cs < 11 || p != pe) {\n        if (ctx->handle.error) {\n            snprintf(error_buf, error_buf_len, \"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n                    (long)(p - c_data), (long)(pe - c_data), (int)(pe - p), p);\n            ctx->handle.error(error_buf, ctx->user_ctx);\n        }\n        retval = READSTAT_ERROR_PARSE;\n    }\n    \n    if (table)\n        free(table);\n    if (error_buf)\n        free(error_buf);\n\n    /* suppress warning */\n    (void)sav_very_long_string_parse_en_main;\n\n    return retval;\n}\n",
        "function_base": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  undefined1 uVar1;\n  char cVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar1 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar1) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar2 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar2 == '\\x03') &&\n         (local_148 = bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "function_pr": "\n/* WARNING: Removing unreachable block (ram,0x0010125e) */\n\nundefined4 sav_parse_very_long_string_record(byte *param_1,int param_2,long param_3)\n\n{\n  char cVar1;\n  undefined1 uVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char *__s;\n  char *__base;\n  byte *pbVar6;\n  int iVar7;\n  undefined1 *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  char *local_150;\n  char *local_148;\n  char *local_140;\n  int local_12c;\n  char *local_128;\n  char *local_118;\n  char *local_110;\n  char *local_108;\n  byte *local_f8;\n  byte *local_e8;\n  byte *local_e0;\n  byte *local_d0;\n  byte *local_c8;\n  int local_bc;\n  undefined1 *local_b8;\n  uint local_ac;\n  int local_a4;\n  byte *local_88;\n  size_t local_70;\n  byte *local_68;\n  uint local_5c;\n  char local_58 [40];\n  undefined4 local_30;\n  int local_2c;\n  byte *local_28;\n  long local_20;\n  int local_14;\n  byte *local_10;\n  \n  local_28 = param_1;\n  local_20 = param_3;\n  local_14 = param_2;\n  local_10 = param_1;\n  local_2c = count_vars(param_3);\n  local_88 = local_28;\n  local_30 = 0;\n  local_5c = 0;\n  local_68 = (byte *)0x0;\n  local_70 = 0;\n  iVar3 = local_14 + 0x400;\n  pbVar5 = local_28 + local_14;\n  __s = (char *)readstat_malloc((long)iVar3);\n  __base = (char *)build_lookup_table(local_2c,local_20);\n  local_a4 = 1;\n  for (; local_88 != pbVar5; local_88 = local_88 + 1) {\n    local_c8 = _sav_very_long_string_parse_trans_keys +\n               (int)(char)_sav_very_long_string_parse_key_offsets[local_a4];\n    local_ac = (uint)(char)_sav_very_long_string_parse_index_offsets[local_a4];\n    iVar7 = (int)(char)_sav_very_long_string_parse_single_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e0 = local_c8 + (long)iVar7 + -1;\n      local_d0 = local_c8;\n      while (local_d0 <= local_e0) {\n        pbVar6 = local_d0 + ((long)local_e0 - (long)local_d0 >> 1);\n        if (*local_88 < *pbVar6) {\n          local_e0 = pbVar6 + -1;\n        }\n        else {\n          if (*local_88 <= *pbVar6) {\n            local_ac = ((int)pbVar6 - (int)local_c8) + local_ac;\n            goto LAB_00101527;\n          }\n          local_d0 = pbVar6 + 1;\n        }\n      }\n      local_c8 = local_c8 + iVar7;\n      local_ac = iVar7 + local_ac;\n    }\n    iVar7 = (int)(char)_sav_very_long_string_parse_range_lengths[local_a4];\n    if (0 < iVar7) {\n      local_e8 = local_c8;\n      local_f8 = local_c8 + (long)(iVar7 << 1) + -2;\n      while (local_e8 <= local_f8) {\n        pbVar6 = local_e8 + ((long)local_f8 - (long)local_e8 >> 1 & 0xfffffffffffffffe);\n        if (*local_88 < *pbVar6) {\n          local_f8 = pbVar6 + -2;\n        }\n        else {\n          if (*local_88 <= pbVar6[1]) {\n            local_ac = (int)((long)pbVar6 - (long)local_c8 >> 1) + local_ac;\n            goto LAB_00101527;\n          }\n          local_e8 = pbVar6 + 2;\n        }\n      }\n      local_ac = iVar7 + local_ac;\n    }\nLAB_00101527:\n    uVar4 = (uint)(char)_sav_very_long_string_parse_indicies[local_ac];\n    local_a4 = (int)(char)_sav_very_long_string_parse_trans_targs[uVar4];\n    if (_sav_very_long_string_parse_trans_actions[uVar4] != '\\0') {\n      local_bc = (int)(char)_sav_very_long_string_parse_actions\n                            [(int)(char)_sav_very_long_string_parse_trans_actions[uVar4]];\n      local_b8 = _sav_very_long_string_parse_actions +\n                 (long)(int)(char)_sav_very_long_string_parse_trans_actions[uVar4] + 1;\n      while (iVar7 = local_bc + -1, local_bc != 0) {\n        puVar8 = local_b8 + 1;\n        uVar2 = *local_b8;\n        local_bc = iVar7;\n        local_b8 = puVar8;\n        switch(uVar2) {\n        case 0:\n          memcpy(local_58,local_68,local_70);\n          local_58[local_70] = '\\0';\n          break;\n        case 1:\n          local_68 = local_88;\n          break;\n        case 2:\n          local_70 = (long)local_88 - (long)local_68;\n          break;\n        case 3:\n          local_110 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup);\n          local_108 = local_110;\n          if (local_110 != (char *)0x0) {\n            while( true ) {\n              local_118 = local_108 + -0x28;\n              bVar10 = false;\n              if (__base <= local_118) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_108 = local_118;\n            }\n            while( true ) {\n              local_118 = local_110 + 0x28;\n              bVar10 = false;\n              if (((long)local_118 - (long)__base) / 0x28 < (long)local_2c) {\n                iVar7 = strcmp(local_118,local_58);\n                bVar10 = iVar7 == 0;\n              }\n              if (!bVar10) break;\n              local_110 = local_118;\n            }\n            for (local_118 = local_108; local_118 <= local_110; local_118 = local_118 + 0x28) {\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x14) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x28) = local_5c;\n              *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_118 + 0x24) * 8)\n                       + 0x1c) = local_5c;\n            }\n          }\n          break;\n        case 4:\n          if (*local_88 != 0) {\n            if ((-(uint)(byte)(*local_88 - 0x30) - 1) / 10 < local_5c) {\n              local_88 = local_88 + 1;\n              goto LAB_00101bcc;\n            }\n            local_5c = local_5c * 10 + (uint)(byte)(*local_88 - 0x30);\n          }\n          break;\n        case 5:\n          local_5c = 0;\n        }\n      }\n    }\n    if (local_a4 == 0) goto LAB_00101bcc;\n  }\n  if (local_88 == pbVar5) {\n    local_12c = (int)(char)_sav_very_long_string_parse_actions\n                           [(int)(char)_sav_very_long_string_parse_eof_actions[local_a4]];\n    local_128 = _sav_very_long_string_parse_actions +\n                (long)(int)(char)_sav_very_long_string_parse_eof_actions[local_a4] + 1;\n    while (iVar7 = local_12c + -1, local_12c != 0) {\n      pcVar9 = local_128 + 1;\n      cVar1 = *local_128;\n      local_12c = iVar7;\n      local_128 = pcVar9;\n      if ((cVar1 == '\\x03') &&\n         (local_148 = (char *)bsearch(local_58,__base,(long)local_2c,0x28,compare_key_varlookup),\n         local_140 = local_148, local_148 != (char *)0x0)) {\n        while( true ) {\n          local_150 = local_140 + -0x28;\n          bVar10 = false;\n          if (__base <= local_150) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_140 = local_150;\n        }\n        while( true ) {\n          local_150 = local_148 + 0x28;\n          bVar10 = false;\n          if (((long)local_150 - (long)__base) / 0x28 < (long)local_2c) {\n            iVar7 = strcmp(local_150,local_58);\n            bVar10 = iVar7 == 0;\n          }\n          if (!bVar10) break;\n          local_148 = local_150;\n        }\n        for (local_150 = local_140; local_150 <= local_148; local_150 = local_150 + 0x28) {\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x14) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x28) = local_5c;\n          *(uint *)(*(long *)(*(long *)(local_20 + 0x58) + (long)*(int *)(local_150 + 0x24) * 8) +\n                   0x1c) = local_5c;\n        }\n      }\n    }\n  }\nLAB_00101bcc:\n  if ((local_a4 < 0xb) || (local_88 != pbVar5)) {\n    if (*(long *)(local_20 + 0x30) != 0) {\n      snprintf(__s,(long)iVar3,\"Parsed %ld of %ld bytes. Remaining bytes: %.*s\",\n               (long)local_88 - (long)local_28,(long)pbVar5 - (long)local_28,\n               (ulong)(uint)((int)pbVar5 - (int)local_88),local_88);\n      (**(code **)(local_20 + 0x30))(__s,*(undefined8 *)(local_20 + 0x50));\n    }\n    local_30 = 5;\n  }\n  if (__base != (char *)0x0) {\n    free(__base);\n  }\n  if (__s != (char *)0x0) {\n    free(__s);\n  }\n  return local_30;\n}\n\n",
        "source_ast": "{\n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    if()goto label\n    if()goto label\n    \n    \n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        if()\n        \n        if()elseif()else{\n          \n          goto label\n        }\n      }\n      \n    }\n    \n    \n    if()goto label\n    \n    \n    while(){\n      switch(){\n        case :\n        \n        {\n          call(, , )\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        case :\n        \n        {\n          call(, , , , )\n          if(){\n            \n            \n            \n            \n            while(call(, )){\n              \n              \n            }\n            \n            while(call(, )){\n              \n              \n            }\n            for(;;){\n              \n              \n              \n            }\n          }\n        }\n        \n        case :\n        \n        {\n          if(){\n            \n            if(){\n              \n            }else{\n              {\n                \n                goto label\n              }\n            }\n          }\n        }\n        \n        case :\n        \n        {\n          \n        }\n        \n        \n      }\n    }\n    if()goto label\n    if()goto label\n    {\n    }\n    if(){\n      \n      \n      while(){\n        switch(){\n          case :\n          \n          {\n            call(, , , , )\n            if(){\n              \n              \n              \n              \n              while(call(, )){\n                \n                \n              }\n              \n              while(call(, )){\n                \n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n          }\n          \n          \n        }\n      }\n    }\n    {\n    }\n  }\n  \n  if(){\n    if(){\n      call(, , , , , , )\n      call(, )\n    }\n    \n  }\n  if()call()\n  if()call()\n  \n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  \n  \n  call()\n  call(, )\n  \n  for(;;){\n    \n    \n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n      \n    }\n    \n    if(){\n      \n      \n      while(){\n        \n        if(){\n          \n        }else{\n          if(){\n            \n            goto label\n          }\n          \n        }\n      }\n      \n    }\n    \n    \n    if(){\n      \n      \n      while(){\n        \n        \n        \n        \n        switch(){\n          case :\n            call(, , )\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            call(, , , , )\n            \n            if(){\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              while(){\n                \n                \n                if(){\n                  call(, )\n                  \n                }\n                if()\n                \n              }\n              for(;;){\n                \n                \n                \n              }\n            }\n            \n          case :\n            if(){\n              if(call()){\n                \n                goto label\n              }\n              call()\n            }\n            \n          case :\n            \n        }\n      }\n    }\n    if()goto label\n  }\n  if(){\n    \n    \n    while(){\n      \n      \n      \n      \n      if(call(, , , , )){\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        while(){\n          \n          \n          if(){\n            call(, )\n            \n          }\n          if()\n          \n        }\n        for(;;){\n          \n          \n          \n        }\n      }\n    }\n  }\n  if(){\n    if(){\n      call(, , , , , call(), )\n      call(, )\n    }\n    \n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 1.8515625,
          "base_ppl": 1.71875,
          "pr_ppl": 1.71875,
          "source_ast_ppl": 2.265625,
          "base_ast_ppl": 2.09375,
          "pr_ast_ppl": 2.09375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B is more readable because it follows standard C code conventions and avoids unnecessary complexity.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O2.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 1.6484375,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.25,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses a more structured and readable approach with a clear state machine, while Candidate A has a more compact but less understandable logic flow.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_dta_parse_timestamp-O3.so",
        "function": "dta_parse_timestamp",
        "source_code": "readstat_error_t dta_parse_timestamp(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_handler, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tunsigned int temp_val = 0;\n\t\n#line 154 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tcs = (int)dta_timestamp_parse_start;\n\t}\n\t\n#line 159 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _dta_timestamp_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_dta_timestamp_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _dta_timestamp_parse_trans_keys + (_dta_timestamp_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_dta_timestamp_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_dta_timestamp_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_dta_timestamp_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _dta_timestamp_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _dta_timestamp_parse_actions + (_dta_timestamp_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 20 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 244 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 24 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 253 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 26 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 262 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 29 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 271 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 30 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 280 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 31 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 289 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 32 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 298 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 33 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 307 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 34 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 316 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 35 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 325 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 36 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 334 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 37 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 343 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 38 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 352 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 39 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 361 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 40 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 370 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 42 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_year = temp_val - 1900; }\n\t\t\t\t\t\t\n#line 379 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 16:  {\n\t\t\t\t\t\t{\n#line 44 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 388 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 17:  {\n\t\t\t\t\t\t{\n#line 46 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 397 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 44 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 52 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 425 \"src/stata/readstat_dta_parse_timestamp.c\"\n\t44\n#line 54 \"src/stata/readstat_dta_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tchar error_buf[1024];\n\t\tif (error_handler) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf), \"Invalid timestamp string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_handler(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)dta_timestamp_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = _dta_timestamp_parse_cond_targs[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)_dta_timestamp_parse_cond_actions[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8\ndta_parse_timestamp(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  undefined8 uVar5;\n  char *pcVar6;\n  uint uVar7;\n  long lVar8;\n  uint uVar9;\n  char *pcVar10;\n  int iVar11;\n  char *pcVar12;\n  char *pcVar13;\n  ulong uVar14;\n  long lVar15;\n  int iVar16;\n  char local_438 [1032];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar11 = 1;\n  uVar9 = 0;\n  pcVar6 = param_1;\n  do {\n    pcVar12 = pcVar6;\n    if (pcVar12 == pcVar1) {\n      if (iVar11 != 0x2d) {\n        uVar9 = (int)*(short *)(_dta_timestamp_parse_eof_trans + (long)iVar11 * 2) - 1;\n      }\n    }\n    else {\n      uVar14 = (ulong)iVar11;\n      pcVar6 = \" 0909 09ADEFJMNOSadefjmnosBGPUbgpuRr 09 09 09:0909Oo GgEIeiCZcz CcNnEe EeBb AUauNnLNln  AaIRYiry  OoVv CKckTt EePp 09\"\n               + (char)_dta_timestamp_parse_key_offsets[uVar14];\n      uVar9 = (uint)*(short *)(_dta_timestamp_parse_index_offsets + uVar14 * 2);\n      if ((0xfffffffeefaU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_single_lengths[uVar14];\n        pcVar10 = pcVar6 + ((ulong)uVar7 - 1);\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while( true ) {\n              lVar15 = (long)pcVar10 - (long)pcVar13 >> 1;\n              pcVar2 = pcVar13 + lVar15;\n              if (*pcVar12 < pcVar13[lVar15]) break;\n              if (*pcVar12 <= pcVar13[lVar15]) {\n                uVar9 = ((int)pcVar2 - (int)pcVar6) + uVar9;\n                goto LAB_001012da;\n              }\n              pcVar13 = pcVar2 + 1;\n              if (pcVar10 < pcVar13) goto LAB_00101200;\n            }\n            pcVar10 = pcVar2 + -1;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_00101200:\n        pcVar6 = pcVar6 + uVar7;\n        uVar9 = uVar9 + uVar7;\n      }\n      if ((0x100000001f0eU >> (uVar14 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_dta_timestamp_parse_range_lengths[uVar14];\n        pcVar10 = pcVar6 + (ulong)uVar7 * 2 + -2;\n        if (pcVar6 <= pcVar10) {\n          pcVar13 = pcVar6;\n          do {\n            while (uVar14 = (long)pcVar10 - (long)pcVar13 >> 1 & 0xfffffffffffffffe,\n                  *pcVar12 < pcVar13[uVar14]) {\n              pcVar10 = pcVar13 + (uVar14 - 2);\n              if (pcVar10 < pcVar13) goto LAB_001012d0;\n            }\n            if (*pcVar12 <= pcVar13[uVar14 + 1]) {\n              uVar7 = (uint)((ulong)(pcVar13 + (uVar14 - (long)pcVar6)) >> 1);\n              break;\n            }\n            pcVar13 = pcVar13 + uVar14 + 2;\n          } while (pcVar13 <= pcVar10);\n        }\nLAB_001012d0:\n        uVar9 = uVar9 + uVar7;\n      }\n    }\nLAB_001012da:\n    cVar3 = (&_dta_timestamp_parse_cond_targs)[uVar9];\n    iVar11 = (int)cVar3;\n    lVar15 = (long)(char)(&_dta_timestamp_parse_cond_actions)[uVar9];\n    if ((lVar15 != 0) && (cVar4 = _dta_timestamp_parse_actions[lVar15], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        switch(*(undefined1 *)(lVar15 + 0x102361 + lVar8)) {\n        case 0:\n          iVar16 = (int)*pcVar12 + iVar16 * 10 + -0x30;\n          break;\n        case 1:\n          iVar16 = 0;\n          break;\n        case 2:\n          *(int *)(param_3 + 0xc) = iVar16;\n          break;\n        case 3:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n          break;\n        case 0xf:\n          *(int *)(param_3 + 0x14) = iVar16 + -0x76c;\n          break;\n        case 0x10:\n          *(int *)(param_3 + 8) = iVar16;\n          break;\n        case 0x11:\n          *(int *)(param_3 + 4) = iVar16;\n        }\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar12 == pcVar1) || (pcVar6 = pcVar12 + 1, cVar3 == '\\0')) {\n      if ((pcVar12 != pcVar1) || (uVar5 = 0, cVar3 < ',')) {\n        if (param_4 != (code *)0x0) {\n          snprintf(local_438,0x400,\"Invalid timestamp string (length=%d): %.*s\",param_2 & 0xffffffff\n                   ,param_2 & 0xffffffff,param_1);\n          (*param_4)(local_438,param_5);\n        }\n        uVar5 = 0x1d;\n      }\n      return uVar5;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    \n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        switch(){\n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n      }while()\n    }\n    if(){\n      if(){\n        if(){\n          call(, , , , , )\n          call(, )\n        }\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.4921875,
          "base_ppl": 2.25,
          "pr_ppl": 2.265625,
          "source_ast_ppl": 1.6484375,
          "base_ast_ppl": 2.25,
          "pr_ast_ppl": 2.25,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B, despite its more complex structure, handles the timestamp parsing logic in a way that is more aligned with expected human-readable code.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O2.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 1.71875,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B, despite being more complex, adheres to best practices for date parsing and error handling, making it more robust.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_date-O3.so",
        "function": "sav_parse_date",
        "source_code": "readstat_error_t sav_parse_date(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 408 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_date_parse_start;\n\t}\n\t\n#line 413 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_date_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_date_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_date_parse_trans_keys + (_sav_date_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_date_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_date_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_date_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_date_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_date_parse_actions + (_sav_date_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 71 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchar digit = ((( (*( p)))) - '0');\n\t\t\t\t\t\t\tif (digit >= 0 && digit <= 9) {\n\t\t\t\t\t\t\t\ttemp_val = 10 * temp_val + digit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 501 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 78 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (temp_val < 70) {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = 100 + temp_val;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttimestamp->tm_year = temp_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 516 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 87 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 525 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 89 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mday = temp_val; }\n\t\t\t\t\t\t\n#line 534 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 94 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 0; }\n\t\t\t\t\t\t\n#line 543 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 95 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 1; }\n\t\t\t\t\t\t\n#line 552 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 6:  {\n\t\t\t\t\t\t{\n#line 96 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 2; }\n\t\t\t\t\t\t\n#line 561 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 7:  {\n\t\t\t\t\t\t{\n#line 97 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 3; }\n\t\t\t\t\t\t\n#line 570 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 8:  {\n\t\t\t\t\t\t{\n#line 98 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 4; }\n\t\t\t\t\t\t\n#line 579 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 9:  {\n\t\t\t\t\t\t{\n#line 99 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 5; }\n\t\t\t\t\t\t\n#line 588 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 10:  {\n\t\t\t\t\t\t{\n#line 100 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 6; }\n\t\t\t\t\t\t\n#line 597 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 11:  {\n\t\t\t\t\t\t{\n#line 101 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 7; }\n\t\t\t\t\t\t\n#line 606 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 12:  {\n\t\t\t\t\t\t{\n#line 102 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 8; }\n\t\t\t\t\t\t\n#line 615 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 13:  {\n\t\t\t\t\t\t{\n#line 103 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 9; }\n\t\t\t\t\t\t\n#line 624 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 14:  {\n\t\t\t\t\t\t{\n#line 104 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 10; }\n\t\t\t\t\t\t\n#line 633 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 15:  {\n\t\t\t\t\t\t{\n#line 105 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_mon = 11; }\n\t\t\t\t\t\t\n#line 642 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 47 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 112 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 670 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t47\n#line 114 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid date string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_date_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = _sav_date_parse_cond_targs[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)_sav_date_parse_cond_actions[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_date(char *param_1,ulong param_2,long param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char cVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  long lVar8;\n  ulong uVar9;\n  char *pcVar10;\n  long lVar11;\n  uint uVar12;\n  char *pcVar13;\n  int iVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  uVar12 = 1;\n  iVar14 = 0;\n  uVar7 = 0;\n  pcVar13 = param_1;\n  do {\n    pcVar10 = pcVar13;\n    if (pcVar10 == pcVar1) {\n      if (uVar12 != 0x30) {\n        uVar7 = (int)*(short *)(_sav_date_parse_eof_trans + (long)(int)uVar12 * 2) - 1;\n      }\n    }\n    else {\n      lVar11 = (long)(int)uVar12;\n      pcVar13 = \" 09 09 -ADFJMNOSPUpuR - 09 09G -rgEeC -cEeB -bAUauN -LN - -nlnAaRY - -ryOoV -vCcT -tEeP -p\"\n                + (char)_sav_date_parse_key_offsets[lVar11];\n      uVar7 = (uint)*(short *)(_sav_date_parse_index_offsets + lVar11 * 2);\n      if (uVar12 < 0x2f) {\n        uVar12 = (uint)(char)_sav_date_parse_single_lengths[lVar11];\n        pcVar16 = pcVar13 + ((ulong)uVar12 - 1);\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while( true ) {\n              lVar8 = (long)pcVar16 - (long)pcVar15 >> 1;\n              pcVar2 = pcVar15 + lVar8;\n              if (*pcVar10 < pcVar15[lVar8]) break;\n              if (*pcVar10 <= pcVar15[lVar8]) {\n                uVar7 = ((int)pcVar2 - (int)pcVar13) + uVar7;\n                goto LAB_001012b8;\n              }\n              pcVar15 = pcVar2 + 1;\n              if (pcVar16 < pcVar15) goto LAB_00101200;\n            }\n            pcVar16 = pcVar2 + -1;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_00101200:\n        pcVar13 = pcVar13 + uVar12;\n        uVar7 = uVar7 + uVar12;\n      }\n      uVar12 = (uint)(char)_sav_date_parse_range_lengths[lVar11];\n      if ('\\0' < (char)_sav_date_parse_range_lengths[lVar11]) {\n        pcVar16 = pcVar13 + (ulong)uVar12 * 2 + -2;\n        if (pcVar13 <= pcVar16) {\n          pcVar15 = pcVar13;\n          do {\n            while (uVar9 = (long)pcVar16 - (long)pcVar15 >> 1 & 0xfffffffffffffffe,\n                  *pcVar10 < pcVar15[uVar9]) {\n              pcVar16 = pcVar15 + (uVar9 - 2);\n              if (pcVar16 < pcVar15) goto LAB_001012b6;\n            }\n            if (*pcVar10 <= pcVar15[uVar9 + 1]) {\n              uVar12 = (uint)((ulong)(pcVar15 + (uVar9 - (long)pcVar13)) >> 1);\n              break;\n            }\n            pcVar15 = pcVar15 + uVar9 + 2;\n          } while (pcVar15 <= pcVar16);\n        }\nLAB_001012b6:\n        uVar7 = uVar7 + uVar12;\n      }\n    }\nLAB_001012b8:\n    cVar3 = (&_sav_date_parse_cond_targs)[uVar7];\n    uVar12 = (uint)cVar3;\n    lVar11 = (long)(char)(&_sav_date_parse_cond_actions)[uVar7];\n    if ((lVar11 != 0) && (cVar4 = _sav_date_parse_actions[lVar11], cVar4 != '\\0')) {\n      lVar8 = 0;\n      do {\n        iVar5 = iVar14;\n        switch(*(undefined1 *)(lVar11 + 0x102311 + lVar8)) {\n        case 0:\n          iVar5 = (int)(char)(*pcVar10 - 0x30U) + iVar14 * 10;\n          if (9 < (byte)(*pcVar10 - 0x30U)) {\n            iVar5 = iVar14;\n          }\n          break;\n        case 1:\n          if (iVar14 < 0x46) {\n            *(int *)(param_3 + 0x14) = iVar14 + 100;\n          }\n          else {\n            *(int *)(param_3 + 0x14) = iVar14;\n          }\n          break;\n        case 2:\n          iVar5 = 0;\n          break;\n        case 3:\n          *(int *)(param_3 + 0xc) = iVar14;\n          break;\n        case 4:\n          *(undefined4 *)(param_3 + 0x10) = 0;\n          break;\n        case 5:\n          *(undefined4 *)(param_3 + 0x10) = 1;\n          break;\n        case 6:\n          *(undefined4 *)(param_3 + 0x10) = 2;\n          break;\n        case 7:\n          *(undefined4 *)(param_3 + 0x10) = 3;\n          break;\n        case 8:\n          *(undefined4 *)(param_3 + 0x10) = 4;\n          break;\n        case 9:\n          *(undefined4 *)(param_3 + 0x10) = 5;\n          break;\n        case 10:\n          *(undefined4 *)(param_3 + 0x10) = 6;\n          break;\n        case 0xb:\n          *(undefined4 *)(param_3 + 0x10) = 7;\n          break;\n        case 0xc:\n          *(undefined4 *)(param_3 + 0x10) = 8;\n          break;\n        case 0xd:\n          *(undefined4 *)(param_3 + 0x10) = 9;\n          break;\n        case 0xe:\n          *(undefined4 *)(param_3 + 0x10) = 10;\n          break;\n        case 0xf:\n          *(undefined4 *)(param_3 + 0x10) = 0xb;\n        }\n        iVar14 = iVar5;\n        lVar8 = lVar8 + 1;\n      } while ((int)cVar4 != (int)lVar8);\n    }\n    if ((pcVar10 == pcVar1) || (pcVar13 = pcVar10 + 1, cVar3 == '\\0')) {\n      if (((pcVar10 != pcVar1) || (uVar6 = 0, cVar3 < '/')) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid date string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n                if(){\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                if(){\n                  \n                }else{\n                  \n                }\n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                \n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        \n      }\n    }\n    \n    \n    \n    if(){\n      \n      do{\n        \n        switch(){\n          case :\n            \n            if(call()){\n              \n            }\n            \n          case :\n            if(){\n              \n            }else{\n              \n            }\n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n            \n          case :\n            \n        }\n        \n        \n      }while()\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.5703125,
          "base_ppl": 2.171875,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 1.71875,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while more complex, correctly parses the date string and handles error conditions, making it more accurate and robust.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O2.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.8671875,
          "source_ast_ppl": 3.953125,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.46875,
          "delta_ppl": -0.0234375
        },
        "llm_qualitative": {
          "motivation": "Candidate B is semantically incorrect but uses standard C constructs, making it easier to understand and fix compared to Candidate A's buggy and convoluted logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "TIE",
          "motivation": "Detected potential bias in LLM AST response; declaring TIE."
        }
      },
      {
        "binary": "task-xz_lzma_validate_chain-O3.so",
        "function": "lzma_validate_chain",
        "source_code": "extern lzma_ret\nlzma_validate_chain(const lzma_filter *filters, size_t *count)\n{\n\t// There must be at least one filter.\n\tif (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)\n\t\treturn LZMA_PROG_ERROR;\n\n\t// Number of non-last filters that may change the size of the data\n\t// significantly (that is, more than 1-2 % or so).\n\tsize_t changes_size_count = 0;\n\n\t// True if it is OK to add a new filter after the current filter.\n\tbool non_last_ok = true;\n\n\t// True if the last filter in the given chain is actually usable as\n\t// the last filter. Only filters that support embedding End of Payload\n\t// Marker can be used as the last filter in the chain.\n\tbool last_ok = false;\n\n\tsize_t i = 0;\n\tdo {\n\t\tsize_t j;\n\t\tfor (j = 0; filters[i].id != features[j].id; ++j)\n\t\t\tif (features[j].id == LZMA_VLI_UNKNOWN)\n\t\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\t// If the previous filter in the chain cannot be a non-last\n\t\t// filter, the chain is invalid.\n\t\tif (!non_last_ok)\n\t\t\treturn LZMA_OPTIONS_ERROR;\n\n\t\tnon_last_ok = features[j].non_last_ok;\n\t\tlast_ok = features[j].last_ok;\n\t\tchanges_size_count += features[j].changes_size;\n\n\t} while (filters[++i].id != LZMA_VLI_UNKNOWN);\n\n\t// There must be 1-4 filters. The last filter must be usable as\n\t// the last filter in the chain. A maximum of three filters are\n\t// allowed to change the size of the data.\n\tif (i > LZMA_FILTERS_MAX || !last_ok || changes_size_count > 3)\n\t\treturn LZMA_OPTIONS_ERROR;\n\n\t*count = i;\n\treturn LZMA_OK;\n}\n",
        "function_base": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        param_1 = param_1 + 2;\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "function_pr": "\nundefined8 lzma_validate_chain(long *param_1,ulong *param_2)\n\n{\n  bool bVar1;\n  bool bVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  byte bVar6;\n  long lVar7;\n  \n  uVar3 = 0xb;\n  if (param_1 != (long *)0x0) {\n    lVar7 = *param_1;\n    if (lVar7 != -1) {\n      param_1 = param_1 + 2;\n      uVar4 = 0;\n      uVar5 = 0;\n      uVar3 = 8;\n      bVar1 = true;\n      do {\n        bVar6 = 1;\n        bVar2 = false;\n        switch(lVar7) {\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n        case 0xb:\n          bVar2 = true;\n          bVar6 = 0;\n          break;\n        case 0xc:\n        case 0xd:\n        case 0xe:\n        case 0xf:\n        case 0x10:\n        case 0x11:\n        case 0x12:\n        case 0x13:\n        case 0x14:\n        case 0x15:\n        case 0x16:\n        case 0x17:\n        case 0x18:\n        case 0x19:\n        case 0x1a:\n        case 0x1b:\n        case 0x1c:\n        case 0x1d:\n        case 0x1e:\n        case 0x1f:\n        case 0x20:\n          goto switchD_00101156_caseD_c;\n        case 0x21:\n          break;\n        default:\n          bVar6 = 1;\n          bVar2 = false;\n          if (1 < lVar7 + 0xbfffffffffffffffU) goto switchD_00101156_caseD_c;\n        }\n        if (!bVar1) goto switchD_00101156_caseD_c;\n        uVar4 = uVar4 + bVar6;\n        uVar5 = uVar5 + 1;\n        lVar7 = *param_1;\n        param_1 = param_1 + 2;\n        bVar1 = bVar2;\n      } while (lVar7 != -1);\n      if ((bVar6 == 1 && uVar5 < 5) && (uVar4 < 4)) {\n        *param_2 = uVar5;\n        uVar3 = 0;\n      }\n    }\nswitchD_00101156_caseD_c:\n  }\n  return uVar3;\n}\n\n",
        "source_ast": "{\n  \n  if()return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    for(;;)if()return\n    \n    \n    if()return\n    \n    \n    \n  }while()\n  \n  \n  \n  if()return\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      do{\n        \n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      \n      \n      \n      \n      \n      do{\n        \n        \n        switch(){\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            \n            \n            \n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n          case :\n            goto label\n          case :\n            \n          case :\n            \n            \n            \n            if()goto label\n        }\n        if()goto label\n        \n        \n        \n        \n        \n      }while()\n      if(){\n        \n        \n      }\n    }\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.234375,
          "base_ppl": 1.890625,
          "pr_ppl": 1.8671875,
          "source_ast_ppl": 3.953125,
          "base_ast_ppl": 2.46875,
          "pr_ast_ppl": 2.46875,
          "delta_ppl": -0.0234375
        },
        "llm_qualitative": {
          "motivation": "Candidate B is semantically incorrect but its structure resembles standard C code with clear loop and variable usage, making it easier to understand and correct.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates introduce excessive goto statements and nesting, but Candidate A more closely matches the Source's nesting structure, especially the do-while loop.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O2.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 2.203125,
          "base_ast_ppl": 2.5625,
          "pr_ast_ppl": 2.5625,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while more verbose, uses standard control flow constructs (loops, conditionals) making it easier to follow compared to Candidate A's goto statements.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_sav_parse_time-O3.so",
        "function": "sav_parse_time",
        "source_code": "readstat_error_t sav_parse_time(const char *data, size_t len, struct tm *timestamp,\nreadstat_error_handler error_cb, void *user_ctx) {\n\treadstat_error_t retval = READSTAT_OK;\n\tchar error_buf[8192];\n\tconst char *p = data;\n\tconst char *pe = p + len;\n\tconst char *eof = pe;\n\tint cs;\n\tint temp_val = 0;\n\t\n#line 83 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tcs = (int)sav_time_parse_start;\n\t}\n\t\n#line 88 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t{\n\t\tint _klen;\n\t\tunsigned int _trans = 0;\n\t\tconst char * _keys;\n\t\tconst signed char * _acts;\n\t\tunsigned int _nacts;\n\t\t_resume: {}\n\t\tif ( p == pe && p != eof )\n\t\t\tgoto _out;\n\t\tif ( p == eof ) {\n\t\t\tif ( _sav_time_parse_eof_trans[cs] > 0 ) {\n\t\t\t\t_trans = (unsigned int)_sav_time_parse_eof_trans[cs] - 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t_keys = ( _sav_time_parse_trans_keys + (_sav_time_parse_key_offsets[cs]));\n\t\t\t_trans = (unsigned int)_sav_time_parse_index_offsets[cs];\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_single_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + _klen - 1;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_keys += _klen;\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + ((_upper-_lower) >> 1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 1;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid)) )\n\t\t\t\t\t\t_lower = _mid + 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)(_mid - _keys);\n\t\t\t\t\t\tgoto _match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_klen = (int)_sav_time_parse_range_lengths[cs];\n\t\t\tif ( _klen > 0 ) {\n\t\t\t\tconst char *_lower = _keys;\n\t\t\t\tconst char *_upper = _keys + (_klen<<1) - 2;\n\t\t\t\tconst char *_mid;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tif ( _upper < _lower ) {\n\t\t\t\t\t\t_trans += (unsigned int)_klen;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t_mid = _lower + (((_upper-_lower) >> 1) & ~1);\n\t\t\t\t\tif ( ( (*( p))) < (*( _mid)) )\n\t\t\t\t\t\t_upper = _mid - 2;\n\t\t\t\t\telse if ( ( (*( p))) > (*( _mid + 1)) )\n\t\t\t\t\t\t_lower = _mid + 2;\n\t\t\t\t\telse {\n\t\t\t\t\t\t_trans += (unsigned int)((_mid - _keys)>>1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t_match: {}\n\t\t}\n\t\tcs = (int)_sav_time_parse_cond_targs[_trans];\n\t\t\n\t\tif ( _sav_time_parse_cond_actions[_trans] != 0 ) {\n\t\t\t\n\t\t\t_acts = ( _sav_time_parse_actions + (_sav_time_parse_cond_actions[_trans]));\n\t\t\t_nacts = (unsigned int)(*( _acts));\n\t\t\t_acts += 1;\n\t\t\twhile ( _nacts > 0 ) {\n\t\t\t\tswitch ( (*( _acts)) )\n\t\t\t\t{\n\t\t\t\t\tcase 0:  {\n\t\t\t\t\t\t{\n#line 24 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\ttemp_val = 10 * temp_val + ((( (*( p)))) - '0');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n#line 173 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 1:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = 0; }\n\t\t\t\t\t\t\n#line 182 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 2:  {\n\t\t\t\t\t\t{\n#line 28 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttemp_val = (( (*( p)))) - '0'; }\n\t\t\t\t\t\t\n#line 191 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 3:  {\n\t\t\t\t\t\t{\n#line 30 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_hour = temp_val; }\n\t\t\t\t\t\t\n#line 200 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 4:  {\n\t\t\t\t\t\t{\n#line 32 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_min = temp_val; }\n\t\t\t\t\t\t\n#line 209 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t\tcase 5:  {\n\t\t\t\t\t\t{\n#line 34 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\t\t\t\t\t\ttimestamp->tm_sec = temp_val; }\n\t\t\t\t\t\t\n#line 218 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_nacts -= 1;\n\t\t\t\t_acts += 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif ( p == eof ) {\n\t\t\tif ( cs >= 12 )\n\t\t\t\tgoto _out;\n\t\t}\n\t\telse {\n\t\t\tif ( cs != 0 ) {\n\t\t\t\tp += 1;\n\t\t\t\tgoto _resume;\n\t\t\t}\n\t\t}\n\t\t_out: {}\n\t}\n\t\n#line 40 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t\n\t\n\tif (cs < \n#line 246 \"src/spss/readstat_sav_parse_timestamp.c\"\n\t12\n#line 42 \"src/spss/readstat_sav_parse_timestamp.rl\"\n\t|| p != pe) {\n\t\tif (error_cb) {\n\t\t\tsnprintf(error_buf, sizeof(error_buf),\n\t\t\t\"Invalid time string (length=%d): %.*s\", (int)len, (int)len, data);\n\t\t\terror_cb(error_buf, user_ctx);\n\t\t}\n\t\tretval = READSTAT_ERROR_BAD_TIMESTAMP_STRING;\n\t}\n\t\n\t(void)sav_time_parse_en_main;\n\t\n\treturn retval;\n}\n",
        "function_base": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)_sav_time_parse_cond_targs[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "function_pr": "\nundefined8 sav_parse_time(char *param_1,ulong param_2,int *param_3,code *param_4,undefined8 param_5)\n\n{\n  char *pcVar1;\n  undefined1 *puVar2;\n  char cVar3;\n  char cVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  uint uVar7;\n  char *pcVar8;\n  uint uVar9;\n  ulong uVar10;\n  undefined1 *puVar11;\n  ulong uVar12;\n  int iVar13;\n  undefined1 *puVar14;\n  undefined1 *puVar15;\n  int iVar16;\n  long lVar17;\n  char local_2038 [8200];\n  \n  pcVar1 = param_1 + param_2;\n  iVar16 = 0;\n  iVar13 = 1;\n  uVar12 = 0;\n  pcVar5 = param_1;\n  do {\n    pcVar8 = pcVar5;\n    if (pcVar8 == pcVar1) {\n      if (iVar13 != 0xd) {\n        uVar12 = (ulong)((int)(char)_sav_time_parse_eof_trans[iVar13] - 1);\n      }\n    }\n    else {\n      uVar10 = (ulong)iVar13;\n      puVar15 = _sav_time_parse_trans_keys + (char)_sav_time_parse_key_offsets[uVar10];\n      uVar9 = (uint)(char)_sav_time_parse_index_offsets[uVar10];\n      if ((0xdaUL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_single_lengths[uVar10];\n        puVar11 = puVar15 + ((ulong)uVar7 - 1);\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while( true ) {\n              lVar17 = (long)puVar11 - (long)puVar14 >> 1;\n              puVar2 = puVar14 + lVar17;\n              if (*pcVar8 < (char)puVar14[lVar17]) break;\n              if (*pcVar8 <= (char)puVar14[lVar17]) {\n                uVar12 = (ulong)(((int)puVar2 - (int)puVar15) + uVar9);\n                goto LAB_00101311;\n              }\n              puVar14 = puVar2 + 1;\n              if (puVar11 < puVar14) goto LAB_00101210;\n            }\n            puVar11 = puVar2 + -1;\n          } while (puVar14 <= puVar11);\n        }\nLAB_00101210:\n        puVar15 = puVar15 + uVar7;\n        uVar9 = uVar7 + uVar9;\n      }\n      uVar12 = (ulong)uVar9;\n      if ((0xfb6UL >> (uVar10 & 0x3f) & 1) != 0) {\n        uVar7 = (uint)(char)_sav_time_parse_range_lengths[uVar10];\n        puVar11 = puVar15 + (ulong)uVar7 * 2 + -2;\n        if (puVar15 <= puVar11) {\n          puVar14 = puVar15;\n          do {\n            while (uVar12 = (long)puVar11 - (long)puVar14 >> 1 & 0xfffffffffffffffe,\n                  *pcVar8 < (char)puVar14[uVar12]) {\n              puVar11 = puVar14 + (uVar12 - 2);\n              if (puVar11 < puVar14) goto LAB_0010130d;\n            }\n            if (*pcVar8 <= (char)puVar14[uVar12 + 1]) {\n              uVar7 = (uint)((ulong)(puVar14 + (uVar12 - (long)puVar15)) >> 1);\n              break;\n            }\n            puVar14 = puVar14 + uVar12 + 2;\n          } while (puVar14 <= puVar11);\n        }\nLAB_0010130d:\n        uVar12 = (ulong)(uVar7 + uVar9);\n      }\n    }\nLAB_00101311:\n    iVar13 = (int)(char)(&_sav_time_parse_cond_targs)[uVar12];\n    if ((0xbfff556ad5U >> (uVar12 & 0x3f) & 1) == 0) {\n      cVar3 = _sav_time_parse_cond_actions[uVar12];\n      cVar4 = _sav_time_parse_actions[cVar3];\n      if (cVar4 != '\\0') {\n        lVar17 = 0;\n        do {\n          switch(*(undefined1 *)((long)cVar3 + 0x1020c9 + lVar17)) {\n          case 0:\n            iVar16 = (int)*pcVar8 + iVar16 * 10 + -0x30;\n            break;\n          case 1:\n            iVar16 = 0;\n            break;\n          case 2:\n            iVar16 = *pcVar8 + -0x30;\n            break;\n          case 3:\n            param_3[2] = iVar16;\n            break;\n          case 4:\n            param_3[1] = iVar16;\n            break;\n          case 5:\n            *param_3 = iVar16;\n          }\n          lVar17 = lVar17 + 1;\n        } while ((int)cVar4 != (int)lVar17);\n      }\n    }\n    if ((pcVar8 == pcVar1) || (pcVar5 = pcVar8 + 1, (0x7ff8aad5abU >> (uVar12 & 0x3f) & 1) == 0)) {\n      if (((pcVar8 != pcVar1) || (uVar6 = 0, (0xbffff5ffffU >> (uVar12 & 0x3f) & 1) != 0)) &&\n         (uVar6 = 0x1d, param_4 != (code *)0x0)) {\n        snprintf(local_2038,0x2000,\"Invalid time string (length=%d): %.*s\",param_2 & 0xffffffff,\n                 param_2 & 0xffffffff,param_1);\n        (*param_4)(local_2038,param_5);\n        uVar6 = 0x1d;\n      }\n      return uVar6;\n    }\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  {\n    \n  }\n  \n  {\n    \n    \n    \n    \n    \n    {\n    }\n    if()goto label\n    if(){\n      if(){\n        \n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n            \n          }\n          \n          if()elseif()else{\n            \n            goto label\n          }\n        }\n      }\n      \n      if(){\n        \n        \n        \n        while(){\n          if(){\n            \n            \n          }\n          \n          if()elseif()else{\n            \n            \n          }\n        }\n      }\n      {\n      }\n    }\n    \n    if(){\n      \n      \n      \n      while(){\n        switch(){\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n          case :\n            {\n              {\n                \n                \n              }\n              \n              \n            }\n        }\n        \n        \n      }\n    }\n    if(){\n      if()goto label\n    }else{\n      if(){\n        \n        goto label\n      }\n    }\n    {\n    }\n  }\n  \n  \n  \n  \n  \n  \n  {\n    if(){\n      call(, , , , , )\n      call(, )\n    }\n    \n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  do{\n    \n    if(){\n      if(){\n        call()\n      }\n    }else{\n      \n      \n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              \n              if()\n              if(){\n                call()\n                goto label\n              }\n              \n              if()goto label\n            }\n            \n          }while()\n        }\n        \n        \n      }\n      \n      if(){\n        \n        \n        if(){\n          \n          do{\n            while(){\n              \n              if()goto label\n            }\n            if(){\n              call(call())\n              \n            }\n            \n          }while()\n        }\n        call()\n      }\n    }\n    \n    if(){\n      \n      \n      if(){\n        \n        do{\n          switch(){\n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n              \n            case :\n              \n          }\n          \n        }while()\n      }\n    }\n    if(){\n      if(){\n        call(, , , , , )\n        call(, )\n        \n      }\n      return\n    }\n  }while()\n}",
        "metrics": {
          "source_ppl": 1.921875,
          "base_ppl": 2.171875,
          "pr_ppl": 2.1875,
          "source_ast_ppl": 2.203125,
          "base_ast_ppl": 2.5625,
          "pr_ast_ppl": 2.5625,
          "delta_ppl": 0.015625
        },
        "llm_qualitative": {
          "motivation": "Candidate B, despite using a more complex parsing mechanism, produces cleaner, more idiomatic C code with standard loops and clear variable assignments.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O2.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.546875,
          "base_ppl": 2.5,
          "pr_ppl": 2.5,
          "source_ast_ppl": 4.15625,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while potentially less semantically perfect, uses standard control flow structures and is more readable, aligning better with human coding practices.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O3.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if ((int)-uVar1 < 0) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "function_pr": "\nundefined8 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  uint uVar1;\n  void *__s1;\n  ulong uVar2;\n  uint uVar3;\n  bool bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  void *pvVar9;\n  undefined8 uVar10;\n  long lVar11;\n  uint *puVar12;\n  bool bVar13;\n  void *local_190;\n  void *local_188;\n  undefined4 local_17c;\n  ulong local_178;\n  char *local_170;\n  undefined8 local_168;\n  _union_1457 local_160;\n  undefined1 local_158 [144];\n  _union_1457 local_c8 [19];\n  \n  local_190 = (void *)0x0;\n  uVar10 = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) != 0) {\n    uVar5 = *(uint *)(param_1 + 0x44) & 0x410;\n    local_17c = *param_2;\n    __s1 = *(void **)(param_2 + 0x26);\n    uVar2 = *(ulong *)(param_2 + 0x28);\n    local_170 = \" compressed-encoding=\";\n    if (uVar5 == 0) {\n      local_170 = \" (\";\n    }\n    puVar12 = (uint *)&DAT_00105b58;\n    bVar13 = false;\n    lVar11 = 0;\n    uVar10 = 0;\n    local_168 = param_3;\n    do {\n      uVar1 = *puVar12;\n      uVar3 = -uVar1;\n      if (0 < (int)uVar1) {\n        uVar3 = uVar1;\n      }\n      if (uVar3 <= uVar2) {\n        if (lVar11 - 0xdU < 2) {\n          iVar6 = (**(code **)(puVar12 + -2))(__s1);\n          if (iVar6 != 0) {\nLAB_001026c7:\n            bVar4 = !bVar13;\n            bVar13 = true;\n            if (bVar4) {\n              memset(local_158,0,0x90);\n              local_160 = (_union_1457)0x1;\n              iVar6 = sigaction(0xd,(sigaction *)&local_160,(sigaction *)local_c8);\n              bVar13 = iVar6 != -1;\n            }\n            local_178 = uVar2;\n            free(local_190);\n            iVar6 = uncompressbuf(local_17c,*(undefined8 *)(param_1 + 0x120),lVar11,\n                                  *(uint *)(param_1 + 0x44) & 0x4000000,__s1,&local_190,&local_178);\n            if (iVar6 != 2) {\n              if (iVar6 == 1) goto LAB_00102670;\n              if (iVar6 != 0) goto LAB_001028d4;\n            }\n            *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) & 0xfb;\n            if (iVar6 == 2) {\n              iVar6 = format_decompression_error(param_1,lVar11,local_190);\n            }\n            else {\n              iVar6 = file_buffer(param_1,0xffffffff,0,local_168,local_190,local_178);\n            }\n            if (iVar6 != -1) {\n              uVar10 = 1;\n              if (((*(byte *)(param_1 + 0x47) & 2) != 0) || ((uVar5 != 0x410 && (uVar5 != 0))))\n              break;\n              iVar6 = file_printf(param_1,local_170);\n              if ((iVar6 != -1) && (lVar8 = file_push_buffer(param_1), lVar8 != 0)) {\n                uVar7 = file_buffer(param_1,0xffffffff,0,0,__s1,uVar2);\n                local_188 = (void *)CONCAT44(local_188._4_4_,uVar7);\n                pvVar9 = (void *)file_pop_buffer(param_1,lVar8);\n                if ((int)local_188 == -1) {\n                  if (pvVar9 != (void *)0x0) {\nLAB_001028d4:\n                    /* WARNING: Subroutine does not return */\n                    abort();\n                  }\n                }\n                else {\n                  if (pvVar9 != (void *)0x0) {\n                    local_188 = pvVar9;\n                    iVar6 = file_printf(param_1,\"%s\",pvVar9);\n                    free(local_188);\n                    if (iVar6 == -1) goto LAB_00102663;\n                  }\n                  uVar10 = 1;\n                  if ((uVar5 != 0) || (iVar6 = file_printf(param_1,&DAT_00104029), iVar6 != -1))\n                  goto LAB_00102670;\n                }\n              }\n            }\nLAB_00102663:\n            uVar10 = 0xffffffff;\n          }\n        }\n        else {\n          iVar6 = bcmp(__s1,*(code **)(puVar12 + -2),(ulong)uVar1);\n          if (iVar6 == 0) goto LAB_001026c7;\n        }\n      }\nLAB_00102670:\n      lVar11 = lVar11 + 1;\n      puVar12 = puVar12 + 8;\n    } while (lVar11 != 0xf);\n    if ((bVar13) && (local_c8[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_c8,(sigaction *)0x0);\n    }\n    free(local_190);\n    *(byte *)(param_1 + 0x44) = *(byte *)(param_1 + 0x44) | 4;\n  }\n  return uVar10;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    \n    \n    \n    \n    if(){\n      \n    }\n    \n    \n    \n    \n    \n    do{\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n          if(){\n            \n            \n            if(){\n              call(, , )\n              \n              call(, , )\n              \n            }\n            \n            call()\n            call(, , , , , , )\n            if(){\n              if()goto label\n              if()goto label\n            }\n            \n            if(){\n              call(, , )\n            }else{\n              call(, , , , , )\n            }\n            if(){\n              \n              if()\n              call(, )\n              if(call()){\n                call(, , , , , )\n                call(, )\n                call(, )\n                if(){\n                  if(){\n                    call()\n                  }\n                }else{\n                  if(){\n                    \n                    call(, , )\n                    call()\n                    if()goto label\n                  }\n                  \n                  if(call(, ))goto label\n                }\n              }\n            }\n            \n          }\n        }else{\n          call(, , )\n          if()goto label\n        }\n      }\n      \n      \n    }while()\n    if(){\n      call(, , )\n    }\n    call()\n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.546875,
          "base_ppl": 2.5,
          "pr_ppl": 2.5,
          "source_ast_ppl": 4.15625,
          "base_ast_ppl": 2.734375,
          "pr_ast_ppl": 2.734375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B, despite some minor inaccuracies, presents a more idiomatic C structure and is easier to understand than Candidate A's overly complex logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O0.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "function_pr": "\nuint readstat_parse_sas7bdat(void *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  int iVar2;\n  uint uVar3;\n  void *__dest;\n  uint *__ptr;\n  long lVar4;\n  iconv_t pvVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  char *pcVar8;\n  uint local_2c;\n  undefined8 local_28;\n  undefined8 local_20;\n  undefined8 local_18;\n  void *local_10;\n  \n  local_28 = 0;\n  puVar1 = *(undefined8 **)((long)param_1 + 0x40);\n  local_20 = param_3;\n  local_18 = param_2;\n  local_10 = param_1;\n  __dest = calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  memcpy(__dest,local_10,0x40);\n  *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)((long)local_10 + 0x48);\n  *(undefined8 *)((long)__dest + 0x128) = *(undefined8 *)((long)local_10 + 0x50);\n  *(undefined8 *)((long)__dest + 0x58) = local_20;\n  *(undefined8 *)((long)__dest + 0x60) = *(undefined8 *)((long)local_10 + 0x40);\n  *(int *)((long)__dest + 0x80) = (int)*(undefined8 *)((long)local_10 + 0x58);\n  if (0 < *(long *)((long)local_10 + 0x60)) {\n    *(int *)((long)__dest + 0x84) = (int)*(undefined8 *)((long)local_10 + 0x60);\n  }\n  iVar2 = (*(code *)*puVar1)(local_18,puVar1[5]);\n  if (iVar2 == -1) {\n    local_2c = 1;\n  }\n  else {\n    lVar4 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    *(long *)((long)__dest + 0x40) = lVar4;\n    if (lVar4 == -1) {\n      local_2c = 0xf;\n      if (*(long *)((long)__dest + 0x30) != 0) {\n        snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: Failed to seek to end of file\");\n        (**(code **)((long)__dest + 0x30))\n                  ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n      }\n    }\n    else {\n      lVar4 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n      if (lVar4 == -1) {\n        local_2c = 0xf;\n        if (*(long *)((long)__dest + 0x30) != 0) {\n          snprintf((char *)((long)__dest + 0x5ce),0x800,\n                   \"ReadStat: Failed to seek to beginning of file\");\n          (**(code **)((long)__dest + 0x30))\n                    ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n        }\n      }\n      else {\n        local_2c = sas_read_header(puVar1,__ptr,*(undefined8 *)((long)__dest + 0x30),local_20);\n        if (local_2c == 0) {\n          *(uint *)((long)__dest + 0x4c) = __ptr[1];\n          *(uint *)((long)__dest + 0x48) = *__ptr;\n          *(uint *)((long)__dest + 0x50) = __ptr[2];\n          uVar3 = machine_is_little_endian();\n          *(uint *)((long)__dest + 0x68) = uVar3 ^ *__ptr;\n          *(undefined8 *)((long)__dest + 0x88) = *(undefined8 *)(__ptr + 0x10);\n          *(undefined8 *)((long)__dest + 0x90) = *(undefined8 *)(__ptr + 0xe);\n          *(undefined8 *)((long)__dest + 0x98) = *(undefined8 *)(__ptr + 8);\n          *(undefined8 *)((long)__dest + 0xb0) = *(undefined8 *)(__ptr + 10);\n          *(undefined8 *)((long)__dest + 0xc0) = *(undefined8 *)(__ptr + 0xc);\n          iVar2 = 4;\n          if (*(int *)((long)__dest + 0x4c) != 0) {\n            iVar2 = 8;\n          }\n          *(long *)((long)__dest + 0xb8) = (long)iVar2;\n          *(undefined8 *)((long)__dest + 0x138) = *(undefined8 *)(__ptr + 0x12);\n          *(undefined8 *)((long)__dest + 0x140) = *(undefined8 *)(__ptr + 0x14);\n          *(uint *)((long)__dest + 0x148) = __ptr[3];\n          if (*(long *)((long)__dest + 0x120) == 0) {\n            *(undefined8 *)((long)__dest + 0x120) = *(undefined8 *)(__ptr + 0x5e);\n          }\n          lVar4 = readstat_malloc(*(undefined8 *)((long)__dest + 0x98));\n          *(long *)((long)__dest + 0xa0) = lVar4;\n          if (lVar4 == 0) {\n            local_2c = 3;\n          }\n          else {\n            if (((*(long *)((long)__dest + 0x120) != 0) && (*(long *)((long)__dest + 0x128) != 0))\n               && (iVar2 = strcmp(*(char **)((long)__dest + 0x120),*(char **)((long)__dest + 0x128))\n                  , iVar2 != 0)) {\n              pvVar5 = iconv_open(*(char **)((long)__dest + 0x128),*(char **)((long)__dest + 0x120))\n              ;\n              if (pvVar5 == (iconv_t)0xffffffffffffffff) {\n                local_2c = 7;\n                goto LAB_0010188a;\n              }\n              *(iconv_t *)((long)__dest + 0x130) = pvVar5;\n            }\n            local_2c = readstat_convert((long)__dest + 0x14c,0x81,__ptr + 0x16,0x20,\n                                        *(undefined8 *)((long)__dest + 0x130));\n            if (((local_2c == 0) &&\n                (local_2c = sas7bdat_parse_meta_pages_pass1(__dest,&local_28), local_2c == 0)) &&\n               (local_2c = sas7bdat_parse_amd_pages_pass1(local_28,__dest), local_2c == 0)) {\n              lVar4 = (*(code *)puVar1[2])(*(undefined8 *)((long)__dest + 0x88),0,puVar1[5]);\n              if (lVar4 == -1) {\n                local_2c = 0xf;\n                if (*(long *)((long)__dest + 0x30) != 0) {\n                  snprintf((char *)((long)__dest + 0x5ce),0x800,\n                           \"ReadStat: Failed to seek to position %ld\",\n                           *(undefined8 *)((long)__dest + 0x88));\n                  (**(code **)((long)__dest + 0x30))\n                            ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                }\n              }\n              else {\n                local_2c = sas7bdat_parse_all_pages_pass2(__dest);\n                if ((local_2c == 0) &&\n                   (local_2c = sas7bdat_submit_columns_if_needed(__dest,0), local_2c == 0)) {\n                  if ((*(long *)((long)__dest + 0x20) == 0) ||\n                     (*(int *)((long)__dest + 0x78) == *(int *)((long)__dest + 0x80))) {\n                    local_2c = sas7bdat_update_progress(__dest);\n                  }\n                  else {\n                    local_2c = 9;\n                    if (*(long *)((long)__dest + 0x30) != 0) {\n                      snprintf((char *)((long)__dest + 0x5ce),0x800,\n                               \"ReadStat: Expected %d rows in file, found %d\",\n                               (ulong)*(uint *)((long)__dest + 0x80),\n                               (ulong)*(uint *)((long)__dest + 0x78));\n                      (**(code **)((long)__dest + 0x30))\n                                ((long)__dest + 0x5ce,*(undefined8 *)((long)__dest + 0x58));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010188a:\n  (*(code *)puVar1[1])(puVar1[5]);\n  if ((((local_2c == 1) || (local_2c == 2)) || (local_2c == 0xf)) &&\n     (*(long *)((long)__dest + 0x30) != 0)) {\n    uVar6 = readstat_error_message(local_2c);\n    piVar7 = __errno_location();\n    pcVar8 = strerror(*piVar7);\n    piVar7 = __errno_location();\n    snprintf((char *)((long)__dest + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n             uVar6,(ulong)local_2c,pcVar8,*piVar7);\n    (**(code **)((long)__dest + 0x30))((long)__dest + 0x5ce,local_20);\n  }\n  if (__dest != (void *)0x0) {\n    sas7bdat_ctx_free(__dest);\n  }\n  if (__ptr != (uint *)0x0) {\n    free(__ptr);\n  }\n  return local_2c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  call(, , )\n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        call(, , )\n        call(, )\n      }\n    }else{\n      call(, , )\n      if(){\n        \n        if(){\n          call(, , )\n          call(, )\n        }\n      }else{\n        call(, , , )\n        if(){\n          \n          \n          \n          call()\n          \n          \n          \n          \n          \n          \n          \n          if(){\n            \n          }\n          \n          \n          \n          \n          if(){\n            \n          }\n          call()\n          \n          if(){\n            \n          }else{\n            if(call(, )){\n              call(, )\n              if(){\n                \n                goto label\n              }\n              \n            }\n            call(, , , , )\n            if(call(, )call(, )){\n              call(, , )\n              if(){\n                \n                if(){\n                  call(, , , )\n                  call(, )\n                }\n              }else{\n                call()\n                if(call(, )){\n                  if(){\n                    call()\n                  }else{\n                    \n                    if(){\n                      call(, , , , )\n                      call(, )\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  call()\n  if(){\n    call()\n    call()\n    call()\n    call()\n    call(, , , , , , )\n    call(, )\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  call(, , )\n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        call(, , )\n        call(, )\n      }\n    }else{\n      call(, , )\n      if(){\n        \n        if(){\n          call(, , )\n          call(, )\n        }\n      }else{\n        call(, , , )\n        if(){\n          \n          \n          \n          call()\n          \n          \n          \n          \n          \n          \n          \n          if(){\n            \n          }\n          \n          \n          \n          \n          if(){\n            \n          }\n          call()\n          \n          if(){\n            \n          }else{\n            if(call(, )){\n              call(, )\n              if(){\n                \n                goto label\n              }\n              \n            }\n            call(, , , , )\n            if(call(, )call(, )){\n              call(, , )\n              if(){\n                \n                if(){\n                  call(, , , )\n                  call(, )\n                }\n              }else{\n                call()\n                if(call(, )){\n                  if(){\n                    call()\n                  }else{\n                    \n                    if(){\n                      call(, , , , )\n                      call(, )\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  call()\n  if(){\n    call()\n    call()\n    call()\n    call()\n    call(, , , , , , )\n    call(, )\n  }\n  if(){\n    call()\n  }\n  if(){\n    call()\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.0,
          "base_ppl": 1.8203125,
          "pr_ppl": 1.8203125,
          "source_ast_ppl": 2.375,
          "base_ast_ppl": 2.375,
          "pr_ast_ppl": 2.375,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B has a clearer structure, uses meaningful variable names, and avoids goto statements, making it significantly more readable.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O2.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.0,
          "base_ppl": 1.9375,
          "pr_ppl": 1.9296875,
          "source_ast_ppl": 2.375,
          "base_ast_ppl": 2.21875,
          "pr_ast_ppl": 2.21875,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses clearer variable names and a more structured approach, making it easier to follow the logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-readstat_readstat_parse_sas7bdat-O3.so",
        "function": "readstat_parse_sas7bdat",
        "source_code": "readstat_error_t readstat_parse_sas7bdat(readstat_parser_t *parser, const char *path, void *user_ctx) {\n    int64_t last_examined_page_pass1 = 0;\n    readstat_error_t retval = READSTAT_OK;\n    readstat_io_t *io = parser->io;\n\n    sas7bdat_ctx_t  *ctx = calloc(1, sizeof(sas7bdat_ctx_t));\n    sas_header_info_t  *hinfo = calloc(1, sizeof(sas_header_info_t));\n\n    ctx->handle = parser->handlers;\n    ctx->input_encoding = parser->input_encoding;\n    ctx->output_encoding = parser->output_encoding;\n    ctx->user_ctx = user_ctx;\n    ctx->io = parser->io;\n    ctx->row_limit = parser->row_limit;\n    if (parser->row_offset > 0)\n        ctx->row_offset = parser->row_offset;\n\n    if (io->open(path, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_OPEN;\n        goto cleanup;\n    }\n\n    if ((ctx->file_size = io->seek(0, READSTAT_SEEK_END, io->io_ctx)) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to end of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if (io->seek(0, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to beginning of file\");\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas_read_header(io, hinfo, ctx->handle.error, user_ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    ctx->u64 = hinfo->u64;\n    ctx->little_endian = hinfo->little_endian;\n    ctx->vendor = hinfo->vendor;\n    ctx->bswap = machine_is_little_endian() ^ hinfo->little_endian;\n    ctx->header_size = hinfo->header_size;\n    ctx->page_count = hinfo->page_count;\n    ctx->page_size = hinfo->page_size;\n    ctx->page_header_size = hinfo->page_header_size;\n    ctx->subheader_pointer_size = hinfo->subheader_pointer_size;\n    ctx->subheader_signature_size = ctx->u64 ? 8 : 4;\n    ctx->ctime = hinfo->creation_time;\n    ctx->mtime = hinfo->modification_time;\n    ctx->version = hinfo->major_version;\n    if (ctx->input_encoding == NULL) {\n        ctx->input_encoding = hinfo->encoding;\n    }\n    if ((ctx->page = readstat_malloc(ctx->page_size)) == NULL) {\n        retval = READSTAT_ERROR_MALLOC;\n        goto cleanup;\n    }\n\n    if (ctx->input_encoding && ctx->output_encoding && strcmp(ctx->input_encoding, ctx->output_encoding) != 0) {\n        iconv_t converter = iconv_open(ctx->output_encoding, ctx->input_encoding);\n        if (converter == (iconv_t)-1) {\n            retval = READSTAT_ERROR_UNSUPPORTED_CHARSET;\n            goto cleanup;\n        }\n        ctx->converter = converter;\n    }\n\n    if ((retval = readstat_convert(ctx->table_name, sizeof(ctx->table_name),\n                hinfo->table_name, sizeof(hinfo->table_name), ctx->converter)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_meta_pages_pass1(ctx, &last_examined_page_pass1)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_amd_pages_pass1(last_examined_page_pass1, ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (io->seek(ctx->header_size, READSTAT_SEEK_SET, io->io_ctx) == -1) {\n        retval = READSTAT_ERROR_SEEK;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Failed to seek to position %\" PRId64, \n                    ctx->header_size);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_parse_all_pages_pass2(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n    \n    if ((retval = sas7bdat_submit_columns_if_needed(ctx, 0)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\n    if (ctx->handle.value && ctx->parsed_row_count != ctx->row_limit) {\n        retval = READSTAT_ERROR_ROW_COUNT_MISMATCH;\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: Expected %d rows in file, found %d\",\n                    ctx->row_limit, ctx->parsed_row_count);\n            ctx->handle.error(ctx->error_buf, ctx->user_ctx);\n        }\n        goto cleanup;\n    }\n\n    if ((retval = sas7bdat_update_progress(ctx)) != READSTAT_OK) {\n        goto cleanup;\n    }\n\ncleanup:\n    io->close(io->io_ctx);\n\n    if (retval == READSTAT_ERROR_OPEN ||\n            retval == READSTAT_ERROR_READ ||\n            retval == READSTAT_ERROR_SEEK) {\n        if (ctx->handle.error) {\n            snprintf(ctx->error_buf, sizeof(ctx->error_buf), \"ReadStat: %s (retval = %d): %s (errno = %d)\", \n                    readstat_error_message(retval), retval, strerror(errno), errno);\n            ctx->handle.error(ctx->error_buf, user_ctx);\n        }\n    }\n\n    if (ctx)\n        sas7bdat_ctx_free(ctx);\n    if (hinfo)\n        free(hinfo);\n\n    return retval;\n}\n",
        "function_base": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = calloc(1,0xdd0);\n  __ptr = calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "function_pr": "\nulong readstat_parse_sas7bdat(undefined8 *param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 *puVar1;\n  code *pcVar2;\n  char *__s2;\n  int iVar3;\n  uint uVar4;\n  undefined8 *puVar5;\n  uint *__ptr;\n  long lVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  char *pcVar9;\n  iconv_t pvVar10;\n  ulong uVar11;\n  undefined8 local_40;\n  uint *local_38;\n  \n  local_40 = 0;\n  puVar1 = (undefined8 *)param_1[8];\n  puVar5 = (undefined8 *)calloc(1,0xdd0);\n  __ptr = (uint *)calloc(1,0x180);\n  uVar7 = param_1[1];\n  *puVar5 = *param_1;\n  puVar5[1] = uVar7;\n  puVar5[2] = param_1[2];\n  puVar5[3] = param_1[3];\n  puVar5[4] = param_1[4];\n  puVar5[5] = param_1[5];\n  puVar5[6] = param_1[6];\n  puVar5[7] = param_1[7];\n  puVar5[0x24] = param_1[9];\n  puVar5[0x25] = param_1[10];\n  puVar5[0xb] = param_3;\n  puVar5[0xc] = puVar1;\n  *(undefined4 *)(puVar5 + 0x10) = *(undefined4 *)(param_1 + 0xb);\n  if (0 < (long)param_1[0xc]) {\n    *(int *)((long)puVar5 + 0x84) = (int)param_1[0xc];\n  }\n  iVar3 = (*(code *)*puVar1)(param_2,puVar1[5]);\n  if (iVar3 == -1) {\n    uVar11 = 1;\nLAB_00101559:\n    (*(code *)puVar1[1])(puVar1[5]);\n    lVar6 = puVar5[6];\njoined_r0x00101568:\n    if (lVar6 != 0) {\n      uVar7 = readstat_error_message(uVar11);\n      piVar8 = __errno_location();\n      local_38 = __ptr;\n      pcVar9 = strerror(*piVar8);\n      snprintf((char *)((long)puVar5 + 0x5ce),0x800,\"ReadStat: %s (retval = %d): %s (errno = %d)\",\n               uVar7,uVar11,pcVar9,*piVar8);\n      __ptr = local_38;\n      (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),param_3);\n    }\n  }\n  else {\n    lVar6 = (*(code *)puVar1[2])(0,2,puVar1[5]);\n    puVar5[8] = lVar6;\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if ((code *)puVar5[6] != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x20646e65206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*(code *)puVar5[6])((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    lVar6 = (*(code *)puVar1[2])(0,0,puVar1[5]);\n    pcVar2 = (code *)puVar5[6];\n    if (lVar6 == -1) {\n      uVar11 = 0xf;\n      if (pcVar2 != (code *)0x0) {\n        *(undefined8 *)((long)puVar5 + 0x5f4) = 0x656c696620666f;\n        *(undefined8 *)((long)puVar5 + 0x5ee) = 0x666f20676e696e6e;\n        *(undefined8 *)((long)puVar5 + 0x5e6) = 0x69676562206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5de) = 0x6b656573206f7420;\n        *(undefined8 *)((long)puVar5 + 0x5d6) = 0x64656c696146203a;\n        *(undefined8 *)((long)puVar5 + 0x5ce) = 0x7461745364616552;\n        (*pcVar2)((long)puVar5 + 0x5ce,puVar5[0xb]);\n      }\n      goto LAB_00101559;\n    }\n    uVar4 = sas_read_header(puVar1,__ptr,pcVar2,param_3);\n    uVar11 = (ulong)uVar4;\n    if (uVar4 == 0) {\n      *(uint *)((long)puVar5 + 0x4c) = __ptr[1];\n      *(uint *)(puVar5 + 9) = *__ptr;\n      *(uint *)(puVar5 + 10) = __ptr[2];\n      uVar4 = machine_is_little_endian();\n      *(uint *)(puVar5 + 0xd) = uVar4 ^ *__ptr;\n      puVar5[0x11] = *(undefined8 *)(__ptr + 0x10);\n      puVar5[0x12] = *(undefined8 *)(__ptr + 0xe);\n      puVar5[0x13] = *(undefined8 *)(__ptr + 8);\n      puVar5[0x16] = *(undefined8 *)(__ptr + 10);\n      puVar5[0x18] = *(undefined8 *)(__ptr + 0xc);\n      puVar5[0x17] = (ulong)(*(int *)((long)puVar5 + 0x4c) != 0) * 4 + 4;\n      puVar5[0x27] = *(undefined8 *)(__ptr + 0x12);\n      puVar5[0x28] = *(undefined8 *)(__ptr + 0x14);\n      *(uint *)(puVar5 + 0x29) = __ptr[3];\n      if (puVar5[0x24] == 0) {\n        puVar5[0x24] = *(undefined8 *)(__ptr + 0x5e);\n      }\n      lVar6 = readstat_malloc();\n      puVar5[0x14] = lVar6;\n      if (lVar6 == 0) {\n        uVar11 = 3;\nLAB_00101735:\n        (*(code *)puVar1[1])(puVar1[5]);\n        sas7bdat_ctx_free(puVar5);\n        goto LAB_00101443;\n      }\n      pcVar9 = (char *)puVar5[0x24];\n      if (((pcVar9 != (char *)0x0) && (__s2 = (char *)puVar5[0x25], __s2 != (char *)0x0)) &&\n         (iVar3 = strcmp(pcVar9,__s2), iVar3 != 0)) {\n        pvVar10 = iconv_open(__s2,pcVar9);\n        if (pvVar10 == (iconv_t)0xffffffffffffffff) {\n          uVar11 = 7;\n          goto LAB_00101735;\n        }\n        puVar5[0x26] = pvVar10;\n      }\n      uVar4 = readstat_convert((long)puVar5 + 0x14c,0x81,__ptr + 0x16,0x20,puVar5[0x26]);\n      uVar11 = (ulong)uVar4;\n      if (uVar4 == 0) {\n        uVar4 = sas7bdat_parse_meta_pages_pass1(puVar5,&local_40);\n        uVar11 = (ulong)uVar4;\n        if (uVar4 == 0) {\n          uVar4 = sas7bdat_parse_amd_pages_pass1(local_40,puVar5);\n          uVar11 = (ulong)uVar4;\n          if (uVar4 == 0) {\n            lVar6 = (*(code *)puVar1[2])(puVar5[0x11],0,puVar1[5]);\n            if (lVar6 == -1) {\n              uVar11 = 0xf;\n              if (puVar5[6] != 0) {\n                snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                         \"ReadStat: Failed to seek to position %ld\",puVar5[0x11]);\n                uVar11 = 0xf;\n                (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n              }\n              goto LAB_00101559;\n            }\n            uVar4 = sas7bdat_parse_all_pages_pass2(puVar5);\n            uVar11 = (ulong)uVar4;\n            if (uVar4 == 0) {\n              uVar4 = sas7bdat_submit_columns_if_needed(puVar5,0);\n              uVar11 = (ulong)uVar4;\n              if (uVar4 == 0) {\n                if ((puVar5[4] != 0) && (*(int *)(puVar5 + 0xf) != *(int *)(puVar5 + 0x10))) {\n                  uVar11 = 9;\n                  if (puVar5[6] != 0) {\n                    snprintf((char *)((long)puVar5 + 0x5ce),0x800,\n                             \"ReadStat: Expected %d rows in file, found %d\");\n                    (*(code *)puVar5[6])((char *)((long)puVar5 + 0x5ce),puVar5[0xb]);\n                  }\n                  goto LAB_00101735;\n                }\n                uVar4 = sas7bdat_update_progress(puVar5);\n                uVar11 = (ulong)uVar4;\n              }\n            }\n          }\n        }\n      }\n    }\n    (*(code *)puVar1[1])(puVar1[5]);\n    if (((uint)uVar11 < 0x10) && ((0x8006U >> ((uint)uVar11 & 0x1f) & 1) != 0)) {\n      lVar6 = puVar5[6];\n      goto joined_r0x00101568;\n    }\n  }\n  sas7bdat_ctx_free(puVar5);\n  if (__ptr == (uint *)0x0) {\n    return uVar11;\n  }\nLAB_00101443:\n  free(__ptr);\n  return uVar11;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  if()\n  if(call(, )){\n    \n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , )\n      call(, )\n    }\n    goto label\n  }\n  if(call(, , , )){\n    goto label\n  }\n  \n  \n  \n  call()\n  \n  \n  \n  \n  \n  (? : )\n  \n  \n  \n  if(){\n    \n  }\n  if(call()){\n    \n    goto label\n  }\n  if(call(, )){\n    call(, )\n    if(){\n      \n      goto label\n    }\n    \n  }\n  if(call(, , , , )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(call(, , )){\n    \n    if(){\n      call(, , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  if(call(, )){\n    goto label\n  }\n  if(){\n    \n    if(){\n      call(, , , , )\n      call(, )\n    }\n    goto label\n  }\n  if(call()){\n    goto label\n  }\n  call()\n  if(){\n    if(){\n      call(, , , call(), , call(), )\n      call(, )\n    }\n  }\n  if()call()\n  if()call()\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  call(, )\n  call(, )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }\n  call(, )\n  if(){\n    \n    call()\n    \n    if(){\n      call()\n      call()\n      \n      call()\n      call(, , , , , , )\n      \n      call(, )\n    }\n  }else{\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , )\n    \n    if(){\n      \n      if(){\n        \n        \n        \n        \n        \n        \n        call(, )\n      }\n      goto label\n    }\n    call(, , , )\n    \n    if(){\n      \n      \n      \n      call()\n      \n      \n      \n      \n      \n      \n      call()\n      \n      \n      \n      if(){\n        \n      }\n      call()\n      \n      if(){\n        \n        call()\n        call()\n        goto label\n      }\n      \n      if(call(, )){\n        call(, )\n        if(){\n          \n          goto label\n        }\n        \n      }\n      call(, , , , )\n      \n      if(){\n        call(, )\n        \n        if(){\n          call(, )\n          \n          if(){\n            call(, , )\n            if(){\n              \n              if(){\n                call(, , , )\n                \n                call(, )\n              }\n              goto label\n            }\n            call()\n            \n            if(){\n              call(, )\n              \n              if(){\n                if(){\n                  \n                  if(){\n                    call(, , )\n                    call(, )\n                  }\n                  goto label\n                }\n                call()\n                \n              }\n            }\n          }\n        }\n      }\n    }\n    call()\n    if(){\n      \n      goto label\n    }\n  }\n  call()\n  if(){\n    return\n  }\n  call()\n  return\n}",
        "metrics": {
          "source_ppl": 2.0,
          "base_ppl": 1.9375,
          "pr_ppl": 1.9296875,
          "source_ast_ppl": 2.375,
          "base_ast_ppl": 2.21875,
          "pr_ast_ppl": 2.21875,
          "delta_ppl": -0.0078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B uses clear, idiomatic C constructs with a logical structure, making it easier to understand and less prone to errors compared to Candidate A's more convoluted approach.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      },
      {
        "binary": "task-file_file_zmagic-O0.so",
        "function": "file_zmagic",
        "source_code": "file_protected int\nfile_zmagic(struct magic_set *ms, const struct buffer *b, const char *name)\n{\n\tunsigned char *newbuf = NULL;\n\tsize_t i, nsz;\n\tchar *rbuf;\n\tfile_pushbuf_t *pb;\n\tint urv, prv, rv = 0;\n\tint mime = ms->flags & MAGIC_MIME;\n\tint fd = b->fd;\n\tconst unsigned char *buf = CAST(const unsigned char *, b->fbuf);\n\tsize_t nbytes = b->flen;\n\tint sa_saved = 0;\n\tstruct sigaction sig_act;\n\n\tif ((ms->flags & MAGIC_COMPRESS) == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ncompr; i++) {\n\t\tint zm;\n\t\tif (nbytes < CAST(size_t, abs(compr[i].maglen)))\n\t\t\tcontinue;\n\t\tif (compr[i].maglen < 0) {\n\t\t\tzm = (*compr[i].u.func)(buf);\n\t\t} else {\n\t\t\tzm = memcmp(buf, compr[i].u.magic,\n\t\t\t    CAST(size_t, compr[i].maglen)) == 0;\n\t\t}\n\n\t\tif (!zm)\n\t\t\tcontinue;\n\n\t\t/* Prevent SIGPIPE death if child dies unexpectedly */\n\t\tif (!sa_saved) {\n\t\t\t//We can use sig_act for both new and old, but\n\t\t\tstruct sigaction new_act;\n\t\t\tmemset(&new_act, 0, sizeof(new_act));\n\t\t\tnew_act.sa_handler = SIG_IGN;\n\t\t\tsa_saved = sigaction(SIGPIPE, &new_act, &sig_act) != -1;\n\t\t}\n\n\t\tnsz = nbytes;\n\t\tfree(newbuf);\n\t\turv = uncompressbuf(fd, ms->bytes_max, i, \n\t\t    (ms->flags & MAGIC_NO_COMPRESS_FORK), buf, &newbuf, &nsz);\n\t\tDPRINTF(\"uncompressbuf = %d, %s, %\" SIZE_T_FORMAT \"u\\n\", urv,\n\t\t    (char *)newbuf, nsz);\n\t\tswitch (urv) {\n\t\tcase OKDATA:\n\t\tcase ERRDATA:\n\t\t\tms->flags &= ~MAGIC_COMPRESS;\n\t\t\tif (urv == ERRDATA)\n\t\t\t\tprv = format_decompression_error(ms, i, newbuf);\n\t\t\telse\n\t\t\t\tprv = file_buffer(ms, -1, NULL, name, newbuf,\n\t\t\t\t    nsz);\n\t\t\tif (prv == -1)\n\t\t\t\tgoto error;\n\t\t\trv = 1;\n\t\t\tif ((ms->flags & MAGIC_COMPRESS_TRANSP) != 0)\n\t\t\t\tgoto out;\n\t\t\tif (mime != MAGIC_MIME && mime != 0)\n\t\t\t\tgoto out;\n\t\t\tif ((file_printf(ms,\n\t\t\t    mime ? \" compressed-encoding=\" : \" (\")) == -1)\n\t\t\t\tgoto error;\n\t\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t * XXX: If file_buffer fails here, we overwrite\n\t\t\t * the compressed text. FIXME.\n\t\t\t */\n\t\t\tif (file_buffer(ms, -1, NULL, NULL, buf, nbytes) == -1)\n\t\t\t{\n\t\t\t\tif (file_pop_buffer(ms, pb) != NULL)\n\t\t\t\t\tabort();\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif ((rbuf = file_pop_buffer(ms, pb)) != NULL) {\n\t\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\t\tfree(rbuf);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tfree(rbuf);\n\t\t\t}\n\t\t\tif (!mime && file_printf(ms, \")\") == -1)\n\t\t\t\tgoto error;\n\t\t\t/*FALLTHROUGH*/\n\t\tcase NODATA:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\t/*NOTREACHED*/\n\t\terror:\n\t\t\trv = -1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tDPRINTF(\"rv = %d\\n\", rv);\n\n\tif (sa_saved && sig_act.sa_handler != SIG_IGN)\n\t\t(void)sigaction(SIGPIPE, &sig_act, NULL);\n\n\tfree(newbuf);\n\tms->flags |= MAGIC_COMPRESS;\n\tDPRINTF(\"Zmagic returns %d\\n\", rv);\n\treturn rv;\n}\n",
        "function_base": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  int iVar3;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar3 = -*(int *)(compr + local_38 * 0x20 + 8);\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (-1 < iVar3) {\n        iVar1 = iVar3;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "function_pr": "\nundefined4 file_zmagic(long param_1,undefined4 *param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  long lVar2;\n  _union_1457 local_1b8 [19];\n  uint local_11c;\n  _union_1457 local_118 [19];\n  uint local_7c;\n  ulong local_78;\n  void *local_70;\n  undefined4 local_64;\n  uint local_60;\n  undefined4 local_5c;\n  int local_58;\n  int local_54;\n  long local_50;\n  void *local_48;\n  ulong local_40;\n  ulong local_38;\n  void *local_30;\n  undefined8 local_28;\n  undefined4 *local_20;\n  long local_18;\n  undefined4 local_c;\n  \n  local_30 = (void *)0x0;\n  local_5c = 0;\n  local_60 = *(uint *)(param_1 + 0x44) & 0x410;\n  local_64 = *param_2;\n  local_70 = *(void **)(param_2 + 0x26);\n  local_78 = *(ulong *)(param_2 + 0x28);\n  local_7c = 0;\n  if ((*(uint *)(param_1 + 0x44) & 4) == 0) {\n    local_c = 0;\n  }\n  else {\n    local_28 = param_3;\n    local_20 = param_2;\n    local_18 = param_1;\n    for (local_38 = 0; local_38 < ncompr; local_38 = local_38 + 1) {\n      iVar1 = *(int *)(compr + local_38 * 0x20 + 8);\n      if (iVar1 < 1) {\n        iVar1 = -iVar1;\n      }\n      if ((ulong)(long)iVar1 <= local_78) {\n        if (*(int *)(compr + local_38 * 0x20 + 8) < 0) {\n          local_11c = (**(code **)(compr + local_38 * 0x20))(local_70);\n        }\n        else {\n          iVar1 = memcmp(local_70,*(void **)(compr + local_38 * 0x20),\n                         (long)*(int *)(compr + local_38 * 0x20 + 8));\n          local_11c = (uint)(iVar1 == 0);\n        }\n        if (local_11c != 0) {\n          if (local_7c == 0) {\n            memset(local_1b8,0,0x98);\n            local_1b8[0] = (_union_1457)0x1;\n            iVar1 = sigaction(0xd,(sigaction *)local_1b8,(sigaction *)local_118);\n            local_7c = (uint)(iVar1 != -1);\n          }\n          local_40 = local_78;\n          free(local_30);\n          local_54 = uncompressbuf(local_64,*(undefined8 *)(local_18 + 0x120),local_38,\n                                   *(uint *)(local_18 + 0x44) & 0x4000000,local_70,&local_30,\n                                   &local_40);\n          if (local_54 != 0) {\n            if (local_54 == 1) goto LAB_00102adf;\n            if (local_54 != 2) {\n                    /* WARNING: Subroutine does not return */\n              abort();\n            }\n          }\n          *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) & 0xfffffffb;\n          if (local_54 == 2) {\n            local_58 = format_decompression_error(local_18,local_38,local_30);\n          }\n          else {\n            local_58 = file_buffer(local_18,0xffffffff,0,local_28,local_30,local_40);\n          }\n          if (local_58 != -1) {\n            local_5c = 1;\n            if (((*(uint *)(local_18 + 0x44) & 0x2000000) != 0) ||\n               ((local_60 != 0x410 && (local_60 != 0)))) break;\n            iVar1 = file_printf(local_18);\n            if ((iVar1 != -1) && (local_50 = file_push_buffer(local_18), local_50 != 0)) {\n              iVar1 = file_buffer(local_18,0xffffffff,0,0,local_70,local_78);\n              if (iVar1 == -1) {\n                lVar2 = file_pop_buffer(local_18);\n                if (lVar2 != 0) {\n                    /* WARNING: Subroutine does not return */\n                  abort();\n                }\n              }\n              else {\n                local_48 = (void *)file_pop_buffer(local_18);\n                if (local_48 != (void *)0x0) {\n                  iVar1 = file_printf(local_18,\"%s\",local_48);\n                  if (iVar1 == -1) {\n                    free(local_48);\n                    goto LAB_00102ad3;\n                  }\n                  free(local_48);\n                }\n                if ((local_60 != 0) || (iVar1 = file_printf(local_18), iVar1 != -1))\n                goto LAB_00102adf;\n              }\n            }\n          }\nLAB_00102ad3:\n          local_5c = 0xffffffff;\n        }\n      }\nLAB_00102adf:\n    }\n    if ((local_7c != 0) && (local_118[0].sa_handler != (__sighandler_t)0x1)) {\n      sigaction(0xd,(sigaction *)local_118,(sigaction *)0x0);\n    }\n    free(local_30);\n    *(uint *)(local_18 + 0x44) = *(uint *)(local_18 + 0x44) | 4;\n    local_c = local_5c;\n  }\n  return local_c;\n}\n\n",
        "source_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  call()\n  \n  \n  \n  if()return\n  for(;;){\n    \n    if(call(, call()))\n    if(){\n      call()\n    }else{\n      call(, , call(, ))\n    }\n    if()\n    \n    if(){\n      \n      \n      call(, , )\n      \n      call(, , )\n    }\n    \n    call()\n    call(, , , , , , )\n    call(, , , )\n    switch(){\n      case :\n      case :\n        \n        if()call(, , )elsecall(, , , , , )\n        if()goto label\n        \n        if()goto label\n        if()goto label\n        if(call(, (? : )))goto label\n        if(call())goto label\n        \n        if(call(, , , , , )){\n          if(call(, ))call()\n          goto label\n        }\n        if(call(, )){\n          if(call(, , )){\n            call()\n            goto label\n          }\n          call()\n        }\n        if(call(, ))goto label\n      \n      case :\n        \n      case :\n        \n        call()\n        \n        \n        \n    }\n  }\n  call(, )\n  if()call(, , )\n  call()\n  \n  call(, )\n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    \n    \n    for(;;){\n      \n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n        }else{\n          call(, , )\n          call()\n        }\n        if(){\n          if(){\n            call(, , )\n            \n            call(, , )\n            call()\n          }\n          \n          call()\n          call(, , , , , , )\n          if(){\n            if()goto label\n            if(){\n              \n              call()\n            }\n          }\n          \n          if(){\n            call(, , )\n          }else{\n            call(, , , , , )\n          }\n          if(){\n            \n            if()\n            call()\n            if(call()){\n              call(, , , , , )\n              if(){\n                call()\n                if(){\n                  \n                  call()\n                }\n              }else{\n                call()\n                if(){\n                  call(, , )\n                  if(){\n                    call()\n                    goto label\n                  }\n                  call()\n                }\n                if(call())goto label\n              }\n            }\n          }\n          \n        }\n      }\n      \n    }\n    if(){\n      call(, , )\n    }\n    call()\n    \n    \n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n  }else{\n    \n    \n    \n    for(;;){\n      \n      if(){\n        \n      }\n      if(){\n        if(){\n          call()\n        }else{\n          call(, , )\n          call()\n        }\n        if(){\n          if(){\n            call(, , )\n            \n            call(, , )\n            call()\n          }\n          \n          call()\n          call(, , , , , , )\n          if(){\n            if()goto label\n            if(){\n              \n              call()\n            }\n          }\n          \n          if(){\n            call(, , )\n          }else{\n            call(, , , , , )\n          }\n          if(){\n            \n            if()\n            call()\n            if(call()){\n              call(, , , , , )\n              if(){\n                call()\n                if(){\n                  \n                  call()\n                }\n              }else{\n                call()\n                if(){\n                  call(, , )\n                  if(){\n                    call()\n                    goto label\n                  }\n                  call()\n                }\n                if(call())goto label\n              }\n            }\n          }\n          \n        }\n      }\n      \n    }\n    if(){\n      call(, , )\n    }\n    call()\n    \n    \n  }\n  return\n}",
        "metrics": {
          "source_ppl": 3.546875,
          "base_ppl": 2.109375,
          "pr_ppl": 2.140625,
          "source_ast_ppl": 4.15625,
          "base_ast_ppl": 2.640625,
          "pr_ast_ppl": 2.640625,
          "delta_ppl": 0.03125
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while less semantically perfect, uses standard loops and structures, making it more readable and approachable for a human developer.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates incorrectly restructure the Source's nested if-else blocks and introduce unnecessary goto statements. However, Candidate A preserves the original `for` loop structure, while Candidate B incorrectly converts it to a `while` loop with goto statements.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_checkfmt-O2.so",
        "function": "file_checkfmt",
        "source_code": "file_protected int\nfile_checkfmt(char *msg, size_t mlen, const char *fmt)\n{\n\tconst char *p;\n\tfor (p = fmt; *p; p++) {\n\t\tif (*p != '%')\n\t\t\tcontinue;\n\t\tif (*++p == '%')\n\t\t\tcontinue;\n\t\tif (*p == '\\0') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"incomplete %% format\");\n\t\t\treturn -1;\n\t\t}\n\t\t// Skip uninteresting.\n\t\twhile (*p != '\\0' && strchr(\"#0.'+- \", *p) != NULL)\n\t\t\tp++;\n\t\tif (*p == '*') {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"* not allowed in format\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (!file_checkfield(msg, mlen, \"width\", &p))\n\t\t\treturn -1;\n\n\t\tif (*p == '.') {\n\t\t\tp++;\n\t\t\tif (!file_checkfield(msg, mlen, \"precision\", &p))\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (!isalpha((unsigned char)*p)) {\n\t\t\tif (msg)\n\t\t\t\tsnprintf(msg, mlen, \"bad format char: %c\", *p);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "function_base": "\nundefined8 file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    for (; *param_3 != 0x25; param_3 = param_3 + 1) {\n      if (*param_3 == 0) {\n        return 0;\n      }\nLAB_0010122d:\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        __format = \"incomplete %% format\";\nLAB_00101278:\n        snprintf(param_1,param_2,__format);\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "function_pr": "\nulong file_checkfmt(char *param_1,size_t param_2,byte *param_3)\n\n{\n  int iVar1;\n  ushort **ppuVar2;\n  char *__format;\n  byte bVar3;\n  byte *local_38;\n  \n  do {\n    while( true ) {\n      bVar3 = *param_3;\n      if (bVar3 == 0x25) break;\n      if (bVar3 == 0) {\n        return (ulong)bVar3;\n      }\nLAB_0010122d:\n      param_3 = param_3 + 1;\n    }\n    local_38 = param_3 + 1;\n    bVar3 = param_3[1];\n    if (bVar3 != 0x25) {\n      if (bVar3 == 0) {\n        if (param_1 != (char *)0x0) {\n          __format = \"incomplete %% format\";\nLAB_00101278:\n          snprintf(param_1,param_2,__format);\n        }\n        return 0xffffffff;\n      }\n      do {\n        if ((0x3f < bVar3) || ((1L << (bVar3 & 0x3f) & 0x1688900000001U) == 0)) {\n          if (bVar3 == 0x2a) {\n            if (param_1 == (char *)0x0) {\n              return 0xffffffff;\n            }\n            __format = \"* not allowed in format\";\n            goto LAB_00101278;\n          }\n          break;\n        }\n        bVar3 = local_38[1];\n        local_38 = local_38 + 1;\n      } while (bVar3 != 0);\n      iVar1 = file_checkfield(param_1,param_2,\"width\",&local_38);\n      if (iVar1 == 0) {\n        return 0xffffffff;\n      }\n      bVar3 = *local_38;\n      if (bVar3 == 0x2e) {\n        local_38 = local_38 + 1;\n        iVar1 = file_checkfield(param_1,param_2,\"precision\",&local_38);\n        if (iVar1 == 0) {\n          return 0xffffffff;\n        }\n        bVar3 = *local_38;\n      }\n      param_3 = local_38;\n      ppuVar2 = __ctype_b_loc();\n      if ((*(byte *)((long)*ppuVar2 + (ulong)bVar3 * 2 + 1) & 4) == 0) {\n        if (param_1 == (char *)0x0) {\n          return 0xffffffff;\n        }\n        snprintf(param_1,param_2,\"bad format char: %c\",(ulong)(uint)(int)(char)bVar3);\n        return 0xffffffff;\n      }\n      goto LAB_0010122d;\n    }\n    param_3 = param_3 + 2;\n  } while( true );\n}\n\n",
        "source_ast": "{\n  \n  for(;;){\n    if()\n    if()\n    if(){\n      if()call(, , )\n      return\n    }\n    \n    while(call(, ))\n    if(){\n      if()call(, , )\n      return\n    }\n    if(call(, , , ))return\n    if(){\n      \n      if(call(, , , ))return\n    }\n    if(call()){\n      if()call(, , , )\n      return\n    }\n  }\n  return\n}",
        "base_ast": "{\n  for(;;){\n    if(){\n      return\n    }\n    \n    \n    if(){\n      if(){\n        if(){\n          return\n        }\n        \n        call(, , )\n        return\n      }\n      do{\n        if(){\n          if(){\n            if(){\n              return\n            }\n            \n            goto label\n          }\n          \n        }\n        \n        \n      }while()\n      call(, , , )\n      if(){\n        return\n      }\n      \n      if(){\n        \n        call(, , , )\n        if(){\n          return\n        }\n        \n      }\n      \n      call()\n      if(){\n        if(){\n          return\n        }\n        call(, , , )\n        return\n      }\n      goto label\n    }\n    \n  }\n  while()\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  do{\n    while(){\n      \n      if()\n      if(){\n        return\n      }\n      \n    }\n    \n    \n    if(){\n      if(){\n        if(){\n          \n          call(, , )\n        }\n        return\n      }\n      do{\n        if(){\n          if(){\n            if(){\n              return\n            }\n            \n            goto label\n          }\n          \n        }\n        \n        \n      }while()\n      call(, , , )\n      if(){\n        return\n      }\n      \n      if(){\n        \n        call(, , , )\n        if(){\n          return\n        }\n        \n      }\n      \n      call()\n      if(){\n        if(){\n          return\n        }\n        call(, , , )\n        return\n      }\n      goto label\n    }\n    \n  }while()\n}",
        "metrics": {
          "source_ppl": 2.921875,
          "base_ppl": 2.203125,
          "pr_ppl": 2.28125,
          "source_ast_ppl": 5.1875,
          "base_ast_ppl": 3.0625,
          "pr_ast_ppl": 3.078125,
          "delta_ppl": 0.078125
        },
        "llm_qualitative": {
          "motivation": "Candidate B exhibits a more idiomatic and readable structure with standard loops and clear logic, making it easier for a human to understand and modify.",
          "winner": "PR"
        },
        "llm_ast": {
          "motivation": "Both candidates incorrectly restructure the source's loops, but Candidate A preserves the outermost for-loop structure more closely.",
          "winner": "BASE"
        }
      },
      {
        "binary": "task-file_file_getbuffer-O2.so",
        "function": "file_getbuffer",
        "source_code": "file_protected const char *\nfile_getbuffer(struct magic_set *ms)\n{\n\tchar *pbuf, *op, *np;\n\tsize_t psize, len;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif (ms->flags & MAGIC_RAW)\n\t\treturn ms->o.buf;\n\n\tif (ms->o.buf == NULL)\n\t\treturn NULL;\n\n\t/* * 4 is for octal representation, + 1 is for NUL */\n\tlen = strlen(ms->o.buf);\n\tif (len > (SIZE_MAX - 1) / 4) {\n\t\tfile_oomem(ms, len);\n\t\treturn NULL;\n\t}\n\tpsize = len * 4 + 1;\n\tif ((pbuf = CAST(char *, realloc(ms->o.pbuf, psize))) == NULL) {\n\t\tfile_oomem(ms, psize);\n\t\treturn NULL;\n\t}\n\tms->o.pbuf = pbuf;\n\n#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)\n\t{\n\t\tmbstate_t state;\n\t\twchar_t nextchar;\n\t\tint mb_conv = 1;\n\t\tsize_t bytesconsumed;\n\t\tchar *eop;\n\t\t(void)memset(&state, 0, sizeof(mbstate_t));\n\n\t\tnp = ms->o.pbuf;\n\t\top = ms->o.buf;\n\t\teop = op + len;\n\n\t\twhile (op < eop) {\n\t\t\tbytesconsumed = mbrtowc(&nextchar, op,\n\t\t\t    CAST(size_t, eop - op), &state);\n\t\t\tif (bytesconsumed == CAST(size_t, -1) ||\n\t\t\t    bytesconsumed == CAST(size_t, -2)) {\n\t\t\t\tmb_conv = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iswprint(nextchar)) {\n\t\t\t\t(void)memcpy(np, op, bytesconsumed);\n\t\t\t\top += bytesconsumed;\n\t\t\t\tnp += bytesconsumed;\n\t\t\t} else {\n\t\t\t\twhile (bytesconsumed-- > 0)\n\t\t\t\t\tOCTALIFY(np, op);\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\n\t\t/* Parsing succeeded as a multi-byte sequence */\n\t\tif (mb_conv != 0)\n\t\t\treturn ms->o.pbuf;\n\t}\n#endif\n\n\tfor (np = ms->o.pbuf, op = ms->o.buf; *op;) {\n\t\tif (isprint(CAST(unsigned char, *op))) {\n\t\t\t*np++ = *op++;\n\t\t} else {\n\t\t\tOCTALIFY(np, op);\n\t\t}\n\t}\n\t*np = '\\0';\n\treturn ms->o.pbuf;\n}\n",
        "function_base": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "function_pr": "\nchar * file_getbuffer(long param_1)\n\n{\n  char *__s;\n  int iVar1;\n  size_t sVar2;\n  undefined1 *__dest;\n  size_t sVar3;\n  ushort **ppuVar4;\n  byte bVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  wchar_t local_3c;\n  mbstate_t local_38;\n  \n  if ((*(byte *)(param_1 + 0x48) & 1) == 0) {\n    __s = *(char **)(param_1 + 0x20);\n    if ((*(byte *)(param_1 + 0x45) & 1) != 0) {\n      return __s;\n    }\n    if (__s != (char *)0x0) {\n      sVar2 = strlen(__s);\n      sVar3 = sVar2;\n      if (sVar2 >> 0x3e == 0) {\n        sVar3 = sVar2 * 4 + 1;\n        __dest = (undefined1 *)realloc(*(void **)(param_1 + 0x30),sVar3);\n        if (__dest != (undefined1 *)0x0) {\n          *(undefined1 **)(param_1 + 0x30) = __dest;\n          local_38.__count = 0;\n          local_38.__value = (_union_27)0x0;\n          if (sVar2 != 0) {\n            pbVar6 = *(byte **)(param_1 + 0x20);\n            pbVar7 = pbVar6 + sVar2;\n            do {\n              sVar3 = mbrtowc(&local_3c,(char *)pbVar6,(long)pbVar7 - (long)pbVar6,&local_38);\n              if (0xfffffffffffffffd < sVar3) {\n                *__dest = 0;\n                pbVar6 = *(byte **)(param_1 + 0x20);\n                pbVar7 = *(byte **)(param_1 + 0x30);\n                bVar5 = *pbVar6;\n                if (bVar5 != 0) {\n                  ppuVar4 = __ctype_b_loc();\n                  do {\n                    if ((*(byte *)((long)*ppuVar4 + (ulong)bVar5 * 2 + 1) & 0x40) == 0) {\n                      *pbVar7 = 0x5c;\n                      pbVar7[1] = *pbVar6 >> 6 | 0x30;\n                      pbVar7[2] = *pbVar6 >> 3 & 7 | 0x30;\n                      pbVar7[3] = *pbVar6 & 7 | 0x30;\n                      pbVar7 = pbVar7 + 4;\n                    }\n                    else {\n                      *pbVar7 = bVar5;\n                      pbVar7 = pbVar7 + 1;\n                    }\n                    bVar5 = pbVar6[1];\n                    pbVar6 = pbVar6 + 1;\n                  } while (bVar5 != 0);\n                }\n                *pbVar7 = 0;\n                return *(char **)(param_1 + 0x30);\n              }\n              iVar1 = iswprint(local_3c);\n              if (iVar1 == 0) {\n                for (; sVar3 != 0; sVar3 = sVar3 - 1) {\n                  *__dest = 0x5c;\n                  __dest[1] = *pbVar6 >> 6 | 0x30;\n                  __dest[2] = *pbVar6 >> 3 & 7 | 0x30;\n                  bVar5 = *pbVar6;\n                  pbVar6 = pbVar6 + 1;\n                  __dest[3] = bVar5 & 7 | 0x30;\n                  __dest = __dest + 4;\n                }\n              }\n              else {\n                memcpy(__dest,pbVar6,sVar3);\n                pbVar6 = pbVar6 + sVar3;\n                __dest = __dest + sVar3;\n              }\n            } while (pbVar6 < pbVar7);\n          }\n          *__dest = 0;\n          return *(char **)(param_1 + 0x30);\n        }\n      }\n      file_oomem(param_1,sVar3);\n      return (char *)0x0;\n    }\n  }\n  return (char *)0x0;\n}\n\n",
        "source_ast": "{\n  \n  \n  if()return\n  if()return\n  if()return\n  \n  call()\n  if(){\n    call(, )\n    return\n  }\n  \n  if(call(call(, ))){\n    call(, )\n    return\n  }\n  \n  {\n    \n    \n    \n    \n    \n    call(, , )\n    \n    \n    \n    while(){\n      call(, , call(, ), )\n      if(call(, )call(, )){\n        \n        \n      }\n      if(call()){\n        call(, , )\n        \n        \n      }else{\n        while()call(, )\n      }\n    }\n    \n    \n    if()return\n  }\n  for(;;){\n    if(call(call(, , ))){\n      \n    }else{\n      call(, )\n    }\n  }\n  \n  return\n}",
        "base_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      return\n    }\n    if(){\n      call()\n      \n      if(){\n        \n        call(, )\n        if(){\n          \n          \n          \n          if(){\n            \n            \n            do{\n              call(, , , )\n              if(){\n                \n                \n                \n                \n                if(){\n                  call()\n                  do{\n                    if(){\n                      \n                      \n                      \n                      \n                      \n                    }else{\n                      \n                      \n                    }\n                    \n                    \n                  }while()\n                }\n                \n                return\n              }\n              call()\n              if(){\n                for(;;){\n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                }\n              }else{\n                call(, , )\n                \n                \n              }\n            }while()\n          }\n          \n          return\n        }\n      }\n      call(, )\n      return\n    }\n  }\n  return\n}",
        "pr_ast": "{\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(){\n    \n    if(){\n      return\n    }\n    if(){\n      call()\n      \n      if(){\n        \n        call(, )\n        if(){\n          \n          \n          \n          if(){\n            \n            \n            do{\n              call(, , , )\n              if(){\n                \n                \n                \n                \n                if(){\n                  call()\n                  do{\n                    if(){\n                      \n                      \n                      \n                      \n                      \n                    }else{\n                      \n                      \n                    }\n                    \n                    \n                  }while()\n                }\n                \n                return\n              }\n              call()\n              if(){\n                for(;;){\n                  \n                  \n                  \n                  \n                  \n                  \n                  \n                }\n              }else{\n                call(, , )\n                \n                \n              }\n            }while()\n          }\n          \n          return\n        }\n      }\n      call(, )\n      return\n    }\n  }\n  return\n}",
        "metrics": {
          "source_ppl": 2.71875,
          "base_ppl": 1.9375,
          "pr_ppl": 1.9375,
          "source_ast_ppl": 3.859375,
          "base_ast_ppl": 2.96875,
          "pr_ast_ppl": 2.96875,
          "delta_ppl": 0.0
        },
        "llm_qualitative": {
          "motivation": "Candidate B, while not perfectly semantically equivalent, uses clear control flow and standard C constructs like for loops, making it significantly easier to understand than Candidate A's complex nested logic.",
          "winner": "PR"
        },
        "llm_ast": {
          "winner": "PR",
          "motivation": "BASE and PR AST are identical; no differences to evaluate."
        }
      }
    ]
  }
}